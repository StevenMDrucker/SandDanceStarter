//---- ChartEngine.js (merges: mat4x.js, hammer-204.min.js, VuePlotCore.js, beachPartyShape.js, beachPartyChart.js) ---- 
// 
///-----------------------------------------------------------------------------------------------------------------
// arrayHelpers.ts.  Copyright (c) 2016 Microsoft Corporation.
//     - part of VuePlotCore library.
///-----------------------------------------------------------------------------------------------------------------
"use strict";
//---- note: these are "this" functions - assumes "this" is the array pointer ----
var vp;
(function (vp) {
    /// colName is optional; if specified, array entires will be treated as records and colName will be used a key
    /// to extract the value to be summed.  If not specified, array entries will be treated like numbers and averaged directly.
    function arrayAvg(colNameOrCallback) {
        var total = 0;
        var count = 0;
        if (vp.utils.isFunction(colNameOrCallback)) {
            for (var i = 0; i < this.length; i++) {
                var value = this[i];
                value = colNameOrCallback(value, i);
                value = parseFloat(value);
                if (isFinite(value)) {
                    total += value;
                    count++;
                }
            }
        }
        else if (vp.utils.isString(colNameOrCallback)) {
            var colName = colNameOrCallback;
            for (var i = 0; i < this.length; i++) {
                var value = this[i][colName];
                value = parseFloat(value);
                if (isFinite(value)) {
                    total += value;
                    count++;
                }
            }
        }
        else {
            for (var i = 0; i < this.length; i++) {
                var value = this[i];
                value = parseFloat(value);
                if (isFinite(value)) {
                    total += value;
                    count++;
                }
            }
        }
        var avg = (count) ? total / count : 0;
        return avg;
    }
    /// colName is optional; if specified, array entires will be treated as records and colName will be used a key
    /// to extract the value to be summed.  If not specified, array entries will be treated like numbers and counted directly.
    function arrayCount(colNameOrCallback) {
        var count = 0;
        if (vp.utils.isFunction(colNameOrCallback)) {
            //---- CALLBACK specified - return value must return fuzzy TRUE to be counted ----
            for (var i = 0; i < this.length; i++) {
                var value = this[i];
                value = colNameOrCallback(value, i);
                if (+value) {
                    count++;
                }
            }
        }
        else if (vp.utils.isString(colNameOrCallback)) {
            //---- COLUMN NAME specified - count all defined values of the column ----
            var colName = colNameOrCallback;
            for (var i = 0; i < this.length; i++) {
                var value = this[i][colName];
                if (value !== undefined) {
                    count++;
                }
            }
        }
        else {
            //---- count all defined value ----
            for (var i = 0; i < this.length; i++) {
                var value = this[i];
                if (value !== undefined) {
                    count++;
                }
            }
        }
        return count;
    }
    /// colName is optional; if specified, array entires will be treated as records and colName will be used a key
    /// to extract the value to be summed.  If not specified, array entries will be treated like numbers and summed directly.
    function arraySum(colNameOrCallback) {
        var total = 0;
        if (vp.utils.isFunction(colNameOrCallback)) {
            for (var i = 0; i < this.length; i++) {
                var value = this[i];
                value = colNameOrCallback(value, i);
                value = parseFloat(value);
                if (isFinite(value)) {
                    total += value;
                }
            }
        }
        else if (vp.utils.isString(colNameOrCallback)) {
            var colName = colNameOrCallback;
            for (var i = 0; i < this.length; i++) {
                var value = this[i][colName];
                value = parseFloat(value);
                if (isFinite(value)) {
                    total += value;
                }
            }
        }
        else {
            for (var i = 0; i < this.length; i++) {
                var value = this[i];
                value = parseFloat(value);
                if (isFinite(value)) {
                    total += value;
                }
            }
        }
        return total;
    }
    /// signature:  arraySelect(func)
    ///     summary: creates a new array by calling the specified function with each element of the array
    ///     paramType(func): function
    ///     snippet: var aray = [3, 5, 2, 1];
    ///     snippet: var newAray = arraySelect(aray, function(n) { return 10*n; });  // newAray will be: [30, 50, 20, 10]
    ///     returns: the new array
    function arraySelect(selectFunc) {
        if (!vp.utils.isFunction(selectFunc)) {
            throw new TypeError();
        }
        //var startTime = new Date().getTime();
        var newValues = Array(this.length);
        for (var i = 0; i < this.length; i++) {
            var elem = this[i];
            var value = selectFunc(elem, i);
            newValues[i] = value;
        }
        //var elapsedMs = new Date().getTime() - startTime;
        return newValues;
    }
    var maxStackSize = 75 * 1000; // 125,000 gives "out of stack space" on IE11
    /// signature:  arrayMin(aray)
    ///     summary: returns the item in the array with the smallest value
    ///     snippet: var aray = [3, 5, 2, 1];
    ///     snippet: var myMax = arrayMin(aray);        // myMax will be set to 1.
    ///     returns: the item in the array with the smallest value
    /// signature: arrayMin(func)
    ///     summary: returns the item in the array for which calling func produces the smallest value
    ///     paramType(func): function
    ///     snippet: var aray = [-5, 3, 0, 3];
    ///     snippet: var myMax = arrayMin(Math.abs);        // myMax will be set to 0
    ///     returns: the item in the array for which calling func produces the smallest value
    function arrayMin(itemFunc, includeNans) {
        //var startTime = new Date().getTime();
        var mm = Number.MAX_VALUE;
        if (vp.utils.isFunction(itemFunc)) {
            for (var i = 0; i < this.length; i++) {
                var value = itemFunc(this[i]);
                if (!includeNans && isNaN(value)) {
                    continue;
                }
                // the below code is 2x faster than: mm = Math.max(mm, aray[i]);
                if (value < mm) {
                    mm = value;
                }
            }
        }
        else {
            //---- this top code is about 10x as fast as the botoom, but crashes with length around 150K ----
            if (includeNans && this.length <= maxStackSize) {
                mm = Math.min.apply(Math, this);
            }
            else {
                for (var i = 0; i < this.length; i++) {
                    if (!includeNans && isNaN(this[i])) {
                        continue;
                    }
                    // the below code is 2x faster than: mm = Math.min(mm, aray[i]);
                    if (this[i] < mm) {
                        mm = this[i];
                    }
                }
            }
        }
        //var elapsedMs = new Date().getTime() - startTime;
        return mm;
    }
    function arrayMax(itemFunc, includeNans) {
        //var startTime = new Date().getTime();
        var mm = -Number.MAX_VALUE; // do NOT use Number.MIN_VALUE 
        if (vp.utils.isFunction(itemFunc)) {
            for (var i = 0; i < this.length; i++) {
                var value = itemFunc(this[i]);
                if (!includeNans && isNaN(value)) {
                    continue;
                }
                // the below code is 2x faster than: mm = Math.max(mm, aray[i]);
                if (value > mm) {
                    mm = value;
                }
            }
        }
        else {
            //---- this top code is about 10x as fast as the botoom, but crashes with length around 150K ----
            if (includeNans && this.length <= maxStackSize) {
                mm = Math.max.apply(Math, this);
            }
            else {
                for (var i = 0; i < this.length; i++) {
                    if (!includeNans && isNaN(this[i])) {
                        continue;
                    }
                    // the below code is 2x faster than: mm = Math.max(mm, aray[i]);
                    if (this[i] > mm) {
                        mm = this[i];
                    }
                }
            }
        }
        //var elapsedMs = new Date().getTime() - startTime;
        return mm;
    }
    /// this function groups data by 1 or more grouping columns or callback functions.  returns an 
    /// array of records:  { key: keyValue, values: recordArray }
    function arrayGroupBy() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        var groupObj = {};
        //---- build fast test of callback functions (vs. col names) ----
        var callbacks = [];
        for (var k = 0; k < args.length; k++) {
            var colNameOrFunc = args[k];
            if (vp.utils.isFunction(colNameOrFunc)) {
                callbacks[k] = colNameOrFunc;
            }
        }
        //---- group the records by the specified colNames ----
        for (var i = 0; i < this.length; i++) {
            var record = this[i];
            var key = "";
            if (args.length > 0) {
                //---- build key for this record ----
                for (var k = 0; k < args.length; k++) {
                    var colName = args[k];
                    if (k > 0) {
                        key += "^";
                    }
                    if (callbacks[k]) {
                        key += callbacks[k](record);
                    }
                    else {
                        key += record[colName];
                    }
                }
            }
            else {
                //---- no keys specified - assume this is a vector of values & group by simliar values ----
                //---- watch out for undefined, NULL, NaN, etc. ----
                key = (record) ? record.toString() : record;
            }
            var list = groupObj[key];
            if (list === undefined || !vp.utils.isArray(list)) {
                list = [];
                groupObj[key] = list;
            }
            list.push(record);
        }
        //---- now build list of groups to return ----
        var groups = [];
        for (var key2 in groupObj) {
            var list = groupObj[key2];
            var group = { key: key2, values: list };
            groups.push(group);
        }
        return groups;
    }
    /// return a copy of the specified array (contains references to same elements).
    /// this works true arrays and objects like Int32Array.
    function arrayClone() {
        var newAray = null;
        if (this) {
            if (this.slice) {
                newAray = this.slice(0);
            }
            else {
                newAray = [];
                for (var i = 0; i < this.length; i++) {
                    newAray[i] = this[i];
                }
            }
        }
        return newAray;
    }
    function arrayTake(count) {
        var newArray = this.slice(0, count);
        return newArray;
    }
    //---- copy current true or pseudo array to new array ----
    function arrayToArray() {
        if (this.slice) {
            var newArray = this.slice(0, this.length);
        }
        else {
            var newArray = [];
            for (var i = 0; i < this.length; i++) {
                newArray[i] = this[i];
            }
        }
        return newArray;
    }
    /// signature:  arrayRemove(item)
    ///     summary:    removes the specified item from the array.
    ///     paramType(item): object
    ///     snippet:    var aray = [3, 4, 5, 6];
    ///     snippet:    arrayRemove(aray, 6);         // aray should now contain [3, 4, 5]
    ///     returns:    null.
    function arrayRemove(elem) {
        var index = this.indexOf(elem);
        if (index > -1) {
            this.splice(index, 1);
        }
    }
    /// signature:  arrayRemoveAt(index)
    ///     summary:    removes the item at the specified index from the array.
    ///     paramType(index): integer number
    ///     snippet:    var aray = [3, 4, 5, 6];
    ///     snippet:    arrayRemoveAt(aray, 0);         // aray should now contain [4, 5, 6]
    ///     returns:    null.
    function arrayRemoveAt(index) {
        if (index > -1) {
            this.splice(index, 1);
        }
    }
    function arrayInsert(index, value) {
        if (index > -1) {
            this.splice(index, 0, value);
        }
    }
    /// signature:  arrayWhere(func)
    ///     summary: creates a new array by only including elements of the current array that return true for the specified function
    ///     paramType(func): function
    ///     snippet: var aray = [3, 5, 2, 1];
    ///     snippet: var newAray = arrayWhere(aray, function(n) { return n >= 3; });  // newAray will be: [3, 5]
    ///     returns: the new array
    ///
    /// "arrayWhere" uses the callback function to conditionally include each record of the array 
    /// in the output stream.  One of our lightweight linq functions.
    function arrayWhere(whereFunc) {
        //var startTime = new Date().getTime();
        var newValues = [];
        for (var i = 0; i < this.length; i++) {
            var value = this[i];
            if (whereFunc(value, i)) {
                newValues.push(value);
            }
        }
        //var elapsedMs = new Date().getTime() - startTime;
        return newValues;
    }
    /// signature:  arar.orderByNum()
    ///     summary: creates a copy of the current array with the items sorted in increasing numeric value
    ///     snippet: var aray = [3, 5, 2, 1];
    ///     snippet: var newAray = aray.orderByNum();     // newAray will be: [1, 2, 3, 5]
    ///     returns: the new array
    /// signature:  aray.orderByNum(func)
    ///     summary: creates a copy of the current array with the items sorted in increasing numeric value, using value returned from calling "func"
    ///     paramType(func): function
    ///     snippet: var aray = [-3, 5, -2, 1];
    ///     snippet: var newAray = aray.orderByNum(Math.abs);     // newAray will be: [1, 2, 3, 5]
    ///     returns: the new array
    ///
    /// "orderByNum" uses the callback function to produce a key for each record in the 
    /// array so the array can be sorted.  One of the VuePlotCore lightweight linq functions.
    function arrayOrderByNum(keyFunc) {
        //var startTime = new Date().getTime();
        var newValues = this.slice(0); // copy array
        if (keyFunc === undefined) {
            //---- JavaScript default: alphabetic, ascending sort ----
            newValues.sort(function (a, b) { return (+a) - (+b); });
        }
        else {
            newValues.sort(function (a, b) {
                var ka = keyFunc(a);
                var kb = keyFunc(b);
                return (+ka) - (+kb);
            });
        }
        //var elapsedMs = new Date().getTime() - startTime;
        return newValues;
    }
    /// signature:  arar.orderByStr()
    ///
    /// "orderByStr" uses the optional callback function to produce a key for each record in the 
    /// array so the array can be sorted by string values.  One of our lightweight linq functions.
    function arrayOrderByStr(keyFunc) {
        //var startTime = new Date().getTime();
        var newValues = this.slice(0); // copy array
        if (keyFunc === undefined) {
            //---- JavaScript default: alphabetic, ascending sort ----
            newValues.sort();
        }
        else {
            newValues.sort(function (a, b) {
                var ka = keyFunc(a) + "";
                var kb = keyFunc(b) + "";
                //---- this works for strings and numbers ----
                return (ka > kb) ? 1 : ((ka == kb) ? 0 : -1);
            });
        }
        //var elapsedMs = new Date().getTime() - startTime;
        return newValues;
    }
    function memberArrayEquals(a2) {
        var eq = false;
        if (a2) {
            var eq = (this.length == a2.length);
            if (eq) {
                for (var i = 0; i < this.length; i++) {
                    if (this[i] != a2[i]) {
                        eq = false;
                        break;
                    }
                }
            }
        }
        return eq;
    }
    function arrayEquals(a1, a2) {
        var eq = true;
        if ((!a1) || (!a2)) {
            eq = (!a1) && (!a2);
        }
        else {
            eq = (a1.length == a2.length);
            if (eq) {
                for (var i = 0; i < a1.length; i++) {
                    if (a1[i] != a2[i]) {
                        eq = false;
                        break;
                    }
                }
            }
        }
        return eq;
    }
    vp.arrayEquals = arrayEquals;
    /// signature:  arrayDistinct()
    ///     summary: creates a copy of the current array with duplicated items removed
    ///     snippet: var aray = [3, 5, 3, 1];
    ///     snippet: var newAray = arrayDistinct(aray);     // newAray will be: [3, 5, 1]
    ///     returns: the new array
    /// signature:  arrayDistinct(func)
    ///     summary: creates a copy of the current array with items that produce duplicates values (when calling func) removed
    ///     paramType(func): function
    ///     snippet: var aray = [-3, 5, 3, 1];
    ///     snippet: var newAray = arrayDistinct(aray);     // newAray will be: [-3, 5, 1]
    ///     returns: the new array
    ///
    /// "distinct" returns the values in the array with duplicates removed, based on the values 
    /// returned for each array entry by the idFunc.
    function arrayDistinct(idFunc) {
        var dict = {};
        var newValues = [];
        for (var i = 0; i < this.length; i++) {
            var value = this[i];
            var id = (idFunc) ? idFunc(value) : value;
            if (!dict.hasOwnProperty(id)) {
                //---- its unique; add it ----
                dict[id] = 1;
                newValues.push(this[i]);
            }
        }
        return newValues;
    }
    function arrayGenerate(root, tagName, callBack) {
        var ss = null;
        var ss = vp.data.generateItems(root, tagName, this);
        if (callBack) {
            //---- for best perf, share one singleWrapper to wrap all objects ----
            var wrapper = vp.dom.createSingleWrapper(null);
            for (var i = 0; i < this.length; i++) {
                var dataItem = this[i];
                wrapper.elem = ss[i];
                wrapper[0] = ss[i];
                callBack(wrapper, dataItem, i);
            }
        }
        return ss;
    }
    /// this function coverts a dataset in "wide" format to "long" format.
    ///     - "wide" format is where each attribute is in its own column.
    ///     - "long" format is where all non-id attributes are represents in 2 columns: "attribute", "value".
    ///
    /// parameters: list of id columns (those that are preserved).  Other columns are transformed into name/value columns
    function arrayWideToLong(col1) {
        var records = [];
        if (this.length > 0) {
            //---- build list of OTHER columns ----
            var others = [];
            var curr = this[0];
            var preserved = vp.utils.argumentsAsArray(arguments);
            for (var cn in curr) {
                if (preserved.indexOf(cn) == -1) {
                    others.push(cn);
                }
            }
            //---- process each INPUT record ----
            for (var i = 0; i < this.length; i++) {
                var curr = this[i]; // input record
                //---- create an output record for each OTHER column ----
                for (var j = 0; j < others.length; j++) {
                    var other = others[j];
                    var record = {}; // output record
                    //---- transfer preserved columns ----
                    for (var a = 0; a < preserved.length; a++) {
                        var colName = preserved[a];
                        record[colName] = curr[colName];
                    }
                    //---- transfer OTHER column ----
                    record.attribute = other;
                    record.value = curr[other];
                    records.push(record);
                }
            }
        }
        return records;
    }
    /// this function coverts a dataset in "long" format to "wide" format.
    ///     - "wide" format is where each attribute is in its own column.
    ///     - "long" format is where all non-id attributes are represents in 2 columns: "attribute", "value".
    ///
    /// parameters: 
    ///     - array of id columns (to define a change in the logical record)
    ///     - attributeColName
    ///     - valueColName
    function arrayLongToWide(idColList, attributeColName, valueColName) {
        var records = [];
        if (this.length > 0) {
            //---- emit an OUTPUT record whenever the key changes or an attribute repeats ----
            var record = {};
            var newRecord = true;
            for (var i = 0; i < this.length; i++) {
                var curr = this[i];
                var changed = false;
                //---- has a column in id changed? ----
                for (var a = 0; a < idColList.length; a++) {
                    var colName = idColList[a];
                    if (curr[colName] != record[colName]) {
                        changed = true;
                        break;
                    }
                }
                //---- have this record seen this attribue before? ----
                var attrName = curr.attribute;
                if (record[attrName]) {
                    changed = true;
                }
                if (changed) {
                    if (i > 0) {
                        //---- output previous record ----
                        records.push(record);
                    }
                    record = {};
                    newRecord = true;
                }
                if (newRecord) {
                    //---- transfer id columns to new record ----
                    for (var a = 0; a < idColList.length; a++) {
                        var colName = idColList[a];
                        record[colName] = curr[colName];
                    }
                    newRecord = false;
                }
                //---- transfer name/value pairs from this record ----
                record[attrName] = curr.value;
            }
            //---- add last record ----
            records.push(record);
        }
        return records;
    }
    /// arrayReorder:  build a new array consisting of "partialValuesInOrder" and then any remaining values in "aray".
    function arrayReorder(partialValuesInOrder) {
        var outAray = [];
        var aray = this.clone();
        //---- add ordered keys ----
        for (var i = 0; i < partialValuesInOrder.length; i++) {
            var value = partialValuesInOrder[i];
            outAray.push(value);
            aray.remove(value);
        }
        //---- add remaining keys ----
        outAray = outAray.concat(aray);
        return outAray;
    }
    /// arrayRemoveValues:  return a new array consisting of elements of "arayOrig" when "values" are removed.
    function arrayRemoveValues(values) {
        var outAray = [];
        var aray = this.clone();
        //---- remove specified values ----
        for (var i = 0; i < values.length; i++) {
            var value = values[i];
            aray.remove(value);
        }
        return aray;
    }
    //---- safely extend Array and Float32Array functions (so that are NOT enumerable) ----
    //---- we extend array with each helper function using this method, so our help functions won't show up during a "for in" operation ----
    function extendArray(helperName, helperFunc, extend) {
        if (extend && Array.prototype[helperName] === undefined) {
            Object.defineProperty(Array.prototype, helperName, { configurable: true, enumerable: false, value: helperFunc });
        }
        else if (!extend) {
            //Object.defineProperty(Array.prototype, helperName, { enumerable: false, value: null });
            if (!delete Array.prototype[helperName]) {
                vp.utils.debug("*** Cannot delete: Array.prototype." + helperName);
            }
        }
        if (extend && Float32Array.prototype[helperName] === undefined) {
            Object.defineProperty(Float32Array.prototype, helperName, { configurable: true, enumerable: false, value: helperFunc });
        }
        else if (!extend) {
            //Object.defineProperty(Float32Array.prototype, helperName, { enumerable: false, value: null });
            if (!delete Array.prototype[helperName]) {
                vp.utils.error("*** Cannot delete: Float32Array.prototype." + helperName);
            }
        }
    }
    function extendArrayWithHelpers(value) {
        extendArray("avg", arrayAvg, value);
        extendArray("count", arrayCount, value);
        extendArray("distinct", arrayDistinct, value);
        extendArray("equals", memberArrayEquals, value);
        extendArray("generate", arrayGenerate, value);
        extendArray("groupBy", arrayGroupBy, value);
        extendArray("max", arrayMax, value);
        extendArray("min", arrayMin, value);
        extendArray("orderByNum", arrayOrderByNum, value);
        extendArray("orderByStr", arrayOrderByStr, value);
        extendArray("remove", arrayRemove, value);
        extendArray("removeAt", arrayRemoveAt, value);
        extendArray("sum", arraySum, value);
        extendArray("take", arrayTake, value);
        extendArray("toArray", arrayToArray, value);
        extendArray("insert", arrayInsert, value);
        extendArray("where", arrayWhere, value);
    }
    vp.extendArrayWithHelpers = extendArrayWithHelpers;
    //---- start up code: add our array helper functions ----
    extendArrayWithHelpers(true);
})(vp || (vp = {}));
var vp;
(function (vp) {
    var unitTests;
    (function (unitTests) {
        //---- add "export" to include this test ----
        function testArrayFuncs() {
            vp.utils.debug("running: testArrayFuncs");
            var count = [3, 5, "abc", new Date(), "45px"].count();
            vp.utils.debug("  [4] count=" + count);
            var sum = [3, 5, "abc", new Date(), "45px"].sum();
            vp.utils.debug("  [53] sum=" + sum);
            var avg = [3, 5, "abc", new Date(), "45px"].avg();
            vp.utils.debug("  [17.667] avg=" + avg);
        }
    })(unitTests = vp.unitTests || (vp.unitTests = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// hsl.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - part of the VuePlotCore library.
///     - a class that represents a color in HSL (hue, saturation, luminance) color space.
///-----------------------------------------------------------------------------------------------------------------
// Specifies an HSLA color value (stored as int + 3 floats).  Designed to support HSL color values as specified
/// for SVG.  Adapted from: http://www.w3.org/TR/css3-color/#hsl-color.  The SVG order is Hsla for creation.
/// 
/// CTR should accept 5 forms: 
///     - hsl (3-4 floats)    
///     - rgb (3-4 floats)
///     
/// Should provide 2 ToXXX() functions:
///     - toRgb()
///     - toString()
///     
/// Should provide 4 public READONLY properties:
///     - var hue
///     - var saturation
///     - var lightness
///     - var alpha
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    var color;
    (function (color) {
        var hsl = (function () {
            function hsl(hue, saturation, lightness, alpha) {
                this._hue = hue;
                this._saturation = saturation;
                this._lightness = lightness;
                //---- init code ----
                this._alpha = (alpha === undefined) ? 1 : alpha;
            }
            /// public: toRgb()
            hsl.prototype.toRgb = function () {
                var rgb = vp.color.rgbFromHsl(this);
                return rgb;
            };
            hsl.prototype.toString = function () {
                return "{H: " + this._hue + ", S: " + this._saturation + ", L: " + this._lightness + ", A: " + this._alpha + "}";
            };
            hsl.prototype.lighten = function () {
                var light = Math.min(1, this._lightness + .13);
                return new vp.color.hsl(this._hue, this._saturation, light, this._alpha);
            };
            hsl.prototype.darken = function () {
                var light = Math.max(0, this._lightness - .13);
                return new vp.color.hsl(this._hue, this._saturation, light, this._alpha);
            };
            /// public: hue
            hsl.prototype.hue = function () {
                return this._hue;
            };
            /// public: saturation
            hsl.prototype.saturation = function () {
                return this._saturation;
            };
            /// public: lightness
            hsl.prototype.lightness = function () {
                return this._lightness;
            };
            /// public: alpha
            hsl.prototype.alpha = function () {
                return this._alpha;
            };
            hsl.prototype.adjustHue = function (factor) {
                var hue = this._hue * factor;
                return new hsl(hue, this._saturation, this._lightness, this._alpha);
            };
            hsl.prototype.adjustSaturation = function (factor) {
                var sat = this._saturation * factor;
                return new hsl(this._hue, sat, this._lightness, this._alpha);
            };
            hsl.prototype.adjustValue = function (factor) {
                var lightness = this._lightness * factor;
                return new hsl(this._hue, this._saturation, lightness, this._alpha);
            };
            return hsl;
        }());
        color.hsl = hsl;
        /// static public: vp.color.hslFromRgb()
        /// "rgb" should be a 3 or 4 element array of numbers, each 0-255.
        function hslFromRgb(rgb) {
            if (vp.utils.isString(rgb)) {
                rgb = vp.color.getColorFromString(rgb);
            }
            //---- convert RGB to HSL ----
            ///
            /// adapted from: http://130.113.54.154/~monger/hsl-rgb.html
            /// 
            var r = rgb[0] / 255; // convert to unit numbers
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var alpha = (rgb.length > 3) ? rgb[3] / 255 : 1;
            var min = Math.min(r, Math.min(g, b));
            var max = Math.max(r, Math.max(g, b));
            var lightness = (max + min) / 2;
            var saturation = 0;
            var hue = 0;
            if (max == min) {
                //---- some shade of gray ----
                saturation = 0;
                hue = 0; // actually undefined, but this is usual way to handle
            }
            else {
                if (lightness < .5) {
                    saturation = (max - min) / (max + min);
                }
                else {
                    saturation = (max - min) / (2 - max - min);
                }
                if (r == max) {
                    hue = (g - b) / (max - min);
                }
                else if (g == max) {
                    hue = 2 + (b - r) / (max - min);
                }
                else {
                    hue = 4 + (r - g) / (max - min);
                }
                //---- hue should now be in range 0..6 ----
                hue *= 60;
                if (hue < 0) {
                    hue += 360;
                }
                hue /= 360; // convert to a percentage
            }
            return new vp.color.hsl(hue, saturation, lightness, 1);
        }
        color.hslFromRgb = hslFromRgb;
        /// static public: vp.color.rgbFromHsl()
        function rgbFromHsl(hsl) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (arguments.length == 3) {
                hsl = new vp.color.hsl(arguments[0], arguments[1], arguments[2]);
            }
            //---- HSL to RGB Conversion----
            ///
            /// adapted from: http://www.w3.org/TR/2003/CR-css3-color-20030514/
            /// 
            var m2 = 0;
            var ll = hsl.lightness();
            var s = hsl.saturation();
            var hue = hsl.hue();
            if (ll <= .5) {
                m2 = ll * (s + 1);
            }
            else {
                m2 = ll + s - ll * s;
            }
            var m1 = ll * 2 - m2;
            var red = vp.color.hueToRgb(m1, m2, hue + 1 / 3);
            var green = vp.color.hueToRgb(m1, m2, hue);
            var blue = vp.color.hueToRgb(m1, m2, hue - 1 / 3);
            //---- we represent RGB values as 3-4 element numeric arrays ----
            var r = vp.data.clamp(Math.round(red * 255), 0, 255);
            var g = vp.data.clamp(Math.round(green * 255), 0, 255);
            var b = vp.data.clamp(Math.round(blue * 255), 0, 255);
            var a = vp.data.clamp(Math.round(hsl.alpha() * 255), 0, 255);
            return [r, g, b, a];
        }
        color.rgbFromHsl = rgbFromHsl;
        function hueToRgb(m1, m2, h) {
            if (h < 0) {
                h = h + 1;
            }
            if (h > 1) {
                h = h - 1;
            }
            if (h * 6 < 1) {
                return m1 + (m2 - m1) * h * 6;
            }
            if (h * 2 < 1) {
                return m2;
            }
            if (h * 3 < 2) {
                return m1 + (m2 - m1) * (2 / 3 - h) * 6;
            }
            return m1;
        }
        color.hueToRgb = hueToRgb;
        function normalizeHue(value) {
            if (value < 0) {
                value = 1 + value;
            }
            else if (value > 1) {
                value = value - 1;
            }
            value = vp.data.clamp(value, 0, 1);
            value = Math.floor(value) - value; // just fractional part
            value = Math.abs(value);
            return value;
        }
        color.normalizeHue = normalizeHue;
    })(color = vp.color || (vp.color = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// mathHelpers.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - part of VuePlotCore library.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    function mathLog10(arg) {
        var result = Math.log(arg) / Math.LN10;
        return result;
    }
    function mathLog2(arg) {
        var result = Math.log(arg) / Math.LN2;
        return result;
    }
    ////---- safely extend MATH functions (so that are NOT enumerable) ----
    ////---- we extend Math with each helper function using this method, so our help functions won't show up during a "for in" operation ----
    //export function extendMath(helperName: string, helperFunc)
    //{
    //    if (Math..prototype[helperName] === undefined)
    //    {
    //        Object.defineProperty(Math.prototype, helperName, { enumerable: false, value: helperFunc });
    //    }
    //}
    //---- just directly add the static methods ----
    if (Math.log10 === undefined) {
        Math.log10 = mathLog10;
    }
    if (Math.log2 === undefined) {
        Math.log2 = mathLog2;
    }
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// scanner.ts.  Copyright (c) 2016 Microsoft Corporation.
///            part of the vuePlot library - general purpose text scanner class
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var utils;
    (function (utils) {
        //---- enum: TokenType ----
        (function (TokenType) {
            TokenType[TokenType["none"] = 0] = "none";
            TokenType[TokenType["operator"] = 1] = "operator";
            TokenType[TokenType["id"] = 2] = "id";
            TokenType[TokenType["string"] = 3] = "string";
            TokenType[TokenType["number"] = 4] = "number";
            TokenType[TokenType["comment"] = 5] = "comment";
            TokenType[TokenType["newLine"] = 6] = "newLine";
            TokenType[TokenType["space"] = 7] = "space";
            TokenType[TokenType["eof"] = 8] = "eof";
        })(utils.TokenType || (utils.TokenType = {}));
        var TokenType = utils.TokenType;
        //---- class: scanner ----
        var scannerClass = (function () {
            function scannerClass(str) {
                //---- private state ----
                this._index = 0;
                this._tokenType = TokenType.none;
                this._token = "";
                this._spacesSkipped = 0;
                this._str = "";
                this._recognizeComments = true;
                this.init(str);
            }
            scannerClass.prototype.init = function (str) {
                this._str = str;
                this._index = 0;
                this._tokenType = TokenType.none;
                this._token = "";
            };
            /// public readonly: this._tokenType
            scannerClass.prototype.tokenType = function () {
                return this._tokenType;
            };
            scannerClass.prototype.spacesSkipped = function () {
                return (this._spacesSkipped > 0);
            };
            /// public readonly: this._token
            scannerClass.prototype.token = function () {
                return this._token;
            };
            scannerClass.prototype.restOfCmd = function () {
                return this._str.substr(this._index);
            };
            scannerClass.prototype.isStartOfNum = function (str, ch, index) {
                var isNum = ((ch >= '0') && (ch <= '9')) || (ch == "-");
                if (!isNum) {
                    if ((ch == ".") && (index + 1 < str.length)) {
                        var ch = str[index + 1];
                        isNum = ((ch >= '0') && (ch <= '9'));
                    }
                }
                return isNum;
            };
            scannerClass.prototype.getIdToken = function (str, ch, index) {
                function isDigit(ch) {
                    return (ch >= '0' && ch <= '9');
                }
                function isLetter(ch) {
                    var low = ch.toLowerCase();
                    return (low >= 'a' && low <= 'z');
                }
                /// is this an ID? ID for this scanner can start with digit, letter, or "_" and
                /// contain digit, letter, or "_".  If it starts with a digit, it must contain
                /// at least 1 letter or 1 "_" (otherwise it is a number).
                var startIndex = index;
                var startsWidhNum = isDigit(ch);
                var foundNonNum = false;
                var gotToken = false;
                if (isDigit(ch) || isLetter(ch) || ch == "_") {
                    index++;
                    //---- find end of token ----
                    while (index <= str.length - 1) {
                        ch = str[index];
                        if (isLetter(ch) || ch == "_") {
                            foundNonNum = true;
                        }
                        else if (!isDigit(ch)) {
                            break;
                        }
                        index++;
                    }
                    if (!startsWidhNum || foundNonNum) {
                        this._token = str.substr(startIndex, index - startIndex);
                        this._index = index;
                        gotToken = true;
                    }
                }
                return gotToken;
            };
            scannerClass.prototype.isDigitChar = function (ch, isFirst) {
                var isDigit = ((ch >= "0") && (ch <= "9"));
                isDigit = isDigit || (ch == ".");
                return isDigit;
            };
            /// public: scan()
            scannerClass.prototype.scan = function () {
                this._spacesSkipped = 0;
                this._token = "";
                //---- skip spaces ----
                //---- note: "160" is the ISO 8859-1 char code for "non breaking space" ----
                while ((this._index < this._str.length) && ((this._str[this._index] == " ") || (this._str[this._index] == "\t") || (this._str[this._index].charCodeAt(0) == 160))) {
                    this._index++;
                    this._spacesSkipped++;
                }
                if (this._index >= this._str.length) {
                    this._tokenType = TokenType.eof;
                }
                else {
                    var ch = this._str[this._index];
                    if (ch == "\n") {
                        //---- NEWLINE ----
                        this._index++;
                        this._tokenType = TokenType.newLine;
                    }
                    else if (this._recognizeComments && (this._index < this._str.length - 1) && (this._str[this._index] == "/") && (this._str[this._index + 1] == "/")) {
                        //---- END-OF-LINE COMMENT ----
                        var start = this._index;
                        this._index += 2;
                        while ((this._index < this._str.length) && (this._str[this._index] != "\n")) {
                            this._index++;
                        }
                        this._token = this._str.substring(start, this._index);
                        this._tokenType = TokenType.comment;
                    }
                    else if (this._recognizeComments && (this._index < this._str.length - 1) && (this._str[this._index] == "/") && (this._str[this._index + 1] == "*")) {
                        //---- IN-PLACE COMMENT ----
                        var start = this._index;
                        this._index += 2;
                        while (this._index < this._str.length - 1) {
                            if (this._str[this._index] == "*" && this._str[this._index + 1] == "/") {
                                this._token = this._str.substring(start, this._index);
                                this._tokenType = TokenType.comment;
                                this._index += 2;
                                break;
                            }
                            this._index++;
                        }
                        this._token = this._str.substring(start, this._index);
                        this._tokenType = TokenType.comment;
                    }
                    else if ((ch == "\"") || (ch == "\'")) {
                        //---- STRING ----
                        var quote = this._str[this._index];
                        var start = this._index;
                        this._index++;
                        while ((this._index < this._str.length) && (this._str[this._index] != quote) && (this._str[this._index] != "\n")) {
                            this._index++;
                        }
                        //---- skip over ending quote ----
                        if ((this._index < this._str.length) && (this._str[this._index] == quote)) {
                            this._index++;
                        }
                        this._token = this._str.substring(start, this._index);
                        this._tokenType = TokenType.string;
                    }
                    else if (this.getIdToken(this._str, ch, this._index)) {
                        this._tokenType = TokenType.id;
                    }
                    else if (this.isStartOfNum(this._str, ch, this._index)) {
                        //---- NUMBER ----
                        var start = this._index;
                        this._index++;
                        while ((this._index < this._str.length) && (this.isDigitChar(this._str[this._index], false))) {
                            this._index++;
                        }
                        //---- see if there is a factional part ----
                        if ((this._index < this._str.length) && (this._str[this._index] == '.')) {
                            this._index++;
                            while ((this._index < this._str.length) && ((this._str[this._index] >= '0') && (this._str[this._index] <= '9'))) {
                                this._index++;
                            }
                        }
                        this._token = this._str.substring(start, this._index);
                        this._tokenType = TokenType.number;
                    }
                    else {
                        //---- OPERATOR ----
                        ///     operators: +, -, *, /, (), ++, --, <, <=, >, >=, ==, !=, =, +=, -=, *=, /=, ?:, [], !, 
                        ///         ., &&, ||
                        this._token = this._str[this._index];
                        this._index++;
                        var t2 = (this._index < this._str.length) ? (this._token + this._str[this._index]) : "";
                        //---- look for double char operator ----
                        if ((t2 == "()") || (t2 == "++") || (t2 == "--") || (t2 == "<=") || (t2 == ">=") ||
                            (t2 == "==") || (t2 == "!=") || (t2 == "<>") || (t2 == "+=") || (t2 == "-=") || (t2 == "*=") ||
                            (t2 == "/=") || (t2 == "&&") || (t2 == "||")) {
                            this._token = t2;
                            this._index++;
                        }
                        this._tokenType = TokenType.operator;
                    }
                }
                this._index = this._index; // update our class field
                return this._tokenType;
            };
            return scannerClass;
        }());
        utils.scannerClass = scannerClass;
    })(utils = vp.utils || (vp.utils = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// string.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - part of VuePlotCore library.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    /// signature:  stringStartsWith(prefix)
    ///     summary: returns true if the string starts with the specified prefix
    ///     paramType(prefix): string
    ///     snippet: var name = "Dr. Smith";
    ///     snippet: var isDoctor = stringStartsWith(name, "Dr. ");        // isDoctor will be true
    ///     returns: true if the string starts with the prefix; false otherwise
    function stringStartsWith(prefix) {
        var found = false;
        if (this.substr(0, prefix.length) == prefix) {
            found = true;
        }
        return found;
    }
    /// signature:  stringEndsWith(suffix)
    ///     summary: returns true if the string ends with the specified suffix
    ///     paramType(suffix): string
    ///     snippet: var animal = "cats";
    ///     snippet: var isPlural = stringEndsWith(animal, "s");        // isPlural will be true
    ///     returns: true if the string ends with the suffix; false otherwise
    function stringEndsWith(suffix) {
        var found = false;
        if (this.substr(this.length - suffix.length, suffix.length) == suffix) {
            found = true;
        }
        return found;
    }
    /// signature:  stringLeftTrim()
    ///     summary: return the string with the leading spaces removed
    ///     snippet: var name = " cat ";
    ///     snippet: var newName = stringLeftTrim(name);       // newName will be "cat "
    ///     returns: returns the newly trimmed string
    function stringLeftTrim() {
        var value = this;
        if (value.length > 0) {
            var i = 0;
            while ((value[i] == ' ') || (value[i] == '\t')) {
                i++;
                if (i >= value.length) {
                    break;
                }
            }
            value = this.substring(i);
        }
        return value;
    }
    /// signature:  stringRightTrim()
    /// summary: return the string with the trailing spaces removed
    /// snippet: var name = " cat ";
    /// snippet: var newName = stringRightTrim(name);         // newName will be " cat"
    function stringRightTrim() {
        var value = this;
        if (value.length > 0) {
            var i = value.length - 1;
            while ((value[i] == ' ') || (value[i] == '\t')) {
                i--;
                if (i < 0) {
                    break;
                }
            }
            value = this.substring(0, i + 1);
        }
        return value;
    }
    /// signature:  stringContains(str)
    ///     summary: return true if the string contains the "str" substring
    ///     paramType(str): string
    ///     snippet: var animals = "dog, cat, rabbit";
    ///     snippet: var hasCat = stringContains(animals, "cat");         // hasCat will be true
    ///     returns: returns true if the string contains the substring; false otherwise
    function stringContains(substr) {
        var index = this.indexOf(substr);
        return index > -1;
    }
    ///** replaces all occurences of 'target' with 'replacement' in 'str'. */
    //export function stringReplace(target, replacement)
    //{
    //    str = str.replace(RegExp(target, "g"), replacement);
    //    return str;
    //}
    // Changes the first character of the supplied string to upper-case.
    function stringCapitalize() {
        if (!this || (this.length == 0)) {
            return this;
        }
        var capFirstChar = this[0].toUpperCase();
        return (capFirstChar + ((this.length > 1) ? this.substring(1) : ''));
    }
    //---- safely extend String functions (so that are NOT enumerable) ----
    //---- we extend String with each helper function using this method, so our help functions won't show up during a "for in" operation ----
    function extendString(helperName, helperFunc) {
        if (String.prototype[helperName] === undefined) {
            Object.defineProperty(String.prototype, helperName, { enumerable: false, value: helperFunc });
        }
    }
    //---- now add our string helper functions ----
    extendString("startsWith", stringStartsWith);
    extendString("endsWith", stringEndsWith);
    extendString("ltrim", stringLeftTrim);
    extendString("rtrim", stringRightTrim);
    extendString("contains", stringContains);
    //extendString("replace", stringReplace);
    extendString("capitalize", stringCapitalize);
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// animation.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library 
///-----------------------------------------------------------------------------------------------------------------
/// class: animation 
/// creates a set of animations for the specified "elem". 
///
/// "elem" is an UNWRAPPED HTML/SVG/Canvas elem.
/// "duration" is the time in milliseconds that the animation lasts.
/// "easeObj" is an optional object to control start and end easing.
/// "container" is an  optional animation container (which controls multiple animations).
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var animation;
    (function (animation) {
        var animationClass = (function () {
            function animationClass(elem, duration, easeObj, parentAnimation, delay) {
                //vp.utils.trace("ctr", "animation");
                this.ctr = "vp.animiation";
                //---- private state ----
                this._children = []; // animation objects for each obj/prop being animated
                this.elementsBeingAnimated = []; // list of elements to call "clearAnim()" when animation stops
                this.elemsToDelete = []; // elems to delete at end of animation
                this.completedFuncs = [];
                this.onFrameCallback = null;
                this.removed = []; // children that have been moved to shader list
                this.timer = null;
                this.timeStarted = undefined;
                this.delaying = false;
                this._frameCount = 0;
                if (vp.utils.isUndefined(duration)) {
                    duration = 1000;
                }
                if (easeObj === true) {
                    easeObj = new vp.eases.powEase(2);
                }
                this.elem = elem;
                this._duration = duration;
                this._easeObj = easeObj;
                this.parentAnimation = parentAnimation;
                this._delay = delay;
                if (parentAnimation) {
                    parentAnimation.add(this);
                }
                //---- start each animation JIT (when first child is added) ----
                //this.restart();
            }
            animationClass.prototype.restart = function () {
                //vp.utils.debug("animation.restart()");
                if (!this.parentAnimation) {
                    this.setTimer();
                }
                this.timeStarted = Date.now();
                this.delaying = (this._delay > 0);
                if (this.elem) {
                    this.initAnim(this.elem);
                }
                //vp.utils.debug("animation object created");
            };
            animationClass.prototype.setTimer = function () {
                var _this = this;
                this.timer = vp.animation.requestAnimationFrame(function (e) {
                    _this.animateFrame();
                });
                //vp.utils.debug("timer created: " + this.timer);
            };
            /// move the specified anim off the active children list to the "removed" list.
            animationClass.prototype.remove = function (anim) {
                this._children.remove(anim);
                this.removed.push(anim);
            };
            animationClass.prototype.frameCount = function () {
                return this._frameCount;
            };
            /// internal.
            animationClass.prototype.getSlideLoc = function (slideLoc, elem) {
                var parent = vp.utils.getCanvasOrSvgParent(elem); // vp.dom.parent(elem);
                var pw = vp.dom.width(parent);
                var ph = vp.dom.height(parent);
                //---- compute OFFSET from current position ----
                var x = 0;
                var y = 0;
                if ((slideLoc == vp.animation.SlideLoc.left) || (slideLoc == "left")) {
                    x = -pw; //-2000;
                }
                else if ((slideLoc == vp.animation.SlideLoc.right) || (slideLoc == "right")) {
                    x = pw;
                }
                else if ((slideLoc == vp.animation.SlideLoc.top) || (slideLoc == "top")) {
                    y = -ph;
                }
                else if ((slideLoc == vp.animation.SlideLoc.bottom) || (slideLoc == "bottom")) {
                    y = ph;
                }
                return { x: x, y: y };
            };
            animationClass.prototype.initAnim = function (elem) {
                elem.animation = this;
                elem._origTransform = undefined;
                elem._transformAnim = undefined;
                this.elementsBeingAnimated.push(elem);
            };
            animationClass.prototype.clearAnim = function (elem) {
                //---- delete animation properties added to elem ----
                delete elem.animation;
                delete elem._origTransform;
                delete elem._transformAnim;
            };
            animationClass.prototype.getTranslateTo = function (trans) {
                var parts = this.parseTransform(trans);
                var locTo = null;
                for (var i = 0; i < parts.length; i++) {
                    if (parts[i].name == "translate") {
                        locTo = { x: parts[i].p0, y: parts[i].p1 };
                        break;
                    }
                }
                return locTo;
            };
            /// public: applyEffect(elem, effect, isEnter)
            animationClass.prototype.applyEffect = function (elem, effect, isEnter) {
                if (isEnter) {
                    this.applyEnterEffect(elem, effect);
                }
                else {
                    this.applyExitEffect(elem, effect);
                }
            };
            /// public: applyEnterEffect(elem, effect)
            animationClass.prototype.applyEnterEffect = function (elem, effect) {
                var startingChildIndex = this._children.length;
                if (effect.fadeType) {
                    if ((effect.fadeType == vp.animation.FadeType.fade) || (effect.fadeType == "fade")) {
                        //---- use "css" (not "attr") for opacity to avoid conflicts when both are set ----
                        //elem.setAttribute("opacity", "0");
                        //---- and avoid the ".css", since that might trigger ANOTHER animation ----
                        var curOpacity = 0;
                        elem.style.opacity = curOpacity;
                        this.animateAttr(elem, "opacity", curOpacity, 1, undefined, undefined, true);
                    }
                }
                if (effect.slideLoc) {
                    var locFrom = this.getSlideLoc(effect.slideLoc, elem);
                    // CHW: use current location, even if transformed, as destination of enter effect
                    var locTo = this.getTranslateTo(vp.dom.transform(elem));
                    if (locTo == null) {
                        var elemAny = elem;
                        var origTransform = elemAny._origTransform;
                        locTo = this.getTranslateTo(origTransform);
                        if (locTo == null) {
                            //---- if elem has no transform, just use (0,0) as the "to" value ----
                            //locTo = { x: vp.dom.attr(elem, "x"), y: vp.dom.attr(elem, "y") }
                            locTo = { x: 0, y: 0 };
                        }
                    }
                    if (locFrom.x) {
                        this.animateAttr(elem, "translate.x", locFrom.x, locTo.x);
                    }
                    if (locFrom.y) {
                        this.animateAttr(elem, "translate.y", locFrom.y, locTo.y);
                    }
                }
                if (effect.growOrigin) {
                    if ((effect.growOrigin != vp.animation.GrowOrigin.none) && (effect.growOrigin != "none")) {
                        var w = vp.dom.width(elem);
                        var h = vp.dom.height(elem);
                        var x = vp.dom.left(elem);
                        var y = vp.dom.top(elem);
                        if ((effect.growOrigin == vp.animation.GrowOrigin.left) || (effect.growOrigin == "left")) {
                            this.animateAttr(elem, "scale.x", 0, 1, x, y);
                        }
                        else if ((effect.growOrigin == vp.animation.GrowOrigin.top) || (effect.growOrigin == "top")) {
                            this.animateAttr(elem, "scale.y", 0, 1, x, y);
                        }
                        else if ((effect.growOrigin == vp.animation.GrowOrigin.right) || (effect.growOrigin == "right")) {
                            this.animateAttr(elem, "scale.x", 0, 1, x + w, y);
                        }
                        else if ((effect.growOrigin == vp.animation.GrowOrigin.bottom) || (effect.growOrigin == "bottom")) {
                            this.animateAttr(elem, "scale.y", 0, 1, x, y + h);
                        }
                        else if ((effect.growOrigin == vp.animation.GrowOrigin.center) || (effect.growOrigin == "center")) {
                            this.animateAttr(elem, "scale.x", 0, 1, x + w / 2, y + h / 2);
                            this.animateAttr(elem, "scale.y", 0, 1, x + w / 2, y + h / 2);
                        }
                    }
                }
                if (effect.rotateAngle) {
                    var w = vp.dom.width(elem);
                    var h = vp.dom.height(elem);
                    var x = vp.dom.left(elem);
                    var y = vp.dom.top(elem);
                    this.animateAttr(elem, "rotate", effect.rotateAngle, 0, x + w / 2, y + h / 2);
                }
                //---- for enter animations, we don't want to restore the origTransform at the end ----
                var elemAny = elem;
                elemAny._origTransform = undefined;
                //---- apply first frame NOW (so we don't see pre-anim version of shape) ----
                this.animateFrameCore(0, startingChildIndex);
            };
            /// public: applyExitEffect(elem, effect)
            animationClass.prototype.applyExitEffect = function (elem, effect) {
                var startingChildIndex = this._children.length;
                if (effect.fadeType) {
                    if ((effect.fadeType == vp.animation.FadeType.fade) || (effect.fadeType == "fade")) {
                        // CHW: only set current opacity if not set
                        var curOpacity = vp.dom.css(elem, "opacity");
                        if (curOpacity == null) {
                            //---- don't use "attr" here, since it will create yet another animation child ----
                            //vp.dom.attr(elem, "opacity", 1);
                            //elem.setAttribute("opacity", "1");
                            elem.style.opacity = 1;
                        }
                        this.animateAttr(elem, "opacity", 0, undefined, undefined, undefined, true);
                    }
                }
                if (effect.slideLoc) {
                    var loc = this.getSlideLoc(effect.slideLoc, elem);
                    // CHW: TODO use current location, even if transformed, as source of exit effect
                    if (loc.x) {
                        this.animateAttr(elem, "translate.x", 0, loc.x);
                    }
                    if (loc.y) {
                        this.animateAttr(elem, "translate.y", 0, loc.y);
                    }
                }
                if (effect.growOrigin) {
                    if ((effect.growOrigin != vp.animation.GrowOrigin.none) && (effect.growOrigin != "none")) {
                        var w = vp.dom.width(elem);
                        var h = vp.dom.height(elem);
                        var x = vp.dom.left(elem);
                        var y = vp.dom.top(elem);
                        if ((effect.growOrigin == vp.animation.GrowOrigin.left) || (effect.growOrigin == "left")) {
                            this.animateAttr(elem, "scale.x", 1, 0, x, y);
                        }
                        else if ((effect.growOrigin == vp.animation.GrowOrigin.top) || (effect.growOrigin == "top")) {
                            this.animateAttr(elem, "scale.y", 1, 0, x, y);
                        }
                        else if ((effect.growOrigin == vp.animation.GrowOrigin.right) || (effect.growOrigin == "right")) {
                            this.animateAttr(elem, "scale.x", 1, 0, x + w, y);
                        }
                        else if ((effect.growOrigin == vp.animation.GrowOrigin.bottom) || (effect.growOrigin == "bottom")) {
                            this.animateAttr(elem, "scale.y", 1, 0, x, y + h);
                        }
                        else if ((effect.growOrigin == vp.animation.GrowOrigin.center) || (effect.growOrigin == "center")) {
                            this.animateAttr(elem, "scale.x", 1, 0, x + w / 2, y + h / 2);
                            this.animateAttr(elem, "scale.y", 1, 0, x + w / 2, y + h / 2);
                        }
                    }
                }
                if (effect.rotateAngle) {
                    var w = vp.dom.width(elem);
                    var h = vp.dom.height(elem);
                    var x = vp.dom.left(elem);
                    var y = vp.dom.top(elem);
                    this.animateAttr(elem, "rotate", 0, effect.rotateAngle, x + w / 2, y + h / 2);
                }
                //---- for exit animations, we don't want to restore the origTransform at the end ----
                var elemAny = elem;
                elemAny._origTransform = undefined;
                //---- apply first frame NOW (so we don't see pre-anim version of shape) ----
                this.animateFrameCore(0, startingChildIndex);
            };
            /// private.
            animationClass.prototype.getTransformObject = function (elem) {
                var elemAny = elem;
                var ta = elemAny._transformAnim;
                if (ta == null) {
                    elemAny._origTransform = vp.dom.transform(elem);
                    ta = new vp.animation.transformAnimation(this, elem);
                    elemAny._transformAnim = ta;
                    this.addAnimation(ta);
                }
                return ta;
            };
            /// private.
            animationClass.prototype.parseTransformParams = function (scanner, transObj, paramCount) {
                var paramNum = 0;
                var tt = scanner.tokenType();
                while (tt == vp.utils.TokenType.number) {
                    var pname = "p" + paramNum++;
                    transObj[pname] = scanner.token();
                    tt = scanner.scan();
                    //---- look for optional comma ----
                    if (scanner.token() == ",") {
                        tt = scanner.scan(); // skip over comma
                    }
                }
                return (paramNum == paramCount);
            };
            //---- parse a transform string into an array of transform part objects (translate, scale, rotate, skew) ----
            /// private.
            animationClass.prototype.parseTransform = function (str) {
                var parts = [];
                if (str != null) {
                    var scanner = new vp.utils.scannerClass(str);
                    var tt = scanner.scan();
                    var paramCounts = { scale: 2, translate: 2, rotate: 3, skew: 2 };
                    while (tt != vp.utils.TokenType.eof) {
                        if (tt != vp.utils.TokenType.id) {
                            //---- looks like an error; just stop parsing ----
                            //parts = [];
                            //break;
                            throw "Error #1 in animation.parseTransform()";
                        }
                        var transObj = { name: scanner.token() };
                        parts.push(transObj);
                        tt = scanner.scan();
                        if (scanner.token() == "(") {
                            tt = scanner.scan();
                            var counts = paramCounts[transObj.name];
                            if (!this.parseTransformParams(scanner, transObj, counts)) {
                                // CHW: handle some common cases that used to look like errors
                                if (transObj.name == "scale" && transObj["p0"]) {
                                    // scale with one parameter; second parameter should equal first
                                    transObj["p1"] = transObj["p0"];
                                }
                                else if (transObj.name == "translate" && transObj["p0"]) {
                                    // translate with one parameter; second parameter should be 0
                                    transObj["p1"] = "0";
                                }
                                else if (transObj.name == "rotate" && transObj["p0"]) {
                                    if (transObj["p2"] === undefined) {
                                        throw "Error #4 in animation.parseTransform(): expected 3 params in rotate()";
                                    }
                                }
                                else {
                                    //---- looks like an error; just stop parsing ----
                                    throw "Error #2 in animation.parseTransform()";
                                }
                            }
                            if (scanner.token() != ")") {
                                //---- looks like an error; just stop parsing ----
                                //parts = [];
                                //break;
                                throw "Error #3 in animation.parseTransform()";
                            }
                            tt = scanner.scan(); // get nextname
                        }
                    }
                }
                return parts;
            };
            /// private.
            animationClass.prototype.getFromNumber = function (elem, isStyle, name) {
                var from = null; // default, if we cannot read it from anywhere...
                var propOwner = (isStyle) ? elem.style : elem;
                // the BELOW code should be changed - it adds a direct property that later down overrides the attribute
                // for an SVG elem like "rect".
                ////---- initialize property with default value, if needed ----
                //if ((propOwner[name] === undefined) || (propOwner[name] === ""))
                //{
                //    propOwner[name] = 0;
                //}
                if (isStyle) {
                    from = vp.dom.css(elem, name);
                    if (!from) {
                        //---- wasn't specified as part of style, so get full computed style (relatively expensive call) ----
                        from = getComputedStyle(elem)[name];
                    }
                    if (vp.utils.isString(from)) {
                        var str = from;
                        if (str.endsWith("px")) {
                            str = str.substr(0, str.length - 2).trim();
                        }
                        from = +str;
                    }
                }
                else if (elem.getAttribute) {
                    var av = elem.getAttribute(name);
                    if (av) {
                        if (av.baseVal != undefined) {
                            from = vp.dom.getBaseVal(elem, name, av);
                        }
                        else if (av.value != undefined) {
                            from = parseFloat(av.value);
                        }
                        else {
                            from = parseFloat(av);
                        }
                    }
                    else {
                        //---- try style again after all ----
                        from = vp.dom.attr(elem, name);
                    }
                }
                else if (name in propOwner) {
                    if (elem.rootContainer) {
                        from = propOwner[name];
                    }
                    else {
                        from = (propOwner[name].baseVal) ? vp.dom.getBaseVal(elem, name, propOwner[name]) : 0;
                    }
                }
                if (from === undefined || from === null || isNaN(from)) {
                }
                return from;
            };
            animationClass.prototype.getFromColor = function (elem, isStyle, name) {
                var from = null;
                if (isStyle) {
                    from = elem.style[name];
                    if (!from || from == "") {
                        //---- need to call (relatively expensive) getComputedStyle ----
                        from = getComputedStyle(elem)[name];
                    }
                }
                else if (elem.getAttribute) {
                    from = elem.getAttribute(name);
                }
                else {
                    from = elem[name];
                }
                if (!from || from == "") {
                    throw "Error: could not find FROM color for property=" + name;
                }
                else {
                }
                return from;
            };
            /// private animatePointsValue()
            animationClass.prototype.animatePointsValue = function (elem, name, isStyle, fromValue, value) {
                var from = vp.dom.attr(elem, "points");
                if (from != value) {
                    var animate = new animation.pointsAnimation(this, elem, name, from, value);
                    this.addAnimation(animate);
                }
            };
            /// private animateColorValue()
            animationClass.prototype.animateColorValue = function (elem, name, isStyle, fromValue, value) {
                var from = fromValue;
                if (vp.utils.isUndefined(from)) {
                    from = this.getFromColor(elem, isStyle, name);
                }
                from = vp.color.getColorFromString(from);
                value = vp.color.getColorFromString(value);
                var areDiff = false;
                if (from != null && from.length > 0 && value != null && value.length > 0) {
                    if ((from[0] != value[0]) || (from[1] != value[1]) || (from[2] != value[2])) {
                        areDiff = true;
                    }
                    if (areDiff) {
                        var animate = new animation.colorAnimation(this, elem, name, from, value, isStyle);
                        this.addAnimation(animate);
                    }
                }
            };
            /// private animateColorValue()
            animationClass.prototype.animateTransformValue = function (elem, name, isStyle, fromValue, value) {
                var ta = this.getTransformObject(elem);
                var from = fromValue;
                if (vp.utils.isUndefined(from)) {
                    if (isStyle) {
                        from = vp.dom.css(elem, "transform");
                    }
                    else {
                        from = vp.dom.attr(elem, "transform");
                    }
                }
                //---- parse "transform" strings into theirparts ----
                var fromParts = this.parseTransform(from);
                var toParts = this.parseTransform(value);
                for (var i = 0; i < toParts.length; i++) {
                    var toPart = toParts[i];
                    var fromPart = (i < fromParts.length) ? fromParts[i] : null;
                    if ((fromPart) && (fromPart.name != toPart.name)) {
                        //---- this is an error for our current level of support ----
                        break;
                    }
                    if (toPart.name == "translate") {
                        var fromX = (fromPart) ? fromPart.p0 : 0;
                        var toX = toPart.p0;
                        var fromY = (fromPart) ? fromPart.p1 : 0;
                        var toY = toPart.p1;
                        ta.makeTransform("translate.x", fromX, toX);
                        ta.makeTransform("translate.y", fromY, toY);
                    }
                    else if (toPart.name == "scale") {
                        var fromX = (fromPart) ? fromPart.p0 : 1;
                        var toX = toPart.p0;
                        var fromY = (fromPart) ? fromPart.p1 : 1;
                        var toY = toPart.p1;
                        ta.makeTransform("scale.x", fromX, toX);
                        ta.makeTransform("scale.y", fromY, toY);
                    }
                    else if (toPart.name == "rotate") {
                        var from = (fromPart) ? fromPart.p0 : 0;
                        var to = toPart.p0;
                        ta.makeTransform("rotate", from, to, toPart.p1, toPart.p2);
                    }
                }
            };
            /// public: animateAttr() - add the specified attribute/value to children (attributes) being animated.
            animationClass.prototype.animateAttr = function (elem, name, value, value2, cx, cy, isStyle) {
                //vp.utils.debug("animateAttr: name=" + name + ", value=" + value);
                var animate = null;
                var fromValue = undefined;
                if (value2 !== undefined) {
                    fromValue = value;
                    value = value2;
                }
                if ((name == "color") || (name == "fill") || (name == "stroke")) {
                    //---- remove any previous animation using this name/element ----
                    this.removeChild(elem, name);
                    //---- COLOR value ----
                    this.animateColorValue(elem, name, isStyle, fromValue, value);
                }
                else if (name == "points") {
                    //---- remove any previous animation using this name/element ----
                    this.removeChild(elem, name);
                    //---- set of points for a line or polygon element ----
                    this.animatePointsValue(elem, name, isStyle, fromValue, value);
                }
                else if (name == "transform") {
                    //---- TRANSFORM value ----
                    this.animateTransformValue(elem, name, isStyle, fromValue, value);
                }
                else if ((name == "scale") || (name == "translate") || (name == "rotate")) {
                    //---- TRANSFORM value ----
                    var ta = this.getTransformObject(elem);
                    ta.makeTransform(name, fromValue, value, cx, cy);
                }
                else if ((name.startsWith("scale.")) || (name.startsWith("translate.")) || (name.startsWith("rotate."))) {
                    //---- TRANSFORM value ----
                    var ta = this.getTransformObject(elem);
                    ta.makeTransform(name, fromValue, value, cx, cy);
                }
                else {
                    //---- remove any previous animation using this name/element ----
                    this.removeChild(elem, name);
                    //---- NUMERIC value ----
                    var from = fromValue;
                    if (vp.utils.isUndefined(from)) {
                        from = this.getFromNumber(elem, isStyle, name);
                        if (from === undefined || from == null || isNaN(from)) {
                            from = 0;
                        }
                    }
                    //---- remove "px" at end of value ----
                    if (vp.utils.isString(value)) {
                        var str = value;
                        if (str.endsWith("px")) {
                            str = str.substr(0, str.length - 2).trim();
                            value = +str;
                        }
                    }
                    //vp.utils.debug("animation.animateAttr: [number detected], from=" + from + ", value=" + value);
                    //---- SVG (IE11 at least) seems to only retain 3 fractional digits, so compare accordingly ----
                    if (!vp.utils.unitsEq(from, value, .01)) {
                        if (name == "y" && elem.tagName == "text") {
                            var aa = 99; // debug
                        }
                        var animate = new animation.numberAnimation(this, elem, name, from, value, isStyle);
                        this.addAnimation(animate);
                    }
                }
                //---- if this is a child of a webGL canvas, add to new animatons list ----
                if (animate != null) {
                    if ((elem.rootContainer) && (elem.rootContainer.glHelper))
                        if (animation.shaderAnimationMgr) {
                            animation.shaderAnimationMgr.addNewAnimation(animate);
                        }
                }
            };
            /// public.
            animationClass.prototype.deleteElementOnCompleted = function (elem) {
                this.elemsToDelete.push(elem);
            };
            animationClass.prototype.removeChild = function (elem, name) {
                for (var i = this._children.length - 1; i >= 0; i--) {
                    var child = this._children[i];
                    if (child.element == elem && child.name == name) {
                        this._children.removeAt(i);
                        //vp.utils.debug("animation.removeChild: removed name=" + name);
                        break;
                    }
                }
            };
            /// private.
            animationClass.prototype.addAnimation = function (newChild) {
                if (newChild.name && newChild.name != "") {
                }
                if (newChild.name == "x" || newChild.name == "y") {
                }
                if ((this._children.length == 0) && (this.timer == null)) {
                    this.restart();
                }
                this._children.push(newChild);
            };
            /// called each frame to animate all contains attribute animations.  must return true when
            /// we have reached percent=1 (100%).
            animationClass.prototype.animateFrame = function () {
                //---- on first frame of first animation, see if a common setset of the GL animations ----
                //---- (those with the same duration) can be moved onto the shader animation list ---
                if (animation.shaderAnimationMgr) {
                    animation.shaderAnimationMgr.processNewAnimations();
                }
                var elapsed = Date.now() - this.timeStarted;
                if (this.delaying) {
                    //vp.utils.debug("anim: delay frame");
                    if (elapsed >= this._delay) {
                        this.delaying = false;
                        this.timeStarted = Date.now();
                        elapsed = 0;
                    }
                }
                else {
                    var percent = elapsed / this._duration;
                    if (percent > 1) {
                        percent = 1;
                    }
                    else if (percent < 0) {
                        percent = 0;
                    }
                    else {
                        //---- apply easing fuction ----
                        if (this._easeObj) {
                            percent = this._easeObj.ease(percent);
                        }
                    }
                    //vp.utils.debug("anim: percent: " + percent);
                    this.animateFrameCore(percent);
                }
                //---- if timer not cleared by onAnimatedStopped(), request another frame ----
                if (this.timer) {
                    this.setTimer();
                }
                return (percent == 1);
            };
            animationClass.prototype.children = function () {
                return this._children;
            };
            animationClass.prototype.animateFrameCore = function (percent, startingChildIndex) {
                //vp.utils.traceAniFrame(this._children.length, this._frameCount, percent);
                if (startingChildIndex !== undefined) {
                    //---- special ENTER/EXIT effect drawing before real frames start ----
                    for (var i = startingChildIndex; i < this._children.length; i++) {
                        this._children[i].animateFrame(percent);
                    }
                }
                else {
                    //---- normal frame ----
                    for (var i = 0; i < this._children.length; i++) {
                        this._children[i].animateFrame(percent);
                    }
                    this._frameCount++;
                    if (this.onFrameCallback) {
                        this.onFrameCallback(percent, this);
                    }
                }
                if (percent == 1) {
                    this.onAnimationStopped();
                }
            };
            /// public.
            animationClass.prototype.stop = function () {
                var stopped = false;
                if (true) {
                    //---- move all elems into their final position instantly ----
                    var percent = 1;
                    //vp.utils.debug("animation.stop: forcing percent=1 positions");
                    //---- experiment - try turning this off - 07/17/2014. ----
                    for (var i = 0; i < this._children.length; i++) {
                        this._children[i].animateFrame(percent);
                    }
                    this.onAnimationStopped(true);
                    stopped = true;
                }
                return stopped;
            };
            animationClass.prototype.onAnimationComplete = function (arg) {
                if (this.completedFuncs.indexOf(arg) == -1) {
                    this.completedFuncs.push(arg);
                }
                return this;
            };
            animationClass.prototype.onFrame = function (arg) {
                if (arguments.length == 0) {
                    return this.onFrameCallback;
                }
                this.onFrameCallback = arg;
                return this;
            };
            /// private.
            animationClass.prototype.onAnimationStopped = function (wasCancelled) {
                //---- stop further animations ----
                if (this.timer) {
                    clearInterval(this.timer);
                    if (!wasCancelled) {
                    }
                    this.timer = null;
                }
                //---- remove associated elements from their containers ----
                if (this.elemsToDelete.length > 0) {
                    for (var i = 0; i < this.elemsToDelete.length; i++) {
                        var elem = this.elemsToDelete[i];
                        vp.dom.remove(elem);
                        vp.utils.assert(elem.parentNode == null);
                    }
                    //vp.utils.debug("onAnimationStopped: removed children=" + this.elemsToDelete.length);
                    this.elemsToDelete = [];
                }
                for (var c = 0; c < this.completedFuncs.length; c++) {
                    var callback = this.completedFuncs[c];
                    callback(this, wasCancelled);
                }
                //---- remove this animation from the list of active animations on the container ----
                //if (this.elem.rootContainer)        // canvas element
                //{
                //    this.elem.rootContainer.removeAnimation(this);
                //}
                //---- remove the animation property so that subsequent property changes are normal ----
                var elements = this.elementsBeingAnimated;
                for (var i = 0; i < elements.length; i++) {
                    this.clearAnim(elements[i]);
                }
                if (this.elem) {
                    this.clearAnim(this.elem);
                }
                //---- note: animations are not directly reusable; all childrent must be re-added ----
                this._children = [];
                this.elementsBeingAnimated = [];
                this.elem = null;
            };
            animationClass.prototype.duration = function (value) {
                if (arguments.length == 0) {
                    return this._duration;
                }
                this._duration = value;
                return this;
            };
            animationClass.prototype.delay = function (value) {
                if (arguments.length == 0) {
                    return this._delay;
                }
                this._delay = value;
                return this;
            };
            animationClass.prototype.easeObj = function (value) {
                if (arguments.length == 0) {
                    return this._easeObj;
                }
                this._easeObj = value;
                return this;
            };
            return animationClass;
        }());
        animation.animationClass = animationClass;
        function createAnimation(elem, duration, easeObj, container, delay) {
            return new animationClass(elem, duration, easeObj, container, delay);
        }
        animation.createAnimation = createAnimation;
        function requestAnimationFrame(callback) {
            var timer = null;
            if (window && window.requestAnimationFrame) {
                window.requestAnimationFrame(callback);
                timer = -1;
            }
            else {
                timer = setTimeout(callback, 1000 / 60);
            }
            return timer;
        }
        animation.requestAnimationFrame = requestAnimationFrame;
        function cancelAnimationFrame(timer) {
            if (window && window.cancelAnimationFrame) {
                window.cancelAnimationFrame(timer);
            }
            else {
                clearTimeout(timer);
            }
        }
        animation.cancelAnimationFrame = cancelAnimationFrame;
        animation.shaderAnimationMgr = null;
    })(animation = vp.animation || (vp.animation = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// animationContainer.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library 
///   - controls multiple animation objects
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var animation;
    (function (animation) {
        /// class: animationContainer
        /// this is used to contain and control a set of vp.animation classes.  to keep animations
        /// crisp and in sync, a single timer is used in the container class. when stopped
        /// or all child animations are completed, the "completedFunc" is called.
        var animationContainer = (function () {
            function animationContainer() {
                this.ctr = "vp.animationContainer";
                //---- private state ----
                this.children = [];
                this.completedFunc = null;
                this.timer = null;
                this._timeStarted = null;
                this.easeObj = null;
                this.isRunning = false;
            }
            animationContainer.prototype.timeStarted = function () {
                return this._timeStarted;
            };
            /// public: add(anim)
            animationContainer.prototype.add = function (anim) {
                var _this = this;
                if (this.children.length == 0) {
                    //---- start the container when first child is added ---
                    this.timer = vp.animation.requestAnimationFrame(function (e) {
                        _this.animateFrame();
                    });
                    this._timeStarted = new Date();
                    this.isRunning = true;
                }
                this.children.push(anim);
            };
            /// public: stop()
            /// stop the running animation.
            animationContainer.prototype.stop = function () {
                var children = this.children;
                if (this.timer) {
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        child.stop();
                    }
                    this.onStoppedOrCompleted();
                }
            };
            /// public: onCompleted(completedFunc)
            /// set the callback func to be called when animation is stopped or completed.
            animationContainer.prototype.onCompleted = function (completedFuncParam) {
                this.completedFunc = completedFuncParam;
            };
            /// public: clear()
            animationContainer.prototype.clear = function () {
                this.stop();
                this.children = [];
            };
            /// private: onStoppedOrCompleted()
            /// this is called when animation container is explictly stopped or all of the child
            /// animations have completed.
            animationContainer.prototype.onStoppedOrCompleted = function () {
                clearInterval(this.timer);
                this.timer = null;
                this.isRunning = false;
                if (this.completedFunc) {
                    this.completedFunc();
                }
            };
            /// public: animateFrame()
            /// called once every 1/60 of a second or so.  its job is to call each child animation and
            /// keep track of which have completed.
            animationContainer.prototype.animateFrame = function () {
                var _this = this;
                var children = this.children;
                //---- go thru backwards, so its safe to remove entries ----
                for (var i = children.length - 1; i >= 0; i--) {
                    var child = children[i];
                    var completed = child.animateFrame();
                    if (completed) {
                        children.removeAt(i);
                    }
                }
                if (children.length == 0) {
                    this.onStoppedOrCompleted();
                }
                if (this.timer) {
                    vp.animation.requestAnimationFrame(function () {
                        _this.animateFrame();
                    });
                }
            };
            return animationContainer;
        }());
        animation.animationContainer = animationContainer;
    })(animation = vp.animation || (vp.animation = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// colorAnimation.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library
///  - animates a color.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var animation;
    (function (animation) {
        //---- class: colorAnimation ----
        var colorAnimation = (function () {
            function colorAnimation(parent, element, attributeName, fromColor, toColor, isStyle) {
                //vp.utils.trace("ctr", "colorAnimation");
                this.element = element;
                this.parent = parent;
                this.attributeName = attributeName;
                this.isStyle = isStyle;
                this.from = vp.color.getColorFromString(fromColor);
                this.to = vp.color.getColorFromString(toColor);
                if (!this.from) {
                    vp.utils.error("colorAnimation: 'from' is not defined");
                }
                if (!this.to) {
                    vp.utils.error("colorAnimation: 'to' is not defined");
                }
            }
            /// private: getAnimateCalue(percent)
            colorAnimation.prototype.getAnimatedValue = function (percent) {
                var from = this.from;
                var to = this.to;
                var r = Math.round(from[0] + percent * (to[0] - from[0]));
                var g = Math.round(from[1] + percent * (to[1] - from[1]));
                var b = Math.round(from[2] + percent * (to[2] - from[2]));
                var value = "rgb(" + r.toString() + "," + g.toString() + "," + b.toString() + ")";
                return value;
            };
            /// public: animateFrame(percent)
            colorAnimation.prototype.animateFrame = function (percent) {
                var value = this.getAnimatedValue(percent);
                if (this.isStyle) {
                    this.element.style[this.attributeName] = value;
                }
                else {
                    this.element.setAttribute(this.attributeName, value);
                }
            };
            return colorAnimation;
        }());
        animation.colorAnimation = colorAnimation;
    })(animation = vp.animation || (vp.animation = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// eases.ts.  Copyright (c) 2016 Microsoft Corporation.
///            part of the vuePlotCore library - eases for animation.
///
/// - adapted from Microsoft WPF Framework (their ease functions).
///-----------------------------------------------------------------------------------------------------------------
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var vp;
(function (vp) {
    var eases;
    (function (eases) {
        //---- enum: easeMode ----
        (function (EaseMode) {
            EaseMode[EaseMode["easeIn"] = 0] = "easeIn";
            EaseMode[EaseMode["easeOut"] = 1] = "easeOut";
            EaseMode[EaseMode["easeInOut"] = 2] = "easeInOut";
        })(eases.EaseMode || (eases.EaseMode = {}));
        var EaseMode = eases.EaseMode;
        (function (BezierEaseMode) {
            BezierEaseMode[BezierEaseMode["ease"] = 0] = "ease";
            BezierEaseMode[BezierEaseMode["easeIn"] = 1] = "easeIn";
            BezierEaseMode[BezierEaseMode["easeOut"] = 2] = "easeOut";
            BezierEaseMode[BezierEaseMode["easeInOut"] = 3] = "easeInOut";
            BezierEaseMode[BezierEaseMode["linear"] = 4] = "linear";
            BezierEaseMode[BezierEaseMode["maxEase"] = 5] = "maxEase";
        })(eases.BezierEaseMode || (eases.BezierEaseMode = {}));
        var BezierEaseMode = eases.BezierEaseMode;
        //---- class: easeBase ----
        var easeBase = (function () {
            function easeBase() {
                this.easeMode = EaseMode.easeInOut;
            }
            //---- this function is overwritten by subclasses ----
            easeBase.prototype.easeCore = function (t) {
                return t;
            };
            easeBase.prototype.ease = function (t) {
                var value;
                if (this.easeMode == EaseMode.easeIn) {
                    value = this.easeCore(t);
                }
                else if (this.easeMode == EaseMode.easeOut) {
                    value = 1 - this.easeCore(1 - t);
                }
                else {
                    if (t < .5) {
                        var coreValue = this.easeCore(t * 2);
                        value = coreValue * .5;
                    }
                    else {
                        var coreValue = this.easeCore(2 * (1 - t));
                        value = (1 - coreValue) * .5 + .5;
                    }
                }
                return value;
            };
            return easeBase;
        }());
        eases.easeBase = easeBase;
        //---- class: floorEase ----
        //----      always uses the first value in a local pair of values. ----
        var floorEase = (function (_super) {
            __extends(floorEase, _super);
            function floorEase() {
                _super.apply(this, arguments);
            }
            floorEase.prototype.easeCore = function (t) {
                return 0;
            };
            return floorEase;
        }(easeBase));
        eases.floorEase = floorEase;
        //---- class: nearestNeighborEase ----
        //----      use the ease that "t" is closest to ----
        var nearestNeighborEase = (function (_super) {
            __extends(nearestNeighborEase, _super);
            function nearestNeighborEase() {
                _super.apply(this, arguments);
            }
            nearestNeighborEase.prototype.easeCore = function (t) {
                return (t < .5) ? 0 : 1;
            };
            return nearestNeighborEase;
        }(easeBase));
        eases.nearestNeighborEase = nearestNeighborEase;
        //---- class: linearEase ----
        //----      use the ease that "t" is closest to ----
        var linearEase = (function (_super) {
            __extends(linearEase, _super);
            function linearEase() {
                _super.apply(this, arguments);
            }
            linearEase.prototype.easeCore = function (t) {
                return t;
            };
            return linearEase;
        }(easeBase));
        eases.linearEase = linearEase;
        //---- class: quadraticEase ----
        var quadraticEase = (function (_super) {
            __extends(quadraticEase, _super);
            function quadraticEase() {
                _super.apply(this, arguments);
            }
            quadraticEase.prototype.easeCore = function (t) {
                return t * t;
            };
            return quadraticEase;
        }(easeBase));
        eases.quadraticEase = quadraticEase;
        //---- class: cubicEase ----
        var cubicEase = (function (_super) {
            __extends(cubicEase, _super);
            function cubicEase() {
                _super.apply(this, arguments);
            }
            cubicEase.prototype.easeCore = function (t) {
                return t * t * t;
            };
            return cubicEase;
        }(easeBase));
        eases.cubicEase = cubicEase;
        //---- class: quarticEase ----
        var quarticEase = (function (_super) {
            __extends(quarticEase, _super);
            function quarticEase() {
                _super.apply(this, arguments);
            }
            quarticEase.prototype.easeCore = function (t) {
                return t * t * t * t;
            };
            return quarticEase;
        }(easeBase));
        eases.quarticEase = quarticEase;
        //---- class: sineEase ----
        var sineEase = (function (_super) {
            __extends(sineEase, _super);
            function sineEase() {
                _super.apply(this, arguments);
            }
            sineEase.prototype.easeCore = function (t) {
                return 1 - Math.sin(Math.PI * .5 * (1 - t));
            };
            return sineEase;
        }(easeBase));
        eases.sineEase = sineEase;
        //---- class: circleEase ----
        var circleEase = (function (_super) {
            __extends(circleEase, _super);
            function circleEase() {
                _super.apply(this, arguments);
            }
            circleEase.prototype.easeCore = function (t) {
                return 1 - Math.sqrt(1 - t * t);
            };
            return circleEase;
        }(easeBase));
        eases.circleEase = circleEase;
        //---- class: backEase ----
        var backEase = (function (_super) {
            __extends(backEase, _super);
            function backEase(amplitude) {
                _super.call(this);
                this.amplitude = amplitude;
            }
            backEase.prototype.easeCore = function (t) {
                return Math.pow(t, 3.0) - t * this.amplitude * Math.sin(Math.PI * t);
            };
            return backEase;
        }(easeBase));
        eases.backEase = backEase;
        //---- class: powEase ----
        var powEase = (function (_super) {
            __extends(powEase, _super);
            function powEase(n) {
                _super.call(this);
                this.n = n;
            }
            powEase.prototype.easeCore = function (t) {
                return Math.pow(t, this.n);
            };
            return powEase;
        }(easeBase));
        eases.powEase = powEase;
        //---- class: stdEaseOut ----
        var stdEaseOut = (function (_super) {
            __extends(stdEaseOut, _super);
            function stdEaseOut() {
                _super.call(this);
                this.easeMode = EaseMode.easeOut;
            }
            stdEaseOut.prototype.easeCore = function (t) {
                return t * t;
            };
            return stdEaseOut;
        }(easeBase));
        eases.stdEaseOut = stdEaseOut;
        //---- class: expEase ----
        var expEase = (function (_super) {
            __extends(expEase, _super);
            function expEase(n) {
                _super.call(this);
                this.n = Math.max(0, n);
            }
            expEase.prototype.easeCore = function (t) {
                if (vp.utils.floatEq(0, this.n)) {
                    return t;
                }
                else {
                    return (Math.exp(this.n * t) - 1.0) / (Math.exp(this.n) - 1.0);
                }
            };
            return expEase;
        }(easeBase));
        eases.expEase = expEase;
        //---- class: springEase ----
        var springEase = (function (_super) {
            __extends(springEase, _super);
            function springEase(springiness, oscillations) {
                _super.call(this);
                this.springiness = springiness;
                this.oscillations = oscillations;
            }
            springEase.prototype.easeCore = function (t) {
                var expo = 0;
                if (vp.utils.floatEq(this.springiness, 0)) {
                    expo = t;
                }
                else {
                    expo = (Math.exp(this.springiness * t) - 1.0) / (Math.exp(this.springiness) - 1.0);
                }
                return expo * (Math.sin((Math.PI * 2.0 * this.oscillations + Math.PI * 0.5) * t));
            };
            return springEase;
        }(easeBase));
        eases.springEase = springEase;
    })(eases = vp.eases || (vp.eases = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// dataAnimMgr.ts.  Copyright (c) 2016 Microsoft Corporation.
///   -part of the vuePlot library.
///   - manages a data source with respect to data changes, filtering, and related animation.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var animation;
    (function (animation) {
        /// class: dataAnimMgr 
        var dataAnimMgrClass = (function () {
            function dataAnimMgrClass(containerUW, pkFunc, appendSFCtor, layerId, isSeriesLayer, createTransition) {
                if (createTransition === void 0) { createTransition = true; }
                //---- private state ----
                this._enterShapes = []; // new shapes for this data change
                this._updateShapes = []; // existing shapes for this data change
                this._exitShapes = []; // exiting shapes for this data change
                this._updateRows = []; // list of rows that were "update" rows in setData()
                this._keys = {}; // dict to map data to shape (by primary key + seriesIndex)
                this._data = []; // the current set of data
                this._enterDataPairs = [];
                this._dataId = undefined;
                this._seriesCount = 1;
                this._appendNameOrCallback = null;
                //---- stats ----
                this._animStartTime = 0;
                this._animFPS = 0;
                this._shapesDrawn = 0;
                this._statsCallback = null;
                this.ctr = "vp.dataAnimMgrEx";
                this._container = ((containerUW) && (containerUW.length)) ? containerUW[0] : containerUW;
                this._pkCallback = pkFunc;
                this._appendNameOrCallback = appendSFCtor;
                this._layerId = layerId;
                this._isSeriesLayer = isSeriesLayer;
                if (createTransition) {
                    this._transition = vp.animation.createTransition(750);
                }
                if (this._pkCallback === undefined) {
                    //---- provide default key callback ----
                    this._pkCallback = vp.utils.indexKeyFunc;
                }
            }
            dataAnimMgrClass.prototype.transition = function (value) {
                if (arguments.length == 0) {
                    return this._transition;
                }
                this._transition = value;
                this.hookTransitionEvents();
                return this;
            };
            dataAnimMgrClass.prototype.hookTransitionEvents = function () {
                var _this = this;
                if (this._transition) {
                    var enter = this._transition.enter();
                    var update = this._transition.update();
                    var exit = this._transition.exit();
                    enter.onAnimationComplete(function (anim, wasCancelled) {
                        _this.onAnimationComplete(anim, wasCancelled, "ENTER");
                    });
                    update.onAnimationComplete(function (anim, wasCancelled) {
                        _this.onAnimationComplete(anim, wasCancelled, "UPDATE");
                    });
                    exit.onAnimationComplete(function (anim, wasCancelled) {
                        _this.onAnimationComplete(anim, wasCancelled, "EXIT");
                    });
                }
            };
            /** will stop all animations associated with this mgr. */
            dataAnimMgrClass.prototype.clearActiveAnimations = function () {
                if (this._transition) {
                    this._transition.clearAnimations(this);
                }
                //this._masterAnim.stop();
            };
            /// do not assume that "container" has been set here - OK to create new shapes but don't append them yet.
            dataAnimMgrClass.prototype.setData = function (newData, isNewDataSet, newDataId) {
                this.clearActiveAnimations();
                //---- merge both into existingShapes ----
                var existingShapes = this._updateShapes.concat(this._enterShapes);
                if (this._exitShapes.length > 0) {
                    //---- about to overwrite exit shapes - remove them now ----
                    this.removeExitShapesNow(-1);
                }
                this._enterShapes = [];
                this._exitShapes = [];
                this._updateShapes = [];
                this._enterDataPairs = [];
                this._updateRows = [];
                if ((isNewDataSet) || (!this._transition)) {
                    this._keys = {};
                    if (newData) {
                        //---- put all new items on "enter" ----
                        for (var i = 0; i < newData.length; i++) {
                            var pair = { dataItem: newData[i], dataIndex: i };
                            this._enterDataPairs.push(pair);
                        }
                    }
                    this._exitShapes = existingShapes;
                    if (!this._transition) {
                        //---- keep it simple and remove them all now ----
                        if (this._exitShapes.length > 0) {
                            this.removeExitShapesNow(-1);
                        }
                    }
                }
                else {
                    //---- mark all existing elements as "not yet found" ----
                    for (var i = 0; i < existingShapes.length; i++) {
                        existingShapes[i].notYetFound = true;
                    }
                    if (newData) {
                        var lastUpdateRow = -1;
                        //---- figure out split of new data into: enter, update groups ----
                        for (var i = 0; i < newData.length; i++) {
                            for (var s = 0; s < this._seriesCount; s++) {
                                var key = this.getFullKey(newData[i], i, s);
                                var uelem = this._keys[key];
                                if (uelem == undefined) {
                                    var pair = { dataItem: newData[i], dataIndex: i };
                                    this._enterDataPairs.push(pair);
                                }
                                else {
                                    uelem.notYetFound = false;
                                    //---- add "i" to  this._updateRows, on first time seen ----
                                    if (lastUpdateRow != i) {
                                        this._updateRows.push(i);
                                        lastUpdateRow = i;
                                    }
                                    //---- update data/dataIndex fields to reflect data change ----
                                    uelem.dataItem.data = newData[i];
                                    uelem.dataIndex = i;
                                    this._updateShapes.push(uelem);
                                }
                            }
                        }
                    }
                    //---- move any elements that we didn't find in the new data into the "exit" elements ----
                    for (var i = 0; i < existingShapes.length; i++) {
                        var elem = existingShapes[i];
                        if (elem.notYetFound === true) {
                            //---- remove key from keys ----
                            var key = this.getFullKey(elem.dataItem, elem.dataIndex, vp.dom.shapeId(elem));
                            this.deleteKey(elem, key);
                            //---- update dataIndex to reflect that data is not in current data[] ----
                            elem.dataIndex = -(elem.dataIndex + 1);
                            this._exitShapes.push(elem);
                        }
                    }
                }
                this._data = newData;
                this._dataId = newDataId;
                return this;
            };
            /** this is only called from layers that support series plotting.  It should be called after setData(), but before
            updateShapes().  */
            dataAnimMgrClass.prototype.setSeriesNames = function (value) {
                if (this._isSeriesLayer) {
                    //---- transform degenerate case to true value ----
                    if (value && value.length == 1 && value[0] == "") {
                        value = [];
                    }
                    this._pendingSeriesNames = value;
                }
            };
            dataAnimMgrClass.prototype.applySeriesNames = function () {
                if (this._updateRows.length) {
                    var data = this._data;
                    var beforeList = this._seriesNames;
                    if (!beforeList) {
                        beforeList = [];
                    }
                    var afterList = this._pendingSeriesNames;
                    if (!afterList) {
                        afterList = [];
                    }
                    //---- build a seriesIndex update table to map from before si to after si ----
                    var seriesUpdateTable = {};
                    for (var i = 0; i < beforeList.length; i++) {
                        var beforeName = beforeList[i];
                        var afterIndex = afterList.indexOf(beforeName);
                        seriesUpdateTable[i] = afterIndex;
                    }
                    //---- first pass - REMOVE old series ----
                    for (var j = this._updateShapes.length - 1; j >= 0; j--) {
                        var elem = this._updateShapes[j];
                        var si = seriesUpdateTable[elem.dataItem.shapeId];
                        if (si == -1) {
                            this._updateShapes.removeAt(j);
                            this._exitShapes.push(elem);
                            //---- remove key from keys ----
                            var key = this.getFullKey(elem.dataItem, elem.dataIndex, vp.dom.shapeId(elem));
                            this.deleteKey(elem, key);
                            //---- use seriesIndex=0 to ensure it gets processed in updateShapes() ----
                            elem.dataItem.shapeId = 0;
                        }
                    }
                    //---- second pass: UPDATE series index of shapes (to be relative to afterList) ----
                    for (var j = this._updateShapes.length - 1; j >= 0; j--) {
                        var elem = this._updateShapes[j];
                        var si = seriesUpdateTable[elem.dataItem.shapeId];
                        if (si > -1) {
                            //---- delete OLD key, if it belongs to elem ----
                            var key = this.getFullKey(elem.dataItem, elem.dataIndex, vp.dom.shapeId(elem));
                            if (this._keys[key] == elem) {
                                this.deleteKey(elem, key);
                            }
                            //---- UPDATE seriesIndex ----
                            elem.dataItem.shapeId = si;
                            //---- add NEW key ----
                            var key = this.getFullKey(elem.dataItem, elem.dataIndex, vp.dom.shapeId(elem));
                            this.addKey(elem, key);
                        }
                    }
                    //---- for each afterName that is new, create a series of shapes and add to _enterShapes ----
                    for (var i = 0; i < afterList.length; i++) {
                        var afterName = afterList[i];
                        if (beforeList.indexOf(afterName) == -1) {
                            //---- afterName ADDED - create a set of shapes for it ----
                            var pairList = [];
                            for (var j = 0; j < this._updateRows.length; j++) {
                                var row = this._updateRows[j];
                                var pair = { dataItem: data[row], dataIndex: row };
                                pairList.push(pair);
                            }
                            if (pairList.length) {
                                var shapes = this.createMultipleShapes(this._appendNameOrCallback, 1, pairList);
                                this.processNewlyCreatedShapes(shapes, pairList, 1, i);
                                //---- add these new shapes to _enterShapes ----
                                this._enterShapes = this._enterShapes.concat(shapes);
                            }
                        }
                    }
                }
                this._seriesNames = this._pendingSeriesNames;
                this._pendingSeriesNames = null;
            };
            /// public: updateShapes()
            /// call this after a call to setData().
            dataAnimMgrClass.prototype.updateShapes = function (seriesIndex, totalSeries, callBack, appendStrOrFunc) {
                //---- apply pending series names (was deferred until now, when caller has set our container) ----
                if (this._pendingSeriesNames && this._container) {
                    this.applySeriesNames();
                }
                this._seriesCount = totalSeries;
                var shapesTouched = [];
                var transition = this._transition;
                //---- we called clear animations in setData(); we don't want to call in a 2nd time here ----
                //if (seriesIndex == 0)
                //{
                //    this.clearActiveAnimations();
                //}
                var start = vp.utils.now();
                this.createEnterShapesIfNeeded(this._seriesCount, appendStrOrFunc);
                var enterElapsed = vp.utils.now() - start;
                var start = vp.utils.now();
                //---- update NEW shapes WITHOUT animation ----
                for (var i = 0; i < this._enterShapes.length; i++) {
                    var uelem = this._enterShapes[i];
                    var shapeId = vp.dom.shapeId(uelem);
                    if (shapeId == seriesIndex) {
                        vp.dom.animate(uelem, 0); // turn off animation for this shape
                        var isLastNew = (i == this._enterShapes.length - 1);
                        callBack(uelem, uelem.dataItem, uelem.dataIndex, true, isLastNew);
                        shapesTouched.push(uelem);
                    }
                }
                this._animStartTime = vp.utils.now();
                if (this._updateShapes.length) {
                    this.createUpdateAnimations(seriesIndex, shapesTouched, callBack);
                }
                if (this._enterShapes.length) {
                    this.createEnterAnimations(seriesIndex, shapesTouched, callBack);
                }
                if (this._exitShapes.length) {
                    this.createExitAnimations(seriesIndex, shapesTouched, callBack);
                }
                //---- return all shapes now in plot for this dataAnimMgr / seriesIndex ----
                var wrap = vp.dom.wrapElements(shapesTouched);
                return wrap;
            };
            dataAnimMgrClass.prototype.createExitAnimations = function (seriesIndex, shapesTouched, callBack) {
                var needDelete = true;
                if (this._transition) {
                    //---- create one animation object for all EXIT elements/properties being animated ----
                    var anim = this._transition.exit();
                    if (anim && anim.duration()) {
                        //vp.utils.debug("creating EXIT animations: id=" + this._layerId);
                        var effect = this._transition.exitEffect();
                        var aniCount = 0;
                        needDelete = false;
                        //---- go thru list backwards, removing entries as we find seriesIndex matches ----
                        for (var i = this._exitShapes.length - 1; i >= 0; i--) {
                            var uelem = this._exitShapes[i];
                            if (vp.dom.shapeId(uelem) == seriesIndex) {
                                anim.initAnim(uelem);
                                anim.applyExitEffect(uelem, effect);
                                anim.deleteElementOnCompleted(uelem);
                                aniCount++;
                                this._exitShapes.removeAt(i);
                            }
                        }
                    }
                    if (aniCount) {
                    }
                }
                if (needDelete) {
                    this.removeExitShapesNow(seriesIndex);
                }
                //var deleteElapsed = vp.utils.now() - start;
            };
            dataAnimMgrClass.prototype.createEnterAnimations = function (seriesIndex, shapesTouched, callBack) {
                if (this._transition) {
                    //---- create ENTER animations ----
                    var anim = this._transition.enter();
                    var effect = this._transition.enterEffect();
                    //var enterProps = this.buildAnimationProps(this._enterAnim);
                    if (anim.duration() && effect) {
                        //vp.utils.debug("creating ENTER animations: id=" + this._layerId);
                        //---- create one animation object for all ENTER elements/properties being animated ----
                        var aniCount = 0;
                        for (var i = 0; i < this._enterShapes.length; i++) {
                            var uelem = this._enterShapes[i];
                            if (vp.dom.shapeId(uelem) == seriesIndex) {
                                anim.initAnim(uelem);
                                anim.applyEnterEffect(uelem, effect);
                                aniCount++;
                            }
                        }
                        if (aniCount) {
                        }
                    }
                }
            };
            dataAnimMgrClass.prototype.createUpdateAnimations = function (seriesIndex, shapesTouched, callBack) {
                //---- create UPDATE animations ----
                var anim = (this._transition) ? this._transition.update() : null;
                if (anim && anim.duration() == 0) {
                    anim = null;
                }
                if (anim) {
                }
                //---- update EXISTING shapes WITH animation ----
                var aniCount = 0;
                for (var i = 0; i < this._updateShapes.length; i++) {
                    var uelem = this._updateShapes[i];
                    if (vp.dom.shapeId(uelem) == seriesIndex) {
                        if (anim) {
                            anim.initAnim(uelem);
                            aniCount++;
                        }
                        callBack(uelem, uelem.dataItem, uelem.dataIndex, false);
                        shapesTouched.push(uelem);
                    }
                }
            };
            /// public: getData()
            //---- this has explict "get" signature because we need to specify "isNewDataSet" for setter ----
            dataAnimMgrClass.prototype.getData = function () {
                return this._data;
            };
            /// remove all shapes from SVG canvas; clear all structures of previous shapes.
            dataAnimMgrClass.prototype.clear = function () {
                var existingShapes = this._updateShapes.concat(this._enterShapes);
                if (this._exitShapes.length > 0) {
                    //---- about to overwrite exit shapes - remove them now ----
                    this.removeExitShapesNow(-1);
                }
                this._enterShapes = [];
                this._exitShapes = [];
                this._updateShapes = [];
                this._enterDataPairs = [];
                this._keys = [];
                this._exitShapes = existingShapes;
                existingShapes = [];
                if (!this._transition) {
                    //---- keep it simple and remove them all now ----
                    if (this._exitShapes.length > 0) {
                        this.removeExitShapesNow(-1);
                    }
                }
            };
            dataAnimMgrClass.prototype.updateWithoutDataChange = function () {
                var existingShapes = this._updateShapes.concat(this._enterShapes);
                if (this._exitShapes.length > 0) {
                    //---- about to overwrite exit shapes - remove them now ----
                    this.removeExitShapesNow(-1);
                }
                this._enterShapes = [];
                this._exitShapes = [];
                this._enterDataPairs = [];
                this._updateShapes = existingShapes;
            };
            dataAnimMgrClass.prototype.createMultipleShapes = function (appendStrOrFunc, seriesCount, enterDataPairs) {
                var elements = [];
                var start = vp.utils.now();
                var count = seriesCount * enterDataPairs.length;
                var needAppend = true;
                if (appendStrOrFunc == null) {
                    appendStrOrFunc = this._appendNameOrCallback;
                }
                if (vp.utils.isFunction(appendStrOrFunc)) {
                    for (var s = 0; s < seriesCount; s++) {
                        for (var i = 0; i < enterDataPairs.length; i++) {
                            var pair = enterDataPairs[i];
                            var elem = appendStrOrFunc(pair.dataItem, pair.dataIndex, s, this._data);
                            elements.push(elem);
                        }
                    }
                }
                else if (appendStrOrFunc) {
                    //if (this._container.append)      
                    //{
                    //    //---- perf win for CREATE and APPEND ----
                    //    needAppend = false;
                    //    //---- create and append CANVAS elements ----
                    //    for (var i = 0; i < count; i++)
                    //    {
                    //        var elem = this._container.append(this._appendNameOrCallback);
                    //        elements.push(elem);
                    //    }
                    //}
                    //else
                    {
                        //---- perf win for CREATE ----
                        elements = vp.dom.createElements(this._container, appendStrOrFunc, count);
                        var createElapsed = vp.utils.now() - start;
                        var start = vp.utils.now();
                    }
                }
                if (needAppend) {
                    //---- perf win for APPEND ----
                    vp.dom.appendElements(this._container, elements);
                    var appendElapsed = vp.utils.now() - start;
                }
                return elements;
            };
            /// private: createShape()
            dataAnimMgrClass.prototype.createShape = function (appendStrOrFunc, dataRecord, index, key, seriesIndex) {
                var uelem = null;
                if (appendStrOrFunc == null) {
                    appendStrOrFunc = this._appendNameOrCallback;
                }
                if (vp.utils.isFunction(appendStrOrFunc)) {
                    uelem = appendStrOrFunc(dataRecord, index, seriesIndex, this._data);
                }
                else if (appendStrOrFunc) {
                    uelem = vp.dom.createElement(this._container, appendStrOrFunc);
                }
                if (uelem != null) {
                    vp.dom.append(this._container, uelem);
                    // "dataItem" should look like: { dataId: dd, shapeId: ss, key: kk, data: dataRecord }
                    var dataItemEx = { dataId: 1, shapeId: seriesIndex, key: key, data: dataRecord };
                    uelem.dataItem = dataItemEx;
                    uelem.dataIndex = index;
                }
                return uelem;
            };
            dataAnimMgrClass.prototype.createEnterShapesIfNeeded = function (seriesCount, appendStrOrFunc) {
                if (this._enterDataPairs.length > 0) {
                    var start = vp.utils.now();
                    var newShapes = this.createMultipleShapes(appendStrOrFunc, seriesCount, this._enterDataPairs);
                    var multiElapsed = vp.utils.now() - start;
                    this.processNewlyCreatedShapes(newShapes, this._enterDataPairs, this._seriesCount);
                    this._enterDataPairs = [];
                    this._enterShapes = this._enterShapes.concat(newShapes);
                }
            };
            dataAnimMgrClass.prototype.processNewlyCreatedShapes = function (newShapes, pairList, seriesCount, seriesIndex) {
                var shapeIndex = 0;
                var start = vp.utils.now();
                //---- create shapes for all series NOW ----
                for (var s = 0; s < seriesCount; s++) {
                    //---- loop thru all ENTER pair objects ----
                    for (var i = 0; i < pairList.length; i++) {
                        var pair = pairList[i];
                        var pk = this.getPrimaryKey(pair.dataItem, pair.dataIndex);
                        var si = (seriesIndex === undefined) ? s : seriesIndex;
                        var uelem = newShapes[shapeIndex++];
                        //var uelem = createShape(appendStrOrFunc, pair.dataItem, pair.dataIndex, pk, s);
                        //enterShapes.push(uelem);
                        // "dataItem" should look like: { dataId: dd, shapeId: ss, key: kk, data: dataRecord }
                        var dataItemEx = { dataId: 1, shapeId: si, key: pk, data: pair.dataItem };
                        uelem.dataItem = dataItemEx;
                        uelem.dataIndex = pair.dataIndex;
                        var key = this.getFullKey(pair.dataItem, pair.dataIndex, si, pk);
                        this.addKey(uelem, key);
                    }
                }
                var propsElapsed = vp.utils.now() - start;
            };
            dataAnimMgrClass.prototype.addKey = function (uelem, key) {
                this._keys[key] = uelem;
            };
            dataAnimMgrClass.prototype.deleteKey = function (uelem, key) {
                delete this._keys[key];
            };
            dataAnimMgrClass.prototype.onAnimationComplete = function (anim, wasCancelled, changeType) {
                var elapsed = vp.utils.now() - this._animStartTime;
                this._animFPS = Math.round(anim.frameCount() / (elapsed / 1000));
                if (this._statsCallback) {
                    var count = this._enterShapes.length + this._updateShapes.length;
                    this._statsCallback(this._animFPS, count, elapsed);
                }
            };
            dataAnimMgrClass.prototype.removeExitShapesNow = function (seriesIndex) {
                //---- no animation, so remove EXIT shapes now ----
                //---- go thru list backwards, removing entries as we find seriesIndex matches ----
                for (var i = this._exitShapes.length - 1; i >= 0; i--) {
                    var uelem = this._exitShapes[i];
                    if ((seriesIndex == -1) || (vp.dom.shapeId(uelem) == seriesIndex)) {
                        vp.dom.remove(uelem);
                        this._exitShapes.removeAt(i);
                    }
                }
                //exitShapes = [];
                var abc = 9;
            };
            dataAnimMgrClass.prototype.lookupElement = function (dataItem, dataIndex, seriesIndex) {
                var key = this.getFullKey(dataItem, dataIndex, seriesIndex);
                return this._keys[key];
            };
            /// private: getPrimaryKey()
            dataAnimMgrClass.prototype.getPrimaryKey = function (dataItem, dataIndex) {
                var key = dataIndex;
                if (dataItem && dataItem.key) {
                    key = dataItem.key;
                }
                else if (this._pkCallback) {
                    if (vp.utils.isString(this._pkCallback)) {
                        if (dataItem) {
                            key = dataItem[this._pkCallback];
                        }
                    }
                    else {
                        key = this._pkCallback(dataItem, dataIndex);
                    }
                }
                return key;
            };
            /// private: getFullKey()
            dataAnimMgrClass.prototype.getFullKey = function (dataItem, dataIndex, seriesIndex, key) {
                if (!key) {
                    key = this.getPrimaryKey(dataItem, dataIndex);
                }
                key += "+" + seriesIndex;
                return key;
            };
            /// public property: container
            dataAnimMgrClass.prototype.container = function (value) {
                if (arguments.length === 0) {
                    return this._container;
                }
                //---- setter ----
                this._container = ((value) && (value.length)) ? value[0] : value;
                return this;
            };
            // public property: dataId
            dataAnimMgrClass.prototype.dataId = function (value) {
                if (arguments.length === 0) {
                    return this._dataId;
                }
                //---- setter ----
                this._dataId = value;
                return this;
            };
            dataAnimMgrClass.prototype.keyFunc = function (value) {
                if (arguments.length === 0) {
                    return this._pkCallback;
                }
                //---- setter ----
                this._pkCallback = value;
                return this;
            };
            /// public: getExistingShapes()
            dataAnimMgrClass.prototype.getExistingShapes = function () {
                return this._enterShapes.concat(this._updateShapes);
            };
            dataAnimMgrClass.prototype.statsCallback = function (value) {
                this._statsCallback = value;
                return this;
            };
            return dataAnimMgrClass;
        }());
        animation.dataAnimMgrClass = dataAnimMgrClass;
    })(animation = vp.animation || (vp.animation = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// effects.ts.  Copyright (c) 2016 Microsoft Corporation.
///              part of the vuePlotCore library - support for enter/exit animation effects.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var animation;
    (function (animation) {
        //---- animate opacity ----
        (function (FadeType) {
            FadeType[FadeType["none"] = 0] = "none";
            FadeType[FadeType["fade"] = 1] = "fade";
        })(animation.FadeType || (animation.FadeType = {}));
        var FadeType = animation.FadeType;
        //---- move shape to/from specified location ----
        (function (SlideLoc) {
            SlideLoc[SlideLoc["none"] = 0] = "none";
            SlideLoc[SlideLoc["left"] = 1] = "left";
            SlideLoc[SlideLoc["top"] = 2] = "top";
            SlideLoc[SlideLoc["right"] = 3] = "right";
            SlideLoc[SlideLoc["bottom"] = 4] = "bottom";
        })(animation.SlideLoc || (animation.SlideLoc = {}));
        var SlideLoc = animation.SlideLoc;
        (function (GrowOrigin) {
            GrowOrigin[GrowOrigin["none"] = 0] = "none";
            GrowOrigin[GrowOrigin["left"] = 1] = "left";
            GrowOrigin[GrowOrigin["top"] = 2] = "top";
            GrowOrigin[GrowOrigin["right"] = 3] = "right";
            GrowOrigin[GrowOrigin["bottom"] = 4] = "bottom";
            GrowOrigin[GrowOrigin["center"] = 5] = "center";
        })(animation.GrowOrigin || (animation.GrowOrigin = {}));
        var GrowOrigin = animation.GrowOrigin;
        //---- make an effect object ----
        function makeEffects(fadeType, slideLoc, growOrigin, rotateAngle, rotateCx, rotateCy) {
            var effect;
            if (arguments.length == 1 && vp.utils.isString(fadeType)) {
                var str = fadeType;
                fadeType = FadeType.none;
                if (str == "fade") {
                    fadeType = FadeType.fade;
                }
                else if (str.startsWith("slide")) {
                    var loc = str.substr(5).toLowerCase();
                    slideLoc = SlideLoc[loc];
                }
                else if (str.startsWith("grow")) {
                    var loc = str.substr(4).toLowerCase();
                    growOrigin = GrowOrigin[loc];
                }
                effect =
                    {
                        fadeType: fadeType, slideLoc: slideLoc, growOrigin: growOrigin,
                        rotateAngle: rotateAngle, rotateCx: rotateCx, rotateCy: rotateCy
                    };
            }
            else if (fadeType == null || vp.utils.isNumber(fadeType)) {
                effect =
                    {
                        fadeType: fadeType, slideLoc: slideLoc, growOrigin: growOrigin,
                        rotateAngle: rotateAngle, rotateCx: rotateCx, rotateCy: rotateCy
                    };
            }
            else if (arguments.length == 1 && vp.utils.isObject(fadeType)) {
                //---- its already an effects object ----
                effect = fadeType;
            }
            else {
                throw "Error - first arg to makeEffect must be a string, FadeType, or effects object";
            }
            return effect;
        }
        animation.makeEffects = makeEffects;
    })(animation = vp.animation || (vp.animation = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// numberAnimation.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library 
///   - animates a numeric property.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var animation;
    (function (animation) {
        //---- class: numberAnimation ----
        var numberAnimation = (function () {
            function numberAnimation(parent, element, attributeName, fromValue, toValue, isCssProperty) {
                //vp.utils.trace("ctr", "numberAnimation");
                this.parent = parent;
                this.element = element;
                this.name = attributeName;
                var from = fromValue;
                var to = toValue;
                this.isCssProperty = isCssProperty;
                //---- remove "px" from value ----
                if ((vp.utils.isString(from)) && (from.endsWith("px"))) {
                    from = from.substr(0, from.length - 2);
                }
                //---- remove "px" from value ----
                if ((vp.utils.isString(to)) && (to.endsWith("px"))) {
                    to = to.substr(0, to.length - 2);
                }
                this.from = +from;
                this.to = +to;
            }
            /// private: getAnimatedValue(percent)
            numberAnimation.prototype.getAnimatedValue = function (percent) {
                var value = this.from + percent * (this.to - this.from);
                return value;
            };
            numberAnimation.prototype.isStyled = function () {
                return this.isCssProperty;
            };
            /// public: animateFrame(percent)
            numberAnimation.prototype.animateFrame = function (percent) {
                var value = this.getAnimatedValue(percent);
                var element = this.element;
                var attributeName = this.name;
                if (this.isCssProperty) {
                    if ((attributeName != "z-index") && (attributeName != "opacity")) {
                        value = value + "px";
                    }
                    element.style[attributeName] = value;
                }
                else if (element[attributeName] == null) {
                    if (value == 0) {
                        var a = 4242;
                    }
                    element.setAttribute(attributeName, value);
                }
                else {
                    //---- normal case - set using "baseVal.value" ----
                    if (element.rootContainer) {
                        //---- its a canvas element ----
                        //element[attributeName] = value;
                        //element.markDrawNeeded();
                        element.setAttribute(attributeName, value);
                    }
                    else if (element.setAttribute) {
                        element.setAttribute(attributeName, value);
                    }
                    else {
                        //---- its an SVG/HTML element ----
                        if (element[attributeName].baseVal) {
                            element[attributeName].baseVal.value = value;
                        }
                        else {
                            element[attributeName] = value;
                        }
                    }
                }
            };
            return numberAnimation;
        }());
        animation.numberAnimation = numberAnimation;
    })(animation = vp.animation || (vp.animation = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// pointsAnimation.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library
///  - animates between 2 "points" strings (for a line or polygon element).
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var animation;
    (function (animation) {
        //---- class: pointsAnimation ----
        var pointsAnimation = (function () {
            function pointsAnimation(parent, element, attributeName, fromPoints, toPoints) {
                //vp.utils.trace("ctr", "pointsAnimation");
                this.element = element;
                this.parent = parent;
                this.attributeName = attributeName;
                if (fromPoints === null) {
                    fromPoints = "";
                }
                if (toPoints === null) {
                    toPoints = "";
                }
                //---- trim FROM POINTS empty space / entry ----
                fromPoints = fromPoints.trim();
                if (fromPoints.endsWith(",")) {
                    fromPoints = fromPoints.substr(0, fromPoints.length - 1).trim();
                }
                //---- trim TO POINTS empty space / entry ----
                toPoints = toPoints.trim();
                if (toPoints.endsWith(",")) {
                    toPoints = toPoints.substr(0, toPoints.length - 1).trim();
                }
                var fromPairs = fromPoints.split(' ');
                var toPairs = toPoints.split(' ');
                if (fromPairs.length != toPairs.length) {
                    //---- no way to reliably animate between these - just set the value now and don't do anything during the animation ----
                    vp.dom.attr(element, attributeName, toPoints, true);
                }
                else {
                    var xFrom = [];
                    var yFrom = [];
                    var xTo = [];
                    var yTo = [];
                    var diffFound = false;
                    for (var i = 0; i < fromPairs.length; i++) {
                        var fromPair = fromPairs[i];
                        var xParts = fromPair.split(",");
                        xFrom.push(+xParts[0]);
                        yFrom.push(+xParts[1]);
                        var toPair = toPairs[i];
                        var yParts = toPair.split(",");
                        xTo.push(+yParts[0]);
                        yTo.push(+yParts[1]);
                        if (xFrom != xTo || yFrom != yTo) {
                            diffFound = true;
                        }
                    }
                    if (!diffFound) {
                        vp.utils.error("pointsAnimation: from/to points are the same");
                    }
                    if (!xFrom.length || !yFrom.length) {
                        vp.utils.error("pointsAnimation: 'from' is not a valid points string");
                    }
                    if (!xTo.length || !yTo.length) {
                        vp.utils.error("pointsAnimation: 'to' is not a valid points string");
                    }
                    this.xFrom = xFrom;
                    this.yFrom = yFrom;
                    this.xTo = xTo;
                    this.yTo = yTo;
                }
            }
            /// private: getAnimateCalue(percent)
            pointsAnimation.prototype.getAnimatedValue = function (percent) {
                var xFrom = this.xFrom;
                var yFrom = this.yFrom;
                var xTo = this.xTo;
                var yTo = this.yTo;
                var value = "";
                for (var i = 0; i < xFrom.length; i++) {
                    //var x = Math.round(xFrom[i] + percent * (xTo[i] - xFrom[i]));
                    //var y = Math.round(yFrom[i] + percent * (yTo[i] - yFrom[i]));
                    var x = xFrom[i] + percent * (xTo[i] - xFrom[i]);
                    var y = yFrom[i] + percent * (yTo[i] - yFrom[i]);
                    if (i == 0) {
                        value = x + "," + y;
                    }
                    else {
                        value += " " + x + "," + y;
                    }
                }
                return value;
            };
            /// public: animateFrame(percent)
            pointsAnimation.prototype.animateFrame = function (percent) {
                //---- make sure at least 1 "part" exists ----
                if (this.xTo && this.xTo.length) {
                    var value = this.getAnimatedValue(percent);
                    this.element.setAttribute(this.attributeName, value);
                }
            };
            return pointsAnimation;
        }());
        animation.pointsAnimation = pointsAnimation;
    })(animation = vp.animation || (vp.animation = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// transformAnimation.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library 
///   - animates a transform (scale, translation, rotation).
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var animation;
    (function (animation) {
        //---- class: transformAnimation ----
        var transformAnimation = (function () {
            function transformAnimation(parent, element) {
                //vp.utils.trace("ctr", "transformAnimation");
                this.parts = [];
                this.parent = parent;
                this.element = element;
            }
            /// public.
            transformAnimation.prototype.makeTransform = function (name, fromValue, toValue, cx, cy) {
                //---- remove any previous PART using this name ----
                this.removePart(name);
                var part = { name: name, from: fromValue, to: toValue, cx: cx, cy: cy };
                this.parts.push(part);
            };
            transformAnimation.prototype.removePart = function (name) {
                for (var i = this.parts.length - 1; i >= 0; i--) {
                    var part = this.parts[i];
                    if (part.name == name) {
                        this.parts.removeAt(i);
                        vp.utils.debug("transformAnimation.removePart: removed name=" + name);
                        break;
                    }
                }
            };
            /// private.
            transformAnimation.prototype.getAnimatedValue = function (percent) {
                //---- build transform string from parts[] ----
                var str = "";
                var parts = this.parts;
                for (var i = 0; i < parts.length; i++) {
                    var part = parts[i];
                    var nextPartName = (i < parts.length - 1) ? parts[i + 1].name : "";
                    var from = +part.from;
                    var to = +part.to;
                    var value = from + percent * (to - from);
                    if (part.name == "scale.x") {
                        var x = value;
                        var y = 1;
                        if (nextPartName == "scale.y") {
                            i++;
                            var nextPart = parts[i];
                            y = +nextPart.from + percent * (+nextPart.to - +nextPart.from);
                        }
                        if (vp.utils.isDefined(part.cx)) {
                            //---- center the scaling at cx, cy ----
                            str += "translate( " + (-part.cx * (x - 1)) + ", " + (-part.cy * (y - 1)) + ") ";
                        }
                        str += "scale(" + x + " " + y + ") ";
                    }
                    else if (part.name == "scale.y") {
                        if (vp.utils.isDefined(part.cx)) {
                            //---- center the scaling at cx, cy ----
                            str += "translate(0 " + (-part.cy * (value - 1)) + ") ";
                        }
                        str += "scale(1 " + value + ") ";
                    }
                    else if (part.name == "translate.x") {
                        var x = value;
                        var y = 0;
                        if (nextPartName == "translate.y") {
                            i++;
                            var nextPart = parts[i];
                            y = +nextPart.from + percent * (+nextPart.to - +nextPart.from);
                        }
                        str += "translate(" + x + " " + y + ") ";
                    }
                    else if (part.name == "translate.y") {
                        str += "translate(0 " + value + ") ";
                    }
                    else if (part.name == "rotate") {
                        str += "rotate(" + value;
                        if (vp.utils.isDefined(part.cx)) {
                            str += " " + part.cx + " " + part.cy;
                        }
                        str += ") ";
                    }
                }
                return str;
            };
            /// public.
            transformAnimation.prototype.animateFrame = function (percent) {
                var transformStr = this.getAnimatedValue(percent).trim();
                this.element.setAttribute("transform", transformStr);
                //if (percent == 1)
                //{
                //    vp.utils.debug("transformAnimation.animateFrame: set transform=" + transformStr);
                //}
            };
            return transformAnimation;
        }());
        animation.transformAnimation = transformAnimation;
    })(animation = vp.animation || (vp.animation = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// transition.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///    - holds animation settings that can be passed to mark.update() functions.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var animation;
    (function (animation) {
        /** Supports data-based generation of SVG text primitives.  Can be used with animations.  Core function
        is "update()". */
        var transitionClass = (function () {
            function transitionClass(duration, easeObj, delay, enterEffect, exitEffect, id) {
                //vp.utils.trace("ctr", "transition");
                if (duration === void 0) { duration = 750; }
                if (easeObj === void 0) { easeObj = true; }
                if (delay === void 0) { delay = 0; }
                if (enterEffect === void 0) { enterEffect = "slideRight"; }
                if (exitEffect === void 0) { exitEffect = "slideLeft"; }
                if (id === void 0) { id = ""; }
                this._activeClients = [];
                this._enterAnim = vp.animation.createAnimation(null, duration, easeObj, null, delay);
                this._updateAnim = vp.animation.createAnimation(null, duration, easeObj, null, delay);
                this._exitAnim = vp.animation.createAnimation(null, duration, easeObj, null, delay);
                this._enterEffect = vp.animation.makeEffects(enterEffect);
                this._exitEffect = vp.animation.makeEffects(exitEffect);
                this._id = id;
                this.hookEnterCompleted();
                this.hookUpdateCompleted();
                this.hookExitCompleted();
            }
            transitionClass.prototype.hookEnterCompleted = function () {
                var _this = this;
                if (this._enterAnim) {
                    this._enterAnim.onAnimationComplete(function (anim, wasCancelled) {
                        if (!wasCancelled) {
                            var count = _this._enterAnim.children().length;
                            if (count > 0) {
                                vp.utils.debug("anim complete: id=" + _this._id + ", changeType=ENTER" +
                                    ", count=" + count);
                            }
                        }
                    });
                }
            };
            transitionClass.prototype.hookUpdateCompleted = function () {
                var _this = this;
                if (this._updateAnim) {
                    this._updateAnim.onAnimationComplete(function (anim, wasCancelled) {
                        if (!wasCancelled) {
                            var count = _this._updateAnim.children().length;
                            if (count > 0) {
                                vp.utils.debug("anim complete: id=" + _this._id + ", changeType=UPDATE" +
                                    ", count=" + count);
                            }
                        }
                    });
                }
            };
            transitionClass.prototype.hookExitCompleted = function () {
                var _this = this;
                if (this._exitAnim) {
                    this._exitAnim.onAnimationComplete(function (anim, wasCancelled) {
                        if (!wasCancelled) {
                            var count = _this._exitAnim.children().length;
                            if (count > 0) {
                                vp.utils.debug("anim complete: id=" + _this._id + ", changeType=EXIT" +
                                    ", count=" + count);
                            }
                        }
                    });
                }
            };
            transitionClass.prototype.addClient = function (clientObj) {
                this._activeClients.push(clientObj);
            };
            /** With this call, the first associated client to have existing animations will clear all of the animations. */
            transitionClass.prototype.clearAnimations = function (clientObj) {
                if (this._activeClients.indexOf(clientObj) > -1) {
                    var enterCount = this._enterAnim.children().length;
                    var updateCount = this._updateAnim.children().length;
                    var exitCount = this._exitAnim.children().length;
                    var total = enterCount + updateCount + exitCount;
                    if (total > 0) {
                    }
                    this._activeClients = [];
                    this._enterAnim.stop();
                    this._updateAnim.stop();
                    this._exitAnim.stop();
                }
                this.addClient(clientObj);
            };
            transitionClass.prototype.enter = function (value) {
                if (arguments.length === 0) {
                    return this._enterAnim;
                }
                this._enterAnim = value;
                this.hookEnterCompleted();
                return this;
            };
            transitionClass.prototype.exit = function (value) {
                if (arguments.length === 0) {
                    return this._exitAnim;
                }
                this._exitAnim = value;
                this.hookExitCompleted();
                return this;
            };
            transitionClass.prototype.update = function (value) {
                if (arguments.length === 0) {
                    return this._updateAnim;
                }
                this._updateAnim = value;
                this.hookUpdateCompleted();
                return this;
            };
            transitionClass.prototype.enterEffect = function (value) {
                if (arguments.length === 0) {
                    return this._enterEffect;
                }
                this._enterEffect = vp.animation.makeEffects(value);
                return this;
            };
            transitionClass.prototype.exitEffect = function (value) {
                if (arguments.length === 0) {
                    return this._exitEffect;
                }
                this._exitEffect = vp.animation.makeEffects(value);
                return this;
            };
            return transitionClass;
        }());
        animation.transitionClass = transitionClass;
        function createTransition(duration, easeObj, delay, enterEffect, exitEffect, id) {
            if (duration === void 0) { duration = 750; }
            if (easeObj === void 0) { easeObj = true; }
            if (delay === void 0) { delay = 0; }
            if (enterEffect === void 0) { enterEffect = "slideRight"; }
            if (exitEffect === void 0) { exitEffect = "slideLeft"; }
            if (id === void 0) { id = ""; }
            return new transitionClass(duration, easeObj, delay, enterEffect, exitEffect, id);
        }
        animation.createTransition = createTransition;
    })(animation = vp.animation || (vp.animation = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// axisHelperBase.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var chartFrame;
    (function (chartFrame) {
        /** The base class for the 4 axis classes.  This class holds drawing data & properties & provides getter/setter access to them.  */
        var axisBaseClass = (function () {
            function axisBaseClass(container, axisDataOrScale, useWebGl, isCrisp, location) {
                this._ellipsesBounds = null;
                this._axisSize = 100;
                this._expandSpace = 0;
                //_rootGroup: any;
                this._positiveAutoRotation = true;
                this._firstBuild = true;
                this._lastYTickBox = 0;
                this._lastXTickBox = 0;
                this._minWidth = 0;
                this._minHeight = 0;
                //---- used by generate routines ----
                this._offset = 0;
                this._maxTextWidth = 0;
                this._maxTextHeight = 0;
                //---- data ----
                this._name = "";
                //---- options----
                this._isAxisLineVisible = true;
                this._ticksOnInside = false;
                this._labelOverflow = LabelOverflow.overWrite;
                this._labelRotation = LabelRotation.none;
                this._nameRotation = LabelRotation.none;
                this._onShade = null; // user callback for shading of any part
                //---- label sizes ----
                /** minimum spacing between largest label and avail space per label before overflow algorithm applies, for 0, 45, and 90 degree rotations. */
                this._minLabelSpacing = [4, -2, -6];
                /** when set, limits the size of the label space perpendicular to the axis.  */
                this._maxPerpendicularSize = undefined;
                //---- measurements ----
                this._labelSizes = null;
                this._szMaxText = { width: 0, height: 0 }; // max measured text size
                this._availPixelsPerLabel = 0;
                this._actualLabelRotation = 0;
                this._measuredSize = 0;
                this._isLabelsVisible = true;
                this._isTicksVisible = true;
                this._isTickBoxesVisible = true;
                this._hideInteriorLabels = false;
                this._isMinorTicksVisible = false;
                var className = "vpxAxis " + LabelLocation[location] + "Axis";
                this._rootMark = vp.marks.createGroupMark(container, className);
                this._rootElem = this._rootMark.rootElem();
                this._location = location;
                var axisData;
                if (axisDataOrScale instanceof chartFrame.axisDataClass) {
                    axisData = axisDataOrScale;
                }
                else {
                    axisData = chartFrame.createAxisData(axisDataOrScale);
                }
                this._axisData = axisData;
                this.buildDefaultDrawingParams();
                vp.select(this._rootElem)
                    .addClass("vpxAxis");
                this._isCrisp = isCrisp;
                //---- use the groupElem that markBase created as our root elem ----
                var tempParent = this._rootElem;
                var svg = null;
                var fakeLabel = null;
                var fakeNameLabel = null;
                //---- always append this for measuring ----
                if (tempParent.tagName == "CANVAS" || tempParent.rootContainer) {
                    var svg = vp.select(document.body).append("svg")
                        .addClass("vpxAxis")
                        .css("opacity", "0")
                        .id("fakeSvgForMeasuring");
                    this._fakeSvg = svg;
                    fakeLabel = this.createFakeTextElement(svg);
                    fakeNameLabel = this.createFakeNameElement(svg);
                }
                else {
                    fakeLabel = this.createFakeTextElement(vp.select(tempParent));
                    fakeNameLabel = this.createFakeNameElement(vp.select(tempParent));
                }
                //---- leave space for elippses ----
                fakeLabel.text("...");
                var rc = this.bounds(fakeLabel[0]); //.getBBox();
                this._ellipsesBounds = rc;
                this._fakeLabel = fakeLabel[0];
                this._fakeNameLabel = fakeNameLabel[0];
            }
            axisBaseClass.prototype.bounds = function (elem) {
                var rc = vp.dom.getBounds(elem);
                var svgRc = { x: rc.left, y: rc.top, width: rc.width, height: rc.height };
                return svgRc;
            };
            axisBaseClass.prototype.createFakeTextElement = function (parent) {
                var fakeLabel = parent.append("text")
                    .addClass("vpxAxisLabel")
                    .id("fakeLabelForMeasuring")
                    .css("opacity", "0")
                    .attr("x", 0)
                    .attr("y", 0);
                return fakeLabel;
            };
            axisBaseClass.prototype.createFakeNameElement = function (parent) {
                var fakeLabel = parent.append("text")
                    .addClass("vpxAxisName")
                    .id("fakeNameForMeasuring")
                    .css("opacity", "0")
                    .attr("x", 0)
                    .attr("y", 0);
                return fakeLabel;
            };
            axisBaseClass.prototype.hide = function (transition) {
                if (transition === undefined) {
                    transition = this._transition;
                }
                this._rootMark.hide(transition);
            };
            axisBaseClass.prototype.show = function (transition, showValue) {
                if (transition === undefined) {
                    transition = this._transition;
                }
                if (showValue === false) {
                    this._rootMark.hide(transition);
                }
                else {
                    this._rootMark.show(transition);
                    if (this._firstBuild) {
                        //---- do a build without animation so that the first show call shows a valid axis ----
                        this.build(null);
                    }
                }
            };
            axisBaseClass.prototype.isVisible = function () {
                return this._rootMark.isVisible();
            };
            axisBaseClass.prototype.buildDefaultDrawingParams = function () {
                this._drawingParams =
                    {
                        //tickLength: 8, minorTickLength: 6, labelToTickPadding: 4, labelToNamePadding: 10, startPadding: 0,
                        tickLength: 12, minorTickLength: 6, labelToTickPadding: 4, labelToNamePadding: 10, startPadding: 0,
                        endPadding: 0, maxPerpendicularSize: 200,
                        axisLine: {}, label: {}, minorTick: {}, tick: {}, tickBox: {}, name: {}
                    };
            };
            axisBaseClass.prototype.clearMeasurements = function () {
                this.labelSizes(null);
                this.labelStrings(null);
            };
            axisBaseClass.prototype.build = function (transition, measureOnly, clearMeasurements) {
                if (clearMeasurements === void 0) { clearMeasurements = true; }
                if (transition === undefined) {
                    transition = this._transition;
                }
                if (clearMeasurements) {
                    this.clearMeasurements();
                }
                //---- apply drawing params to sub-marks ----
                var dp = this._drawingParams;
                this._axisLineMark.drawingParams(dp ? dp.axisLine : null);
                this._tickMark.drawingParams(dp ? dp.tick : null);
                this._tickBox.drawingParams(dp ? dp.tickBox : null);
                this._minorTickMark.drawingParams(dp ? dp.minorTick : null);
                this._labelMark.drawingParams(dp ? dp.label : null);
                this._nameMark.drawingParams(dp ? dp.name : null);
                //---- apply NAME params to name mark ----
                //---- note that LABEL params are applied during "measureAllLabels()" ----
                var drawingParams = this._nameMark.drawingParams();
                vp.marks.applyTextParams(this._fakeNameLabel, drawingParams);
                vp.dom.css(this._fakeNameLabel, "opacity", 0); // ensure fake remains hidden
                var breaks = this._axisData.getActualBreaks();
                var labels = (this._isLabelsVisible) ? this._axisData.getActualLabels(breaks) : [];
                var off = this._axisData.getOffsets(breaks);
                var tickOffsets = off.tickOffsets;
                var labelOffsets = off.labelOffsets;
                var minorOffsets = [];
                if (this._isMinorTicksVisible) {
                    minorOffsets = this._axisData.getActualMinorOffsets(breaks);
                }
                if (!this._isTicksVisible) {
                    tickOffsets = [];
                    minorOffsets = [];
                }
                if (!this._isLabelsVisible) {
                    labelOffsets = [];
                }
                else if (this._hideInteriorLabels) {
                    if (labelOffsets.length > 2) {
                        //---- use first and last ----
                        labelOffsets = [labelOffsets[0], labelOffsets[labelOffsets.length - 1]];
                        labels = [labels[0], labels[labels.length - 1]];
                    }
                }
                this._tickOffsets = tickOffsets;
                this._minorTickOffsets = minorOffsets;
                this._labelOffsets = labelOffsets;
                this._labelStrings = labels;
                this._expandSpace = this._axisData._scale.expandSpace();
                this._breakValues = breaks;
                this
                    .shadeMarks(transition, vp.data, 0, true, null, measureOnly);
                this._firstBuild = false;
            };
            ///
            /// General Note: we must call generate on each mark, even if we don't want to draw the objects.
            ///
            axisBaseClass.prototype.generateHorizontalName = function (generate, transition, isRightOrBottomAxis) {
                //---- generate NAME ----
                var drawName = (this._name != null && this._name != "");
                if (drawName && isRightOrBottomAxis) {
                    this._offset += this._drawingParams.labelToNamePadding;
                }
                if (generate) {
                    this._nameMark.generate(drawName, transition);
                }
                //---- use this estimated width on both generate and measure passes (for consistent results) ----
                this._maxTextWidth = this.getNameWidth();
                if (drawName) {
                    if (isRightOrBottomAxis) {
                        this._offset += this._maxTextWidth;
                    }
                    else {
                        this._offset += this._maxTextWidth + this._drawingParams.labelToNamePadding;
                    }
                }
            };
            axisBaseClass.prototype.generateVerticalName = function (generate, transition, isRightOrBottomAxis) {
                //---- generate NAME ----
                var drawName = (this._name != null && this._name != "");
                if (drawName && isRightOrBottomAxis) {
                    this._offset += this._drawingParams.labelToNamePadding;
                }
                if (generate) {
                    this._nameMark.generate(drawName, transition);
                }
                //---- use this estimated height on both generate and measure passes (for consistent results) ----
                this._maxTextHeight = this.getNameHeight();
                if (drawName) {
                    if (isRightOrBottomAxis) {
                        this._offset += this._maxTextHeight;
                    }
                    else {
                        this._offset += this._maxTextHeight + this._drawingParams.labelToNamePadding;
                    }
                }
            };
            axisBaseClass.prototype.generateHorizontalLabels = function (generate, transition, isRightOrBottomAxis) {
                var _this = this;
                //---- measure labels ----
                if (!this._labelSizes) {
                    this._szMaxText = this.measureAllLabels(this._labelStrings);
                }
                //---- join label data and GENERATE (even if not drawing labels) ----
                var labelData = [];
                if (this._labelSizes) {
                    labelData = this._labelOffsets.map(function (data, index) {
                        return { offset: data, label: _this._labelStrings[index], breakValue: _this._breakValues[index] };
                    });
                }
                //---- draw labels ----
                this._maxTextWidth = 0;
                var drawLabels = (labelData.length > 0);
                if (drawLabels && isRightOrBottomAxis) {
                    this._offset += this._drawingParams.labelToTickPadding;
                }
                if (generate) {
                    this._labelMark.generate(labelData, transition);
                }
                //---- use this estimated width on both generate and measure passes (for consistent results) ----
                this._maxTextWidth = this.getMaxLabelSize(true).width;
                if (drawLabels) {
                    if (isRightOrBottomAxis) {
                        this._offset += this._maxTextWidth;
                    }
                    else {
                        this._offset += this._maxTextWidth + this._drawingParams.labelToTickPadding;
                    }
                }
            };
            axisBaseClass.prototype.generateVerticalLabels = function (generate, transition, isRightOrBottomAxis) {
                var _this = this;
                //---- measure labels ----
                if (!this._labelSizes) {
                    this._szMaxText = this.measureAllLabels(this._labelStrings);
                }
                //---- join label data and GENERATE (even if not drawing labels) ----
                var labelData = [];
                if (this._labelSizes) {
                    labelData = this._labelOffsets.map(function (data, index) {
                        return { offset: data, label: _this._labelStrings[index], breakValue: _this._breakValues[index] };
                    });
                }
                //---- draw labels ----
                this._maxTextHeight = 0;
                var drawLabels = (labelData.length > 0);
                if (drawLabels && isRightOrBottomAxis) {
                    this._offset += this._drawingParams.labelToTickPadding;
                }
                if (generate) {
                    this._labelMark.generate(labelData, transition);
                }
                //---- use this estimated height on both generate and measure passes (for consistent results) ----
                this._maxTextHeight = this.getMaxLabelSize(false).height;
                if (drawLabels) {
                    if (isRightOrBottomAxis) {
                        this._offset += this._maxTextHeight;
                    }
                    else {
                        this._offset += this._maxTextHeight + this._drawingParams.labelToTickPadding;
                    }
                }
            };
            axisBaseClass.prototype.generateTicks = function (generate, transition, isRightOrBottomAxis) {
                //---- update offsets for ticks ----
                var drawTicks = ((this._tickOffsets && this._tickOffsets.length) ||
                    (this._minorTickOffsets && this._minorTickOffsets.length));
                if (!isRightOrBottomAxis) {
                    if (this._ticksOnInside || (!drawTicks)) {
                        this._offset += 0;
                    }
                    else {
                        this._offset += this._drawingParams.tickLength;
                    }
                }
                //---- draw primary and minor TICKS  ----
                this.hideTicksIfTooMany();
                if (generate) {
                    this._tickMark.generate(this._tickOffsets, transition);
                    if (this._isTickBoxesVisible) {
                        var breaks = this._axisData.getActualBreaks();
                        var tickBoxData = this._tickOffsets.map(function (data, index) {
                            return { index: index, tickOffset: data, breakValue: breaks[index] };
                        });
                        this._tickBox.generate(tickBoxData, transition);
                    }
                    this._minorTickMark.generate(this._minorTickOffsets, transition);
                }
                if (isRightOrBottomAxis) {
                    if (this._ticksOnInside || (!drawTicks)) {
                        this._offset += 0;
                    }
                    else {
                        this._offset += this._drawingParams.tickLength;
                    }
                }
            };
            axisBaseClass.prototype.generateAxisLine = function (generate, transition, isRightOrBottomAxis) {
                //---- draw axis line ----
                var drawLine = (this._isAxisLineVisible) ? [1] : [];
                if (generate) {
                    this._axisLineMark.generate(drawLine, transition);
                }
                if (!isRightOrBottomAxis) {
                    this._offset += 1; // todo: support dp.axisLine.lineSize or CSS, whichever is set
                }
            };
            axisBaseClass.prototype.getMeasuredWidth = function () {
                this.build(null, true, true);
                return this._measuredSize;
            };
            axisBaseClass.prototype.getMeasuredHeight = function () {
                this.build(null, true, true);
                return this._measuredSize;
            };
            axisBaseClass.prototype.minWidth = function (value) {
                if (arguments.length === 0) {
                    return this._minWidth;
                }
                this._minWidth = value;
                return this;
            };
            axisBaseClass.prototype.minHeight = function (value) {
                if (arguments.length === 0) {
                    return this._minHeight;
                }
                this._minHeight = value;
                return this;
            };
            axisBaseClass.prototype.tickCount = function (value) {
                if (arguments.length === 0) {
                    return this._axisData.tickCount();
                }
                this._axisData.tickCount(value);
                return this;
            };
            axisBaseClass.prototype.isLabelsVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isLabelsVisible;
                }
                this._isLabelsVisible = value;
                return this;
            };
            axisBaseClass.prototype.isTicksVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isTicksVisible;
                }
                this._isTicksVisible = value;
                return this;
            };
            axisBaseClass.prototype.isTickBoxesVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isTickBoxesVisible;
                }
                this._isTickBoxesVisible = value;
                return this;
            };
            axisBaseClass.prototype.isAxisLineVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isAxisLineVisible;
                }
                this._isAxisLineVisible = value;
                return this;
            };
            axisBaseClass.prototype.hideInteriorLabels = function (value) {
                if (arguments.length === 0) {
                    return this._hideInteriorLabels;
                }
                this._hideInteriorLabels = value;
                return this;
            };
            axisBaseClass.prototype.isMinorTicksVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isMinorTicksVisible;
                }
                this._isMinorTicksVisible = value;
                return this;
            };
            axisBaseClass.prototype.axisData = function (value) {
                if (arguments.length === 0) {
                    return this._axisData;
                }
                this._axisData = value;
                return this;
            };
            //---- to be overridden by the subclass ----
            axisBaseClass.prototype.shadeMarks = function (transition, record, index, isNew, context, measureOnly) {
                var group = vp.select(this._rootElem)
                    .addClass("vpxAxis");
            };
            axisBaseClass.prototype.getNameWidth = function () {
                var sz = this.getFinalTextSize(this._name, this._drawingParams.name, this._fakeNameLabel);
                var width = this.rotatedSize(this._nameRotation, sz.width, sz.height);
                return width;
            };
            axisBaseClass.prototype.getNameHeight = function () {
                var sz = this.getFinalTextSize(this._name, this._drawingParams.name, this._fakeNameLabel);
                var height = this.rotatedSize(this._nameRotation, sz.height, sz.width);
                return height;
            };
            axisBaseClass.prototype.getMaxLabelSize = function (isForWidth) {
                var sz = this._szMaxText;
                var actualLabelRotation = this._actualLabelRotation;
                if (actualLabelRotation == 45 || actualLabelRotation == -45) {
                    sz = this.getRotateSize45(sz.width, sz.height);
                }
                else if (actualLabelRotation == 90 || actualLabelRotation == -90) {
                    //---- sizes are flipped ----
                    sz = { width: sz.height, height: sz.width };
                }
                var perpSize = this.getActualMaxPerpendicularSize();
                if (perpSize > 0) {
                    if (isForWidth) {
                        sz.width = Math.min(sz.width, perpSize);
                    }
                    else {
                        sz.height = Math.min(sz.height, perpSize);
                    }
                }
                return sz;
            };
            axisBaseClass.prototype.horizontalTickShader = function (element, record, index, isNew, xStart, length, y, isLastNew) {
                if (this._ticksOnInside) {
                    vp.select(element)
                        .hLine(xStart, xStart + length, y, this._isCrisp);
                }
                else {
                    vp.select(element)
                        .hLine(xStart - length, xStart, y, this._isCrisp);
                }
                if (this._onShade) {
                    this._onShade(element, record, index, isNew, isLastNew);
                }
            };
            axisBaseClass.prototype.horizontalTickBoxShader = function (element, record, index, isNew, xStart, length, yRecord, isLastNew) {
                var y = yRecord.tickOffset;
                if (index > 0) {
                    var lastY = this._lastYTickBox;
                    var spacer = 0;
                    var height = Math.max(0, lastY - (y + 2 * spacer));
                    var x = (this._ticksOnInside) ? xStart : (xStart - length);
                    vp.select(element)
                        .bounds(x, y + spacer, length, height, this._isCrisp);
                }
                if (this._onShade) {
                    this._onShade(element, record, index, isNew, isLastNew);
                }
                this._lastYTickBox = y;
            };
            axisBaseClass.prototype.verticalTickShader = function (element, record, index, isNew, yStart, length, x, isLastNew) {
                if (this._ticksOnInside) {
                    vp.select(element)
                        .vLine(yStart, yStart + length, x, this._isCrisp);
                }
                else {
                    vp.select(element)
                        .vLine(yStart - length, yStart, x, this._isCrisp);
                }
                if (this._onShade) {
                    this._onShade(element, record, index, isNew, isLastNew);
                }
            };
            axisBaseClass.prototype.verticalTickBoxShader = function (element, record, index, isNew, yStart, length, xRecord, isLastNew) {
                var x = xRecord.tickOffset;
                if (index > 0) {
                    var lastX = this._lastXTickBox;
                    var spacer = 0;
                    var width = Math.max(0, x - (lastX + 2 * spacer));
                    var y = (this._ticksOnInside) ? (yStart - length) : yStart;
                    vp.select(element)
                        .bounds(lastX + spacer, y, width, length, this._isCrisp);
                }
                if (this._onShade) {
                    this._onShade(element, record, index, isNew, isLastNew);
                }
                this._lastXTickBox = x;
            };
            axisBaseClass.prototype.rootElem = function () {
                return this._rootElem;
            };
            axisBaseClass.prototype.translate = function (x, y, isCrispAdjustment) {
                if (isCrispAdjustment === undefined && this._isCrisp) {
                    isCrispAdjustment = true;
                }
                //---- magic offset only works on direct groups? ----
                vp.select(this._rootElem)
                    .translate(x, y, isCrispAdjustment);
                return this;
            };
            axisBaseClass.prototype.rotateText45 = function (text, wrapElem, alignTo, angle, drawParams, fakeLabel) {
                //var text = wrapElem.text();
                var szText = this.getFinalTextSize(text, drawParams, fakeLabel);
                var finalHeight = szText.height;
                var finalWidth = szText.width;
                var rcCurrent = this.bounds(wrapElem[0]); // .getBBox() not defined in Chrome
                var xCurrent = rcCurrent.x;
                var yCurrent = rcCurrent.y;
                var anchor = "middle";
                var valign = "middle";
                if (alignTo == vp.chartFrame.LabelLocation.top) {
                    if (angle == -45) {
                        //---- rotate at MIDDLE RIGHT to keep top of text aligned ----
                        anchor = "end";
                        var rx = xCurrent + finalHeight; // + rc.width;
                        var ry = yCurrent; // + rc.height / 2;
                        //---- after-rotation adjustments ---
                        rx += finalWidth / 2 - 12;
                        ry += 4;
                    }
                    else {
                        //---- rotate at MIDDLE LEFT to keep top of text aligned ----
                        anchor = "start";
                        var rx = xCurrent + finalHeight / 2;
                        var ry = yCurrent; // + rc.height / 2;
                        //---- after-rotation adjustments ---
                        rx += finalWidth / 2 - 12 + 2;
                        ry += 4 - 5; //-6;
                    }
                }
                else if (alignTo == vp.chartFrame.LabelLocation.bottom) {
                    if (angle == -45) {
                        //---- rotate at BOTTOM LEFT to keep top of text aligned ----
                        anchor = "start";
                        valign = "bottom";
                        var rx = xCurrent + finalWidth;
                        var ry = yCurrent + finalHeight;
                        //---- after-rotation adjustments ---
                        rx += (-finalWidth / 2) + 4;
                        ry += -2; //-(rc.height + 4)
                    }
                    else {
                        //---- rotate at BOTTOM RIGHT to keep top of text aligned ----
                        anchor = "end";
                        valign = "bottom";
                        var rx = xCurrent + finalWidth;
                        var ry = yCurrent + finalHeight;
                        //---- after-rotation adjustments ---
                        rx -= finalWidth / 2 + 2;
                        ry += -2; //-(rc.height + 4);
                    }
                }
                else if (alignTo == vp.chartFrame.LabelLocation.right) {
                    if (angle == -45) {
                        //---- rotate at TOP RIGHT to keep top of text aligned ----
                        valign = "top";
                        anchor = "end";
                        var rx = xCurrent + finalWidth;
                        var ry = yCurrent;
                        //---- after-rotation adjustments ---
                        rx += 12;
                        ry += -8;
                    }
                    else {
                        //---- rotate at TOP RIGHT to keep top of text aligned ----
                        valign = "top";
                        anchor = "end";
                        var rx = xCurrent + finalWidth;
                        var ry = yCurrent;
                        //---- after-rotation adjustments ---
                        rx += 24; //-4;
                        ry += -4;
                    }
                }
                else if (alignTo == vp.chartFrame.LabelLocation.left) {
                    if (angle == -45) {
                        //---- rotate at TOP LEFT to keep top of text aligned ----
                        valign = "top";
                        anchor = "start";
                        var rx = xCurrent;
                        var ry = yCurrent;
                        //---- after-rotation adjustments ---
                        rx += -4;
                        ry += -4;
                    }
                    else {
                        //---- rotate at TOP LEFT to keep top of text aligned ----
                        valign = "top";
                        anchor = "start";
                        var rx = xCurrent;
                        var ry = yCurrent;
                        //---- after-rotation adjustments ---
                        rx += 4;
                        ry += -8;
                    }
                }
                var rotateStr = "rotate(" + angle + ", " + rx + ", " + ry + ")";
                wrapElem
                    .attr("x", rx)
                    .attr("y", ry)
                    .attr("text-anchor", anchor)
                    .attr("transform", rotateStr);
                this.finalTextBaseline(fakeLabel, wrapElem, valign);
                var sz = this.getRotateSize45(finalWidth, finalHeight);
                return sz;
            };
            axisBaseClass.prototype.getRotateSize45 = function (width, height) {
                //---- approximate sizes for 45 degree rotation ----
                var height = .85 * width; //  Math.cos(45)*rc.height + Math.sin(45)*finalWidth;
                var width = .85 * width; // Math.cos(45)*finalWidth + Math.sin(45)*rc.height;
                return { width: width, height: height };
            };
            axisBaseClass.prototype.rotatedSize = function (rotation, normalSize, size90) {
                var newSize = normalSize;
                if (rotation == LabelRotation.rotate90 || rotation == LabelRotation.rotateMinus90) {
                    newSize = size90;
                }
                else if (rotation == LabelRotation.rotate45 || rotation == LabelRotation.rotateMinus45) {
                    newSize = Math.cos(45) * normalSize + Math.sin(45) * size90;
                }
                return newSize;
            };
            axisBaseClass.prototype.finalTextBaseline = function (fakeLabel, wrapElem, align) {
                /// must compute the delta using "fakeLabel" (since it has the final text attributes) 
                /// and then apply delta to wrapElem
                if (fakeLabel.textContent == "") {
                    fakeLabel.textContent = "A"; // text content must be set for computeTextBaselineDelta() to succeed
                }
                var delta = vp.dom.computeTextBaselineDelta(fakeLabel, align);
                wrapElem.attr("dy", delta);
            };
            axisBaseClass.prototype.labelSizes = function (value) {
                if (arguments.length === 0) {
                    var data = {
                        sizes: this._labelSizes,
                        szMaxText: this._szMaxText,
                        pixelsPerLabel: this._availPixelsPerLabel,
                        actualLabelRotation: this._actualLabelRotation,
                    };
                    if (!this._labelSizes || !this.labelSizes.length) {
                        data = null;
                    }
                    return data;
                }
                this._labelSizes = (value) ? value.sizes : null;
                this._szMaxText = (value) ? value.szMaxText : { width: 0, height: 0 };
                this._availPixelsPerLabel = (value) ? value.pixelsPerLabel : 0;
                this._actualLabelRotation = (value) ? value.actualLabelRotation : 0;
                return this;
            };
            axisBaseClass.prototype.getActualMaxPerpendicularSize = function () {
                var perpSize = (this._maxPerpendicularSize > 0) ? this._maxPerpendicularSize : this._drawingParams.maxPerpendicularSize;
                return perpSize;
            };
            axisBaseClass.prototype.getAvailablePixelsPerLabelForTruncation = function (actualLabelRotation) {
                var availPixelsPerLabel = 0;
                var perpSize = this.getActualMaxPerpendicularSize();
                var perpSize45 = Math.sqrt(2) * perpSize;
                var regSize = this._availPixelsPerLabel;
                if (this._location == vp.chartFrame.LabelLocation.left || this._location == vp.chartFrame.LabelLocation.right) {
                    //---- vertical axis ----
                    if (actualLabelRotation == 90 || actualLabelRotation == -90) {
                        availPixelsPerLabel = regSize;
                    }
                    else if (actualLabelRotation == 45 || actualLabelRotation == -45) {
                        availPixelsPerLabel = perpSize45;
                    }
                    else {
                        availPixelsPerLabel = perpSize;
                    }
                }
                else {
                    //---- horizontal axis ----
                    if (actualLabelRotation == 0) {
                        availPixelsPerLabel = regSize;
                    }
                    else if (actualLabelRotation == 45 || actualLabelRotation == -45) {
                        availPixelsPerLabel = perpSize45;
                    }
                    else {
                        availPixelsPerLabel = perpSize;
                    }
                }
                return availPixelsPerLabel;
            };
            axisBaseClass.prototype.shadeTextLabel = function (index, element, cx, cy, text, hAlign, vAlign, alignTo, returnWidth, availPixelsPerLabel, isLastNew) {
                var fullText = text;
                var actualLabelRotation = this._actualLabelRotation;
                var fakeLabel = this._fakeLabel;
                //---- TRUNCATE TEXT ----
                if ((availPixelsPerLabel) && (this._labelOverflow == LabelOverflow.ellipses || this._labelOverflow == LabelOverflow.truncate)) {
                    text = this.truncateText(text, availPixelsPerLabel, this._labelOverflow, fakeLabel);
                }
                var wrap = vp.select(element)
                    .attr("x", cx)
                    .attr("y", cy)
                    .attr("text-anchor", hAlign)
                    .text(text)
                    .title(fullText);
                var szLabel = this.getFinalTextSize(text, this._drawingParams.label, this._fakeLabel);
                //if (text != fullText)       // we need new text measurement
                //{
                //    rcx = element.getBBox();
                //}
                this.finalTextBaseline(fakeLabel, wrap, vAlign);
                var mySize = (returnWidth) ? szLabel.width : szLabel.height;
                if (actualLabelRotation) {
                    var result;
                    if (actualLabelRotation == 45 || actualLabelRotation == -45) {
                        result = this.rotateText45(text, wrap, alignTo, actualLabelRotation, this._drawingParams.label, fakeLabel);
                    }
                    else if (actualLabelRotation == 90 || actualLabelRotation == -90) {
                        result = this.rotateText90(text, wrap, alignTo, cx, cy, actualLabelRotation, this._drawingParams.label, fakeLabel);
                    }
                    mySize = (returnWidth) ? result.width : result.height;
                }
                else {
                }
                return mySize;
            };
            axisBaseClass.prototype.getLabelBounds = function (index, x, y, hAlign) {
                var rc = new vp.geom.rectLight(0, 0, 1, 1);
                if (this._labelSizes) {
                    rc = this._labelSizes[index];
                }
                //---- yCorrection is the number text.top is shifted by due to unstoppable alphabetic line vertical alignment ----
                var yCorrection = -rc.y;
                if (hAlign == "middle") {
                    x -= rc.width / 2;
                }
                else if (hAlign == "end") {
                    x -= rc.width;
                }
                //---- cannot modify system SVGRect; must recreate it ----
                var rcx = { x: x, y: y - yCorrection, width: rc.width, height: rc.height, yCorrection: yCorrection };
                return rcx;
            };
            axisBaseClass.prototype.rotateText90 = function (text, wrapElem, alignTo, cx, cy, angle, drawParams, fakeLabel) {
                //var text = wrapElem.text();
                var szText = this.getFinalTextSize(text, drawParams, fakeLabel);
                var finalHeight = szText.height;
                var finalWidth = szText.width;
                var rcCurrent = this.bounds(wrapElem[0]); // .getBBox();
                var xCurrent = rcCurrent.x;
                var yCurrent = rcCurrent.y;
                var anchor = "middle";
                var valign = "middle";
                //---- compute true CENTER of element (where rotation will be done) ----
                var rx = cx + finalWidth / 2;
                var ry = cy + finalHeight / 2;
                var rxChanged = false;
                var ryChanged = false;
                //---- adjustsment needed after clean rotation  tp PRESERVE ALIGNMENT ----
                if (alignTo == vp.chartFrame.LabelLocation.left) {
                    //---- ALIGN TO LEFT ----
                    rx += -finalWidth / 2 + finalHeight / 2;
                    rxChanged = true;
                    ry -= 10;
                    ryChanged = true;
                }
                else if (alignTo == vp.chartFrame.LabelLocation.right) {
                    //---- ALIGN TO RIGHT ----
                    rx += (+finalWidth / 2 - finalHeight / 2);
                    rxChanged = true;
                }
                else if (alignTo == vp.chartFrame.LabelLocation.top) {
                    //---- ALIGN TO TOP ----
                    if (angle == -90) {
                        rx += (-finalHeight / 2 - finalWidth / 2) + 7;
                        ry += (+finalWidth / 2 - finalHeight / 2) + 4 - 7;
                        rxChanged = true;
                        ryChanged = true;
                    }
                    else {
                        rx += (-finalHeight / 2 - finalWidth / 2) + 11;
                        ry += (+finalWidth / 2) - (finalHeight / 2) + 4 - 7;
                        rxChanged = true;
                        ryChanged = true;
                    }
                }
                else if (alignTo == vp.chartFrame.LabelLocation.bottom) {
                    //---- ALIGN TO BOTTOM ----
                    if (angle == -90) {
                        //---- rotate at BOTTOM LEFT to keep top of text aligned ----
                        anchor = "start";
                        valign = "bottom";
                        var rx = xCurrent + finalWidth;
                        var ry = yCurrent + finalHeight;
                        //---- after-rotation adjustments ---
                        rx += (-finalWidth / 2) + 7;
                        ry += -2 + 9; //-(finalHeight + 4)
                    }
                    else {
                        //---- rotate at BOTTOM RIGHT to keep top of text aligned ----
                        anchor = "end";
                        valign = "bottom";
                        var rx = xCurrent + finalWidth;
                        var ry = yCurrent + finalHeight;
                        //---- after-rotation adjustments ---
                        rx += -(finalWidth) / 2 + 2 - 8;
                        ry += -2 + 9; //-(finalHeight + 4);
                    }
                }
                wrapElem
                    .attr("x", rx)
                    .attr("text-anchor", anchor)
                    .attr("y", ry);
                //wrapElem.textBaseline(valign);
                this.finalTextBaseline(fakeLabel, wrapElem, valign);
                //---- finally, apply the rotation ----
                var rotateStr = "rotate(" + angle + ", " + rx + ", " + ry + ")";
                wrapElem
                    .attr("transform", rotateStr);
                //--- getBBox() doesn't report rotated info, so just calc ourselves ----
                return { width: finalHeight, height: finalWidth };
            };
            /// TODO: review axisBaseClass and try to minimize the number of measurements we do.
            axisBaseClass.prototype.getFinalTextSize = function (text, drawingParams, fakeLabel) {
                /// Note: we might be animating the fontSize or fontWeight, which will affect the layout.  We only
                /// do a single layout and then animate all properties to their final value.  This means that we 
                /// must measure each label with its final drawing properties, but also preserve the current properties.
                /// To accomplish this, we use "fakeLabel" to do the measurement here. 
                fakeLabel.textContent = text;
                //vp.marks.applyTextParams(fakeLabel, drawingParams);
                var rcFake = this.bounds(fakeLabel); // .getBBox();
                return { width: rcFake.width, height: rcFake.height };
            };
            axisBaseClass.prototype.hideTicksIfTooMany = function () {
                var availAxisSize = this._axisSize - 2 * this._expandSpace;
                var pixelsPerTick = availAxisSize / this._tickOffsets.length;
                var minPixelsPerTick = 2;
                if (pixelsPerTick < minPixelsPerTick) {
                    //---- hide the ticks ----
                    this._tickOffsets = [];
                    this._minorTickOffsets = [];
                }
            };
            axisBaseClass.prototype.getActualLabelRotation = function (maxMeasuredWidth, maxMeasuredHeight, axisSize, labelCount) {
                var rotation = this._labelRotation;
                if (rotation == LabelRotation.auto) {
                    //---- can labels fit unrotated? ----
                    rotation = LabelRotation.none;
                    var pixelsAvailPerLabel = (axisSize / labelCount) - this._minLabelSpacing[0];
                    if (pixelsAvailPerLabel < maxMeasuredWidth) {
                        //---- no; try 45 degrees ----
                        if (this._positiveAutoRotation) {
                            rotation = LabelRotation.rotate45;
                        }
                        else {
                            rotation = LabelRotation.rotateMinus45;
                        }
                        pixelsAvailPerLabel = (axisSize / labelCount) - this._minLabelSpacing[1];
                        var pixelsRequired = 1.34 * maxMeasuredHeight;
                        if (pixelsAvailPerLabel < pixelsRequired) {
                            //---- no; try 90 degrees ----
                            rotation = (this._positiveAutoRotation) ? LabelRotation.rotate90 : LabelRotation.rotateMinus90;
                            pixelsAvailPerLabel = (axisSize / labelCount) - this._minLabelSpacing[2];
                            var pixelsRequired = maxMeasuredHeight;
                            if (pixelsAvailPerLabel < pixelsRequired) {
                            }
                        }
                    }
                }
                return rotation;
            };
            axisBaseClass.prototype.getAvailPixelsPerLabel = function (actualRotation, availAxisSize, labelCount) {
                var avail = 0;
                if (actualRotation == LabelRotation.none) {
                    avail = (availAxisSize / labelCount) - this._minLabelSpacing[0];
                }
                else if (actualRotation == LabelRotation.rotate45 || actualRotation == LabelRotation.rotateMinus45) {
                    avail = (availAxisSize / labelCount) - this._minLabelSpacing[1];
                }
                else if (actualRotation == LabelRotation.rotate90 || actualRotation == LabelRotation.rotateMinus90) {
                    avail = (availAxisSize / labelCount) - this._minLabelSpacing[2];
                }
                return avail;
            };
            /** See if labels can fit the axis, using rotation and trimming. */
            axisBaseClass.prototype.canLabelsFit = function (availAxisSize, labelCount, maxMeasuredWidth, maxMeasuredHeight) {
                //---- unrotated fit ----
                var availPixels0 = (availAxisSize / labelCount) - this._minLabelSpacing[0];
                var neededPixels0 = maxMeasuredWidth;
                var canFit0 = (availPixels0 >= neededPixels0);
                //---- 45 degree fit ----
                var availPixels45 = (availAxisSize / labelCount) - this._minLabelSpacing[1];
                var neededPixels45 = 1.34 * maxMeasuredHeight;
                var canFit45 = (availPixels45 >= neededPixels45);
                //---- 90 degree fit ----
                var availPixels90 = (availAxisSize / labelCount) - this._minLabelSpacing[2];
                var neededPixels90 = maxMeasuredHeight;
                var canFit90 = (availPixels90 >= neededPixels90);
                //---- different for all values of rotation -----
                var canFit = false;
                var rotation = this._labelRotation;
                if (rotation == LabelRotation.none) {
                    canFit = canFit0;
                }
                else if (rotation == LabelRotation.rotate45 || rotation == LabelRotation.rotateMinus45) {
                    canFit = canFit45;
                }
                else if (rotation == LabelRotation.rotate90 || rotation == LabelRotation.rotateMinus90) {
                    canFit = canFit90;
                }
                else if (rotation == LabelRotation.auto) {
                    canFit = (canFit0 || canFit45 || canFit90);
                }
                return canFit;
            };
            axisBaseClass.prototype.measureAllLabels = function (labelStrings) {
                var availAxisSize = this._axisSize - 2 * this._expandSpace;
                var maxMeasuredWidth = 0;
                var maxMeasuredHeight = 0;
                var fakeLabel = this._fakeLabel;
                var labelSizes = null;
                var labels = labelStrings;
                var availPixelsPerLabel = 0;
                var actualLabelRotation = LabelRotation.none;
                if (labels.length) {
                    //---- PRE-MEASUREMENT policies ----
                    //---- IMPORTANT PERF: avoid measurement of more labels than could possibly fit ----
                    if (!this.canLabelsFit(availAxisSize, labels.length, this._ellipsesBounds.width / 3, this._ellipsesBounds.height)) {
                        //---- hide labels ----
                        this._labelOffsets = [];
                        this._labelStrings = [];
                    }
                    else {
                        labelSizes = [];
                        var cachedMeasurements = this._axisData.labelMeasurements();
                        if (cachedMeasurements.labelSizes) {
                            //vp.utils.debug("measureAllLabels: using CACHED sizes" + labels.length);
                            labelSizes = cachedMeasurements.labelSizes;
                            maxMeasuredWidth = cachedMeasurements.szMaxText.width;
                            maxMeasuredHeight = cachedMeasurements.szMaxText.height;
                        }
                        else {
                            //vp.utils.debug("measureAllLabels: count=" + labels.length);
                            //---- apply font, textSize, etc. to fakeLabel now ----
                            var drawingParams = this._labelMark.drawingParams();
                            vp.marks.applyTextParams(fakeLabel, drawingParams);
                            vp.dom.css(fakeLabel, "opacity", 0); // ensure fake remains hidden
                            //---- MEASURE all the labels here ----
                            for (var i = 0; i < labels.length; i++) {
                                var label = labels[i];
                                //---- set up for measuring "labelStr" ----
                                fakeLabel.textContent = label;
                                var rc = this.bounds(fakeLabel); //.getBBox();
                                labelSizes.push(rc);
                                maxMeasuredWidth = Math.max(maxMeasuredWidth, rc.width);
                                maxMeasuredHeight = Math.max(maxMeasuredHeight, rc.height);
                            }
                            //---- store results in cache ----
                            cachedMeasurements.labelSizes = labelSizes;
                            cachedMeasurements.szMaxText.width = maxMeasuredWidth;
                            cachedMeasurements.szMaxText.height = maxMeasuredHeight;
                        }
                    }
                    //---- POST-MEASUREMENT policies ----
                    //---- apply "auto rotation" policy ----
                    actualLabelRotation = this.getActualLabelRotation(maxMeasuredWidth, maxMeasuredHeight, availAxisSize, labels.length);
                    availPixelsPerLabel = this.getAvailPixelsPerLabel(actualLabelRotation, availAxisSize, labels.length);
                    //---- apply "hide all" policy ----
                    if (this._labelOverflow == LabelOverflow.hideAll) {
                        var canFit = this.canLabelsFit(availAxisSize, labels.length, maxMeasuredWidth, maxMeasuredHeight);
                        if (!canFit) {
                            //---- hide labels ----
                            this._labelOffsets = [];
                            this._labelStrings = [];
                            labelSizes = null;
                        }
                    }
                }
                this._labelSizes = labelSizes;
                this._availPixelsPerLabel = availPixelsPerLabel;
                this._actualLabelRotation = actualLabelRotation;
                return { width: maxMeasuredWidth, height: maxMeasuredHeight };
            };
            axisBaseClass.prototype.truncateText = function (text, maxLength, overflow, fakeLabel) {
                var ellipseWidth = this._ellipsesBounds.width;
                return vp.formatters.truncateText(text, maxLength, overflow == LabelOverflow.ellipses, fakeLabel, ellipseWidth);
            };
            axisBaseClass.prototype.eraseCanvas = function () {
                this._rootElem.eraseCanvas();
            };
            axisBaseClass.prototype.tickOffsets = function (value) {
                if (arguments.length === 0) {
                    return this._tickOffsets;
                }
                this._tickOffsets = value;
                return this;
            };
            axisBaseClass.prototype.minorTickOffsets = function (value) {
                if (arguments.length === 0) {
                    return this._minorTickOffsets;
                }
                this._minorTickOffsets = value;
                return this;
            };
            axisBaseClass.prototype.labelOffsets = function (value) {
                if (arguments.length === 0) {
                    return this._labelOffsets;
                }
                this._labelOffsets = value;
                return this;
            };
            axisBaseClass.prototype.labelStrings = function (value) {
                if (arguments.length === 0) {
                    return this._labelStrings;
                }
                this._labelStrings = value;
                return this;
            };
            axisBaseClass.prototype.name = function (value) {
                if (arguments.length === 0) {
                    return this._name;
                }
                this._name = value;
                return this;
            };
            axisBaseClass.prototype.labelRotation = function (value) {
                if (arguments.length === 0) {
                    return this._labelRotation;
                }
                this._labelRotation = value;
                return this;
            };
            axisBaseClass.prototype.positiveAutoRotation = function (value) {
                if (arguments.length === 0) {
                    return this._positiveAutoRotation;
                }
                this._positiveAutoRotation = value;
                return this;
            };
            axisBaseClass.prototype.ticksOnInside = function (value) {
                if (arguments.length === 0) {
                    return this._ticksOnInside;
                }
                this._ticksOnInside = value;
                return this;
            };
            axisBaseClass.prototype.nameRotation = function (value) {
                if (arguments.length === 0) {
                    return this._nameRotation;
                }
                this._nameRotation = value;
                return this;
            };
            axisBaseClass.prototype.minLabelSpacing = function (value) {
                if (arguments.length === 0) {
                    return this._minLabelSpacing;
                }
                if (!vp.utils.isArray(value)) {
                    value = [value];
                }
                this._minLabelSpacing = value;
                return this;
            };
            axisBaseClass.prototype.maxPerpendicularSize = function (value) {
                if (arguments.length === 0) {
                    return this._maxPerpendicularSize;
                }
                this._maxPerpendicularSize = value;
                return this;
            };
            axisBaseClass.prototype.expandSpace = function (value) {
                if (arguments.length === 0) {
                    return this._expandSpace;
                }
                this._expandSpace = value;
                return this;
            };
            axisBaseClass.prototype.labelOverflow = function (value) {
                if (arguments.length === 0) {
                    return this._labelOverflow;
                }
                this._labelOverflow = value;
                return this;
            };
            axisBaseClass.prototype.onShade = function (value) {
                if (arguments.length === 0) {
                    return this._onShade;
                }
                this._onShade = value;
                return this;
            };
            axisBaseClass.prototype.drawingParams = function (value) {
                if (arguments.length === 0) {
                    return this._drawingParams;
                }
                this._drawingParams = value;
                return this;
            };
            axisBaseClass.prototype.transition = function (value) {
                if (arguments.length == 0) {
                    return this._transition;
                }
                this._transition = value;
                return this;
            };
            axisBaseClass.prototype.isCrisp = function (value) {
                if (arguments.length === 0) {
                    return this._isCrisp;
                }
                this._isCrisp = value;
                return this;
            };
            return axisBaseClass;
        }());
        chartFrame.axisBaseClass = axisBaseClass;
        /** Specifies how to truncate or hide axis labels that exceed the available space.  If "maxLabelSize" is specified, the
        width of the unrotated label, or the height of the rotated label, is compared to the specified value of "maxLabelSize".  Otherwise, the rotated  size of the
        label in the direction of the axis is compared to the available space between breaks on the axis.  When not enough space is available,
        "LabelOverflow" specifies how the label is drawn. */
        (function (LabelOverflow) {
            //clip,
            /** draws the entire label, even if it results in labels overwriting each other. */
            LabelOverflow[LabelOverflow["overWrite"] = 0] = "overWrite";
            /** truncates the label to fit the available space. */
            LabelOverflow[LabelOverflow["truncate"] = 1] = "truncate";
            /** truncates the label with "..." marks to fit the available space. */
            LabelOverflow[LabelOverflow["ellipses"] = 2] = "ellipses";
            /** hides all of the labels on the axis if any of the labels is too large for the available space. */
            LabelOverflow[LabelOverflow["hideAll"] = 3] = "hideAll";
        })(chartFrame.LabelOverflow || (chartFrame.LabelOverflow = {}));
        var LabelOverflow = chartFrame.LabelOverflow;
        /** Specifies the rotation of the axis labels or name. */
        (function (LabelRotation) {
            LabelRotation[LabelRotation["none"] = 0] = "none";
            LabelRotation[LabelRotation["rotate45"] = 45] = "rotate45";
            LabelRotation[LabelRotation["rotateMinus45"] = -45] = "rotateMinus45";
            LabelRotation[LabelRotation["rotate90"] = 90] = "rotate90";
            LabelRotation[LabelRotation["rotateMinus90"] = -90] = "rotateMinus90";
            LabelRotation[LabelRotation["auto"] = -1] = "auto";
        })(chartFrame.LabelRotation || (chartFrame.LabelRotation = {}));
        var LabelRotation = chartFrame.LabelRotation;
        /** Specifies where the labels are, relative to the axis line.  */
        (function (LabelLocation) {
            LabelLocation[LabelLocation["left"] = 0] = "left";
            LabelLocation[LabelLocation["top"] = 1] = "top";
            LabelLocation[LabelLocation["right"] = 2] = "right";
            LabelLocation[LabelLocation["bottom"] = 3] = "bottom";
        })(chartFrame.LabelLocation || (chartFrame.LabelLocation = {}));
        var LabelLocation = chartFrame.LabelLocation;
        //* used for ticks and minor ticks. */
        function indexKeyFunc(data, index) {
            return index;
        }
        chartFrame.indexKeyFunc = indexKeyFunc;
        function offsetKeyFunc(data, index) {
            return data.offset;
        }
        chartFrame.offsetKeyFunc = offsetKeyFunc;
        /** used for labels. */
        function labelKeyFunc(data, index) {
            return data.label;
        }
        chartFrame.labelKeyFunc = labelKeyFunc;
    })(chartFrame = vp.chartFrame || (vp.chartFrame = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// axisData.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var chartFrame;
    (function (chartFrame) {
        /** contain scale, breaks, lablels, and other info needed to build axes, legends, and grid lines.  */
        var axisDataClass = (function () {
            function axisDataClass(scale, name, tickCount, breaks, labels, formatter) {
                this._scale = scale;
                this._name = name;
                this._tickCount = (tickCount === undefined) ? 8 : tickCount;
                this._breaks = breaks;
                this._labels = labels;
                this._formatter = formatter;
                this._labelMeasurements = new labelMeasurementData();
                this.onScaleChanged();
            }
            axisDataClass.prototype.clearMeasurements = function () {
                this._labelMeasurements.clear();
            };
            axisDataClass.prototype.onScaleChanged = function () {
                this._dateScaleInfo = null;
                var scale = this._scale;
                if (scale) {
                    if (scale.scaleType() == vp.scales.ScaleType.dateTime) {
                        this._dateScaleInfo = vp.dateHelper.getDateScaleValues(scale.domainMin(), scale.domainMax());
                    }
                }
            };
            // private
            axisDataClass.prototype.getLinearBreaks = function () {
                var min = this._scale.domainMin();
                var max = this._scale.domainMax();
                var step = (max - min) / (this._tickCount - 1);
                var breaks = vp.data.range(min, max, step);
                return breaks;
            };
            // public
            axisDataClass.prototype.getActualBreaks = function () {
                var breaks = this._breaks;
                var scale = this._scale;
                var tickCount = this._tickCount;
                if (!breaks) {
                    var scaleType = scale.scaleType();
                    if (scaleType == vp.scales.ScaleType.categoryIndex || scaleType == vp.scales.ScaleType.categoryKey) {
                        breaks = vp.utils.keys(scale.categoryKeys());
                    }
                    else if (scaleType == vp.scales.ScaleType.log) {
                        var min = scale.domainMin();
                        var max = scale.domainMax();
                        breaks = [];
                        for (var i = 0; i < Number.MAX_VALUE; i++) {
                            var bv = min * Math.pow(10, i);
                            if (bv > max) {
                                break;
                            }
                            breaks.push(bv);
                        }
                    }
                    else if (scaleType == vp.scales.ScaleType.lowBias) {
                        var log25 = Math.log(25);
                        //---- to compute breaks, REVERSE MAP normalized steps (0-1) into data space ----
                        var min = scale.domainMin();
                        var max = scale.domainMax();
                        var range = (min == max) ? 1 : (max - min);
                        var stepCount = tickCount; // - 1;
                        var stepSize = 1 / (stepCount - 1);
                        breaks = [];
                        for (var i = 0; i < stepCount; i++) {
                            var percent = i * stepSize;
                            //---- convert to log-adjusted percent ----
                            var v = percent * log25;
                            v = Math.exp(v);
                            percent = (v - 1) / 24;
                            //---- convert from percent to value in domain ----
                            var breakValue = min + percent * range;
                            breaks.push(breakValue);
                        }
                    }
                    else if (scaleType == vp.scales.ScaleType.highBias) {
                        var exp4m1 = Math.exp(4) - 1;
                        //---- to compute breaks, REVERSE MAP normalized steps (0-1) into data space ----
                        var min = scale.domainMin();
                        var max = scale.domainMax();
                        var range = (min == max) ? 1 : (max - min);
                        var stepCount = tickCount; // - 1;
                        var stepSize = 1 / (stepCount - 1);
                        breaks = [];
                        for (var i = 0; i < stepCount; i++) {
                            var percent = i * stepSize;
                            //---- convert to exp-adjusted percent ----
                            var v = (percent * exp4m1) + 1;
                            v = Math.log(v);
                            percent = v / 4;
                            //---- convert from percent to value in domain ----
                            var breakValue = min + percent * range;
                            breaks.push(breakValue);
                        }
                    }
                    else if (scaleType == vp.scales.ScaleType.linear || scaleType == vp.scales.ScaleType.dateTime) {
                        breaks = this.getLinearBreaks();
                    }
                    else {
                        vp.utils.error("axis.generate: unsupported scaleType=" + scaleType);
                    }
                }
                return breaks;
            };
            /** Calculate the tick and label offsets for this axis data. */
            axisDataClass.prototype.getOffsets = function (breaks) {
                var _this = this;
                var tickOffsets = null;
                var labelOffsets = null;
                var scaleType = this._scale.scaleType();
                var isCategory = (scaleType == vp.scales.ScaleType.categoryIndex || scaleType == vp.scales.ScaleType.categoryKey);
                if (isCategory) {
                    var categoryScale = this._scale;
                    var halfStep = categoryScale.stepSize() / 2;
                    labelOffsets = [];
                    tickOffsets = breaks.map(function (value, index) {
                        var offset = _this._scale.scale(value);
                        labelOffsets.push(offset);
                        return offset - halfStep;
                    });
                    if (tickOffsets.length > 0) {
                        //---- add extra tick at end ----
                        var count = tickOffsets.length;
                        var extraOffset = tickOffsets[count - 1] + 2 * halfStep;
                        tickOffsets.push(extraOffset);
                    }
                }
                else {
                    //---- scale breaks into TICKOFFSETS ----
                    tickOffsets = breaks.map(function (value, index) {
                        return _this._scale.scale(value);
                    });
                    labelOffsets = tickOffsets;
                }
                return { tickOffsets: tickOffsets, labelOffsets: labelOffsets };
            };
            axisDataClass.prototype.makeLinearMinor = function (breaks, minorSteps) {
                var minor = [];
                for (var i = 1; i < breaks.length; i++) {
                    var thisBreak = breaks[i];
                    var lastBreak = breaks[i - 1];
                    var stepSize = (thisBreak - lastBreak) / (minorSteps + 1);
                    for (var j = 1; j <= minorSteps; j++) {
                        var minorBreak = lastBreak + j * stepSize;
                        var offset = this._scale.scale(minorBreak);
                        minor.push(offset);
                    }
                }
                return minor;
            };
            axisDataClass.prototype.makeCategoryMinor = function (breaks) {
                var minor = [];
                for (var i = 1; i < breaks.length; i++) {
                    var thisBreak = breaks[i];
                    var offset = this._scale.scale(thisBreak);
                    minor.push(offset);
                }
                return minor;
            };
            /** we skip over minor breaks and go straight for minor offsets.  This is because its hard to caculate
            minor breaks for category scales, and we don't have any other use for the minor break values themselves. */
            axisDataClass.prototype.getActualMinorOffsets = function (breaks) {
                var minor = [];
                var scaleType = this._scale.scaleType();
                if (scaleType == vp.scales.ScaleType.log) {
                    minor = [];
                    for (var i = 1; i < breaks.length; i++) {
                        var incr = breaks[i - 1];
                        for (var j = 2; j < 10; j++) {
                            var breakValue = j * incr;
                            var offset = this._scale.scale(breakValue);
                            minor.push(offset);
                        }
                    }
                }
                else if (scaleType == vp.scales.ScaleType.categoryIndex || scaleType == vp.scales.ScaleType.categoryKey) {
                    //---- category: use 1 line per major break (2 intervals) ----
                    minor = this.makeCategoryMinor(breaks);
                }
                else {
                    //---- linear: use 4 lines per major break (5 intervals) ----
                    minor = this.makeLinearMinor(breaks, 4);
                }
                return minor;
            };
            axisDataClass.prototype.getDecimalDigitCount = function (value) {
                var ddc = 0;
                var str = value + "";
                var index = str.indexOf(".");
                if (index > -1) {
                    ddc = str.length - (index + 1);
                }
                return ddc;
            };
            axisDataClass.prototype.getActualLabels = function (breakValues) {
                var labels = this._labels;
                if (!labels) {
                    var scaleType = this._scale.scaleType();
                    var isCategory = (scaleType == vp.scales.ScaleType.categoryIndex || scaleType == vp.scales.ScaleType.categoryKey);
                    //---- TODO: allow for user-specified formatter and user-specified "numDecimals" ----
                    var formatter = this._formatter;
                    if (!formatter) {
                        if (isCategory) {
                            formatter = vp.formatters.string;
                        }
                        else if (this._dateScaleInfo) {
                            formatter = vp.formatters.createExcelFormatter(this._dateScaleInfo.formatString, "date");
                        }
                    }
                    var numDecimals = undefined; // this._numDecimalPlaces;
                    if (!isCategory) {
                        numDecimals = 0;
                        if (breakValues.length > 0) {
                            numDecimals = this.getDecimalDigitCount(breakValues[0]);
                            if (breakValues.length > 1) {
                                var singleTickInterval = breakValues[1] - breakValues[0];
                                var ddc = this.getDecimalDigitCount(singleTickInterval);
                                numDecimals = Math.max(numDecimals, ddc);
                            }
                        }
                        numDecimals = Math.min(4, numDecimals); // don't show too much, by default
                        if (!formatter) {
                            formatter = vp.formatters.createCommaFormatter(numDecimals);
                        }
                    }
                    labels = breakValues.map(function (value, index) {
                        return formatter(value);
                    });
                }
                return labels;
            };
            axisDataClass.prototype.scale = function (value) {
                if (arguments.length == 0) {
                    return this._scale;
                }
                this._scale = value;
                this.onScaleChanged();
                return this;
            };
            axisDataClass.prototype.tickCount = function (value) {
                if (arguments.length == 0) {
                    return this._tickCount;
                }
                this._tickCount = value;
                return this;
            };
            axisDataClass.prototype.formatter = function (value) {
                if (arguments.length == 0) {
                    return this._formatter;
                }
                this._formatter = value;
                return this;
            };
            axisDataClass.prototype.labelMeasurements = function (value) {
                if (arguments.length == 0) {
                    return this._labelMeasurements;
                }
                this._labelMeasurements = value;
                return this;
            };
            return axisDataClass;
        }());
        chartFrame.axisDataClass = axisDataClass;
        function createAxisData(scale, name, tickCount, breaks, labels, formatter) {
            return new axisDataClass(scale, name, tickCount, breaks, labels, formatter);
        }
        chartFrame.createAxisData = createAxisData;
        //* these are label measurements, independent of a specific axis size or orientation. */
        var labelMeasurementData = (function () {
            function labelMeasurementData() {
                this.clear();
            }
            labelMeasurementData.prototype.clear = function () {
                this.labelSizes = null;
                this.szMaxText = { width: 0, height: 0 };
            };
            return labelMeasurementData;
        }());
        chartFrame.labelMeasurementData = labelMeasurementData;
    })(chartFrame = vp.chartFrame || (vp.chartFrame = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// bottomAxis.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var chartFrame;
    (function (chartFrame) {
        /** creates a vertical axis with the labels to the right of the axis line. */
        var bottomAxisClass = (function (_super) {
            __extends(bottomAxisClass, _super);
            function bottomAxisClass(container, axisDataOrScale, useWebGl, isCrisp) {
                var _this = this;
                _super.call(this, container, axisDataOrScale, useWebGl, isCrisp, chartFrame.LabelLocation.bottom);
                //vp.utils.trace("ctr", "bottomAxis");
                var root = this._rootElem;
                //---- create AXIS LINE ----
                this._axisLineMark = vp.marks.createLineMark(root, "vpxAxisLine")
                    .onShade(function (element, record, index, isNew) {
                    var xStart = 0;
                    var xEnd = _this._axisSize;
                    var y = _this._offset;
                    vp.select(element)
                        .hLine(xStart - 1, xEnd, y, _this._isCrisp);
                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });
                //---- create AXIS TICKS ----
                this._tickMark = vp.marks.createLineMark(root, "vpxAxisTick")
                    .keyFunc(chartFrame.indexKeyFunc)
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    _this.verticalTickShader(element, record, index, isNew, _this._offset, -_this._drawingParams.tickLength, record, isLastNew);
                });
                //---- create AXIS TICK BOXES ----
                this._tickBox = vp.marks.createRectangleMark(root, "vpxAxisTickBox")
                    .keyFunc(chartFrame.indexKeyFunc)
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    _this.verticalTickBoxShader(element, record, index, isNew, _this._offset, _this._drawingParams.tickLength, record, isLastNew);
                });
                //---- create MINOR TICKS  ----
                this._minorTickMark = vp.marks.createLineMark(root, "vpxAxisMinorTick")
                    .keyFunc(chartFrame.indexKeyFunc)
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    _this.verticalTickShader(element, record, index, isNew, _this._offset, -_this._drawingParams.minorTickLength, record, isLastNew);
                });
                //---- create AXIS LABELS ----
                this._labelMark = vp.marks.createTextMark(root, "vpxAxisLabel")
                    .keyFunc(chartFrame.labelKeyFunc)
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    var cx = record.offset;
                    var cy = _this._offset;
                    var availPixelsPerLabel = _this.getAvailablePixelsPerLabelForTruncation(_this._actualLabelRotation);
                    var myHeight = _this.shadeTextLabel(index, element, cx, cy, record.label, "middle", "top", vp.chartFrame.LabelLocation.top, false, availPixelsPerLabel, isLastNew);
                    _this._maxTextHeight = Math.max(_this._maxTextHeight, myHeight);
                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew, isLastNew);
                    }
                });
                //---- create NAME ----
                this._nameMark = vp.marks.createTextMark(root, "vpxAxisName")
                    .onShade(function (element, record, index, isNew, isLastNew) {
                    /// General Note: when laying out elements with animations potentially active,
                    /// we cannot rely on system calls to determine position - we have to track 
                    /// x,y positions manually.  This is because calls like "elem.attr("x", 34)" don't change
                    /// "x" to 34 until the end of the animation.
                    var cx = _this._axisSize / 2;
                    var cy = _this._offset;
                    var wrap = vp.select(element)
                        .attr("x", cx + "")
                        .attr("y", cy + "")
                        .text(_this._name);
                    //---- now that properties are all set, VERT ALIGN at "cy" ----
                    _this.finalTextBaseline(_this._fakeNameLabel, wrap, "top");
                    if (_this._nameRotation) {
                        if (_this._nameRotation == 45 || _this._nameRotation == -45) {
                            var result = _this.rotateText45(_this._name, wrap, vp.chartFrame.LabelLocation.top, _this._nameRotation, _this._drawingParams.name, _this._fakeNameLabel);
                            _this._maxTextHeight = result.height;
                        }
                        else if (_this._nameRotation == 90 || _this._nameRotation == -90) {
                            var result = _this.rotateText90(_this._name, wrap, vp.chartFrame.LabelLocation.top, cx, cy, _this._nameRotation, _this._drawingParams.name, _this._fakeNameLabel);
                            _this._maxTextHeight = result.height;
                        }
                    }
                    else {
                        var szLabel = _this.getFinalTextSize(_this._name, _this._drawingParams.name, _this._fakeNameLabel);
                        _this._maxTextHeight = szLabel.height;
                    }
                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew, isLastNew);
                    }
                });
            }
            bottomAxisClass.prototype.shadeMarks = function (transition, record, index, isNew, context, measureOnly) {
                var dp = this._drawingParams;
                var generate = (!measureOnly);
                var group = vp.select(this._rootElem)
                    .addClass("vpxAxis");
                this._maxTextWidth = 0;
                this._offset = dp.startPadding;
                //---- generate SUB MARKS ----
                this.generateAxisLine(generate, transition, true);
                this.generateTicks(generate, transition, true);
                this.generateVerticalLabels(generate, transition, true);
                this.generateVerticalName(generate, transition, true);
                this._offset += dp.endPadding;
                this._measuredSize = this._offset;
            };
            bottomAxisClass.prototype.width = function (value) {
                if (arguments.length === 0) {
                    return this._axisSize;
                }
                this._axisSize = value;
                return this;
            };
            return bottomAxisClass;
        }(chartFrame.axisBaseClass));
        chartFrame.bottomAxisClass = bottomAxisClass;
        function createBottomAxis(container, axisDataOrScale, useWebGl, isCrisp) {
            if (isCrisp === void 0) { isCrisp = true; }
            return new bottomAxisClass(container, axisDataOrScale, useWebGl, isCrisp);
        }
        chartFrame.createBottomAxis = createBottomAxis;
    })(chartFrame = vp.chartFrame || (vp.chartFrame = {}));
})(vp || (vp = {}));
/// chartFrameEx.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var chartFrame;
    (function (chartFrame) {
        /** A visual object that hosts a title, legend, axes, gridlines, and a plot area.  */
        var chartFrameEx = (function () {
            function chartFrameEx(container, xData, yData) {
                //vp.utils.trace("ctr", "chartFrame");
                var _this = this;
                this._isCrisp = true;
                this._firstShow = true;
                this._xData = xData;
                this._yData = yData;
                this._container = container;
                //---- for SOME REASON, the CHART FRAME SVG group is not rendering on FireFox or Chrome. ----
                //var root = vp.select(container);
                //root.append("text")
                //    .position(20, 100)
                //    .colors("red", "black", .5)
                //    .font("verdana", 38, true, true)
                //    .text("BeachParty!");
                this._rootMark = vp.marks.createGroupMark(container, "vpxChartFrame");
                var uRootElem = this._rootMark.rootElem();
                this._rootElem = uRootElem;
                var rootElem = vp.select(uRootElem);
                rootElem
                    .addClass("vpxChartFrame");
                this._leftAxis = vp.chartFrame.createLeftAxis(uRootElem, yData, null, true);
                this._bottomAxis = vp.chartFrame.createBottomAxis(uRootElem, xData, null, true);
                this._topAxis = vp.chartFrame.createTopAxis(uRootElem, xData, null, true);
                this._rightAxis = vp.chartFrame.createRightAxis(uRootElem, yData, null, true);
                this._gridLines = vp.chartFrame.createGridLines(uRootElem, xData, yData, true)
                    .isXVisible(xData != null)
                    .isYVisible(yData != null);
                this._titleMark = vp.marks.createTextMark(uRootElem, "vpxAxisTitle")
                    .onShade(function (element, record, index, isNew, isLastNew) {
                    _this.shadeTextMark(10, 10, "start", element, _this._title.text);
                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew, isLastNew);
                    }
                });
                this._subTitleMark = vp.marks.createTextMark(uRootElem, "vpxAxisSubTitle")
                    .onShade(function (element, record, index, isNew, isLastNew) {
                    _this.shadeTextMark(10, 30, "start", element, _this._subTitle.text);
                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew, isLastNew);
                    }
                });
                //---- PLACEHOLDER for now ----
                this._legend = vp.chartFrame.createRightAxis(uRootElem, null, null, true);
                this._boxMark = vp.marks.createRectangleMark(uRootElem, "vpxAxisBox")
                    .onShade(function (element, record, index, isNew, isLastNew) {
                    var rc = _this._rcPlot;
                    vp.select(element)
                        .bounds(rc.left, rc.top, rc.width, rc.height, _this._isCrisp);
                });
                //---- only LEFT and BOTTOM are visible by default ----
                this._topAxis.hide();
                this._rightAxis.hide();
                this._boxMark.hide();
                this._legend.hide();
                this._titleMark.hide();
                this._subTitleMark.hide();
                this._gridLines.hide();
                this.buildDefaultDrawingParams();
            }
            chartFrameEx.prototype.shadeTextMark = function (x, y, anchor, element, text) {
                var wrap = vp.select(element)
                    .text(text);
                wrap = vp.select(element)
                    .attr("x", x + "")
                    .attr("y", y + "")
                    .attr("text-anchor", anchor);
                //---- now that properties are all set, VERT ALIGN at "cy" ----
                //this.finalTextBaseline(this._fakeNameLabel, wrap, "middle");
                //var szLabel = this.getFinalTextSize(this._name, this._drawingParams.name, this._fakeNameLabel);
                //this._maxTextWidth = szLabel.width;
            };
            chartFrameEx.prototype.hide = function (transition) {
                if (transition === undefined) {
                    transition = this._transition;
                }
                this._rootMark.hide(transition);
            };
            chartFrameEx.prototype.show = function (transition) {
                if (transition === undefined) {
                    transition = this._transition;
                }
                this._rootMark.show(transition);
            };
            chartFrameEx.prototype.isVisible = function () {
                return this._rootMark.isVisible();
            };
            chartFrameEx.prototype.buildAndShow = function (axis, show) {
                if (show) {
                    if (axis.isVisible()) {
                        //---- change visible axis with animation ----
                        axis.build();
                    }
                    else {
                        axis.build(undefined); // build without animation
                        axis.show(); // show with animation
                    }
                }
                else {
                    axis.hide();
                }
            };
            chartFrameEx.prototype.build = function (transition) {
                if (transition === undefined) {
                    transition = this._transition;
                }
                //---- apply drawing params to sub-marks ----
                var dp = this._drawingParams;
                this._leftAxis.drawingParams(dp ? dp.leftAxis : null);
                this._topAxis.drawingParams(dp ? dp.topAxis : null);
                this._rightAxis.drawingParams(dp ? dp.rightAxis : null);
                this._bottomAxis.drawingParams(dp ? dp.bottomAxis : null);
                this._boxMark.drawingParams(dp ? dp.box : null);
                this._gridLines.drawingParams(dp ? dp.gridLines : null);
                this._titleMark.drawingParams(dp ? dp.title : null);
                this._subTitleMark.drawingParams(dp ? dp.subTitle : null);
                this._legend.drawingParams(dp ? dp.legend : null);
                var transition = this._transition;
                var width = this._width;
                var height = this._height;
                var left = 0;
                var top = 0;
                var right = width;
                var bottom = height;
                //---- layout TITLE ----
                //---- layout SUBTITLE ----
                //---- layout LEGEND ----
                this.layoutAxes(transition, left, top, right, bottom);
                var rcPlot = this._rcPlot;
                //---- call build() on all sub-marks ----
                this.buildAndShow(this._leftAxis, this._isLeftAxisVisible);
                this.buildAndShow(this._bottomAxis, this._isBottomAxisVisible);
                this.buildAndShow(this._topAxis, this._isTopAxisVisible);
                this.buildAndShow(this._rightAxis, this._isRightAxisVisible);
                //---- follow marks need show/hide calls ----
                if (this._isBoxVisible) {
                    this._boxMark.build();
                    this._boxMark.show();
                }
                else {
                    this._boxMark.hide();
                }
                //vp.utils.debug("chartFrame: isGridVisible: " + this._isGridLinesVisible);
                if (this._isGridLinesVisible) {
                    this._gridLines
                        .width(rcPlot.width)
                        .height(rcPlot.height)
                        .translate(rcPlot.left, rcPlot.top, this._isCrisp)
                        .show()
                        .build();
                }
                else {
                    this._gridLines.hide();
                }
                if (this._isTitleVisible) {
                    this._titleMark.build();
                }
                if (this._isSubTitleVisible) {
                    this._subTitleMark.build();
                }
                if (this._legend.isVisible()) {
                    this._legend.build();
                }
            };
            chartFrameEx.prototype.layoutAxes = function (transition, left, top, right, bottom) {
                //---- start with approx. values ----
                var xHeight = 35;
                var yWidth = 75;
                var width = right - left;
                var height = bottom - top;
                var plotWidth = width; // - 40;
                var plotHeight = height; // - 40;
                var leftAxis = this._leftAxis;
                var bottomAxis = this._bottomAxis;
                var topAxis = this._topAxis;
                var rightAxis = this._rightAxis;
                var showLeft = this._isLeftAxisVisible;
                var showTop = this._isTopAxisVisible;
                var showRight = this._isRightAxisVisible;
                var showBottom = this._isBottomAxisVisible;
                var xScale = this._xData.scale();
                var yScale = this._yData.scale();
                if (showLeft) {
                    // plotWidth -= yWidth;
                    //---- will measure left and right axes with full height ----
                    leftAxis
                        .height(plotHeight);
                }
                if (showRight) {
                    //plotWidth -= yWidth;
                    //---- will measure left and right axes with full height ----
                    rightAxis
                        .height(plotHeight);
                }
                if (showTop) {
                    plotHeight -= xHeight;
                    topAxis
                        .width(plotWidth);
                }
                if (showBottom) {
                    plotHeight -= xHeight;
                    bottomAxis
                        .width(plotWidth);
                }
                //---- when less than 4 axes are drawn, we need to use padding so we don't truncate the end labels (which are centered on borders) ----
                var topPad = 10;
                var bottomPad = 10;
                var leftPad = 20;
                var rightPad = 20;
                var axesOnOutSide = this._axesOnOutSide;
                //---- rcPlot will exactly define the plot area rectangle ----
                var rcPlot = vp.geom.createRect(0, 0, width, height);
                //---- important: this block of code must call "getMeasuredXXX()" on each visible axis ----
                if ((showLeft || showRight || showTop || showBottom)) {
                    var leftWidth = (showLeft) ? leftAxis.getMeasuredWidth() : leftPad;
                    if (!axesOnOutSide) {
                        rcPlot.left = leftWidth;
                        rcPlot.width -= leftWidth;
                    }
                    var rightWidth = (showRight) ? rightAxis.getMeasuredWidth() : rightPad;
                    if (!axesOnOutSide) {
                        rcPlot.width -= rightWidth;
                    }
                    //---- left and right widths are final; apply them to top/bottom axes ----
                    bottomAxis.width(rcPlot.width);
                    topAxis.width(rcPlot.width);
                    var bottomHeight = (showBottom) ? bottomAxis.getMeasuredHeight() : bottomPad;
                    if (!axesOnOutSide) {
                        rcPlot.height -= bottomHeight;
                    }
                    var topHeight = (showTop) ? topAxis.getMeasuredHeight() : topPad;
                    if (!axesOnOutSide) {
                        rcPlot.top = topHeight;
                        rcPlot.height -= topHeight;
                    }
                }
                if (axesOnOutSide) {
                    rcPlot = vp.geom.createRect(0, 0, width, height);
                }
                rcPlot.right = rcPlot.left + rcPlot.width;
                rcPlot.bottom = rcPlot.top + rcPlot.height;
                this._rcPlot = rcPlot;
                //---- OK, rcPlot is FINAL; now we can start the actual layout ----
                //---- here we update the RANGE of our X and Y scales in screen pixel coordinates ----
                //---- this may work against a client using 3D range coordinates; they should pass us a COPY of their scales ----
                xScale.range(0, rcPlot.width);
                yScale.range(rcPlot.height, 0);
                this._gridLines
                    .width(rcPlot.width)
                    .height(rcPlot.height);
                if (showLeft) {
                    leftAxis
                        .height(rcPlot.height);
                    if (axesOnOutSide) {
                        leftAxis.translate(-leftAxis._measuredSize + 1, 0, this._isCrisp);
                    }
                    else {
                        leftAxis.translate(1 + leftAxis._leftPad, rcPlot.top, this._isCrisp);
                    }
                }
                if (showRight) {
                    rightAxis
                        .height(rcPlot.height);
                    if (axesOnOutSide) {
                        rightAxis.translate(rcPlot.right, 0, this._isCrisp);
                    }
                    else {
                        rightAxis.translate(rcPlot.right + 1, rcPlot.top, this._isCrisp);
                    }
                }
                if (showBottom) {
                    bottomAxis
                        .width(rcPlot.width);
                    if (axesOnOutSide) {
                        bottomAxis.translate(0, rcPlot.bottom, this._isCrisp);
                    }
                    else {
                        bottomAxis.translate(rcPlot.left, rcPlot.bottom, this._isCrisp);
                    }
                }
                if (showTop) {
                    topAxis
                        .width(rcPlot.width);
                    if (axesOnOutSide) {
                        topAxis.translate(0, -topAxis._measuredSize, this._isCrisp);
                    }
                    else {
                        topAxis.translate(rcPlot.left, 1, this._isCrisp);
                    }
                }
            };
            chartFrameEx.prototype.translate = function (x, y, isCrispAdjustment) {
                if (isCrispAdjustment === undefined && this._isCrisp) {
                    isCrispAdjustment = true;
                }
                //---- magic offset only works on direct groups? ----
                vp.select(this._rootElem)
                    .translate(x, y, isCrispAdjustment);
                return this;
            };
            chartFrameEx.prototype.onShade = function (value) {
                if (arguments.length === 0) {
                    return this._onShade;
                }
                this._onShade = value;
                return this;
            };
            chartFrameEx.prototype.width = function (value) {
                if (arguments.length === 0) {
                    return this._width;
                }
                this._width = value;
                return this;
            };
            chartFrameEx.prototype.height = function (value) {
                if (arguments.length === 0) {
                    return this._height;
                }
                this._height = value;
                return this;
            };
            chartFrameEx.prototype.isBoxVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isBoxVisible;
                }
                this._isBoxVisible = value;
                return this;
            };
            chartFrameEx.prototype.isLeftAxisVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isLeftAxisVisible;
                }
                this._isLeftAxisVisible = value;
                return this;
            };
            chartFrameEx.prototype.isTopAxisVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isTopAxisVisible;
                }
                this._isTopAxisVisible = value;
                return this;
            };
            chartFrameEx.prototype.isRightAxisVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isRightAxisVisible;
                }
                this._isRightAxisVisible = value;
                return this;
            };
            chartFrameEx.prototype.isBottomAxisVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isBottomAxisVisible;
                }
                this._isBottomAxisVisible = value;
                return this;
            };
            chartFrameEx.prototype.isGridLinesVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isGridLinesVisible;
                }
                this._isGridLinesVisible = value;
                return this;
            };
            chartFrameEx.prototype.isTitleVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isTitleVisible;
                }
                this._isTitleVisible = value;
                return this;
            };
            chartFrameEx.prototype.axesOnOutside = function (value) {
                if (arguments.length === 0) {
                    return this._axesOnOutSide;
                }
                this._axesOnOutSide = value;
                return this;
            };
            chartFrameEx.prototype.drawingParams = function (value) {
                if (arguments.length === 0) {
                    return this._drawingParams;
                }
                this._drawingParams = value;
                return this;
            };
            chartFrameEx.prototype.transition = function (value) {
                if (arguments.length == 0) {
                    return this._transition;
                }
                this._transition = value;
                this.onTransitionChanged();
                return this;
            };
            chartFrameEx.prototype.onTransitionChanged = function () {
                var transition = this._transition;
                this._leftAxis.transition(transition);
                this._topAxis.transition(transition);
                this._rightAxis.transition(transition);
                this._bottomAxis.transition(transition);
                this._boxMark.transition(transition);
                this._titleMark.transition(transition);
                this._subTitleMark.transition(transition);
                this._gridLines.transition(transition);
                this._legend.transition(transition);
            };
            chartFrameEx.prototype.rootElem = function () {
                return this._rootElem;
            };
            chartFrameEx.prototype.buildDefaultDrawingParams = function () {
                this._drawingParams =
                    {
                        leftAxis: this._leftAxis.drawingParams(),
                        topAxis: this._topAxis.drawingParams(),
                        rightAxis: this._rightAxis.drawingParams(),
                        bottomAxis: this._bottomAxis.drawingParams(),
                        gridLines: this._gridLines.drawingParams(),
                        legend: this._legend.drawingParams(),
                        box: {},
                        title: {},
                        subTitle: {},
                    };
            };
            chartFrameEx.prototype.leftAxis = function () {
                return this._leftAxis;
            };
            chartFrameEx.prototype.topAxis = function () {
                return this._topAxis;
            };
            chartFrameEx.prototype.rightAxis = function () {
                return this._rightAxis;
            };
            chartFrameEx.prototype.bottomAxis = function () {
                return this._bottomAxis;
            };
            chartFrameEx.prototype.gridLines = function () {
                return this._gridLines;
            };
            chartFrameEx.prototype.legend = function () {
                return this._legend;
            };
            chartFrameEx.prototype.title = function () {
                return this._title;
            };
            chartFrameEx.prototype.subTitle = function () {
                return this._subTitle;
            };
            chartFrameEx.prototype.isCrisp = function (value) {
                if (arguments.length === 0) {
                    return this._isCrisp;
                }
                this._isCrisp = value;
                this.onIsCrispChanged();
                return this;
            };
            chartFrameEx.prototype.onIsCrispChanged = function () {
                var isCrisp = this._isCrisp;
                this._bottomAxis.isCrisp(isCrisp);
                this._leftAxis.isCrisp(isCrisp);
                this._topAxis.isCrisp(isCrisp);
                this._rightAxis.isCrisp(isCrisp);
                this._gridLines.isCrisp(isCrisp);
                this._legend.isCrisp(isCrisp);
            };
            chartFrameEx.prototype.xAxisData = function (value) {
                if (arguments.length == 0) {
                    return this._xData;
                }
                this._xData = value;
                this._bottomAxis.axisData(value);
                this._topAxis.axisData(value);
                this._gridLines.xAxisData(value);
                return this;
            };
            chartFrameEx.prototype.yAxisData = function (value) {
                if (arguments.length == 0) {
                    return this._yData;
                }
                this._yData = value;
                this._leftAxis.axisData(value);
                this._rightAxis.axisData(value);
                this._gridLines.yAxisData(value);
                return this;
            };
            chartFrameEx.prototype.plotAreaBounds = function () {
                return this._rcPlot;
            };
            return chartFrameEx;
        }());
        chartFrame.chartFrameEx = chartFrameEx;
        /** Note: this class will update the range of the x and y scales, so you may want to pass a copy of them, rather than the original. */
        function createChartFrameEx(container, xData, yData) {
            return new chartFrameEx(container, xData, yData);
        }
        chartFrame.createChartFrameEx = createChartFrameEx;
        var textData = (function () {
            function textData() {
            }
            return textData;
        }());
        chartFrame.textData = textData;
    })(chartFrame = vp.chartFrame || (vp.chartFrame = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// gridLines.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var chartFrame;
    (function (chartFrame) {
        /** A set of horizontal and vertical gridlines, associated with X and Y scales.  */
        var gridLinesClass = (function () {
            function gridLinesClass(container, xData, yData, isCrisp) {
                //vp.utils.trace("ctr", "gridLines");
                var _this = this;
                if (isCrisp === void 0) { isCrisp = true; }
                this._firstShow = true;
                this._container = container;
                this._xData = xData;
                this._yData = yData;
                this._isCrisp = isCrisp;
                this._rootMark = vp.marks.createGroupMark(container, "vpxGridLines");
                var uRootElem = this._rootMark.rootElem();
                this._rootElem = uRootElem;
                var root = vp.select(uRootElem);
                root
                    .addClass("vpxGridLines");
                this.buildInitialDrawingParams();
                //---- create X GRID LINES ----
                this._xMark = vp.marks.createLineMark(uRootElem, "vpxXGridLine")
                    .onShade(function (element, record, index, isNew) {
                    var dp = _this._drawingParams ? _this._drawingParams.x : null;
                    _this.verticalGridLineShader(element, record, index, isNew, 0, _this._isCrisp, dp, -1);
                });
                //---- create X MINOR GRID LINES ----
                this._xMinorMark = vp.marks.createLineMark(uRootElem, "vpxXMinorGridLine")
                    .onShade(function (element, record, index, isNew) {
                    var dp = _this._drawingParams ? _this._drawingParams.xMinor : null;
                    _this.verticalGridLineShader(element, record, index, isNew, 0, _this._isCrisp, dp, -1);
                });
                //---- create Y GRID LINES ----
                this._yMark = vp.marks.createLineMark(uRootElem, "vpxYGridLine")
                    .onShade(function (element, record, index, isNew) {
                    var dp = _this._drawingParams ? _this._drawingParams.y : null;
                    _this.horizontalGridLineShader(element, record, index, isNew, 0, _this._isCrisp, dp, 1);
                });
                //---- create Y MINOR GRID LINES ----
                this._yMinorMark = vp.marks.createLineMark(uRootElem, "vpxYMinorGridLine")
                    .onShade(function (element, record, index, isNew) {
                    var dp = _this._drawingParams ? _this._drawingParams.yMinor : null;
                    _this.horizontalGridLineShader(element, record, index, isNew, 0, _this._isCrisp, dp, 1);
                });
            }
            gridLinesClass.prototype.buildInitialDrawingParams = function () {
                //---- don't overspecify - let CSS kick in where possible ----
                var daX = { startPadding: 0, endPadding: 0 }; //, lineSize: 1, lineType: "solid", opacity: 1, stroke: "gray" };
                var daY = { startPadding: 0, endPadding: 0 }; // , lineSize: 1, lineType: "solid", opacity: 1, stroke: "gray" };
                var daXMinor = { startPadding: 0, endPadding: 0, lineType: "dotted" }; //, lineSize: 1, opacity: 1, stroke: "gray" };
                var daYMinor = { startPadding: 0, endPadding: 0, lineType: "dotted" }; // , lineSize: 1, opacity: 1, stroke: "gray" };
                this._drawingParams = { x: daX, y: daY, xMinor: daXMinor, yMinor: daYMinor };
            };
            gridLinesClass.prototype.hide = function (transition) {
                if (transition === undefined) {
                    transition = this._transition;
                }
                this._rootMark.hide(transition);
                return this;
            };
            gridLinesClass.prototype.show = function (transition) {
                if (transition === undefined) {
                    transition = this._transition;
                }
                this._rootMark.show(transition);
                return this;
            };
            gridLinesClass.prototype.isVisible = function () {
                return this._rootMark.isVisible();
            };
            gridLinesClass.prototype.build = function (transition) {
                if (transition === undefined) {
                    transition = this._transition;
                }
                var xBreaks = this._xData.getActualBreaks();
                var result = this._xData.getOffsets(xBreaks);
                var xOffsets = result.tickOffsets;
                var xMinorOffsets = this._xData.getActualMinorOffsets(xBreaks);
                var yBreaks = this._yData.getActualBreaks();
                var result = this._yData.getOffsets(yBreaks);
                var yOffsets = result.tickOffsets;
                var yMinorOffsets = this._yData.getActualMinorOffsets(yBreaks);
                //---- hide X grids ----
                if (!this._isXVisible) {
                    xOffsets = [];
                    xMinorOffsets = [];
                }
                else if (!this._isXMinorVisible) {
                    xMinorOffsets = [];
                }
                //---- hide Y grids ----
                if (!this._isYVisible) {
                    yOffsets = [];
                    yMinorOffsets = [];
                }
                else if (!this._isYMinorVisible) {
                    yMinorOffsets = [];
                }
                //---- draw GRID LINES ----
                this._xMark.generate(xOffsets, transition);
                this._xMinorMark.generate(xMinorOffsets, transition);
                this._yMark.generate(yOffsets, transition);
                this._yMinorMark.generate(yMinorOffsets, transition);
            };
            gridLinesClass.prototype.horizontalGridLineShader = function (element, record, index, isNew, xOffset, isCrisp, da, dir) {
                if (dir === void 0) { dir = 1; }
                var width = this._width - da.startPadding - da.endPadding;
                var xStart = xOffset + dir * da.startPadding;
                var xEnd = xStart + dir * width;
                var y = record;
                vp.select(element)
                    .hLine(xStart, xEnd, y, isCrisp);
                vp.marks.applyLineParams(element, da);
                if (this._onShade) {
                    this._onShade(element, record, index, isNew);
                }
            };
            gridLinesClass.prototype.verticalGridLineShader = function (element, record, index, isNew, yOffset, isCrisp, da, dir) {
                if (dir === void 0) { dir = 1; }
                var height = this._height - da.startPadding - da.endPadding;
                var x = record;
                var yStart = yOffset - dir * da.startPadding;
                var yEnd = yStart - dir * height;
                vp.select(element)
                    .vLine(yStart, yEnd, x, isCrisp);
                vp.marks.applyLineParams(element, da);
                if (this._onShade) {
                    this._onShade(element, record, index, isNew);
                }
            };
            gridLinesClass.prototype.opacity = function (value) {
                if (arguments.length === 0) {
                    return this._rootMark.opacity();
                }
                this._rootMark.opacity(value);
                return this;
            };
            gridLinesClass.prototype.height = function (value) {
                if (arguments.length === 0) {
                    return this._height;
                }
                this._height = value;
                return this;
            };
            gridLinesClass.prototype.width = function (value) {
                if (arguments.length === 0) {
                    return this._width;
                }
                this._width = value;
                return this;
            };
            gridLinesClass.prototype.isXVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isXVisible;
                }
                this._isXVisible = value;
                return this;
            };
            gridLinesClass.prototype.isYVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isYVisible;
                }
                this._isYVisible = value;
                return this;
            };
            gridLinesClass.prototype.isXMinorVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isXMinorVisible;
                }
                this._isXMinorVisible = value;
                return this;
            };
            gridLinesClass.prototype.isYMinorVisible = function (value) {
                if (arguments.length === 0) {
                    return this._isYMinorVisible;
                }
                this._isYMinorVisible = value;
                return this;
            };
            gridLinesClass.prototype.isCrisp = function (value) {
                if (arguments.length === 0) {
                    return this._isCrisp;
                }
                this._isCrisp = value;
                return this;
            };
            gridLinesClass.prototype.drawingParams = function (value) {
                if (arguments.length === 0) {
                    return this._drawingParams;
                }
                this._drawingParams = value;
                return this;
            };
            gridLinesClass.prototype.translate = function (x, y, isCrispAdjustment) {
                vp.select(this._rootElem)
                    .translate(x, y, isCrispAdjustment);
                return this;
            };
            gridLinesClass.prototype.transition = function (value) {
                if (arguments.length == 0) {
                    return this._transition;
                }
                this._transition = value;
                return this;
            };
            gridLinesClass.prototype.rootElem = function () {
                return this._rootElem;
            };
            gridLinesClass.prototype.xAxisData = function (value) {
                if (arguments.length == 0) {
                    return this._xData;
                }
                this._xData = value;
                return this;
            };
            gridLinesClass.prototype.yAxisData = function (value) {
                if (arguments.length == 0) {
                    return this._yData;
                }
                this._yData = value;
                return this;
            };
            return gridLinesClass;
        }());
        chartFrame.gridLinesClass = gridLinesClass;
        function createGridLines(container, xData, yData, isCrisp) {
            if (isCrisp === void 0) { isCrisp = true; }
            return new gridLinesClass(container, xData, yData, isCrisp);
        }
        chartFrame.createGridLines = createGridLines;
    })(chartFrame = vp.chartFrame || (vp.chartFrame = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// leftAxis.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var chartFrame;
    (function (chartFrame) {
        /** creates a vertical axis with the labels to the right of the axis line. */
        var leftAxisClass = (function (_super) {
            __extends(leftAxisClass, _super);
            function leftAxisClass(container, axisDataOrScale, useWebGl, isCrisp) {
                var _this = this;
                _super.call(this, container, axisDataOrScale, useWebGl, isCrisp, chartFrame.LabelLocation.left);
                this._leftPad = 0;
                //vp.utils.trace("ctr", "leftAxis");
                this._nameRotation = 90; // the default for a left axis
                var root = this._rootElem;
                //---- create AXIS NAME ----
                this._nameMark = vp.marks.createTextMark(root, "vpxAxisName")
                    .onShade(function (element, record, index, isNew) {
                    /// General Note: when laying out elements with animations potentially active,
                    /// we cannot rely on system calls to determine position - we have to track 
                    /// x,y positions manually.  This is because calls like "elem.attr("x", 34)" don't change
                    /// "x" to 34 until the end of the animation.
                    var wrap = vp.select(element)
                        .text(_this._name);
                    var cx = _this._offset;
                    var cy = _this._axisSize / 2;
                    wrap = vp.select(element)
                        .attr("x", cx + "")
                        .attr("y", cy + "")
                        .attr("text-anchor", "start");
                    //---- now that properties are all set, VERT ALIGN at "cy" ----
                    _this.finalTextBaseline(_this._fakeNameLabel, wrap, "middle");
                    if (_this._nameRotation) {
                        if (_this._nameRotation == 45 || _this._nameRotation == -45) {
                            var result = _this.rotateText45(_this._name, wrap, vp.chartFrame.LabelLocation.left, _this._nameRotation, _this._drawingParams.name, _this._fakeNameLabel);
                            _this._maxTextWidth = result.width;
                        }
                        else if (_this._nameRotation == 90 || _this._nameRotation == -90) {
                            var result = _this.rotateText90(_this._name, wrap, vp.chartFrame.LabelLocation.left, cx, cy, _this._nameRotation, _this._drawingParams.name, _this._fakeNameLabel);
                            _this._maxTextWidth = result.width;
                        }
                    }
                    else {
                        var szLabel = _this.getFinalTextSize(_this._name, _this._drawingParams.name, _this._fakeNameLabel);
                        _this._maxTextWidth = szLabel.width;
                    }
                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });
                //---- create AXIS LABELS ----
                this._labelMark = vp.marks.createTextMark(root, "vpxAxisLabel")
                    .keyFunc(chartFrame.labelKeyFunc)
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    //---- szMaxText has been set to the largest measured label width/height ----
                    var textWidth = _this._szMaxText.width;
                    var availPixelsPerLabel = _this.getAvailablePixelsPerLabelForTruncation(_this._actualLabelRotation);
                    //---- will we apply truncation? ----
                    if (_this._labelOverflow == chartFrame.LabelOverflow.ellipses || _this._labelOverflow == chartFrame.LabelOverflow.truncate) {
                        textWidth = Math.min(textWidth, availPixelsPerLabel);
                    }
                    textWidth = _this.rotatedSize(_this._actualLabelRotation, textWidth, _this._szMaxText.height);
                    var xRight = _this._offset + textWidth;
                    var cy = record.offset;
                    var myWidth = _this.shadeTextLabel(index, element, xRight, cy, record.label, "end", "middle", chartFrame.LabelLocation.right, true, availPixelsPerLabel, isLastNew);
                    _this._maxTextWidth = Math.max(_this._maxTextWidth, myWidth);
                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew, isLastNew);
                    }
                });
                //---- create AXIS TICKS  ----
                this._tickMark = vp.marks.createLineMark(root, "vpxAxisTick")
                    .keyFunc(chartFrame.indexKeyFunc)
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    _this.horizontalTickShader(element, record, index, isNew, _this._offset, _this._drawingParams.tickLength, record, isLastNew);
                });
                //---- create AXIS TICK BOXES  ----
                this._tickBox = vp.marks.createRectangleMark(root, "vpxAxisTickBox")
                    .keyFunc(chartFrame.indexKeyFunc)
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    _this.horizontalTickBoxShader(element, record, index, isNew, _this._offset, _this._drawingParams.tickLength, record, isLastNew);
                });
                //---- create MINOR TICKS  ----
                this._minorTickMark = vp.marks.createLineMark(root, "vpxAxisMinorTick")
                    .keyFunc(chartFrame.indexKeyFunc)
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    _this.horizontalTickShader(element, record, index, isNew, _this._offset, _this._drawingParams.minorTickLength, record, isLastNew);
                });
                //---- create AXIS LINE ----
                this._axisLineMark = vp.marks.createLineMark(root, "vpxAxisLine")
                    .onShade(function (element, record, index, isNew) {
                    var yStart = 0;
                    var yEnd = _this._axisSize;
                    var x = _this._offset;
                    vp.select(element)
                        .vLine(yStart, yEnd, x, _this._isCrisp);
                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });
            }
            leftAxisClass.prototype.shadeMarks = function (transition, record, index, isNew, context, measureOnly) {
                var dp = this._drawingParams;
                var generate = (!measureOnly);
                var group = vp.select(this._rootElem)
                    .addClass("vpxAxis");
                this._maxTextWidth = 0;
                this._offset = dp.startPadding;
                //---- generate SUB MARKS ----
                this.generateHorizontalName(generate, transition, false);
                this.generateHorizontalLabels(generate, transition, false);
                this.generateTicks(generate, transition, false);
                this.generateAxisLine(generate, transition, false);
                this._offset += dp.endPadding;
                if (this._minWidth && this._minWidth > this._offset) {
                    this._leftPad = this._minWidth - this._offset;
                    this._measuredSize = this._minWidth;
                }
                else {
                    this._leftPad = 0;
                    this._measuredSize = this._offset;
                }
            };
            leftAxisClass.prototype.height = function (value) {
                if (arguments.length === 0) {
                    return this._axisSize;
                }
                this._axisSize = value;
                return this;
            };
            return leftAxisClass;
        }(chartFrame.axisBaseClass));
        chartFrame.leftAxisClass = leftAxisClass;
        function createLeftAxis(container, axisDataOrScale, useWebGl, isCrisp) {
            if (isCrisp === void 0) { isCrisp = true; }
            return new leftAxisClass(container, axisDataOrScale, useWebGl, isCrisp);
        }
        chartFrame.createLeftAxis = createLeftAxis;
    })(chartFrame = vp.chartFrame || (vp.chartFrame = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// rightAxis.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var chartFrame;
    (function (chartFrame) {
        /** creates a vertical axis with the labels to the right of the axis line. */
        var rightAxisClass = (function (_super) {
            __extends(rightAxisClass, _super);
            function rightAxisClass(container, axisDataOrScale, useWebGl, isCrisp) {
                var _this = this;
                _super.call(this, container, axisDataOrScale, useWebGl, isCrisp, chartFrame.LabelLocation.right);
                //vp.utils.trace("ctr", "rightAxis");
                this._nameRotation = 90; // the default for a right axis
                var root = this._rootElem;
                //---- create AXIS LINE ----
                this._axisLineMark = vp.marks.createLineMark(root, "vpxAxisLine")
                    .keyFunc(chartFrame.indexKeyFunc)
                    .onShade(function (element, record, index, isNew) {
                    var yStart = 0;
                    var yEnd = _this._axisSize;
                    var x = _this._offset;
                    vp.select(element)
                        .vLine(yStart - 1, yEnd, x, _this._isCrisp);
                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });
                //---- create AXIS TICKS ----
                this._tickMark = vp.marks.createLineMark(root, "vpxAxisTick")
                    .keyFunc(chartFrame.indexKeyFunc)
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    _this.horizontalTickShader(element, record, index, isNew, _this._offset, -_this._drawingParams.tickLength, record, isLastNew);
                });
                //---- create AXIS TICK BOXES  ----
                this._tickBox = vp.marks.createRectangleMark(root, "vpxAxisTickBox")
                    .keyFunc(chartFrame.indexKeyFunc)
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    _this.horizontalTickBoxShader(element, record, index, isNew, _this._offset, _this._drawingParams.tickLength, record, isLastNew);
                });
                //---- create MINOR TICKS  ----
                this._minorTickMark = vp.marks.createLineMark(root, "vpxAxisMinorTick")
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    _this.horizontalTickShader(element, record, index, isNew, _this._offset, -_this._drawingParams.minorTickLength, record, isLastNew);
                });
                //---- create AXIS LABELS ----
                this._labelMark = vp.marks.createTextMark(root, "vpxAxisLabel")
                    .keyFunc(chartFrame.labelKeyFunc)
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    //---- szMaxText has been set to the largest measured label width/height ----
                    var xLeft = _this._offset;
                    var cy = record.offset - 1; // small adjustment for asthetics
                    var availPixelsPerLabel = _this.getAvailablePixelsPerLabelForTruncation(_this._actualLabelRotation);
                    var myWidth = _this.shadeTextLabel(index, element, xLeft, cy, record.label, "start", "middle", vp.chartFrame.LabelLocation.left, true, availPixelsPerLabel, isLastNew);
                    _this._maxTextWidth = Math.max(_this._maxTextWidth, myWidth);
                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew, isLastNew);
                    }
                });
                //---- create AXIS NAME ----
                this._nameMark = vp.marks.createTextMark(root, "vpxAxisName")
                    .onShade(function (element, record, index, isNew) {
                    var wrap = vp.select(element)
                        .text(_this._name);
                    var cx = _this._offset;
                    var cy = _this._axisSize / 2;
                    wrap = vp.select(element)
                        .attr("x", cx + "")
                        .attr("y", cy + "")
                        .attr("text-anchor", "start");
                    //---- now that properties are all set, VERT ALIGN at "cy" ----
                    _this.finalTextBaseline(_this._fakeNameLabel, wrap, "middle");
                    if (_this._nameRotation) {
                        if (_this._nameRotation == 45 || _this._nameRotation == -45) {
                            var result = _this.rotateText45(_this._name, wrap, vp.chartFrame.LabelLocation.left, _this._nameRotation, _this._drawingParams.name, _this._fakeNameLabel);
                            _this._maxTextWidth = result.width;
                        }
                        else if (_this._nameRotation == 90 || _this._nameRotation == -90) {
                            var result = _this.rotateText90(_this._name, wrap, vp.chartFrame.LabelLocation.left, cx, cy, _this._nameRotation, _this._drawingParams.name, _this._fakeNameLabel);
                            _this._maxTextWidth = result.width;
                        }
                    }
                    else {
                        var szLabel = _this.getFinalTextSize(_this._name, _this._drawingParams.name, _this._fakeNameLabel);
                        _this._maxTextWidth = szLabel.width;
                    }
                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });
            }
            rightAxisClass.prototype.shadeMarks = function (transition, record, index, isNew, context, measureOnly) {
                var dp = this._drawingParams;
                var generate = (!measureOnly);
                var group = vp.select(this._rootElem)
                    .addClass("vpxAxis");
                this._maxTextWidth = 0;
                this._offset = dp.startPadding;
                //---- generate SUB MARKS ----
                this.generateAxisLine(generate, transition, true);
                this.generateTicks(generate, transition, true);
                this.generateHorizontalLabels(generate, transition, true);
                this.generateHorizontalName(generate, transition, true);
                this._offset += dp.endPadding;
                this._measuredSize = this._offset;
            };
            rightAxisClass.prototype.height = function (value) {
                if (arguments.length === 0) {
                    return this._axisSize;
                }
                this._axisSize = value;
                return this;
            };
            return rightAxisClass;
        }(chartFrame.axisBaseClass));
        chartFrame.rightAxisClass = rightAxisClass;
        function createRightAxis(container, axisDataOrScale, useWebGl, isCrisp) {
            if (isCrisp === void 0) { isCrisp = true; }
            return new rightAxisClass(container, axisDataOrScale, useWebGl, isCrisp);
        }
        chartFrame.createRightAxis = createRightAxis;
    })(chartFrame = vp.chartFrame || (vp.chartFrame = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// topAxis.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var chartFrame;
    (function (chartFrame) {
        /** creates a vertical axis with the labels to the right of the axis line. */
        var topAxisClass = (function (_super) {
            __extends(topAxisClass, _super);
            function topAxisClass(container, axisDataOrScale, useWebGl, isCrisp) {
                var _this = this;
                _super.call(this, container, axisDataOrScale, useWebGl, isCrisp, chartFrame.LabelLocation.top);
                //vp.utils.trace("ctr", "topAxis");
                var root = this._rootElem;
                //---- create AXIS NAME ----
                this._nameMark = vp.marks.createTextMark(root, "vpxAxisName")
                    .onShade(function (element, record, index, isNew) {
                    var wrap = vp.select(element)
                        .text(_this._name);
                    //---- get early "rc" so we can bottom align (rotation vs. top align causing problem here) ----
                    var rc = vp.dom.getBounds(element); // .getBBox();
                    var cx = _this._axisSize / 2;
                    var textHeight = _this.rotatedSize(_this._nameRotation, rc.height, rc.width);
                    var cy = _this._offset; // + textHeight; 
                    var wrap = vp.select(element)
                        .attr("x", cx + "")
                        .attr("y", cy + "")
                        .attr("text-anchor", "middle");
                    //---- now that properties are all set, VERT ALIGN at "cy" ----
                    _this.finalTextBaseline(_this._fakeNameLabel, wrap, "top");
                    if (_this._nameRotation) {
                        if (_this._nameRotation == 45 || _this._nameRotation == -45) {
                            var result = _this.rotateText45(_this._name, wrap, vp.chartFrame.LabelLocation.bottom, _this._nameRotation, _this._drawingParams.name, _this._fakeNameLabel);
                            _this._maxTextHeight = result.height;
                        }
                        else if (_this._nameRotation == 90 || _this._nameRotation == -90) {
                            var result = _this.rotateText90(_this._name, wrap, vp.chartFrame.LabelLocation.bottom, cx, cy, _this._nameRotation, _this._drawingParams.name, _this._fakeNameLabel);
                            _this._maxTextHeight = result.height;
                        }
                    }
                    else {
                        var szLabel = _this.getFinalTextSize(_this._name, _this._drawingParams.name, _this._fakeNameLabel);
                        _this._maxTextHeight = szLabel.height;
                    }
                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });
                //---- create AXIS LABELS ----
                this._labelMark = vp.marks.createTextMark(root, "vpxAxisLabel")
                    .keyFunc(chartFrame.labelKeyFunc)
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    var textHeight = _this._szMaxText.height;
                    var availPixelsPerLabel = _this.getAvailablePixelsPerLabelForTruncation(_this._actualLabelRotation);
                    //---- will we apply truncation? ----
                    if (_this._labelOverflow == chartFrame.LabelOverflow.ellipses || _this._labelOverflow == chartFrame.LabelOverflow.truncate) {
                        textHeight = Math.min(textHeight, availPixelsPerLabel);
                    }
                    textHeight = _this.rotatedSize(_this._actualLabelRotation, textHeight, _this._szMaxText.width);
                    var cx = record.offset;
                    var yBottom = _this._offset + textHeight;
                    var availPixelsPerLabel = _this.getAvailablePixelsPerLabelForTruncation(_this._actualLabelRotation);
                    var myHeight = _this.shadeTextLabel(index, element, cx, yBottom, record.label, "middle", "bottom", chartFrame.LabelLocation.bottom, false, textHeight, isLastNew);
                    _this._maxTextHeight = Math.max(_this._maxTextHeight, myHeight);
                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew, isLastNew);
                    }
                });
                //---- create AXIS TICKS ----
                this._tickMark = vp.marks.createLineMark(root, "vpxAxisTick")
                    .keyFunc(chartFrame.indexKeyFunc)
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    _this.verticalTickShader(element, record, index, isNew, _this._offset, _this._drawingParams.tickLength, record, isLastNew);
                });
                //---- create AXIS TICK BOXES ----
                this._tickBox = vp.marks.createRectangleMark(root, "vpxAxisTickBox")
                    .keyFunc(chartFrame.indexKeyFunc)
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    _this.verticalTickBoxShader(element, record, index, isNew, _this._offset, _this._drawingParams.tickLength, record, isLastNew);
                });
                //---- create MINOR TICKS  ----
                this._minorTickMark = vp.marks.createLineMark(root, "vpxAxisMinorTick")
                    .keyFunc(chartFrame.indexKeyFunc)
                    .onShade(function (element, record, index, isNew, context, transition, isLastNew) {
                    _this.verticalTickShader(element, record, index, isNew, _this._offset, _this._drawingParams.minorTickLength, record, isLastNew);
                });
                //---- create AXIS LINE ----
                this._axisLineMark = vp.marks.createLineMark(root, "vpxAxisLine")
                    .onShade(function (element, record, index, isNew) {
                    var xStart = 0;
                    var xEnd = _this._axisSize;
                    var y = _this._offset;
                    vp.select(element)
                        .hLine(xStart, xEnd, y, _this._isCrisp);
                    if (_this._onShade) {
                        _this._onShade(element, record, index, isNew);
                    }
                });
            }
            topAxisClass.prototype.shadeMarks = function (transition, record, index, isNew, context, measureOnly) {
                var dp = this._drawingParams;
                var generate = (!measureOnly);
                var group = vp.select(this._rootElem)
                    .addClass("vpxAxis");
                this._maxTextWidth = 0;
                this._offset = dp.startPadding;
                //---- generate SUB MARKS ----
                this.generateVerticalName(generate, transition, false);
                this.generateVerticalLabels(generate, transition, false);
                this.generateTicks(generate, transition, false);
                this.generateAxisLine(generate, transition, false);
                this._offset += dp.endPadding;
                this._measuredSize = this._offset;
            };
            topAxisClass.prototype.width = function (value) {
                if (arguments.length === 0) {
                    return this._axisSize;
                }
                this._axisSize = value;
                return this;
            };
            return topAxisClass;
        }(chartFrame.axisBaseClass));
        chartFrame.topAxisClass = topAxisClass;
        function createTopAxis(container, axisDataOrScale, useWebGl, isCrisp) {
            if (isCrisp === void 0) { isCrisp = true; }
            return new topAxisClass(container, axisDataOrScale, useWebGl, isCrisp);
        }
        chartFrame.createTopAxis = createTopAxis;
    })(chartFrame = vp.chartFrame || (vp.chartFrame = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// canvasElement.ts.  Copyright (c) 201r Microsoft Corporation.
///            Part of the vuePlotCore library - the base class for a canvas container or element.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var canvas;
    (function (canvas) {
        var nextCanvasElementId = 1;
        //---- class: canvasElement ----
        //----    Lightweight class to hold attributes for a canvas shape, and optional children. ----
        var canvasElement = (function () {
            function canvasElement(parent) {
                this.ctr = "vp.canvasElement;";
                this.transform = null;
                this.id = nextCanvasElementId++;
                this.stylesByClass = {};
                this.stroke = "";
                this.fill = "";
                this.parentNode = parent;
                this.rootContainer = this.getRoot(parent);
                this.opacity = 1;
                this["stroke-width"] = 0;
            }
            canvasElement.prototype.clientRectToBoundingBox = function (rc) {
                var bb = { x: rc.left, y: rc.top, width: rc.width, height: rc.height, right: rc.right, bottom: rc.bottom };
                return bb;
            };
            canvasElement.prototype.getRoot = function (elem) {
                while ((elem) && (elem.ctr != "vp.canvasContainerElement") && (elem.tagName != "CANVAS")) {
                    elem = elem.parentNode;
                    ;
                }
                if (elem && elem.tagName == "CANVAS") {
                    elem = elem.canvasContainerElement; // canvasContainerElement associated with the CANVAS
                }
                return elem;
            };
            canvasElement.prototype.drawFrame = function (ctx, container) {
                this.preDraw(ctx);
                this.drawAll(ctx, container);
                this.postDraw(ctx);
            };
            canvasElement.prototype.preDraw = function (ctx) {
                ctx.globalAlpha = this.opacity;
                if (this.transform) {
                    var trans = this.transform;
                    ctx.setTransform(trans.sx, 0, 0, trans.sy, trans.tx, trans.ty);
                    if (trans.angle) {
                        ctx.translate(trans.cx, trans.cy);
                        ctx.rotate(Math.PI / 180 * trans.angle);
                    }
                }
            };
            canvasElement.prototype.drawAll = function (ctx, container) {
            };
            canvasElement.prototype.postDraw = function (ctx) {
                if (this.transform) {
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                }
            };
            canvasElement.prototype.markDrawNeeded = function () {
                this.rootContainer.markDrawNeeded();
            };
            canvasElement.prototype.setPathData = function (value) {
            };
            canvasElement.prototype.setPathPoints = function (value) {
            };
            /// todo: remove shortcuts (assuming no spaces between func name and "(", limited # of spaces in func args).
            canvasElement.prototype.getInsideOfFuncStr = function (str, funcName) {
                var result = null;
                var index = str.indexOf(funcName + "(");
                if (index > -1) {
                    var index2 = str.indexOf(")", index);
                    if (index2 > -1) {
                        var start = index + funcName.length + 1;
                        var len = index2 - start;
                        result = str.substr(start, len).trim();
                        result = result.replace(/,/g, ' '); // translate commas into spaces
                        result = result.replace(/  /g, ' '); // compress double spaces to single
                        result = result.replace(/  /g, ' '); // compress double spaces to single
                    }
                }
                return result;
            };
            canvasElement.prototype.setTransform = function (value) {
                var transform = null;
                if (value) {
                    var transform = { tx: 0, ty: 0, sx: 1, sy: 1, angle: 0, cx: 0, cy: 0 };
                    var result = this.getInsideOfFuncStr(value, "translate");
                    if (result) {
                        var numbers = result.split(' ');
                        transform.tx = +numbers[0];
                        transform.ty = +numbers[1];
                    }
                    var result = this.getInsideOfFuncStr(value, "scale");
                    if (result) {
                        var numbers = result.split(' ');
                        transform.sx = +numbers[0];
                        transform.sy = +numbers[1];
                    }
                    var result = this.getInsideOfFuncStr(value, "rotate");
                    if (result) {
                        var numbers = result.split(' ');
                        transform.angle = +numbers[0];
                        transform.cx = +numbers[1];
                        transform.cy = +numbers[2];
                    }
                }
                this.transform = transform;
                this.markDrawNeeded();
            };
            canvasElement.prototype.getTransform = function () {
                var str = "";
                if (this.transform) {
                    var trans = this.transform;
                    var str = "";
                    if (trans.tx != 0 || trans.ty != 0) {
                        str += "translate(" + trans.tx + " " + trans.ty + ") ";
                    }
                    if (trans.sx != 1 || trans.sy != 1) {
                        str += "scale(" + trans.sx + " " + trans.sy + ") ";
                    }
                    if (trans.angle) {
                        str += "rotate(" + trans.angle + " " + trans.cx + " " + trans.cy + ") ";
                    }
                }
                return str;
            };
            canvasElement.prototype.applyStyle = function (style) {
                if (style.opacity !== undefined) {
                    this.opacity = style.opacity;
                }
                if (style.fill !== undefined) {
                    this.fill = style.fill;
                }
                if (style.stroke !== undefined) {
                    this.stroke = style.stroke;
                }
                if (style.strokeWidth !== undefined) {
                    this["stroke-width"] = parseFloat(style.strokeWidth); // ignore "px" units on end, if any
                }
            };
            canvasElement.prototype.setAttribute = function (name, value) {
                if (name == "d") {
                    //---- special handling for path's data property ----
                    this.setPathData(value);
                }
                else if (name == "points") {
                    //---- special handling for path's data property ----
                    this.setPathPoints(value);
                }
                else if (name == "transform") {
                    this.setTransform(value);
                }
                else {
                    this[name] = value;
                }
                this.markDrawNeeded();
            };
            canvasElement.prototype.getAttribute = function (name) {
                return this[name];
            };
            canvasElement.prototype.append = function (strElem) {
                var elem = null;
                if (strElem == "rect") {
                    elem = new canvas.canvasRectElement(this);
                }
                else if (strElem == "circle") {
                    elem = new canvas.canvasCircleElement(this);
                }
                else if (strElem == "ellipse") {
                    elem = new canvas.canvasEllipseElement(this);
                }
                else if (strElem == "text") {
                    elem = new canvas.canvasTextElement(this);
                }
                else if (strElem == "line") {
                    elem = new canvas.canvasLineElement(this);
                }
                else if (strElem == "path") {
                    elem = new canvas.canvasPathElement(this);
                }
                else if (strElem == "image") {
                    elem = new canvas.canvasImageElement(this);
                }
                else if (strElem == "polygon") {
                    elem = new canvas.canvasPolygonElement(this);
                }
                else if (strElem == "g") {
                    elem = new canvas.canvasGroupElement(this);
                }
                else {
                    vp.utils.error("This element type not yet supported for canvas by VuePlot: " + strElem);
                }
                if (elem != null) {
                    this.children.push(elem);
                    this.markDrawNeeded();
                }
                return elem;
            };
            return canvasElement;
        }());
        canvas.canvasElement = canvasElement;
    })(canvas = vp.canvas || (vp.canvas = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// canvasCircleElement.ts.  Copyright (c) 2016 Microsoft Corporation.
///     Part of the vuePlotore library - represents a lightweight CANVAS CIRCLE element.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var canvas;
    (function (canvas) {
        //---- class: canvasCircleElement ----
        var canvasCircleElement = (function (_super) {
            __extends(canvasCircleElement, _super);
            function canvasCircleElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasCircleElement";
                this.tagName = "circle";
                this.cx = 0;
                this.cy = 0;
                this.r = 0;
            }
            canvasCircleElement.prototype.applyStyle = function (style) {
                _super.prototype.applyStyle.call(this, style);
            };
            canvasCircleElement.prototype.getOffset = function () {
                var x = this.cx - this.r;
                var y = this.cy - this.r;
                return { x: x, y: y };
            };
            /// return elem found at x,y.
            canvasCircleElement.prototype.hitTest = function (x, y) {
                var elem = null;
                //---- for circle, this is easy.  use distance <= r for match ----
                var xdiff = this.cx - x;
                var ydiff = this.cy - y;
                var dist = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
                if (dist <= this.r) {
                    elem = this;
                }
                //vp.utils.debug("circle.hitTest: dist=" + dist);
                return elem;
            };
            canvasCircleElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;
                    ctx.beginPath();
                    ctx.arc(this.cx, this.cy, this.r, 0, Math.PI * 2, true);
                    ctx.closePath();
                    if (container.isHitTesting) {
                        container.hitTestPath(ctx, this);
                    }
                    if (this.fill != null && this.fill != "none" && this.fill != "") {
                        if (container.currentFill != this.fill) {
                            ctx.fillStyle = this.fill;
                            container.currentFill = this.fill;
                        }
                        ctx.fill();
                    }
                    if (this.stroke != null && this.stroke != "none" && this.stroke != "") {
                        if (container.currentStroke != this.stroke) {
                            ctx.strokeStyle = this.stroke;
                            container.currentStroke = this.stroke;
                        }
                        if (container.currentStrokeWidth != this["stroke-width"]) {
                            ctx.lineWidth = this["stroke-width"];
                            container.currentStrokeWidth = this["stroke-width"];
                        }
                        ctx.stroke();
                    }
                }
            };
            canvasCircleElement.prototype.getWidth = function () {
                return 2 * this.r;
            };
            canvasCircleElement.prototype.getHeight = function () {
                return 2 * this.r;
            };
            return canvasCircleElement;
        }(canvas.canvasElement));
        canvas.canvasCircleElement = canvasCircleElement;
    })(canvas = vp.canvas || (vp.canvas = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// canvasContainerElement.ts.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlotCore library - holds information associated with a CANVAS DOM element.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var canvas;
    (function (canvas_1) {
        //---- class: canvasContainerElement - a helper class for a canvas element that has ----
        //---- lightweight "canvas elements" (our "property bags" for shapes drawn in a canvas).
        var canvasContainerElement = (function (_super) {
            __extends(canvasContainerElement, _super);
            function canvasContainerElement(canvas, ctx, contextRequest) {
                _super.call(this, null);
                //---- keep this instance as property on canvas, so other instances can reuse us ----
                //---- and, as we walk the hierarchy, we know that this is a canvas on which we have ----
                //---- canvas lightweight elements.
                this.ctr = "vp.canvasContainerElement";
                this.frameCount = 0;
                this.lastTime = Date.now();
                this.bufferBuildTime = 0;
                this.frameRate = 0;
                this.frameRateChanged = null;
                this.opacity = 1;
                this.currentFill = "";
                this.currentStroke = "";
                this.currentStrokeWidth = 0;
                this.selectedFill = "orange";
                this.drawCallback = null;
                this.activeAnimations = []; // list of active animations
                this.drawNeeded = false; // this flagged is used to rebuild buffers (don't remove)
                //---- hit test management ----
                this.isHitTesting = false;
                this.hitTestX = 0;
                this.hitTestY = 0;
                this.hitTestResult = null;
                this.drawTimer = null;
                //animTimer = null;
                this.drawCount = 0;
                this.rootContainer = this;
                this.parentNode = canvas;
                canvas.canvasContainerElement = this;
                this.canvas = canvas; // our canvas ELEMENT
                this.ctx = ctx;
                this.children = [];
                this.contextRequest = contextRequest;
                this.initialized = false;
                vp.utils.debug("canvasContainer CTR");
                if (this.contextRequest == "3d") {
                    this.initialized = true;
                }
            }
            /// hit testing for canvas 2D/3D elements (rect, circle, text, line, etc).
            canvasContainerElement.prototype.getCanvasElementAtPoint = function (x, y) {
                var elemFound = null;
                //---- canvas 2d - use pointInPath() during drawing to find elem ----
                this.isHitTesting = true;
                this.hitTestX = x;
                this.hitTestY = y;
                this.hitTestResult = null;
                this.drawFrame();
                elemFound = this.hitTestResult;
                return elemFound;
            };
            canvasContainerElement.prototype.markDrawNeeded = function () {
                //vp.utils.debug("container.markDrawNeeded: drawTimer=" + this.drawTimer);
                var _this = this;
                if (!this.drawTimer) {
                    this.drawTimer = setTimeout(function () {
                        _this.drawFrame(false);
                    }, 10);
                }
            };
            /// remove the specified child element.
            canvasContainerElement.prototype.removeChild = function (element) {
                this.children.remove(element);
                this.markDrawNeeded();
            };
            /// remove all children.
            canvasContainerElement.prototype.clear = function () {
                this.children = [];
                this.markDrawNeeded();
            };
            canvasContainerElement.prototype.hitTestPath = function (ctx, elem) {
                if (ctx.isPointInPath(this.hitTestX, this.hitTestY)) {
                    this.hitTestResult = elem;
                    this.isHitTesting = false;
                }
            };
            canvasContainerElement.prototype.drawAll = function (ctx) {
                ctx.globalAlpha = 1;
                //this.drawSelf(ctx);
                this.currentFill = "none";
                this.currentStroke = "none";
                this.currentStrokeWidth = -999;
                this.selectedFill = "orange";
                //---- draw children ----
                for (var i = 0; i < this.children.length; i++) {
                    this.children[i].drawFrame(ctx, this);
                }
            };
            canvasContainerElement.prototype.drawFrame = function (rearmTimer) {
                this.drawCount++;
                //vp.utils.debug("canvasContainerElement: draw(): drawCount=" + this.drawCount);
                this.drawTimer = null;
                //---- frame stats ----
                this.frameCount++;
                var elapsed = Date.now() - this.lastTime;
                if (elapsed >= 1000) {
                    this.frameRate = Math.round(this.frameCount / (elapsed / 1000));
                    if (this.frameRateChanged != null) {
                        var count = this.children.length;
                        this.frameRateChanged(this.frameRate, count, this.bufferBuildTime);
                    }
                    this.frameCount = 0;
                    this.lastTime = Date.now();
                }
                //---- clear the canvas ----
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawAll(this.ctx);
                if (this.children.length == 0) {
                    vp.utils.debug("canvas clear, children=" + this.children.length);
                }
                if (this.drawCallback) {
                    this.drawCallback();
                }
            };
            canvasContainerElement.prototype.close = function () {
                if (this.drawTimer) {
                    clearTimeout(this.drawTimer);
                    this.drawTimer = null;
                }
                this.children = [];
            };
            return canvasContainerElement;
        }(canvas_1.canvasElement));
        canvas_1.canvasContainerElement = canvasContainerElement;
    })(canvas = vp.canvas || (vp.canvas = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// canvasEllipseElement.ts.  Copyright (c) 2016 Microsoft Corporation.
///     Part of the vuePlotCore library - represents a lightweight CANVAS ELLIPSE element.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var canvas;
    (function (canvas) {
        //---- class: canvasEllipseElement ----
        var canvasEllipseElement = (function (_super) {
            __extends(canvasEllipseElement, _super);
            function canvasEllipseElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasEllipseElement";
                this.tagName = "ellipse";
                this.opacity = 1;
                this.cx = 0;
                this.cy = 0;
                this.rx = 0;
                this.ry = 0;
                this["stroke-width"] = 1;
            }
            canvasEllipseElement.prototype.getOffset = function () {
                var x = this.cx - this.rx;
                var y = this.cy - this.ry;
                return { x: x, y: y };
            };
            /// return elem found at x,y.
            canvasEllipseElement.prototype.hitTest = function (x, y) {
                var elem = null;
                //---- for ellipse, this is easy.  use distance <= r for match ----
                var xdiff = this.cx - x;
                var ydiff = this.cy - y;
                var dist = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
                if (dist <= Math.max(this.rx, this.ry)) {
                    elem = this;
                }
                //vp.utils.debug("ellipse.hitTest: dist=" + dist);
                return elem;
            };
            canvasEllipseElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;
                    var left = this.cx - this.rx;
                    var right = this.cx + this.rx;
                    var top = this.cy - this.ry;
                    var bottom = this.cy + this.ry;
                    //---- canvas has no built-in ellipse support, so we just scale a circle ----
                    var xScale = 1;
                    var yScale = 1;
                    var radius = this.rx;
                    if (this.rx > this.ry) {
                        yScale = this.ry / this.rx;
                        radius = this.rx;
                    }
                    else {
                        xScale = this.rx / this.ry;
                        radius = this.ry;
                    }
                    ctx.beginPath();
                    ctx.save();
                    ctx.translate(this.cx, this.cy);
                    ctx.scale(xScale, yScale);
                    ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
                    ctx.restore();
                    ctx.closePath();
                    if (container.isHitTesting) {
                        container.hitTestPath(ctx, this);
                    }
                    if (this.fill != null && this.fill != "none") {
                        if (container.currentFill != this.fill) {
                            ctx.fillStyle = this.fill;
                            container.currentFill = this.fill;
                        }
                        ctx.fill();
                    }
                    if (this.stroke != null) {
                        if (container.currentStroke != this.stroke) {
                            ctx.strokeStyle = this.stroke;
                            container.currentStroke = this.stroke;
                        }
                        if (container.currentStrokeWidth != this["stroke-width"]) {
                            ctx.lineWidth = this["stroke-width"];
                            container.currentStrokeWidth = this["stroke-width"];
                        }
                        ctx.stroke();
                    }
                }
            };
            canvasEllipseElement.prototype.getWidth = function () {
                return 2 * this.rx;
            };
            canvasEllipseElement.prototype.getHeight = function () {
                return 2 * this.ry;
            };
            return canvasEllipseElement;
        }(canvas.canvasElement));
        canvas.canvasEllipseElement = canvasEllipseElement;
    })(canvas = vp.canvas || (vp.canvas = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// canvasGroupElement.ts.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlotCore library - a class for a lightweight canvas GROUP element  
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var canvas;
    (function (canvas) {
        //---- class: canvasGroupElement ----
        var canvasGroupElement = (function (_super) {
            __extends(canvasGroupElement, _super);
            function canvasGroupElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasGroupElement";
                this.tagName = "g";
                this.opacity = 1;
                this.children = [];
                this.x = 0;
                this.y = 0;
            }
            canvasGroupElement.prototype.getOffset = function () {
                return { x: this.x, y: this.y };
            };
            /// find 2d/3d element that intersects with x,y at z=0.  return that element.
            canvasGroupElement.prototype.hitTest = function (x, y) {
                var elem = null;
                //---- for now, we test each child.  may use color-based bitmap in future. ----
                for (var i = 0; i < this.children.length; i++) {
                    var child = this.children[i];
                    elem = child.hitTest(x, y);
                    if (elem) {
                        break;
                    }
                }
                return elem;
            };
            canvasGroupElement.prototype.appendChild = function (element) {
                this.children.push(element);
                this.markDrawNeeded();
            };
            /// remove the specified child element.
            canvasGroupElement.prototype.removeChild = function (element) {
                this.children.remove(element);
                this.markDrawNeeded();
            };
            /// remove all children.
            canvasGroupElement.prototype.clear = function () {
                this.children = [];
                this.markDrawNeeded();
            };
            canvasGroupElement.prototype.drawAll = function (ctx, container) {
                //---- todo: apply transfrom from each element (group & children) ----
                if (this.visibility != "hidden") {
                    //---- draw children ----
                    for (var i = 0; i < this.children.length; i++) {
                        var child = this.children[i];
                        child.drawFrame(ctx, container);
                    }
                }
            };
            return canvasGroupElement;
        }(canvas.canvasElement));
        canvas.canvasGroupElement = canvasGroupElement;
    })(canvas = vp.canvas || (vp.canvas = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// canvasImageElement.ts.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlotCore library - represents a lightweight CANVAS IMAGE element.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var canvas;
    (function (canvas) {
        //---- class: canvasImageElement ----
        var canvasImageElement = (function (_super) {
            __extends(canvasImageElement, _super);
            function canvasImageElement(parentElement) {
                var _this = this;
                _super.call(this, parentElement);
                this.ctr = "vp.canvasImageElement";
                this.tagName = "image";
                this.x = 0;
                this.y = 0;
                this.width = 100;
                this.height = 100;
                this.strokePlacement = "straddle"; // "inside", "straddle", "outside"
                this.image = new Image();
                this._href = null;
                this.opacity = 1;
                this["stroke-width"] = 0;
                this.image.onload = function (e) {
                    _this.markDrawNeeded();
                };
            }
            canvasImageElement.prototype.getOffset = function () {
                return { x: this.x, y: this.y };
            };
            canvasImageElement.prototype.getBBox = function () {
                var x = (vp.utils.isDefined(this.layoutX)) ? this.layoutX : this.x;
                var y = (vp.utils.isDefined(this.layoutY)) ? this.layoutY : this.y;
                //---- return bounds as a vuePlot rect ----
                var rc = {
                    left: x, top: y, width: this.width, height: this.height,
                    right: x + this.width, bottom: y + this.height
                };
                return rc;
            };
            canvasImageElement.prototype.hrefOverride = function (src) {
                if (arguments.length == 0) {
                    return this._href;
                }
                this._href = src;
                this.image.setAttribute("src", src);
            };
            /// return elem found at x,y.
            canvasImageElement.prototype.hitTest = function (x, y) {
                //---- for axis aligned rect, this is easy.  see if point is between left/right and top/bottom ----
                var elem = null;
                var myx = (vp.utils.isDefined(this.layoutX)) ? this.layoutX : this.x;
                var myy = (vp.utils.isDefined(this.layoutY)) ? this.layoutY : this.y;
                if ((x >= myx) && (x <= myx + this.width)) {
                    if ((y >= myy) && (y <= myy + this.height)) {
                        elem = this;
                    }
                }
                return elem;
            };
            canvasImageElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                    if (container.isHitTesting) {
                        ctx.save();
                        //---- create a rect path ----
                        ctx.beginPath();
                        ctx.rect(this.x, this.y, this.width, this.height);
                        container.hitTestPath(ctx, this);
                        ctx.restore();
                    }
                }
            };
            canvasImageElement.prototype.getWidth = function () {
                return this.width;
            };
            canvasImageElement.prototype.getHeight = function () {
                return this.height;
            };
            return canvasImageElement;
        }(canvas.canvasElement));
        canvas.canvasImageElement = canvasImageElement;
    })(canvas = vp.canvas || (vp.canvas = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// canvasLineElement.js.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlot library - represents a lightweight CANVAS LINE element.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var canvas;
    (function (canvas) {
        //---- class: canvasLineElement ----
        var canvasLineElement = (function (_super) {
            __extends(canvasLineElement, _super);
            function canvasLineElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasLineElement";
                this.tagName = "rect";
                this.opacity = 1;
                this.x1 = 0;
                this.x2 = 0;
                this.y1 = 0;
                this.y2 = 0;
                this["stroke-width"] = 1;
            }
            canvasLineElement.prototype.getOffset = function () {
                var left = Math.min(this.x1, this.x2);
                var top = Math.min(this.y1, this.y2);
                return { x: left, y: top };
            };
            /// return line at x,y, if any.
            canvasLineElement.prototype.hitTest = function (x, y) {
                //---- for NOW, just use axis aligned rect.  later, we will test the non-axis aligned rect that is the line ----
                var elem = null;
                var left = Math.min(this.x1, this.x2);
                var right = Math.max(this.x1, this.x2);
                var top = Math.min(this.y1, this.y2);
                var bottom = Math.max(this.y1, this.y2);
                if ((x >= left) && (x <= right)) {
                    if ((y >= top) && (y <= bottom)) {
                        elem = this;
                    }
                }
                return elem;
            };
            canvasLineElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;
                    if ((this.stroke != null) && (this["stroke-width"] > 0)) {
                        if (container.currentStroke != this.stroke) {
                            ctx.strokeStyle = this.stroke;
                            container.currentStroke = this.stroke;
                        }
                        if (container.currentStrokeWidth != this["stroke-width"]) {
                            ctx.lineWidth = this["stroke-width"];
                            container.currentStrokeWidth = this["stroke-width"];
                        }
                        ctx.beginPath();
                        ctx.moveTo(this.x1, this.y1);
                        ctx.lineTo(this.x2, this.y2);
                        ctx.stroke();
                        if (container.isHitTesting) {
                            container.hitTestPath(ctx, this);
                        }
                    }
                }
            };
            canvasLineElement.prototype.getWidth = function () {
                return Math.abs(this.x1 - this.x2);
            };
            canvasLineElement.prototype.getHeight = function () {
                return Math.abs(this.y1 - this.y2);
            };
            return canvasLineElement;
        }(canvas.canvasElement));
        canvas.canvasLineElement = canvasLineElement;
    })(canvas = vp.canvas || (vp.canvas = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// canvasPathElement.ts.  Copyright (c) 2016 Microsoft Corporation.
///     Part of the vuePlotCore library - represents a lightweight CANVAS PATH element.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var canvas;
    (function (canvas) {
        //---- class: canvasPathElement ----
        var canvasPathElement = (function (_super) {
            __extends(canvasPathElement, _super);
            function canvasPathElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasPathElement";
                this.tagName = "path";
                this.opacity = 1;
                this.boundingBox = { x: 0, y: 0, width: 0, height: 0, right: 0, bottom: 0 };
                this.createPathFunc = null; // function to run the path cmds
                this.pathDataStr = ""; // the "d" string, used to generate "createPathFunc"
                this["stroke-width"] = 1;
            }
            canvasPathElement.prototype.getOffset = function () {
                return { x: this.boundingBox.x, y: this.boundingBox.y };
            };
            canvasPathElement.prototype.getBBox = function () {
                return this.boundingBox;
            };
            canvasPathElement.prototype.createPathOnContext = function (ctx) {
                //---- "createPathFunc" is generated when the "d" property is assigned a value ----
                //---- calling "drawPath(ctx)" runs the path commands in the specified ctx context. ----
                if (this.createPathFunc) {
                    this.createPathFunc(ctx);
                }
            };
            /// return elem found at x,y.
            canvasPathElement.prototype.hitTest = function (x, y) {
                //---- for axis aligned rect, this is easy.  see if point is between left/right and top/bottom ----
                var bb = this.boundingBox;
                var elem = null;
                if ((x >= bb.x) && (x <= bb.right)) {
                    if ((y >= bb.y) && (y <= bb.bottom)) {
                        elem = this;
                    }
                }
                return elem;
            };
            canvasPathElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;
                    ctx.beginPath();
                    this.createPathOnContext(ctx); // run the dynamically generatedto draw the path
                    if (this.fill != null && this.fill != "none") {
                        if (container.currentFill != this.fill) {
                            ctx.fillStyle = this.fill;
                            container.currentFill = this.fill;
                        }
                        ctx.fill();
                    }
                    if ((this.stroke != null) && (this["stroke-width"] > 0)) {
                        if (container.currentStroke != this.stroke) {
                            ctx.strokeStyle = this.stroke;
                            container.currentStroke = this.stroke;
                        }
                        if (container.currentStrokeWidth != this["stroke-width"]) {
                            ctx.lineWidth = this["stroke-width"];
                            container.currentStrokeWidth = this["stroke-width"];
                        }
                        ctx.stroke();
                    }
                    if (container.isHitTesting) {
                        container.hitTestPath(ctx, this);
                    }
                }
            };
            //--- this is the "d" attribute (the path string) ----
            canvasPathElement.prototype.setPathData = function (value) {
                this.pathDataStr = value;
                this.parseDataStr();
            };
            /// Canvas path is NOT a string - it a series of cmds executed on the ctx object, 
            /// so we generate that a JavaScript function to do those commands here...
            canvasPathElement.prototype.parseDataStr = function () {
                var parser = new vp.internal.parsePathDataAndGenerateDrawFunc(this.pathDataStr);
                var both = parser.parse();
                var funcStr = both[0];
                var rc = both[1];
                this.boundingBox = this.clientRectToBoundingBox(rc);
                //---- generate code for our----
                eval("this.createPathFunc = " + funcStr);
            };
            canvasPathElement.prototype.getWidth = function () {
                return this.boundingBox.width;
            };
            canvasPathElement.prototype.getHeight = function () {
                return this.boundingBox.height;
            };
            return canvasPathElement;
        }(canvas.canvasElement));
        canvas.canvasPathElement = canvasPathElement;
    })(canvas = vp.canvas || (vp.canvas = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// canvasPolygonElement.js.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlot library - represents a lightweight CANVAS POLYGON element.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var canvas;
    (function (canvas) {
        //---- class: canvasPolygonElement ----
        var canvasPolygonElement = (function (_super) {
            __extends(canvasPolygonElement, _super);
            function canvasPolygonElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasPolygonElement";
                this.tagName = "rect";
                this.opacity = 1;
                this.boundingBox = { x: 0, y: 0, width: 0, height: 0, right: 0, bottom: 0 };
                this.pointStr = "";
                this.fill = "";
                this.stroke = "";
                this["stroke-width"] = 1;
            }
            canvasPolygonElement.prototype.getOffset = function () {
                return { x: this.boundingBox.x, y: this.boundingBox.y };
            };
            canvasPolygonElement.prototype.getBBox = function () {
                return this.boundingBox;
            };
            canvasPolygonElement.prototype.drawPath = function (ctx) {
                //---- this is generated when the "points" property is assigned a value ----
            };
            /// return elem found at x,y.
            canvasPolygonElement.prototype.hitTest = function (x, y) {
                //---- for axis aligned rect, this is easy.  see if point is between left/right and top/bottom ----
                var bb = this.boundingBox;
                var elem = null;
                if ((x >= bb.x) && (x <= bb.right)) {
                    if ((y >= bb.y) && (y <= bb.bottom)) {
                        elem = this;
                    }
                }
                return elem;
            };
            canvasPolygonElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;
                    ctx.beginPath();
                    this.drawPath(ctx); // run the dynamically generatedto draw the path
                    if (this.fill != null && this.fill != "none") {
                        if (container.currentFill != this.fill) {
                            ctx.fillStyle = this.fill;
                            container.currentFill = this.fill;
                        }
                        ctx.fill();
                    }
                    if ((this.stroke != null) && (this["stroke-width"] > 0)) {
                        if (container.currentStroke != this.stroke) {
                            ctx.strokeStyle = this.stroke;
                            container.currentStroke = this.stroke;
                        }
                        if (container.currentStrokeWidth != this["stroke-width"]) {
                            ctx.lineWidth = this["stroke-width"];
                            container.currentStrokeWidth = this["stroke-width"];
                        }
                        ctx.stroke();
                    }
                    if (container.isHitTesting) {
                        container.hitTestPath(ctx, this);
                    }
                }
            };
            canvasPolygonElement.prototype.setPathPoints = function (value) {
                this.points(value);
            };
            canvasPolygonElement.prototype.points = function (value) {
                if (arguments.length == 0) {
                    return this.pointStr;
                }
                this.pointStr = value;
                this.genDrawFromPoints();
                return this;
            };
            canvasPolygonElement.prototype.genDrawFromPoints = function () {
                var funcStr = "function (ctx)\r\n"
                    + "{\r\n";
                var minX = Number.MAX_VALUE;
                var minY = Number.MAX_VALUE;
                var maxX = -Number.MAX_VALUE; // Number.MIN_VALUE;
                var maxY = -Number.MAX_VALUE; // Number.MIN_VALUE;
                var firstPt = null;
                var points = this.pointStr.split(" ");
                for (var i = 0; i < points.length; i++) {
                    var ptx = points[i];
                    var xy = ptx.split(",");
                    var pt = { x: +xy[0], y: +xy[1] };
                    if (i == 0) {
                        funcStr += "    ctx.moveTo(" + pt.x + "," + pt.y + ");\r\n";
                    }
                    else {
                        funcStr += "    ctx.lineTo(" + pt.x + "," + pt.y + ");\r\n";
                    }
                    if (firstPt == null) {
                        firstPt = pt;
                    }
                    minX = Math.min(minX, pt.x);
                    minY = Math.min(minY, pt.y);
                    maxX = Math.max(maxX, pt.x);
                    maxY = Math.max(maxY, pt.y);
                }
                //---- generate line back to initial point ----
                if (firstPt) {
                    funcStr += "    ctx.lineTo(" + firstPt.x + "," + firstPt.y + ");\r\n";
                }
                funcStr += "}\r\n";
                var rc = vp.geom.rect(minX, minY, maxX - minX, maxY - minY);
                this.boundingBox = this.clientRectToBoundingBox(rc);
                //---- generate code for our----
                eval("this.drawPath = " + funcStr);
            };
            canvasPolygonElement.prototype.getWidth = function () {
                return this.boundingBox.width;
            };
            canvasPolygonElement.prototype.getHeight = function () {
                return this.boundingBox.height;
            };
            return canvasPolygonElement;
        }(canvas.canvasElement));
        canvas.canvasPolygonElement = canvasPolygonElement;
    })(canvas = vp.canvas || (vp.canvas = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// canvasRectElement.ts.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlotCore library - represents a lightweight CANVAS RECT element.
///-----------------------------------------------------------------------------------------------------------------
//---- class: canvasRectElement ----
var vp;
(function (vp) {
    var canvas;
    (function (canvas) {
        var canvasRectElement = (function (_super) {
            __extends(canvasRectElement, _super);
            function canvasRectElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasRectElement";
                this.tagName = "rect";
                this.x = 0;
                this.y = 0;
                this.width = 100;
                this.height = 100;
                this.strokePlacement = "straddle"; // "inside", "straddle", "outside"
                this.fill = "";
                this.stroke = "";
            }
            canvasRectElement.prototype.getOffset = function () {
                return { x: this.x, y: this.y };
            };
            canvasRectElement.prototype.getBBox = function () {
                var x = (vp.utils.isDefined(this.layoutX)) ? this.layoutX : this.x;
                var y = (vp.utils.isDefined(this.layoutY)) ? this.layoutY : this.y;
                //---- return bounds as a vuePlot rect ----
                var rc = {
                    left: x, top: y, width: this.width, height: this.height,
                    right: x + this.width, bottom: y + this.height
                };
                return rc;
            };
            /// return elem found at x,y.
            canvasRectElement.prototype.hitTest = function (x, y) {
                //---- for axis aligned rect, this is easy.  see if point is between left/right and top/bottom ----
                var elem = null;
                var myx = (vp.utils.isDefined(this.layoutX)) ? this.layoutX : this.x;
                var myy = (vp.utils.isDefined(this.layoutY)) ? this.layoutY : this.y;
                if ((x >= myx) && (x <= myx + this.width)) {
                    if ((y >= myy) && (y <= myy + this.height)) {
                        elem = this;
                    }
                }
                return elem;
            };
            canvasRectElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;
                    if (this.fill != null && this.fill != "none") {
                        if (container.currentFill != this.fill) {
                            ctx.fillStyle = this.fill;
                            container.currentFill = this.fill;
                        }
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                    }
                    if ((this.stroke != null) && (this["stroke-width"] > 0)) {
                        if (container.currentStroke != this.stroke) {
                            ctx.strokeStyle = this.stroke;
                            container.currentStroke = this.stroke;
                        }
                        var sw = this["stroke-width"];
                        if (container.currentStrokeWidth != sw) {
                            ctx.lineWidth = sw;
                            container.currentStrokeWidth = sw;
                        }
                        if (this.strokePlacement == "inside") {
                            var sw_div2 = this["stroke-width"] / 2;
                            ctx.strokeRect(this.x + sw_div2, this.y + sw_div2, this.width - sw, this.height - sw);
                        }
                        else if (this.strokePlacement == "outside") {
                            var sw_div2 = this["stroke-width"] / 2;
                            ctx.strokeRect(this.x - sw_div2, this.y - sw_div2, this.width + sw, this.height + sw);
                        }
                        else {
                            ctx.strokeRect(this.x, this.y, this.width, this.height);
                        }
                    }
                    if (container.isHitTesting) {
                        ctx.save();
                        //---- create a rect path ----
                        ctx.beginPath();
                        ctx.rect(this.x, this.y, this.width, this.height);
                        container.hitTestPath(ctx, this);
                        ctx.restore();
                    }
                }
            };
            canvasRectElement.prototype.getWidth = function () {
                return this.width;
            };
            canvasRectElement.prototype.getHeight = function () {
                return this.height;
            };
            return canvasRectElement;
        }(canvas.canvasElement));
        canvas.canvasRectElement = canvasRectElement;
    })(canvas = vp.canvas || (vp.canvas = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// canvasTextElement.ts.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlotCore library - represents a lightweight CANVAS TEXT element.
///-----------------------------------------------------------------------------------------------------------------
//---- class: canvasRectElement ----
var vp;
(function (vp) {
    var canvas;
    (function (canvas) {
        //---- class: canvasTextElement ----
        var canvasTextElement = (function (_super) {
            __extends(canvasTextElement, _super);
            function canvasTextElement(parentElement) {
                _super.call(this, parentElement);
                this.ctr = "vp.canvasTextElement";
                this.tagName = "text";
                this.textContent = "";
                this.opacity = 1;
                this.x = 0;
                this.y = 0;
                this.fill = "";
                this.stroke = "";
                this.width = 0;
                this.height = 0;
                this.verticalAlign = "top"; // all measurements rely on this (?)
            }
            canvasTextElement.prototype.applyStyle = function (style) {
                if (style.opacity !== undefined) {
                    this.opacity = style.opacity;
                }
                if (style.fill !== undefined) {
                    this.fill = style.fill;
                }
                if (style.stroke !== undefined) {
                    this.stroke = style.stroke;
                }
                if (style.strokeWidth !== undefined) {
                    this["stroke-width"] = style.strokeWidth;
                }
                if (style.fontSize !== undefined) {
                    this["font-size"] = style.fontSize;
                }
                if (style.fontWeight !== undefined) {
                    this.fontWeight = style.fontWeight;
                }
                if (style.fontStyle !== undefined) {
                    this.fontStyle = style.fontStyle;
                }
                if (style.fontFamily !== undefined) {
                    this["font-family"] = style.fontFamily;
                }
                if (style.textAnchor !== undefined) {
                    this["text-anchor"] = style.textAnchor;
                }
            };
            /// return elem found at x,y.
            canvasTextElement.prototype.hitTest = function (x, y) {
                //---- for text; just treat as rect.  see if point is between left/right and top/bottom ----
                var elem = null;
                if ((x >= this.x) && (x <= this.x + this.width)) {
                    if ((y >= this.y) && (y <= this.y + this.height)) {
                        elem = this;
                    }
                }
                return elem;
            };
            canvasTextElement.prototype.getOffset = function () {
                var left = this.x;
                var top = this.y;
                //---- elem.y specifies the bottom for text elements, so substract the height to get the top ----
                top -= this.getHeight();
                return { x: left, y: top };
            };
            canvasTextElement.prototype.setContextForDrawing = function (ctx) {
                var font = "";
                //---- STYLE ----
                if (this.fontStyle != undefined) {
                    font += this.fontStyle + " ";
                }
                //---- WEIGHT ----
                if (this.fontWeight != undefined) {
                    font += this.fontWeight + " ";
                }
                //---- SIZE ----
                if (this["font-size"] != undefined) {
                    var fs = this["font-size"];
                    if (vp.utils.isNumber(fs)) {
                        //---- SVG uses the "current user coordinate system" for this; we will assume it is pixels ----
                        font += fs + "px ";
                    }
                    else {
                        font += fs + " ";
                    }
                }
                if (this["font-family"]) {
                    font += this["font-family"] + " ";
                }
                else {
                    font += "tahoma ";
                }
                ctx.font = font;
                if (this.fill != null && this.fill != "none") {
                    ctx.fillStyle = this.fill;
                }
                else {
                    ctx.fillStyle = "transparent";
                }
                if (this.stroke != null && this.stroke != "none") {
                    ctx.strokeStyle = this.stroke;
                    ctx.lineWidth = this["stroke-width"];
                }
                else {
                    ctx.strokeStyle = "transparent";
                    ctx.lineWidth = 0;
                }
                var textAlign = this["text-anchor"]; // start, middle, or end
                if (textAlign) {
                    if (textAlign == "middle") {
                        textAlign = "center";
                    }
                    ctx.textAlign = textAlign;
                }
                if (this.verticalAlign) {
                    ctx.textBaseline = this.verticalAlign;
                }
            };
            canvasTextElement.prototype.drawAll = function (ctx, container) {
                if (this.visibility != "hidden") {
                    ctx.globalAlpha = this.opacity;
                    this.setContextForDrawing(ctx);
                    //---- apply alignment ----
                    var x = +this.x;
                    var y = +this.y;
                    if (this.transform && this.transform.angle) {
                        //var height = this.getHeight();
                        //var width = this.getWidth();
                        //---- must offset x, y from the rotation position ----
                        x -= this.transform.cx;
                        y -= this.transform.cy;
                    }
                    if (this.fill && this.fill != "none") {
                        ctx.fillText(this.textContent, x, y);
                    }
                    if (this.stroke && this.stroke != "none") {
                        ctx.strokeText(this.textContent, x, y);
                    }
                    if (container.isHitTesting) {
                        ctx.save();
                        //---- create a rect path to represent the text block (any other way to do this?) ----
                        ctx.beginPath();
                        var width = +ctx.measureText(this.textContent).width;
                        var height = this.getHeight();
                        ctx.rect(this.x, this.y, width, height);
                        container.hitTestPath(ctx, this);
                        ctx.restore();
                    }
                }
            };
            canvasTextElement.prototype.getBBox = function () {
                var x = (vp.utils.isDefined(this.layoutX)) ? this.layoutX : this.x;
                var y = (vp.utils.isDefined(this.layoutY)) ? this.layoutY : this.y;
                var w = this.getWidth();
                var h = this.getHeight();
                //---- return bounds as rect but using "x" and "y" instead of "left" and "top" ----
                var rc = {
                    x: x, y: y, width: w, height: h,
                    right: x + w, bottom: y + h
                };
                return rc;
            };
            canvasTextElement.prototype.getWidth = function () {
                var width = 0;
                var ctx = this.rootContainer.ctx;
                this.setContextForDrawing(ctx);
                width = ctx.measureText(this.textContent).width;
                return width;
            };
            canvasTextElement.prototype.getHeight = function () {
                var height = 0;
                //---- note: ctx.measureText() doesn't support height; parse it from ctx.font ----
                //---- since the font size is the height of characters rendered by that font ----
                var ctx = this.rootContainer.ctx;
                this.setContextForDrawing(ctx);
                var fontStr = ctx.font;
                height = parseFloat(fontStr); // starts with "10px" ...
                if (fontStr.contains("pt ")) {
                    height = height * 98 / 72;
                }
                return height;
            };
            return canvasTextElement;
        }(canvas.canvasElement));
        canvas.canvasTextElement = canvasTextElement;
    })(canvas = vp.canvas || (vp.canvas = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// aggAvg.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library: avg() aggregate class for groupBy/aggregation.
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    var data;
    (function (data) {
        var aggAvg = (function () {
            function aggAvg() {
            }
            aggAvg.prototype.init = function () {
                this._total = 0;
                this._count = 0;
            };
            aggAvg.prototype.process = function (value) {
                this._total += +value;
                this._count++;
            };
            aggAvg.prototype.getResult = function () {
                var result = 0;
                if (this._count > 0) {
                    result = this._total / this._count;
                }
                return result;
            };
            return aggAvg;
        }());
        data.aggAvg = aggAvg;
    })(data = vp.data || (vp.data = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// aggCount.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library: count() aggregate class for groupBy/aggregation.
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    var data;
    (function (data) {
        var aggCount = (function () {
            function aggCount() {
            }
            aggCount.prototype.init = function () {
                this._count = 0;
            };
            aggCount.prototype.process = function (value) {
                this._count++;
            };
            aggCount.prototype.getResult = function () {
                return this._count;
            };
            return aggCount;
        }());
        data.aggCount = aggCount;
    })(data = vp.data || (vp.data = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// aggMax.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library: max() aggregate class for groupBy/aggregation.
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    var data;
    (function (data) {
        var aggMax = (function () {
            function aggMax() {
            }
            aggMax.prototype.init = function () {
                this._maxValue = undefined;
            };
            aggMax.prototype.process = function (value) {
                value = +value;
                if (this._maxValue === undefined || value > this._maxValue) {
                    this._maxValue = value;
                }
            };
            aggMax.prototype.getResult = function () {
                return this._maxValue;
            };
            return aggMax;
        }());
        data.aggMax = aggMax;
    })(data = vp.data || (vp.data = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// aggMedian.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library: median() aggregate class for groupBy/aggregation.
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    var data;
    (function (data) {
        var aggMedian = (function () {
            function aggMedian() {
            }
            aggMedian.prototype.init = function () {
                this._values = [];
            };
            aggMedian.prototype.process = function (value) {
                this._values.push(+value);
            };
            aggMedian.prototype.getResult = function () {
                var sorted = this._values.orderByNum();
                var count = sorted.length;
                var result = 0;
                if (count > 0) {
                    if (count % 2 == 0) {
                        //---- even - take avg of 2 middle values ----
                        var index = count / 2;
                        result = (sorted[index - 1] + sorted[index]) / 2;
                    }
                    else {
                        //---- odd - take middle value ----
                        var index = Math.floor(count / 2);
                        result = sorted[index];
                    }
                }
                return result;
            };
            return aggMedian;
        }());
        data.aggMedian = aggMedian;
    })(data = vp.data || (vp.data = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// aggMin.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library: min() aggregate class for groupBy/aggregation.
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    var data;
    (function (data) {
        var aggMin = (function () {
            function aggMin() {
            }
            aggMin.prototype.init = function () {
                this._minValue = undefined;
            };
            aggMin.prototype.process = function (value) {
                value = +value;
                if (this._minValue === undefined || value < this._minValue) {
                    this._minValue = value;
                }
            };
            aggMin.prototype.getResult = function () {
                return this._minValue;
            };
            return aggMin;
        }());
        data.aggMin = aggMin;
    })(data = vp.data || (vp.data = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// aggMode.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library: mode() aggregate class for groupBy/aggregation.
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    var data;
    (function (data) {
        var aggMode = (function () {
            function aggMode() {
            }
            aggMode.prototype.init = function () {
                this._counts = {};
            };
            aggMode.prototype.process = function (value) {
                value = +value;
                var entry = this._counts[value];
                if (entry === undefined) {
                    this._counts[value] = 1;
                }
                else {
                    this._counts[value] = 1 + entry;
                }
            };
            aggMode.prototype.getResult = function () {
                var max = undefined;
                var mode = undefined;
                var keys = vp.utils.keys(this._counts);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var count = this._counts[key];
                    if (max === undefined || count > max) {
                        max = count;
                        mode = key;
                    }
                }
                //---- mode is undefined if no number is repeated ----
                return (max > 1) ? mode : undefined;
            };
            return aggMode;
        }());
        data.aggMode = aggMode;
    })(data = vp.data || (vp.data = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// aggStdDev.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library: stdDev() aggregate class for groupBy/aggregation.
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    var data;
    (function (data) {
        var aggStdDev = (function () {
            function aggStdDev() {
            }
            aggStdDev.prototype.init = function () {
                this._total = 0;
                this._count = 0;
                this._numbers = [];
            };
            aggStdDev.prototype.process = function (value) {
                value = +value;
                this._total += value;
                this._count++;
                this._numbers.push(value);
            };
            aggStdDev.prototype.getResult = function () {
                var result = 0;
                var count = this._count;
                if (count > 0) {
                    var mean = this._total / count;
                    var sum = 0;
                    for (var i = 0; i < count; i++) {
                        var diff = this._numbers[i] - mean;
                        sum += diff * diff;
                    }
                    //---- variance of SAMPLE (vs. population) ----
                    var variance = sum / (count - 1);
                    result = Math.sqrt(variance);
                }
                return result;
            };
            return aggStdDev;
        }());
        data.aggStdDev = aggStdDev;
    })(data = vp.data || (vp.data = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// aggSum.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library: sum() aggregate class for groupBy/aggregation.
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    var data;
    (function (data) {
        var aggSum = (function () {
            function aggSum() {
            }
            aggSum.prototype.init = function () {
                this._sum = 0;
            };
            aggSum.prototype.process = function (value) {
                this._sum += +value;
            };
            aggSum.prototype.getResult = function () {
                return this._sum;
            };
            return aggSum;
        }());
        data.aggSum = aggSum;
    })(data = vp.data || (vp.data = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// aggVariance.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library: variance() aggregate class for groupBy/aggregation.
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    var data;
    (function (data) {
        var aggVariance = (function () {
            function aggVariance() {
            }
            aggVariance.prototype.init = function () {
                this._total = 0;
                this._count = 0;
                this._numbers = [];
            };
            aggVariance.prototype.process = function (value) {
                value = +value;
                this._total += value;
                this._count++;
                this._numbers.push(value);
            };
            aggVariance.prototype.getResult = function () {
                var result = 0;
                var count = this._count;
                if (count > 0) {
                    var mean = this._total / count;
                    var sum = 0;
                    for (var i = 0; i < count; i++) {
                        var diff = this._numbers[i] - mean;
                        sum += diff * diff;
                    }
                    //---- variance of SAMPLE (vs. population) ----
                    result = sum / (count - 1);
                }
                return result;
            };
            return aggVariance;
        }());
        data.aggVariance = aggVariance;
    })(data = vp.data || (vp.data = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// dataUtils.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library - data binding and related functions.
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    var data;
    (function (data_1) {
        function getTypeName(obj) {
            var typeName = typeof obj;
            if ((typeName != "number") && (typeName != "boolean") && (typeName != "string")) {
                var objStr = Object.prototype.toString.call(obj);
                if (objStr.endsWith(" Date]")) {
                    typeName = "date";
                }
                else if (objStr.endsWith("Array]")) {
                    typeName = "array";
                }
            }
            return typeName;
        }
        data_1.getTypeName = getTypeName;
        /** scans all of the entries in data and returns one of: "number", "date", "string". */
        function getDataType(data) {
            var count = data.length;
            var numberCount = 0;
            var dateCount = 0;
            var stringCount = 0;
            var noValueCount = 0;
            var hardTypeName = null;
            for (var i = 0; i < data.length; i++) {
                var value = data[i];
                if (value === null || value === undefined || value === "") {
                    noValueCount++;
                }
                else {
                    var typeName = typeof value;
                    if (typeName == "number") {
                        hardTypeName = "number";
                        break;
                    }
                    else if (typeName == "object") {
                        var strName = Object.prototype.toString.call(value);
                        if (strName.endsWith(" Date]")) {
                            hardTypeName = "date";
                            break;
                        }
                    }
                    else if (typeName == "string") {
                        if (!isNaN(+value)) {
                            numberCount++;
                        }
                        else if (!isNaN(Date.parse(value))) {
                            dateCount++;
                        }
                        else if (value.length == 19 && !isNaN(Date.parse(value.replace(" ", "T")))) {
                            //---- change raw data to be a valid date string ----
                            data[i] = value.replace(" ", "T");
                            dateCount++;
                        }
                        else {
                            stringCount++;
                        }
                    }
                }
            }
            if (hardTypeName) {
                var typeName = hardTypeName;
            }
            else {
                var typeName = "string";
                if (stringCount == 0) {
                    if (dateCount > 0 && numberCount == 0) {
                        typeName = "date";
                    }
                    else if (numberCount > 0) {
                        typeName = "number";
                    }
                }
            }
            return typeName;
        }
        data_1.getDataType = getDataType;
        function calcNumDecimals(max, min, tickCount) {
            var numDecimals = 0;
            var range = max - min;
            if (range > 0) {
                var singleTickInterval = range / tickCount;
                var log10Val = Math.log(singleTickInterval) * Math.LOG10E;
                if (log10Val < 0) {
                    numDecimals = Math.ceil(-log10Val);
                }
            }
            return numDecimals;
        }
        data_1.calcNumDecimals = calcNumDecimals;
        function clamp(value, min, max) {
            if (value < min) {
                value = min;
            }
            else if (value > max) {
                value = max;
            }
            return value;
        }
        data_1.clamp = clamp;
        function mapValue(value, fromMin, fromMax, toMin, toMax) {
            var range = fromMax - fromMin;
            var percent = (range) ? (value - fromMin) / range : 1;
            var newValue = toMin + percent * (toMax - toMin);
            return newValue;
        }
        data_1.mapValue = mapValue;
        ///
        /// timing: range(1000*1000) takes 842ms on roland's home machine (3/23/2012).
        ///
        function range(from, to, incr) {
            //var startTime = new Date().getTime();
            var values = [];
            var minIcrement = 1.0e-10; // must be big enough to change a floating point value
            if (vp.utils.isUndefined(incr)) {
                incr = 1;
            }
            if (vp.utils.isUndefined(to)) {
                to = from;
                from = 1;
            }
            //---- guard against infinite loops ----
            if (incr == 0) {
            }
            else if ((from < to) && (incr < minIcrement)) {
            }
            else if ((from > to) && (incr > -minIcrement)) {
            }
            else if ((vp.utils.floatGeq(from, to)) && (incr < 0)) {
                //---- emit normal range ----
                for (var value = from; vp.utils.floatGeq(value, to); value += incr) {
                    values.push(value);
                }
            }
            else if ((vp.utils.floatLeq(from, to)) && (incr > 0)) {
                //---- emit normal range ----
                for (var value = from; vp.utils.floatLeq(value, to); value += incr) {
                    values.push(value);
                }
            }
            //---- ensure last value="to" (floating point error) ----
            if (values.length > 0) {
                var epsilon = .00001;
                var last = values.length - 1;
                var diff = Math.abs(values[last] - to);
                if (diff != 0 && diff < epsilon) {
                    values[last] = to;
                }
            }
            //var elapsedMs = new Date().getTime() - startTime;
            return values;
        }
        data_1.range = range;
        //---- creates a hash object to hold a data item and its data index ----
        function dataPairHolder(dataItem, dataIndex) {
            var pair = { dataItem: dataItem, dataIndex: dataIndex };
            return pair;
        }
        data_1.dataPairHolder = dataPairHolder;
        function dataRepeat(value, count) {
            var values = [];
            for (var i = 0; i < count; i++) {
                values[i] = value;
            }
            return values;
        }
        data_1.dataRepeat = dataRepeat;
        function lerp(percent, a, b) {
            return a + percent * (b - a);
        }
        data_1.lerp = lerp;
        function makeLastData(data) {
            var lastRecord = (data.length) ? data[0] : null;
            var lastData = [];
            var lastIndex = 0;
            for (var i = 0; i < data.length; i++) {
                var origRecord = data[i];
                var record = { current: origRecord, index: i, last: lastRecord, lastIndex: lastIndex };
                lastData.push(record);
                lastRecord = origRecord;
                lastIndex = i;
            }
            return lastData;
        }
        data_1.makeLastData = makeLastData;
        function generateItems(root, tagName, data) {
            var elemArray = [];
            var start = Date.now();
            if (root.multiAppend) {
                elemArray = root.multiAppend(tagName, data.length);
                for (var i = 0; i < elemArray.length; i++) {
                    var elem = elemArray[i];
                    var dataItem = data[i];
                    vp.dom.dataItem(elem, dataItem);
                    vp.dom.dataIndex(elem, i);
                }
            }
            else {
                for (var i = 0; i < data.length; i++) {
                    //---- this does the right thing for canvas, SVG, and HTML elements ----
                    var elem = root.append(tagName);
                    var dataItem = data[i];
                    elem.dataItem(dataItem);
                    elem.dataIndex(i);
                    elemArray.push(elem[0]);
                }
            }
            var elapsed = Date.now() - start;
            //alert("append of " + data.length + " elements took: " + elapsed + "ms");
            var ss = vp.dom.wrapElements(elemArray);
            return ss;
        }
        data_1.generateItems = generateItems;
        /// public: dataJoin(data, "name", data2, "name2", ...)
        /// this joins the data in each array into a new array, with each field given the associated name.
        function dataJoin(data, name1) {
            var records = [];
            for (var i = 0; i < data.length; i++) {
                //---- loop thru all the fields and create a record ----
                var record = {};
                for (var a = 0; a < arguments.length; a += 2) {
                    var dataX = arguments[a];
                    var nameX = arguments[a + 1];
                    var valueX = dataX[i];
                    record[nameX] = valueX;
                }
                records.push(record);
            }
            return records;
        }
        data_1.dataJoin = dataJoin;
        /// public: $.dataFrame(desc)
        /// this builds an array of records whose name/vector pairs are given as key/values of the desc object.
        function dataFrame(desc) {
            var records = [];
            var firstVector = null;
            for (var k in desc) {
                firstVector = desc[k];
                break;
            }
            if (firstVector) {
                for (var i = 0; i < firstVector.length; i++) {
                    //---- loop thru all the fields and create a record ----
                    var record = {};
                    for (var name in desc) {
                        record[name] = desc[name][i];
                    }
                    records.push(record);
                }
            }
            return records;
        }
        data_1.dataFrame = dataFrame;
        /// public: dataSelect(data, fieldName)
        /// "data" is an array of records.
        /// "fieldName" is the name of one of the record's fields.
        /// returns an array of "fieldName" values (one entry from each record in data).
        function dataSelect(data, field) {
            var values = []; // empty array, by default
            if (!field) {
                //---- if no field specified, just return the data as is ----
                values = data;
            }
            else if (data.length > 0) {
                var firstRecord = data[0];
                if (firstRecord[field] !== undefined) {
                    values = data.map(function (data, index) { return data[field]; });
                }
            }
            return values;
        }
        data_1.dataSelect = dataSelect;
        function doesNestedRecordContainColumn(record, colName) {
            while (vp.utils.isArray(record)) {
                record = record[0];
            }
            var hasCol = record[colName] !== undefined;
            return hasCol;
        }
        data_1.doesNestedRecordContainColumn = doesNestedRecordContainColumn;
        /** extracts the vector of values from the array of records, which includes a field named colName.  If each
        record is in turn an array, returns the count of the array, if countIfArray=true. */
        function getVector(data, colName, countIfArray) {
            var values = null;
            if (data.length) {
                var firstRecord = data[0];
                if (vp.utils.isArray(firstRecord)) {
                    //---- special case - count array entries in each record ----
                    if (doesNestedRecordContainColumn(firstRecord, colName)) {
                        values = data.map(function (d, index) { return d.length; });
                    }
                }
                else if (firstRecord[colName] !== undefined) {
                    //---- normal case ----
                    values = data.map(function (d, index) { return d[colName]; });
                }
            }
            return values;
        }
        data_1.getVector = getVector;
        /**  builds a matrix of records in X and Y, dim size x size, with a "value" field that has some peaks and valleys. */
        function peaks(size, flatten) {
            var baseNum = 3;
            var incr = (2 * baseNum) / size;
            var rows = [];
            for (var y = -baseNum; y <= baseNum; y += incr) {
                var row = (flatten) ? rows : [];
                for (var x = -baseNum; x <= baseNum; x += incr) {
                    //z =  3*(1-x)^2*exp(-(x^2) - (y+1)^2) ... 
                    //   - 10*(x/5 - x^3 - y^5)*exp(-x^2-y^2) ... 
                    //   - 1/3*exp(-(x+1)^2 - y^2) 
                    var z1 = 3 * (1 - x) * (1 - x) * Math.exp(-(x * x) - (y + 1) * (y + 1));
                    var z2 = -10 * (x / 5 - x * x * x - Math.pow(y, 5)) * Math.exp(-(x * x) - (y * y));
                    var z3 = -1 / 3 * Math.exp(-(x + 1) * (x + 1) - (y * y));
                    var z = z1 + z2 + z3;
                    //var value = 5*Math.sin(x) + 4*Math.cos(y);
                    var record = { x: x, y: y, z: z };
                    row.push(record);
                }
                if (row != rows) {
                    rows.push(row);
                }
            }
            return rows;
        }
        data_1.peaks = peaks;
        function isAllIntegers(data) {
            var allInts = true;
            for (var i = 0; i < data.length; i++) {
                var value = data[i];
                if (!vp.utils.isInteger(value)) {
                    allInts = false;
                    break;
                }
            }
            return allInts;
        }
        data_1.isAllIntegers = isAllIntegers;
        function createAggregator(name) {
            var agg = undefined;
            if (name == "count") {
                agg = new data_1.aggCount();
            }
            else if (name == "sum") {
                agg = new data_1.aggSum();
            }
            else if (name == "min") {
                agg = new data_1.aggMin();
            }
            else if (name == "max") {
                agg = new data_1.aggMax();
            }
            else if (name == "avg" || name == "mean" || name == "average") {
                agg = new data_1.aggAvg();
            }
            else if (name == "median") {
                agg = new data_1.aggMedian();
            }
            else if (name == "mode") {
                agg = new data_1.aggMode();
            }
            else if (name == "stdDev" || name == "std") {
                agg = new data_1.aggStdDev();
            }
            else if (name == "variance" || name == "var") {
                agg = new data_1.aggVariance();
            }
            else if (name == "none") {
                agg = new data_1.aggNone();
            }
            return agg;
        }
        data_1.createAggregator = createAggregator;
        /** Groups the data by the specified group column and then takes the specified aggregate of the specified value column within each group.  Returns array of records
        with 2 columns: aggregate value, group key.  if groupRecord is omitted, data is assumed to be pre-grouped. */
        function aggByGroup(data, aggInfo, groupRecord) {
            var newRecords = [];
            var groupColumn = (groupRecord) ? groupRecord.column : null;
            var newGroupName = (groupRecord) ? groupRecord.name : "";
            var aggregator = createAggregator(aggInfo.aggName);
            //---- if groupColumn not specified, data is pre-grouped ----
            var groupedData = (groupColumn) ? data.groupBy(groupColumn) : data;
            //---- process each group ----
            for (var g = 0; g < groupedData.length; g++) {
                var group = groupedData[g];
                var values = group.values;
                aggregator.init();
                //---- process each value in group ----
                for (var v = 0; v < values.length; v++) {
                    var record = values[v];
                    var value = (aggInfo.column == "*") ? 1 : record[aggInfo.column];
                    value = parseFloat(value);
                    if (isFinite(value)) {
                        //total += value;
                        aggregator.process(value);
                    }
                }
                //---- get result for group ----
                var aggResult = aggregator.getResult();
                var newRecord = {};
                newRecord[newGroupName] = group.key;
                newRecord[aggInfo.name] = aggResult;
                newRecords.push(newRecord);
            }
            return newRecords;
        }
        data_1.aggByGroup = aggByGroup;
        /** Groups the data by the specified group column and then calculates the specified aggregates within each group.  Returns array of records
        with 2 columns for each specified aggregate: aggregate value, group key */
        function multiAggByGroup(data, aggArray, groupRecord) {
            var newRecords = [];
            var groupColumn = groupRecord.column;
            var newGroupName = groupRecord.name;
            var aggregators = [];
            for (var i = 0; i < aggArray.length; i++) {
                var aggInfo = aggArray[i];
                var aggregator = createAggregator(aggInfo.aggName);
                aggregator.init();
                aggregators.push(aggregator);
            }
            var groupedData = data.groupBy(groupRecord.column);
            //---- process each group ----
            for (var g = 0; g < groupedData.length; g++) {
                var group = groupedData[g];
                var values = group.values;
                for (var i = 0; i < aggArray.length; i++) {
                    aggregator = aggregators[i];
                    aggregator.init();
                }
                //---- process each value in group ----
                for (var v = 0; v < values.length; v++) {
                    var record = values[v];
                    var value = (aggInfo.column == "*") ? 1 : record[aggInfo.column];
                    value = parseFloat(value);
                    if (isFinite(value)) {
                        for (var i = 0; i < aggArray.length; i++) {
                            aggregator = aggregators[i];
                            aggregator.process(value);
                        }
                    }
                }
                //---- get result for group ----
                var newRecord = {};
                newRecord[newGroupName] = group.key;
                for (var i = 0; i < aggArray.length; i++) {
                    aggregator = aggregators[i];
                    var aggInfo = aggArray[i];
                    var aggResult = aggregator.getResult();
                    newRecord[aggInfo.name] = aggResult;
                }
                newRecords.push(newRecord);
            }
            return newRecords;
        }
        data_1.multiAggByGroup = multiAggByGroup;
        /** returns the date part of the DateTime value. */
        function datePart(date) {
            var newDate = new Date(date.valueOf());
            newDate.setHours(0, 0, 0, 0);
            return newDate;
        }
        data_1.datePart = datePart;
        var nameColumnPair = (function () {
            function nameColumnPair(name, column) {
                this.name = name;
                this.column = column;
            }
            return nameColumnPair;
        }());
        data_1.nameColumnPair = nameColumnPair;
        var nameColumnAgg = (function () {
            function nameColumnAgg(name, column, aggName) {
                this.name = name;
                this.column = column;
                this.aggName = aggName;
            }
            return nameColumnAgg;
        }());
        data_1.nameColumnAgg = nameColumnAgg;
        function normalize(data, toMin, toMax) {
            if (toMin === void 0) { toMin = -1; }
            if (toMax === void 0) { toMax = 1; }
            var min = data.min();
            var max = data.max();
            var newData = data.map(function (num, index) {
                var newNum = vp.data.mapValue(num, min, max, toMin, toMax);
                return newNum;
            });
            return newData;
        }
        data_1.normalize = normalize;
    })(data = vp.data || (vp.data = {}));
})(vp || (vp = {}));
var vp;
(function (vp) {
    var unitTests;
    (function (unitTests) {
        function testDataUtils() {
            vp.utils.debug("running: testDataUtils");
            var data = [
                { sales: 1, year: 1990 },
                { sales: 5, year: 1990 },
                { sales: 3, year: 1990 },
                { sales: 8, year: 1990 },
                { sales: 2, year: 2001 },
                { sales: 7, year: 2001 },
                { sales: 10, year: 2009 },
            ];
            //---- avg by direct column group ----
            var newData = vp.data.aggByGroup(data, { name: "avgSales", column: "sales", aggName: "avg" }, { name: "year", column: "year" });
            var averages = vp.data.dataSelect(newData, "avgSales");
            vp.utils.debug("  [4.25, 4.5, 10] averageByGroup: " + averages);
            //---- avg by callback group ----
            var newData = vp.data.aggByGroup(data, { name: "avgSales", column: "sales", aggName: "avg" }, { name: "century", column: function (r) { return Math.floor(r.year / 100); } });
            var averages = vp.data.dataSelect(newData, "avgSales");
            vp.utils.debug("  [4.25, 6.33] averageByGroup: " + averages);
            //---- test datePart() ----
            var date = vp.data.datePart(new Date());
            vp.utils.debug("  [today at midnight] datePart: " + date);
        }
        unitTests.testDataUtils = testDataUtils;
    })(unitTests = vp.unitTests || (vp.unitTests = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// selectedSet.ts.  Copyright (c) 2016 Microsoft Corporation.
///              part of the vuePlot library - selected set functions.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var dom;
    (function (dom) {
        var selectedSet = (function () {
            //select = Array.prototype.select;
            function selectedSet(elements) {
                //---- make "selectedSet" look/act like an array object ---
                this.length = 0;
                this.push = Array.prototype.push;
                this.sort = Array.prototype.sort;
                this.splice = Array.prototype.splice;
                this.indexOf = Array.prototype.indexOf;
                if (elements) {
                    var sameCtr = true; // initially
                    var lastCtr = "";
                    for (var i = 0; i < elements.length; i++) {
                        var elem = elements[i];
                        this.push(elem);
                        if (i == 0) {
                            lastCtr = elem.ctr;
                        }
                        else {
                            if (elem.ctr != lastCtr) {
                                sameCtr = false;
                            }
                        }
                    }
                    //---- extend this wrapper if elem with custom control properties ----
                    if ((elements.length > 0) && (sameCtr)) {
                        var elem = elements[0];
                        if ((elem.control) && (elem.control.extendWrapper)) {
                            elem.control.extendWrapper(this);
                        }
                    }
                }
            }
            selectedSet.prototype.frameRateChanged = function (fpsCallBack) {
                var appendedElements = [];
                var firstContainer = null;
                this.each(function (index, container) {
                    vp.dom.frameRateChanged(this, fpsCallBack);
                });
                return this;
            };
            //---- ADD the content to the selected set of containers ----
            selectedSet.prototype.add = function (content) {
                var ss = null;
                var firstContainer = true;
                this.each(function (index, container) {
                    var newElems = vp.dom.add(container, content);
                    if (firstContainer) {
                        ss = vp.dom.wrapElements(newElems);
                        firstContainer = false;
                    }
                });
                return ss;
            };
            /// remove all children (childNodes) of each item in the selected set.
            selectedSet.prototype.clear = function () {
                return this.each(function (index, element) {
                    vp.dom.clear(element);
                });
            };
            selectedSet.prototype.show = function (showIt) {
                return this.each(function (index, element) {
                    vp.dom.show(this, showIt);
                });
            };
            selectedSet.prototype.showToggle = function () {
                return this.each(function (index, element) {
                    vp.dom.showToggle(this);
                });
            };
            selectedSet.prototype.hide = function (showIt) {
                return this.each(function (index, element) {
                    vp.dom.hide(this);
                });
            };
            selectedSet.prototype.collapse = function () {
                return this.each(function (index, element) {
                    vp.dom.collapse(this);
                });
            };
            selectedSet.prototype.expand = function () {
                return this.each(function (index, element) {
                    vp.dom.expand(this);
                });
            };
            /// gets the {left,top} offset of the HTML/SVG/Canvas element from the document origin.
            selectedSet.prototype.docOffset = function (elem) {
                var value = null;
                if (this.length > 0) {
                    value = vp.dom.docOffset(elem);
                }
                return value;
            };
            selectedSet.prototype.left = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.left(this[0]);
                    }
                    return value;
                }
                else {
                    //---- SET value ----
                    return this.each(function (index, element) {
                        vp.dom.left(this, value);
                    });
                }
            };
            selectedSet.prototype.top = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.top(this[0]);
                    }
                    return value;
                }
                else {
                    //---- SET value ----
                    return this.each(function (index, element) {
                        vp.dom.top(this, value);
                    });
                }
            };
            selectedSet.prototype.width = function (value) {
                if (arguments.length == 0) {
                    var value = null;
                    if (this.length > 0) {
                        value = vp.dom.width(this[0]);
                    }
                    return value;
                }
                else {
                    //---- SET value ----
                    var origValue = value;
                    return this.each(function (index, element) {
                        if (vp.utils.isFunction(origValue)) {
                            value = origValue(index, element);
                        }
                        vp.dom.width(this, value);
                    });
                }
            };
            selectedSet.prototype.css = function (name, value) {
                if (arguments.length == 1) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.css(this[0], name);
                    }
                    return value;
                }
                //---- SET value ----
                var origValue = value;
                return this.each(function (index, element) {
                    if (vp.utils.isFunction(origValue)) {
                        value = origValue(index, element);
                    }
                    vp.dom.css(this, name, value);
                });
            };
            selectedSet.prototype.height = function (value) {
                if (arguments.length == 0) {
                    var value = null;
                    if (this.length > 0) {
                        value = vp.dom.height(this[0]);
                    }
                    return value;
                }
                //---- SET value ----
                var origValue = value;
                return this.each(function (index, element) {
                    if (vp.utils.isFunction(origValue)) {
                        value = origValue(index, element);
                    }
                    vp.dom.height(this, value);
                });
            };
            /// get total height of first element
            selectedSet.prototype.totalHeight = function () {
                var value = null;
                if (this.length > 0) {
                    value = vp.dom.totalHeight(this[0]);
                }
                return value;
            };
            /// get total width of first element
            selectedSet.prototype.totalWidth = function () {
                var value = null;
                if (this.length > 0) {
                    value = vp.dom.totalWidth(this[0]);
                }
                return value;
            };
            selectedSet.prototype.toolTipEnabled = function (value) {
                if (arguments.length == 0) {
                    value = (this.length > 0) ? this[0].toolTipEnabled : false;
                    return value;
                }
                return this.each(function (index, element) {
                    vp.dom.toolTipEnabled(element, value);
                });
            };
            selectedSet.prototype.animate = function (duration, ease, container) {
                return this.each(function (index, element) {
                    vp.dom.animate(this, duration, ease, container);
                });
            };
            selectedSet.prototype.onAnimationComplete = function (completedFunc) {
                return this.each(function (index, element) {
                    vp.dom.onAnimationComplete(this, completedFunc);
                });
            };
            selectedSet.prototype.remove = function () {
                return this.each(function (index, element) {
                    if (this.animation == null) {
                        vp.dom.remove(this);
                    }
                    else {
                        this.animation.deleteElementsOnCompleted(this);
                    }
                });
            };
            selectedSet.prototype.attr = function (name, value) {
                if (arguments.length == 1) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.attr(this[0], name);
                    }
                    return value;
                }
                //---- SET value ----
                var origValue = value;
                return this.each(function (index, element) {
                    vp.dom.attr(this, name, value);
                });
            };
            selectedSet.prototype.prop = function (name, value) {
                if (arguments.length == 1) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.prop(this[0], name);
                    }
                    return value;
                }
                //---- SET value ----
                var origValue = value;
                return this.each(function (index, element) {
                    vp.dom.prop(this, name, value);
                });
            };
            selectedSet.prototype.attrXlink = function (name, origValue) {
                return this.attrNS("http://www.w3.org/1999/xlink", name, origValue);
            };
            selectedSet.prototype.attrNS = function (ns, name, value) {
                return this.each(function (index, element) {
                    vp.dom.attrNS(element, ns, name, value);
                });
            };
            selectedSet.prototype.hLine = function (x1, x2, y, makeCrisp) {
                return this.each(function (index, element) {
                    vp.dom.hLine(element, x1, x2, y, makeCrisp);
                });
            };
            selectedSet.prototype.vLine = function (y1, y2, x, makeCrisp) {
                return this.each(function (index, element) {
                    vp.dom.vLine(element, y1, y2, x, makeCrisp);
                });
            };
            selectedSet.prototype.bounds = function (x, y, width, height, makeCrisp) {
                return this.each(function (index, element) {
                    vp.dom.bounds(element, x, y, width, height, makeCrisp);
                });
            };
            selectedSet.prototype.radius = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    value = (this.length > 0) ? vp.dom.radius(this[0]) : 0;
                    return value;
                }
                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.radius(this, value);
                });
            };
            selectedSet.prototype.tabIndex = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    value = (this.length > 0) ? vp.dom.tabIndex(this[0]) : 0;
                    return value;
                }
                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.tabIndex(this, value);
                });
            };
            selectedSet.prototype.opacity = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.opacity(this[0]);
                    }
                    return value;
                }
                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.opacity(this, value);
                });
            };
            selectedSet.prototype.checked = function (value) {
                //---- GET value ----
                if (arguments.length == 0) {
                    value = null;
                    if (this.length > 0) {
                        value = vp.dom.checked(this[0]);
                    }
                    return value;
                }
                //---- SET value ----
                return this.each(function (index, element) {
                    //---- animation not supported for "checked" ----
                    vp.dom.checked(this, value);
                });
            };
            selectedSet.prototype.position = function (x, y) {
                return this.each(function (index, element) {
                    vp.dom.position(element, x, y);
                });
            };
            selectedSet.prototype.absPosition = function (left, top) {
                return this.each(function (index, element) {
                    vp.dom.absPosition(element, left, top);
                });
            };
            selectedSet.prototype.removeProp = function (name) {
                return this.each(function (index, element) {
                    //---- animation not supported for this operation ----
                    vp.dom.removeProp(this, name);
                });
            };
            selectedSet.prototype.center = function (cx, cy) {
                return this.each(function (index, element) {
                    vp.dom.center(element, cx, cy);
                });
            };
            selectedSet.prototype.id = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.id(this[0]);
                    }
                    return value;
                }
                else {
                    //---- SET value ----
                    return this.each(function (index, element) {
                        vp.dom.id(this, value);
                    });
                }
            };
            selectedSet.prototype.addClass = function (name) {
                return this.each(function (index, element) {
                    vp.dom.addClass(this, name);
                });
            };
            selectedSet.prototype.removeClass = function (name) {
                return this.each(function (index, element) {
                    vp.dom.removeClass(this, name);
                });
            };
            selectedSet.prototype.hasClass = function (name) {
                var hasIt = false;
                if (this.length > 0) {
                    hasIt = vp.dom.hasClass(this[0], name);
                }
                return hasIt;
            };
            selectedSet.prototype.getBounds = function (relToParent, includePadding) {
                var result = null;
                if (this.length > 0) {
                    result = vp.dom.getBounds(this[0], relToParent, includePadding);
                }
                return result;
            };
            selectedSet.prototype.setClass = function (name) {
                return this.each(function (index, element) {
                    vp.dom.setClass(this, name);
                });
            };
            selectedSet.prototype.toggleClass = function (name) {
                return this.each(function (index, element) {
                    vp.dom.toggleClass(this, name);
                });
            };
            selectedSet.prototype.attach = function (eventName, funcToCall, useCapture) {
                return this.each(function (index, element) {
                    vp.events.attach(this, eventName, funcToCall, useCapture);
                });
            };
            selectedSet.prototype.detach = function (eventName, funcToCall, useCapture) {
                return this.each(function (index, element) {
                    vp.events.detach(this, eventName, funcToCall, useCapture);
                });
            };
            selectedSet.prototype.transform = function (value) {
                return this.each(function (index, element) {
                    vp.dom.transform(this, value);
                });
            };
            selectedSet.prototype.translate = function (x, y, makeCrispGroup, makeCrispRoot) {
                return this.each(function (index, element) {
                    vp.dom.translate(this, x, y, makeCrispGroup, makeCrispRoot);
                });
            };
            selectedSet.prototype.transformOrigin = function (value) {
                if (arguments.length == 0) {
                    value = (this.length > 0) ? vp.dom.transformOrigin(this[0]) : undefined;
                    return value;
                }
                return this.each(function (index, element) {
                    vp.dom.transformOrigin(value);
                });
            };
            selectedSet.prototype.addStop = function (offset, color, opacity) {
                return this.each(function (index, element) {
                    vp.dom.addStop(this, offset, color, opacity);
                });
            };
            selectedSet.prototype.textBaseline = function (alignType, rc) {
                return this.each(function (index, element) {
                    vp.dom.textBaseline(element, alignType, rc);
                });
            };
            selectedSet.prototype.from = function (x1, y1) {
                return this.each(function (index, element) {
                    vp.dom.from(element, x1, y1);
                });
            };
            selectedSet.prototype.to = function (x2, y2) {
                return this.each(function (index, element) {
                    vp.dom.to(element, x2, y2);
                });
            };
            selectedSet.prototype.font = function (family, size, weight, style) {
                return this.each(function (index, element) {
                    vp.dom.font(element, family, size, weight, style);
                });
            };
            selectedSet.prototype.dataPair = function (dataItem, dataIndex) {
                return this.each(function (index, element) {
                    vp.dom.dataPair(this, dataItem, dataIndex);
                });
            };
            selectedSet.prototype.data = function (value) {
                if (arguments.length == 0) {
                    var anyElem = this[0];
                    return (anyElem.data) ? anyElem.data() : null;
                }
                return this.each(function (index, element) {
                    var anyElem = element;
                    if (anyElem.data) {
                        anyElem.data(value);
                    }
                });
            };
            selectedSet.prototype.dataItem = function (dataItem) {
                if (dataItem != null) {
                    return this.each(function (index, element) {
                        this.dataItem = dataItem;
                    });
                }
                else {
                    return this[0].dataItem;
                }
            };
            selectedSet.prototype.dataIndex = function (value) {
                if (value != null) {
                    return this.each(function (index, element) {
                        this.dataIndex = value;
                    });
                }
                else {
                    return (this.length == 0) ? null : this[0].dataIndex;
                }
            };
            selectedSet.prototype.customAttr = function (name, value) {
                if (arguments.length == 1) {
                    value = (this.length > 0) ? vp.dom.customAttr(this[0], name) : undefined;
                    return value;
                }
                return this.each(function (index, element) {
                    vp.dom.customAttr(element, name, value);
                });
            };
            selectedSet.prototype.text = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    value = null;
                    if (this.length > 0) {
                        value = vp.dom.text(this[0]);
                    }
                    return value;
                }
                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.text(this, value);
                });
            };
            selectedSet.prototype.title = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    value = null;
                    if (this.length > 0) {
                        value = vp.dom.title(this[0]);
                    }
                    return value;
                }
                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.title(this, value);
                });
            };
            selectedSet.prototype.value = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    if (this.length > 0) {
                        value = vp.dom.value(this[0]);
                    }
                    return value;
                }
                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.value(this, value);
                });
            };
            selectedSet.prototype.html = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    return (this.length == 0) ? null : this[0].innerHTML;
                }
                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.html(this, value);
                });
            };
            selectedSet.prototype.colors = function (fill, stroke, strokeWidth) {
                return this.each(function (index, element) {
                    vp.dom.colors(this, fill, stroke, strokeWidth);
                });
            };
            selectedSet.prototype.href = function (value) {
                return this.attrNS("http://www.w3.org/1999/xlink", "href", value);
            };
            selectedSet.prototype.safeHref = function (value, fallback) {
                if ((!value) || (value.length == 0)) {
                    value = fallback;
                }
                return this.each(function (index, element) {
                    vp.dom.href(this, value);
                });
            };
            selectedSet.prototype.kids = function () {
                var kids = [];
                if (this.length > 0) {
                    kids = vp.dom.children(this[0]);
                }
                var wrappedKids = vp.dom.wrapElements(kids);
                return wrappedKids;
            };
            selectedSet.prototype.elementSizes = function (callBack) {
                var value = undefined;
                if (this.length > 0) {
                    value = vp.dom.elementSizes(this[0]);
                }
                return value;
            };
            selectedSet.prototype.background = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    return (this.length == 0) ? null : this[0].background;
                }
                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.background(this, value);
                });
            };
            selectedSet.prototype.focus = function () {
                if (this.length > 0) {
                    vp.dom.focus(this[0]);
                }
                return this;
            };
            selectedSet.prototype.dataId = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    return (this.length == 0) ? null : vp.dom.dataItem(this[0]);
                }
                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.dataItem(this, value);
                });
            };
            selectedSet.prototype.shapeId = function (value) {
                if (arguments.length == 0) {
                    //---- GET value ----
                    return (this.length == 0) ? null : vp.dom.shapeId(this[0]);
                }
                //---- SET value ----
                return this.each(function (index, element) {
                    vp.dom.shapeId(this, value);
                });
            };
            /// get element at specified index.  fails silently if index is not a number or out of range.
            selectedSet.prototype.get = function (index) {
                var element = null;
                if (vp.utils.isNumber(index)) {
                    if ((index >= 0) && (index < this.length)) {
                        element = this[index];
                    }
                }
                return element;
            };
            selectedSet.prototype.element = function () {
                return this.get(0);
            };
            /// wrap the element at specified index.  fails silently if index is not a number or out of range.
            selectedSet.prototype.wrap = function (index) {
                var element = this.get(index);
                var ss = null;
                if (element) {
                    ss = vp.dom.wrapElements(element);
                }
                return ss;
            };
            selectedSet.prototype.toArray = function () {
                return Array.prototype.slice.call(this, 0);
            };
            //---- eachsignature: callback(index, element) ----
            selectedSet.prototype.each = function (callback) {
                for (var i = 0; i < this.length; i++) {
                    var elem = this[i];
                    //---- callback with this=elem and 2 params ----
                    callback.call(elem, i, elem);
                }
                return this;
            };
            //---- eachWrappedsignature: callback(index, element) ----
            selectedSet.prototype.eachWrapped = function (callback) {
                var sw = vp.dom.createSingleWrapper(null);
                for (var i = 0; i < this.length; i++) {
                    var elem = this[i];
                    sw.elem = elem;
                    //---- callback with this=wrapper(elem) and 2 params ----
                    callback.call(sw, i, sw);
                }
                return this;
            };
            /// adds the specified element/array to the selected set.
            selectedSet.prototype.merge = function (elemOrArray) {
                var newElements = null;
                if (elemOrArray instanceof vp.dom.selectedSet) {
                    elemOrArray = elemOrArray.toArray();
                }
                else if (elemOrArray instanceof vp.canvas.canvasSelectedSet) {
                    elemOrArray = elemOrArray.toArray();
                }
                else if (elemOrArray instanceof vp.dom.singleWrapperSuperClass) {
                    elemOrArray = elemOrArray.elem;
                }
                if (vp.utils.isArray(elemOrArray)) {
                    newElements = this.toArray().concat(elemOrArray);
                }
                else {
                    newElements = this.toArray();
                    newElements.push(elemOrArray);
                }
                var newSet = new vp.dom.selectedSet(newElements);
                return newSet;
            };
            //---- remove the selected set from their parent ----
            selectedSet.prototype.removeCore = function (content) {
                this.each(function (index, element) {
                    vp.dom.remove(element);
                });
            };
            selectedSet.prototype.append = function (content) {
                return vp.dom.appendCoreMulti(this, content, "append");
            };
            selectedSet.prototype.prepend = function (content) {
                return vp.dom.appendCoreMulti(this, content, "prepend");
            };
            selectedSet.prototype.insertBefore = function (content) {
                return vp.dom.appendCoreMulti(this, content, "insertBefore");
            };
            selectedSet.prototype.insertAfter = function (content) {
                return vp.dom.appendCoreMulti(this, content, "insertAfter");
            };
            selectedSet.prototype.is = function (elementType) {
                var match = false;
                for (var i = 0; i < this.length; i++) {
                    var elem = this[i];
                    match = vp.dom.is(elem, elementType);
                    if (match) {
                        break;
                    }
                }
                return match;
            };
            //---- extend vuePlot selected set to add "context()" ----
            //---- use to obtain a Canvas (2d) or WebGL (3d) context ----
            selectedSet.prototype.context = function (origRequest) {
                var cc = null;
                var value = null;
                for (var i = 0; i < this.length; i++) {
                    var elem = this[i];
                    var contextRequest = origRequest;
                    if (elem.getContext) {
                        if (contextRequest == "3d") {
                            //---- works for IE11, Chrome, Safari, FireFox ----
                            contextRequest = "experimental-webgl";
                            //---- setting alpha=false prevents alpha values that we output from compositing with other DOM elements ----
                            value = elem.getContext(contextRequest, { alpha: false });
                        }
                        else {
                            value = elem.getContext(contextRequest);
                        }
                    }
                    if (value == null) {
                        if (origRequest == "2d") {
                        }
                        else {
                        }
                    }
                    if (value != null) {
                        if (elem.canvasContainerElement != null) {
                            //---- reuse existing object (prevent duplicates w/diff info) ----
                            cc = elem.canvasContainerElement;
                            cc.ctx = value;
                            cc.contextRequest = origRequest;
                        }
                        else {
                            cc = new vp.canvas.canvasContainerElement(elem, value, origRequest);
                        }
                    }
                    break;
                }
                return cc;
            };
            return selectedSet;
        }());
        dom.selectedSet = selectedSet;
    })(dom = vp.dom || (vp.dom = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// singleWrapper.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///    - class that wraps a single element (HTML, SVG, Canvas, or WebGL item).
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var dom;
    (function (dom) {
        /** class that wraps a single element (HTML, SVG, Canvas, or WebGL item). */
        var singleWrapperSuperClass = (function () {
            function singleWrapperSuperClass(elem) {
                this.prop = null;
                this.elem = elem;
                //---- these are one and the same ----
                this.prop = this.customAttr;
                //---- we want calling code to be able to treat this as an array (so it doesn't have to special case ss vs. this) ----
                var self = this;
                self.length = 0;
                //---- make "selectedSet" look/act like an array object ---
                self.push = Array.prototype.push;
                self.splice = Array.prototype.splice;
                self.indexOf = Array.prototype.indexOf;
                self.select = Array.prototype.select;
                self.push(elem);
                //---- remove this as soon as all 15 controls are converted to TypeScript ----
                //---- extend this wrapper if elem with custom control properties ----
                var anyElem = elem;
                if ((anyElem) && (anyElem.control) && (anyElem.control.extendWrapper)) {
                    anyElem.control.extendWrapper(this);
                }
            }
            singleWrapperSuperClass.prototype.element = function (value) {
                if (arguments.length == 0) {
                    return this.elem;
                }
                this[0] = value;
                this.elem = value;
            };
            singleWrapperSuperClass.prototype.css = function (name, value) {
                if (arguments.length == 1) {
                    return vp.dom.css(this.elem, name);
                }
                vp.dom.css(this.elem, name, value);
                return this;
            };
            singleWrapperSuperClass.prototype.hLine = function (x1, x2, y, makeCrisp) {
                vp.dom.hLine(this.elem, x1, x2, y, makeCrisp);
                return this;
            };
            singleWrapperSuperClass.prototype.vLine = function (y1, y2, x, makeCrisp) {
                vp.dom.vLine(this.elem, y1, y2, x, makeCrisp);
                return this;
            };
            singleWrapperSuperClass.prototype.bounds = function (x, y, width, height, makeCrisp) {
                vp.dom.bounds(this.elem, x, y, width, height, makeCrisp);
                return this;
            };
            singleWrapperSuperClass.prototype.colors = function (fill, stroke, strokeWidth) {
                vp.dom.colors(this.elem, fill, stroke, strokeWidth);
                return this;
            };
            singleWrapperSuperClass.prototype.text = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.text(this.elem);
                }
                vp.dom.text(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.tabIndex = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.tabIndex(this.elem);
                }
                vp.dom.tabIndex(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.title = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.title(this.elem);
                }
                vp.dom.title(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.value = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.value(this.elem);
                }
                vp.dom.value(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.html = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.html(this.elem);
                }
                vp.dom.html(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.show = function (showIt) {
                vp.dom.show(this.elem, showIt);
                return this;
            };
            singleWrapperSuperClass.prototype.showToggle = function () {
                vp.dom.showToggle(this.elem);
                return this;
            };
            singleWrapperSuperClass.prototype.hide = function (showIt) {
                vp.dom.hide(this.elem);
                return this;
            };
            singleWrapperSuperClass.prototype.collapse = function () {
                vp.dom.collapse(this.elem);
                return this;
            };
            singleWrapperSuperClass.prototype.expand = function () {
                vp.dom.expand(this.elem);
                return this;
            };
            singleWrapperSuperClass.prototype.dataIndex = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.dataIndex(this.elem);
                }
                vp.dom.dataIndex(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.data = function (value) {
                var anyElem = this.elem;
                if (arguments.length == 0) {
                    return (anyElem.data) ? anyElem.data() : null;
                }
                if (anyElem.data) {
                    anyElem.data(value);
                }
                return this;
            };
            singleWrapperSuperClass.prototype.dataItem = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.dataItem(this.elem);
                }
                vp.dom.dataItem(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.dataPair = function (dataItem, dataIndex) {
                vp.dom.dataPair(this.elem, dataItem, dataIndex);
                return this;
            };
            singleWrapperSuperClass.prototype.to = function (x, y) {
                vp.dom.to(this.elem, x, y);
                return this;
            };
            singleWrapperSuperClass.prototype.from = function (x, y) {
                vp.dom.from(this.elem, x, y);
                return this;
            };
            singleWrapperSuperClass.prototype.attach = function (name, callBack, useCapture) {
                vp.events.attach(this.elem, name, callBack, useCapture);
                return this;
            };
            singleWrapperSuperClass.prototype.detach = function (name, callBack, useCapture) {
                vp.events.detach(this.elem, name, callBack, useCapture);
                return this;
            };
            singleWrapperSuperClass.prototype.transform = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.transform(this.elem);
                }
                vp.dom.transform(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.translate = function (x, y, makeCrispGroup, makeCrispRoot) {
                vp.dom.translate(this.elem, x, y, makeCrispGroup, makeCrispRoot);
                return this;
            };
            singleWrapperSuperClass.prototype.transformOrigin = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.transformOrigin(this.elem);
                }
                vp.dom.transformOrigin(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.href = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.href(this.elem);
                }
                vp.dom.href(this.elem, value);
                return this;
                // return vp.dom.attrNS("http://www.w3.org/1999/xlink", "href", value);
            };
            singleWrapperSuperClass.prototype.safeHref = function (value, fallback) {
                if ((!value) || (value.length == 0)) {
                    value = fallback;
                }
                vp.dom.href(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.font = function (family, size, weight, style) {
                vp.dom.font(this.elem, family, size, weight, style);
                return this;
            };
            singleWrapperSuperClass.prototype.setClass = function (value) {
                vp.dom.setClass(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.hasClass = function (value) {
                var returnValue = vp.dom.hasClass(this.elem, value);
                return returnValue;
            };
            singleWrapperSuperClass.prototype.addClass = function (value) {
                vp.dom.addClass(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.removeClass = function (value) {
                vp.dom.removeClass(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.toggleClass = function (value) {
                vp.dom.toggleClass(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.id = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.id(this.elem);
                }
                vp.dom.id(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.getBounds = function (relToParent, includePadding) {
                return vp.dom.getBounds(this.elem, relToParent, includePadding);
            };
            singleWrapperSuperClass.prototype.center = function (cx, cy) {
                vp.dom.center(this.elem, cx, cy);
                return this;
            };
            singleWrapperSuperClass.prototype.position = function (x, y) {
                vp.dom.position(this.elem, x, y);
                return this;
            };
            singleWrapperSuperClass.prototype.absPosition = function (left, top) {
                vp.dom.absPosition(this.elem, left, top);
                return this;
            };
            singleWrapperSuperClass.prototype.opacity = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.opacity(this.elem);
                }
                vp.dom.opacity(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.radius = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.radius(this.elem);
                }
                vp.dom.radius(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.attr = function (name, value, disableAnim) {
                if (arguments.length == 1) {
                    return vp.dom.attr(this.elem, name);
                }
                vp.dom.attr(this.elem, name, value, disableAnim);
                return this;
            };
            singleWrapperSuperClass.prototype.customAttr = function (name, value) {
                if (arguments.length == 1) {
                    return vp.dom.customAttr(this.elem, name);
                }
                vp.dom.customAttr(this.elem, name, value);
                return this;
            };
            singleWrapperSuperClass.prototype.remove = function () {
                vp.dom.remove(this.elem);
                return this;
            };
            singleWrapperSuperClass.prototype.toolTipEnabled = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.toolTipEnabled(this.elem);
                }
                vp.dom.toolTipEnabled(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.height = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.height(this.elem);
                }
                vp.dom.height(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.width = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.width(this.elem);
                }
                vp.dom.width(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.totalHeight = function () {
                return vp.dom.totalHeight(this.elem);
            };
            singleWrapperSuperClass.prototype.totalWidth = function () {
                return vp.dom.totalWidth(this.elem);
            };
            singleWrapperSuperClass.prototype.left = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.left(this.elem);
                }
                vp.dom.left(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.top = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.top(this.elem);
                }
                vp.dom.top(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.checked = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.checked(this.elem);
                }
                vp.dom.checked(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.clear = function () {
                vp.dom.clear(this.elem);
                return this;
            };
            singleWrapperSuperClass.prototype.add = function (content) {
                var elems = vp.dom.add(this.elem, content);
                var ss = vp.dom.wrapElements(elems);
                return ss;
            };
            singleWrapperSuperClass.prototype.append = function (content) {
                var ss = vp.dom.append(this.elem, content);
                return ss;
            };
            singleWrapperSuperClass.prototype.prepend = function (content) {
                var ss = vp.dom.prepend(this.elem, content);
                return ss;
            };
            singleWrapperSuperClass.prototype.insertBefore = function (content) {
                var ss = vp.dom.insertBefore(this.elem, content);
                return ss;
            };
            singleWrapperSuperClass.prototype.insertAfter = function (content) {
                var ss = vp.dom.insertAfter(this.elem, content);
                return ss;
            };
            singleWrapperSuperClass.prototype.addStop = function (offset, color, opacity) {
                vp.dom.addStop(this.elem, offset, color, opacity);
                return this;
            };
            singleWrapperSuperClass.prototype.textBaseline = function (alignType, rc) {
                vp.dom.textBaseline(this.elem, alignType, rc);
                return this;
            };
            singleWrapperSuperClass.prototype.animate = function (duration, ease, container) {
                vp.dom.animate(this.elem, duration, ease, container);
                return this;
            };
            singleWrapperSuperClass.prototype.onAnimationComplete = function (callback) {
                vp.dom.onAnimationComplete(this.elem, callback);
                return this;
            };
            singleWrapperSuperClass.prototype.frameRateChanged = function (callBack) {
                vp.dom.frameRateChanged(this.elem, callBack);
                return this;
            };
            /// creates a new selectedSet from the current this.elem and the specified element/array.
            singleWrapperSuperClass.prototype.merge = function (elemOrArray) {
                var newElements = null;
                if (elemOrArray instanceof vp.dom.selectedSet) {
                    elemOrArray = elemOrArray.toArray();
                }
                else if (elemOrArray instanceof vp.dom.singleWrapperSuperClass) {
                    elemOrArray = elemOrArray.elem;
                }
                if (vp.utils.isArray(elemOrArray)) {
                    newElements = this.toArray().concat(elemOrArray);
                }
                else {
                    newElements = this.toArray();
                    newElements.push(elemOrArray);
                }
                var newSet = new vp.dom.selectedSet(newElements);
                return newSet;
            };
            singleWrapperSuperClass.prototype.toArray = function () {
                return [this.elem];
            };
            singleWrapperSuperClass.prototype.wrap = function (index) {
                var we = null;
                if (index == 0) {
                    we = vp.dom.wrapElements(this.elem);
                }
                return we;
            };
            singleWrapperSuperClass.prototype.kids = function () {
                var kids = vp.dom.children(this.elem);
                var wrappedKids = vp.dom.wrapElements(kids);
                return wrappedKids;
            };
            singleWrapperSuperClass.prototype.each = function (callback) {
                //---- pass our element to callback as wrapped ("this") ----
                callback.call(this, 0, this);
                return this;
            };
            singleWrapperSuperClass.prototype.elementSizes = function () {
                return vp.dom.elementSizes(this.elem); //, callBack);
            };
            singleWrapperSuperClass.prototype.focus = function () {
                vp.dom.focus(this.elem);
                return this;
            };
            singleWrapperSuperClass.prototype.background = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.background(this.elem);
                }
                vp.dom.background(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.dataId = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.dataId(this.elem);
                }
                vp.dom.dataId(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.shapeId = function (value) {
                if (arguments.length == 0) {
                    return vp.dom.shapeId(this.elem);
                }
                vp.dom.shapeId(this.elem, value);
                return this;
            };
            singleWrapperSuperClass.prototype.is = function (elementType) {
                return vp.dom.is(this.elem, elementType);
            };
            return singleWrapperSuperClass;
        }());
        dom.singleWrapperSuperClass = singleWrapperSuperClass;
        /** class that wraps a single element (HTML, SVG, Canvas, or WebGL item). */
        var singleWrapperClass = (function (_super) {
            __extends(singleWrapperClass, _super);
            function singleWrapperClass() {
                _super.apply(this, arguments);
                this.ctr = "vp.singleWrapper"; // code depends on this exact string
            }
            return singleWrapperClass;
        }(singleWrapperSuperClass));
        dom.singleWrapperClass = singleWrapperClass;
        function createSingleWrapper(elem) {
            return new singleWrapperClass(elem);
        }
        dom.createSingleWrapper = createSingleWrapper;
    })(dom = vp.dom || (vp.dom = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// basicSelect.ts.  Copyright (c) 2016 Microsoft Corporation.
///              part of the vuePlot library - selectand related support.
///              Note: this file must be processed first in its folder.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var dom;
    (function (dom) {
        /// internal.
        /// elements: the list of collected elements to add matches to.
        function getElementsCore(elements, parentElem, byId, byClass, byTag, byColon, name) {
            //vp.utils.debug("getElementsCore: parentElem=" + parentElem + ", parentElem.tagName=" + parentElem.tagName);
            if ((parentElem.id == "canvases") || (parentElem.id == "2dRect")) {
                var dummy2 = 0;
            }
            var kids = vp.dom.children(parentElem);
            if ((kids) && (kids.length > 0)) {
                for (var i = 0; i < kids.length; i++) {
                    var elem = kids[i];
                    if (elem.tagName == "svg") {
                        var a = 9;
                    }
                    if (byId) {
                        if (elem.id == name) {
                            elements.push(elem);
                        }
                    }
                    else if (byTag) {
                        if ((elem.tagName) && (elem.tagName.toLowerCase() == name)) {
                            elements.push(elem);
                        }
                    }
                    else if (byColon) {
                        if (colonTest(elem, name)) {
                            elements.push(elem);
                        }
                    }
                    else if (byClass) {
                        if (vp.dom.hasClass(elem, name)) {
                            elements.push(elem);
                        }
                    }
                    else {
                        //---- must be "*" (include everything) ----
                        elements.push(elem);
                    }
                    var grandKids = vp.dom.children(elem);
                    if ((grandKids) && (grandKids.length > 0)) {
                        //---- search the children of "elem" and add the matches to "elements" ----
                        getElementsCore(elements, elem, byId, byClass, byTag, byColon, name);
                    }
                }
            }
        }
        /// internal: return true if element meets condition of specified colon filter
        function colonTest(elem, name) {
            var meets = false;
            /// for perf reasons, we don't call out to utility functions to check for values; that
            /// cross-browser code is duplicated here.
            if (elem != null) {
                if (name == "checked") {
                    meets = elem.checked;
                }
                else if (name == "hidden") {
                    meets = (elem.visibility == "hidden");
                }
                else if (name == "visible") {
                    meets = (elem.visibility != "hidden");
                }
                else if (name == "selected") {
                    meets = (elem.selected === true);
                }
                else if (name == "checked") {
                    meets = (elem.checked === true);
                }
                else if (name == "disabled") {
                    meets = (elem.disabled);
                }
                else if (name == "enabled") {
                    meets = (elem.disabled === undefined);
                }
                else if (name == "input") {
                    meets = (elem.tagName.toLowerCase() == "input");
                }
                else if (name == "radio") {
                    meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "radio"));
                }
                else if (name == "button") {
                    meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "button"));
                }
                else if (name == "checkbox") {
                    meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "checkbox"));
                }
                else if (name == "button") {
                    meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "button"));
                }
                else if (name == "password") {
                    meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "password"));
                }
                else if (name == "text") {
                    meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "text"));
                }
                else if (name == "submit") {
                    meets = ((elem.tagName.toLowerCase() == "input") && (elem.type.toLowerCase() == "submit"));
                }
            }
            return meets;
        }
        function getElementsInSelectorString(parentElem, selector) {
            var ss = selector.trim();
            var elements = [];
            var byId = false;
            var byTag = false;
            var byClass = false;
            var byColon = false;
            var name = "";
            if (parentElem == null) {
                parentElem = document;
            }
            else if (parentElem.length) {
                parentElem = parentElem[0]; // unwrap parent, if needed
            }
            //---- keep it very simple for now ----
            if (ss.startsWith("#")) {
                byId = true;
                name = ss.substring(1).ltrim();
            }
            else if (ss.startsWith(".")) {
                byClass = true;
                name = ss.substring(1).ltrim();
            }
            else if (ss.startsWith(":")) {
                byColon = true;
                name = ss.substring(1).ltrim();
            }
            else if (ss != "*") {
                byTag = true;
                name = ss.toLowerCase();
            }
            getElementsCore(elements, parentElem, byId, byClass, byTag, byColon, name);
            return elements;
        }
        dom.getElementsInSelectorString = getElementsInSelectorString;
        function wrapElements(elemOrArray) {
            var ss = null;
            if (vp.utils.isArray(elemOrArray)) {
                if (elemOrArray.length == 1) {
                    ss = vp.dom.createSingleWrapper(elemOrArray[0]);
                }
                else {
                    ss = new vp.dom.selectedSet(elemOrArray);
                }
            }
            else if (elemOrArray) {
                ss = vp.dom.createSingleWrapper(elemOrArray);
            }
            return ss;
        }
        dom.wrapElements = wrapElements;
        /// upwrap(elem): return unwrapped version of elem (can be wrapper or unwrapped element)
        function unwrap(elem) {
            if (elem.length) {
                elem = elem[0];
            }
            return elem;
        }
        dom.unwrap = unwrap;
    })(dom = vp.dom || (vp.dom = {}));
})(vp || (vp = {}));
var vp;
(function (vp) {
    function select(p1, p2) {
        var parentElem = null;
        var selector = null;
        if (p2) {
            //---- selection string specified ----
            parentElem = p1;
            selector = p2;
        }
        else if (vp.utils.isString(p1)) {
            //---- only p1=string specified ----
            parentElem = document.body;
            selector = p1;
        }
        else {
            //---- only p1=NON-string specified ----
            parentElem = p1;
            selector = null;
        }
        //return new vp.dom.selectedSet(rootElement, selectStr);
        if (vp.utils.isString(selector)) {
            var elems = vp.dom.getElementsInSelectorString(parentElem, selector);
            return vp.dom.wrapElements(elems);
        }
        else if (vp.utils.isArray(parentElem)) {
            return vp.dom.wrapElements(parentElem);
        }
        else if (parentElem != null) {
            return vp.dom.wrapElements(parentElem);
        }
        else {
            return new vp.dom.selectedSet(); // empty selected set
        }
    }
    vp.select = select;
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// canvasSelectedSet.ts.  Copyright (c) 2016 Microsoft Corporation.
///     Part of the vuePlotCore library - holds a set of canvas items that actions can be executed against.  
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var canvas;
    (function (canvas) {
        //---- class: canvasSelectedSet ----
        var canvasSelectedSet = (function (_super) {
            __extends(canvasSelectedSet, _super);
            //---- "fnCanvas" functions live here ----
            function canvasSelectedSet(parentElem, selector) {
                _super.call(this);
                this.ctr = "vp.canvas.canvasSelectedSet";
                this.parentElem = parentElem;
                this.selector = selector;
                if (vp.utils.isString(selector)) {
                    var elems = vp.dom.getElementsInSelectorString(parentElem, selector);
                    for (var i = 0; i < elems.length; i++) {
                        this.push(elems[i]);
                    }
                }
                else if (vp.utils.isArray(selector)) {
                    for (var i = 0; i < selector.length; i++) {
                        this.push(selector[i]);
                    }
                }
                else if (selector != null) {
                    //---- assume it is a single element ----
                    this.push(selector);
                }
            }
            /// adds the specified element/array to the selected set.
            canvasSelectedSet.prototype.merge = function (elemOrArray) {
                var newElements = null;
                if (elemOrArray instanceof vp.canvas.canvasSelectedSet) {
                    elemOrArray = elemOrArray.toArray();
                }
                if (vp.utils.isArray(elemOrArray)) {
                    newElements = this.toArray().concat(elemOrArray);
                }
                else {
                    var aray = this.toArray();
                    aray.push(elemOrArray);
                    newElements = aray;
                }
                var newSet = new vp.canvas.canvasSelectedSet(this.parentElem, newElements);
                return newSet;
            };
            /// rapidly creates and appends the specified "str" canvas element for the specified "count".
            canvasSelectedSet.prototype.multiAppend = function (str, count) {
                var appendedElements = [];
                if (this.length > 0) {
                    //---- for now, only support first container ----//
                    var container = this[0];
                    for (var i = 0; i < count; i++) {
                        var elem = container.append(str);
                        appendedElements.push(elem);
                    }
                }
                return appendedElements;
            };
            canvasSelectedSet.prototype.updateBounds = function (w, h) {
                return this.each(function (index, container) {
                    this.updateBounds(w, h);
                });
            };
            canvasSelectedSet.prototype.initShaderAnimations = function (duration, onCompleteCallback) {
                return this.each(function (index, container) {
                    this.initShaderAnimations(duration, onCompleteCallback);
                });
            };
            canvasSelectedSet.prototype.resetShaderAnimations = function () {
                return this.each(function (index, container) {
                    this.resetShaderAnimations();
                });
            };
            canvasSelectedSet.prototype.pointSize = function (value) {
                if (arguments.length == 0) {
                    value = (this.length > 0) ? this[0].pointSize() : undefined;
                    return value;
                }
                return this.each(function (index, container) {
                    this.pointSize(value);
                });
            };
            canvasSelectedSet.prototype.usePointSprites = function (value) {
                if (arguments.length == 0) {
                    value = (this.length > 0) ? this[0].usePointSprites() : undefined;
                    return value;
                }
                return this.each(function (index, container) {
                    this.usePointSprites(value);
                });
            };
            canvasSelectedSet.prototype.usePointSize = function (value) {
                if (arguments.length == 0) {
                    value = (this.length > 0) ? this[0].usePointSize() : undefined;
                    return value;
                }
                return this.each(function (index, container) {
                    this.usePointSize(value);
                });
            };
            canvasSelectedSet.prototype.markRebuildNeeded = function () {
                return this.each(function (index, container) {
                    this.markRebuildNeeded();
                });
            };
            canvasSelectedSet.prototype.append = function (content) {
                var appendedElements = [];
                var firstContainer = null;
                this.each(function (index, container) {
                    if (firstContainer == null) {
                        firstContainer = container;
                    }
                    if (content instanceof vp.dom.selectedSet) {
                        content = content.toArray();
                    }
                    else if (content instanceof vp.dom.singleWrapperSuperClass) {
                        content = content.elem;
                    }
                    if (vp.utils.isArray(content)) {
                        for (var i = 0; i < content.length; i++) {
                            var child = content[i];
                            var element = container.appendChild(child);
                            appendedElements.push(element);
                        }
                    }
                    else if (vp.utils.isString(content)) {
                        var canvasElement = this.append(content);
                        if (canvasElement != null) {
                            //---- transfer data info from parent container ----
                            canvasElement.dataItem = container.dataItem;
                            canvasElement.dataIndex = container.dataIndex;
                            appendedElements.push(canvasElement);
                        }
                    }
                    else if (content != null) {
                        container.appendChild(content);
                        appendedElements.push(content);
                    }
                });
                var ss = null;
                if (firstContainer != null) {
                    ss = new vp.canvas.canvasSelectedSet(firstContainer, appendedElements);
                }
                return ss;
            };
            canvasSelectedSet.prototype.attr = function (name, origValue) {
                return this.each(function (index, element) {
                    var value = origValue;
                    if (typeof origValue === "function") {
                        value = origValue(element.dataItem, element.dataIndex);
                    }
                    if (vp.utils.isUndefined(this.animation)) {
                        //---- no animation is active - just set in instantly ----
                        //this[name] = value;
                        //this.markRebuildNeeded();
                        this.setAttribute(name, value);
                    }
                    else {
                        //---- add to current animation ----
                        this.animation.animateAttr(element, name, value);
                    }
                });
            };
            return canvasSelectedSet;
        }(vp.dom.selectedSet));
        canvas.canvasSelectedSet = canvasSelectedSet;
        function canvasSelect(selectStr) {
            return new vp.canvas.canvasSelectedSet(document.body, selectStr);
        }
        canvas.canvasSelect = canvasSelect;
        function selectContext(selectObj, contextName) {
            var ssCanvas = vp.canvas.canvasSelect();
            var elems = null;
            if (vp.utils.isString(selectObj)) {
                elems = vp.dom.getElementsInSelectorString(document.body, selectObj);
            }
            else {
                elems = [selectObj]; // assume it is a canvas element
            }
            var ss = new vp.dom.selectedSet(elems);
            if (ss.length > 0) {
                var cc = ss.context(contextName);
                if (cc != null) {
                    ssCanvas = ssCanvas.merge(cc);
                }
            }
            return ssCanvas;
        }
        canvas.selectContext = selectContext;
    })(canvas = vp.canvas || (vp.canvas = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// canvasUtils.ts.  Copyright (c) 2016 Microsoft Corporation.
///                part of the vuePlotCore library - misc utility functions for canvas.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var internal;
    (function (internal) {
        var parsePathDataAndGenerateDrawFunc = (function () {
            function parsePathDataAndGenerateDrawFunc(dstr) {
                this.index = 0;
                this.firstPt = { x: 0, y: 0 };
                this.lastPt = { x: 0, y: 0 };
                this.firstPointSeen = false;
                this.minX = Number.MAX_VALUE;
                this.minY = Number.MAX_VALUE;
                this.maxX = -Number.MAX_VALUE; // Number.MIN_VALUE;
                this.maxY = -Number.MAX_VALUE; // Number.MIN_VALUE;
                this.d = dstr;
            }
            parsePathDataAndGenerateDrawFunc.prototype.parse = function () {
                var funcStr = "function (ctx)\r\n"
                    + "{\r\n";
                var cmd = "";
                /// sample: d="M 100 100 L 300 100 L 200 300 z"
                /// uppercase cmd letter: absolute coordinates, lowercase: relative coordinates
                ///
                /// M=move, L=line, Z=close, H=horizontal line, V=vertical line, C=cubic bezier, S=reflective cubic bezier
                /// Q=quadratic bezier, T=reflective quadratic, A=arc
                var lastIndex = -1;
                var d = this.d;
                while (this.index < d.length) {
                    this.skipSpaces(d);
                    if (this.index == lastIndex) {
                        vp.utils.error("Error: internal error in parsePathDataAndGenerateDrawFunc()");
                    }
                    if (this.index >= d.length) {
                        break;
                    }
                    lastIndex = this.index;
                    var ch = d[this.index];
                    var isLower = ((ch >= "a") && (ch <= "z"));
                    var isUpper = ((ch >= "A") && (ch <= "Z"));
                    if ((isLower) || (isUpper)) {
                        //---- new cmd specified ----
                        cmd = ch;
                        this.index++;
                        this.skipSpaces(d);
                    }
                    else {
                        vp.utils.error("Error: unrecognized token in path: " + ch);
                    }
                    //---- process current command ----
                    if ((cmd == "M") || (cmd == "m")) {
                        this.firstPointSeen = false; // get ready for a new first point 
                        var pt = this.parsePoint(d, cmd == "m");
                        funcStr += "    ctx.moveTo(" + pt.x + ", " + pt.y + ");\r\n";
                    }
                    else if ((cmd == "L") || (cmd == "l")) {
                        var pt = this.parsePoint(d, cmd == "l");
                        funcStr += "    ctx.lineTo(" + pt.x + ", " + pt.y + ");\r\n";
                    }
                    else if (cmd == "X") {
                        var cx = this.parseNumber(d);
                        var cy = this.parseNumber(d);
                        var r = this.parseNumber(d);
                        var startAngle = this.parseNumber(d);
                        var endAngle = this.parseNumber(d);
                        var antiClock = this.parseNumber(d);
                        funcStr += "    ctx.arc(" + cx + ", " + cy + "," + r + "," +
                            startAngle + "," + endAngle + "," + antiClock + ");\r\n";
                    }
                    else if ((cmd == "A") || (cmd == "a")) {
                        vp.utils.error("Error - 'A' (arc) command in path not currently supported by VuePlot");
                    }
                    else if ((cmd == "Z") || (cmd == "z")) {
                        //if (this.firstPointSeen)
                        //{
                        //    //---- close path with straight line to first point ----
                        //    funcStr += "ctx.lineTo(" + this.firstPt.x + ", " + this.firstPt.y + ");\r\n";
                        //}
                        funcStr += "ctx.closePath();\r\n";
                    }
                    else {
                        vp.utils.error("Error: unrecognized cmd in path: " + cmd);
                    }
                }
                funcStr += "}\r\n";
                var bb = vp.geom.rect(this.minX, this.minY, this.maxX - this.minX, this.maxY - this.minY);
                return [funcStr, bb];
            };
            parsePathDataAndGenerateDrawFunc.prototype.skipSpaces = function (d) {
                while (this.index < this.d.length) {
                    var ch = this.d[this.index];
                    if ((ch == ' ') || (ch == "\t") || (ch == "\r") || (ch == '\n') || (ch == ",")) {
                        this.index++;
                    }
                    else {
                        break;
                    }
                }
            };
            parsePathDataAndGenerateDrawFunc.prototype.parseNumber = function (d) {
                this.skipSpaces(d);
                var isNegative = false;
                var value = 0;
                var d = this.d;
                if (this.index < d.length) {
                    var ch = d[this.index];
                    if (ch == "+") {
                        this.index++;
                    }
                    else if (ch == '-') {
                        this.index++;
                        isNegative = true;
                    }
                    var start = this.index;
                    while (this.index < d.length) {
                        var ch = d[this.index];
                        if ((ch == '.') || ((ch >= '0') && (ch <= '9'))) {
                            this.index++;
                        }
                        else {
                            break;
                        }
                    }
                    var str = d.substr(start, this.index - start);
                    value = parseFloat(str);
                }
                if (isNegative) {
                    value = -value;
                }
                this.index = this.index;
                return value;
            };
            parsePathDataAndGenerateDrawFunc.prototype.parsePoint = function (d, isRelative) {
                /// <number> [ "," ] <number>    (skip spaces in-between each element) 
                var x = this.parseNumber(d);
                var y = this.parseNumber(d);
                if (isRelative) {
                    x += this.lastPt.x;
                    y += this.lastPt.y;
                }
                var pt = { x: x, y: y };
                this.onPointSeen(pt);
                return pt;
            };
            parsePathDataAndGenerateDrawFunc.prototype.onPointSeen = function (pt) {
                if (!this.firstPointSeen) {
                    this.firstPt = pt;
                    this.firstPointSeen = true;
                }
                this.lastPt = pt;
                this.minX = Math.min(this.minX, pt.x);
                this.minY = Math.min(this.minY, pt.y);
                this.maxX = Math.max(this.maxX, pt.x);
                this.maxY = Math.max(this.maxY, pt.y);
            };
            return parsePathDataAndGenerateDrawFunc;
        }());
        internal.parsePathDataAndGenerateDrawFunc = parsePathDataAndGenerateDrawFunc;
    })(internal = vp.internal || (vp.internal = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// colors.ts.  Copyright (c) 2016 Microsoft Corporation.
///             part of the vuePlot library - color helper and related functions.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var color;
    (function (color) {
        color.colors = {};
        color.colors.aliceblue = [240, 248, 255];
        color.colors.antiquewhite = [250, 235, 215];
        color.colors.aqua = [0, 255, 255];
        color.colors.aquamarine = [127, 255, 212];
        color.colors.azure = [240, 255, 255];
        color.colors.beige = [245, 245, 220];
        color.colors.bisque = [255, 228, 196];
        color.colors.black = [0, 0, 0];
        color.colors.blanchedalmond = [255, 235, 205];
        color.colors.blue = [0, 0, 255];
        color.colors.blueviolet = [138, 43, 226];
        color.colors.brown = [165, 42, 42];
        color.colors.burlywood = [222, 184, 135];
        color.colors.cadetblue = [95, 158, 160];
        color.colors.chartreuse = [127, 255, 0];
        color.colors.chocolate = [210, 105, 30];
        color.colors.coral = [255, 127, 80];
        color.colors.cornflowerblue = [100, 149, 237];
        color.colors.cornsilk = [255, 248, 220];
        color.colors.crimson = [220, 20, 60];
        color.colors.cyan = [0, 255, 255];
        color.colors.darkblue = [0, 0, 139];
        color.colors.darkcyan = [0, 139, 139];
        color.colors.darkgoldenrod = [184, 134, 11];
        color.colors.darkgray = [169, 169, 169];
        color.colors.darkgreen = [0, 100, 0];
        color.colors.darkkhaki = [189, 183, 107];
        color.colors.darkmagenta = [139, 0, 139];
        color.colors.darkolivegreen = [85, 107, 47];
        color.colors.darkorange = [255, 140, 0];
        color.colors.darkorchid = [153, 50, 204];
        color.colors.darkred = [139, 0, 0];
        color.colors.darksalmon = [233, 150, 122];
        color.colors.darkseagreen = [143, 188, 143];
        color.colors.darkslateblue = [72, 61, 139];
        color.colors.darkslategray = [47, 79, 79];
        color.colors.darkturquoise = [0, 206, 209];
        color.colors.darkviolet = [148, 0, 211];
        color.colors.deeppink = [255, 20, 147];
        color.colors.deepskyblue = [0, 191, 255];
        color.colors.dimgray = [105, 105, 105];
        color.colors.dodgerblue = [30, 144, 255];
        color.colors.firebrick = [178, 34, 34];
        color.colors.floralwhite = [255, 250, 240];
        color.colors.forestgreen = [34, 139, 34];
        color.colors.fuchsia = [255, 0, 255];
        color.colors.gainsboro = [220, 220, 220];
        color.colors.ghostwhite = [248, 248, 255];
        color.colors.gold = [255, 215, 0];
        color.colors.goldenrod = [218, 165, 32];
        color.colors.gray = [128, 128, 128];
        color.colors.green = [0, 128, 0];
        color.colors.greenyellow = [173, 255, 47];
        color.colors.honeydew = [240, 255, 240];
        color.colors.hotpink = [255, 105, 180];
        color.colors.indianred = [205, 92, 92];
        color.colors.indigo = [75, 0, 130];
        color.colors.ivory = [255, 255, 240];
        color.colors.khaki = [240, 230, 140];
        color.colors.lavender = [230, 230, 250];
        color.colors.lavenderblush = [255, 240, 245];
        color.colors.lawngreen = [124, 252, 0];
        color.colors.lemonchiffon = [255, 250, 205];
        color.colors.lightblue = [173, 216, 230];
        color.colors.lightcoral = [240, 128, 128];
        color.colors.lightcyan = [224, 255, 255];
        color.colors.lightgoldenrodyellow = [250, 250, 210];
        color.colors.lightgray = [211, 211, 211];
        color.colors.lightgreen = [144, 238, 144];
        color.colors.lightpink = [255, 182, 193];
        color.colors.lightsalmon = [255, 160, 122];
        color.colors.lightseagreen = [32, 178, 170];
        color.colors.lightskyblue = [135, 206, 250];
        color.colors.lightslategray = [119, 136, 153];
        color.colors.lightsteelblue = [176, 196, 222];
        color.colors.lightyellow = [255, 255, 224];
        color.colors.lime = [0, 255, 0];
        color.colors.limegreen = [50, 205, 50];
        color.colors.linen = [250, 240, 230];
        color.colors.magenta = [255, 0, 255];
        color.colors.maroon = [128, 0, 0];
        color.colors.mediumaquamarine = [102, 205, 170];
        color.colors.mediumblue = [0, 0, 205];
        color.colors.mediumorchid = [186, 85, 211];
        color.colors.mediumpurple = [147, 112, 219];
        color.colors.mediumseagreen = [60, 179, 113];
        color.colors.mediumslateblue = [123, 104, 238];
        color.colors.mediumspringgreen = [0, 250, 154];
        color.colors.mediumturquoise = [72, 209, 204];
        color.colors.mediumvioletred = [199, 21, 133];
        color.colors.midnightblue = [25, 25, 112];
        color.colors.mintcream = [245, 255, 250];
        color.colors.mistyrose = [255, 228, 225];
        color.colors.moccasin = [255, 228, 181];
        color.colors.navajowhite = [255, 222, 173];
        color.colors.navy = [0, 0, 128];
        color.colors.oldlace = [253, 245, 230];
        color.colors.olive = [128, 128, 0];
        color.colors.olivedrab = [107, 142, 35];
        color.colors.orange = [255, 165, 0];
        color.colors.orangered = [255, 69, 0];
        color.colors.orchid = [218, 112, 214];
        color.colors.palegoldenrod = [238, 232, 170];
        color.colors.palegreen = [152, 251, 152];
        color.colors.paleturquoise = [175, 238, 238];
        color.colors.palevioletred = [219, 112, 147];
        color.colors.papayawhip = [255, 239, 213];
        color.colors.peachpuff = [255, 218, 185];
        color.colors.peru = [205, 133, 63];
        color.colors.pink = [255, 192, 203];
        color.colors.plum = [221, 160, 221];
        color.colors.powderblue = [176, 224, 230];
        color.colors.purple = [128, 0, 128];
        color.colors.red = [255, 0, 0];
        color.colors.rosybrown = [188, 143, 143];
        color.colors.royalblue = [65, 105, 225];
        color.colors.saddlebrown = [139, 69, 19];
        color.colors.salmon = [250, 128, 114];
        color.colors.sandybrown = [244, 164, 96];
        color.colors.seagreen = [46, 139, 87];
        color.colors.seashell = [255, 245, 238];
        color.colors.sienna = [160, 82, 45];
        color.colors.silver = [192, 192, 192];
        color.colors.skyblue = [135, 206, 235];
        color.colors.slateblue = [106, 90, 205];
        color.colors.slategray = [112, 128, 144];
        color.colors.snow = [255, 250, 250];
        color.colors.springgreen = [0, 255, 127];
        color.colors.steelblue = [70, 130, 180];
        color.colors.tan = [210, 180, 140];
        color.colors.teal = [0, 128, 128];
        color.colors.thistle = [216, 191, 216];
        color.colors.tomato = [255, 99, 71];
        color.colors.transparent = [255, 255, 255];
        color.colors.turquoise = [64, 224, 208];
        color.colors.violet = [238, 130, 238];
        color.colors.wheat = [245, 222, 179];
        color.colors.white = [255, 255, 255];
        color.colors.whitesmoke = [245, 245, 245];
        color.colors.yellow = [255, 255, 0];
        color.colors.yellowgreen = [154, 205, 50];
        ///--------------------------------------------------------
        /// parse 1 of 147 predefined SVG color names
        /// and return its value as a 3 element number array.
        ///--------------------------------------------------------
        function getColorFromName(name) {
            var value = color.colors[name.toLowerCase()];
            if (vp.utils.isUndefined(value)) {
            }
            return value;
        }
        color.getColorFromName = getColorFromName;
        function getRandomColor() {
            var keys = vp.utils.keys(color.colors);
            var index = Math.round(Math.random() * keys.length - 1);
            var colorName = keys[index];
            return color.colors[colorName];
        }
        color.getRandomColor = getRandomColor;
        ///--------------------------------------------------------
        /// parse 3 or 6 char hex string without leading "#"
        /// and return its value as a 3 element number array.
        ///--------------------------------------------------------
        function getColorFromHexString(str) {
            var value = color.colors.black;
            if (str.length == 3) {
                var redStr = str[0] + str[0];
                var r = parseInt(redStr, 16);
                var greenStr = str[1] + str[1];
                var g = parseInt(greenStr, 16);
                var blueStr = str[2] + str[2];
                var b = parseInt(blueStr, 16);
                value = [r, g, b];
            }
            else if (str.length == 6) {
                var redStr = str[0] + str[1];
                var r = parseInt(redStr, 16);
                var greenStr = str[2] + str[3];
                var g = parseInt(greenStr, 16);
                var blueStr = str[4] + str[5];
                var b = parseInt(blueStr, 16);
                value = [r, g, b];
            }
            return value;
        }
        color.getColorFromHexString = getColorFromHexString;
        function parseRGBPart(part) {
            var value = 0;
            part = part.trim();
            if (part.endsWith("%")) {
                //---- remove the "%" ----
                part = part.substring(0, part.length - 1).trim();
                var percent = parseFloat(part);
                value = Math.max(0, Math.min(255, Math.round(255 * percent)));
            }
            else {
                value = parseInt(part);
            }
            return value;
        }
        ///--------------------------------------------------------
        /// parse a comma separate rgb string (should be: xx, xx, xx)
        /// and return its value as a 3 element number array.  Each "xx"
        /// is either an integer number or a float followed by a "%" char.
        ///--------------------------------------------------------
        function getColorFromRgbString(str) {
            var value = color.colors.black;
            var parts = str.split(',');
            if (parts.length == 3) {
                var r = parseRGBPart(parts[0]);
                var g = parseRGBPart(parts[1]);
                var b = parseRGBPart(parts[2]);
                value = [r, g, b];
            }
            else if (parts.length == 4) {
                var r = parseRGBPart(parts[0]);
                var g = parseRGBPart(parts[1]);
                var b = parseRGBPart(parts[2]);
                var a = parseRGBPart(parts[3]);
                value = [r, g, b]; // for now, don't return the "a"
            }
            return value;
        }
        color.getColorFromRgbString = getColorFromRgbString;
        /// converts an array of 3 RGB numbers (0-255) into a valid HTML/SVG color string.
        function toColor(r, g, b, a) {
            var str = null;
            if (vp.utils.isString(r)) {
                str = r; // already a color string
            }
            else {
                if (arguments.length == 1) {
                    var aray = r;
                    r = aray[0];
                    g = aray[1];
                    b = aray[2];
                    if (aray.length > 3) {
                        a = aray[3];
                    }
                }
                var red = vp.data.clamp(Math.round(r), 0, 255);
                var green = vp.data.clamp(Math.round(g), 0, 255);
                var blue = vp.data.clamp(Math.round(b), 0, 255);
                //if (true)       // for now, always use just 3 colors   // a === undefined)
                if (a === undefined) {
                    //---- caution: SVG (at least in IE9) does NOT accept spaces betweeen commas ----
                    str = ("rgb(" + red + "," + green + "," + blue + ")");
                }
                else {
                    var alpha = vp.data.clamp(Math.round(a), 0, 255);
                    str = ("rgba(" + red + "," + green + "," + blue + "," + alpha + ")");
                }
            }
            return str;
        }
        color.toColor = toColor;
        function getColorFromString(str) {
            var value = str;
            if (vp.utils.isString(str)) {
                str = str.trim();
                if (str.startsWith("#")) {
                    value = getColorFromHexString(str.substring(1));
                }
                else if (str.startsWith("rgb(")) {
                    value = getColorFromRgbString(str.substring(4, str.length - 1));
                }
                else if (str.startsWith("rgba(")) {
                    value = getColorFromRgbString(str.substring(5, str.length - 1));
                }
                else {
                    value = getColorFromName(str);
                }
            }
            return value;
        }
        color.getColorFromString = getColorFromString;
        /// public: interpolateColors(color1, color2, percent)
        /// interpolate between color1 and color2, using "percent".  
        /// returns the interpolated value.
        function interpolateColors(color1, color2, percent) {
            if (!vp.utils.isArray(color1)) {
                color1 = getColorFromString(color1);
            }
            if (!vp.utils.isArray(color2)) {
                color2 = getColorFromString(color2);
            }
            var value = [];
            for (var i = 0; i < 3; i++) {
                var min = color1[i];
                var max = color2[i];
                value[i] = min + percent * (max - min);
            }
            return value;
        }
        color.interpolateColors = interpolateColors;
        function isValidColor(value) {
            var isValid = false;
            if (vp.utils.isNumber(value)) {
                isValid = true;
            }
            else if (vp.utils.isString(value)) {
                var parts = getColorFromString(value);
                isValid = (parts !== undefined);
            }
            return isValid;
        }
        color.isValidColor = isValidColor;
        /** extract an HTML legal color value from a palette.  Does NOT do blending between entries. */
        function colorFromPalette(palette, index, firstPaletteIndex, isCycling) {
            //---- when a filter is active and we draw all shapes with a subset scale, ----
            //---- it is common for the index to be invalid.  so, we fix it up here ----
            if (firstPaletteIndex === void 0) { firstPaletteIndex = 0; }
            if (isCycling) {
                if (index < firstPaletteIndex) {
                    index = firstPaletteIndex;
                }
                else {
                    //---- wrap around available palette ----
                    index = index % (palette.length - 1);
                }
                index = Math.floor(vp.data.clamp(index, firstPaletteIndex, palette.length - 1));
            }
            else {
                //---- new policy is that an "other" palette at the end catches all "too big" entries ----
                index = Math.floor(vp.data.clamp(index, firstPaletteIndex, palette.length - 1));
            }
            var cr = palette[index];
            if (!vp.utils.isString(cr)) {
                cr = toColor(cr);
            }
            return cr;
        }
        color.colorFromPalette = colorFromPalette;
        /** extract an HTML legal color value from a palette by blending the 2 closest enties as per non-integer index. */
        function continuousColorFromPalette(palette, index) {
            //---- when a filter is active and we draw all shapes with a subset scale, ----
            //---- it is common for the index to be invalid.  so, we fix it up here ----
            index = (Math.abs(index) % palette.length); // recycle entires to fulfill request
            var cr;
            if ((index < palette.length - 1) && (index != Math.floor(index))) {
                //---- interpolate between two entries ----
                var fract = index - Math.floor(index);
                var floorIndex = Math.floor(index);
                cr = colorLerp(palette[floorIndex], palette[floorIndex + 1], fract);
            }
            else {
                cr = palette[Math.floor(index)];
            }
            if (!vp.utils.isString(cr)) {
                cr = toColor(cr);
            }
            return cr;
        }
        color.continuousColorFromPalette = continuousColorFromPalette;
        /** does a LERP (mixture) of 2 colors, both of which are 3-dim RGB arrays.  Returns result as a 3-dim RGB array.*/
        function colorLerp(color1, color2, percent) {
            var value = [];
            for (var i = 0; i < 3; i++) {
                var min = color1[i];
                var max = color2[i];
                value[i] = min + percent * (max - min);
            }
            return value;
        }
        color.colorLerp = colorLerp;
        /** converts an RGB color array (values 0-255) to an WebGL-compatible percentage array (values 0-1). */
        function makeColorArrayForWebGL(crArray) {
            var newArray = [crArray[0] / 255, crArray[1] / 255, crArray[2] / 255, 1];
            return newArray;
        }
        color.makeColorArrayForWebGL = makeColorArrayForWebGL;
    })(color = vp.color || (vp.color = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// event.ts.  Copyright (c) 2016 Microsoft Corporation.
///            part of the vuePlot library - keyboard, mouse, and touch related event handling.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var events;
    (function (events) {
        events.eventAttachCount = 0;
        events.eventDetachCount = 0;
        //export var eventFireCount = 0;
        //---- keyCodes (for keyboard test, see: http://unixpapa.com/js/testkey.html) ----
        events.keyCodes = {
            //enter: "Enter", shift: 16, ctrl: 17, alt: 18, escape: "Esc", left: 37, up: 38, right: 39, down: 40,
            enter: 13, shift: 16, ctrl: 17, alt: 18, escape: 27, left: 37, up: 38, right: 39, down: 40,
            insert: 45, home: 36, pageUp: 33, "delete": 46, end: 35, pageDown: 34, space: 32,
            A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80,
            Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, minus: 189,
            f12: 123,
        };
        var _isDragDropEnabled = true;
        events.keyboardKeys = {};
        /// cross-browser support for cancelling an event.
        function cancelEventDefault(evt) {
            if (evt.preventDefault) {
                evt.preventDefault();
            }
            else {
                return false;
            }
        }
        events.cancelEventDefault = cancelEventDefault;
        function cancelEventBubble(evt) {
            evt.stopPropagation();
        }
        events.cancelEventBubble = cancelEventBubble;
        function monitorKeyboard(enable) {
            if (enable) {
                attach(window, "keydown", onKeyDown);
                attach(window, "keyup", onKeyUp);
            }
            else {
                detach(window, "keydown", onKeyDown);
                detach(window, "keyup", onKeyUp);
            }
        }
        events.monitorKeyboard = monitorKeyboard;
        function isKeyPressed(keyCode) {
            return (events.keyboardKeys[keyCode] == "down");
        }
        events.isKeyPressed = isKeyPressed;
        /// used by vp.monitorKeyboard.
        function onKeyDown(evt) {
            events.keyboardKeys[evt.keyCode] = "down";
            //vp.utils.debug("keydown: " + evt.keyCode);
        }
        /// used by vp.monitorKeyboard.
        function onKeyUp(evt) {
            events.keyboardKeys[evt.keyCode] = "up";
            //vp.utils.debug("keyup: " + evt.keyCode);
        }
        /// returns the current mouse positon from the event object "e".  This value is in logical window space,
        /// which includes scroll offsets.
        function mousePosition(e, relToParent) {
            //    var isIe = (document.all);
            //    var xPos = (isIe) ? window.event.clientX + document.documentElement.scrollLeft : e.pageX;
            //    var yPos = (isIe) ? window.event.clientY + document.documentElement.scrollTop : e.pageY;
            var x = e.pageX;
            var y = e.pageY;
            // Handle a non-IE 'touch' event
            if (e.type.startsWith('touch') && (e.changedTouches != undefined) && (e.changedTouches.length > 0)) {
                x = e.changedTouches[0].pageX;
                y = e.changedTouches[0].pageY;
            }
            if (relToParent) {
                var off = vp.dom.docOffset(relToParent);
                x -= off.left;
                y -= off.top;
            }
            return { x: +x, y: +y };
        }
        events.mousePosition = mousePosition;
        var mouseMoveCallback = null;
        var mouseUpCallback = null;
        var iframeNames = null;
        /** capture all MouseMove and MouseUp messages, even those that happen outside of the browser window. This
         works on all major browsers. */
        function setCaptureWindow(moveCallback, upCallback, frameNames) {
            vp.utils.debug("setCaptureWindow: start...");
            if (mouseMoveCallback) {
                var msg = "Error: setCaptureWindow is already active (call 'vp.events.releaseCaptureWindow' to clear)";
                //---- not sure why this is happening sometimes ----
                //throw msg;
                vp.utils.debug(msg);
                releaseCaptureWindow();
            }
            vp.events.attach(window, "mousemove", moveCallback);
            vp.events.attach(window, "mouseup", upCallback);
            mouseMoveCallback = moveCallback;
            mouseUpCallback = upCallback;
            iframeNames = frameNames;
            //---- turn off mouse events for iframes ----
            if (frameNames) {
                for (var i = 0; i < frameNames.length; i++) {
                    var name = frameNames[i];
                    vp.select("#" + name)
                        .css("pointer-events", "none");
                }
            }
            vp.utils.debug("setCaptureWindow: capture set.");
        }
        events.setCaptureWindow = setCaptureWindow;
        function releaseCaptureWindow() {
            if (mouseMoveCallback) {
                vp.events.detach(window, "mousemove", mouseMoveCallback);
                vp.events.detach(window, "mouseup", mouseUpCallback);
                mouseMoveCallback = null;
                mouseUpCallback = null;
            }
            //---- re-enabled mouse events for iframes ----
            var iframeNames = iframeNames;
            if (iframeNames) {
                for (var i = 0; i < iframeNames.length; i++) {
                    var name = iframeNames[i];
                    vp.select("#" + name)
                        .css("pointer-events", "");
                }
                iframeNames = null;
            }
            vp.utils.debug("releaseCaptureWindow: capture released.");
        }
        events.releaseCaptureWindow = releaseCaptureWindow;
        var mouseMoveWrapper = function (e) {
            //---- set by SetCapture ----
        };
        var mouseUpWrapper = function (e) {
            //---- set by SetCapture ----
        };
        /// captures the mouse for mouse events on "element".  if "setCapture" is not supported by
        /// the browser, it tries to simulate it.  The "mouseMoveCallback" and "mouseUpCallback", if supplied, 
        /// are attached to the best element for the situation.
        ///
        /// tested on roland's home machine - 8/5/2012.  seems to work perfectly now on IE9, Chrome, Firefox!
        ///   - no blue selection as we drag
        ///   - no system drag/drop interference
        ///   - cursor stays as specified during drag
        ///   - on releaseCapture(), all is restored to normal.
        function setCapture(element, evt, mouseMoveCallback, mouseUpCallback) {
            var useCapture = (element.setCapture);
            mouseMoveWrapper = function (e) {
                e.vp_element = element;
                mouseMoveCallback(e);
            };
            mouseUpWrapper = function (e) {
                e.vp_element = element;
                mouseUpCallback(e);
            };
            if (useCapture) {
                //---- listen to events on the ELEMENT ----
                if (mouseMoveCallback) {
                    attach(element, "mousemove", mouseMoveWrapper);
                }
                if (mouseUpCallback) {
                    attach(element, "mouseup", mouseUpWrapper);
                }
                //---- prevent text selection by browser during our drag operation (for FireFox) ----
                vp.dom.enableElementSelection(document.body, false);
                element.setCapture();
                element._turnedOffDrawDrop = null;
            }
            else {
                //---- listen to events on the DOCUMENT ----
                if (mouseMoveCallback) {
                    attach(document, "mousemove", mouseMoveWrapper);
                }
                if (mouseUpCallback) {
                    attach(document, "mouseup", mouseUpWrapper);
                }
                //---- prevent text selection by browser during our drag operation (for Chrome) ----
                vp.dom.enableElementSelection(document.body, false);
                element._turnedOffDrawDrop = enableDragDrop(false);
                var cursorState = vp.dom.css(element, "cursor");
                if (cursorState) {
                    //---- create a style sheet that keeps cursor constant during capture ----
                    var sheet = new vp.dom.styleSheetClass()
                        .addRule("*", "cursor: " + cursorState)
                        .id("vp_setCapture_ss");
                }
            }
            if (evt) {
                evt.preventDefault(); // don't allow selection to select text, etc. during our capture
                evt.stopPropagation();
                evt.cancelBubble = true;
            }
            return useCapture;
        }
        events.setCapture = setCapture;
        function setFocus(elem) {
            while ((elem) && (!elem.focus)) {
                elem = vp.dom.parent(elem);
            }
            if (elem.focus) {
                elem.focus();
            }
        }
        events.setFocus = setFocus;
        /// captures the mouse for mouse events on "element".
        function releaseCapture(element, evt, mouseMoveCallback, mouseUpCallback) {
            var callRelease = (element.releaseCapture);
            if (callRelease) {
                element.releaseCapture();
                //---- clear events on the ELEMENT ----
                if (mouseMoveWrapper) {
                    detach(element, "mousemove", mouseMoveWrapper);
                    mouseMoveWrapper = null;
                }
                if (mouseUpWrapper) {
                    detach(element, "mouseup", mouseUpWrapper);
                    mouseUpWrapper = null;
                }
                //---- re-enable text selection by browser (for FireFox) ----
                vp.dom.enableElementSelection(document.body, true);
            }
            else {
                //---- clear events on the DOCUMENT ----
                if (mouseMoveWrapper) {
                    detach(document, "mousemove", mouseMoveWrapper);
                    mouseMoveWrapper = null;
                }
                if (mouseUpWrapper) {
                    detach(document, "mouseup", mouseUpWrapper);
                    mouseUpWrapper = null;
                }
                //---- re-enable text selection by browser (for Chrome) ----
                vp.dom.enableElementSelection(document.body, true);
                if (element._turnedOffDrawDrop) {
                    enableDragDrop(true);
                }
                //---- remove the stylesheet, if we created it ----
                var elem = document.getElementById("vp_setCapture_ss");
                if (elem) {
                    vp.dom.remove(elem);
                }
            }
            return callRelease;
        }
        events.releaseCapture = releaseCapture;
        function stopDragDrop(evt) {
            evt.dataTransfer.dropEffect = 'none';
            evt.stopPropagation();
            evt.preventDefault();
        }
        function enableDragDrop(isEnabled) {
            if (_isDragDropEnabled != isEnabled) {
                var body = vp.select(document.body);
                body.attach("dragstart", function (e) {
                    return _isDragDropEnabled = true;
                });
                body.attr("draggable", isEnabled);
                if (isEnabled) {
                    body.detach("dragenter", stopDragDrop);
                    body.detach("ondragover", stopDragDrop);
                    body.detach("ondrop", stopDragDrop);
                }
                else {
                    body.attach("dragenter", stopDragDrop);
                    body.attach("ondragover", stopDragDrop);
                    body.attach("ondrop", stopDragDrop);
                }
                _isDragDropEnabled = isEnabled;
            }
        }
        events.enableDragDrop = enableDragDrop;
        function attach(elem, eventName, funcToCall, useCapturePhase) {
            events.eventAttachCount++;
            if ((eventName == "mousewheel") && (vp.utils.isFireFox)) {
                eventName = "DOMMouseScroll";
            }
            if ((eventName == "resize") && (elem != window)) {
                ////---- add support for resize events on non-window elements ----
                //if (!elem.resizeEvent)
                //{
                //    if (elem.tagName == "circle")
                //    {
                //        elem.resizeEvent = { prevWidth: vp.dom.width(elem), prevRadius: vp.dom.attr(elem, "radius"), callBacks: [] };
                //    }
                //    else
                //    {
                //        elem.resizeEvent = { prevWidth: vp.dom.width(elem), prevHeight: vp.dom.height(elem), callBacks: [] };
                //    }
                //}
                //elem.resizeEvent.callBacks.push(funcToCall);
                throw "bp.dom.attach: resize event no longer supported for non-window elements";
            }
            else {
                if ((elem.control) && (elem.control.addEventListener)) {
                    //---- let the control handle the event management ----
                    elem.control.addEventListener(eventName, funcToCall);
                }
                else if (elem.addEventListener) {
                    elem.addEventListener(eventName, funcToCall, useCapturePhase);
                }
                else if (elem.attachEvent) {
                    elem.attachEvent(eventName, funcToCall);
                }
                else {
                    throw "Cannot attach to non-DOM element: " + elem;
                }
                //---- track active event handlers for easy removal later ----
                if (!elem._eventHandlers) {
                    elem._eventHandlers = [];
                }
                var tracker = new EventTracker(eventName, funcToCall, useCapturePhase);
                elem._eventHandlers.push(tracker);
            }
        }
        events.attach = attach;
        var EventTracker = (function () {
            function EventTracker(eventName, callback, useCapturePhase) {
                this.eventName = eventName;
                this.callback = callback;
                this.useCapturePhase = useCapturePhase;
            }
            return EventTracker;
        }());
        events.EventTracker = EventTracker;
        /// trigger the vuePlot "resize" event on the specified elem.
        function triggerResize(elem) {
            //---- has someone hooked the "resize" event on this elem? ----
            if (!elem.resizeEvent) {
                //---- try his kids ----
                var kids = vp.dom.children(elem);
                for (var i = 0; i < kids.length; i++) {
                    triggerResize(kids[i]);
                }
            }
            else {
                var resizeEvent = elem.resizeEvent;
                //---- see if at least one of size properties has really changed ----
                var changed = false;
                if (elem.tagName == "circle") {
                    var radius = elem.attr("radius");
                    changed = (radius != resizeEvent.prevRadius);
                    if (changed) {
                        resizeEvent.prevRadius = radius;
                    }
                }
                else {
                    var width = vp.dom.width(elem);
                    var changeWidth = (width != resizeEvent.prevWidth);
                    if (changeWidth) {
                        resizeEvent.prevWidth = width;
                    }
                    var height = vp.dom.height(elem);
                    var changeHeight = (height != resizeEvent.prevHeight);
                    if (changeHeight) {
                        resizeEvent.prevHeight = height;
                    }
                    changed = (changeWidth || changeHeight);
                }
                if (changed) {
                    var callBacks = resizeEvent.callBacks;
                    for (var i = 0; i < callBacks.length; i++) {
                        var callBack = callBacks[i];
                        var e = { target: elem, type: "resize", currentTarget: elem, cancelable: false, bubbles: false };
                        callBack(e);
                    }
                }
            }
        }
        events.triggerResize = triggerResize;
        /// window was resized; trigger the "resize" event on the element and all its children
        function triggerResizeRecursive(elem) {
            if (elem.resizeEvent) {
                triggerResize(elem);
            }
            var kids = vp.dom.children(elem);
            if ((kids) && (kids.length > 0)) {
                for (var i = 0; i < kids.length; i++) {
                    triggerResizeRecursive(kids[i]);
                }
            }
        }
        function wheelDelta(evt) {
            return (evt.detail) ? -40 * evt.detail : evt.wheelDelta;
        }
        events.wheelDelta = wheelDelta;
        function detach(elem, eventName, funcToCall, useCapture) {
            events.eventDetachCount++;
            if ((eventName == "mousewheel") && (vp.utils.isFireFox)) {
                eventName = "DOMMouseScroll";
            }
            //---- remove from our handlers list ----
            if (elem._eventHandlers) {
                if (eventName && funcToCall) {
                    //---- remove single matching tracker ----
                    detachCore(elem, eventName, funcToCall, useCapture);
                    for (var i = 0; i < elem._eventHandlers.length; i++) {
                        var tracker = elem._eventHandlers[i];
                        if (tracker.eventName == eventName && tracker.callback == funcToCall && tracker.useCapturePhase == useCapture) {
                            elem._eventHandlers.splice(i, 1); // removeAt(i);
                            break;
                        }
                    }
                }
                else if (eventName) {
                    //---- remove all trackers for specified eventName ----
                    for (var i = elem._eventHandlers.length - 1; i >= 0; i--) {
                        var tracker = elem._eventHandlers[i];
                        if (tracker.eventName == eventName) {
                            detachCore(elem, eventName, tracker.callback, tracker.useCapturePhase);
                            elem._eventHandlers.splice(i, 1); // .removeAt(i);
                        }
                    }
                }
                else {
                    //---- remove all trackers ----
                    for (var i = elem._eventHandlers.length - 1; i >= 0; i--) {
                        var tracker = elem._eventHandlers[i];
                        detachCore(elem, tracker.eventName, tracker.callback, tracker.useCapturePhase);
                        elem._eventHandlers.splice(i, 1); //.removeAt(i);
                    }
                }
            }
        }
        events.detach = detach;
        function detachCore(elem, eventName, funcToCall, useCapture) {
            if ((elem.control) && (elem.control.removeEventListener)) {
                //---- let the control handle the event management ----
                elem.control.removeEventListener(eventName, funcToCall);
            }
            else if (elem.removeEventListener) {
                elem.removeEventListener(eventName, funcToCall);
            }
            else if (elem.detachEvent) {
                elem.detachEvent(eventName, funcToCall);
            }
        }
        /// returns the HTML, SVG, or lightweight cavnas element at the specified x,y
        /// (pixels from document origin).
        function elementFromPoint(x, y) {
            //---- first, get the HTML or SVG element from the DOM ----
            var elem = document.elementFromPoint(x, y);
            if (elem != null) {
                //---- now, see if there is a canvas element at that location ----
                if (elem.canvasContainerElement) {
                    //---- make x, y relative to canvas ----
                    var off = vp.dom.docOffset(elem);
                    x -= off.left;
                    y -= off.top;
                    elem = elem.canvasContainerElement.getCanvasElementAtPoint(x, y);
                }
            }
            return elem;
        }
        events.elementFromPoint = elementFromPoint;
        //---- local init code (try/catch is so it can be processed from a web worker thread ----
        try {
            attach(window, "resize", function (e) {
                triggerResizeRecursive(document.body);
            });
        }
        catch (ex) {
        }
    })(events = vp.events || (vp.events = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// inkHitTest.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - part of the vuePlotCore library 
///     - does ink based hit testing of a shape and rectangle, using a temp. canvas
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var internal;
    (function (internal) {
        var inkHitTest = (function () {
            function inkHitTest(rect) {
                //---- private state ----
                this.tempCanvas = null;
                this.root = null;
                this.ctx = null;
                this.rect = rect;
                this.w = rect.width;
                this.h = rect.height;
                //---- create a temp. canvas object to render to ----
                this.tempCanvas = vp.select(document.body).append("canvas")
                    .id("$_tempCanvas")
                    .attr("width", this.w + "")
                    .attr("height", this.h + "");
                this.root = vp.canvas.selectContext("#$_tempCanvas", "2d");
                this.ctx = this.root[0].ctx;
            }
            inkHitTest.prototype.transferAttrs = function (fromElem, toElem, attrNameList) {
                //---- unwrap toElem ----
                toElem = (toElem.length) ? toElem[0] : toElem;
                for (var i = 0; i < attrNameList.length; i++) {
                    var name = attrNameList[i];
                    var value = (name == "text") ? vp.dom.text(fromElem) : vp.dom.attr(fromElem, name);
                    if (value !== undefined) {
                        vp.dom.attr(toElem, name, value);
                    }
                }
            };
            inkHitTest.prototype.canvasElemFromSvg = function (canvasRoot, svgElem) {
                //---- add svgElem to canvasRoot ----
                var canvasElem = null;
                if (svgElem.tagName == "g") {
                    canvasElem = canvasRoot.append("g");
                    this.transferAttrs(svgElem, canvasElem, []);
                }
                else if (svgElem.tagName == "rect") {
                    canvasElem = canvasRoot.append("rect");
                    this.transferAttrs(svgElem, canvasElem, ["x", "y", "width", "height"]);
                }
                else if (svgElem.tagName == "line") {
                    canvasElem = canvasRoot.append("line");
                    this.transferAttrs(svgElem, canvasElem, ["x1", "y1", "x2", "y2"]);
                }
                else if (svgElem.tagName == "circle") {
                    canvasElem = canvasRoot.append("circle");
                    this.transferAttrs(svgElem, canvasElem, ["cx", "cy", "r"]);
                }
                else if (svgElem.tagName == "ellipse") {
                    canvasElem = canvasRoot.append("ellipse");
                    this.transferAttrs(svgElem, canvasElem, ["cx", "cy", "rx", "ry"]);
                }
                else if (svgElem.tagName == "path") {
                    canvasElem = canvasRoot.append("path");
                    this.transferAttrs(svgElem, canvasElem, ["d"]);
                }
                else if (svgElem.tagName == "polyline") {
                    canvasElem = canvasRoot.append("polyline");
                    this.transferAttrs(svgElem, canvasElem, ["points"]);
                }
                else if (svgElem.tagName == "polygon") {
                    canvasElem = canvasRoot.append("polygon");
                    this.transferAttrs(svgElem, canvasElem, ["points"]);
                }
                else if (svgElem.tagName == "text") {
                    canvasElem = canvasRoot.append("text");
                    this.transferAttrs(svgElem, canvasElem, ["x", "y", "text", "dx", "dy", "font-size", "font-width", "font-weight",
                        "font-style", "font-family"]);
                }
                else {
                }
                if (canvasElem) {
                    //---- transfer common attributes -----
                    this.transferAttrs(svgElem, canvasElem, ["transform", "fill", "stroke", "stroke-width"]);
                    //---- unwrap canvasElem ----
                    canvasElem = (canvasElem.length) ? canvasElem[0] : canvasElem;
                    //---- don't interfere with our high-level transform ----
                    canvasElem.transform = null;
                }
                else {
                    canvasElem = vp.select(""); // empty wrapper
                }
                return canvasElem;
            };
            inkHitTest.prototype.addCanvasChild = function (canvasParent, svgElem) {
                if (svgElem.tagName) {
                    canvasParent = this.canvasElemFromSvg(canvasParent, svgElem);
                    //---- now add children of svgElem ----
                    var kids = vp.dom.children(svgElem);
                    if (kids.length > 0) {
                        var wcp = vp.dom.wrapElements(canvasParent);
                        for (var i = 0; i < kids.length; i++) {
                            this.addCanvasChild(wcp, kids[i]);
                        }
                    }
                }
            };
            inkHitTest.prototype.close = function () {
                //---- remove temp canvas ----
                this.root[0].close(); // stop drawing
                this.tempCanvas.remove();
            };
            inkHitTest.prototype.doesShapeOverlap = function (svgShape) {
                var shapeWidth = vp.dom.width(svgShape);
                var shapeHeight = vp.dom.height(svgShape);
                this.root.clear(); // remove previous shapes
                this.addCanvasChild(this.root, svgShape);
                //---- clear the canvas ----
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.clearRect(0, 0, this.w, this.h);
                //---- set the transform so that only the rect area of the shape will be drawn on the canvas ----
                var x = -this.rect.left;
                var y = -this.rect.top;
                this.ctx.setTransform(1, 0, 0, 1, x, y);
                //---- draw the shape ----
                this.root[0].drawAll(this.ctx);
                //---- get the pixels in the canvas ----
                var imageData = this.ctx.getImageData(0, 0, this.w, this.h);
                var intersects = false;
                //---- now, walk each pixel and see if any ink is present ----
                var index = 0;
                for (var r = 0; r < this.h; r++) {
                    if (intersects) {
                        break;
                    }
                    for (var c = 0; c < this.w; c++) {
                        if (intersects) {
                            break;
                        }
                        for (var p = 0; p < 4; p++) {
                            if (imageData.data[index++]) {
                                intersects = true;
                                break;
                            }
                        }
                    }
                }
                return intersects;
            };
            return inkHitTest;
        }());
        internal.inkHitTest = inkHitTest;
    })(internal = vp.internal || (vp.internal = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// insertAppend.ts.  Copyright (c) 2016 Microsoft Corporation.
///                   part of the vuePlot library - handles inserting and appending content to containers.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var dom;
    (function (dom) {
        function createHtml(tagName) {
            var element = document.createElement(tagName);
            return element;
        }
        dom.createHtml = createHtml;
        function createSvg(tagName) {
            var nsSvg = "http://www.w3.org/2000/svg";
            var svgElem = document.createElementNS(nsSvg, tagName);
            return svgElem;
        }
        dom.createSvg = createSvg;
        /** createElement(parent, tagName) - creates an HTML, SVG, or CANVAS element with the specified tagName.
        returns: the newly created element (unwrapped). */
        function createElement(parent, tagName) {
            var element = null;
            var parentElem = (parent.element) ? parent.element() : parent;
            if ((tagName.toLowerCase() == "svg") || (vp.utils.isSvgDocOrElement(parentElem))) {
                //---- normal SVG container ----
                //---- NOTE: do NOT include STYLE properties on the SVG document - causing polyline elements to not render (04/01/2015 - rfernand). ----
                element = document.createElementNS('http://www.w3.org/2000/svg', tagName);
            }
            else {
                var tagNameLower = tagName.toLowerCase();
                var element = null;
                if (tagNameLower.startsWith("vp.")) {
                    var ctr = eval(tagName);
                    if (vp.utils.isFunction(ctr)) {
                        //---- create the vuePlot visual control ----
                        var obj = ctr.call();
                        if (vp.utils.isDefined(obj.tagName)) {
                            element = obj;
                        }
                        else {
                            element = obj.domElement;
                        }
                    }
                }
                else {
                    //---- regular HTML element ----
                    element = document.createElement(tagName);
                }
            }
            return element;
        }
        dom.createElement = createElement;
        /// this was created to help speed up our slow create and append routines by looping at the 
        /// lowest level possible.
        function createElements(parent, tagName, count) {
            var elements = [];
            var parentElem = (parent.element) ? parent.element() : parent;
            if ((tagName.toLowerCase() == "svg") || (vp.utils.isSvgDocOrElement(parentElem))) {
                //---- normal SVG container ----
                for (var i = 0; i < count; i++) {
                    var elem = document.createElementNS('http://www.w3.org/2000/svg', tagName);
                    elements[i] = elem;
                }
            }
            else {
                var tagNameLower = tagName.toLowerCase();
                var element = null;
                if (tagNameLower.startsWith("vp.")) {
                    var ctr = eval(tagName);
                    if (vp.utils.isFunction(ctr)) {
                        for (var i = 0; i < count; i++) {
                            //---- create the vuePlot visual control ----
                            var obj = ctr.call();
                            if (vp.utils.isDefined(obj.tagName)) {
                                element = obj;
                            }
                            else {
                                element = obj.domElement;
                            }
                            elements[i] = element;
                        }
                    }
                }
                else {
                    //---- regular HTML element ----
                    for (var i = 0; i < count; i++) {
                        element = document.createElement(tagName);
                        elements[i] = element;
                    }
                }
            }
            return elements;
        }
        dom.createElements = createElements;
        /// internal.
        function insertOrAppend(container, child, insertOp) {
            var returnValue = null;
            var addingToContainer = ((insertOp == "append") || (insertOp == "prepend"));
            if ((insertOp == "append") || ((addingToContainer) && (container.children.length == 0))) {
                returnValue = container.appendChild(child);
            }
            else if (insertOp == "prepend") {
                returnValue = container.insertBefore(child, container.children[0]);
            }
            else if (insertOp == "insertBefore") {
                var parent = container.parentNode;
                returnValue = parent.insertBefore(child, container);
            }
            else if (insertOp == "insertAfter") {
                var parent = container.parentNode;
                returnValue = parent.insertBefore(child, container.nextSibling);
            }
            return returnValue;
        }
        //---- INTERNAL: appends the content into the container, using the specified insertOp, and returns ----
        //---- an array of appended elements. ----
        function appendCoreSingle(container, content, insertOp) {
            var appendedElements = [];
            //---- look for all 3 "select set" types ----
            if (content instanceof vp.dom.selectedSet) {
                content = content.toArray();
            }
            else if (content.ctr == "vp.canvas.canvasSelectedSet") {
                content = content.toArray();
            }
            else if (content instanceof vp.dom.singleWrapperSuperClass) {
                //---- special handling since "content" is already wrapped ----
                var element = insertOrAppend(container, content.elem, insertOp);
                appendedElements = content; // already wrapped (don't rewrap)
            }
            //else if (content instanceof vp.marks.markBaseClass)
            //{
            //    var element = insertOrAppend(container, content._container, insertOp);
            //    appendedElements = content;      // already wrapped (don't rewrap)
            //}
            if (appendedElements.length == 0) {
                if (vp.utils.isArray(content)) {
                    for (var i = 0; i < content.length; i++) {
                        var child = content[i];
                        var element = insertOrAppend(container, child, insertOp);
                        appendedElements.push(element);
                    }
                }
                else if (vp.utils.isString(content)) {
                    var element = vp.dom.createElement(container, content);
                    if (element != null) {
                        //---- transfer data info from parent container ----
                        element.dataItem = container.dataItem;
                        element.dataIndex = container.dataIndex;
                        insertOrAppend(container, element, insertOp);
                        appendedElements.push(element);
                    }
                }
                else if (vp.utils.isFunction(content)) {
                    //---- call func to get content to append ----
                    var elemFromFunc = content(this);
                    var element = insertOrAppend(container, elemFromFunc, insertOp);
                    appendedElements.push(element);
                }
                else if (content != null) {
                    var element = insertOrAppend(container, content, insertOp);
                    appendedElements.push(element);
                }
            }
            return appendedElements;
        }
        //---- add specified content to container & return added elements as ARRAY ----
        //---- seems to be used only for HTML "select" element? ----
        //---- TODO: merge this with "vp.appendCoreSingle" (using a callBack functon to do the append/insert/add!) ----
        function add(container, content) {
            var addedElements = [];
            var element;
            //---- look for all 3 "select set" types ----
            if (content instanceof vp.dom.selectedSet) {
                content = content.toArray();
            }
            else if (content.ctr == "vp.canvas.canvasSelectedSet") {
                content = content.toArray();
            }
            else if (content instanceof vp.dom.singleWrapperSuperClass) {
                content = [content.elem];
            }
            if (vp.utils.isArray(content)) {
                for (var i = 0; i < content.length; i++) {
                    var child = content[i];
                    element = container.add(child);
                    addedElements.push(element);
                }
            }
            else if (vp.utils.isString(content)) {
                if (vp.utils.isSvgDocOrElement(container)) {
                    //---- normal SVG container ----
                    element = document.createElementNS('http://www.w3.org/2000/svg', content);
                    if (element != null) {
                        //---- transfer data info from parent container ----
                        element.dataItem = container.dataItem;
                        element.dataIndex = container.dataIndex;
                        container.add(element);
                        addedElements.push(element);
                    }
                }
                else {
                    //---- regular HTML element ----
                    element = document.createElement(content);
                    if (element != null) {
                        //---- transfer data info from parent container ----
                        element.dataItem = container.dataItem;
                        element.dataIndex = container.dataIndex;
                        container.add(element);
                        addedElements.push(element);
                    }
                }
            }
            else if (content != null) {
                container.add(content);
                addedElements.push(element);
            }
            return addedElements;
        }
        dom.add = add;
        //---- append into specified container and return elements in a wrapper ----
        function append(container, content) {
            var elements = null;
            if (container.tagName == "CANVAS") {
                if (!container.canvasContainerElement) {
                    //---- build a canvasContainerElement on the fly ----
                    container = vp.canvas.selectContext(container, "2d")[0];
                }
                else {
                    //---- switch from canvas element to our associated canvas container object ----
                    container = container.canvasContainerElement;
                }
            }
            //if (container.append)
            //{
            //    //---- its a canvasContainer or canvasGroup element ----
            //    elements = container.append(content);
            //}
            //else
            {
                elements = appendCoreSingle(container, content, "append");
            }
            if (!vp.utils.isSelectedSet(elements)) {
                elements = vp.dom.wrapElements(elements);
            }
            return elements;
        }
        dom.append = append;
        //---- append into specified container ----
        function appendElements(container, elements) {
            //if (container.append)      // canvas group 
            //{
            //    for (var i = 0; i < elements.length; i++)
            //    {
            //        container.append(elements[i]);
            //    }
            //}
            //else
            {
                for (var i = 0; i < elements.length; i++) {
                    container.appendChild(elements[i]);
                }
            }
        }
        dom.appendElements = appendElements;
        //---- prepend into specified container ----
        function prepend(container, content) {
            var elements = appendCoreSingle(container, content, "prepend");
            return vp.dom.wrapElements(elements);
        }
        dom.prepend = prepend;
        //---- insert content before specified container ----
        function insertBefore(container, content) {
            var elements = appendCoreSingle(container, content, "insertBefore");
            return vp.dom.wrapElements(elements);
        }
        dom.insertBefore = insertBefore;
        //---- insert content after specified container ----
        function insertAfter(container, content) {
            var elements = appendCoreSingle(container, content, "insertAfter");
            return vp.dom.wrapElements(elements);
        }
        dom.insertAfter = insertAfter;
        /// INTERNAL.
        function appendCoreMulti(self, content, insertOp) {
            var appendedElements = [];
            var firstContainer = true;
            self.each(function (index, container) {
                var newElements = appendCoreSingle(container, content, insertOp);
                if (firstContainer) {
                    appendedElements = newElements;
                    firstContainer = false;
                }
            });
            var ss = vp.dom.wrapElements(appendedElements);
            return ss;
        }
        dom.appendCoreMulti = appendCoreMulti;
    })(dom = vp.dom || (vp.dom = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// isFuncs.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - functions for testing object categories
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var utils;
    (function (utils) {
        utils.isFireFox = navigator.userAgent.toLowerCase().contains("firefox");
        utils.isChrome = navigator.userAgent.toLowerCase().contains("chrome");
        utils.isIE = navigator.userAgent.toLowerCase().contains("trident");
        utils.isIE11 = navigator.userAgent.contains("Trident/7.0");
        utils.isEdge = navigator.userAgent.toLowerCase().contains("edge/");
        utils.isIOS = (navigator.userAgent.contains("iPod") ||
            navigator.userAgent.contains("iPhone") ||
            navigator.userAgent.contains("iPad"));
        utils.isSafari = navigator.userAgent.contains("Safari");
        function isUndefined(obj) {
            return (typeof obj === "undefined");
        }
        utils.isUndefined = isUndefined;
        function isDefined(obj) {
            return (!(typeof obj === "undefined"));
        }
        utils.isDefined = isDefined;
        /// returns true if obj is a VuePlot visualization element.
        function isVuePlotControl(obj) {
            return (obj && (!(typeof obj.control === "undefined")));
        }
        utils.isVuePlotControl = isVuePlotControl;
        /// is obj an svg child element?
        function isSvgElement(obj) {
            var isSvg = (obj && obj.tagName == "svg") ? false : vp.utils.isSvgDocOrElement(obj);
            return isSvg;
        }
        utils.isSvgElement = isSvgElement;
        /// is this element an svg document or svg child element?
        function isSvgDocOrElement(elem) {
            var isSvg = false;
            var parent = elem;
            while ((parent != null) && (parent != document)) {
                if (parent.tagName == "svg") {
                    isSvg = true;
                    break;
                }
                if (parent.tagName == "foreignObject") {
                    isSvg = false;
                    break;
                }
                if (parent.parentNode == null) {
                    // CHW: return true when root is an SVG.*Element
                    var cname = parent.constructor.toString();
                    if (cname.match(/object SVG.*Element/i)) {
                        // consider part of SVG tree if root element is an SVG element
                        isSvg = true;
                        break;
                    }
                }
                parent = parent.parentNode;
            }
            return isSvg;
        }
        utils.isSvgDocOrElement = isSvgDocOrElement;
        /// is obj an HTML 5 canvas ----
        function isCanvas(obj) {
            return ((obj != null) && (obj.tagName == "CANVAS"));
        }
        utils.isCanvas = isCanvas;
        /// is obj a lightweight canvas child? ----
        function isCanvasChild(obj) {
            return ((obj != null) && (obj.rootContainer) && (obj.rootContainer.canvas.tagName == "CANVAS"));
        }
        utils.isCanvasChild = isCanvasChild;
        function isCanvasContainer(obj) {
            return ((obj != null) && (obj.rootContainer == obj));
        }
        utils.isCanvasContainer = isCanvasContainer;
        /// returns true if obj is a function.
        function isFunction(obj) {
            return (typeof obj === "function");
        }
        utils.isFunction = isFunction;
        /// returns true if obj is a number.
        function isNumber(obj) {
            return (typeof obj === "number");
        }
        utils.isNumber = isNumber;
        /// returns true if obj is an object (not a primitive).
        function isObject(obj) {
            return (typeof obj === "object");
        }
        utils.isObject = isObject;
        /// returns true if obj is a boolean value (true/false).
        function isBoolean(obj) {
            return (typeof obj === "boolean");
        }
        utils.isBoolean = isBoolean;
        /// returns true if obj is a number and not a NAN and not infinity
        function isValidNumber(obj) {
            return ((typeof obj === "number") && (!isNaN(obj)) && (isFinite(obj)));
        }
        utils.isValidNumber = isValidNumber;
        function isInteger(value) {
            var isInt = isValidNumber(value);
            if (isInt) {
                if (value != Math.floor(value)) {
                    isInt = false;
                }
            }
            return isInt;
        }
        utils.isInteger = isInteger;
        /// returns true if obj is an array.
        function isArray(obj) {
            //return (typeof this === "array");
            return (obj == null) ? false : Object.prototype.toString.call(obj) === "[object Array]";
        }
        utils.isArray = isArray;
        /// returns true if obj is a string.
        function isString(obj) {
            return (typeof obj === "string");
        }
        utils.isString = isString;
        /// returns true if obj is a selected set.
        function isSelectedSet(elem) {
            return ((elem.ctr == "vp.dom.selectedSet") || (elem instanceof vp.dom.singleWrapperSuperClass));
        }
        utils.isSelectedSet = isSelectedSet;
        /// returns true if obj is a Date object.
        function isDate(obj) {
            return (obj instanceof Date);
        }
        utils.isDate = isDate;
    })(utils = vp.utils || (vp.utils = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// dom.ts.  Copyright (c) 2016 Microsoft Corporation.
///            part of the vuePlot library - getters and setters for element attributes and CSS properties.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var dom;
    (function (dom) {
        function is(elem, elementType) {
            var match = false;
            if (elem.tagName) {
                match = (elem.tagName.toLowerCase() == elementType.toLowerCase());
            }
            return match;
        }
        dom.is = is;
        /// get/set the "left" css propperty (relative to its parent).  this supports HTML elements, 
        /// including the SVG and Canvas documents.
        /// SVG and Canvas children should use the "x" and "cx" attributes.
        function left(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                //---- try SVG first (since elem.offsetLeft returns "0" on Chrome for SVG elements) ----
                if (elem.getBBox) {
                    //---- SVG element ----
                    var rc = elem.getBBox();
                    value = rc.x;
                }
                else {
                    //---- try modern HTML ----
                    value = elem.offsetLeft;
                    if (value === undefined) {
                        if (elem.getOffset) {
                            //---- canvas element ----
                            value = elem.getOffset().x;
                        }
                    }
                }
                return value;
            }
            else {
                //---- SET value ----
                if (vp.utils.isNumber(value)) {
                    //---- ensure number without units get interpreted as pixels ----
                    value = value + "px";
                }
                if (vp.utils.isUndefined(elem.animation)) {
                    //---- no animation is active - just set in instantly ----
                    elem.style.left = value;
                }
                else {
                    //---- add to current animation object ----
                    elem.animation.animateAttr(elem, "left", value, undefined, undefined, undefined, true);
                }
            }
        }
        dom.left = left;
        /// get/set the "top" css propperty (relative to its parent).  this supports HTML elements, 
        /// including the SVG and Canvas documents.
        /// SVG and Canvas children should use the "x" and "cx" attributes.
        function top(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                //---- try SVG first (since elem.offsetLeft returns "0" on Chrome for SVG elements) ----
                if (elem.getBBox) {
                    //---- SVG element ----
                    var rc = elem.getBBox();
                    value = rc.y;
                }
                else {
                    //---- ftry modern HTML ----
                    value = elem.offsetTop;
                    if (value === undefined) {
                        if (elem.getOffset) {
                            //---- canvas element ----
                            value = elem.getOffset().y;
                        }
                    }
                }
                return value;
            }
            else {
                //---- SET value ----
                if (vp.utils.isNumber(value)) {
                    //---- ensure number without units get interpreted as pixels ----
                    value = value + "px";
                }
                if (vp.utils.isUndefined(elem.animation)) {
                    //---- no animation is active - just set it instantly ----
                    elem.style.top = value;
                }
                else {
                    //---- add to current animation object ----
                    elem.animation.animateAttr(elem, "top", value, undefined, undefined, undefined, true);
                }
            }
        }
        dom.top = top;
        /// public getBounds(elem) - return a RECT that represents the x, y, width, height relative 
        /// to its parent.  Works for HTML, SVG, and CANVAS elements.
        function getBounds(elem, relToParent, includePadding) {
            var rc = undefined;
            //---- checking "getBoundingClientRect" was working but now seems to have broken ----
            //---- switched to check getBBox first on 10/23/2012 - rfernand ----
            if (elem.getBBox) {
                var rcx = elem.getBBox();
                //---- convert to true rect ----
                var rc = vp.geom.rect(rcx.x, rcx.y, rcx.width, rcx.height);
                //---- bug corrected: 03/24/2015 - rfernand ----
                //if ((!relToParent) && (elem.parentNode))
                if ((relToParent) && (elem.parentNode)) {
                    var rcp = getBounds(elem.parentNode, false);
                    rc = vp.geom.offsetRect(rc, rcp.left, rcp.top);
                }
            }
            else if (elem.getBoundingClientRect) {
                rc = elem.getBoundingClientRect();
                if ((relToParent) && (elem.parentNode)) {
                    var rcp = elem.parentNode.getBoundingClientRect();
                    rc = vp.geom.offsetRect(rc, -rcp.left, -rcp.top);
                }
            }
            if (includePadding) {
                var cs = window.getComputedStyle(elem);
                var leftPad = parseFloat(cs["paddingLeft"]);
                var topPad = parseFloat(cs["paddingTop"]);
                var rightPad = parseFloat(cs["paddingRight"]);
                var bottomPad = parseFloat(cs["paddingBottom"]);
                //---- just adjust left/top - apparently width and height already include padding ----
                rc = vp.geom.createRect(rc.left - leftPad, rc.top - topPad, rc.width, rc.height);
            }
            return rc;
        }
        dom.getBounds = getBounds;
        function parentOffset(elem) {
            return { left: left(elem), top: top(elem) };
        }
        dom.parentOffset = parentOffset;
        /// return size of browser window.
        function windowSize() {
            return { width: window.innerWidth, height: window.innerHeight };
        }
        dom.windowSize = windowSize;
        /// return the actual width of the specified element.
        function getWidth(elem) {
            //---- get "width" value ----
            var width = 0;
            if (elem) {
                try {
                    if ((elem == window) || (elem == document)) {
                        width = windowSize().width;
                    }
                    else if (elem.rootContainer) {
                        //---- this is a vueplot canvasContainerElement ----
                        if (elem.rootContainer == elem) {
                            elem = elem.canvas;
                            width = elem.getBoundingClientRect().width;
                        }
                        else {
                            //---- its a canvas 2d/3d lightweight element ----
                            width = elem.getWidth.call(elem);
                        }
                    }
                    else if ((elem.tagName == "svg") && (vp.utils.isFireFox)) {
                        //---- SVG document on FireFox ----
                        if (elem.clientWidth) {
                            //---- svg document on Chrome needs this ----
                            width = elem.clientWidth;
                        }
                        if (width == 0) {
                            //---- sampleData.html needs this checked before checking elem.width.baseVal ----
                            if ((elem.style) && (elem.style.width !== undefined)) {
                                width = getCssNumber(elem.style.width, vp.dom.width(elem.parentNode));
                            }
                        }
                        if (width == 0) {
                            if ((elem.width) && (elem.width.baseVal)) {
                                width = getBaseVal(elem, "width", elem.width);
                            }
                        }
                    }
                    else {
                        //---- give getBBox() priority since FireFox computes text height wrong using getBoundingClientRect ----
                        if (vp.utils.isFireFox && elem.getBBox) {
                            width = elem.getBBox().width;
                        }
                        else if (vp.utils.isSvgDocOrElement(elem)) {
                            //---- SVG document not on FireFox ----
                            if (elem.clientWidth) {
                                //---- svg document on Chrome needs this ----
                                width = elem.clientWidth;
                            }
                            else if (!vp.utils.isFireFox && elem.getBBox) {
                                width = elem.getBBox().width;
                            }
                            else {
                                //---- sometimes we call too early and elem.getBoundingClientRect() gets an "unspecified error" ----
                                try {
                                    width = elem.getBoundingClientRect().width;
                                }
                                catch (ex) {
                                }
                                //---- simplfy this ASAP ----
                                if (width == 0) {
                                    if ((elem.width) && (elem.width.baseVal)) {
                                        width = getBaseVal(elem, "width", elem.width);
                                    }
                                    else {
                                        //---- last resort ----
                                        width = parseFloat(window.getComputedStyle(elem).width);
                                    }
                                }
                                //---- should check this sooner? ----
                                if ((width == 0) || (isNaN(width))) {
                                    width = +elem.getAttribute("width");
                                }
                            }
                        }
                        else {
                            //---- HTML element ----
                            width = elem.offsetWidth;
                        }
                    }
                }
                catch (ex) {
                }
            }
            return width;
        }
        dom.getWidth = getWidth;
        function totalWidth(elem) {
            //var width = getWidth(elem);
            ////---- add borders ----
            //var cs = window.getComputedStyle(elem);
            //var bs = parseFloat(cs["borderLeftWidth"]) + parseFloat(cs["borderRightWidth"]);
            //width += bs;
            var cs = window.getComputedStyle(elem);
            var width = parseFloat(cs.marginLeft) + elem.offsetWidth + parseFloat(cs.marginRight);
            return width;
        }
        dom.totalWidth = totalWidth;
        function totalHeight(elem) {
            //var height = getHeight(elem);
            ////---- add borders ----
            //var cs = window.getComputedStyle(elem);
            //var bs = parseFloat(cs["borderTopWidth"]) + parseFloat(cs["borderBottomWidth"]);
            //height += bs;
            var cs = window.getComputedStyle(elem);
            var height = parseFloat(cs.marginTop) + elem.offsetHeight + parseFloat(cs.marginBottom);
            return height;
        }
        dom.totalHeight = totalHeight;
        function elementSizes(elem) {
            //---- core width/height ----
            var width = getWidth(elem);
            var height = getHeight(elem);
            var cs = window.getComputedStyle(elem);
            //---- margins ----
            var marginWidth = parseFloat(cs["marginLeft"]) + parseFloat(cs["marginRight"]);
            var marginHeight = parseFloat(cs["marginTop"]) + parseFloat(cs["marginBottom"]);
            //---- borders ----
            var borderWidth = parseFloat(cs["borderLeftWidth"]) + parseFloat(cs["borderRightWidth"]);
            var borderHeight = parseFloat(cs["borderTopWidth"]) + parseFloat(cs["borderBottomWidth"]);
            //---- padding ----
            var paddingWidth = parseFloat(cs["paddingLeft"]) + parseFloat(cs["paddingRight"]);
            var paddingHeight = parseFloat(cs["paddingTop"]) + parseFloat(cs["paddingBottom"]);
            var sizes = {
                width: width, height: height,
                marginWidth: marginWidth, marginHeight: marginHeight,
                borderWidth: borderWidth, borderHeight: borderHeight,
                paddingWidth: paddingWidth, paddingHeight: paddingHeight
            };
            return sizes;
        }
        dom.elementSizes = elementSizes;
        function getBaseVal(elem, propName, prop) {
            var value = 0;
            try {
                if ((prop) && (prop.baseVal)) {
                    var unitType = prop.baseVal.unitType;
                    if ((unitType == 1) || (unitType == 5)) {
                        value = prop.baseVal.value;
                    }
                    else if (unitType == 2) {
                        //---- percentage (of parent) ----
                        if ((elem) && (elem.parentNode)) {
                            var pValue = 0;
                            var parent = elem.parentNode;
                            if (vp.utils.isSvgElement(parent)) {
                                pValue = attr(parent, propName);
                            }
                            else if (vp.utils.isCanvasChild(parent)) {
                                pValue = attr(parent, propName);
                            }
                            else {
                                pValue = css(parent, propName);
                            }
                            var factor = prop.baseVal.valueInSpecifiedUnits;
                            value = factor / 100 * pValue;
                        }
                    }
                }
            }
            catch (err) {
            }
            return value;
        }
        dom.getBaseVal = getBaseVal;
        /// return the actual height of the specified element.
        function getHeight(elem) {
            //--- get "height" value ----
            var height = 0;
            if (elem) {
                try {
                    if ((elem == window) || (elem == document)) {
                        height = windowSize().height;
                    }
                    else if (elem.rootContainer) {
                        //---- this is a vueplot canvasContainerElement ----
                        if (elem.rootContainer == elem) {
                            elem = elem.canvas;
                            height = elem.getBoundingClientRect().height;
                        }
                        else {
                            //---- its a canvas 2d/3d lightweight element ----
                            height = elem.getHeight.call(elem);
                        }
                    }
                    else if ((elem.tagName == "svg") && (vp.utils.isFireFox)) {
                        //---- SVG document on FireFox ----
                        if (elem.clientHeight) {
                            //---- svg document on Chrome needs this ----
                            height = elem.clientHeight;
                        }
                        if (height == 0) {
                            if ((elem.style) && (elem.style.height !== undefined)) {
                                height = getCssNumber(elem.style.height, vp.dom.height(elem.parentNode));
                            }
                        }
                        if (height == 0) {
                            if ((elem.height) && (elem.height.baseVal)) {
                                height = getBaseVal(elem, "height", elem.height);
                            }
                        }
                    }
                    else {
                        //---- give getBBox() priority since FireFox computes text height wrong using getBoundingClientRect ----
                        if (vp.utils.isFireFox && elem.getBBox) {
                            height = elem.getBBox().height;
                        }
                        else if (vp.utils.isSvgDocOrElement(elem)) {
                            //---- SVG document not on FireFox ----
                            if (elem.clientHeight) {
                                //---- svg document on Chrome needs this ----
                                height = elem.clientHeight;
                            }
                            else if (!vp.utils.isFireFox && elem.getBBox) {
                                height = elem.getBBox().height;
                            }
                            else {
                                //---- sometimes we call too early and elem.getBoundingClientRect() gets an "unspecified error" ----
                                try {
                                    height = elem.getBoundingClientRect().height;
                                }
                                catch (ex) {
                                }
                                //---- simplfy this ASAP ----
                                if (height == 0) {
                                    if ((elem.height) && (elem.height.baseVal)) {
                                        height = getBaseVal(elem, "height", elem.height);
                                    }
                                    else {
                                        //---- last resort ----
                                        height = parseFloat(window.getComputedStyle(elem).height);
                                    }
                                }
                                //---- should check this sooner? ----
                                if ((height == 0) || (isNaN(height))) {
                                    height = +elem.getAttribute("height");
                                }
                            }
                        }
                        else {
                            //---- HTML element ----
                            height = elem.offsetHeight;
                        }
                    }
                }
                catch (ex) {
                }
            }
            return height;
        }
        dom.getHeight = getHeight;
        function setWidth(elem, value) {
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                var isSvg = vp.utils.isSvgDocOrElement(elem);
                if (isSvg || vp.utils.isCanvasChild(elem)) {
                    elem.setAttribute("width", value);
                    //---- .css does its own triggerResize() call, but setAttribute does NOT ----
                    vp.events.triggerResize(elem);
                }
                else {
                    if (vp.utils.isNumber(value)) {
                        value = value + "px"; // important to have units specified for HTML elements
                    }
                    css(elem, "width", value);
                }
            }
            else {
                //---- add to current animation object ----
                elem.animation.animateAttr(elem, "width", value, undefined, undefined, undefined, true);
            }
        }
        dom.setWidth = setWidth;
        function setHeight(elem, value) {
            //---- SET value ----
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                {
                    var isSvg = vp.utils.isSvgDocOrElement(elem);
                    if (isSvg || vp.utils.isCanvasChild(elem)) {
                        elem.setAttribute("height", value);
                        //---- .css does its own triggerResize() call, but setAttribute does NOT ----
                        vp.events.triggerResize(elem);
                    }
                    else {
                        if (vp.utils.isNumber(value)) {
                            value = value + "px"; // important to have units specified for HTML elements
                        }
                        css(elem, "height", value);
                    }
                }
            }
            else {
                //---- add to current animation object ----
                elem.animation.animateAttr(elem, "height", value, undefined, undefined, undefined, true);
            }
        }
        dom.setHeight = setHeight;
        function width(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                return getWidth(elem);
            }
            setWidth(elem, value);
        }
        dom.width = width;
        function height(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                return getHeight(elem);
            }
            //---- SET value ----
            setHeight(elem, value);
        }
        dom.height = height;
        function background(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                return css(elem, "background");
            }
            //---- SET value ----
            css(elem, "background", value);
        }
        dom.background = background;
        /// parse a css style string as a number.
        function getCssNumber(cssValueStr, parentValue) {
            //---- can get fancier in future, but see if this basic functionality helps ----
            var value = 0;
            if (cssValueStr != "") {
                value = parseFloat(cssValueStr);
            }
            if (cssValueStr.endsWith("%")) {
                if (vp.utils.isNumber(parentValue)) {
                    //---- base percentage of size/width of parent ----
                    value = (value * parentValue) / 100;
                }
            }
            return value;
        }
        dom.getCssNumber = getCssNumber;
        function center(elem, cx, cy) {
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                elem.setAttribute("cx", cx);
                elem.setAttribute("cy", cy);
            }
            else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, "cx", cx);
                elem.animation.animateAttr(elem, "cy", cy);
            }
        }
        dom.center = center;
        function from(elem, x1, y1) {
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                elem.setAttribute("x1", x1);
                elem.setAttribute("y1", y1);
            }
            else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, "x1", x1);
                elem.animation.animateAttr(elem, "y1", y1);
            }
        }
        dom.from = from;
        function font(elem, family, size, weight, style) {
            if (weight === false) {
                weight = undefined;
            }
            else if (weight === true) {
                weight = "bold";
            }
            if (style === false) {
                style = undefined;
            }
            else if (style === true) {
                style = "italic";
            }
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                elem.setAttribute("font-family", family);
                elem.setAttribute("font-size", size);
                if (weight != undefined) {
                    elem.setAttribute("font-weight", weight);
                }
                if (style != undefined) {
                    elem.setAttribute("font-style", style);
                }
            }
            else {
                //---- add to current animation ----
                this.animation.animateAttr(elem, "font-family", family);
                this.animation.animateAttr(elem, "font-size", size);
                if (weight != undefined) {
                    this.animation.animateAttr(elem, "font-weight", weight);
                }
                if (style != undefined) {
                    this.animation.animateAttr(elem, "font-style", style);
                }
            }
        }
        dom.font = font;
        function to(elem, x2, y2) {
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                elem.setAttribute("x2", x2);
                elem.setAttribute("y2", y2);
            }
            else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, "x2", x2);
                elem.animation.animateAttr(elem, "y2", y2);
            }
        }
        dom.to = to;
        function translate(elem, x, y, makeCrispGroup, makeCrispRoot) {
            if (makeCrispRoot) {
                //---- adjust the offset so that the group is a round number offset within the HTML document ----
                var result = vp.utils.getRootCrispTranslate(elem, x, y);
                x = result.x;
                y = result.y;
            }
            else if (makeCrispGroup) {
                //---- round the translation for child groups ----
                x = Math.round(x);
                y = Math.round(y);
            }
            transform(elem, "translate(" + x + "," + y + ")");
        }
        dom.translate = translate;
        function transform(elem, strTransform) {
            if (arguments.length == 1) {
                var value = undefined;
                if (vp.utils.isSvgDocOrElement(elem)) {
                    value = elem.getAttribute("transform");
                }
                else if (vp.utils.isCanvasChild(elem)) {
                    value = elem.getTransform();
                }
                else if (vp.utils.isDefined(elem.style.transform)) {
                    value = elem.style.transform;
                }
                else if (vp.utils.isDefined(elem.style.msTransform)) {
                    value = elem.style.msTransform;
                }
                else if (vp.utils.isDefined(elem.style.webkitTransform)) {
                    value = elem.style.webkitTransform;
                }
                else if (vp.utils.isDefined(elem.style.MozTransform)) {
                    value = elem.style.MozTransform;
                }
                return value;
            }
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                if (vp.utils.isSvgDocOrElement(elem)) {
                    elem.setAttribute("transform", strTransform);
                }
                else if (vp.utils.isCanvasChild(elem)) {
                    elem.setTransform(strTransform);
                }
                else if (vp.utils.isDefined(elem.style.transform)) {
                    elem.style.transform = strTransform;
                }
                else if (vp.utils.isDefined(elem.style.msTransform)) {
                    elem.style.msTransform = strTransform;
                }
                else if (vp.utils.isDefined(elem.style.webkitTransform)) {
                    elem.style.webkitTransform = strTransform;
                }
                else if (vp.utils.isDefined(elem.style.MozTransform)) {
                    elem.style.MozTransform = strTransform;
                }
            }
            else {
                //---- add to current animation ----
                //---- TODO: add support for transform here ----
                elem.animation.animateAttr(elem, "transform", strTransform);
            }
        }
        dom.transform = transform;
        function transformOrigin(elem, value) {
            if (arguments.length === 0) {
                return elem.getAttribute("transforOrigin");
            }
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                if (vp.utils.isSvgDocOrElement(elem)) {
                    elem.setAttribute("transformOrigin", value);
                }
            }
            else {
                //---- add to current animation ----
                //---- TODO: add support for transform here ----
                elem.animation.animateAttr(elem, "transformOrigin", value);
            }
        }
        dom.transformOrigin = transformOrigin;
        function position(elem, x, y) {
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                elem.setAttribute("x", x);
                elem.setAttribute("y", y);
            }
            else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, "x", x);
                elem.animation.animateAttr(elem, "y", y);
            }
        }
        dom.position = position;
        function absPosition(elem, left, top) {
            css(elem, "position", "absolute");
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                css(elem, "left", left);
                css(elem, "top", top);
            }
            else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, "left", left, undefined, undefined, undefined, true);
                elem.animation.animateAttr(elem, "top", top, undefined, undefined, undefined, true);
            }
        }
        dom.absPosition = absPosition;
        /// private
        function isSizeName(name) {
            var isSizeName = ((name == "width") || (name == "height") || (name == "radius"));
            return isSizeName;
        }
        dom.isSizeName = isSizeName;
        function attr(elem, name, value, disableAnim) {
            if (arguments.length == 2) {
                //---- GET value ----
                if (elem) {
                    var needGetAttr = true;
                    if ((elem.control) && (elem.control.getAttribute)) {
                        var isSizeName = isSizeName(name); // CHW: pass name
                        if (!isSizeName) {
                            //---- let control handle the attribute GET ----
                            value = elem.control.getAttribute(name);
                            needGetAttr = false;
                        }
                    }
                    if (needGetAttr) {
                        value = elem.getAttribute(name);
                    }
                }
                return value;
            }
            //---- SET value ----
            var origValue = value;
            if (typeof origValue === "function") {
                value = origValue(elem.dataItem, elem.dataIndex);
            }
            //if (name == "opacity" && +value == 0)
            //{
            //    var a = 4242;
            //}
            //---- if attribute is not animatable, we need to apply now ----
            var isAttrAnimatable = ((!disableAnim) && (isPropertyAnimatable(name)));
            if ((vp.utils.isUndefined(elem.animation)) || (!isAttrAnimatable)) {
                var needSetAttr = true;
                //---- no animation is active - just set in instantly ----
                if ((elem.control) && (elem.control.setAttribute)) {
                    var isSizeName = isSizeName(name);
                    if (!isSizeName) {
                        if (value + "" === "NaN") {
                            //---- help  debug case where font-family get sets to "Nan" ----
                            vp.utils.error("Error: cannot set attr value to NaN: " + name);
                        }
                        //---- let control handle the attribute SET ----
                        elem.control.setAttribute(name, value);
                        needSetAttr = false;
                    }
                }
                if (needSetAttr) {
                    if (value + "" === "NaN") {
                        var a = 9;
                        vp.utils.error("Error: cannot set attr value to NaN: " + name);
                    }
                    else if (name == "r" && +value < 0) {
                        //---- prevent throwing exception in Chrome for transform values that are negative ----
                        vp.utils.error("Error: radius (r) cannot be negative: " + value);
                        value = 0;
                    }
                    elem.setAttribute(name, value);
                }
                if ((name == "width") || (name == "height") || (name == "radius")) {
                    vp.events.triggerResize(elem);
                }
            }
            else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, name, value);
            }
        }
        dom.attr = attr;
        function attrNS(elem, ns, name, value) {
            if (arguments.length == 3) {
                //---- GET value ----
                value = elem.getAttributeNS(ns, name);
                return value;
            }
            //---- SET value ----
            var origValue = value;
            if (typeof origValue === "function") {
                value = origValue(elem.dataItem, elem.dataIndex);
            }
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                elem.setAttributeNS(ns, name, value);
            }
            else {
                //---- add to current animation ----
                //---- TODO: pass "ns" along to animation... ----
                elem.animation.animateAttr(elem, name, value);
            }
        }
        dom.attrNS = attrNS;
        function href(elem, value) {
            //---- if element has this defined - call it instead ----
            if (vp.utils.isFunction(elem.hrefOverride)) {
                return elem.hrefOverride(value);
            }
            else {
                if (arguments.length == 1) {
                    if (vp.utils.isSvgDocOrElement(elem)) {
                        value = attrNS(elem, "http://www.w3.org/1999/xlink", "href");
                    }
                    else {
                        value = elem.getAttribute("href");
                    }
                    return value;
                }
                if (vp.utils.isSvgDocOrElement(elem)) {
                    attrNS(elem, "http://www.w3.org/1999/xlink", "href", value);
                }
                else {
                    elem.setAttribute("href", value);
                }
            }
        }
        dom.href = href;
        function prop(elem, name, value) {
            if (arguments.length == 2) {
                //---- GET value ----
                value = elem[name];
                return value;
            }
            //---- SET value ----
            var origValue = value;
            if (typeof origValue === "function") {
                value = origValue(elem.dataItem, elem.dataIndex);
            }
            //---- animation NOT supported for custom properties (most of them we do NOT want animated) ----
            elem[name] = value;
        }
        dom.prop = prop;
        //---- todo: we should probably only define one of these and zap the other one ---
        dom.customAttr = prop;
        /// get/set the "opacity" css property on the item.
        function opacity(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = (elem.rootContainer) ? elem.opacity : elem.style.opacity;
                return value;
            }
            else {
                //---- SET value ----
                if (vp.utils.isUndefined(elem.animation)) {
                    //---- no animation is active - just set in instantly ----
                    if (elem.rootContainer) {
                        elem.opacity = value;
                    }
                    else {
                        elem.style.opacity = value;
                    }
                }
                else {
                    //---- add to current animation ----
                    elem.animation.animateAttr(elem, "opacity", value, undefined, undefined, undefined, true);
                }
            }
        }
        dom.opacity = opacity;
        /// get/set the "checked" property on the item.
        function checked(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.checked;
            }
            else {
                //---- SET value ----
                elem.checked = value;
            }
            return value;
        }
        dom.checked = checked;
        function removeAttribute(elem, name) {
            elem.removeAttribute(name);
        }
        dom.removeAttribute = removeAttribute;
        function removeProp(elem, name) {
            return delete elem[name];
        }
        dom.removeProp = removeProp;
        function id(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.getAttribute("id");
                return value;
            }
            else {
                //---- SET value ----
                elem.setAttribute("id", value);
            }
        }
        dom.id = id;
        function toolTipEnabled(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.toolTipEnabled;
                return value;
            }
            else {
                //---- SET value ----
                elem.toolTipEnabled = value;
            }
        }
        dom.toolTipEnabled = toolTipEnabled;
        function getClass(elem) {
            var name = "";
            if ((vp.utils.isSvgDocOrElement(elem)) && (elem.getAttribute)) {
                name = elem.getAttribute("class");
            }
            else {
                name = elem.className;
            }
            if (name == null) {
                name = "";
            }
            else if (name.baseVal) {
                //---- chrome ----
                name = name.baseVal;
            }
            return name;
        }
        dom.getClass = getClass;
        /// sets the class name of the element to just the specified name.
        function setClass(elem, name) {
            if ((vp.utils.isSvgDocOrElement(elem)) && (elem.getAttribute)) {
                elem.setAttribute("class", name);
            }
            else {
                elem.className = name;
            }
        }
        dom.setClass = setClass;
        /// add the specified class name to the element, if it doesn't already have it.
        function addClass(elem, name) {
            if (!hasClass(elem, name)) {
                var cnBefore = getClass(elem);
                var newName = "";
                if (cnBefore == "") {
                    newName = name;
                }
                else {
                    newName = cnBefore + " " + name;
                }
                setClass(elem, newName);
            }
        }
        dom.addClass = addClass;
        /// returns true if the element has the specified class name.
        function hasClass(elem, name) {
            var hasIt = false;
            var cn = getClass(elem);
            if ((cn == name) || (cn.startsWith(name + " ")) || (cn.endsWith(" " + name)) || (cn.contains(" " + name + " "))) {
                hasIt = true;
            }
            return hasIt;
        }
        dom.hasClass = hasClass;
        /// removes the specified class name from the element, if it is found in it.
        function removeClass(elem, name) {
            var cn = getClass(elem);
            var nameLen = name.length;
            var newcn = cn;
            if (cn == name) {
                newcn = "";
            }
            else {
                var index = (cn.indexOf(" " + name + " "));
                if (index > -1) {
                    newcn = cn.substring(0, index) + cn.substring(index + nameLen + 1);
                }
                else {
                    if (cn.endsWith(" " + name)) {
                        var len = cn.length - (nameLen + 1);
                        newcn = cn.substring(0, len);
                    }
                    else if (cn.startsWith(name + "")) {
                        newcn = cn.substring(name.length + 1);
                    }
                }
            }
            if (newcn != cn) {
                setClass(elem, newcn);
            }
        }
        dom.removeClass = removeClass;
        /// if the class name is found in the element, it is removed.  otherwise, it is added.
        function toggleClass(elem, name) {
            if (hasClass(elem, name)) {
                removeClass(elem, name);
            }
            else {
                addClass(elem, name);
            }
        }
        dom.toggleClass = toggleClass;
        /// if the class name is found in the element, it is removed.  otherwise, it is added.
        function tabIndex(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.getAttribute(elem, "tabIndex");
                return value;
            }
            else {
                //---- SET value ----
                var actualValue = value;
                if (typeof value === "function") {
                    actualValue = value(elem.dataItem, elem.dataIndex);
                }
                elem.setAttribute("tabIndex", value);
            }
        }
        dom.tabIndex = tabIndex;
        /// get/set the "text" property on the element.
        function text(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.textContent;
                return value;
            }
            else {
                //---- SET value ----
                var actualValue = value;
                if (typeof value === "function") {
                    actualValue = value(elem.dataItem, elem.dataIndex);
                }
                elem.textContent = actualValue;
            }
        }
        dom.text = text;
        /// return the "title" child, if any, for the element.
        function getTitleChild(elem) {
            var title = null;
            for (var i = 0; i < elem.childNodes.length; i++) {
                var child = elem.childNodes[i];
                if (child.tagName == "title") {
                    title = child;
                    break;
                }
            }
            return title;
        }
        dom.getTitleChild = getTitleChild;
        /// get/set the "title" property on the element (standard tooltip).
        function title(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = null;
                if (vp.utils.isSvgElement(elem)) {
                    var title = getTitleChild(elem);
                    if (title) {
                        value = title.textContent;
                    }
                }
                else if (elem.getAttribute) {
                    value = elem.getAttribute("title");
                }
                return value;
            }
            else {
                //---- SET value ----
                var actualValue = value;
                if (typeof value === "function") {
                    actualValue = value(elem.dataItem, elem.dataIndex);
                }
                if (vp.utils.isSvgElement(elem)) {
                    var title = getTitleChild(elem);
                    if (!title) {
                        title = vp.dom.createSvg("title");
                        elem.appendChild(title);
                    }
                    title.textContent = value;
                }
                else {
                    elem.setAttribute("title", actualValue);
                }
            }
        }
        dom.title = title;
        function html(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.innerHTML;
                return value;
            }
            else {
                //---- SET value ----
                var actualValue = value;
                if (typeof value === "function") {
                    actualValue = value(elem.dataItem, elem.dataIndex);
                }
                elem.innerHTML = actualValue;
            }
        }
        dom.html = html;
        /// get/set the "value" property on the element.
        function value(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.value;
                return value;
            }
            else {
                //---- SET value ----
                var actualValue = value;
                if (typeof value === "function") {
                    actualValue = value(elem.dataItem, elem.dataIndex);
                }
                elem.value = actualValue;
            }
        }
        dom.value = value;
        /** remove all childNodes or children of the element. */
        function clear(element) {
            if (vp.utils.isCanvasChild(element)) {
                element.clear();
            }
            else if (vp.utils.isCanvasContainer(element)) {
                element.clear();
            }
            else if (element.childNodes) {
                while (element.childNodes.length > 0) {
                    element.removeChild(element.firstChild);
                }
            }
        }
        dom.clear = clear;
        /// remove the element from its parent.
        function remove(element) {
            var parentNode = element.parentNode;
            if (parentNode != null) {
                parentNode.removeChild(element);
            }
        }
        dom.remove = remove;
        /// hide an element.
        function hide(elem) {
            visibility(elem, "hidden");
        }
        dom.hide = hide;
        /// collapse an element.
        function collapse(elem) {
            //vp.visibility(elem, "collapse");
            css(elem, "display", "none");
        }
        dom.collapse = collapse;
        /// uncollapse an element.
        function expand(elem) {
            //vp.visibility(elem, "collapse");
            css(elem, "display", "block");
        }
        dom.expand = expand;
        /// show an element.
        function show(elem, showIt) {
            if (showIt === false) {
                visibility(elem, "hidden");
            }
            else {
                visibility(elem, "visible");
            }
        }
        dom.show = show;
        function visibility(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                if (elem.rootContainer == elem) {
                    value = elem.canvas.style.visibility;
                }
                else if (elem.rootContainer) {
                    //---- its a canvas lightweight element ----
                    value = elem.visibility;
                }
                else {
                    //---- normal HTML/SVG element ----
                    value = elem.style.visibility;
                }
                return value;
            }
            //---- SET value ----
            if (elem.rootContainer == elem) {
                elem.canvas.style.visibility = value;
            }
            else if (elem.rootContainer) {
                //---- its a canvas lightweight element ----
                elem.visibility = value;
            }
            else {
                //---- normal HTML/SVG element ----
                elem.style.visibility = value;
            }
        }
        dom.visibility = visibility;
        /// toggle an element between hidden and visible
        function showToggle(elem) {
            var vis = visibility(elem);
            if ((vis == "") || (vis == "visible")) {
                visibility(elem, "collapse");
            }
            else {
                visibility(elem, "visible");
            }
        }
        dom.showToggle = showToggle;
        function isPropertyAnimatable(name) {
            var nonAnimators = ["title", "d", "font-family", "cursor", "stroke-dasharray", "text-anchor", "shape-rendering",
                "text-rendering", "stroke-linecap"];
            var isAnimatable = (nonAnimators.indexOf(name) == -1);
            return isAnimatable;
        }
        /// get/set single CSS style property.
        function css(elem, prop, value) {
            if (elem.canvas) {
                elem = elem.canvas;
            }
            else if (elem.rootContainer) {
                //---- if child of a canvas, use the getAttribute/setAttribute functions for all properties ----
                return attr(elem, prop, value);
            }
            //---- is this still needed?  7/21/2014 - roland.  It messes up "stroke-dasharray" on IE (and others?) ----
            //---- provide translation from prop names like "short-shape" to "shortShape" for Firefox ----
            //var index = prop.indexOf('-');
            //while (index > -1)
            //{
            //    prop = prop.substr(0, index) + prop.substr(index + 1, 1).toUpperCase() + prop.substr(index + 2);
            //    index = prop.indexOf('-');
            //}
            if (arguments.length == 2) {
                //---- GET value ----
                if (prop == "width") {
                    value = getWidth(elem);
                }
                else if (prop == "height") {
                    value = getHeight(elem);
                }
                else {
                    value = elem.style[prop];
                }
                return value;
            }
            if (name == "fill") {
                var aaa = 999;
            }
            //---- if attribute is not animatable, we need to apply now ----
            var isAttrAnimatable = isPropertyAnimatable(prop);
            //---- SET value ----
            if ((vp.utils.isUndefined(elem.animation)) || (!isAttrAnimatable)) {
                //---- set it directly ----
                if (vp.utils.isNumber(value)) {
                    if ((prop != "z-index") && (prop != "zIndex") && (prop != "opacity")) {
                        value += "px";
                    }
                }
                if ((prop == "height") && (value) && (value.startsWith("0"))) {
                    var dummmy = 9;
                }
                if (value + "" === "NaN") {
                    //---- help  debug case where font-family get sets to "Nan" ----
                    var a = 23;
                }
                elem.style[prop] = value;
                if ((prop == "width") || (prop == "height") || (prop == "radius")) {
                    vp.events.triggerResize(elem);
                }
            }
            else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, prop, value, undefined, undefined, undefined, true);
            }
        }
        dom.css = css;
        function parent(elem) {
            var parent = null;
            if (elem.parentNode) {
                parent = elem.parentNode;
            }
            return parent;
        }
        dom.parent = parent;
        function children(parentElem, includeAll) {
            var kids = [];
            if ((parentElem.tagName == "CANVAS") && (parentElem.canvasContainerElement)) {
                parentElem = parentElem.canvasContainerElement;
            }
            if ((parentElem.ctr == "vp.dom.selectedSet") || (parentElem.ctr == "vp.canvas.canvasSelectedSet")) {
                for (var i = 0; i < parentElem.length; i++) {
                    var hisKids = children(parentElem[i]);
                    kids = kids.concat(hisKids);
                }
            }
            else if (parentElem.ctr == "vp.singleWrapper") {
                kids = children(parentElem.elem);
            }
            else if (parentElem.children) {
                kids = parentElem.children;
            }
            else if (parentElem.childNodes) {
                //---- SVG document ----
                kids = parentElem.childNodes;
            }
            //---- convert from HTML Collection to array, if needed ----
            if (!vp.utils.isArray(kids)) {
                var collect = kids;
                kids = [];
                for (var i = 0; i < collect.length; i++) {
                    kids.push(collect[i]);
                }
            }
            //---- include indirect children, if specified ----
            if (includeAll) {
                for (var i = 0; i < kids.length; i++) {
                    var ikids = children(kids[i]);
                    kids = kids.concat(ikids);
                }
            }
            return kids;
        }
        dom.children = children;
        function childNodes(parentElem, includeAll) {
            var kids = [];
            if ((parentElem.tagName == "CANVAS") && (parentElem.canvasContainerElement)) {
                parentElem = parentElem.canvasContainerElement;
            }
            if ((parentElem.ctr == "vp.dom.selectedSet") || (parentElem.ctr == "vp.canvas.canvasSelectedSet")) {
                for (var i = 0; i < parentElem.length; i++) {
                    var hisKids = childNodes(parentElem[i]);
                    kids = kids.concat(hisKids);
                }
            }
            else if (parentElem.ctr == "vp.singleWrapper") {
                kids = childNodes(parentElem.elem);
            }
            else if (parentElem.childNodes) {
                kids = parentElem.childNodes;
            }
            //---- convert from HTML Collection to array, if needed ----
            if (!vp.utils.isArray(kids)) {
                var collect = kids;
                kids = [];
                for (var i = 0; i < collect.length; i++) {
                    kids.push(collect[i]);
                }
            }
            //---- include indirect children, if specified ----
            if (includeAll) {
                for (var i = 0; i < kids.length; i++) {
                    var ikids = childNodes(kids[i]);
                    kids = kids.concat(ikids);
                }
            }
            return kids;
        }
        dom.childNodes = childNodes;
        function bounds(elem, x, y, width, height, makeCrisp) {
            if (makeCrisp) {
                //---- round bounds ----
                x = Math.round(x);
                y = Math.round(y);
                width = Math.round(width);
                height = Math.round(height);
            }
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                if (height === undefined) {
                    //---- for circle-types ----
                    elem.setAttribute("cx", x);
                    elem.setAttribute("cy", y);
                    elem.setAttribute("r", width);
                }
                else {
                    if (vp.utils.isSvgDocOrElement(elem) || vp.utils.isCanvasChild(elem)) {
                        elem.setAttribute("x", x);
                        elem.setAttribute("y", y);
                        elem.setAttribute("width", width);
                        elem.setAttribute("height", height);
                    }
                    else {
                        css(elem, "left", x);
                        css(elem, "top", y);
                        css(elem, "width", width);
                        css(elem, "height", height);
                    }
                }
            }
            else {
                //---- add to current animation ----
                if (height === undefined) {
                    //---- for circle-types ----
                    elem.animation.animateAttr(elem, "cx", x);
                    elem.animation.animateAttr(elem, "cy", y);
                    elem.animation.animateAttr(elem, "r", width);
                }
                else {
                    if (vp.utils.isSvgDocOrElement(elem) || vp.utils.isCanvasChild(elem)) {
                        elem.animation.animateAttr(elem, "x", x);
                        elem.animation.animateAttr(elem, "y", y);
                        elem.animation.animateAttr(elem, "width", width);
                        elem.animation.animateAttr(elem, "height", height);
                    }
                    else {
                        elem.animation.animateAttr(elem, "left", x, undefined, undefined, undefined, true);
                        elem.animation.animateAttr(elem, "top", y, undefined, undefined, undefined, true);
                        elem.animation.animateAttr(elem, "width", width, undefined, undefined, undefined, true);
                        elem.animation.animateAttr(elem, "height", height, undefined, undefined, undefined, true);
                    }
                }
            }
        }
        dom.bounds = bounds;
        function colors(elem, fill, stroke, strokeWidth) {
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                if (fill !== undefined) {
                    elem.setAttribute("fill", fill);
                }
                if (stroke !== undefined) {
                    elem.setAttribute("stroke", stroke);
                }
                if (strokeWidth != undefined) {
                    elem.setAttribute("stroke-width", strokeWidth);
                }
            }
            else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, "fill", fill);
                elem.animation.animateAttr(elem, "stroke", stroke);
                elem.animation.animateAttr(elem, "strokeWidth", strokeWidth);
            }
        }
        dom.colors = colors;
        function addStop(brush, offset, color, opacity) {
            var ss = "stop-color: " + color;
            if (opacity != null) {
                ss += "; stop-opacity: " + opacity;
            }
            if (vp.utils.isUndefined(brush.animation)) {
                //---- no animation is active - just set in instantly ----
                var stop = document.createElementNS("http://www.w3.org/2000/svg", "stop");
                stop.setAttribute("offset", offset);
                stop.setAttribute("style", ss);
                brush.appendChild(stop);
            }
            else {
            }
        }
        dom.addStop = addStop;
        function dataItem(elem, value) {
            if (arguments.length == 1) {
                return elem.dataItem;
            }
            elem.dataItem = value;
        }
        dom.dataItem = dataItem;
        function dataIndex(elem, value) {
            if (arguments.length == 1) {
                return elem.dataIndex;
            }
            elem.dataIndex = value;
        }
        dom.dataIndex = dataIndex;
        function animate(elem, duration, ease, container, delay) {
            var anyElem = elem;
            if (duration) {
                //---- store the animation object on the element so it can be retreived later, if needed ----
                anyElem.animation = new vp.animation.animationClass(elem, duration, ease, container, delay);
            }
            else {
                delete anyElem.animation; // mark it as not animating, so we set attributes, etc. directly
            }
        }
        dom.animate = animate;
        function onAnimationComplete(elem, completedFunc) {
            elem.animation.onAnimationComplete(completedFunc);
        }
        dom.onAnimationComplete = onAnimationComplete;
        function frameRateChanged(elem, callBack) {
            elem.frameRateChanged = callBack;
        }
        dom.frameRateChanged = frameRateChanged;
        function radius(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.getAttribute("radius");
                return value;
            }
            //---- SET value ----
            if (vp.utils.isUndefined(elem.animation)) {
                //---- no animation is active - just set in instantly ----
                elem.setAttribute("radius", value);
            }
            else {
                //---- add to current animation ----
                elem.animation.animateAttr(elem, "radius", value);
            }
        }
        dom.radius = radius;
        function returnFalse() {
            return false;
        }
        dom.returnFalse = returnFalse;
        function dataPair(elem, dataItem, dataIndex) {
            elem.dataItem = dataItem;
            elem.dataIndex = dataIndex;
        }
        dom.dataPair = dataPair;
        function focus(elem) {
            elem.focus();
        }
        dom.focus = focus;
        function dataId(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.dataItem.dataId;
                return value;
            }
            //---- SET value ----
            elem.dataItem.dataId = value;
        }
        dom.dataId = dataId;
        function shapeId(elem, value) {
            if (arguments.length == 1) {
                //---- GET value ----
                value = elem.dataItem.shapeId;
                return value;
            }
            //---- SET value ----
            elem.dataItem.shapeId = value;
        }
        dom.shapeId = shapeId;
        /* This sets the attributes on the line element "elem" to make it a vertical line.  If "makeCrisp"
           is set to true, and the stroke-width is set to an odd whole number, the line is drawn "crisp",
           without antialiasing. */
        function vLine(elem, y1, y2, x, makeCrisp) {
            if (makeCrisp) {
                //---- NOTE: this code assumes that a parent elelment has offset our points to .5, .5 boundaries, relatative to the HTML document ----
                attr(elem, "shape-rendering", "crispEdges");
                y1 = .5 + Math.floor(y1);
                y2 = .5 + Math.floor(y2);
                x = Math.round(x); // this one does not get a .5 offset here
            }
            //---- SET value ----
            attr(elem, "y1", y1);
            attr(elem, "y2", y2);
            attr(elem, "x1", x);
            attr(elem, "x2", x);
        }
        dom.vLine = vLine;
        /* This sets the attributes on the line element "elem" to make it a horizontal line.  If "makeCrisp"
           is set to true, and the stroke-width is set to an odd whole number, the line is drawn "crisp",
           without antialiasing. */
        function hLine(elem, x1, x2, y, makeCrisp) {
            if (makeCrisp) {
                //---- NOTE: this code assumes that our parent groups/documents are all rounded to whole numbers ----
                attr(elem, "shape-rendering", "crispEdges");
                /// Rule from experiments/svgCrispLines.html:
                ///   - for horizontal lines, X=rounded, Y=.5+rounded
                x1 = .5 + Math.floor(x1);
                x2 = .5 + Math.floor(x2);
                y = Math.round(y);
            }
            //---- SET value ----
            attr(elem, "y1", y);
            attr(elem, "y2", y);
            attr(elem, "x1", x1);
            attr(elem, "x2", x2);
        }
        dom.hLine = hLine;
        /// used to temp. disable HTML element selection by the user with mouse/touch
        /// during a control's dragging operation.
        function enableElementSelection(elem, enable) {
            if (enable) {
                if (vp.utils.isDefined(elem.onselectstart)) {
                    elem.onselectstart = null;
                }
                else if (vp.utils.isDefined(elem.style.MozUserSelect)) {
                    //---- restore default of "text" ----
                    elem.style.MozUserSelect = "text";
                }
                else if (elem.onmousedown == returnFalse) {
                    elem.onmousedown = null;
                }
            }
            else {
                if (vp.utils.isDefined(elem.onselectstart)) {
                    elem.onselectstart = returnFalse;
                }
                else if (vp.utils.isDefined(elem.style.MozUserSelect)) {
                    elem.style.MozUserSelect = "none";
                }
                else {
                    //---- caution: this could break other things ----
                    elem.onmousedown = returnFalse;
                }
            }
        }
        dom.enableElementSelection = enableElementSelection;
        /// returns the scroll offset for the HTML page.  This value is in pixels from the document origin.
        /// verified correct by roland on 6/21/2013 on Windows 8 for: IE10, Chrome 27, and FireFox 21.0.
        function getBodyScroll() {
            return { x: window.pageXOffset, y: window.pageYOffset };
        }
        dom.getBodyScroll = getBodyScroll;
        /// gets the {left,top} offset of the HTML/SVG/Canvas element from the document origin.
        /// verified correct by roland on 5/12/2012 on Windows 7 for: IE9, Chrome 18.0, and FireFox 11.0.
        /// testing included HMTL document, HTML element, SVG doc, SVG element, Canvas 2d doc, Canvas 2d elem,
        /// Canvas 3d doc, Canvas 3d elem.
        function docOffset(elem) {
            var left = 0;
            var top = 0;
            var origElem = elem;
            //---- walk up the parent hierarchy until we hit a real HTML element ----
            while ((elem) && (elem != document.body)) {
                if ((elem.rootContainer) && (elem.rootContainer == elem)) {
                    elem = elem.canvas;
                }
                if (elem.rootContainer) {
                    //---- its a canvas 2d/3d lightweight element ----
                    var offset = elem.getOffset();
                    left += offset.x;
                    top += offset.y;
                }
                else if ((elem.tagName == "svg") && (!vp.utils.isIE)) {
                    //---- special handling for SVG document for Chrome/FireFox ----
                    //---- these browsers do wierd things when a viewBox is set on the SVG document, so we use this workaround ----
                    if (vp.utils.isFireFox) {
                        //---- FireFox ----
                        //var rc = elem.getBoundingClientRect();
                        // problem: getBoundingClinetRect() varies with viewBox on svgdoc, so it is not simple to use.
                        // as our workaround, we use elem.getBBox() for parent offset and then the location of the parent.
                        var vb = elem.viewBox;
                        if ((vb) && (vb.baseVal) && (vb.baseVal.width > 0) && (vb.baseVal.height > 0)) {
                            //---- viewbox is active ----
                            //---- add offset to parent ----
                            var box = elem.getBBox();
                            left += box.x;
                            top += box.y;
                            //---- wait - getBBox() is measured from outside box of parent (not content); so we need to ----
                            //---- adjust by adding the left/top margin and the left/top border size (yuck) ----
                            left -= getCssNumber(elem.parentNode.style.marginLeft);
                            left -= getCssNumber(elem.parentNode.style.borderLeft);
                            top -= getCssNumber(elem.parentNode.style.marginTop);
                            top -= getCssNumber(elem.parentNode.style.borderTop);
                        }
                        else {
                            //---- viewbox is inactive ----
                            var rc = elem.getBoundingClientRect();
                            left += rc.left;
                            top += rc.top;
                            //---- this stuff is really strange; now we seem to need to offset it by getBBox() ----
                            var bb = elem.getBBox();
                            left -= bb.x;
                            top -= bb.y;
                            break;
                        }
                    }
                    else {
                        //---- Chrome ----
                        if (vp.utils.isDefined(elem.offsetLeft)) {
                            //---- this fixes "mouse" and "panAndZoom" samples for Chrome, but more adjustments may be needed ----
                            //---- we also need to work for "stdChart" bar selection dragging ----
                            //---- as a temp workaround, use 2 code paths (one for active viewBox, one for other case) ----
                            var vb = elem.viewBox;
                            if ((vb) && (vb.baseVal) && (vb.baseVal.width > 0) && (vb.baseVal.height > 0)) {
                                //---- viewbox is active ----
                                left += elem.offsetLeft;
                                top += elem.offsetTop;
                                break;
                            }
                            else {
                                //---- viewbox is inactive ----
                                var rc = elem.getBoundingClientRect();
                                left += rc.left;
                                top += rc.top;
                                break;
                            }
                        }
                    }
                }
                else {
                    //---- HTML element ----
                    //---- "modern browser" assumption - we rely on getBoundClientRect() to do the hard work ----
                    var rc = elem.getBoundingClientRect();
                    left += rc.left;
                    top += rc.top;
                    break;
                }
                elem = elem.parentNode;
            }
            //---- must always add the scroll offset of the body ----
            var bs = getBodyScroll();
            left += bs.x;
            top += bs.y;
            return { left: left, top: top };
        }
        dom.docOffset = docOffset;
        function textBaseline(textElem, alignType, rc) {
            if (textBaseline instanceof vp.canvas.canvasTextElement) {
                textElem.setAttribute("textBaseline", alignType);
            }
            else {
                var delta = computeTextBaselineDelta(textElem, alignType);
                //---- animate if needed by using "attr" ----
                //textElem.setAttribute("dy", delta);
                vp.dom.attr(textElem, "dy", delta + "");
            }
        }
        dom.textBaseline = textBaseline;
        function computeTextBaselineDelta(textElem, alignType) {
            var yPos = +textElem.getAttribute("y");
            yPos += +textElem.getAttribute("dy");
            var rc = vp.dom.getBounds(textElem); //.getBBox();
            var yCorrection = yPos - rc.top;
            var height = rc.height;
            var delta = 0;
            if (alignType == "top") {
                //---- align TOP ----
                delta = yCorrection;
            }
            else if (alignType == "bottom") {
                //---- align BOTTOM ----
                delta = yCorrection - height;
            }
            else if (alignType == "middle") {
                //---- align BOTTOM ----
                delta = yCorrection - height / 2;
            }
            return delta;
        }
        dom.computeTextBaselineDelta = computeTextBaselineDelta;
    })(dom = vp.dom || (vp.dom = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// styleSheet.ts.  Copyright (c) 2016 Microsoft Corporation.
///                part of the vuePlot library - misc utility functions.
///
///     - adapted from code on the web.  Need URL...
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var dom;
    (function (dom) {
        var styleSheetClass = (function () {
            function styleSheetClass(innerText) {
                //---- local state ----
                this._styleSheet = null;
                this._elem = null;
                this._elem = document.createElement('style');
                this._elem.type = 'text/css';
                this._elem.innerHTML = innerText;
                //---- fix for webhit ----
                this._elem.appendChild(document.createTextNode(""));
                //---- append to document <head> section ----
                //var head0 = document.getElementsByTagName('head')[0];
                //head0.appendChild(this._elem);
                document.head.appendChild(this._elem);
                //---- elem is now the final sheet object, so get the newly created sheet ----
                this._styleSheet = document.styleSheets[document.styleSheets.length - 1];
                //if (innerText)
                //{
                //    this._styleSheet.cssText = innerText;
                //}
            }
            //---- add a rule to this style sheet ----
            styleSheetClass.prototype.addRule = function (selector, style) {
                if (vp.utils.isFireFox) {
                    selector = selector.replace("::selection", "::-moz-selection");
                }
                var myRules = this._styleSheet.rules || this._styleSheet.cssRules;
                var atIndex = myRules.length;
                this._styleSheet.insertRule(selector + ' {' + style + '}', atIndex);
                return this;
            };
            //---- remove this style sheet from the document
            styleSheetClass.prototype.remove = function () {
                var head0 = document.getElementsByTagName('head')[0];
                head0.removeChild(this._elem);
                return this;
            };
            styleSheetClass.prototype.sheet = function () {
                return this._styleSheet;
            };
            /// propety: id
            styleSheetClass.prototype.id = function (value) {
                if (arguments.length === 0) {
                    return vp.dom.id(this._elem);
                }
                vp.dom.id(this._elem, value);
                return this;
            };
            return styleSheetClass;
        }());
        dom.styleSheetClass = styleSheetClass;
        function createStyleSheet(innerText) {
            return new styleSheetClass(innerText);
        }
        dom.createStyleSheet = createStyleSheet;
    })(dom = vp.dom || (vp.dom = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// formatters.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlot library 
///   - defines a set of chart label formatting functions
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var formatters;
    (function (formatters) {
        var THOUSAND_SEPARATOR = ",";
        // TODO (07/28/2014): add "_locale" to "comma" and other formatting functions, to ease formatting override by clients.
        //var _locale: string = undefined;
        //export function locale(): string;
        //export function locale(value: string): any;
        //export function locale(value?: string): any
        //{
        //    if (arguments.length == 0)
        //    {
        //        return _locale;
        //    }
        //    _locale = value;
        //    return this;
        //}
        /// format a number nicely (shortest decimal possible, add commas for thousands).
        function comma(value, numDecimalPlaces, forceDecimalPlaces, removeLeadingSingleZero) {
            if (numDecimalPlaces === undefined) {
                numDecimalPlaces = 2;
            }
            //---- convert to a number, if possible ----
            var num = parseFloat(value);
            if ((vp.utils.isNumber(num)) && (!isNaN(num))) {
                value = num;
                var isWholeNum = (Math.abs(value - Math.round(value)) == 0); // < vp.epsilon);
                if ((!forceDecimalPlaces) && (isWholeNum)) {
                    value = Math.round(value).toString();
                }
                else {
                    //---- ensure "numDecimalPlaces" is a legal value ----
                    numDecimalPlaces = Math.round(numDecimalPlaces);
                    numDecimalPlaces = Math.max(0, Math.min(20, numDecimalPlaces));
                    var isLessThanOne = (Math.abs(value) < 1);
                    //if (false)      // (value != 0) && (isLessThanOne) && (numDecimalPlaces > 0))
                    //{
                    //    value = num + "";   // default formatting
                    //    var index = <number>value.indexOf(".");
                    //    if (index > 0)
                    //    {
                    //        var signifCount = 0;
                    //        var excessIndex = -1;
                    //        var firstSignifIndex = -1;
                    //        var excessCount = 0;
                    //        //---- remove excess digits after "numDecimalPlaces" ----
                    //        for (var i = index + 1; i < value.length; i++)
                    //        {
                    //            if (value[i] >= "0" && value[i] <= "9")
                    //            {
                    //                //---- its a DIGIT (vs. +E..) ----
                    //                if ((value[i] > "0") && (firstSignifIndex == -1))
                    //                {
                    //                    firstSignifIndex = i;
                    //                }
                    //                if (firstSignifIndex > -1)
                    //                {
                    //                    signifCount++;
                    //                }
                    //                if ((signifCount > numDecimalPlaces) && (excessIndex == -1))
                    //                {
                    //                    excessIndex = i;
                    //                }
                    //                if (excessIndex > -1)
                    //                {
                    //                    excessCount++;
                    //                }
                    //            }
                    //            else
                    //            {
                    //                break;
                    //            }
                    //        }
                    //        //---- reached end of digits after the "." ----
                    //        if (excessIndex > -1)
                    //        {
                    //            //---- delete digits at "excessIndex" ----
                    //            value = value.substr(0, excessIndex) + value.substr(excessIndex + excessCount);
                    //        }
                    //    }
                    //}
                    //else
                    {
                        value = value.toFixed(numDecimalPlaces);
                        if ((isLessThanOne) && (removeLeadingSingleZero) && (forceDecimalPlaces)) {
                            value = value.substr(1);
                        }
                        //---- remove extra zeros ----
                        if ((!forceDecimalPlaces) && (value.contains("."))) {
                            var allZeros = (0).toFixed(numDecimalPlaces).substr(1);
                            if (value.endsWith(allZeros)) {
                                var len = value.length - allZeros.length;
                                value = value.substr(0, len);
                            }
                        }
                    }
                }
                //---- add commas, as needed ----
                var parts = value.split('.');
                var left = parts[0];
                var right = (parts.length > 1) ? "." + parts[1] : "";
                var len = left.length;
                //---- don't add commas to 4 digit numbers ----
                if ((len > 4) || (len > 5 && len[0] == "-")) {
                    var startLen = (len % 3) == 0 ? 3 : len % 3;
                    var newLeft = left.substring(0, startLen);
                    for (var i = startLen; i < len; i += 3) {
                        newLeft += THOUSAND_SEPARATOR + left.substring(i, i + 3);
                    }
                    value = newLeft + right;
                }
                //---- look for exception to rule ----
                if (value.startsWith("-,")) {
                    value = "-" + value.substr(2);
                }
            }
            return value;
        }
        formatters.comma = comma;
        // Adds commas as the thousands separator (eg. 1234567.89 will become "1,234,567.89").
        // Exponent format numbers (eg. 6e+29) will NOT be formatted.
        function commaOnly(value) {
            var num = parseFloat(value);
            if ((vp.utils.isNumber(num)) && (!isNaN(num)) && (value.toString().indexOf("e+") == -1)) {
                //---- add commas, as needed ----
                var parts = value.toString().split('.'); // DON'T use 'num' here: we want to preserve any trailing 0's in the mantissa of 'value' [as potentially added by comma()]
                var left = parts[0];
                var right = (parts.length > 1) ? "." + parts[1] : "";
                var len = left.length;
                if (len > 3) {
                    var startLen = (len % 3) == 0 ? 3 : len % 3;
                    var newLeft = left.substring(0, startLen);
                    for (var i = startLen; i < len; i += 3) {
                        newLeft += THOUSAND_SEPARATOR + left.substring(i, i + 3);
                    }
                    value = newLeft + right;
                    //---- avoid "-," problem ----
                    if (value.startsWith("-,")) {
                        value = "-" + value.substr(2);
                    }
                }
            }
            return (value.toString());
        }
        formatters.commaOnly = commaOnly;
        function createCommaFormatter(numDecimals) {
            return function (value) {
                return comma(value, numDecimals);
            };
        }
        formatters.createCommaFormatter = createCommaFormatter;
        //---- format a number as a percentage ----
        function percent(value, numDecimalPlaces) {
            //---- convert to a number, if possible ----
            var num = parseFloat(value);
            if (vp.utils.isNumber(num)) {
                value = 100 * num;
                value = comma(value, numDecimalPlaces) + "%";
            }
            return value;
        }
        formatters.percent = percent;
        //---- format a number as a dollar amount (US only for now) ----
        function dollar(value, numDecimalPlaces) {
            if (numDecimalPlaces === undefined) {
                numDecimalPlaces = 2;
            }
            //---- convert to a number, if possible ----
            var num = parseFloat(value);
            if (vp.utils.isNumber(num)) {
                value = "$" + comma(value, numDecimalPlaces, true);
            }
            return value;
        }
        formatters.dollar = dollar;
        //---- format a number in scientific notation ----
        function scientific(value, numDecimalPlaces) {
            //---- convert to a number, if possible ----
            var num = parseFloat(value);
            if (vp.utils.isNumber(num)) {
                if (numDecimalPlaces === undefined) {
                    value = num.toExponential(2);
                }
                else {
                    value = num.toExponential(numDecimalPlaces);
                }
            }
            return value;
        }
        formatters.scientific = scientific;
        function date(value) {
            var date;
            if (!(value instanceof Date)) {
                date = new Date(value);
            }
            else {
                date = value;
            }
            //---- for now, hard code to year ----
            var str = date.getFullYear();
            return str;
        }
        formatters.date = date;
        function string(value) {
            return value + ""; // ensure it is a string
        }
        formatters.string = string;
        /// format a number nicely (shortest decimal possible, add commas for thousands).
        function format(value) {
            if (vp.utils.isNumber(value)) {
                value = comma(value);
            }
            return value;
        }
        formatters.format = format;
        /**
         *  return a subset of "text" that doesn't exceed "maxLength".
         * @param text
         * @param maxLength
         * @param addEllipses
         * @param fakeLabel can be SVGTextElement or HTMLElement
         * @param ellipsesWidth
         */
        function truncateText(text, maxLength, addEllipses, fakeLabel, ellipsesWidth) {
            var newStr = "";
            //---- first, see if whole text fits ----
            fakeLabel.textContent = text;
            var rc = vp.dom.getBounds(fakeLabel); // .getBBox();
            if (rc.width <= maxLength) {
                newStr = text;
            }
            else {
                if (addEllipses) {
                    //---- leave space for elippses ----
                    maxLength -= ellipsesWidth;
                }
                //---- do a binary search on the best string ----
                var low = 0;
                var high = text.length - 1;
                while (low <= high) {
                    var next = Math.floor((high + low) / 2);
                    var testStr = text.substr(0, next);
                    fakeLabel.textContent = testStr;
                    var rc = vp.dom.getBounds(fakeLabel); //.getBBox();
                    if (rc.width > maxLength) {
                        high = next - 1;
                    }
                    else {
                        low = next + 1;
                        newStr = testStr;
                    }
                }
                if (addEllipses) {
                    newStr += "...";
                }
            }
            return newStr;
        }
        formatters.truncateText = truncateText;
    })(formatters = vp.formatters || (vp.formatters = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// excelFormatter.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlot library 
///   - formats values using a simplified interpretation of an excel formatting string.  Used when we are running independent
///     of Excel (otherwise, we use Excel to format the values directly).
///
///   - one of the simplications that we do: we ignore locale-aware strings (all US formatting).
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var formatters;
    (function (formatters) {
        var monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October",
            "November", "December"];
        var monthAbbrevs = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        var dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        var dayAbbrevs = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        function N2(n) {
            var str = +n + "";
            if (str.length < 2) {
                str = "0" + str;
            }
            return str;
        }
        function getHours(hours, ampm) {
            if (ampm) {
                if (hours == 0) {
                    hours = 12;
                }
                else if (hours > 12) {
                    hours = hours - 12;
                }
            }
            return hours;
        }
        /** Formats a number as a date or time, according to the specified 'format' string.  Example
        formats:  m/dd/yyyy, mmm-yy, hh:mm:ss AM/PM. */
        function formatDateTime(value, format) {
            var index = 0;
            var output = "";
            var ampm = format.contains("AM/PM");
            var hours = 0;
            var date;
            if (!(value instanceof Date)) {
                date = new Date(value);
            }
            else {
                date = value;
            }
            while (index < format.length) {
                var fmt = format.substr(index);
                if (fmt.startsWith("mmmm")) {
                    //---- full month name ----
                    var str = monthNames[date.getMonth()];
                    output += str;
                    index += 4;
                }
                else if (fmt.startsWith("mmm")) {
                    //---- 3 letter month abbreviaton ----
                    var str = monthAbbrevs[date.getMonth()];
                    output += str;
                    index += 3;
                }
                else if (fmt.startsWith("mm")) {
                    //---- 2 digit minutes ----
                    var str = N2(date.getMinutes());
                    output += str;
                    index += 2;
                }
                else if (fmt.startsWith("m")) {
                    //---- 1-2 digit day month number (1-relative) ----
                    var str = (date.getMonth() + 1) + "";
                    output += str;
                    index += 1;
                }
                else if (fmt.startsWith("q")) {
                    //---- 1 digit QUARTER number (1-relative) ----
                    var str = (Math.floor(date.getMonth() / 3) + 1) + "";
                    output += str;
                    index += 1;
                }
                else if (fmt.startsWith("dddd")) {
                    //---- full day of week ----
                    var str = dayNames[date.getDay()];
                    output += str;
                    index += 4;
                }
                else if (fmt.startsWith("ddd")) {
                    //---- 3 letter day abbreviaton ----
                    var str = dayAbbrevs[date.getDay()];
                    output += str;
                    index += 3;
                }
                else if (fmt.startsWith("dd")) {
                    //---- 2 digit day-of-month ----
                    var str = N2(date.getDate());
                    output += str;
                    index += 2;
                }
                else if (fmt.startsWith("d")) {
                    //---- 1-2 digit day of month ----
                    var str = date.getDate() + "";
                    output += str;
                    index += 1;
                }
                else if (fmt.startsWith("yyyy")) {
                    //---- 4 digit year ----
                    var str = date.getFullYear() + "";
                    output += str;
                    index += 4;
                }
                else if (fmt.startsWith("yy")) {
                    //---- 2 digit year----
                    var str = (date.getFullYear() + "").substr(2); // drop first 2 chars
                    output += str;
                    index += 3;
                }
                else if (fmt.startsWith(".0")) {
                    //---- milliseconds as fraction ----
                    var str = (date.getMilliseconds() / 1000) + "";
                    output += str;
                    index += 2;
                }
                else if (fmt.startsWith("ss")) {
                    //---- 2 digit seconds ----
                    var str = N2(date.getSeconds());
                    output += str;
                    index += 2;
                }
                else if (fmt.startsWith("s")) {
                    //---- 1-2 digit seconds ----
                    var str = date.getSeconds() + "";
                    output += str;
                    index += 1;
                }
                else if (fmt.startsWith("hh")) {
                    //---- 2 digit hours ----
                    hours = date.getHours();
                    var hrs = getHours(hours, ampm);
                    var str = N2(hrs);
                    output += str;
                    index += 2;
                }
                else if (fmt.startsWith("h")) {
                    //---- 1-2 digit hours ----
                    hours = date.getHours();
                    var hrs = getHours(hours, ampm);
                    var str = hrs + "";
                    output += str;
                    index += 1;
                }
                else if (fmt.startsWith("AM/PM")) {
                    //---- AM/PM indicator ----
                    var str = (hours > 11) ? "PM" : "AM";
                    output += str;
                    index += 5;
                }
                else {
                    //---- copy a literal char ----
                    output += fmt[0];
                    index += 1;
                }
            }
            return output;
        }
        formatters.formatDateTime = formatDateTime;
        function getDecimalDigits(fmt) {
            var digits = 0;
            var index = fmt.indexOf('.');
            if (index > -1) {
                index++;
                while (index < fmt.length) {
                    if (fmt[index] == '0') {
                        digits++;
                        index++;
                    }
                    else {
                        break;
                    }
                }
            }
            return digits;
        }
        function formatByType(value, valueType) {
            var str = null;
            if (valueType == "date") {
                str = formatDateTime(value, "m/dd/yyyy hh:mm:ss AM/PM");
            }
            else if (valueType == "number") {
                str = formatters.comma(value);
            }
            else {
                str = value;
            }
            return str;
        }
        formatters.formatByType = formatByType;
        /** Formats a number according to the specified 'format' string (a simplified version of an Excel numeric
        formatting string).  Example formats:  0, #,##0.000, $#,##0.00 */
        function formatNumber(value, format) {
            var index = 0;
            var output = "";
            var hasComma = format.contains(",");
            var hasDollar = format.contains("$");
            var hasPercent = format.contains("%");
            var hasDecimal = format.contains(".");
            var decimalDigits = getDecimalDigits(format);
            var fmt = format;
            value = +value; // ensure its a number
            if (fmt.contains("E+00")) {
                //---- scientific notation ----
                var str = value.toExponential(decimalDigits);
                index += 4;
            }
            else if (hasPercent) {
                value = value * 100;
                str = value.toFixed(decimalDigits);
            }
            else if (hasComma) {
                str = vp.formatters.comma(value, decimalDigits, true);
            }
            else {
                str = value.toFixed(decimalDigits);
            }
            if (hasDecimal && decimalDigits == 0) {
                str += ".";
            }
            if (hasDollar) {
                str = "$" + str;
            }
            if (hasPercent) {
                str += "%";
            }
            output += str;
            return output;
        }
        formatters.formatNumber = formatNumber;
        function createNumFormatterFromRange(minValue, maxValue, steps) {
            if (steps === void 0) { steps = 2; }
            var numDecimals = 2;
            var range = maxValue - minValue;
            if (range > steps) {
                numDecimals = 0;
            }
            //---- TODO: increase decimals as range gets smaller ----
            var formatter = formatters.createCommaFormatter(numDecimals);
            return formatter;
        }
        formatters.createNumFormatterFromRange = createNumFormatterFromRange;
        function createDateFormatterFromRange(minDate, maxDate, steps) {
            if (steps === void 0) { steps = 2; }
            /// formats: m/dd/yyyy, mmm-yy, hh:mm:ss AM/PM. */
            var msPerDay = 86400000;
            var msPerYear = 365 * msPerDay;
            var format = "yyyy";
            var duration = maxDate - minDate;
            var years = duration / msPerYear;
            if (years > 1) {
                if (years >= steps) {
                    //---- year is sufficient ----
                    format = "yyyy";
                }
                else {
                    //---- month and year ----
                    format = "mmm-yyyy";
                }
            }
            else {
                var days = years * 365;
                if (days >= steps) {
                    //---- date is sufficient ----
                    format = "m/dd/yyyy";
                }
                else if (days > 1) {
                    //---- date + hour ----
                    format = "m/dd/yyyy hh AM/PM";
                }
                else {
                    var secs = duration / 1000;
                    if (secs >= steps) {
                        //---- time is sufficient ----
                        format = "hh:mm:ss AM/PM";
                    }
                    else {
                        //---- time + MS ----
                        format = "hh:mm:ss.0";
                    }
                }
            }
            var formatter = createExcelFormatter(format, "date");
            return formatter;
        }
        formatters.createDateFormatterFromRange = createDateFormatterFromRange;
        function createExcelFormatter(formatString, colType) {
            var formatFunc = null;
            var external = window.external;
            //---- force VS debugger to open when hosted by Excel ----
            //---- for this to work: uncheck BOTH advanced "browsing" options about "disable script debugging" ----
            //var dummy;
            //var b = dummy.foo.bar;
            //---- is Excel available, for more accurate formatting? ----
            if (external && external.isHostedInExcel) {
                //---- use EXCEL HOST to format ----
                formatFunc = function (value) {
                    return external.formatValueWithExcel(value, formatString);
                };
            }
            else {
                //---- local formatting ----
                if (!formatString || formatString == "General") {
                    if (colType == "number") {
                        formatFunc = function (value) {
                            // Add the commas, but leave the full precision [ie. display the full mantissa] 
                            return vp.formatters.commaOnly(value);
                        };
                    }
                }
                else {
                    if (colType == "number") {
                        formatFunc = function (value) {
                            return vp.formatters.formatNumber(value, formatString);
                        };
                    }
                    else if (colType == "date") {
                        formatFunc = function (value) {
                            return vp.formatters.formatDateTime(value, formatString);
                        };
                    }
                }
                if (!formatFunc) {
                    //---- NO-OP function ----
                    formatFunc = function (value) {
                        return value;
                    };
                }
            }
            formatFunc._formatString = formatString;
            formatFunc._colType = colType;
            return formatFunc;
        }
        formatters.createExcelFormatter = createExcelFormatter;
    })(formatters = vp.formatters || (vp.formatters = {}));
})(vp || (vp = {}));
//-----------------------------------------------------------------------------------------------------------------
// BasicTypes.ts    Copyright 2014 Microsoft Corporation.
//-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var geom;
    (function (geom) {
        /// aka "SVGRect".
        var rectLight = (function () {
            function rectLight(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            return rectLight;
        }());
        geom.rectLight = rectLight;
    })(geom = vp.geom || (vp.geom = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// matrix4.ts.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlotCore library - a 4x4 matrix class.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var geom;
    (function (geom) {
        /// matrix4 class.
        /// formulas in matrix4 adapted from various Microsoft code:
        ///     - DxCodePack project: http://archive.msdn.microsoft.com/WindowsAPICodePack) File: D3DCommonStructs.h
        ///     - Microsoft DirectX docs: http://msdn.microsoft.com/en-us/library/windows/desktop/bb205351%28v=vs.85%29.aspx
        ///     - XnaMathMatrix.inl (Microsoft SDK file)
        ///     - Microsoft WPF (Orcas release): \Core\CSharp\System\Windows\Media3D\Matrix3D.cs\1\Matrix3D.cs (line 1285) 
        /// Note: WebGL uses a right-hand coordinate system (with positive z axis coming towards viewer), so shapes should
        /// be placed in the negative z space.  
        ///
        /// Dec-05/2014 - just verified that WebGL IS a RIGHT HAND system.  
        /// Camera goes in positive Z, object go in negative Z. And triangles on the "front" of an object wind COUNTER-CLOCKWISE. Also,
        /// matricies are multiplied in reverse order (right to left) to apply transformations in a RIGHT HAND system.  Wierd.
        ///
        /// from: http://stackoverflow.com/questions/6118996/matrix-mult-order-in-direct3d
        /// The fundamental difference between OpenGL and DirectX arises from the fact that OpenGL treats matrices in column major order,
        /// while DirectX treats matrics in row major order.
        var matrix4 = (function () {
            function matrix4() {
                //if (typeof Float32Array == 'undefined')
                //{
                //    this.mat = new Array(16);
                //}
                //else
                //{  
                //    this.mat = new Float32Array(16);
                //}
                //---- we want calling code to be able to treat this as an array ----
                var self = this;
                //---- add array support ----
                this.length = 16;
                self.push = Array.prototype.push;
                self.splice = Array.prototype.splice;
                self.indexOf = Array.prototype.indexOf;
                self.map = Array.prototype.map;
                self.select = Array.prototype.select;
            }
            matrix4.prototype.toArray = function () {
                var result = [];
                for (var i = 0; i < this.length; i++) {
                    result[i] = this[i];
                }
                return result;
            };
            matrix4.prototype.toFloat32Array = function () {
                var result = new Float32Array(this.length);
                for (var i = 0; i < this.length; i++) {
                    result[i] = this[i];
                }
                return result;
            };
            matrix4.fromFloats = function (m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
                var mat = new matrix4();
                mat[0] = m11;
                mat[1] = m12;
                mat[2] = m13;
                mat[3] = m14;
                mat[4] = m21;
                mat[5] = m22;
                mat[6] = m23;
                mat[7] = m24;
                mat[8] = m31;
                mat[9] = m32;
                mat[10] = m33;
                mat[11] = m34;
                mat[12] = m41;
                mat[13] = m42;
                mat[14] = m43;
                mat[15] = m44;
                return mat;
            };
            matrix4.identity = function () {
                var mat = new matrix4();
                //---- build identity matrix ----
                mat[0] = 1; // M11
                mat[1] = 0; // M12
                mat[2] = 0; // M13
                mat[3] = 0; // M14
                mat[4] = 0; // M21
                mat[5] = 1; // M22
                mat[6] = 0; // M23
                mat[7] = 0; // M24
                mat[8] = 0; // M31
                mat[9] = 0; // M32
                mat[10] = 1; // M33
                mat[11] = 0; // M34
                mat[12] = 0; // M41
                mat[13] = 0; // M42
                mat[14] = 0; // M43
                mat[15] = 1; // M44
                return mat;
            };
            matrix4.transpose = function (m) {
                var b = matrix4.identity();
                b[0] = m[0];
                b[1] = m[4];
                b[2] = m[8];
                b[3] = m[12];
                b[4] = m[1];
                b[5] = m[5];
                b[6] = m[9];
                b[7] = m[13];
                b[8] = m[2];
                b[9] = m[6];
                b[10] = m[10];
                b[11] = m[14];
                b[12] = m[3];
                b[13] = m[7];
                b[14] = m[11];
                b[15] = m[15];
                return b;
            };
            matrix4.toMat3Array = function (m) {
                var b = new Float32Array(9);
                b[0] = m[0];
                b[1] = m[1];
                b[2] = m[2];
                b[3] = m[4];
                b[4] = m[5];
                b[5] = m[6];
                b[6] = m[8];
                b[7] = m[9];
                b[8] = m[10];
                return b;
            };
            matrix4.invert = function (m) {
                var b = matrix4.identity();
                var _offsetX = m[12];
                var _offsetY = m[13];
                var _offsetZ = m[14];
                // compute all six 2x2 determinants of 2nd two columns
                var y01 = m[2] * m[7] - m[6] * m[3];
                var y02 = m[2] * m[11] - m[10] * m[3];
                var y03 = m[2] * m[15] - _offsetZ * m[3];
                var y12 = m[6] * m[11] - m[10] * m[7];
                var y13 = m[6] * m[15] - _offsetZ * m[7];
                var y23 = m[10] * m[15] - _offsetZ * m[11];
                // Compute 3x3 cofactors for 1st the column 
                var z30 = m[5] * y02 - m[9] * y01 - m[1] * y12;
                var z20 = m[1] * y13 - m[5] * y03 + _offsetY * y01;
                var z10 = m[9] * y03 - _offsetY * y02 - m[1] * y23;
                var z00 = m[5] * y23 - m[9] * y13 + _offsetY * y12;
                // Compute 4x4 determinant 
                var det = _offsetX * z30 + m[8] * z20 + m[4] * z10 + m[0] * z00;
                // If Determinant is computed using a different method then Inverse can throw 
                // NotInvertable when HasInverse is true.  (Windows OS #901174)
                //
                var epsilon = .0000001; // .0001;
                if (Math.abs(det) > epsilon) {
                    // Compute 3x3 cofactors for the 2nd column
                    var z31 = m[0] * y12 - m[4] * y02 + m[8] * y01;
                    var z21 = m[4] * y03 - _offsetX * y01 - m[0] * y13;
                    var z11 = m[0] * y23 - m[8] * y03 + _offsetX * y02;
                    var z01 = m[8] * y13 - _offsetX * y12 - m[4] * y23;
                    // Compute all six 2x2 determinants of 1st two columns 
                    y01 = m[0] * m[5] - m[4] * m[1];
                    y02 = m[0] * m[9] - m[8] * m[1];
                    y03 = m[0] * _offsetY - _offsetX * m[1];
                    y12 = m[4] * m[9] - m[8] * m[5];
                    y13 = m[4] * _offsetY - _offsetX * m[5];
                    y23 = m[8] * _offsetY - _offsetX * m[9];
                    // Compute all 3x3 cofactors for 2nd two columns
                    var z33 = m[2] * y12 - m[6] * y02 + m[10] * y01;
                    var z23 = m[6] * y03 - _offsetZ * y01 - m[2] * y13;
                    var z13 = m[2] * y23 - m[10] * y03 + _offsetZ * y02;
                    var z03 = m[10] * y13 - _offsetZ * y12 - m[6] * y23;
                    var z32 = m[7] * y02 - m[11] * y01 - m[3] * y12;
                    var z22 = m[3] * y13 - m[7] * y03 + m[15] * y01;
                    var z12 = m[11] * y03 - m[15] * y02 - m[3] * y23;
                    var z02 = m[7] * y23 - m[11] * y13 + m[15] * y12;
                    var rcp = 1.0 / det;
                    // Multiply all 3x3 cofactors by reciprocal & transpose
                    b[0] = z00 * rcp;
                    b[1] = z10 * rcp;
                    b[2] = z20 * rcp;
                    b[3] = z30 * rcp;
                    b[4] = z01 * rcp;
                    b[5] = z11 * rcp;
                    b[6] = z21 * rcp;
                    b[7] = z31 * rcp;
                    b[8] = z02 * rcp;
                    b[9] = z12 * rcp;
                    b[10] = z22 * rcp;
                    b[11] = z32 * rcp;
                    b[12] = z03 * rcp;
                    b[13] = z13 * rcp;
                    b[14] = z23 * rcp;
                    b[15] = z33 * rcp;
                }
                return b;
            };
            //---- returns a matrix that does an orthographic projection (RIGHT HAND) ----
            matrix4.createOrthographic = function (width, height, nearPlane, farPlane) {
                var zn = nearPlane;
                var zf = farPlane;
                var m22 = 1 / (zn - zf);
                var m32 = zn * m22;
                var mat = matrix4.fromFloats(2 / width, 0, 0, 0, // first row
                0, 2 / height, 0, 0, // second row
                0, 0, m22, 0, // third row   (added minus sign based on comparison to XNA)
                0, 0, m32, 1); // forth row
                return mat;
            };
            //---- returns a matrix that does an orthographic projection (RIGHT HAND) ----
            //---- note: the directx formula we use has different values in the z-scale and z-translation terms ----
            //---- as compared to results from gl-matrix.js. ----
            matrix4.createOrthographicOffCenter = function (left, right, bottom, top, near, far) {
                var mat = matrix4.fromFloats(2 / (right - left), 0, 0, 0, // first row
                0, 2 / (top - bottom), 0, 0, // second row
                0, 0, 1 / (near - far), 0, // third row
                (left + right) / (left - right), (top + bottom) / (bottom - top), near / (near - far), 1); // forth row
                return mat;
            };
            /// creates a RIGHT-HANDED view matrix  (the location and direction of the camera)
            /// "eyePos" is the camera location
            /// "lookAt" is the location that the camera is pointed
            /// "up" is a vector from the center to the top of the camera 
            ///
            /// corrected on 12/10/2014 to match directx formula:
            ///  http://msdn.microsoft.com/en-us/library/windows/desktop/bb281711(v=vs.85).aspx
            ///
            matrix4.createLookAt = function (eyePos, lookAt, up) {
                var zaxis = geom.vector3.normal(geom.vector3.subtract(eyePos, lookAt));
                var xaxis = geom.vector3.normal(geom.vector3.cross(up, zaxis));
                var yaxis = geom.vector3.cross(zaxis, xaxis);
                var mat = matrix4.fromFloats(xaxis.x, yaxis.x, zaxis.x, 0, xaxis.y, yaxis.y, zaxis.y, 0, xaxis.z, yaxis.z, zaxis.z, 0, -geom.vector3.dot(xaxis, eyePos), -geom.vector3.dot(yaxis, eyePos), -geom.vector3.dot(zaxis, eyePos), 1);
                return mat;
            };
            // confirmed with mark finch that "0" as last element in perspective matrices is correct (rfernand 12/18/2014).
            matrix4.createPerspectiveRH = function (width, height, zNear, zFar) {
                var mat = matrix4.fromFloats(2 * zNear / width, 0, 0, 0, 0, 2 * zNear / height, 0, 0, 0, 0, zFar / (zNear - zFar), -1, 0, 0, zNear * zFar / (zNear - zFar), 0);
                return mat;
            };
            /// "fov" is the field of view in the y direction, in radians.
            // confirmed with mark finch that "0" as last element in perspective matrices is correct (rfernand 12/18/2014).
            //---- correction for OPEN-GL from mark finch, 12/18/2014 (so we apply to webgl) ----
            // M[2, 2] = -(far + near) / (far – near)
            // M[3, 2] = -(2.0 * far * near) / (far – near)
            matrix4.createPerspectiveFovRH = function (fovY, aspect, zNear, zFar) {
                var yScale = 1 / Math.tan(fovY / 2); // cot(fovY/2)
                var xScale = yScale / aspect;
                /// 02/04/2015 rfernand: as per Mark Finch.
                var mat = matrix4.fromFloats(xScale, 0, 0, 0, 0, yScale, 0, 0, 0, 0, -(zFar + zNear) / (zFar - zNear), -1, // mark finch
                0, 0, -(2 * zFar * zNear) / (zFar - zNear), 0); // mark finch     
                return mat;
            };
            /** WARNING: do NOT use this for WebGL (use RH).
            "fov" is the field of view in the y direction, in radians. */
            matrix4.createPerspectiveFovLH = function (fovY, aspect, zNear, zFar) {
                var yScale = 1 / Math.tan(fovY / 2); // cot(fovY/2)
                var xScale = yScale / aspect;
                /// 02/04/2015 rfernand: as per XNA 4 code (differs from DirectX 9 docs).
                var mat = matrix4.fromFloats(xScale, 0, 0, 0, 0, yScale, 0, 0, 0, 0, zFar / (zNear - zFar), -1, 0, 0, (zNear * zFar) / (zNear - zFar), 0);
                return mat;
            };
            // confirmed with mark finch that "0" as last element in perspective matrices is correct (rfernand 12/18/2014).
            matrix4.createPerspectiveOffCenterRH = function (left, right, bottom, top, zNear, zFar) {
                var mat = matrix4.fromFloats(2 * zNear / (right - left), 0, 0, 0, 0, 2 * zNear / (top - bottom), 0, 0, (left + right) / (right - left), (top + bottom) / (top - bottom), zFar / (zNear - zFar), -1, 0, 0, 2 * zNear * zFar / (zNear - zFar), 0);
                return mat;
            };
            //---- multiply matrix and a vector ----
            //---- do NOT use this to transform a point - for webGL, we want v * m  (not m*v) ----
            matrix4.multiplyVector = function (m, v) {
                var x = v.x;
                var y = v.y;
                var z = v.z;
                var w = v.w;
                var x = m[0] * x + m[1] * y + m[2] * z + m[3] * w;
                var y = m[4] * x + m[5] * y + m[6] * z + m[7] * w;
                var z = m[8] * x + m[9] * y + m[10] * z + m[11] * w;
                var w = m[12] * x + m[13] * y + m[14] * z + m[15] * w;
                var result = new geom.vector4(x, y, z, w);
                return result;
            };
            //---- multiply 2 matrices ----
            matrix4.multiply = function (a, b) {
                var mat = matrix4.fromFloats(a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12], // m[0]
                a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13], // m[1]
                a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14], // m[2]
                a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15], // m[3]
                a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12], // m[4]
                a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13], // m[5]
                a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14], // m[6]
                a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15], // m[7]
                a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12], // m[8]
                a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13], // m[9]
                a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14], // m[10]
                a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15], // m[11]
                a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12], // m[12]
                a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13], // m[13]
                a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14], // m[14]
                a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]); // m[15]
                return mat;
            };
            /** Note: this function treats "v" as if it were a vector4 (with 4th component=1). It
            performs the multipication:  v * mat    (not the reverse).
            NOTE: we return a vector4 so the call has a chance to use the returned v.w value, which
            sometimes should be used to scale the xyz value (1/w), like when you have the mat includes
            a projection component.  */
            matrix4.transformPoint = function (mat, v) {
                var x = v.x;
                var y = v.y;
                var z = v.z;
                var w = 1;
                var newX = x * mat[0] + y * mat[4] + z * mat[8] + w * mat[12];
                var newY = x * mat[1] + y * mat[5] + z * mat[9] + w * mat[13];
                var newZ = x * mat[2] + y * mat[6] + z * mat[10] + w * mat[14];
                var newW = x * mat[3] + y * mat[7] + z * mat[11] + w * mat[15];
                return new geom.vector4(newX, newY, newZ, newW);
            };
            /** taken from: http://msdn.microsoft.com/en-us/library/microsoft.xna.framework.matrix.aspx */
            matrix4.createTranslation = function (x, y, z) {
                //---- values get put into M41, M42, M43 (all on 4th row, M[12-14]) ----
                var mat = matrix4.identity();
                mat[12] = x;
                mat[13] = y;
                mat[14] = z;
                return mat;
            };
            matrix4.createScale = function (x, y, z) {
                var mat = matrix4.identity();
                mat[0] = x;
                mat[5] = y;
                mat[10] = z;
                return mat;
            };
            /**Returns a matrix that does a rotation about the X axis by the specified angle in radians. */
            matrix4.createRotationX = function (angle) {
                var mat = matrix4.fromFloats(1, 0, 0, 0, 0, Math.cos(angle), -Math.sin(angle), 0, 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1);
                return mat;
            };
            /**Returns a matrix that does a rotation about the Y axis by the specified angle in radians. */
            matrix4.createRotationY = function (angle) {
                var mat = matrix4.fromFloats(Math.cos(angle), 0, Math.sin(angle), 0, 0, 1, 0, 0, -Math.sin(angle), 0, Math.cos(angle), 0, 0, 0, 0, 1);
                return mat;
            };
            /**Returns a matrix that does a rotation about the Z axis by the specified angle in radians. */
            matrix4.createRotationZ = function (angle) {
                var mat = matrix4.fromFloats(Math.cos(angle), -Math.sin(angle), 0, 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                return mat;
            };
            /**Returns a matrix that does a rotation about the Z axis by the specified angle in radians. */
            matrix4.createAxisRotation = function (theta, axis) {
                theta = -theta; // formula was off here
                var c = Math.cos(theta);
                var s = Math.sin(theta);
                var t = 1 - c;
                var x = axis[0];
                var y = axis[1];
                var z = axis[2];
                var mat = matrix4.fromFloats(t * x * x + c, t * x * y + s * z, t * x * z - s * y, 0, t * x * y - s * z, t * y * y + c, t * y * z + s * x, 0, t * x * z + s * y, t * y * z - s * x, t * z * z + c, 0, 0, 0, 0, 1);
                return mat;
            };
            /** Returns a matrix that rotates about the z (yaw), y (pitch), and x (roll) axes.  All
            angles are specified in radians. */
            matrix4.createFromYawPitchRoll = function (yaw, pitch, roll) {
                var mz = matrix4.createRotationZ(yaw);
                var my = matrix4.createRotationY(pitch);
                var mx = matrix4.createRotationX(roll);
                var mat = mz;
                mat = matrix4.multiply(mat, my);
                mat = matrix4.multiply(mat, mx);
                return mat;
            };
            return matrix4;
        }());
        geom.matrix4 = matrix4;
    })(geom = vp.geom || (vp.geom = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// point2.ts.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlotCore library - a 2 dim point class.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var geom;
    (function (geom) {
        var point2 = (function () {
            function point2(x, y) {
                this.x = (x === undefined) ? 0 : x;
                this.y = (y === undefined) ? 0 : y;
            }
            return point2;
        }());
        geom.point2 = point2;
        function createPoint2(x, y) {
            return new point2(x, y);
        }
        geom.createPoint2 = createPoint2;
    })(geom = vp.geom || (vp.geom = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// point3.ts.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlotCore library - a 3 dim point class.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var geom;
    (function (geom) {
        var point3 = (function () {
            function point3(x, y, z) {
                this.x = (x === undefined) ? 0 : x;
                this.y = (y === undefined) ? 0 : y;
                this.z = (z === undefined) ? 0 : z;
            }
            point3.prototype.toString = function () {
                return "point3 {x: " + this.x + ", y: " + this.y + ", z: " + this.z + "}";
            };
            return point3;
        }());
        geom.point3 = point3;
        function createPoint3(x, y, z) {
            return new point3(x, y, z);
        }
        geom.createPoint3 = createPoint3;
    })(geom = vp.geom || (vp.geom = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// rect.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - part of the vuePlot library
///     - small library of flat rectangle functions   {left, top, right, bottom, width, height}
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var geom;
    (function (geom) {
        function createRect(left, top, w, h) {
            var rc = { left: left, top: top, width: w, height: h, right: left + w, bottom: top + h };
            return rc;
        }
        geom.createRect = createRect;
        function rect(left, top, w, h) {
            return createRect(left, top, w, h);
        }
        geom.rect = rect;
        function rectToString(rc) {
            var str = "{left: " + Math.round(rc.left) + ", top: " + Math.round(rc.top)
                + ", width: " + Math.round(rc.width) + ", height: " + Math.round(rc.height) + "}";
            return str;
        }
        geom.rectToString = rectToString;
        function rectFromPoints(pt1, pt2) {
            var x = Math.min(pt1.x, pt2.x);
            var y = Math.min(pt1.y, pt2.y);
            var w = Math.abs(pt1.x - pt2.x);
            var h = Math.abs(pt1.y - pt2.y);
            var rc = { left: x, top: y, width: w, height: h, right: x + w, bottom: y + h };
            return rc;
        }
        geom.rectFromPoints = rectFromPoints;
        function rectContainsPoint(rc, pt) {
            var contains = false;
            if (pt.x >= rc.left) {
                if (pt.x <= rc.right) {
                    if (pt.y >= rc.top) {
                        if (pt.y <= rc.bottom) {
                            contains = true;
                        }
                    }
                }
            }
            return contains;
        }
        geom.rectContainsPoint = rectContainsPoint;
        /** returns true if rcInner is completely contained within rcOuter. */
        function rectContainsRect(rcOuter, rcInner) {
            var contains = false;
            if (rcInner.left >= rcOuter.left) {
                if (rcInner.right <= rcOuter.right) {
                    if (rcInner.top >= rcOuter.top) {
                        if (rcInner.bottom <= rcOuter.bottom) {
                            contains = true;
                        }
                    }
                }
            }
            return contains;
        }
        geom.rectContainsRect = rectContainsRect;
        /** returns true if rc1 overlaps in any way with rc2. */
        function rectIntersectsRect(rc1, rc2) {
            var overlaps = true;
            if (rc1.right < rc2.left) {
                overlaps = false;
            }
            else if (rc1.left > rc2.right) {
                overlaps = false;
            }
            else if (rc1.bottom < rc2.top) {
                overlaps = false;
            }
            else if (rc1.top > rc2.bottom) {
                overlaps = false;
            }
            return overlaps;
        }
        geom.rectIntersectsRect = rectIntersectsRect;
        function rectIntersectsSvgShape(rc, shape) {
            var tag = shape.tagName;
            var intersects = false;
            if (tag == "line") {
                var x1 = vp.dom.attr(shape, "x1");
                var y1 = vp.dom.attr(shape, "y1");
                var x2 = vp.dom.attr(shape, "x2");
                var y2 = vp.dom.attr(shape, "y2");
                intersects = rectIntersectsLine(rc, x1, y1, x2, y2);
            }
            else if (tag == "polygon") {
                var pts = vp.dom.attr(shape, "points");
                intersects = rectIntersectsAreaPolygon(rc, pts);
            }
            else {
                //---- use bounding box test for all other shapes ----
                var rc2 = vp.dom.getBounds(shape, true);
                intersects = vp.geom.rectIntersectsRect(rc, rc2);
            }
            return intersects;
        }
        geom.rectIntersectsSvgShape = rectIntersectsSvgShape;
        function rectIntersectsAreaPolygon(rc, pointStr) {
            var overlaps = true;
            var pts = parsePoints(pointStr);
            var x1 = pts[0].x;
            var x2 = pts[2].x;
            var y1 = pts[0].y; // left bottom
            var y2 = pts[1].y;
            var y3 = pts[2].y;
            var y4 = pts[3].y; // right bottom
            //---- try to reject based on x bounds of area ----
            var maxX = Math.max(x1, x2);
            var minX = Math.min(x1, x2);
            if (maxX < rc.left) {
                overlaps = false;
            }
            else if (minX > rc.right) {
                overlaps = false;
            }
            else {
                //--- reject based on y bounds of area ----
                var maxY = Math.max(y1, y4);
                var minY = Math.min(y2, y3);
                if (maxY < rc.top) {
                    //--- bottom of area is above top of rect ----
                    overlaps = false;
                }
                else if (minY > rc.bottom) {
                    //---- top of area is below bottom of rect ----
                    overlaps = false;
                }
                else if (x1 != x2) {
                    //---- find where TOP diagonal line (x1,y2)..(x2,y3) intersects left & right of rect ----
                    var m = (y3 - y2) / (x2 - x1);
                    var b = y3 - m * x2;
                    var yLeft = m * rc.left + b;
                    var yRight = m * rc.right + b;
                    //---- if both are below the rect, they do not intercept ----
                    if ((yLeft > rc.bottom) && (yRight > rc.bottom)) {
                        overlaps = false;
                    }
                    else {
                        //---- find where BOTTOM diagonal line (x1,y1)..(x2,y4) intersects left & right of rect ----
                        var m = (y4 - y1) / (x2 - x1);
                        var b = y4 - m * x2;
                        var yLeft = m * rc.left + b;
                        var yRight = m * rc.right + b;
                        //---- if both are above the rect, they do not intercept ----
                        if ((yLeft < rc.top) && (yRight < rc.top)) {
                            overlaps = false;
                        }
                    }
                }
            }
            return overlaps;
        }
        geom.rectIntersectsAreaPolygon = rectIntersectsAreaPolygon;
        function parsePoints(str) {
            var pts = [];
            str = str.replace(/, /g, ","); // replace all ", " chars with just comma
            str = str.replace(/  /g, " "); // replace all double spaces with a single space
            var parts = str.split(" ");
            for (var i = 0; i < parts.length; i++) {
                var pps = parts[i].split(",");
                if (pps.length != 2) {
                    vp.utils.error("unsupported point format in shape");
                }
                var pt = { x: pps[0], y: pps[1] };
                pts.push(pt);
            }
            return pts;
        }
        function rectIntersectsLine(rc, x1, y1, x2, y2) {
            var overlaps = true;
            //---- try to reject based on x bounds of line ----
            var maxX = Math.max(x1, x2);
            var minX = Math.min(x1, x2);
            if (maxX < rc.left) {
                overlaps = false;
            }
            else if (minX > rc.right) {
                overlaps = false;
            }
            else {
                //--- reject based on y bounds of line ----
                var maxY = Math.max(y1, y2);
                var minY = Math.min(y1, y2);
                if (maxY < rc.top) {
                    overlaps = false;
                }
                else if (minY > rc.bottom) {
                    overlaps = false;
                }
                else {
                    //---- find where line intersects left & right of rect ----
                    var m = (y2 - y1) / (x2 - x1);
                    var b = y2 - m * x2;
                    var yLeft = m * rc.left + b;
                    var yRight = m * rc.right + b;
                    //---- if both are ABOVE the rect, they do not intercept ----
                    if ((yLeft < rc.top) && (yRight < rc.top)) {
                        overlaps = false;
                    }
                    //---- if both are BELOW the rect, they do not intercept ----
                    if ((yLeft > rc.bottom) && (yRight > rc.bottom)) {
                        overlaps = false;
                    }
                }
            }
            return overlaps;
        }
        geom.rectIntersectsLine = rectIntersectsLine;
        function offsetRect(rc, xoff, yoff) {
            var x = rc.left + xoff;
            var y = rc.top + yoff;
            var w = rc.width;
            var h = rc.height;
            return { left: x, top: y, width: w, height: h, right: x + w, bottom: y + h };
        }
        geom.offsetRect = offsetRect;
    })(geom = vp.geom || (vp.geom = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// vector2.ts.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlotCore library - a 2 dim vector class.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var geom;
    (function (geom) {
        var vector2 = (function () {
            function vector2(x, y) {
                this.x = (x === undefined) ? 0 : x;
                this.y = (y === undefined) ? 0 : y;
            }
            vector2.add = function (v, v2) {
                var vNew = new vector2(v.x + v2.x, v.y + v2.y);
                return vNew;
            };
            vector2.subtract = function (v, v2) {
                var vNew = new vector2(v.x - v2.x, v.y - v2.y);
                return vNew;
            };
            vector2.multiply = function (v, s) {
                var vNew = new vector2(v.x * s, v.y * s);
                return vNew;
            };
            vector2.dot = function (v, v2) {
                var sum = v.x * v2.x + v.y * v2.y;
                return sum;
            };
            /// return the normalized vector.
            vector2.normal = function (v) {
                var magnitude = Math.sqrt((v.x * v.x) + (v.y * v.y));
                var vNew = new vector2(v.x / magnitude, v.y / magnitude);
                return vNew;
            };
            return vector2;
        }());
        geom.vector2 = vector2;
        function createVector2(x, y) {
            return new vector2(x, y);
        }
        geom.createVector2 = createVector2;
    })(geom = vp.geom || (vp.geom = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// vector3.ts.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlotCore library - a 3 dim vector class.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var geom;
    (function (geom) {
        var vector3 = (function () {
            function vector3(x, y, z) {
                this.x = (x === undefined) ? 0 : x;
                this.y = (y === undefined) ? 0 : y;
                this.z = (z === undefined) ? 0 : z;
            }
            vector3.add = function (v, v2) {
                var vNew = new vector3(v.x + v2.x, v.y + v2.y, v.z + v2.z);
                return vNew;
            };
            vector3.magnitude = function (v) {
                var mag = Math.sqrt((v.x * v.x) + (v.y * v.y) + (v.z * v.z));
                return mag;
            };
            vector3.subtract = function (v, v2) {
                var vNew = new vector3(v.x - v2.x, v.y - v2.y, v.z - v2.z);
                return vNew;
            };
            vector3.multiply = function (v, s) {
                var vNew = new vector3(v.x * s, v.y * s, v.z * s);
                return vNew;
            };
            vector3.cross = function (v, v2) {
                var vNew = new vector3();
                vNew.x = v.y * v2.z - v.z * v2.y;
                vNew.y = v.z * v2.x - v.x * v2.z;
                vNew.z = v.x * v2.y - v.y * v2.x;
                return vNew;
            };
            vector3.dot = function (v, v2) {
                var sum = v.x * v2.x + v.y * v2.y + v.z * v2.z;
                return sum;
            };
            /// return the normalized vector.
            vector3.normal = function (v) {
                var magnitude = Math.sqrt((v.x * v.x) + (v.y * v.y) + (v.z * v.z));
                var vNew = new vector3(v.x / magnitude, v.y / magnitude, v.z / magnitude);
                return vNew;
            };
            /// return the vector normal to 3 points.
            vector3.normalToPoints = function (pt1, pt2, pt3) {
                var v1 = new vector3(pt2.x - pt1.x, pt2.y - pt1.y, pt2.z - pt1.z);
                var v2 = new vector3(pt3.x - pt2.x, pt3.y - pt2.y, pt3.z - pt1.z);
                var vNew = vector3.cross(v1, v2);
                return vNew;
            };
            vector3.zero = function () {
                return new vector3(0, 0, 0);
            };
            vector3.up = function () {
                return new vector3(0, 1, 0);
            };
            vector3.prototype.toString = function () {
                return "vector3 {x: " + this.x + ", y: " + this.y + ", z: " + this.z + "}";
            };
            return vector3;
        }());
        geom.vector3 = vector3;
        function createVector3(x, y, z) {
            return new vector3(x, y, z);
        }
        geom.createVector3 = createVector3;
    })(geom = vp.geom || (vp.geom = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// vector4.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - a set of flat functions for 3d vector support.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var geom;
    (function (geom) {
        var vector4 = (function () {
            function vector4(x, y, z, w) {
                this.x = (x === undefined) ? 0 : x;
                this.y = (y === undefined) ? 0 : y;
                this.z = (z === undefined) ? 0 : z;
                this.w = (w === undefined) ? 0 : w;
            }
            vector4.add = function (v, v2) {
                var vNew = new vector4(v.x + v2.x, v.y + v2.y, v.z + v2.z, v.w + v2.w);
                return vNew;
            };
            vector4.subtract = function (v, v2) {
                var vNew = new vector4(v.x - v2.x, v.y - v2.y, v.z - v2.z, v.w - v2.w);
                return vNew;
            };
            vector4.multiply = function (v, s) {
                var vNew = new vector4(v.x * s, v.y * s, v.z * s, v.w * s);
                return vNew;
            };
            ///// 
            //static cross(v, v2): vector4
            //{
            //    var x = v.y * v2.z - v.z * v2.y;
            //    var y = v.z * v2.x - v.x * v2.z;
            //    var z = v.x * v2.y - v.y * v2.x;
            //    var w = 1;          // ??
            //    return new vector4(x, y, z, w);
            //}
            vector4.dot = function (v, v2) {
                var sum = v.x * v2.x + v.y * v2.y + v.z * v2.z + v.w * v2.w;
                return sum;
            };
            /// return the normalized vector.
            vector4.normal = function (v) {
                var magnitude = Math.sqrt((v.x * v.x) + (v.y * v.y) + (v.z * v.z) + (v.w * v.w));
                var vNew = new vector4(v.x / magnitude, v.y / magnitude, v.z / magnitude, v.w / magnitude);
                return vNew;
            };
            vector4.zero = function () {
                return new vector4(0, 0, 0, 0);
            };
            return vector4;
        }());
        geom.vector4 = vector4;
    })(geom = vp.geom || (vp.geom = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// markBase.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - data-based generation "mark" base class.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** Base class for all other mark classes. */
        var markBaseClass = (function () {
            /** "container" can be null, a string ("svg", "canvas", or "webGl"), or a container (SVG doc, SVG "g", Canvas element,
            or a canvas group element).  "shapeName" is name of the shape when an SVG or Canavas container is used.
            "glShapeName" is the name of the associated vuePlot webGl shape. */
            function markBaseClass(container, shapeName, glShapeName, useWebGl, className) {
                //super(container);
                this._seriesIndex = 0;
                this._seriesCount = 1;
                this._onShaderCallback = null;
                this._data = [0];
                this._fromGlParams = null;
                this._computedStyle = undefined;
                this._isVisible = true;
                this._firstShow = true;
                this._showOpacity = 1;
                var result = this.createContainerIfNeeded(container);
                container = result.container;
                useWebGl = (result.useWebGl !== undefined) ? result.useWebGl : useWebGl;
                this._container = container;
                //this.elem = container;
                this._shapeName = shapeName;
                this._glShapeName = glShapeName;
                this._className = className;
                this._jsParser = new marks.jsParserClass();
                //---- support for eBook calling ----
                var useWebGL = ((window["$usingWebGL"] === true || useWebGl) && (glShapeName != null));
                if (useWebGL) {
                    this._containerType = containerType.glCanvas;
                    this._glBuilder = new marks.glBuilderClass(container, glShapeName);
                    this._glBuilder.statsCallback(function (fps, shapesDrawn, elapsed) {
                        var w = window;
                        if (w.$setMarkStats) {
                            w.$setMarkStats(fps, shapesDrawn);
                        }
                    });
                }
                else {
                    if (container.tagName.toLowerCase() == "canvas") {
                        this._containerType = containerType.canvasElem;
                    }
                    else if (container.rootContainer) {
                        this._containerType = containerType.canvasGroup;
                    }
                    else {
                        this._containerType = containerType.svg;
                    }
                }
                if (this._containerType == containerType.canvasElem) {
                    //var request = (useWebGL) ? "3d" : "2d";
                    var canvasContainerElem = vp.canvas.selectContext(container, "2d")[0];
                    canvasContainerElem.clear();
                    this._container = canvasContainerElem;
                }
                var rootElem = this._container;
                if (!useWebGL) {
                    //---- create our own GROUP that will parent the generated shapes ----
                    var id = "rootElem-" + ((className) ? className : shapeName);
                    var groupElem = vp.select(container)
                        .append("g")
                        .id(id);
                    rootElem = groupElem[0];
                }
                this._rootElem = rootElem;
                vp.dom.css(rootElem, "opacity", "1"); // write as "1" so toggle code works
                //---- NOTE: "rootElem" is the container that shapes will be generated into ----
                this._dataAnimMgr = new vp.animation.dataAnimMgrClass(rootElem, null, shapeName, className, false, false);
                this._dataAnimMgr
                    .statsCallback(function (fps, shapesDrawn, elapsed) {
                    var w = window;
                    if (w.$setMarkStats) {
                        w.$setMarkStats(fps, shapesDrawn);
                    }
                });
                if (className) {
                    if (this._containerType == containerType.canvasElem || this._containerType == containerType.canvasGroup) {
                        var parentClassName = vp.select(this._container).attr("className");
                        this._computedStyle = vp.utils.getComputedStyleFromClass(shapeName, parentClassName, className);
                    }
                }
            }
            markBaseClass.prototype.createContainerIfNeeded = function (container) {
                if (!container) {
                    container = "svg";
                }
                var useWebGl = undefined;
                if (vp.utils.isString(container)) {
                    var containType = container;
                    useWebGl = (containType == "webGl");
                    if (containType == "svg") {
                        container = vp.dom.createSvg("svg");
                    }
                    else if (containType == "canvas" || useWebGl) {
                        container = vp.dom.createElement(null, "canvas");
                    }
                    else {
                        throw "Error - container string must be 'svg', 'canvas', or 'webGl', but was '" + containType + "'";
                    }
                }
                return { container: container, useWebGl: useWebGl };
            };
            markBaseClass.prototype.rootElem = function () {
                return this._rootElem;
            };
            markBaseClass.prototype.translate = function (x, y, makeCrispAdjustment) {
                if (makeCrispAdjustment === void 0) { makeCrispAdjustment = false; }
                if (this._rootElem) {
                    vp.select(this._rootElem)
                        .translate(x, y, makeCrispAdjustment);
                }
                return this;
            };
            markBaseClass.prototype.onShade = function (callback) {
                if (arguments.length === 0) {
                    return this._onShaderCallback;
                }
                this._onShaderCallback = callback;
                return this;
            };
            markBaseClass.prototype.keyFunc = function (callback) {
                if (arguments.length === 0) {
                    return this._dataAnimMgr.keyFunc();
                }
                this._dataAnimMgr.keyFunc(callback);
                return this;
            };
            markBaseClass.prototype.drawingParams = function (value) {
                if (arguments.length === 0) {
                    return this._drawingParams;
                }
                this._drawingParams = value;
                return this;
            };
            markBaseClass.prototype.opacity = function (value) {
                if (arguments.length === 0) {
                    return this._showOpacity;
                }
                this._showOpacity = value;
                vp.dom.css(this._rootElem, "opacity", value + "");
                this._isVisible = (value > 0);
                return this;
            };
            markBaseClass.prototype.build = function (transition, context) {
                this.generate(this._data, transition, context);
            };
            markBaseClass.prototype.generate = function (data, transition, context) {
                var _this = this;
                //---- support a few shortcuts for specifying the data ----
                if (data === true) {
                    //---- 1 row of dummy data ----
                    data = [1];
                }
                else if (data === false) {
                    //---- 0 rows of dummy data ----
                    data = [];
                }
                else if (vp.utils.isNumber(data)) {
                    data = vp.data.range(data);
                }
                if (data !== undefined) {
                    this._data = data;
                }
                if (!this._onShaderCallback) {
                    throw "Error - shader not defined for mark";
                }
                if (transition === undefined) {
                    transition = this._transition;
                }
                if (this._containerType == containerType.glCanvas) {
                    var glParams = this._jsParser.getGlParams(this._onShaderCallback, context);
                    this._glBuilder.drawScene(this._data, transition, glParams, this._fromGlParams);
                    this._fromGlParams = glParams;
                }
                else {
                    this.eraseCanvas();
                    this._dataAnimMgr
                        .transition(transition);
                    if (data === undefined) {
                        this._dataAnimMgr.updateWithoutDataChange();
                    }
                    else {
                        this._dataAnimMgr.setData(data);
                    }
                    this._dataAnimMgr.updateShapes(this._seriesIndex, this._seriesCount, function (elem, data, index, isNew, isLastNew) {
                        _this.applyClass(elem);
                        _this.applyDrawingParams(elem);
                        _this._onShaderCallback(elem, data.data, index, isNew, context, transition, isLastNew);
                        _this.postProcessShape(elem);
                    });
                }
            };
            //---- overridden by subclasses ----
            // private
            markBaseClass.prototype.applyDrawingParams = function (elem) {
            };
            markBaseClass.prototype.applyClass = function (elem) {
                if (this._className) {
                    var containType = this._containerType;
                    if (containType == containerType.svg) {
                        //---- just addClass on the element ----
                        vp.select(elem).addClass(this._className);
                    }
                    else if (this._computedStyle) {
                        //---- build style for named class ----
                        //var style = { fill: "gray", stroke: "black", strokeWidth: 1 };
                        elem.applyStyle(this._computedStyle);
                    }
                }
            };
            markBaseClass.prototype.postProcessShape = function (element) {
            };
            markBaseClass.prototype.clear = function () {
                this._dataAnimMgr.clear();
                this.eraseCanvas();
                return this;
            };
            markBaseClass.prototype.eraseCanvas = function () {
                if (this._glBuilder) {
                    this._glBuilder.clear();
                }
                else {
                    //vp.select(this._groupElem)
                    //    .clear();
                    var ctx = this._container.ctx;
                    if (ctx) {
                        var canvas = vp.select(this._container.canvas);
                        var w = canvas.width();
                        var h = canvas.height();
                        ctx.clearRect(0, 0, w, h);
                    }
                }
            };
            markBaseClass.prototype.isVisible = function () {
                return this._isVisible;
            };
            /** used at end of opacity animation, or in its place, to ensure item is hidden from hover, tooltips, clicks, etc. */
            markBaseClass.prototype.setVisibleNow = function (visible) {
                if (visible) {
                    vp.select(this._rootElem)
                        .css("opacity", this._showOpacity + "")
                        .css("visibility", "visible");
                }
                else {
                    vp.select(this._rootElem)
                        .css("opacity", "0")
                        .css("visibility", "hidden");
                }
            };
            markBaseClass.prototype.hide = function (transition) {
                var _this = this;
                if (transition === undefined) {
                    transition = this._transition;
                }
                var opacity = +vp.select(this._rootElem).css("opacity");
                if (opacity) {
                    if (transition) {
                        vp.select(this._rootElem)
                            .animate(transition.exit().duration(), null)
                            .onAnimationComplete(function (e) { return _this.setVisibleNow(false); })
                            .css("opacity", 0 + "");
                    }
                    else {
                        this.setVisibleNow(false);
                    }
                }
                this._isVisible = false;
            };
            markBaseClass.prototype.show = function (transition) {
                var _this = this;
                if (transition === undefined) {
                    transition = this._transition;
                }
                var opacity = +vp.select(this._rootElem).css("opacity");
                if (!opacity) {
                    if (transition) {
                        vp.select(this._rootElem)
                            .animate(transition.enter().duration(), null)
                            .onAnimationComplete(function (e) { return _this.setVisibleNow(true); })
                            .css("opacity", this._showOpacity + "");
                    }
                    else {
                        this.setVisibleNow(true);
                    }
                }
                this._firstShow = false;
                this._isVisible = true;
            };
            markBaseClass.prototype.transition = function (value) {
                if (arguments.length == 0) {
                    return this._transition;
                }
                this._transition = value;
            };
            return markBaseClass;
        }());
        marks.markBaseClass = markBaseClass;
        var markBase = (function (_super) {
            __extends(markBase, _super);
            function markBase() {
                _super.apply(this, arguments);
            }
            return markBase;
        }(markBaseClass));
        marks.markBase = markBase;
        (function (containerType) {
            containerType[containerType["svg"] = 0] = "svg";
            containerType[containerType["canvasElem"] = 1] = "canvasElem";
            containerType[containerType["canvasGroup"] = 2] = "canvasGroup";
            containerType[containerType["glCanvas"] = 3] = "glCanvas";
            containerType[containerType["glGroup"] = 4] = "glGroup";
        })(marks.containerType || (marks.containerType = {}));
        var containerType = marks.containerType;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// circleMark.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas CIRCLE primitives.  Can be used with animations.  Core function
        is "update()". */
        var circleMarkClass = (function (_super) {
            __extends(circleMarkClass, _super);
            function circleMarkClass(container, className) {
                _super.call(this, container, "circle", null, undefined, className);
                //vp.utils.trace("ctr", "circleMark");
            }
            // private 
            circleMarkClass.prototype.applyDrawingParams = function (elem) {
                marks.applyShapeDrawingParams(elem, this._drawingParams);
            };
            return circleMarkClass;
        }(marks.markBaseClass));
        marks.circleMarkClass = circleMarkClass;
        function createCircleMark(container, className) {
            return new circleMarkClass(container, className);
        }
        marks.createCircleMark = createCircleMark;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// ellipseMark.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas ellipse primitives.  Can be used with animations.  Core function
        is "update()". */
        var ellipseMarkClass = (function (_super) {
            __extends(ellipseMarkClass, _super);
            function ellipseMarkClass(container, className) {
                _super.call(this, container, "ellipse", null, false, className);
                //vp.utils.trace("ctr", "ellipseMark");
            }
            // private 
            ellipseMarkClass.prototype.applyDrawingParams = function (elem) {
                marks.applyShapeDrawingParams(elem, this._drawingParams);
            };
            return ellipseMarkClass;
        }(marks.markBaseClass));
        marks.ellipseMarkClass = ellipseMarkClass;
        function createEllipseMark(container, className) {
            return new ellipseMarkClass(container, className);
        }
        marks.createEllipseMark = createEllipseMark;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// drawingParams.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - interfaces and functions related to marks and their drawing parameter properties.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** Apply the drawing parameters to the text element.  "hAdjust" and "vAdjust" allow the caller to apply
        additional positioning adjustments to those already specified in "dp". */
        function applyTextParams(elem, dp, alignText, hAdjust, vAdjust) {
            if (alignText === void 0) { alignText = true; }
            var clearMissing = true;
            if (elem != null) {
                //---- FILL ----
                if (dp && dp.fill !== undefined) {
                    vp.dom.css(elem, "fill", dp.fill);
                }
                else if (clearMissing && elem.style.fill != "") {
                    vp.dom.css(elem, "fill", "");
                }
                //---- OPACITY ----
                if (dp && dp.opacity !== undefined) {
                    vp.dom.css(elem, "opacity", dp.opacity);
                }
                else if (clearMissing && elem.style.opacity != "") {
                    vp.dom.css(elem, "opacity", "");
                }
                //---- TEXT SIZE ----
                if (dp && dp.textSize !== undefined) {
                    vp.dom.css(elem, "font-size", dp.textSize);
                }
                else if (clearMissing && elem.style.fontSize != "") {
                    vp.dom.css(elem, "font-size", "");
                }
                //---- FONT FAMILY ----
                if (dp && dp.fontFamily !== undefined) {
                    vp.dom.css(elem, "font-family", dp.fontFamily);
                }
                else if (clearMissing && elem.style.fontFamily != "") {
                    vp.dom.css(elem, "font-family", "");
                }
                if (dp && dp.fontWeight !== undefined) {
                    vp.dom.css(elem, "font-weight", dp.fontWeight);
                }
                else if (clearMissing && elem.style.fontWeight != "") {
                    vp.dom.css(elem, "font-weight", "");
                }
                //---- TEXT LABEL ----
                if (dp && dp.textLabel !== undefined) {
                    vp.dom.text(elem, dp.textLabel);
                }
                //---- "text" isn't safe to zap (and is unlikely to have been set in theme) ----
                //else if (clearMissing && elem.textContent != "")
                //{
                //    vp.dom.text(elem, "")
                //}
                if (alignText) {
                    //---- HALIGN, VALIGN ----
                    var hAlign = (dp) ? dp.hAlign : null;
                    if (hAdjust) {
                        hAlign = hAdjust.value + (hAdjust.sign * hAlign);
                    }
                    var vAlign = (dp) ? dp.vAlign : null;
                    if (vAdjust) {
                        vAlign = vAdjust.value + (vAdjust.sign * vAlign);
                    }
                    //---- DX and DY seem to be ATTR only ----
                    if (hAlign || vAlign) {
                        var adjust = calculateTextAdjust(elem, hAlign, vAlign);
                        vp.dom.attr(elem, "dx", adjust.x);
                        vp.dom.attr(elem, "dy", adjust.y);
                    }
                }
            }
        }
        marks.applyTextParams = applyTextParams;
        /// use the "hAlign" and "vAlign" property values to calculate the x/y adjustment
        /// needed for the text. requires the text element with the final text applied to it
        /// (and it should be attached to the document) so that it can be correctly measured.  
        ///
        /// return the adjustment as a {x, y} object.
        function calculateTextAdjust(textElem, hAlign, vAlign) {
            var hvals = { left: 0, middle: .5, right: 1 };
            var vvals = { top: 1, middle: .5, bottom: 0 };
            var adjust = { x: 0, y: 0 };
            if (textElem) {
                //---- HALIGN ----
                if (hvals[hAlign]) {
                    hAlign = hvals[hAlign];
                }
                //---- VALIGN ----
                if (vvals[vAlign]) {
                    vAlign = vvals[vAlign];
                }
                var uelem = (textElem.length) ? textElem[0] : textElem;
                var bb = vp.dom.getBounds(uelem);
                //---- horizontal alignment defaults to: text starts at "x" ----
                adjust.x = -(bb.width * hAlign);
                //---- UNROATED TEXT: vertical alignment defaults to: CENTER LINE of text is at "y" ----
                adjust.y = (1 - .25 - vAlign) * bb.height; // the ".25" is an asthetic adjustment for vertical alignment
            }
            return adjust;
        }
        marks.calculateTextAdjust = calculateTextAdjust;
        function applyLineParams(element, dp) {
            if ((element != null) && (dp != null)) {
                //---- use "css" to override values in CSS style sheets (vs. "attr") ----
                if (dp.stroke !== undefined) {
                    vp.dom.css(element, "stroke", dp.stroke);
                }
                if (dp.opacity !== undefined) {
                    vp.dom.css(element, "opacity", dp.opacity);
                }
                if (dp.lineSize !== undefined) {
                    vp.dom.css(element, "stroke-width", dp.lineSize);
                }
                if (dp.lineType !== undefined) {
                    var dashArray = vp.utils.lineTypeToDashArray(dp.lineType);
                    vp.dom.css(element, "stroke-dasharray", dashArray);
                }
            }
        }
        marks.applyLineParams = applyLineParams;
        function applyShapeDrawingParams(elem, dp) {
            if ((elem != null) && (dp != null)) {
                if (dp.stroke !== undefined) {
                    vp.dom.css(elem, "stroke", dp.stroke);
                }
                if (dp.fill !== undefined) {
                    vp.dom.css(elem, "fill", dp.fill);
                }
                if (dp.opacity !== undefined) {
                    vp.dom.css(elem, "opacity", dp.opacity);
                }
                if (dp.lineType !== undefined) {
                    var lineType = vp.utils.lineTypeToDashArray(dp.lineType);
                    vp.dom.attr(elem, "stroke-dasharray", lineType);
                }
                if (dp.lineSize !== undefined) {
                    vp.dom.attr(elem, "stroke-width", dp.lineSize);
                }
            }
        }
        marks.applyShapeDrawingParams = applyShapeDrawingParams;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// groupMark.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas group primitives.  Can be used with animations.  Core function
        is "update()". */
        var groupMarkClass = (function (_super) {
            __extends(groupMarkClass, _super);
            function groupMarkClass(container, className) {
                _super.call(this, container, "g", null, false, className);
                //vp.utils.trace("ctr", "groupMark");
            }
            return groupMarkClass;
        }(marks.markBaseClass));
        marks.groupMarkClass = groupMarkClass;
        function createGroupMark(container, className) {
            return new groupMarkClass(container, className);
        }
        marks.createGroupMark = createGroupMark;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// glBuilder.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** WebGL helper class for marks. */
        var glBuilderClass = (function () {
            function glBuilderClass(canvas, glShapeName) {
                this._trans3d = null; // our current elevation-based camera
                this._animation = null;
                this._usingPosition = false;
                this._shapeVertices = null;
                this._usingWidth = false;
                this._randomVectors = {};
                //---- stats ----
                this._animStartTime = 0;
                this._animFrameCount = 0;
                this._animFPS = 0;
                this._shapesDrawn = 0;
                this._statsCallback = null;
                this._canvas = canvas;
                this._gl = canvas.getContext("webgl");
                this._glShapeName = glShapeName;
                //vp.utils.trace("ctr", "glBuilder");
                if (!this._gl) {
                    this._gl = canvas.getContext("experimental-webgl");
                }
                if (!this._gl) {
                    alert("Your browser does not support WebGL");
                    return;
                }
                var rotation = 0;
                var elevation = 90;
                var width = vp.select(canvas).width();
                var height = vp.select(canvas).height();
                this._trans3d = vp.plotBox.createTransform3d(width, height, rotation, elevation, 0, width, 0, height, -1, 1);
            }
            glBuilderClass.prototype.init = function (data, glParams, fromGlParams) {
                this._gl.viewportWidth = this._canvas.width;
                this._gl.viewportHeight = this._canvas.height;
                this.initBuffers(data, glParams, fromGlParams);
                this.initShaders(glParams, fromGlParams);
            };
            glBuilderClass.prototype.updateScreenSize = function (w, h) {
                var changed = false;
                //---- prevent negative numbers ----
                w = Math.max(0, w);
                h = Math.max(0, h);
                var gl = this._gl;
                if (gl) {
                    if (w != gl.viewportWidth) {
                        gl.viewportWidth = w;
                        changed = true;
                    }
                    if (h != gl.viewportHeight) {
                        gl.viewportHeight = h;
                        changed = true;
                    }
                }
                if (changed) {
                    this._trans3d
                        .screenWidth(w)
                        .screenHeight(h)
                        .xMax(w)
                        .yMax(h)
                        .rebuild();
                }
            };
            glBuilderClass.prototype.buildVertexShader = function (glParams, fromGlParams) {
                var usePosition = this._usingPosition;
                var a = "//---- data buffers ----\n";
                a += "attribute float index;\n";
                if (usePosition) {
                    var vdim = this._shapeVertices.length / 3;
                    a += "attribute float vertexIndex_;\n";
                }
                for (var i = 0; i < glParams.dataColNames.length; i++) {
                    var colName = glParams.dataColNames[i];
                    a += "attribute float " + colName + ";\n";
                }
                for (var i = 0; i < glParams.randomColNames.length; i++) {
                    var colName = glParams.randomColNames[i];
                    a += "attribute float " + colName + ";\n";
                }
                a += "\n";
                a += "//---- constants ----\n";
                if (usePosition) {
                    a += "uniform vec3 vertices_[" + vdim + "];\n";
                }
                a += "uniform mat4 mvpMatrix_;\n";
                a += "uniform vec3 colors_[3];\n";
                a += "uniform float colorIndex_;\n";
                if (fromGlParams) {
                    a += "uniform float colorIndexFrom_;\n";
                    a += "uniform float percent_;\n";
                }
                a += "\n";
                a += "//---- shader output variables ----\n";
                a += "varying vec4 vColor;\n";
                a += "\n";
                a += "%functions%";
                a += "void main(void)\n";
                a += "{\n";
                a += "%cmds%";
                a += "  vColor = color_;\n";
                if (usePosition) {
                    if (this._usingWidth) {
                        a += "  vec3 v_ = vertices_[int(vertexIndex_)];\n";
                        a += "  vec3 pos_ = vec3(v_.x * width_, v_.y * height_, 0) + vec3(x_, y_, 0.0);\n";
                        a += "  gl_Position = mvpMatrix_ * vec4(pos_, 1.0);\n";
                    }
                    else {
                        a += "  vec3 pos_ = vertices_[int(vertexIndex_)] * size_ + vec3(x_, y_, 0.0);\n";
                        a += "  gl_Position = mvpMatrix_ * vec4(pos_, 1.0);\n";
                    }
                }
                else {
                    a += "  gl_Position = mvpMatrix_ * vec4(x_, y_, 0.0, 1.0);\n";
                    a += "  gl_PointSize = size_;  \n";
                }
                a += "}\n";
                return a;
            };
            glBuilderClass.prototype.fragShader = function () {
                var a = "\n \
                     precision mediump float;\n \
                     varying vec4 vColor;\n \
                            \n \
                     void main(void )\n \
                     {\n \
                        gl_FragColor =  vColor;  \n \
                     }\n \
                ";
                return a;
            };
            glBuilderClass.prototype.clear = function () {
                if (this._gl) {
                    var gl = this._gl;
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                }
            };
            glBuilderClass.prototype.drawScene = function (data, transition, glParams, fromGlParams) {
                var _this = this;
                this._usingPosition = (this._glShapeName != "point");
                this.init(data, glParams, fromGlParams);
                var gl = this._gl;
                //---- clear screen with BLACK color ----
                var cr = vp.select(this._canvas).css("background-color");
                var bg = vp.color.getColorFromString(cr);
                gl.clearColor(bg[0] / 255, bg[1] / 255, bg[2] / 255, 1);
                gl.enable(gl.DEPTH_TEST);
                //gl.enable(0x8642);     // gl.PROGRAM_POINT_SIZE  (undefined in some browsers)
                //gl.pointSize(33);      // for some reason, this one was not implemented (but vertex shader DOES support gl_pointSize)
                //---- enable blending ----
                gl.enable(gl.BLEND);
                gl.disable(gl.DEPTH_TEST); // must turn off (takes priority over blending)
                //---- IE11 bug workaround - use simple blending because IE11 doesn't support the below alternative ----
                //gl.blendFunc(gl.SRC_ALPHA, gl.DST_ALPHA);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                //---- set the shader constants ----
                this.setShaderConstants(glParams, fromGlParams);
                gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
                gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
                //---- set up buffer mapping ----
                var floats = 1; // index
                if (this._usingPosition) {
                    floats++;
                }
                floats += glParams.dataColNames.length;
                floats += glParams.randomColNames.length;
                var strideInBytes = floats * 4;
                var buffOffset = 0;
                if (this._shaderProgram.alIndex > -1) {
                    gl.vertexAttribPointer(this._shaderProgram.alIndex, 1, gl.FLOAT, false, strideInBytes, buffOffset);
                }
                buffOffset += 4; // we always add INDEX data, so always offset by 4 here
                if (this._usingPosition) {
                    if (this._shaderProgram.alVertexIndex > -1) {
                        gl.vertexAttribPointer(this._shaderProgram.alVertexIndex, 1, gl.FLOAT, false, strideInBytes, buffOffset);
                    }
                    buffOffset += 4;
                }
                for (var i = 0; i < glParams.dataColNames.length; i++) {
                    var dataColName = glParams.dataColNames[i];
                    if (this._shaderProgram[dataColName] > -1) {
                        gl.vertexAttribPointer(this._shaderProgram[dataColName], 1, gl.FLOAT, false, strideInBytes, buffOffset);
                    }
                    buffOffset += 4;
                }
                for (var i = 0; i < glParams.randomColNames.length; i++) {
                    var randColName = glParams.randomColNames[i];
                    if (this._shaderProgram[randColName] > -1) {
                        gl.vertexAttribPointer(this._shaderProgram[randColName], 1, gl.FLOAT, false, strideInBytes, buffOffset);
                    }
                    buffOffset += 4;
                }
                this.drawSceneFrame(0);
                //---- start an animation ----
                if (fromGlParams && transition) {
                    var update = transition.update();
                    var duration = update.duration();
                    var easing = update.easeObj();
                    var delay = update.delay();
                    this._animStartTime = vp.utils.now();
                    this._animFrameCount = 0;
                    var animation = vp.animation.createAnimation(null, duration, easing, null, delay)
                        .onFrame(function (percent) {
                        _this.drawSceneFrame(percent);
                    })
                        .onAnimationComplete(function () {
                        var elapsed = vp.utils.now() - _this._animStartTime;
                        _this._animFPS = Math.round(_this._animFrameCount / (elapsed / 1000));
                        if (_this._statsCallback) {
                            _this._statsCallback(_this._animFPS, _this._shapesDrawn, elapsed);
                        }
                    });
                    animation.restart(); // have to start these manually since we are not adding child animations
                }
            };
            glBuilderClass.prototype.drawSceneFrame = function (percent) {
                var gl = this._gl;
                //---- clear viewport ----
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                //---- update percent constant ----
                this._gl.uniform1f(this._shaderProgram.ulPercent, percent);
                //vp.utils.debug("drawSceneFrame: percent=" + percent);
                //---- DRAW PRIMITIVES ----
                if (this._usingPosition) {
                    gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
                }
                else {
                    gl.drawArrays(gl.POINTS, 0, this._vertexBuffer.numItems);
                }
                this._shapesDrawn = this._vertexBuffer.numItems;
                this._animFrameCount++;
            };
            glBuilderClass.prototype.applyShaderParams = function (shader, glParams, fromGlParams) {
                var cmd = "  float x_ = " + glParams.x + ";\n";
                cmd += "  float y_ = " + glParams.y + ";\n";
                if (this._usingWidth) {
                    cmd += "  float width_ = " + glParams.width + ";\n";
                    cmd += "  float height_ = " + glParams.height + ";\n";
                }
                else if (this._glShapeName == "line2d") {
                    cmd += "  float size_ = 1.0;\n";
                    cmd += "  float strokeWidth_ = " + glParams.strokeWidth + ";\n";
                }
                else {
                    cmd += "  float size_ = " + glParams.size + ";\n";
                }
                cmd += "  float opacity_ = " + glParams.opacity + ";\n";
                cmd += "  vec4 color_ = vec4(colors_[int(colorIndex_)], opacity_);\n";
                cmd += "\n";
                var cmds = glParams.cmds + cmd;
                if (fromGlParams) {
                    //--- run code in a inner block so we avoid variable name conflicts ----
                    var cmdFrom = "\n";
                    cmdFrom += "  if (percent_ < 1.0)\n";
                    cmdFrom += "  {\n";
                    cmdFrom += fromGlParams.cmds;
                    cmdFrom += "\n";
                    cmdFrom += "    float xFrom_ = " + fromGlParams.x + ";\n";
                    cmdFrom += "    float yFrom_ = " + fromGlParams.y + ";\n";
                    cmdFrom += "    float sizeFrom_ = " + fromGlParams.size + ";\n";
                    cmdFrom += "    vec4 colorFrom_ = vec4(colors_[int(colorIndexFrom_)], 1.0);\n";
                    cmdFrom += "\n";
                    cmdFrom += "    x_ = mix(xFrom_, x_, percent_);\n";
                    cmdFrom += "    y_ = mix(yFrom_, y_, percent_);\n";
                    cmdFrom += "    size_ = mix(sizeFrom_, size_, percent_);\n";
                    cmdFrom += "    color_ = mix(colorFrom_, color_, percent_);\n";
                    cmdFrom += "  }\n";
                    cmds += cmdFrom;
                }
                //---- add translated statements ----
                var str = shader.replace(/%functions%/, glParams.functions);
                var str = str.replace(/%cmds%/, cmds);
                return str;
            };
            glBuilderClass.prototype.getShader = function (gl, id, glParams, fromGlParams) {
                var str = (id == "shader-fs") ? this.fragShader() : this.buildVertexShader(glParams, fromGlParams);
                var shader;
                if (id == "shader-fs") {
                    shader = gl.createShader(gl.FRAGMENT_SHADER);
                }
                else if (id == "shader-vs") {
                    str = this.applyShaderParams(str, glParams, fromGlParams);
                    //---- store for easy access by VuePlot eBook UI ----
                    var w = window;
                    if (w.setVertexShader) {
                        w.setVertexShader(this._canvas, str);
                    }
                    shader = gl.createShader(gl.VERTEX_SHADER);
                }
                else {
                    return null;
                }
                gl.shaderSource(shader, str);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    alert(gl.getShaderInfoLog(shader));
                    return null;
                }
                return shader;
            };
            glBuilderClass.prototype.initShaders = function (glParams, fromGlParams) {
                var w = window;
                var gl = this._gl;
                this._shaderProgram = this._gl.createProgram();
                var program = this._shaderProgram;
                var fragmentShader = this.getShader(this._gl, "shader-fs", null, null);
                var vertexShader = this.getShader(this._gl, "shader-vs", glParams, fromGlParams);
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    alert("Could not initialise shaders");
                }
                gl.useProgram(program);
                //---- attribute locations ----
                //---- map "index" to buffer ----
                program.alIndex = gl.getAttribLocation(program, "index");
                if (program.alIndex > -1) {
                    gl.enableVertexAttribArray(program.alIndex);
                }
                program.alVertexIndex = gl.getAttribLocation(program, "vertexIndex_");
                if (program.alVertexIndex > -1) {
                    gl.enableVertexAttribArray(program.alVertexIndex);
                }
                for (var i = 0; i < glParams.dataColNames.length; i++) {
                    var dataColName = glParams.dataColNames[i];
                    program[dataColName] = gl.getAttribLocation(program, dataColName);
                    if (program[dataColName] > -1) {
                        gl.enableVertexAttribArray(program[dataColName]);
                    }
                }
                for (var i = 0; i < glParams.randomColNames.length; i++) {
                    var randColName = glParams.randomColNames[i];
                    program[randColName] = gl.getAttribLocation(program, randColName);
                    if (program[randColName] > -1) {
                        gl.enableVertexAttribArray(program[randColName]);
                    }
                }
                //---- constant locations ----
                program.ulVertices = gl.getUniformLocation(program, "vertices_");
                program.ulColors = gl.getUniformLocation(program, "colors_");
                program.ulColorIndex = gl.getUniformLocation(program, "colorIndex_");
                program.ulColorIndexFrom = gl.getUniformLocation(program, "colorIndexFrom_");
                program.mvpMatrixUniform = gl.getUniformLocation(program, "mvpMatrix_");
                program.ulPercent = gl.getUniformLocation(program, "percent_");
                //alert("shaders initialized");
            };
            glBuilderClass.prototype.setShaderConstants = function (glParams, fromGlParams) {
                var gl = this._gl;
                var program = this._shaderProgram;
                this._gl.uniform1f(this._shaderProgram.ulPercent, 0);
                var usingStroke = (this._glShapeName == "line2d");
                //---- color palette ----
                var cr = (usingStroke) ? glParams.stroke : glParams.fill;
                if (!cr || cr.length != 3) {
                    cr = [0, 0, 0];
                }
                var crFrom = [.7, .2, .2]; // red
                if (fromGlParams) {
                    crFrom = (usingStroke) ? fromGlParams.stroke : fromGlParams.fill;
                    if (!crFrom || crFrom.length != 3) {
                        crFrom = [.7, .2, .2];
                    }
                }
                gl.uniform3fv(program.ulColors, [
                    cr[0], cr[1], cr[2],
                    crFrom[0], crFrom[1], crFrom[2],
                    .2, .2, .7]); // blue
                if (this._shapeVertices) {
                    gl.uniform3fv(program.ulVertices, this._shapeVertices);
                }
                gl.uniform1f(this._shaderProgram.ulColorIndex, 0); // to color 
                gl.uniform1f(this._shaderProgram.ulColorIndexFrom, 1); // from color 
                //---- set MATRIX from camera ----
                var mvp = this._trans3d.getMatrix();
                gl.uniformMatrix4fv(program.mvpMatrixUniform, false, mvp.toArray());
            };
            glBuilderClass.prototype.initBuffers = function (data, glParams, fromGlParams) {
                this._vertexBuffer = this._gl.createBuffer();
                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexBuffer);
                var vertexBuff = [];
                var shape = this._glShapeName;
                var verticesPerRecord = 0;
                //---- add INDEX and SHAPE info ----
                if (shape == "point") {
                    verticesPerRecord = this.setPointVertices(data);
                }
                else if (shape == "triangle") {
                    verticesPerRecord = this.setTriangleVertices(data);
                }
                else if (shape == "rect2d") {
                    verticesPerRecord = this.setRect2dVertices(data);
                }
                else if (shape == "line2d") {
                    verticesPerRecord = this.setLine2dVertices(data);
                }
                else {
                    throw "Error: unsupported WebGl mark shape=" + shape;
                }
                //---- this number is independent of stride per vertex ----
                this._vertexBuffer.numItems = (verticesPerRecord == 0) ? (data.length) : (verticesPerRecord * data.length);
                //---- pack all the data into vertexBuff ----
                for (var i = 0; i < data.length; i++) {
                    for (var j = 0; j < Math.max(1, verticesPerRecord); j++) {
                        //---- add a triangle vertex index----
                        vertexBuff.push(i); // record index
                        if (verticesPerRecord > 0) {
                            vertexBuff.push(j); // vertex index          
                        }
                        //---- add data for columns referenced ----
                        for (var c = 0; c < glParams.origColNames.length; c++) {
                            var colName = glParams.origColNames[c];
                            if (colName == "value_number") {
                                var value = +data[i];
                            }
                            else {
                                var value = +data[i][colName];
                            }
                            vertexBuff.push(value); // data column value
                        }
                        //---- add RANDOM data columns ----
                        for (var c = 0; c < glParams.randomColNames.length; c++) {
                            var colName = "random" + (c + 1) + "_";
                            var vector = this.getRandomVector(colName, data.length);
                            var value = vector[i];
                            vertexBuff.push(value); // data column value
                        }
                    }
                }
                //var colCount = glParams.origColNames.length;
                this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(vertexBuff), this._gl.STATIC_DRAW);
                //alert("buffers initialized");
            };
            glBuilderClass.prototype.getRandomVector = function (name, count) {
                var vector = this._randomVectors[name];
                if (vector === undefined) {
                    vector = [];
                    for (var i = 0; i < count; i++) {
                        vector.push(Math.random());
                    }
                    this._randomVectors[name] = vector;
                }
                else if (vector.length < count) {
                    var oldCount = vector.length;
                    for (var i = oldCount; i < count; i++) {
                        vector.push(Math.random());
                    }
                }
                return vector;
            };
            glBuilderClass.prototype.setPointVertices = function (data) {
                this._shapeVertices = null;
                this._usingWidth = false;
                return 0;
            };
            glBuilderClass.prototype.setTriangleVertices = function (data) {
                var verticesPerRecord = 3;
                //---- single triangle: X, Y, Z ----
                var vertices = [
                    -.5, .5, 0,
                    .5, .5, 0,
                    .0, -.5, 0,
                ];
                this._shapeVertices = vertices;
                this._usingWidth = false;
                return verticesPerRecord;
            };
            glBuilderClass.prototype.setRect2dVertices = function (data) {
                var vertexBuff = [];
                var verticesPerRecord = 6;
                //---- draw with x,y in upper left corner ----
                var vertices = [
                    1, 1, 0,
                    0, 1, 0,
                    0, 0, 0,
                    1, 1, 0,
                    0, 0, 0,
                    1, 0, 0,
                ];
                this._shapeVertices = vertices;
                this._usingWidth = true;
                return verticesPerRecord;
            };
            glBuilderClass.prototype.setLine2dVertices = function (data) {
                var vertexBuff = [];
                var verticesPerRecord = 6;
                //---- draw with x,y in upper left corner ----
                var vertices = [
                    1, 1, 0,
                    0, 1, 0,
                    0, 0, 0,
                    1, 1, 0,
                    0, 0, 0,
                    1, 0, 0,
                ];
                this._shapeVertices = vertices;
                this._usingWidth = false;
                return verticesPerRecord;
            };
            glBuilderClass.prototype.statsCallback = function (value) {
                this._statsCallback = value;
                return this;
            };
            return glBuilderClass;
        }());
        marks.glBuilderClass = glBuilderClass;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// imageMark.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas image primitives.  Can be used with animations.  Core function
        is "update()". */
        var imageMarkClass = (function (_super) {
            __extends(imageMarkClass, _super);
            function imageMarkClass(container, className) {
                _super.call(this, container, "image", null, false, className);
                //vp.utils.trace("ctr", "imageMark");
            }
            return imageMarkClass;
        }(marks.markBaseClass));
        marks.imageMarkClass = imageMarkClass;
        function createImageMark(container, className) {
            return new imageMarkClass(container, className);
        }
        marks.createImageMark = createImageMark;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// jsParser.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** Used to translate JavaScript shader functions into GL shader statements and expressions. */
        var jsParserClass = (function () {
            function jsParserClass() {
                this._context = null;
            }
            jsParserClass.prototype.makeRecordColumnName = function (name) {
                name = name.replace(/ /g, "_");
                return "data_" + name + "_";
            };
            jsParserClass.prototype.colorToGlColor = function (ca) {
                if ((ca.indexOf(",") > -1) && (ca.indexOf("(") == -1)) {
                    //---- its a string of 3 rgb numbers ----
                    ca = ca.split(",");
                }
                else {
                    ca = vp.color.getColorFromString(ca);
                }
                //---- GL wants normalized colors ----
                if (!ca) {
                    ca = [0, 0, 0];
                }
                else {
                    ca = [ca[0] / 255, ca[1] / 255, ca[2] / 255];
                }
                return ca;
            };
            jsParserClass.prototype.removeQuotes = function (name) {
                name = name.trim();
                if (name.startsWith("\"")) {
                    name = name.substr(1, name.length - 2).trim(); // remove quotes
                }
                return name;
            };
            jsParserClass.prototype.fixupNumber = function (value) {
                //---- ensure number is a float ----
                if (value.indexOf(".") == -1) {
                    value += ".0";
                }
                return value;
            };
            jsParserClass.prototype.processRecordColumn = function (token, attrBlock) {
                //---- make sure we only add name once ----
                var newColumn = false;
                if (attrBlock.origColNames.indexOf(token) == -1) {
                    attrBlock.origColNames.push(token);
                    newColumn = true;
                }
                //---- make the flat name safe for mixing with other user code ----
                token = this.makeRecordColumnName(token);
                if (newColumn) {
                    attrBlock.dataColNames.push(token);
                }
                return token;
            };
            jsParserClass.prototype.translateExp = function (line, usage, attrBlock) {
                var isCdRef = false;
                var isMathRef = false;
                var isvpRef = false;
                var isRecordRef = false;
                var isFirstToken = true;
                var scanner = new vp.utils.scannerClass(line);
                var tt = scanner.scan();
                var exp = "";
                while (tt != vp.utils.TokenType.eof) {
                    var token = scanner.token();
                    if (tt == vp.utils.TokenType.number) {
                        token = this.fixupNumber(token);
                        exp += " " + token;
                    }
                    else if (tt == vp.utils.TokenType.operator) {
                        if (token == ".") {
                            if (isCdRef || isMathRef || isvpRef || isRecordRef) {
                                token = null;
                            }
                        }
                        else if (isRecordRef) {
                            //---- code used "record" without the dot qualified - record is really just a number ----
                            var lastToken = this.processRecordColumn("value", attrBlock);
                            exp += " " + lastToken;
                        }
                        //---- output the operator ----
                        if (token) {
                            exp += " " + token;
                        }
                    }
                    else if (tt == vp.utils.TokenType.id) {
                        if (token == "Math") {
                            isMathRef = true;
                            token = null;
                        }
                        else if (token == "cd") {
                            isCdRef = true;
                            token = null;
                        }
                        else if (token == "vp") {
                            isvpRef = true;
                            token = null;
                        }
                        else if (token == "record") {
                            isRecordRef = true;
                            token = null;
                        }
                        else {
                            if (isMathRef) {
                                //---- just handle the exceptions since most are supported ----
                                if (token == "PI") {
                                    token = "3.14159265";
                                }
                                else if (token == "random") {
                                    var count = attrBlock.randomColNames.length + 1;
                                    var randColName = "random" + count + "_";
                                    attrBlock.randomColNames.push(randColName);
                                    token = randColName;
                                    //---- effectively remove the () in the input string ----
                                    scanner.scan(); // skip over "random" to "()"
                                }
                                else {
                                }
                            }
                            else if (isCdRef) {
                                token = this._context[token];
                                //---- is it a number? ----
                                if (!isNaN(+token)) {
                                    token = this.fixupNumber(token + "");
                                }
                            }
                            else if (isRecordRef) {
                                token = this.processRecordColumn(token, attrBlock);
                            }
                            else if (isvpRef) {
                                //---- vp.select(elem) line; just ignore it ----
                                break;
                            }
                            isCdRef = false;
                            isMathRef = false;
                            isvpRef = false;
                            isRecordRef = false;
                        }
                        if (token == "var") {
                            token = "float";
                        }
                        else if (token == "function" && isFirstToken) {
                            //---- the function header - ignore this line ----
                            break;
                        }
                        if (token) {
                            exp += " " + token;
                        }
                    }
                    else if (tt == vp.utils.TokenType.string) {
                        exp += " " + token;
                    }
                    else {
                    }
                    tt = scanner.scan();
                }
                if (isRecordRef) {
                    //---- code used "record" without the dot qualified - record is really just a number ----
                    var lastToken = this.processRecordColumn("value_number", attrBlock);
                    exp += " " + lastToken;
                }
                if (usage == "color") {
                    var str = this.removeQuotes(exp);
                    exp = this.colorToGlColor(str);
                }
                return exp;
            };
            jsParserClass.prototype.translateJsStatements = function (lines, attrBlock) {
                var bracketLevel = 0;
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i].trim();
                    if (line.startsWith(".attr(")) {
                        this.translateAttrCall(line, attrBlock);
                        continue;
                    }
                    else if (line.startsWith("function")) {
                        //---- skip this line ----
                        continue;
                    }
                    else if (line.startsWith("vp.select(")) {
                        //---- skip this line ----
                        continue;
                    }
                    else if (line == "{") {
                        bracketLevel++;
                        if (bracketLevel == 1) {
                            continue;
                        }
                    }
                    else if (line == "}") {
                        bracketLevel--;
                        if (bracketLevel == 0) {
                            continue;
                        }
                    }
                    var cmd = this.translateExp(line, "cmd", attrBlock);
                    if (cmd && cmd.trim() != "") {
                        attrBlock.cmds += cmd + "\n";
                    }
                }
            };
            jsParserClass.prototype.translateAttrCall = function (line, attrBlock) {
                var part = line.substr(6); // skip over ".attr("
                if (part.length && part[part.length - 1] == ")") {
                    part = part.substr(0, part.length - 1).trim();
                }
                //---- divide pair at first space ----
                var name = part;
                var value = "";
                var index = part.indexOf(" ");
                if (index > -1) {
                    name = part.substr(0, index).trim();
                    value = part.substr(index + 1).trim();
                }
                if (name.length && name[name.length - 1] == ",") {
                    //---- remove trailing comma ----
                    name = name.substr(0, name.length - 1).trim();
                }
                name = this.removeQuotes(name);
                if (name == "width") {
                    value = this.translateExp(value, "number", attrBlock);
                    attrBlock.width = value;
                }
                else if (name == "height") {
                    value = this.translateExp(value, "number", attrBlock);
                    attrBlock.height = value;
                }
                else if (name == "size") {
                    value = this.translateExp(value, "number", attrBlock);
                    attrBlock.size = value;
                }
                else if (name == "stroke-width") {
                    value = this.translateExp(value, "number", attrBlock);
                    attrBlock.strokeWidth = value;
                }
                else if (name == "opacity") {
                    value = this.translateExp(value, "number", attrBlock);
                    attrBlock.opacity = value;
                }
                else if (name == "fill") {
                    value = this.translateExp(value, "color", attrBlock);
                    attrBlock.fill = value;
                }
                else if (name == "stroke") {
                    value = this.translateExp(value, "color", attrBlock);
                    attrBlock.stroke = value;
                }
                else if (name == "x" || name == "cx") {
                    value = this.translateExp(value, "number", attrBlock);
                    attrBlock.x = value;
                }
                else if (name == "y" || name == "cy") {
                    value = this.translateExp(value, "number", attrBlock);
                    attrBlock.y = value;
                }
            };
            jsParserClass.prototype.getGlParams = function (shaderCallback, context) {
                this._context = context;
                var size = "20.0";
                var fill = [0, 0, 1, 1]; // blue
                var stroke = [0, 0, 1, 1]; // blue
                var x = ".5";
                var y = ".5";
                var cmds = "";
                var attrBlock = {
                    size: size, width: size, height: size, fill: fill, stroke: stroke, x: x, y: y, opacity: "1.0", strokeSize: 1,
                    cmds: cmds, origColNames: [], dataColNames: [], randomColNames: [], functions: "",
                };
                var code = shaderCallback.toString();
                //alert("code=" + code);
                var lines = code.split("\n");
                this.translateJsStatements(lines, attrBlock);
                //if (attrBlock.randomCount)
                //{
                //    //---- use von Neumann's middle square method, with slight modification ----
                //    var rf = "float random(float seed1, float seed2)\n";
                //    rf += "{\n";
                //    rf += "  seed1 = seed1 + 17.3;\n";
                //    rf += "  seed2 = seed2 + 29.1;\n";
                //    rf += "  seed1 = fract((seed1*seed1 + seed2*seed2)*1024.0);\n";
                //    rf += "  return seed1;\n";
                //    rf += "}\n\n";
                //    attrBlock.functions += rf;
                //}
                return attrBlock;
            };
            return jsParserClass;
        }());
        marks.jsParserClass = jsParserClass;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// lineMark.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas line primitives.  Can be used with animations.  Core function
        is "update()". */
        var lineMarkClass = (function (_super) {
            __extends(lineMarkClass, _super);
            function lineMarkClass(container, className) {
                _super.call(this, container, "line", null, false, className);
                //vp.utils.trace("ctr", "lineMark");
            }
            // private 
            lineMarkClass.prototype.applyDrawingParams = function (elem) {
                marks.applyLineParams(elem, this._drawingParams);
            };
            return lineMarkClass;
        }(marks.markBaseClass));
        marks.lineMarkClass = lineMarkClass;
        function createLineMark(container, className) {
            return new lineMarkClass(container, className);
        }
        marks.createLineMark = createLineMark;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// pathMark.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas path primitives.  Can be used with animations.  Core function
        is "update()". */
        var pathMarkClass = (function (_super) {
            __extends(pathMarkClass, _super);
            function pathMarkClass(container, className) {
                _super.call(this, container, "path", null, false, className);
                //vp.utils.trace("ctr", "pathMark");
            }
            // private 
            pathMarkClass.prototype.applyDrawingParams = function (elem) {
                marks.applyShapeDrawingParams(elem, this._drawingParams);
            };
            return pathMarkClass;
        }(marks.markBaseClass));
        marks.pathMarkClass = pathMarkClass;
        function createPathMark(container, className) {
            return new pathMarkClass(container, className);
        }
        marks.createPathMark = createPathMark;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// pointMark.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** Supports data-based generation of WebGL POINT primitives.  Can be used with animations.  Core function
        is "update()". */
        var pointMarkClass = (function (_super) {
            __extends(pointMarkClass, _super);
            function pointMarkClass(container, useWebGl, className) {
                _super.call(this, container, "rect", "point", useWebGl, className);
                //vp.utils.trace("ctr", "pointMark");
            }
            pointMarkClass.prototype.postProcessShape = function (element) {
                var wrap = vp.select(element);
                var size = wrap.attr("size");
                wrap
                    .attr("width", size)
                    .attr("height", size);
            };
            return pointMarkClass;
        }(marks.markBaseClass));
        marks.pointMarkClass = pointMarkClass;
        function createPointMark(container, className) {
            return new pointMarkClass(container, false, className);
        }
        marks.createPointMark = createPointMark;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// rect2dMark.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** Supports data-based generation of WebGL rect2d primitives.  Can be used with animations.  Core function
        is "update()". */
        var rect2dMarkClass = (function (_super) {
            __extends(rect2dMarkClass, _super);
            function rect2dMarkClass(container, useWebGl, className) {
                _super.call(this, container, "rect", "rect2d", useWebGl, className);
                //vp.utils.trace("ctr", "rect2dMark");
            }
            rect2dMarkClass.prototype.postProcessShape = function (element) {
                var wrap = vp.select(element);
                var size = wrap.attr("size");
                wrap
                    .attr("width", size)
                    .attr("height", size);
            };
            return rect2dMarkClass;
        }(marks.markBaseClass));
        marks.rect2dMarkClass = rect2dMarkClass;
        function createRect2dMark(container, useWebGl, className) {
            return new rect2dMarkClass(container, useWebGl, className);
        }
        marks.createRect2dMark = createRect2dMark;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// rectangleMark.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas RECT primitives.  Can be used with animations.  Core function
        is "update()". */
        var rectangleMarkClass = (function (_super) {
            __extends(rectangleMarkClass, _super);
            function rectangleMarkClass(container, className) {
                _super.call(this, container, "rect", null, false, className);
                //vp.utils.trace("ctr", "rectangleMark");
            }
            // private 
            rectangleMarkClass.prototype.applyDrawingParams = function (elem) {
                marks.applyShapeDrawingParams(elem, this._drawingParams);
            };
            return rectangleMarkClass;
        }(marks.markBaseClass));
        marks.rectangleMarkClass = rectangleMarkClass;
        function createRectangleMark(container, className) {
            return new rectangleMarkClass(container, className);
        }
        marks.createRectangleMark = createRectangleMark;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// textMark.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas text primitives.  Can be used with animations.  Core function
        is "update()". */
        var textMarkClass = (function (_super) {
            __extends(textMarkClass, _super);
            function textMarkClass(container, className) {
                _super.call(this, container, "text", null, false, className);
                //vp.utils.trace("ctr", "textMark");
            }
            // private 
            textMarkClass.prototype.applyDrawingParams = function (elem) {
                marks.applyTextParams(elem, this._drawingParams);
            };
            return textMarkClass;
        }(marks.markBaseClass));
        marks.textMarkClass = textMarkClass;
        function createTextMark(container, className) {
            return new textMarkClass(container, className);
        }
        marks.createTextMark = createTextMark;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// triangleMark.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** Supports data-based generation of WebGL triangle primitives.  Can be used with animations.  Core function
        is "update()". */
        var triangleMarkClass = (function (_super) {
            __extends(triangleMarkClass, _super);
            function triangleMarkClass(container, className) {
                _super.call(this, container, null, "triangle", true, className);
                //vp.utils.trace("ctr", "triangleMark");
            }
            triangleMarkClass.prototype.postProcessShape = function (element) {
                var wrap = vp.select(element);
                var size = wrap.attr("size");
                wrap
                    .attr("width", size)
                    .attr("height", size);
            };
            return triangleMarkClass;
        }(marks.markBaseClass));
        marks.triangleMarkClass = triangleMarkClass;
        function createTriangleMark(container, className) {
            return new triangleMarkClass(container, className);
        }
        marks.createTriangleMark = createTriangleMark;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// quadTree.ts.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlotCore library.
///-----------------------------------------------------------------------------------------------------------------
/// quadTreeClass code adapted from this algorithm:   http://en.wikipedia.org/wiki/Quadtree
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var layouts;
    (function (layouts) {
        /** A structure for accelerating N-body type calculations. */
        var quadTreeClass = (function () {
            function quadTreeClass(points) {
                this.points = points;
                this.buildTree();
            }
            quadTreeClass.prototype.buildTree = function () {
                var points = this.points;
                var xMin = Math.floor(points.min(function (data) { return data.x; }));
                var xMax = Math.ceil(points.max(function (data) { return data.x; }));
                var yMin = Math.floor(points.min(function (data) { return data.y; }));
                var yMax = Math.ceil(points.max(function (data) { return data.y; }));
                var root = new quadNodeClass(xMin, yMin, xMax, yMax);
                this.rootNode = root;
                for (var i = 0; i < points.length; i++) {
                    var pt = points[i];
                    root.insert(pt);
                }
            };
            /** Visits each node of the tree in pre-order. */
            quadTreeClass.prototype.visit = function (callback) {
                this.rootNode.visit(callback);
            };
            /** Visits each node of the tree in post-order. */
            quadTreeClass.prototype.visitPostOrder = function (callback, visitEmptyNodes) {
                if (visitEmptyNodes === void 0) { visitEmptyNodes = false; }
                this.rootNode.postOrder(callback, visitEmptyNodes);
            };
            return quadTreeClass;
        }());
        layouts.quadTreeClass = quadTreeClass;
        var quadNodeClass = (function () {
            function quadNodeClass(left, top, right, bottom) {
                this.left = left;
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.isLeaf = true;
            }
            quadNodeClass.prototype.postOrder = function (callback, visitEmptyNodes) {
                if (this.nodes && this.nodes.length) {
                    for (var i = 0; i < this.nodes.length; i++) {
                        var childNode = this.nodes[i];
                        if (childNode.point || visitEmptyNodes) {
                            childNode.postOrder(callback, visitEmptyNodes);
                        }
                    }
                }
                callback(this, this.left, this.top, this.right, this.bottom);
            };
            quadNodeClass.prototype.insert = function (pt) {
                if (!this.containsPoint(pt)) {
                    //---- pt doesn't belong in this node ----
                    return false;
                }
                if (!this.point) {
                    this.point = pt;
                    return true;
                }
                if (!this.nodes) {
                    this.subdivide();
                }
                //---- insert in 1 of our 4 nodes ----
                for (var i = 0; i < this.nodes.length; i++) {
                    var node = this.nodes[i];
                    if (node.insert(pt)) {
                        return true;
                    }
                }
                //---- could not insert ----
                throw "Error: could not insert point in quadTree: " + pt.x + ", " + pt.y;
            };
            quadNodeClass.prototype.subdivide = function () {
                //---- create 4 subnodes ----
                if (!this.nodes) {
                    var nodes = [];
                    this.nodes = nodes;
                    var xMid = (this.right + this.left) / 2;
                    var yMid = (this.bottom + this.top) / 2;
                    //---- watch out for floating point issues are these get super small in degenerate cases ----
                    //---- where all nodes are in same approximate location ----
                    var nwNode = new quadNodeClass(this.left, this.top, xMid, yMid);
                    nodes.push(nwNode);
                    var neNode = new quadNodeClass(xMid, this.top, this.right, yMid);
                    nodes.push(neNode);
                    var swNode = new quadNodeClass(this.left, yMid, xMid, this.bottom);
                    nodes.push(swNode);
                    var seNode = new quadNodeClass(xMid, yMid, this.right, this.bottom);
                    nodes.push(seNode);
                    this.isLeaf = false;
                }
            };
            quadNodeClass.prototype.visit = function (callback) {
                var skipChildren = callback(this, this.left, this.top, this.right, this.bottom);
                if ((!skipChildren) && (this.nodes)) {
                    for (var i = 0; i < this.nodes.length; i++) {
                        var node = this.nodes[i];
                        node.visit(callback);
                    }
                }
            };
            quadNodeClass.prototype.containsPoint = function (pt) {
                var contains = false;
                if (pt.x >= this.left && pt.x <= this.right) {
                    contains = (pt.y >= this.top && pt.y <= this.bottom);
                }
                return contains;
            };
            return quadNodeClass;
        }());
        layouts.quadNodeClass = quadNodeClass;
        function createQuadTree(points) {
            return new quadTreeClass(points);
        }
        layouts.createQuadTree = createQuadTree;
    })(layouts = vp.layouts || (vp.layouts = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// dragHelper.ts.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlotCore library.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var layouts;
    (function (layouts) {
        /** Supports dragstart, drag, dragend events. */
        var dragHelperClass = (function () {
            function dragHelperClass(ownerCallback) {
                var _this = this;
                this._onDragStartCallback = null;
                this._onDragCallback = null;
                this._onDragEndCallback = null;
                this._dragElem = null;
                this._ownerCallback = null;
                this._ownerCallback = ownerCallback;
                vp.events.attach(window, "mousemove", function (e) {
                    _this.dragging(e);
                });
                vp.events.attach(window, "mouseup", function (e) {
                    _this.endDragging(e);
                });
            }
            dragHelperClass.prototype.addElements = function (elements) {
                for (var i = 0; i < elements.length; i++) {
                    var elem = elements[i];
                    this.addElement(elem);
                }
            };
            dragHelperClass.prototype.addElement = function (elem) {
                var _this = this;
                vp.select(elem)
                    .attach("mousedown", function (e) {
                    _this.startDragging(e);
                });
            };
            dragHelperClass.prototype.startDragging = function (e) {
                this._dragElem = e.target;
                if (this._ownerCallback) {
                    this._ownerCallback("dragstart", this._dragElem, e);
                }
                if (this._onDragStartCallback) {
                    this._onDragStartCallback(e);
                }
            };
            dragHelperClass.prototype.dragging = function (e) {
                if (this._dragElem) {
                    if (this._ownerCallback) {
                        this._ownerCallback("drag", this._dragElem, e);
                    }
                    if (this._onDragCallback) {
                        this._onDragCallback(e);
                    }
                }
            };
            dragHelperClass.prototype.endDragging = function (e) {
                var elem = this._dragElem;
                if (elem) {
                    this._dragElem = null;
                    if (this._ownerCallback) {
                        this._ownerCallback("dragend", elem, e);
                    }
                    if (this._onDragEndCallback) {
                        this._onDragEndCallback(e);
                    }
                }
            };
            dragHelperClass.prototype.onDragStart = function (callback) {
                if (arguments.length == 0) {
                    return this._onDragStartCallback;
                }
                this._onDragStartCallback = callback;
                return this;
            };
            dragHelperClass.prototype.onDrag = function (callback) {
                if (arguments.length == 0) {
                    return this._onDragCallback;
                }
                this._onDragCallback = callback;
                return this;
            };
            dragHelperClass.prototype.onDragEnd = function (callback) {
                if (arguments.length == 0) {
                    return this._onDragEndCallback;
                }
                this._onDragEndCallback = callback;
                return this;
            };
            return dragHelperClass;
        }());
        layouts.dragHelperClass = dragHelperClass;
    })(layouts = vp.layouts || (vp.layouts = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// forceLayout.ts.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlotCore library.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var layouts;
    (function (layouts) {
        /// TODO: [in-progress] debug Barnes-Hut technique to speed-up node-to-node charge calculations...
        /** Layout of nodes and optional links using force directed layout. Supports start, tick, and end events. */
        var forceLayoutClass = (function () {
            function forceLayoutClass() {
                this._alpha = 0; // simulated annealing "heat" parameter
                this._friction = .9;
                this._gravity = .1;
                this._charge = -30; // number or callback func
                this._width = 100;
                this._height = 100;
                this._linkDistance = 20;
                this._linkStrength = 1;
                this._chargeDistance = Infinity;
                this._theta = .8; // Barnes-Hut parameter
                this._tickCount = 0; // stats (count the # of ticks per "sim cycle"
                this._onStartCallback = null;
                this._onTickCallback = null;
                this._onEndCallback = null;
                this._lastTickTime = 0;
                this._lastDt = 0;
                this._tickCallbackInProgress = false;
                this._dragHelper = null;
                //---- offset on element where drag started ----
                this._xDelta = 0;
                this._yDelta = 0;
                //---- stats ----
                this._totalUpdateNodesTime = 0;
                this._maxUpdateNodesTime = 0;
                this._lastStatTime = 0;
                this._onStatsCallback = null;
            }
            /** Return a drag helper class, to assist caller in dragging elements associated with "nodes". */
            forceLayoutClass.prototype.getDragHelper = function () {
                var _this = this;
                if (!this._dragHelper) {
                    this._dragHelper = new layouts.dragHelperClass(function (name, dragElem, e) {
                        _this.processDragEvent(name, dragElem, e);
                    });
                }
                return this._dragHelper;
            };
            forceLayoutClass.prototype.processDragEvent = function (name, dragElem, e) {
                var node = dragElem.dataItem.data;
                if (name == "dragstart") {
                    node.dragFixed = true;
                    var pt = vp.events.mousePosition(e);
                    this._xDelta = node.x - pt.x;
                    this._yDelta = node.y - pt.y;
                    node.x = pt.x + this._xDelta;
                    node.y = pt.y + this._yDelta;
                    this.resume();
                }
                else if (name == "drag") {
                    var pt = vp.events.mousePosition(e);
                    node.x = pt.x + this._xDelta;
                    node.y = pt.y + this._yDelta;
                    this.resume();
                }
                else if (name == "dragend") {
                    node.dragFixed = false;
                    //---- set prev close to new current position ----
                    node.px = node.x + .1 * Math.random();
                    node.py = node.y + .1 * Math.random();
                }
            };
            forceLayoutClass.prototype.start = function () {
                this.innerStart(.1);
            };
            forceLayoutClass.prototype.innerStart = function (alphaValue) {
                //this.stop();
                this._alpha = alphaValue;
                if (this._nodes && this._nodes.length) {
                    if (this._onStartCallback) {
                        this._onStartCallback(null);
                    }
                    this.initNodesAsNeeded();
                    if (this._links) {
                        this.initLinksAsNeeded();
                    }
                    ////---- stats ----
                    //this._totalUpdateNodesTime = 0;
                    //this._maxUpdateNodesTime = 0;
                    //this._tickCount = 0;
                    //this._lastStatTime = vp.utils.now();
                    if (!this._timer) {
                        this.tick(true);
                    }
                }
            };
            forceLayoutClass.prototype.initNodesAsNeeded = function () {
                var nodes = this._nodes;
                var charge = this._charge;
                var chargeFunc = vp.utils.isFunction(charge);
                for (var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    if (node.x === undefined) {
                        node.x = Math.round(Math.random() * this._width);
                        node.y = Math.round(Math.random() * this._width);
                    }
                    if (node.px === undefined) {
                        node.px = node.x + .1 * Math.random();
                        node.py = node.y + .1 * Math.random();
                    }
                    node.weight = 1;
                    //---- refresh CHARGE info for each node ----
                    node.charge = (chargeFunc) ? charge(node, i) : charge;
                }
            };
            forceLayoutClass.prototype.initLinksAsNeeded = function () {
                var links = this._links;
                var distance = this._linkDistance;
                var distanceFunc = vp.utils.isFunction(distance);
                var strength = this._linkStrength;
                var strengthFunc = vp.utils.isFunction(strength);
                //---- CACHE distance and strength values ----
                for (var i = 0; i < links.length; i++) {
                    var link = links[i];
                    link.distance = (distanceFunc) ? distance(link, i) : distance;
                    link.strength = (strengthFunc) ? strength(link, i) : strength;
                    //---- adjust weight of connected nodes ----
                    link.source.weight++;
                    link.target.weight++;
                }
            };
            forceLayoutClass.prototype.stop = function () {
                if (this._timer) {
                    this.onStopped();
                }
            };
            forceLayoutClass.prototype.onStopped = function () {
                if (this._timer) {
                    vp.animation.cancelAnimationFrame(this._timer);
                    this._timer = undefined;
                }
                this._alpha = 0;
                if (this._onEndCallback) {
                    this._onEndCallback(null);
                }
                //vp.utils.debug("forceLayout.stop called");
            };
            forceLayoutClass.prototype.resume = function () {
                this.innerStart(.1);
            };
            forceLayoutClass.prototype.tick = function (startTimer) {
                var _this = this;
                var now = vp.utils.now();
                var delta = now - this._lastStatTime;
                if (delta > 1000) {
                    var tps = Math.round(this._tickCount / (delta / 1000));
                    if (this._onStatsCallback) {
                        this._onStatsCallback(tps, this._maxUpdateNodesTime, this._totalUpdateNodesTime / tps);
                    }
                    this._lastStatTime = now;
                    this._tickCount = 0;
                    this._maxUpdateNodesTime = 0;
                    this._totalUpdateNodesTime = 0;
                }
                var started = vp.utils.now();
                this.updateNodes();
                var elapsed = vp.utils.now() - started;
                this._totalUpdateNodesTime += elapsed;
                this._maxUpdateNodesTime = Math.max(this._maxUpdateNodesTime, elapsed);
                if (this._onTickCallback) {
                    this._tickCallbackInProgress = true;
                    try {
                        this._onTickCallback(null, this._quadTree);
                    }
                    finally {
                        this._tickCallbackInProgress = false;
                    }
                }
                var alphaDecayFactor = .99; // .97
                this._alpha *= alphaDecayFactor;
                if (this._alpha <= .0005) {
                    this._alpha = 0;
                }
                this._tickCount++;
                this._lastTickTime = vp.utils.now();
                //vp.utils.debug("forceLayout.tick: alpha=" + this._alpha + ", tickCount=" + this._tickCount);
                if (this._alpha > 0 && startTimer) {
                    this._timer = vp.animation.requestAnimationFrame(function (e) {
                        _this.tick(true);
                    });
                }
                else {
                    this.onStopped();
                }
            };
            forceLayoutClass.prototype.updateNodes = function () {
                if (this._tickCallbackInProgress) {
                    throw "Error - updateNodes() called while tick callback in progress";
                }
                var nodes = this._nodes;
                var quadTree = null;
                if (this._charge && this._theta) {
                    quadTree = vp.layouts.createQuadTree(nodes);
                    this.addMassToQuadTree(quadTree);
                }
                this._quadTree = quadTree;
                //---- values for "dt" between .2 and .4 work best so far ----
                var dt = .2 + .2 * Math.random();
                //var dt = (this._lastTickTime) ? (this._lastTickTime - Date.now())/.3 : Math.random();
                for (var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    if (!node.dragFixed && !node.fixed) {
                        var lastDt = (this._lastDt) ? this._lastDt : dt;
                        this.updateNode(node, quadTree, dt, lastDt);
                    }
                }
                this._lastDt = dt;
            };
            forceLayoutClass.prototype.addMassToQuadTree = function (quadTree) {
                //---- visit each node, from children to their parents ----
                quadTree.visitPostOrder(function (origNode, left, top, right, bottom) {
                    //---- note: we only visit non-empty quadNodes, so "point" will be set ----
                    var qtNode = origNode;
                    var totalMass = 0;
                    var xCom = 0;
                    var yCom = 0;
                    //---- first, calculate the total mass for this qtNode ----
                    var node = qtNode.point;
                    totalMass = node.charge;
                    if (qtNode.nodes) {
                        for (var i = 0; i < qtNode.nodes.length; i++) {
                            var qtChild = qtNode.nodes[i];
                            if (qtChild.point) {
                                totalMass += qtChild.totalMass;
                            }
                        }
                    }
                    //---- now, calculate the center of mass ----
                    var factor = (totalMass) ? node.charge / totalMass : 1;
                    xCom += factor * node.x;
                    yCom += factor * node.y;
                    if (qtNode.nodes) {
                        for (var i = 0; i < qtNode.nodes.length; i++) {
                            var qtChild = qtNode.nodes[i];
                            if (qtChild.point) {
                                var factor = (totalMass) ? qtChild.totalMass / totalMass : 1;
                                xCom += factor * qtChild.xCom;
                                yCom += factor * qtChild.yCom;
                            }
                        }
                    }
                    qtNode.totalMass = totalMass;
                    qtNode.xCom = xCom;
                    qtNode.yCom = yCom;
                });
            };
            forceLayoutClass.prototype.updateNode = function (node, quadTree, dt, lastDt) {
                if (isNaN(node.x) || isNaN(node.y)) {
                    throw "Error - nan value found in node";
                }
                var forceTotal = { x: 0, y: 0 };
                //---- compute force from GRAVITY (modified by distance from center) ----
                var cx = this._width / 2;
                var cy = this._height / 2;
                this.addForceWithDistance(node, { x: cx, y: cy, id: -1 }, this._gravity, Infinity, "*", forceTotal);
                //---- compute force from OTHER NODES ----
                if (this._charge) {
                    var result = this.computeNodeForces(node, quadTree);
                    forceTotal.x += result.x;
                    forceTotal.y += result.y;
                    if (node.id == 1) {
                    }
                }
                if (this._linkDistance && this._links) {
                    result = this.computeLinkForces(node);
                    forceTotal.x += result.x;
                    forceTotal.y += result.y;
                }
                //---- apply force using Verlet Integration, with friction ----
                var dt2 = dt * dt;
                var maxTickCount = 300;
                var decayingPercent = (maxTickCount - this._tickCount) / maxTickCount;
                var px = node.px;
                var py = node.py;
                node.px = node.x;
                node.py = node.y;
                var x = node.x;
                var y = node.y;
                //---- verlet formulas from: http://en.wikipedia.org/wiki/Verlet_integration ----
                //---- regular verlet ----
                //node.x = node.x + (node.x - px) + forceX/node.weight * dt2;
                //node.y = node.y + (node.y - py) + forceY/node.weight * dt2;
                //---- time-corrected verlet ----
                //node.x = node.x + (node.x - px)*dt/lastDt + forceX / node.weight * dt2;
                //node.y = node.y + (node.y - py)*dt/lastDt + forceY / node.weight * dt2;
                //---- basic stormer-verlet ----
                //node.x = 2 * node.x - px + forceX/node.weight * dt2;
                //node.y = 2 * node.y - py + forceY/node.weight * dt2;
                //---- basic stormer-verlet with friction ----
                //node.x = (2 - f) * node.x - (1 - f)px + forceX/node.weight * dt2;
                //node.y = (2 - f) * node.y - (1 - f)py + forceY/node.weight * dt2;
                //---- warning: heatFactor exceeding .9 will cause unstable behavior ----
                //var heatFactor = 9.5 * this._alpha;   
                var heatFactor = (this._tickCount < 75) ? .85 : (0 + .95 * decayingPercent); // linear decay (vs alpha decay)
                heatFactor *= this._friction;
                //---- regular verlet with heat on momentum ----
                node.x = x + (x - px) * heatFactor + forceTotal.x / node.weight * dt2;
                node.y = y + (y - py) * heatFactor + forceTotal.y / node.weight * dt2;
                if (isNaN(node.x) || isNaN(node.y)) {
                    throw "Error - nan value found in node";
                }
            };
            forceLayoutClass.prototype.computeLinkForces = function (node) {
                var links = this._links;
                var force = { x: 0, y: 0 };
                for (var i = 0; i < links.length; i++) {
                    var link = links[i];
                    if (link.source == node) {
                        this.computeLinkForce(node, link.target, link, force);
                    }
                    else if (link.target == node) {
                        this.computeLinkForce(node, link.source, link, force);
                    }
                }
                return force;
            };
            forceLayoutClass.prototype.computeLinkForce = function (node, target, link, forceTotal) {
                //---- compute distance between node & target ----
                var dx = node.x - target.x;
                var dy = node.y - target.y;
                var dist = Math.sqrt(dx * dx + dy * dy);
                var delta = link.distance - dist;
                var rawForce = delta * link.strength;
                this.addForceWithDistance(target, node, rawForce, Infinity, null, forceTotal);
            };
            forceLayoutClass.prototype.computeNodeForces = function (fromNode, quadTree) {
                var nodes = this._nodes;
                var forceTotal = { x: 0, y: 0 };
                if (this._theta) {
                    //---- use Barnes-Hut trick for caclulating force faster ----
                    this.computeQuadTreeNodeForce(fromNode, quadTree.rootNode, forceTotal);
                }
                else {
                    //---- calc force 1-1 with all other nodes ----
                    for (var i = 0; i < nodes.length; i++) {
                        var node = nodes[i];
                        if (node != fromNode) {
                            this.addForceWithDistance(fromNode, node, node.charge, this._chargeDistance, "/", forceTotal);
                        }
                    }
                }
                return forceTotal;
            };
            forceLayoutClass.prototype.addForceWithDistance = function (from, to, charge, maxDistance, distOp, forceTotal) {
                if (charge) {
                    var dx = to.x - from.x;
                    var dy = to.y - from.y;
                    var dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < maxDistance) {
                        var rawForce;
                        if (distOp === "*") {
                            rawForce = charge * dist;
                        }
                        else if (distOp === "/") {
                            rawForce = (dist > .000001) ? (charge / dist) : 0;
                        }
                        else {
                            rawForce = charge;
                        }
                        if (rawForce) {
                            //---- separate rawForce into X and Y components ----
                            var radians = Math.atan2(dy, dx);
                            var fx = Math.cos(radians) * rawForce;
                            var fy = Math.sin(radians) * rawForce;
                            forceTotal.x += fx;
                            forceTotal.y += fy;
                        }
                    }
                }
            };
            forceLayoutClass.prototype.computeQuadTreeNodeForce = function (node, qtNode, forceTotal) {
                //---- compute distance between node and center of mass of qtNode ----
                var dx = node.x - qtNode.xCom;
                var dy = node.y - qtNode.yCom;
                var dist = Math.sqrt(dx * dx + dy * dy);
                var regionWidth = qtNode.right - qtNode.left;
                var ratio = regionWidth / dist;
                //vp.utils.debug("ratio: " + ratio + ", regionWidth: " + regionWidth + ", dist: " + dist);
                if (ratio < this._theta) {
                    //---- use shortcut ----
                    this.addForceWithDistance(node, { x: qtNode.xCom, y: qtNode.yCom }, qtNode.totalMass, this._chargeDistance, "/", forceTotal);
                }
                else {
                    //---- calc with qtNode: point, and 4 child nodes ----
                    if (qtNode.point && qtNode.point != node) {
                        var ptNode = qtNode.point;
                        this.addForceWithDistance(node, ptNode, ptNode.charge, this._chargeDistance, "/", forceTotal);
                    }
                    if (qtNode.nodes) {
                        for (var i = 0; i < qtNode.nodes.length; i++) {
                            var childNode = qtNode.nodes[i];
                            if (childNode.point) {
                                this.computeQuadTreeNodeForce(node, childNode, forceTotal);
                            }
                        }
                    }
                }
            };
            forceLayoutClass.prototype.onStart = function (callback) {
                this._onStartCallback = callback;
                return this;
            };
            forceLayoutClass.prototype.onTick = function (callback) {
                this._onTickCallback = callback;
                return this;
            };
            forceLayoutClass.prototype.onEnd = function (callback) {
                this._onEndCallback = callback;
                return this;
            };
            forceLayoutClass.prototype.onStats = function (callback) {
                this._onStatsCallback = callback;
                return this;
            };
            forceLayoutClass.prototype.nodes = function (value) {
                if (arguments.length === 0) {
                    return this._nodes;
                }
                this._nodes = value;
                return this;
            };
            forceLayoutClass.prototype.links = function (value) {
                if (arguments.length === 0) {
                    return this._links;
                }
                this._links = value;
                return this;
            };
            forceLayoutClass.prototype.gravity = function (value) {
                if (arguments.length === 0) {
                    return this._gravity;
                }
                this._gravity = value;
                return this;
            };
            forceLayoutClass.prototype.charge = function (value) {
                if (arguments.length === 0) {
                    return this._charge;
                }
                this._charge = value;
                return this;
            };
            forceLayoutClass.prototype.width = function (value) {
                if (arguments.length === 0) {
                    return this._width;
                }
                this._width = value;
                return this;
            };
            forceLayoutClass.prototype.height = function (value) {
                if (arguments.length === 0) {
                    return this._height;
                }
                this._height = value;
                return this;
            };
            forceLayoutClass.prototype.alpha = function (value) {
                if (arguments.length === 0) {
                    return this._alpha;
                }
                this._alpha = value;
                if (!this._timer && value > 0) {
                    this.innerStart(this._alpha);
                }
                return this;
            };
            forceLayoutClass.prototype.chargeDistance = function (value) {
                if (arguments.length === 0) {
                    return this._chargeDistance;
                }
                this._chargeDistance = value;
                return this;
            };
            forceLayoutClass.prototype.linkDistance = function (value) {
                if (arguments.length === 0) {
                    return this._linkDistance;
                }
                this._linkDistance = value;
                return this;
            };
            forceLayoutClass.prototype.theta = function (value) {
                if (arguments.length === 0) {
                    return this._theta;
                }
                this._theta = value;
                return this;
            };
            forceLayoutClass.prototype.friction = function (value) {
                if (arguments.length === 0) {
                    return this._friction;
                }
                this._friction = value;
                return this;
            };
            return forceLayoutClass;
        }());
        layouts.forceLayoutClass = forceLayoutClass;
        function createForceLayout() {
            return new forceLayoutClass();
        }
        layouts.createForceLayout = createForceLayout;
        var quadNodeMass = (function (_super) {
            __extends(quadNodeMass, _super);
            function quadNodeMass() {
                _super.apply(this, arguments);
            }
            return quadNodeMass;
        }(layouts.quadNodeClass));
        layouts.quadNodeMass = quadNodeMass;
    })(layouts = vp.layouts || (vp.layouts = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// buildPie.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var paths;
    (function (paths_1) {
        function buildPie(data, cx, cy, innerRadius, outerRadius, createCanvasPath, callback) {
            var paths = [];
            var lastX = null;
            var lastYMin = null;
            var lastYMax = null;
            var yValues = [];
            //---- first pass - collect all the data ----
            for (var i = 0; i < data.length; i++) {
                var record = data[i];
                var info = { y: 100 };
                callback(record, i, info);
                yValues.push(info.y);
            }
            var abc = "hi there";
            if (abc.startsWith("dkdk")) {
            }
            //---- second pass - normalize the data ----
            var sum = yValues.sum(function (d) {
                return Math.abs(d);
            });
            var rotation = 0;
            //---- third pass - generate the slices ----
            for (var i = 0; i < data.length; i++) {
                var angle = 360 * (yValues[i] / sum);
                var path = getPieSlicePath(cx, cy, innerRadius, outerRadius, angle, rotation, createCanvasPath);
                paths.push(path);
                rotation += angle;
            }
            return paths;
        }
        paths_1.buildPie = buildPie;
        function placeOnCircle(ptCenter, radius, rotationDegrees) {
            rotationDegrees -= 90; // make 0 degrees start "12:00" position
            var radians = rotationDegrees * (Math.PI / 180);
            var xEnd = ptCenter.x + Math.cos(radians) * radius;
            var yEnd = ptCenter.y + Math.sin(radians) * radius;
            return { x: xEnd, y: yEnd };
        }
        //---- draw ARC from current point to ptEnd ----
        function makeArc(arcDegrees, sweepClockwise, radius, ptEnd) {
            var isLarge = (arcDegrees >= 180) ? 1 : 0;
            var sweepFlag = (sweepClockwise) ? 1 : 0;
            var path = "A" + radius + "," + radius + ",0," + isLarge + "," + sweepFlag + "," +
                ptEnd.x + "," + ptEnd.y + " ";
            return path;
        }
        function pointAlongLine(ptStart, ptEnd, dist) {
            var x = ptStart.x + dist * (ptEnd.x - ptStart.x);
            var y = ptStart.y + dist * (ptEnd.y - ptStart.y);
            var pt = { x: x, y: y };
            return pt;
        }
        function getPieSlicePath(xCenter, yCenter, innerRadius, outerRadius, angleDegrees, rotation, createCanvasPath) {
            var path = null;
            if (createCanvasPath) {
                path = getPieSlicePathCanvas(xCenter, yCenter, innerRadius, outerRadius, angleDegrees, rotation);
            }
            else {
                path = getPieSlicePathSvg(xCenter, yCenter, innerRadius, outerRadius, angleDegrees, rotation);
            }
            return path;
        }
        paths_1.getPieSlicePath = getPieSlicePath;
        function getPieSlicePathSvg(xCenter, yCenter, innerRadius, outerRadius, angleDegrees, rotation) {
            var ptCenter = { x: xCenter, y: yCenter };
            var ptStart = { x: xCenter, y: yCenter };
            if (innerRadius > 0) {
                //ptStart.x += innerRadius;
                ptStart = placeOnCircle(ptCenter, innerRadius, rotation);
            }
            var path = "M" + ptStart.x + "," + ptStart.y + " ";
            var fullPie = false;
            if (angleDegrees >= 360) {
                fullPie = true;
                //---- the ARC cmd cannot draw a full circle, but this value seems to work well ----
                angleDegrees = 359.999;
            }
            var ptArc = placeOnCircle(ptCenter, outerRadius, rotation);
            if (!fullPie) {
                //---- first line (extends to the start of the arc) ----
                path += "L" + ptArc.x + "," + ptArc.y + " ";
            }
            else {
                path += "M" + ptArc.x + "," + ptArc.y + " ";
            }
            //---- the arc ----
            var ptArcEnd = placeOnCircle(ptCenter, outerRadius, rotation + angleDegrees);
            var arc = makeArc(angleDegrees, true, outerRadius, ptArcEnd);
            path += arc;
            if (innerRadius > 0) {
                var ptEnd = placeOnCircle(ptCenter, innerRadius, rotation + angleDegrees);
                if (fullPie) {
                    //---- need to move to ptEnd ---
                    path += "M" + ptEnd.x + "," + ptEnd.y + " ";
                }
                else {
                    //---- draw a line to ptEnd ----
                    path += "L" + ptEnd.x + "," + ptEnd.y + " ";
                }
                //---- reverse, innner arc ----
                var arc2 = makeArc(angleDegrees, false, innerRadius, ptStart);
                path += arc2;
            }
            path += "Z"; // close path
            //---- test ----
            //path = "M 100 100 L 300 100 L 200 300 z";
            return path;
        }
        paths_1.getPieSlicePathSvg = getPieSlicePathSvg;
        function getPieSlicePathCanvas(xCenter, yCenter, innerRadius, outerRadius, angleDegrees, rotation) {
            var ptCenter = { x: xCenter, y: yCenter };
            var ptStart = { x: xCenter, y: yCenter };
            if (innerRadius > 0) {
                //ptStart.x += innerRadius;
                ptStart = placeOnCircle(ptCenter, innerRadius, rotation);
            }
            var path = "M" + ptStart.x + "," + ptStart.y + " ";
            var fullPie = false;
            if (angleDegrees >= 360) {
                fullPie = true;
                //---- the ARC cmd cannot draw a full circle, but this value seems to work well ----
                angleDegrees = 359.999;
            }
            var ptArc = placeOnCircle(ptCenter, outerRadius, rotation);
            if (!fullPie) {
                //---- first line (extends to the start of the arc) ----
                path += "L" + ptArc.x + "," + ptArc.y + " ";
            }
            else {
                path += "M" + ptArc.x + "," + ptArc.y + " ";
            }
            var startAngle = (rotation - 90) * Math.PI / 180; // convert to radians
            var endAngle = (rotation - 90 + angleDegrees) * Math.PI / 180; // convert to radians
            //---- the arc ----
            var ptArcEnd = placeOnCircle(ptCenter, outerRadius, rotation + angleDegrees);
            //var arc = makeArc(angleDegrees, true, outerRadius, ptArcEnd);
            var arc = "X" + xCenter + "," + yCenter + "," + outerRadius + "," + startAngle + "," + endAngle + ",0 ";
            arc += "M" + ptArcEnd.x + "," + ptArcEnd.y + " "; // move current point to end of arc
            path += arc;
            if (innerRadius > 0) {
                var ptEnd = placeOnCircle(ptCenter, innerRadius, rotation + angleDegrees);
                if (fullPie) {
                    //---- need to move to ptEnd ---
                    path += "M" + ptEnd.x + "," + ptEnd.y + " ";
                }
                else {
                    //---- draw a line to ptEnd ----
                    path += "L" + ptEnd.x + "," + ptEnd.y + " ";
                }
                //---- reverse, innner arc ----
                //var arc2 = makeArc(angleDegrees, false, innerRadius, ptStart);
                var arc2 = "X" + xCenter + "," + yCenter + "," + innerRadius + "," + endAngle + "," + startAngle + ",1 ";
                arc2 += "M" + ptStart.x + "," + ptStart.y + " "; // move current point to end of arc
                path += arc2;
            }
            path += "Z"; // close path
            //---- test ----
            //path = "M 100 100 L 300 100 L 200 300 z";
            return path;
        }
        paths_1.getPieSlicePathCanvas = getPieSlicePathCanvas;
    })(paths = vp.paths || (vp.paths = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// curveFitting.ts.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlotCore library - curve fitting functions.
///-----------------------------------------------------------------------------------------------------------------
/// all of these functions in this file, unless specified otherwise, 
/// were adapted from book "practical WPF Charts and Graphics"
/// http://www.amazon.com/Practical-Charts-Graphics-Experts-Voice/dp/1430224819, Chapter 11 Curve Fitting.  
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var curveFitting;
    (function (curveFitting) {
        function line(xa, ya) {
            var values = {};
            if ((!xa) || (!xa.length) || (!ya) || (!ya.length)) {
                vp.utils.error("error - polyfit() requires X and Y number arrays");
            }
            if (xa.length != ya.length) {
                vp.utils.error("error - polyfit() requires that X and Y be the same size");
            }
            var count = xa.length;
            //---- model: y = slope*x + intercept ----
            var xm = average(xa);
            var ym = average(ya);
            var btop = 0;
            var bbot = 0;
            for (var i = 0; i < count; i++) {
                btop += (ya[i] * (xa[i] - xm));
                bbot += (xa[i] * (xa[i] - xm));
            }
            var slope = btop / bbot;
            var intercept = ym - xm * slope;
            var sigma = 0;
            for (var i = 0; i < count; i++) {
                var t = ya[i] - intercept - (slope * xa[i]);
                sigma += t * t;
            }
            sigma = Math.sqrt(sigma / (count - 2));
            var ptFrom = { x: xa[0], y: slope * xa[0] + intercept };
            var ptTo = { x: xa[count - 1], y: slope * xa[count - 1] + intercept };
            values = { slope: slope, intercept: intercept, sigma: sigma, ptFrom: ptFrom, ptTo: ptTo };
            return values;
        }
        curveFitting.line = line;
        function average(nums) {
            var total = 0;
            var count = nums.length;
            for (var i = 0; i < nums.length; i++) {
                total += nums[i];
            }
            var avg = (count > 0) ? total / count : 0;
            return avg;
        }
        function matrix2d(rows, cols) {
            var m = [];
            for (var i = 0; i < rows; i++) {
                var row = [];
                for (var j = 0; j < cols; j++) {
                    row.push(0);
                }
                m.push(row);
            }
            return m;
        }
        function vector(cols) {
            var row = [];
            for (var j = 0; j < cols; j++) {
                row.push(0);
            }
            return row;
        }
        //export function linRegressPoly(xa, ya, degree)
        //{
        //    var f0 = function(x) {return 1;}
        //    var f1 = function(x) {return x;}
        //    var f2 = function(x) {return x*x;}
        //    var f3 = function(x) {return x*x*x;}
        //    var f = null;
        //    if (degree == 1)
        //    {
        //        f = [f0, f1];
        //    }
        //    else if (degree == 2)
        //    {
        //        f = [f0, f1, f2];
        //    }
        //    else if (degree == 3)
        //    {
        //        f = [f0, f1, f2, f3];
        //    }
        //    var result = export function linearRegression(xa, ya, f);
        //    return result;
        //}
        /// "xa" are the x data values, "ya" are the y data values, "degree" is the polynomial degress (1, 2, ...)
        function polyFit(xa, ya, degree) {
            var m = degree + 1;
            var a = matrix2d(m, m);
            var b = vector(m);
            var n = xa.length;
            for (var k = 0; k < m; k++) {
                b[k] = 0;
                for (var i = 0; i < n; i++) {
                    b[k] += Math.pow(xa[i], k) * ya[i];
                }
            }
            for (var j = 0; j < m; j++) {
                for (var k = 0; k < m; k++) {
                    a[j][k] = 0;
                    for (var i = 0; i < n; i++) {
                        a[j][k] += Math.pow(xa[i], j + k);
                    }
                }
            }
            var coef = gaussJordan(a, b);
            //---- calculate the std deviation ----
            var s = 0;
            for (var i = 0; i < n; i++) {
                var s1 = 0;
                for (var j = 0; j < m; j++) {
                    s1 += coef[j] * Math.pow(xa[i], j);
                }
                s += (ya[i] - s1) * (ya[i] - s1);
            }
            var sigma = Math.sqrt(s / (n - m));
            return { coef: coef, sigma: sigma };
        }
        curveFitting.polyFit = polyFit;
        /// "xa" are the x data values, "ya" are the y data values, "wa" are the weight values.
        function weightedLinearRegression(xa, ya, wa) {
            var n = xa.length;
            var xw = 0;
            var yw = 0;
            var b1 = 0;
            var b2 = 0;
            var a = 0;
            var b = 0;
            for (var i = 0; i < n; i++) {
                xw += xa[i] / n;
                yw = ya[i] / n;
            }
            for (var i = 0; i < n; i++) {
                b1 += wa[i] * wa[i] * ya[i] * (xa[i] - xw);
                //b2 += wa[i] * wa[i] * xa[i] * (xa[i] - xw);
                b2 += wa[i] * wa[i] * xa[i] * (ya[i] - yw);
            }
            b = b1 / b2;
            a = yw - xw * b;
            return { coef: [a, b] };
        }
        curveFitting.weightedLinearRegression = weightedLinearRegression;
        /// "xa" are the x data values, "ya" are the y data values, "degree" is the polynomial degress (1, 2, ...)
        function exponentialFit(xa, ya) {
            var logy = [];
            for (var i = 0; i < ya.length; i++) {
                logy[i] = Math.log(ya[i]);
            }
            var result = weightedLinearRegression(xa, logy, ya);
            return result;
        }
        curveFitting.exponentialFit = exponentialFit;
        /// "xa" are the x data values, "ya" are the y data values, "f" is an array of model func (usually returns x**N).
        function linearRegression(xa, ya, f) {
            var m = f.length;
            var a = matrix2d(m, m);
            var b = vector(m);
            var n = xa.length;
            for (var k = 0; k < m; k++) {
                b[k] = 0;
                for (var i = 0; i < n; i++) {
                    var result = f[k](xa[i]);
                    var term = result * ya[i];
                    b[k] += term;
                }
            }
            for (var j = 0; j < m; j++) {
                for (var k = 0; k < m; k++) {
                    a[j][k] = 0;
                    for (var i = 0; i < n; i++) {
                        var result = f[j](xa[i]);
                        var result2 = f[k](xa[i]);
                        var term = result * result2;
                        a[j][k] += term;
                    }
                }
            }
            var coef = gaussJordan(a, b);
            //---- calculate the std deviation ----
            var s = 0;
            for (var i = 0; i < n; i++) {
                var s1 = 0;
                for (var j = 0; j < m; j++) {
                    s1 += coef[j] * f[j](xa[i]);
                }
                s += (ya[i] - s1) * (ya[i] - s1);
            }
            var sigma = Math.sqrt(s / (n - m));
            return { coef: coef, sigma: sigma };
        }
        curveFitting.linearRegression = linearRegression;
        /// "a" is Matrix, "b" is array.
        function gaussJordan(a, b) {
            triangulate(a, b);
            var n = b.length;
            var x = vector(n);
            for (var i = n - 1; i >= 0; i--) {
                var d = a[i][i];
                if (Math.abs(d) < 1.0e-500) {
                    vp.utils.error("error: diagnoal element is too small for GaussJordan");
                }
                x[i] = (b[i] - dotProduct(a[i], x)) / d;
            }
            return x;
        }
        /// "a" is array, "b" is array.
        function dotProduct(a, b) {
            var sum = 0;
            for (var i = 0; i < a.length; i++) {
                sum += a[i] * b[i];
            }
            return sum;
        }
        /// "a" is Matrix, "b" is array.
        function triangulate(a, b) {
            var n = a.length;
            var v = vector(n);
            for (var i = 0; i < n - 1; i++) {
                var d = pivot(a, b, i);
                if (Math.abs(d) < 1.0e-500) {
                    vp.utils.error("error: diagnoal element is too small for triangulate");
                }
                for (var j = i + 1; j < n; j++) {
                    var dd = a[j][i] / d;
                    for (var k = i + 1; k < n; k++) {
                        a[j][k] -= dd * a[i][k];
                    }
                    b[j] -= dd * b[i];
                }
            }
        }
        /// "a" is Matrix, "b" is array, "q" in number.
        function pivot(a, b, q) {
            var n = b.length;
            var i = q;
            var d = 0;
            for (var j = q; j < n; j++) {
                var dd = Math.abs(a[j][q]);
                if (dd > d) {
                    d = dd;
                    i = j;
                }
            }
            if (i > q) {
                //---- swap rows "q" and "i" in a ----
                var temp = a[q];
                a[q] = a[i];
                a[i] = temp;
                //---- swap elements "q" and "i" in b ----
                temp = b[q];
                b[q] = b[i];
                b[i] = temp;
            }
            return a[q][q];
        }
        function spline(xx, yy) {
            //---- convert xx,yy into points ----
            var points = xx.map(function (data, index) {
                return { x: xx[index], y: yy[index] };
            });
            var tension = .5; // controls how smooth/sharp changes are at each point
            var tensions = null;
            var segments = [];
            if (points.length == 2) {
                if (tensions) {
                    tension = tensions[0];
                }
                addSplineSegment(segments, points[0], points[0], points[1], points[1], tension, tension);
            }
            else {
                for (var i = 0; i < points.length; i++) {
                    var t1 = (tensions) ? tensions[i % tensions.length] : tension;
                    var t2 = (tensions) ? tensions[(i + 1) % tensions.length] : tension;
                    if (i == 0) {
                        addSplineSegment(segments, points[0], points[0], points[1], points[2], t1, t2);
                    }
                    else if (i == points.length - 2) {
                        addSplineSegment(segments, points[i - 1], points[i], points[i + 1], points[i + 1], t1, t2);
                    }
                    else if (i != points.length - 1) {
                        addSplineSegment(segments, points[i - 1], points[i], points[i + 1], points[i + 2], t1, t2);
                    }
                }
            }
            return segments;
        }
        curveFitting.spline = spline;
        function addSplineSegment(segments, pt0, pt1, pt2, pt3, t1, t2) {
            // adapted from Charles Petzold book:
            // See Petzold, "Programming Microsoft Windows with C#", pages 645-646 or 
            //     Petzold, "Programming Microsoft Windows with Microsoft Visual Basic .NET", pages 638-639
            // for derivation of the following formulas:
            var SX1 = t1 * (pt2.x - pt0.x);
            var SY1 = t1 * (pt2.y - pt0.y);
            var SX2 = t2 * (pt3.x - pt1.x);
            var SY2 = t2 * (pt3.y - pt1.y);
            var AX = SX1 + SX2 + 2 * pt1.x - 2 * pt2.x;
            var AY = SY1 + SY2 + 2 * pt1.y - 2 * pt2.y;
            var BX = -2 * SX1 - SX2 - 3 * pt1.x + 3 * pt2.x;
            var BY = -2 * SY1 - SY2 - 3 * pt1.y + 3 * pt2.y;
            var CX = SX1;
            var CY = SY1;
            var DX = pt1.x;
            var DY = pt1.y;
            var tolerance = .25; // .25 is the standard tolerance for curve flattening (curve to lines)
            var num = Math.floor((Math.abs(pt1.x - pt2.x) + Math.abs(pt1.y - pt2.y)) / tolerance);
            //num = 4;   // debugging
            var points = [];
            segments.push(points);
            // Notice begins at 1 so excludes the first point (which is just pt1)
            for (var i = 1; i < num; i++) {
                var t = i / (num - 1);
                var pt = {
                    x: AX * t * t * t + BX * t * t + CX * t + DX,
                    y: AY * t * t * t + BY * t * t + CY * t + DY
                };
                points.push(pt);
            }
        }
    })(curveFitting = vp.curveFitting || (vp.curveFitting = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// paths.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var paths;
    (function (paths_2) {
        function buildShape(shapeName, x, y, size, createCanvasPath) {
            var index = vp.paths.ShapeTypeNames.indexOf(shapeName);
            if (index == -1) {
                throw "Error: unknown shape name=" + shapeName;
            }
            var shapeType = index;
            var path = paths_2.getPathDataForShape(shapeType, x, y, size, size, createCanvasPath);
            return path;
        }
        paths_2.buildShape = buildShape;
        function buildLine(data, buildSinglePath, callback) {
            var paths = [];
            var lastX = null;
            var lastY = null;
            var path = "";
            for (var i = 0; i < data.length; i++) {
                var record = data[i];
                var info = { x: 0, y: 100 };
                callback(record, i, info);
                if (i == 0) {
                    lastX = info.x;
                    lastY = info.y;
                }
                if (buildSinglePath) {
                    if (i == 0) {
                        path = "M" + lastX + "," + lastY;
                    }
                    path += " L" + info.x + "," + info.y;
                }
                else {
                    path = "M" + lastX + "," + lastY;
                    path += " L" + info.x + "," + info.y;
                }
                lastX = info.x;
                lastY = info.y;
                if (!buildSinglePath) {
                    paths.push(path);
                }
            }
            if (buildSinglePath) {
                paths.push(path);
            }
            return paths;
        }
        paths_2.buildLine = buildLine;
        function buildArea(data, callback) {
            var paths = [];
            var lastX = null;
            var lastYMin = null;
            var lastYMax = null;
            for (var i = 0; i < data.length; i++) {
                var record = data[i];
                var info = { x: 0, yMin: 0, yMax: 100 };
                callback(record, i, info);
                if (i == 0) {
                    lastX = info.x;
                    lastYMin = info.yMin;
                    lastYMax = info.yMax;
                }
                var path = "M" + lastX + "," + lastYMin; // MOVE to lower left
                path += " L" + lastX + "," + lastYMax; // LINE to upper left
                path += " L" + info.x + "," + info.yMax; // LINE to upper right
                path += " L" + info.x + "," + info.yMin; // LINE to lower right
                path += " Z";
                lastX = info.x;
                lastYMin = info.yMin;
                lastYMax = info.yMax;
                paths.push(path);
            }
            return paths;
        }
        paths_2.buildArea = buildArea;
        function buildSpline(data, callback) {
            var paths = [];
            var lastX = null;
            var lastY = null;
            var path = "";
            var xa = [];
            var ya = [];
            for (var i = 0; i < data.length; i++) {
                var record = data[i];
                var info = { x: 0, y: 100 };
                callback(record, i, info);
                xa.push(info.x);
                ya.push(info.y);
            }
            //---- calc the spline path for this rect ----
            var segments = vp.curveFitting.spline(xa, ya);
            //---- create dummy path for first pt ----
            var path = "M0,0 ";
            paths.push(path);
            //---- convert segments to paths ----
            for (var s = 0; s < segments.length; s++) {
                var segment = segments[s];
                var path = "M";
                for (var i = 0; i < segment.length; i++) {
                    var pt = segment[i];
                    if (i > 0) {
                        path += "L";
                    }
                    path += pt.x + "," + pt.y + " ";
                }
                paths.push(path);
            }
            return paths;
        }
        paths_2.buildSpline = buildSpline;
    })(paths = vp.paths || (vp.paths = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// shapeData.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - uses to create paths for our set of shapeTypes.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var paths;
    (function (paths) {
        function getPathDataForShape(shapeType, x, y, w, h, createCanvasPath) {
            var move = function (str, x, y) {
                str += " M " + x + " " + y;
                return str;
            };
            var line = function (str, x, y) {
                str += " L " + x + " " + y;
                return str;
            };
            var circle = function (str, cx, cy, r) {
                if (createCanvasPath) {
                    str += " X " + cx + "," + cy + "," + r + ",0," + 2 * Math.PI + ",0";
                }
                else {
                    str += " M " + (cx - r) + " " + cy +
                        " a " + r + " " + r + " 0 1 0 " + (2 * r) + " 0" +
                        " a " + r + " " + r + " 0 1 0 " + (-2 * r) + " 0";
                }
                return str;
            };
            var close = function (str) {
                str += " z";
                return str;
            };
            var d = "";
            //---- scale our 0..1 vars as per the desired bounds ----
            var x0 = x - w / 2;
            var x1 = x + w / 2;
            var x5 = x;
            var y0 = y - h / 2;
            var y1 = y + h / 2;
            var y5 = y;
            switch (shapeType) {
                case ShapeType.triangleUp:
                    {
                        //---- triangle ----
                        d = move(d, x0, y1);
                        d = line(d, x5, y0);
                        d = line(d, x1, y1);
                        d = close(d);
                        break;
                    }
                case ShapeType.plus:
                    {
                        //---- plus sign ----
                        d = move(d, x0, y5);
                        d = line(d, x1, y5);
                        d = move(d, x5, y1);
                        d = line(d, x5, y0);
                        break;
                    }
                case ShapeType.x:
                    {
                        //---- big X ----
                        d = move(d, x0, y0);
                        d = line(d, x1, y1);
                        d = move(d, x1, y0);
                        d = line(d, x0, y1);
                        break;
                    }
                case ShapeType.diamond:
                    {
                        //---- diamond ----
                        d = move(d, x5, y0);
                        d = line(d, x0, y5);
                        d = line(d, x5, y1);
                        d = line(d, x1, y5);
                        d = line(d, x5, y0);
                        d = close(d);
                        break;
                    }
                case ShapeType.triangleDown:
                    {
                        //---- upside down triangle ----
                        d = move(d, x0, y0);
                        d = line(d, x5, y1);
                        d = line(d, x1, y0);
                        d = close(d);
                        break;
                    }
                case ShapeType.triangleLeft:
                    {
                        //---- left pointing triangle ----
                        d = move(d, x1, y0);
                        d = line(d, x1, y1);
                        d = line(d, x0, y5);
                        d = close(d);
                        break;
                    }
                case ShapeType.triangleRight:
                    {
                        //---- right pointing triangle ----
                        d = move(d, x0, y0);
                        d = line(d, x0, y1);
                        d = line(d, x1, y5);
                        d = close(d);
                        break;
                    }
                case ShapeType.pentagram:
                    {
                        //---- for pentagram ----
                        var y3 = y0 + .36 * h;
                        var y6 = y0 + .62 * h;
                        var y7 = y0 + .76 * h;
                        var x2 = x0 + .19 * w;
                        var x3 = x0 + .31 * w;
                        var x4 = x0 + .37 * w;
                        var x6 = x0 + .63 * w;
                        var x7 = x0 + .69 * w;
                        var x8 = x0 + .85 * w;
                        //---- 5 point star ----
                        d = move(d, x5, y0);
                        d = line(d, x6, y3);
                        d = line(d, x1, y3);
                        d = line(d, x7, y6);
                        d = line(d, x8, y1);
                        d = line(d, x5, y7);
                        d = line(d, x2, y1);
                        d = line(d, x3, y6);
                        d = line(d, x0, y3);
                        d = line(d, x4, y3);
                        d = close(d);
                        break;
                    }
                case ShapeType.hexagram:
                    {
                        //---- for hexagram ----
                        var y2 = y0 + .25 * h;
                        var y7 = y0 + .75 * h;
                        var x2 = x0 + .21 * w;
                        var x3 = x0 + .36 * w;
                        var x6 = x0 + .64 * w;
                        var x8 = x0 + .80 * w;
                        //---- 5 point star ----
                        d = move(d, x5, y0);
                        d = line(d, x6, y2);
                        d = line(d, x1, y2);
                        d = line(d, x8, y5);
                        d = line(d, x1, y7);
                        d = line(d, x6, y7);
                        d = line(d, x5, y1);
                        d = line(d, x3, y7);
                        d = line(d, x0, y7);
                        d = line(d, x2, y5);
                        d = line(d, x0, y2);
                        d = line(d, x3, y2);
                        d = close(d);
                        break;
                    }
                case ShapeType.xInSquare:
                    {
                        //---- X in square ----
                        //---- X-part ----
                        d = move(d, x0, y0);
                        d = line(d, x1, y1);
                        d = move(d, x1, y0);
                        d = line(d, x0, y1);
                        //---- square-part ----
                        d = move(d, x0, y0);
                        d = line(d, x0, y1);
                        d = line(d, x1, y1);
                        d = line(d, x1, y0);
                        d = close(d);
                        break;
                    }
                case ShapeType.asterisk:
                    {
                        //---- asterisk ----
                        //---- make diagonals a bit smaller ----
                        var diagFactor = .14;
                        var x2 = x0 + diagFactor * w;
                        var x8 = x1 - diagFactor * w;
                        var y2 = y0 + diagFactor * h;
                        var y8 = y1 - diagFactor * h;
                        d = move(d, x5, y0);
                        d = line(d, x5, y1);
                        d = move(d, x8, y2);
                        d = line(d, x2, y8);
                        d = move(d, x1, y5);
                        d = line(d, x0, y5);
                        d = move(d, x8, y8);
                        d = line(d, x2, y2);
                        break;
                    }
                case ShapeType.plusInDiamond:
                    {
                        //---- diamond with a plus inside ----
                        //---- diamond-part ----
                        d = move(d, x5, y0);
                        d = line(d, x0, y5);
                        d = line(d, x5, y1);
                        d = line(d, x1, y5);
                        d = line(d, x5, y0);
                        d = close(d);
                        //---- plus-part ----
                        d = move(d, x0, y5);
                        d = line(d, x1, y5);
                        d = move(d, x5, y1);
                        d = line(d, x5, y0);
                        break;
                    }
                case ShapeType.plusInCircle:
                    {
                        //---- plus in a circle ----
                        //---- circle-part ----
                        d = circle(d, x5, y5, w / 2);
                        //---- plus-part ----
                        d = move(d, x0, y5);
                        d = line(d, x1, y5);
                        d = move(d, x5, y1);
                        d = line(d, x5, y0);
                        break;
                    }
                case ShapeType.triangleUpDown:
                    {
                        //---- 2 triangles ----
                        //---- triangle-part ----
                        d = move(d, x0, y1);
                        d = line(d, x5, y0);
                        d = line(d, x1, y1);
                        d = close(d);
                        //---- down-triangle-part ----
                        d = move(d, x0, y0);
                        d = line(d, x5, y1);
                        d = line(d, x1, y0);
                        d = close(d);
                        break;
                    }
                case ShapeType.square:
                    {
                        //---- square with plus ----
                        //---- square-part ----
                        d = move(d, x0, y0);
                        d = line(d, x0, y1);
                        d = line(d, x1, y1);
                        d = line(d, x1, y0);
                        d = close(d);
                        break;
                    }
                case ShapeType.plusInSquare:
                    {
                        //---- square with plus ----
                        //---- square-part ----
                        d = move(d, x0, y0);
                        d = line(d, x0, y1);
                        d = line(d, x1, y1);
                        d = line(d, x1, y0);
                        d = close(d);
                        //---- plus-part ----
                        d = move(d, x0, y5);
                        d = line(d, x1, y5);
                        d = move(d, x5, y1);
                        d = line(d, x5, y0);
                        break;
                    }
                case ShapeType.circle:
                    {
                        //---- circle-part ----
                        d = circle(d, x5, y5, w / 2);
                        break;
                    }
                case ShapeType.xInCircle:
                    {
                        //---- X in a circle ----
                        //---- circle-part ----
                        d = circle(d, x5, y5, w / 2);
                        //---- X-part ----
                        d = move(d, x0, y0);
                        d = line(d, x1, y1);
                        d = move(d, x1, y0);
                        d = line(d, x0, y1);
                        break;
                    }
                case ShapeType.triangleInSquare:
                    {
                        //---- triangle in a square ----
                        //---- triangle-part ----
                        //---- triangle-part ----
                        d = move(d, x0, y1);
                        d = line(d, x5, y0);
                        d = line(d, x1, y1);
                        d = close(d);
                        //---- square-part ----
                        d = move(d, x0, y0);
                        d = line(d, x0, y1);
                        d = line(d, x1, y1);
                        d = line(d, x1, y0);
                        d = close(d);
                        break;
                    }
            }
            return d;
        }
        paths.getPathDataForShape = getPathDataForShape;
        (function (ShapeType) {
            //---- simple shapes that can be filled ----
            ShapeType[ShapeType["circle"] = 0] = "circle";
            ShapeType[ShapeType["diamond"] = 1] = "diamond";
            ShapeType[ShapeType["hexagram"] = 2] = "hexagram";
            ShapeType[ShapeType["pentagram"] = 3] = "pentagram";
            ShapeType[ShapeType["square"] = 4] = "square";
            ShapeType[ShapeType["triangleUp"] = 5] = "triangleUp";
            ShapeType[ShapeType["triangleDown"] = 6] = "triangleDown";
            ShapeType[ShapeType["triangleLeft"] = 7] = "triangleLeft";
            ShapeType[ShapeType["triangleRight"] = 8] = "triangleRight";
            ShapeType[ShapeType["asterisk"] = 9] = "asterisk";
            ShapeType[ShapeType["x"] = 10] = "x";
            ShapeType[ShapeType["plus"] = 11] = "plus";
            ShapeType[ShapeType["plusInDiamond"] = 12] = "plusInDiamond";
            ShapeType[ShapeType["plusInCircle"] = 13] = "plusInCircle";
            ShapeType[ShapeType["plusInSquare"] = 14] = "plusInSquare";
            ShapeType[ShapeType["triangleUpDown"] = 15] = "triangleUpDown";
            ShapeType[ShapeType["triangleInSquare"] = 16] = "triangleInSquare";
            ShapeType[ShapeType["xInCircle"] = 17] = "xInCircle";
            ShapeType[ShapeType["xInSquare"] = 18] = "xInSquare";
        })(paths.ShapeType || (paths.ShapeType = {}));
        var ShapeType = paths.ShapeType;
        paths.ShapeTypeNames = [
            //---- simple shapes that can be filled ----
            "circle",
            "diamond",
            "hexagram",
            "pentagram",
            "square",
            "triangleUp",
            "triangleDown",
            "triangleLeft",
            "triangleRight",
            //---- line and complex shapes that usually are not filled ----
            "asterisk",
            "x",
            "plus",
            "plusInDiamond",
            "plusInCircle",
            "plusInSquare",
            "triangleUpDown",
            "triangleInSquare",
            "xInCircle",
            "xInSquare",
        ];
    })(paths = vp.paths || (vp.paths = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// plotBox.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - a conceptual 3D box that holds the 2D/3D axes for a chart and provides pan/zoom/rotate functions.
///-----------------------------------------------------------------------------------------------------------------
///-----------------------------------------------------------------------------------------------------------------
/// plotBox.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - a conceptual 3D box that holds the 2D/3D axes for a chart and provides pan/zoom/rotate functions.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var plotBox;
    (function (plotBox) {
        var plotBoxClass = (function () {
            function plotBoxClass() {
                //---- private state ----
                this._transform3d = null;
                this._canvas = null;
                this._ctx = null;
                this._width = 0;
                this._height = 0;
                var canvas = document.createElement("canvas");
                this._canvas = canvas;
                var ctx = canvas.getContext("2d");
                this._ctx = ctx;
                var transform3d = plotBox.createTransform3d();
                this._transform3d = transform3d;
            }
            plotBoxClass.prototype.width = function (value) {
                if (arguments.length == 0) {
                    return this._width;
                }
                this._width = value;
                this._canvas.setAttribute("width", value + "");
                return this;
            };
            plotBoxClass.prototype.height = function (value) {
                if (arguments.length == 0) {
                    return this._height;
                }
                this._height = value;
                this._canvas.setAttribute("height", value + "");
                return this;
            };
            plotBoxClass.prototype.draw = function (xOptions, yOptions, zOptions) {
                var rect = vp.geom.createRect(0, 0, 100, 100);
                return rect;
            };
            return plotBoxClass;
        }());
        plotBox.plotBoxClass = plotBoxClass;
        function createPlotBox() {
            return new plotBoxClass();
        }
        plotBox.createPlotBox = createPlotBox;
    })(plotBox = vp.plotBox || (vp.plotBox = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// transform3d.js.  Copyright (c) 2016 Microsoft Corporation.
///     Part of the vuePlotCore library - class for translating 3D point3s to 2D (3D scaling using azimuth and elevation).
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var plotBox;
    (function (plotBox) {
        /** This class uses azimuth and elevation to project point3s from 3D space to 2D space. */
        var transform3dClass = (function () {
            /** builds a 3D matrix that can be used to translate point3s from 3D to 2D.  The projection
            is specified by an azimuth and an elevation (both in degrees of rotation).  The
            standard MATLAB setting for a 3D view is azimuth=-37.5, elevation=30.  For a direct overhead (2D)
            view, use azimuth=0, elevation=90. */
            function transform3dClass(screenWidth, screenHeight, azimuth, elevation, xMin, xMax, yMin, yMax, zMin, zMax, isScreenOutput) {
                //---- private adjustments ----
                this._xFact = 2; // 1.2;  
                this._yFact = 2; // 1.6
                this._xShift = 1; // 1.05
                this._yShift = 1; // .75
                //---- getter/setter fields ----
                this._azimuth = 0;
                this._elevation = 0;
                this._screenWidth = 0;
                this._screenHeight = 0;
                //---- public properties ----
                this._xOffset = 0;
                this._yOffset = 0;
                this._xScale = 0;
                this._yScale = 0;
                this._xMin = 0;
                this._xMax = 0;
                this._yMin = 0;
                this._yMax = 0;
                this._zMin = 0;
                this._zMax = 0;
                //---- internal state fields ----
                this._mat = null;
                this._mainMat = null;
                this._matScreen = null;
                this._origWidth = 0;
                this._xRange = 0;
                this._yRange = 0;
                this._zRange = 0;
                this._isScreenOutput = true;
                this._azimuth = azimuth;
                this._elevation = elevation;
                this._xMin = xMin;
                this._xMax = xMax;
                this._yMin = yMin;
                this._yMax = yMax;
                this._zMin = zMin;
                this._zMax = zMax;
                this._screenWidth = screenWidth;
                this._screenHeight = screenHeight;
                this._origWidth = screenWidth;
                this._isScreenOutput = isScreenOutput;
                //---- constants that effect how 3D image is contained in screen frame ----
                this.resetCamera();
            }
            transform3dClass.prototype.getZoom = function () {
                var zoom = this._xScale / this._xFact;
                return zoom;
            };
            transform3dClass.prototype.getX = function () {
                return this._xOffset;
            };
            transform3dClass.prototype.getY = function () {
                return this._yOffset;
            };
            transform3dClass.prototype.getElevation = function () {
                return this._elevation;
            };
            transform3dClass.prototype.getRotation = function () {
                return this._azimuth;
            };
            transform3dClass.prototype.setZoom = function (value) {
                var zoom = value * this._xFact;
                this._xScale = zoom;
                this._yScale = zoom;
            };
            transform3dClass.prototype.setX = function (value) {
                this._xOffset = value;
            };
            transform3dClass.prototype.setY = function (value) {
                this._yOffset = value;
            };
            transform3dClass.prototype.setElevation = function (value) {
                this._elevation = value;
            };
            transform3dClass.prototype.setRotation = function (value) {
                this._azimuth = value;
            };
            transform3dClass.prototype.resetCamera = function () {
                this._xOffset = 0;
                this._yOffset = 0;
                this._xScale = this._xFact;
                this._yScale = this._yFact;
                this.rebuild();
            };
            transform3dClass.prototype.getMatrix = function () {
                return this._mat;
            };
            transform3dClass.prototype.getScreenMatrix = function () {
                return this._matScreen;
            };
            transform3dClass.prototype.rebuild = function () {
                var elevation = this._elevation;
                var azimuth = this._azimuth;
                //elevation = vp.lamp(elevation, -90, 90);
                //azimuth = vp.lamp(azimuth, -180, 180);
                //---- convert to radians ----
                elevation = elevation * Math.PI / 180;
                azimuth = azimuth * Math.PI / 180;
                this._xRange = this.safeRange(this._xMax, this._xMin);
                this._yRange = this.safeRange(this._yMax, this._yMin);
                this._zRange = this.safeRange(this._zMax, this._zMin);
                //---- pre-compute 4 values ----
                var se = Math.sin(elevation);
                var ce = Math.cos(elevation);
                var sa = Math.sin(azimuth);
                var ca = Math.cos(azimuth);
                //---- NORMALIZE point3s in 3D space (to [-.5..+5]) ----
                //var x = (x - this._xMin) / this._xRange - .5;
                //var y = (y - this._yMin) / this._yRange - .5;
                //var z = (z - this._zMin) / this._zRange - .5;
                var preMat1 = vp.geom.matrix4.createTranslation(-this._xMin, -this._yMin, -this._zMin);
                var preMat2 = vp.geom.matrix4.createScale(1 / this._xRange, 1 / this._yRange, 1 / this._zRange);
                var preMat3 = vp.geom.matrix4.createTranslation(-.5, -.5, -.5);
                //---- MAP from 3D to 2D (to [-1..+1]) ----
                var mainMat = vp.geom.matrix4.fromFloats(ca, -se * sa, ce * sa, 0, sa, se * ca, -ce * ca, 0, 0, ce, se, 0, 0, 0, 0, 1);
                //---- MAP from ([-1..+1] to screen pixels ----
                //v.x = (this._xShift + this._xScale * v.x) * (this._screenWidth / 2) + this._xOffset;
                //v.y = (this._yShift - this._yScale * v.y) * (this._screenHeight / 2) + this._yOffset;
                var postMat1 = vp.geom.matrix4.createScale(this._xScale, -this._yScale, 1);
                var postMat2 = vp.geom.matrix4.createTranslation(this._xShift, this._yShift, 0);
                var postMat3 = vp.geom.matrix4.createScale(this._screenWidth / 2, this._screenHeight / 2, 1);
                var postMat4 = vp.geom.matrix4.createTranslation(this._xOffset, this._yOffset, 0);
                //---- now, multiple all matricies into a single transform matrix ----
                var mat = preMat1;
                mat = vp.geom.matrix4.multiply(mat, preMat2);
                mat = vp.geom.matrix4.multiply(mat, preMat3);
                mat = vp.geom.matrix4.multiply(mat, mainMat);
                mat = vp.geom.matrix4.multiply(mat, postMat1);
                mat = vp.geom.matrix4.multiply(mat, postMat2);
                mat = vp.geom.matrix4.multiply(mat, postMat3);
                mat = vp.geom.matrix4.multiply(mat, postMat4);
                this._matScreen = mat;
                if (!this._isScreenOutput) {
                    //---- transform from screen pixels back to -1, +1 range (for input to WebGL) ----
                    var postMat5 = vp.geom.matrix4.createScale(2 * 1 / this._screenWidth, 2 * 1 / this._screenHeight, 1);
                    var postMat6 = vp.geom.matrix4.createTranslation(-1, -1, 0);
                    mat = vp.geom.matrix4.multiply(mat, postMat5);
                    mat = vp.geom.matrix4.multiply(mat, postMat6);
                }
                this._mat = mat;
                this._mainMat = mainMat;
                return this;
            };
            transform3dClass.prototype.transformPointEx = function (x, y, z) {
                //---- NORMALIZE point3s in 3D space (to [-.5..+5]) ----
                var nx = (x - this._xMin) / this._xRange - .5;
                var ny = (y - this._yMin) / this._yRange - .5;
                var nz = (z - this._zMin) / this._zRange - .5;
                var v = vp.geom.matrix4.transformPoint(this._mainMat, new vp.geom.vector3(nx, ny, nz));
                //---- MAP from ([-1..+1] to screen pixels ----
                var xx = (this._xShift + this._xScale * v.x) * (this._screenWidth / 2) + this._xOffset;
                var yy = (this._yShift - this._yScale * v.y) * (this._screenHeight / 2) + this._yOffset;
                if (!this._isScreenOutput) {
                    //---- map back to -1, +1 ----
                    xx = (2 * xx / this._screenWidth) - 1;
                    yy = (2 * yy / this._screenHeight) - 1;
                }
                var vv = new vp.geom.vector3(xx, yy, v.z);
                return vv;
            };
            transform3dClass.prototype.adjustZoom = function (scaleFactor, x, y) {
                //---- concept: we want to set the xScale and yScale numbers to a new value, and then adjust the ----
                //---- xOffset and yOffset values such that ptOver is over the same point3 in data space.   ----
                //---- FOR REFERENCE: formula for mapping from ([-1..+1] to screen pixels ----
                //v.x = (this._xShift + this._xScale * v.x) * (this._screenWidth / 2) + this._xOffset;
                //v.y = (this._yShift - this._yScale * v.y) * (this._screenHeight / 2) + this._yOffset;
                if (!this._isScreenOutput) {
                    //---- from WebGL output to our system, the Y must be flipped ----
                    y = this._screenHeight - y;
                }
                //---- MAP ptOver from SCREEN to NORMALIZED 2D space ----
                var xNorm = (x - this._xOffset) / (this._screenWidth / 2);
                //var xNorm = (x - this._xOffset) / (this._screenWidth / 2);
                xNorm = (xNorm - this._xShift) / this._xScale;
                var yNorm = (y - this._yOffset) / (this._screenHeight / 2);
                //var yNorm = (y - this._yOffset) / (this._screenHeight / 2);
                //var yNorm = y / ((this._screenHeight / 2) - this._yOffset);
                yNorm = (yNorm - this._yShift) / (-this._yScale);
                //---- now, apply the new scaling factors ----
                if (scaleFactor < 0) {
                    //---- treat as absolute sclae ----
                    var zoom = -scaleFactor * this._xFact;
                    this._xScale = zoom;
                    this._yScale = zoom;
                }
                else {
                    this._xScale *= scaleFactor;
                    this._yScale *= scaleFactor;
                }
                //---- now, MAP (xNorm, yNorm) back to SCREEN space ----
                var xScreen = (this._xShift + this._xScale * xNorm) * (this._screenWidth / 2) + this._xOffset;
                var yScreen = (this._yShift - this._yScale * yNorm) * (this._screenHeight / 2) + this._yOffset;
                //---- now, compute difference between ptOver and (xScreen, yScreen) and add to xOffset, yOffset ----
                var xDiff = xScreen - x;
                var yDiff = yScreen - y;
                this._xOffset -= xDiff;
                this._yOffset -= yDiff;
                //---- test ----
                //this.rebuild();
            };
            transform3dClass.prototype.safeRange = function (max, min) {
                var range = max - min;
                if (range == 0) {
                    range = 1;
                }
                return range;
            };
            transform3dClass.prototype.testTheMatrix = function () {
                //---- test out mat ----
                var pt = this.transformPoint(0, 0, 0);
                vp.utils.assert(vp.utils.floatEq(pt.x, this._screenWidth / 2));
                vp.utils.assert(vp.utils.floatEq(pt.y, this._screenHeight / 2));
            };
            transform3dClass.prototype.xMin = function (value) {
                if (arguments.length == 0) {
                    return this._xMin;
                }
                this._xMin = value;
                //this.rebuild();
                return this;
            };
            transform3dClass.prototype.xMax = function (value) {
                if (arguments.length == 0) {
                    return this._xMax;
                }
                this._xMax = value;
                //this.rebuild();
                return this;
            };
            transform3dClass.prototype.yMin = function (value) {
                if (arguments.length == 0) {
                    return this._yMin;
                }
                this._yMin = value;
                //this.rebuild();
                return this;
            };
            transform3dClass.prototype.yMax = function (value) {
                if (arguments.length == 0) {
                    return this._yMax;
                }
                this._yMax = value;
                //this.rebuild();
                return this;
            };
            transform3dClass.prototype.screenWidth = function (value) {
                if (arguments.length == 0) {
                    return this._screenWidth;
                }
                this._screenWidth = value;
                this._origWidth = value;
                //this.rebuild();
                return this;
            };
            transform3dClass.prototype.screenHeight = function (value) {
                if (arguments.length == 0) {
                    return this._screenHeight;
                }
                this._screenHeight = value;
                //this.rebuild();
                return this;
            };
            //azimuth(): number;
            //azimuth(value: number): transform3dClass;
            //azimuth(value?: number): any
            //{
            //    if (arguments.length == 0)
            //    {
            //        return this._azimuth;
            //    }
            //    this._azimuth = value;
            //    //this.rebuild();
            //    return this;
            //}
            //elevation(): number;
            //elevation(value: number): transform3dClass;
            //elevation(value?: number): any
            //{
            //    if (arguments.length == 0)
            //    {
            //        return this._elevation;
            //    }
            //    this._elevation = value;
            //    //this.rebuild(); 
            //    return this;  
            //}  
            /** transform a point3 from 3D to 2D */
            transform3dClass.prototype.transformPoint = function (x, y, z) {
                var v = vp.geom.matrix4.transformPoint(this._mat, new vp.geom.vector3(x, y, z));
                return v;
            };
            return transform3dClass;
        }());
        plotBox.transform3dClass = transform3dClass;
        function createTransform3d(screenWidth, screenHeight, azimuth, elevation, xMin, xMax, yMin, yMax, zMin, zMax, isScreenOutput) {
            return new transform3dClass(screenWidth, screenHeight, azimuth, elevation, xMin, xMax, yMin, yMax, zMin, zMax, isScreenOutput);
        }
        plotBox.createTransform3d = createTransform3d;
    })(plotBox = vp.plotBox || (vp.plotBox = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// baseScale.ts.  Copyright (c) 2016 Microsoft Corporation.
///     Part of the vuePlot library - base class for scales.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var scales;
    (function (scales) {
        var baseScaleClass = (function () {
            function baseScaleClass() {
                this.ctr = "vp.scales.baseScaleClass";
                this.scaleName = "baseScale";
                this._expandSpace = 0; // for adding space after range min and before range max
                /// try defaulting this to true, for BeachParty compatability and general sanity.
                /// when true, we clip values to start/end of range palette.  
                /// maybe this should be an enum.  hmm.  for now, we will treat "false" as "range wrapping" 
                this._isRangeClipping = true;
                this._domainMin = 0;
                this._domainMax = 1;
                this._isPaletteDiscrete = undefined;
                this._mappingCallback = undefined; // used to allow caller to override normal mapping from percent to colors
                this._scaleType = ScaleType.linear;
                //---- other fields ----
                this._categoryKeys = {}; // used for categoryMap mapping
                this._nextKeyIndex = 0;
                this._domainDelta = 1;
                this._userSetCategoryKeys = false;
                /** this gets replaced by one of the 3 scale routines internally. */
                this.scale = function (value, seriesIndex) {
                    return 0;
                };
                this.onMapTypeChanged();
            }
            baseScaleClass.prototype.isCategory = function () {
                var isCat = (this._scaleType == ScaleType.categoryIndex || this._scaleType == ScaleType.categoryKey);
                return isCat;
            };
            baseScaleClass.prototype.expandSpace = function (value) {
                if (arguments.length === 0) {
                    return this._expandSpace;
                }
                this._expandSpace = value;
                this.onRangeChanged();
                return this;
            };
            baseScaleClass.prototype.mappingCallback = function (value) {
                if (arguments.length === 0) {
                    return this._mappingCallback;
                }
                this._mappingCallback = value;
                return this;
            };
            baseScaleClass.prototype.isPaletteDiscrete = function (value) {
                if (arguments.length === 0) {
                    return this._isPaletteDiscrete;
                }
                this._isPaletteDiscrete = value;
                return this;
            };
            baseScaleClass.prototype.isRangeClipping = function (value) {
                if (arguments.length == 0) {
                    return this._isRangeClipping;
                }
                this._isRangeClipping = value;
                return this;
            };
            baseScaleClass.prototype.scaleType = function (value) {
                if (arguments.length == 0) {
                    return this._scaleType;
                }
                if (value != this._scaleType) {
                    this._scaleType = value;
                    this.onMapTypeChanged();
                }
                return this;
            };
            baseScaleClass.prototype.palette = function (value) {
                if (arguments.length == 0) {
                    return this._palette;
                }
                this._palette = (arguments.length == 1) ? value : vp.utils.argumentsAsArray(arguments);
                this.onPaletteChanged();
                return this;
            };
            baseScaleClass.prototype.rangeMin = function (value) {
                if (!this._palette) {
                    //---- JIT, convert to 2 dimensional array ----
                    this._palette = [0, 100];
                }
                if (arguments.length == 0) {
                    return this._palette[0];
                }
                this._palette[0] = value;
                this.onRangeChanged();
                return this;
            };
            baseScaleClass.prototype.rangeMax = function (value) {
                if (!this._palette) {
                    //---- JIT, convert to 2 dimensional array ----
                    this._palette = [0, 100];
                }
                if (arguments.length == 0) {
                    return this._palette[1];
                }
                this._palette[1] = value;
                this.onRangeChanged();
                return this;
            };
            baseScaleClass.prototype.range = function (min, max) {
                this.rangeMin(min);
                this.rangeMax(max);
                return this;
            };
            baseScaleClass.prototype.onRangeChanged = function () {
            };
            baseScaleClass.prototype.onPaletteChanged = function () {
            };
            baseScaleClass.prototype.stops = function (value) {
                if (arguments.length == 0) {
                    return this._stops;
                }
                this._stops = (arguments.length == 1) ? value : vp.utils.argumentsAsArray(arguments);
                return this;
            };
            baseScaleClass.prototype.domainMin = function (value) {
                if (arguments.length == 0) {
                    return this._domainMin;
                }
                this._domainMin = value;
                this.onDomainChanged();
                return this;
            };
            baseScaleClass.prototype.domainMax = function (value) {
                if (arguments.length == 0) {
                    return this._domainMax;
                }
                this._domainMax = value;
                this.onDomainChanged();
                return this;
            };
            baseScaleClass.prototype.onDomainChanged = function () {
                this._domainDelta = this._domainMax - this._domainMin;
                if (this._domainDelta == 0) {
                    this._domainDelta = 1;
                }
            };
            baseScaleClass.prototype.resetKeys = function () {
                if (!this._userSetCategoryKeys) {
                    this._categoryKeys = {}; // reset the keys seen
                    this._nextKeyIndex = 0;
                }
            };
            baseScaleClass.prototype.categoryKeys = function (value) {
                if (arguments.length == 0) {
                    return this._categoryKeys;
                }
                this.setCategoryKeys(value);
                return this;
            };
            baseScaleClass.prototype.setCategoryKeys = function (keys) {
                this._categoryKeys = {};
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    this._categoryKeys[key] = i;
                }
                this._nextKeyIndex = keys.length;
                ;
                this._userSetCategoryKeys = true;
            };
            baseScaleClass.prototype.onMapTypeChanged = function () {
                var scaleType = this._scaleType;
                if (scaleType == ScaleType.categoryIndex) {
                    this.scale = this.categoryIndexScale;
                }
                else if (scaleType == ScaleType.categoryKey) {
                    this.scale = this.categoryKeyScale;
                }
                else if (scaleType == ScaleType.linear) {
                    this.scale = this.lerpScale;
                }
                this.resetKeys();
            };
            /** call this using the index of the key value, as stored in the categoryKeys property. */
            baseScaleClass.prototype.categoryIndexScale = function (keyIndex) {
                var result = undefined;
                var palette = this._palette;
                if (palette && palette.length > 0) {
                    if (this._isRangeClipping) {
                        var paletteIndex = this.clip(keyIndex, 0, palette.length - 1);
                    }
                    else {
                        var paletteIndex = keyIndex % palette.length;
                    }
                    //---- we require category scales to have an entry for each key (no interpolation) ----
                    //---- this is true for X, Y, Z category scales as well ----
                    //---- use "keyIndex" to get a value from palette ----
                    paletteIndex = Math.floor(paletteIndex);
                    result = palette[paletteIndex];
                }
                return result;
            };
            /** use this to get the index of the key before calling categoryScale(). */
            baseScaleClass.prototype.getIndexOfKey = function (value) {
                var index = this._categoryKeys[value];
                if (index === undefined) {
                    index = this._nextKeyIndex++;
                    this._categoryKeys[value] = index;
                }
                return index;
            };
            baseScaleClass.prototype.categoryKeyScale = function (value) {
                var index = this.getIndexOfKey(value);
                //---- pass all original arguments (subclass may have extra params) ----
                arguments[0] = index; // update "value" param
                var result = this.categoryIndexScale.apply(this, arguments);
                return result;
            };
            baseScaleClass.prototype.clip = function (value, min, max) {
                //---- it turns out we DON'T WANT clipping for our plots ----
                //---- so we disable this by default ----
                if (value < min) {
                    value = min;
                }
                else if (value > max) {
                    value = max;
                }
                return value;
            };
            baseScaleClass.prototype.calcPercent = function (value) {
                var divisor = (this._domainDelta === 0) ? 1 : this._domainDelta;
                var t = (value - this._domainMin) / divisor;
                if (this._isRangeClipping) {
                    t = this.clip(t, 0, 1);
                }
                //if (this._isWrappingEnabled)
                //{
                //    if (t > 1) 
                //    {
                //        t = t - Math.floor(t);      // get fractional part of value
                //    }
                //}
                return t;
            };
            baseScaleClass.prototype.lerpPalette = function (t, palette) {
                var result = null;
                var pcount = palette.length; // we know pcount >= 2
                var lastIndex = pcount - 1; // we know lastIndex >= 1
                //---- allow for t outside of bounds [0..1], but don't apply clipping ----
                if (t < 0) {
                    //---- always use first 2 palettes for this out of bounds case ----
                    result = this.interpolateValues(palette[0], palette[1], t);
                }
                else if (t > 1) {
                    //---- always use last 2 palettes for this out of bounds case ----
                    result = this.interpolateValues(palette[pcount - 2], palette[pcount - 1], t);
                }
                else if (t == 0) {
                    //---- take care of easy cases first ----
                    result = palette[0];
                }
                else if (t == 1) {
                    //---- take care of easy cases first ----
                    result = palette[lastIndex];
                }
                else {
                    var stops = this._stops;
                    if ((stops) && (stops.length != pcount)) {
                        stops = null;
                    }
                    var index = -1;
                    if (!stops) {
                        //---- common case, & faster path ----
                        var dindex = lastIndex * t;
                        var index = Math.min(lastIndex - 1, Math.floor(dindex));
                        //---- re-normalize t ----
                        t = dindex - index;
                    }
                    else {
                        //---- walk stops[] to find pair of values "t" is between ----
                        var index = -1;
                        for (var i = 0; i < pcount; i++) {
                            if (stops[i] >= t) {
                                index = i;
                                break;
                            }
                        }
                        if (index == -1) {
                            //---- never found - use last entry ----
                            result = palette[lastIndex];
                        }
                        else if (index == 0) {
                            //---- use first entry ----
                            result = palette[0];
                        }
                        else {
                            index--; // start with our previous entry
                            var interval = stops[index + 1] - stops[index];
                            //---- re-normalize "t" ----
                            t = (interval == 0) ? 0 : ((t - stops[index]) / interval);
                        }
                    }
                    ////---- now we can apply the ease ----
                    //if (easeFunc != null)
                    //{
                    //    t = easeFunc(t);
                    //}
                    if (t == 0) {
                        result = palette[index];
                    }
                    else if (t == 1) {
                        result = palette[index + 1];
                    }
                    else {
                        result = this.interpolateValues(palette[index], palette[index + 1], t);
                    }
                }
                return result;
            };
            baseScaleClass.prototype.lerpScale = function (value, rangePalette) {
                var result = undefined;
                var palette = (rangePalette) ? rangePalette : this._palette;
                if ((this._expandSpace) && (palette && palette.length == 2)) {
                    var p0 = palette[0];
                    var p1 = palette[1];
                    if (p0 > p1) {
                        //---- flipped scale ----
                        p0 = p0 - this._expandSpace;
                        p1 = p1 + this._expandSpace;
                    }
                    else {
                        p0 = p0 + this._expandSpace;
                        p1 = p1 - this._expandSpace;
                    }
                    //---- create new copy of palette (don't touch the class property ----
                    palette = [p0, p1];
                }
                value = +value;
                if (this._mappingCallback) {
                    var t = this.calcPercent(value);
                    result = this._mappingCallback(value, t);
                }
                else {
                    if ((palette && palette.length > 0) && (!isNaN(value))) {
                        if (palette.length == 1) {
                            //---- take care of odd case first ----
                            result = palette[0];
                        }
                        else {
                            ///
                            /// Note: "t" wiil be [0..1] and will be used to find pair of entries in palette[]) 
                            /// 
                            var t = this.calcPercent(value);
                            if (this._isPaletteDiscrete) {
                                var rawIndex = t * palette.length;
                                var index = Math.floor(rawIndex);
                                //---- correct edge case where t=1 ----
                                //---- correct edge case where a range of numeric values is treated as:   value > min, value <= max ----
                                if (index > 0 && index == rawIndex) {
                                    index--;
                                }
                                result = palette[index];
                            }
                            else {
                                result = this.lerpPalette(t, palette);
                            }
                        }
                    }
                }
                return result;
            };
            baseScaleClass.prototype.lerp = function (num, num2, t) {
                var result = num + t * (num2 - num);
                return result;
            };
            baseScaleClass.prototype.interpolateValues = function (min, max, t) {
                var result = this.lerp(min, max, t);
                return result;
            };
            return baseScaleClass;
        }());
        scales.baseScaleClass = baseScaleClass;
        var baseScale = (function (_super) {
            __extends(baseScale, _super);
            function baseScale() {
                _super.apply(this, arguments);
            }
            return baseScale;
        }(baseScaleClass));
        scales.baseScale = baseScale;
        //---- NEW VuePlot Wide Policy - make the first letter of enum name CAPITAL, to avoid accidental ambiguous reference to property of same name ----
        //---- that is usually not caught by TypeScript. ----
        /** type of mapping used in scales to extract values from a range palette. */
        (function (ScaleType) {
            /** use normalized input value to interplate between palette entries. */
            ScaleType[ScaleType["linear"] = 0] = "linear";
            /** take log of input values before doing linear scale to range. */
            ScaleType[ScaleType["log"] = 1] = "log";
            /** take log of normalized input values before doing linear scale to range. */
            ScaleType[ScaleType["lowBias"] = 2] = "lowBias";
            /** take exp of normalized input values before doing linear scale to range. */
            ScaleType[ScaleType["highBias"] = 3] = "highBias";
            /** use itemIndex as index into palette.  Caution: do NOT use with a filter, where your itemIndexes
             * are not consecutive.  */
            ScaleType[ScaleType["categoryIndex"] = 4] = "categoryIndex";
            /** use a map to track unique values and use key index as index into palette. */
            ScaleType[ScaleType["categoryKey"] = 5] = "categoryKey";
            /** simliar to linear, but with support for nice date breaks and formatting on axis/legend. */
            ScaleType[ScaleType["dateTime"] = 6] = "dateTime";
        })(scales.ScaleType || (scales.ScaleType = {}));
        var ScaleType = scales.ScaleType;
        //export interface IScale
        //{
        //    scale(value: any): any;
        //    getActualBreaks(): any[];
        //    getActualLabels(): string[];
        //    autoRange(): boolean;
        //    rangeMin(value: number): IScale;
        //    rangeMax(value: number): IScale;
        //}
        /** extract a numeric value from a discrete palette.  Does NOT do blending between entries. */
        function numberFromDiscretePalette(palette, index, firstPaletteIndex) {
            //---- when a filter is active and we draw all shapes with a subset scale, ----
            //---- it is common for the index to be invalid.  so, we fix it up here ----
            if (firstPaletteIndex === void 0) { firstPaletteIndex = 0; }
            //---- new policy is that an "other" palette at the end catches all "too big" entries ----
            index = Math.floor(vp.data.clamp(index, firstPaletteIndex, palette.length - 1));
            var value = palette[index];
            return value;
        }
        scales.numberFromDiscretePalette = numberFromDiscretePalette;
        /** extract a numeric value from a continuous palette by blending the 2 closest enties as per the non-integer index. */
        function numberFromContinuousPalette(palette, index) {
            //---- when a filter is active and we draw all shapes with a subset scale, ----
            //---- it is common for the index to be invalid.  so, we fix it up here ----
            index = (Math.abs(index) % palette.length); // recycle entires to fulfill request
            var value = 0;
            if ((index < palette.length - 1) && (index != Math.floor(index))) {
                //---- interpolate between two entries ----
                var fract = index - Math.floor(index);
                var floorIndex = Math.floor(index);
                value = vp.data.lerp(fract, palette[floorIndex], palette[floorIndex + 1]);
            }
            else {
                value = palette[Math.floor(index)];
            }
            return value;
        }
        scales.numberFromContinuousPalette = numberFromContinuousPalette;
    })(scales = vp.scales || (vp.scales = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// categoryScale.ts.  Copyright (c) 2016 Microsoft Corporation.
///     Part of the vuePlotCore library - category scale.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var scales;
    (function (scales) {
        var categoryScaleClass = (function (_super) {
            __extends(categoryScaleClass, _super);
            /** if scaleByIndex is true, the scale() function will be passed the index of the key at scale() usage
            time.  if false, it will pass the key value itself (which is RECOMMENDED when a filter can be used). */
            function categoryScaleClass(scaleByIndex) {
                _super.call(this);
                this._rangeBounds = null;
                this._stepSize = 1; // size of a category within the range
                //vp.utils.trace("ctr", "categoryScale");
                this.ctr = "vp.scales.categoryScaleClass";
                this.scaleName = "category";
                if (scaleByIndex) {
                    this.scaleType(scales.ScaleType.categoryIndex);
                }
                else {
                    this.scaleType(scales.ScaleType.categoryKey);
                }
            }
            categoryScaleClass.prototype.stepSize = function () {
                return this._stepSize;
            };
            categoryScaleClass.prototype.domain = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                if (arguments.length == 0) {
                    return this._categoryKeys;
                }
                if (args.length == 1) {
                    this.setCategoryKeys(args[0]);
                }
                else {
                    this.setCategoryKeys(args);
                }
                if (this._rangeBounds) {
                    this.computeRangeFromBounds();
                }
                return this;
            };
            categoryScaleClass.prototype.rangeValues = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                if (arguments.length == 0) {
                    return this._palette;
                }
                if (args.length == 1) {
                    //---- values passed as single array ----
                    this.palette(args[0]);
                }
                else {
                    //---- values passed as function arguments ----
                    this.palette(args);
                }
                this._rangeBounds = null;
                return this;
            };
            /** create a palette of values from the range bounds. */
            categoryScaleClass.prototype.range = function (min, max, computeRangeSteps) {
                if (computeRangeSteps === void 0) { computeRangeSteps = true; }
                if (computeRangeSteps) {
                    this._rangeBounds = [min, max];
                    this.computeRangeFromBounds();
                }
                else {
                    this._palette = [min, max];
                }
                return this;
            };
            categoryScaleClass.prototype.onRangeChanged = function () {
                _super.prototype.onRangeChanged.call(this);
                if (this._rangeBounds) {
                    this.computeRangeFromBounds();
                }
            };
            categoryScaleClass.prototype.computeRangeFromBounds = function () {
                var keys = vp.utils.keys(this._categoryKeys);
                var steps = keys.length;
                var min = this._rangeBounds[0];
                var max = this._rangeBounds[1];
                if (min < max) {
                    min += this._expandSpace;
                    max -= this._expandSpace;
                }
                else {
                    max += this._expandSpace;
                    min -= this._expandSpace;
                }
                var delta = max - min; // might be negative
                this._stepSize = (steps >= 1) ? (delta / steps) : 1;
                var halfStep = this._stepSize / 2;
                //---- generate points in middle of each step ----
                var stopper = max - halfStep; // only generate "steps" steps
                this._palette = vp.data.range(min, stopper, this._stepSize).map(function (value, index) {
                    return value + halfStep;
                });
                //vp.utils.debug("*** rangeFromBounds: max=" + max + ", stepSize=" + this._stepSize +
                //    ", this._palette=" + this._palette);
            };
            categoryScaleClass.prototype.map = function (value) {
                return this.scale(value);
            };
            return categoryScaleClass;
        }(scales.baseScale));
        scales.categoryScaleClass = categoryScaleClass;
        function createCategoryIndex() {
            return new categoryScaleClass(true);
        }
        scales.createCategoryIndex = createCategoryIndex;
        function createCategoryKey() {
            return new categoryScaleClass(false);
        }
        scales.createCategoryKey = createCategoryKey;
    })(scales = vp.scales || (vp.scales = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// dateScale.ts.  Copyright (c) 2016 Microsoft Corporation.
///     Part of the vuePlot library - date/time scale.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var scales;
    (function (scales) {
        var dateScaleClass = (function (_super) {
            __extends(dateScaleClass, _super);
            function dateScaleClass() {
                _super.call(this);
                //vp.utils.trace("ctr", "dateScale");
                this.ctr = "vp.scales.dateScaleClass";
                this.scaleName = "date";
                this._scaleType = scales.ScaleType.dateTime;
            }
            dateScaleClass.prototype.domain = function (min, max) {
                if (arguments.length == 0) {
                    return [this._domainMin, this._domainMax];
                }
                //---- the "+" here will convert JavaScript data objects to their numeric equivalent ----
                this.domainMin(+min);
                this.domainMax(+max);
                return this;
            };
            dateScaleClass.prototype.range = function (min, max) {
                if (arguments.length == 0) {
                    if (arguments.length == 0) {
                        return this._palette;
                    }
                }
                this.palette([min, max]);
                return this;
            };
            dateScaleClass.prototype.map = function (value) {
                return this.scale(value);
            };
            return dateScaleClass;
        }(scales.baseScale));
        scales.dateScaleClass = dateScaleClass;
        function createDate() {
            return new dateScaleClass();
        }
        scales.createDate = createDate;
    })(scales = vp.scales || (vp.scales = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// linearScale.ts.  Copyright (c) 2016 Microsoft Corporation.
///     Part of the vuePlot library - linear scale.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var scales;
    (function (scales) {
        var linearScaleClass = (function (_super) {
            __extends(linearScaleClass, _super);
            function linearScaleClass() {
                _super.call(this);
                //vp.utils.trace("ctr", "linearScale");
                this.ctr = "vp.scales.linearScaleClass";
                this.scaleName = "linear";
                this._scaleType = scales.ScaleType.linear;
            }
            linearScaleClass.prototype.domain = function (min, max) {
                if (arguments.length == 0) {
                    return [this._domainMin, this._domainMax];
                }
                this.domainMin(min);
                this.domainMax(max);
                return this;
            };
            linearScaleClass.prototype.range = function (min, max) {
                if (arguments.length == 0) {
                    if (arguments.length == 0) {
                        return this._palette;
                    }
                }
                this.palette([min, max]);
                return this;
            };
            linearScaleClass.prototype.map = function (value) {
                return this.scale(value);
            };
            return linearScaleClass;
        }(scales.baseScale));
        scales.linearScaleClass = linearScaleClass;
        function createLinear() {
            return new linearScaleClass();
        }
        scales.createLinear = createLinear;
    })(scales = vp.scales || (vp.scales = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// logScale.ts.  Copyright (c) 2016 Microsoft Corporation.
///     Part of the vuePlotCore library - log scale.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var scales;
    (function (scales) {
        var logScaleClass = (function (_super) {
            __extends(logScaleClass, _super);
            function logScaleClass() {
                _super.call(this);
                //vp.utils.trace("ctr", "logScale");
                this.ctr = "vp.scales.logScaleClass";
                this.scaleName = "log";
                this._scaleType = scales.ScaleType.log;
            }
            logScaleClass.prototype.domain = function (min, max) {
                if (arguments.length == 0) {
                    return [this._domainMin, this._domainMax];
                }
                this.domainMin(min);
                this.domainMax(max);
                return this;
            };
            logScaleClass.prototype.range = function (min, max) {
                if (arguments.length == 0) {
                    if (arguments.length == 0) {
                        return this._palette;
                    }
                }
                this.palette([min, max]);
                return this;
            };
            logScaleClass.prototype.map = function (value) {
                return this.scale(value);
            };
            logScaleClass.prototype.calcPercent = function (value) {
                //---- TODO: precompute these when domain changes ----
                var logMin = Math.log(this._domainMin);
                var logMax = Math.log(this._domainMax);
                var logDelta = (logMax == logMin) ? 1 : (logMax - logMin);
                var logValue = Math.log(value);
                var t = (logValue - logMin) / logDelta;
                if (this._isRangeClipping) {
                    t = this.clip(t, 0, 1);
                }
                return t;
            };
            return logScaleClass;
        }(scales.baseScale));
        scales.logScaleClass = logScaleClass;
        function createLog() {
            return new logScaleClass();
        }
        scales.createLog = createLog;
    })(scales = vp.scales || (vp.scales = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// niceNumbers.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///    - used to caculate nice numbers for an axis, for histograms, etc.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var scales;
    (function (scales) {
        /** settings for an attribute (value, scaling, and legend data). */
        var niceNumbers = (function () {
            function niceNumbers() {
            }
            niceNumbers.niceUp = function (value) {
                var nice = 0;
                if (value < 0) {
                    nice = -niceNumbers.niceDown(-value);
                }
                else if (value > 0) {
                    var precision = 2; // round the 2 most significant digit
                    var exponent = Math.floor(Math.log10(value) - (precision + 1));
                    var sciNotation = value / Math.pow(10, exponent);
                    var nice = Math.ceil(sciNotation) * Math.pow(10, exponent);
                }
                return nice;
            };
            niceNumbers.niceUpAlt = function (value) {
                var nice = 0;
                if (value < 0) {
                    nice = -niceNumbers.niceDown(-value);
                }
                else if (value > 0) {
                    var exponent = Math.floor(Math.log10(value));
                    var mantissa = value / Math.pow(10, exponent);
                    if (mantissa <= 2) {
                        mantissa = 2;
                    }
                    else if (mantissa <= 5) {
                        mantissa = 5;
                    }
                    else if (mantissa < 10) {
                        mantissa = 10;
                    }
                    var nice = Math.ceil(mantissa) * Math.pow(10, exponent);
                }
                return nice;
            };
            /** Finds a nice number that is <= value. */
            niceNumbers.niceDown = function (value) {
                var nice = 0;
                if (value < 0) {
                    nice = -niceNumbers.niceUp(-value);
                }
                else if (value > 0) {
                    var precision = 2; // round the 2 most significant digit
                    var exponent = Math.floor(Math.log10(value) - (precision + 1));
                    var sciNotation = value / Math.pow(10, exponent);
                    var nice = Math.floor(sciNotation) * Math.pow(10, exponent);
                }
                return nice;
            };
            niceNumbers.calcMinMaxGivenTickCount = function (min, max, tickCount) {
                //hostServices.debug("START calcMinMaxGivenTickCount: min=" + min + ", max=" + max + ", tickCount=" + tickCount);
                var numDivs = tickCount - 1;
                var range = max - min;
                if ((numDivs > 0) && (range > 0)) {
                    //---- special case ----
                    if (min > 0 && min < .1 && max > .9 && max < 1) {
                        min = 0;
                        newMax = 1;
                        increment = 1 / numDivs;
                    }
                    else {
                        var increment = range / numDivs;
                        increment = niceNumbers.niceUp(increment);
                        //---- set min ----
                        if (min != 0) {
                            min = increment * (Math.floor(min / increment));
                        }
                        //---- set max ----
                        var newMax = min + numDivs * increment;
                        if (newMax < max) {
                            //---- need to again with adjusted min ----
                            range = max - min;
                            increment = range / numDivs;
                            increment = niceNumbers.niceUp(increment);
                            min = increment * (Math.floor(min / increment));
                            newMax = min + numDivs * increment;
                        }
                    }
                }
                else {
                    var newMax = max;
                    var increment = range;
                }
                var result = { min: min, max: newMax, increment: increment, tickCount: tickCount };
                //hostServices.debug("calcMinMaxGivenTickCount: newMin=" + result.min + ", newMax=" + result.max + ", increment=" +
                //    result.increment + ", tickCount=" + result.tickCount);
                return result;
            };
            niceNumbers.calculate = function (dataMin, dataMax, extendDomainToZero, useOnlyIntBreaks, callerMin, callerMax, callerTickCount, addmaxHeadroom) {
                //---- designed for "measure" data (see seperate algorithm for date values) ----
                var min = dataMin;
                var max = dataMax;
                var adjustMin = true;
                var adjustMax = true;
                if (callerMin != undefined) {
                    min = callerMin;
                    adjustMin = false;
                }
                if (callerMax != undefined) {
                    max = callerMax;
                    adjustMax = false;
                }
                if (addmaxHeadroom === undefined) {
                    addmaxHeadroom = true;
                }
                var incr = 0;
                if ((adjustMin) || (adjustMax)) {
                    var minMax = this.calcMinMax(min, max, adjustMin, adjustMax, extendDomainToZero, addmaxHeadroom, useOnlyIntBreaks);
                    min = minMax.min;
                    max = minMax.max;
                    incr = minMax.incr;
                }
                else {
                    var result2 = this.calcIncr(min, max, useOnlyIntBreaks);
                    incr = result2.incr;
                }
                //---- calc TICKS ----
                var ticks = 0;
                if (callerTickCount === undefined) {
                    var incrCount = (max - min) / incr;
                    ticks = 1 + Math.floor(incrCount + .00001);
                }
                else {
                    ticks = callerTickCount;
                }
                //---- assign final values ----
                var result = { min: min, max: max, tickCount: ticks };
                return result;
            };
            niceNumbers.calcIncr = function (min, max, useOnlyIntBreaks) {
                var incr = 1;
                var range = max - min;
                if (range > 0) {
                    var exp = Math.floor(Math.log10(range));
                    var r = range / Math.pow(10, exp);
                    if (r > 9.523) {
                        range *= 1.05;
                        max = min + range;
                        exp = Math.floor(Math.log10(range));
                        r = range / Math.pow(10, exp);
                    }
                    if (r < 2) {
                        incr = .2;
                    }
                    else if (r < 5) {
                        incr = .5;
                    }
                    incr = incr * Math.pow(10, exp);
                    if (useOnlyIntBreaks) {
                        incr = Math.max(1, Math.round(incr));
                    }
                }
                return { incr: incr, max: max };
            };
            niceNumbers.calcMinMax = function (dataMin, dataMax, adjustMin, adjustMax, extendDomainToZero, addmaxHeadroom, useOnlyIntBreaks) {
                var min = dataMin;
                var max = dataMax;
                if (extendDomainToZero) {
                    if ((min > 0) && (adjustMin)) {
                        min = 0;
                    }
                    if ((max < 0) && (adjustMax)) {
                        max = 0;
                    }
                }
                if ((min == max) && (adjustMax)) {
                    incr = (useOnlyIntBreaks) ? 1 : .1 * dataMin;
                    max = dataMin + incr;
                }
                else {
                    var range = max - min;
                    if (range > 0) {
                        if (useOnlyIntBreaks) {
                            min = Math.floor(min);
                            max = Math.ceil(max);
                        }
                        var result = niceNumbers.calcIncr(min, max, useOnlyIntBreaks);
                        var incr = result.incr;
                        max = result.max;
                        //---- set domainMin to max INCR increment that is < minValue (or <= if 0) ----
                        //---- set domainMax to min INCR increment that is > maxValue ----
                        if (min >= 0) {
                            min = incr * Math.floor(min / incr);
                        }
                        else {
                            min = incr * Math.floor(min * 1.001 / incr);
                        }
                        if (addmaxHeadroom) {
                            if ((max / incr) == Math.round(max / incr)) {
                                //---- if max is a multiple of "incr", add one increment ----
                                max = max + incr;
                            }
                            else {
                                //---- round UP to the next increment ----
                                //max = incr * Math.ceil(max / incr);
                                //---- try always adding one incr ----
                                max = incr * Math.round((max + incr) / incr);
                            }
                        }
                        else {
                            //---- try always adding part of one incr ----
                            max = incr * Math.floor((max + .9 * incr) / incr);
                        }
                    }
                }
                return { min: min, max: max, incr: incr };
            };
            return niceNumbers;
        }());
        scales.niceNumbers = niceNumbers;
    })(scales = vp.scales || (vp.scales = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// msgMgr.ts.  Copyright (c) 2016 Microsoft Corporation.
///                part of the vuePlotCore library - misc utility functions.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var utils;
    (function (utils) {
        /** a class that manages window messages for its associated window. */
        var msgMgrClass = (function () {
            function msgMgrClass(windowName) {
                var _this = this;
                this._windowName = windowName;
                //---- hook "message" event (msgs from hosting window) ----
                window.addEventListener('message', function (e) { _this.onMessageFromParent(e); });
            }
            msgMgrClass.prototype.postMessageToParent = function (msgObj) {
                if (!this._parentWindow) {
                    this._parentWindow = window.parent;
                }
                if (this._parentWindow) {
                    //---- don't overwrite the FROM field, if already set ----
                    if (!msgObj.from) {
                        msgObj.from = this._windowName;
                    }
                    var msg = JSON.stringify(msgObj);
                    var domain = this.getDomain();
                    this._parentWindow.postMessage(msg, domain);
                }
            };
            msgMgrClass.prototype.getDomain = function () {
                var domain = location.hostname;
                if (!domain) {
                    domain = "localhost";
                }
                domain = "http://" + domain;
                return domain;
            };
            msgMgrClass.prototype.onMessageFromParent = function (e) {
                //console.log("OnMessageFromParent!!!");
                if (e && e.data) {
                    var msgObj = JSON.parse(e.data);
                    if (msgObj.from != this._windowName) {
                        vp.utils.debug("got window message from " + msgObj.from + ": " + e.data);
                        this.processMessageFromParent(e, msgObj);
                    }
                }
            };
            //---- view class should override this ----
            msgMgrClass.prototype.processMessageFromParent = function (e, msgObj) {
            };
            return msgMgrClass;
        }());
        utils.msgMgrClass = msgMgrClass;
    })(utils = vp.utils || (vp.utils = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// traceMgr.ts.  Copyright (c) 2016 Microsoft Corporation.
///                part of the vuePlotCore library - misc utility functions.
///-----------------------------------------------------------------------------------------------------------------
//module vp.utils
//{
//    export var traceCmds: traceCmd[] = [];
//    export class traceMgrClass extends msgMgrClass
//    {
//        _traceWindow: Window = null;
//        constructor()
//        {
//            super("traceMgr");
//            //---- startup code for traceMgr ----
//            vp.events.attach(window.document, "keydown", (e) =>
//            {
//                if (e.keyCode == vp.events.keyCodes.f12 && e.ctrlKey)
//                {
//                    //---- open a "trace explorer" window on  Ctrl-F12 ----
//                    this._traceWindow = window.open("../TraceExplorer/TraceExplorer.html");
//                    //alert("set traceWindow=" + this._traceWindow.name);
//                    setTimeout((e) =>
//                    {
//                        //---- send trace explorer it's INIT msg ----
//                        this.postMessageToFrame({ msgType: "init" });
//                    }, 200);
//                    vp.events.cancelEventDefault(e);
//                }
//            });
//        }
//        processMessageFromParent(e, msgObj)
//        {
//            if (msgObj.msgType == "getTraceCmds")
//            {
//                alert("got 'getTraceCmds' request from window=" + this._traceWindow.name);
//                var traceStr = JSON.stringify(traceCmds);
//                var msgObj2 = { msgType: "traceCmds", value: traceStr };
//                alert("sending msg to traceExplorer, from window=" + window.name + ", to window=" + this._traceWindow.name );
//                this.postMessageToFrame(msgObj2);
//            }
//        }
//        postMessageToFrame(msgObj)
//        {
//            //var iframe = <HTMLIFrameElement>document.getElementById(id);
//            //var contentWindow = iframe.contentWindow;
//            var contentWindow = this._traceWindow;
//            //alert("postMessageToFrame; traceWindow=" + this._traceWindow.name);
//            if (contentWindow)
//            {
//                var msg = JSON.stringify(msgObj);
//                var domain = this.getDomain();
//                contentWindow.postMessage(msg, domain);
//            }
//        }
//    }
//    export function trace(traceType: string, id: string, status?: any)
//    {
//        var cmd = new traceCmd(traceType, id, status);
//        //debug("trace: " + cmd);
//        cmd.traceNum = traceCmds.length;
//        traceCmds.push(cmd);
//    }
//    export function traceAniFrame(childCount: number, frameNumber: number, percent: number)
//    {
//        var cmd = new aniFrameCmd(childCount, frameNumber, percent);
//        //debug("trace: " + cmd);
//        cmd.traceNum = traceCmds.length;
//        traceCmds.push(cmd);
//    }
//    // private
//    export class traceCmd
//    {
//        traceNum: number;
//        timeStamp: number;
//        traceType: string;
//        id: string;
//        status: any;
//        constructor(traceType: string, id: string, status?: any)
//        {
//            this.traceType = traceType;
//            this.id = id;
//            this.status = status;
//            this.timeStamp = vp.utils.now();
//        }
//        toString()
//        {
//            var str = this.traceType + ": " + this.id;
//            if (status)
//            {
//                str += "{" + status + "}";
//            }
//            return str;
//        }
//    }
//    export class aniFrameCmd extends traceCmd
//    {
//        childCount: number;
//        frameNumber: number;
//        percent: number;
//        constructor(childCount: number, frameNumber: number, percent: number)
//        {
//            super("aniFrame", "");
//            this.childCount = childCount;
//            this.frameNumber = frameNumber;
//            this.percent = percent;
//        }
//    }
//    //var traceMgr = new traceMgrClass();
//}
////---- create function in "window" global namespace ----
//function sendDirectMessage(msg)
//{
//    if (msg == "getTraceCmds")
//    {
//        var str = JSON.stringify(vp.utils.traceCmds);
//        return str;
//    }
//}
///-----------------------------------------------------------------------------------------------------------------
/// utils.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - general utility functions
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var utils;
    (function (utils) {
        var debugId = null;
        function now() {
            //---- for now, don't use this ----
            //if (false)      // (window.performance)
            //{
            //    //---- use HIGH PRECISION timer when available ----
            //    var value = window.performance.now();
            //}
            //else
            {
                //---- use this 15ms increment thing if we have to ----
                var value = +Date.now();
            }
            return value;
        }
        utils.now = now;
        utils.appStartTime = now();
        function mapEquals(map1, map2) {
            var keys1 = vp.utils.keys(map1);
            var keys2 = vp.utils.keys(map2);
            var eq = vp.arrayEquals(keys1, keys2);
            if (eq) {
                for (var i = 0; i < keys1.length; i++) {
                    var key = keys1[i];
                    var value1 = map1[key];
                    var value2 = map2[key];
                    eq = equals(value1, value2);
                    if (!eq) {
                        break;
                    }
                }
            }
            return eq;
        }
        utils.mapEquals = mapEquals;
        function equals(any1, any2) {
            if (vp.utils.isArray(any1)) {
                var eq = vp.arrayEquals(any1, any2);
            }
            else if (any1 instanceof Float32Array) {
                var eq = vp.arrayEquals(any1, any2);
            }
            else if (any1 instanceof Object) {
                var eq = vp.utils.mapEquals(any1, any2);
            }
            else {
                var eq = (any1 === any2);
            }
            return eq;
        }
        utils.equals = equals;
        function parseJsonIntoObj(json, obj) {
            var j = JSON.parse(json);
            copyMapIntoObj(j, obj);
            return obj;
        }
        utils.parseJsonIntoObj = parseJsonIntoObj;
        function addUnits(value, defaultUnits) {
            if (!vp.utils.isString(value)) {
                value = value + defaultUnits;
            }
            else {
                //---- see if value has any non-digits ----
                var foundUnits = false;
                for (var i = 0; i < value.length; i++) {
                    if ((value[i] < '0') || (value[i] > '9')) {
                        foundUnits = true;
                        break;
                    }
                }
                if (!foundUnits) {
                    value += defaultUnits;
                }
            }
            return value;
        }
        utils.addUnits = addUnits;
        function indexKeyFunc(dataRecord, index) {
            return index;
        }
        utils.indexKeyFunc = indexKeyFunc;
        function setDebugId(name) {
            debugId = name;
        }
        utils.setDebugId = setDebugId;
        /// send "msg" to the browser debug console, if present. 
        function debug(msg) {
            if (window.console && window.console.log) {
                var now = vp.utils.now() - vp.utils.appStartTime;
                var secs = now / 1000;
                var time = "@" + secs.toFixed(3);
                if (debugId) {
                    time += " [" + debugId + "]";
                }
                console.log(time + ": " + msg);
            }
        }
        utils.debug = debug;
        /// test condition - use alert if false
        function assert(cond, msg) {
            if (!cond) {
                if (!msg) {
                    msg = "vp.assert: conditon failed";
                }
                alert(msg);
            }
        }
        utils.assert = assert;
        /// return true if object has one or more dictionary keys.
        function hasKeys(obj) {
            /// fastest cross-browser test
            var count = 0;
            for (var k in obj) {
                count++;
                break;
            }
            return (count > 0);
        }
        utils.hasKeys = hasKeys;
        utils.computedStyles = {};
        function getComputedStyleFromClass(shapeName, parentClassName, className) {
            var key = shapeName + "^" + className;
            var cs = utils.computedStyles[key];
            if (!cs) {
                //---- create a temp SVG document ----
                var svg = vp.select(document.body).append("svg")
                    .addClass(parentClassName);
                var elem = svg.append(shapeName)
                    .addClass(className);
                //---- let browser system compute all casdaded styles as of this moment ----
                var css = window.getComputedStyle(elem[0]);
                //---- copy a subset of the properties we need because when we ----
                //---- remove our temp. elements, the css will be updated and useless to us ----
                cs = {
                    fill: css.fill, stroke: css.stroke, strokeWidth: css.strokeWidth, opacity: css.opacity,
                    fontFamily: css.fontFamily, fontSize: css.fontSize, fontWeight: css.fontWeight, fontStyle: css.fontStyle,
                    strokeDasharray: css.strokeDasharray, strokeDashoffset: css.strokeDashoffset, textAnchor: css.textAnchor,
                };
                utils.computedStyles[key] = cs;
                //---- clean up temp stuff ----
                elem.remove();
                svg.remove();
            }
            return cs;
        }
        utils.getComputedStyleFromClass = getComputedStyleFromClass;
        function getShapeId(element) {
            var id = "";
            var elem = element;
            if (elem.dataItem) {
                id = elem.dataItem.dataId + "," + elem.dataItem.key + ", " + elem.dataItem.shapeId;
            }
            return id;
        }
        utils.getShapeId = getShapeId;
        function toArray(pseudoArray) {
            var elems = [];
            for (var i = 0; i < pseudoArray.length; i++) {
                var elem = pseudoArray[i];
                elems.push(elem);
            }
            return elems;
        }
        utils.toArray = toArray;
        /** find HTML, SVG, or canvas elements that overlap with specificed rcBounds. */
        function getElementsInBounds(container, rcBounds, rcAdjusted) {
            var elems = [];
            var svgDoc = this.getCanvasOrSvgParent(container);
            if (svgDoc && svgDoc.getIntersectionList) {
                //---- very strange: getIntersectionList requires you to create the SVGRect this way ----
                var rc = svgDoc.createSVGRect();
                rc.x = rcBounds.left;
                rc.y = rcBounds.top;
                rc.width = rcBounds.width;
                rc.height = rcBounds.height;
                //---- returns a nodeList, which is not an array ----
                var nodeList = svgDoc.getIntersectionList(rc, null);
                elems = vp.utils.toArray(nodeList);
            }
            else {
                rcBounds = rcAdjusted;
                var kids = vp.dom.children(container);
                var svgIntersectCount = 0;
                for (var k = 0; k < kids.length; k++) {
                    var kid = kids[k];
                    if (kid.tagName != "defs") {
                        var rcLight = vp.dom.getBounds(kid, true);
                        //---- start with simple BOUNDING BOX test ----
                        var intersects = vp.geom.rectIntersectsRect(rcBounds, rcLight);
                        if (intersects) {
                            elems.push(kid);
                            if (vp.utils.isSvgElement(kid)) {
                                svgIntersectCount++;
                            }
                        }
                    }
                }
                //---- now, render to canvas and do test there ----
                //---- we can do more precise testing on SVG shapes, but limit shapes to prevent long waits ----
                if ((svgIntersectCount > 0) && (svgIntersectCount <= 100)) {
                    //---- do a more precise test using inkHitTest --
                    elems = getElementsInkHitTest(rcBounds, elems);
                }
            }
            //---- filter out non-SHAPES ----
            elems = elems.where(function (elem, index) {
                var id = getShapeId(elem);
                return (id != null && id != "");
            });
            //---- remove duplicates (so that 2 shapes for same id don't cancel each other out) ----
            elems = elems.distinct(function (elem, index) {
                return getShapeId(elem);
            });
            return elems;
        }
        utils.getElementsInBounds = getElementsInBounds;
        function getElementsInkHitTest(rcBand, elems) {
            var newElems = [];
            var inkHitTest = null;
            try {
                //---- currently, we select any partial overlap with rcBand and shapes ----
                for (var k = 0; k < elems.length; k++) {
                    var elem = elems[k];
                    var intersects = true; // until proven otherwise
                    if (vp.utils.isSvgElement(elem)) {
                        var tag = elem.tagName;
                        if ((tag != "rect") && (tag != "image") && (tag != "text")) {
                            //---- complex shape passes bounding box test ----
                            //---- we need to draw shape on a temp canvas to see if it overlaps rect ----
                            if (!inkHitTest) {
                                //--- small tweak required to rcBand for inkHit testing (why?) ----
                                var rcInk = vp.geom.rect(rcBand.left, rcBand.top + 4, rcBand.width, rcBand.height);
                                inkHitTest = new vp.internal.inkHitTest(rcInk);
                            }
                            intersects = inkHitTest.doesShapeOverlap(elem);
                        }
                    }
                    if (intersects) {
                        newElems.push(elem);
                    }
                }
            }
            finally {
                if (inkHitTest) {
                    inkHitTest.close();
                }
            }
            return newElems;
        }
        /// return the size of the text in a SPAN element whose class is the specified class.
        //export function measureText(text, spanClass)
        //{
        //    var span = document.createElement("span");
        //    document.body.appendChild(span);
        //    vp.dom.text(span, text);
        //    vp.setClass(span, spanClass);
        //    var sz = { width: vp.dom.width(span), height: vp.dom.height(span) }
        //    document.body.removeChild(span);
        //    return sz;
        //}
        ///// return the size of the text in an SVG element whose class is the specified class.
        //export function measureSvgText(svgNode, text, className)
        //{
        //    var textElem = document.createElementNS('http://www.w3.org/2000/svg', "text");
        //    svgNode.append(textElem);
        //    vp.setClass(textElem, className);
        //    var xx = vp.dom.getBounds(textElem);
        //    var rect = textElem.getBoundingClientRect();
        //    svgNode.remove(textElem);
        //    var sz = { width: rect.width, height: rect.height }
        //    return sz;
        //}
        function cb(thisObj, func) {
            var wrapper = function (thisObj, func) {
                if ((!thisObj) || (!func)) {
                    vp.utils.error("Bad vp.cb() call: both arguments must be non-null");
                }
                this.thisObj = thisObj;
                this.func = func;
                var self = this;
                this.callIt = function () {
                    return self.func.apply(self.thisObj, arguments);
                };
            };
            var wrapFunc = new wrapper(thisObj, func);
            return wrapFunc.callIt;
        }
        utils.cb = cb;
        //export function getMousePosition(e)
        //{
        //    var x: number = 0;
        //    var y: number = 0;
        //    // Handle a non-IE 'touch' event
        //    if ((<string>e.type).startsWith('touch') && (e.changedTouches != undefined) && (e.changedTouches.length > 0))
        //    {
        //        x = e.changedTouches[0].pageX;
        //        y = e.changedTouches[0].pageY;
        //    }
        //    else
        //    {
        //        x = <number> e.pageX;
        //        y = <number> e.pageY;
        //    }
        //    return { x: x, y: y };
        //}
        /** When set to a function, the function is called before an error is reported. */
        utils.onError = null;
        function error(msg, lineNum) {
            var omitThrow = false;
            if (lineNum) {
                msg += " [line: " + lineNum + "]";
            }
            if (vp.utils.onError) {
                omitThrow = vp.utils.onError(msg);
            }
            if (!omitThrow) {
                throw msg;
            }
        }
        utils.error = error;
        function jsonToStr(obj) {
            var value = "";
            if (obj instanceof Int32Array) {
                //---- support for this is marginal, at best, depending on browser. ----
                //---- we convert to a map whose keys are the index ----
                if (utils.isIE) {
                    //---- IE doesn't handle this at all; must do it manually ----
                    var map = {};
                    var ia = obj;
                    for (var i = 0; i < ia.length; i++) {
                        map[i] = ia[i];
                    }
                    value = "Int32Array" + JSON.stringify(map);
                }
                else {
                    value = "Int32Array" + JSON.stringify(obj);
                }
            }
            else {
                value = JSON.stringify(obj);
            }
            return value;
        }
        utils.jsonToStr = jsonToStr;
        function getFileExtension(name) {
            name = name.toLowerCase();
            var ext = "";
            var index = name.lastIndexOf(".");
            if (index > -1) {
                ext = name.substr(index);
            }
            return ext;
        }
        utils.getFileExtension = getFileExtension;
        function jsonFromStr(str) {
            var data = null;
            //---- note: JSON.parse() cannot handle "Int32Array{...}" ----
            if (str.startsWith("Int32Array")) {
                str = str.substr(10); // skip over Int32Array
                var objWithKeys = JSON.parse(str);
                var keys = vp.utils.keys(objWithKeys);
                //---- first pass: get exact length of new Int32Array ----
                var length = 0;
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    //---- watch out for non-numeric keys (other properties on map) ----
                    var index = +key;
                    if (!isNaN(index)) {
                        length++;
                    }
                }
                var ia = vp.utils.int32Array(length);
                //---- second pass: fill the new array ----
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    //---- watch out for non-numeric keys (other properties on map) ----
                    var index = +key;
                    if (!isNaN(index)) {
                        var value = objWithKeys[key];
                        ia[index] = +value;
                    }
                }
                data = ia;
            }
            else {
                data = JSON.parse(str);
            }
            return data;
        }
        utils.jsonFromStr = jsonFromStr;
        function float32Array(length) {
            var vector = null;
            if (typeof Float32Array === "undefined") {
                vector = new Array(length);
            }
            else {
                vector = new Float32Array(length);
            }
            return vector;
        }
        utils.float32Array = float32Array;
        function int32Array(length) {
            var vector = null;
            if (typeof Int32Array === "undefined") {
                vector = new Array(length);
            }
            else {
                vector = new Int32Array(length);
            }
            return vector;
        }
        utils.int32Array = int32Array;
        function toRadians(value) {
            return value * Math.PI / 180;
        }
        utils.toRadians = toRadians;
        function toDegrees(value) {
            return value * 180 / Math.PI;
        }
        utils.toDegrees = toDegrees;
        function toHex2(value) {
            var str = value.toString(16);
            if (str.length == 1) {
                str = "0" + str;
            }
            return str;
        }
        utils.toHex2 = toHex2;
        function makeCtxColorStr(cr3) {
            var red = vp.data.clamp(Math.round(cr3[0]), 0, 255);
            var green = vp.data.clamp(Math.round(cr3[1]), 0, 255);
            var blue = vp.data.clamp(Math.round(cr3[2]), 0, 255);
            //---- use hex format to compare correctly with ctx colors ----
            var str = "#" + this.toHex2(red) + this.toHex2(green) + this.toHex2(blue);
            return str;
        }
        utils.makeCtxColorStr = makeCtxColorStr;
        /// prevents the default event handling from happening.
        function cancelEventDefault(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.returnValue = false;
        }
        utils.cancelEventDefault = cancelEventDefault;
        /// prevents the event from bubbling to other controls.
        function cancelEventBubble(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            e.cancelBubble = false;
        }
        utils.cancelEventBubble = cancelEventBubble;
        function argumentsAsArray(args) {
            var array = [];
            for (var a = 0; a < args.length; a++) {
                array.push(args[a]);
            }
            return array;
        }
        utils.argumentsAsArray = argumentsAsArray;
        function setTimer(interval, callback) {
            return setInterval(callback, interval);
        }
        utils.setTimer = setTimer;
        function clearTimer(handle) {
            clearInterval(handle);
        }
        utils.clearTimer = clearTimer;
        function setOneShotTimer(interval, callback) {
            return setTimeout(callback, interval);
        }
        utils.setOneShotTimer = setOneShotTimer;
        function clearOneShotTimer(handle) {
            clearTimeout(handle);
        }
        utils.clearOneShotTimer = clearOneShotTimer;
        function globalEval(js, wantReturn) {
            //---- eval in global context by adding a script element to the <head> ----
            var script = document.createElement("script");
            script.type = "text/javascript";
            script.text = (wantReturn) ? "window._evalResult = " + js : js;
            var head = document.getElementsByTagName("head")[0];
            if (!head) {
                throw "Error - HTML missing head element (required for globalEval)";
            }
            head.appendChild(script);
            head.removeChild(script);
            var win = window;
            var retVal = (wantReturn) ? win._evalResult : undefined;
            return retVal;
        }
        utils.globalEval = globalEval;
        //------------------------------------------------------------------------------------------------
        /// internal - supports "thisWrapper()"
        function wrapper(func, thisObj) {
            this.func = func;
            this.thisObj = thisObj;
            var self = this;
            this.callIt = function (e) {
                self.func.call(self.thisObj, e);
            };
        }
        /// get a list of the key/value parameters for the current page url.  if values are surrounded by quotes, they may contain other urls with their own
        /// parameters, so beware.
        function getCmdParams(cmd) {
            var params = {};
            if (cmd) {
                var scanner = new vp.utils.scannerClass(cmd);
                scanner._recognizeComments = false;
                var tt = scanner.scan();
                var key = "";
                var value = "";
                var scanningValue = false;
                while (tt != utils.TokenType.eof) {
                    var token = scanner.token();
                    if (token == "=") {
                        scanningValue = true;
                    }
                    else if (token == "&") {
                        params[key] = value;
                        key = "";
                        value = "";
                        scanningValue = false;
                    }
                    else {
                        if (scanningValue) {
                            if (tt == utils.TokenType.string) {
                                //---- remove quotes ----
                                if (token.startsWith("\"") || token.startsWith("'")) {
                                    token = token.substr(1, token.length - 2);
                                }
                            }
                            value += token;
                        }
                        else {
                            key += token;
                        }
                    }
                    tt = scanner.scan();
                }
                //---- finish last key/value pair ----
                if (key) {
                    params[key] = value;
                }
            }
            return params;
        }
        utils.getCmdParams = getCmdParams;
        /// create a instance of the XMLHttpRequest object.
        function createXMLHttpRequest() {
            var req = null;
            if (XMLHttpRequest != null) {
                req = new XMLHttpRequest();
            }
            else {
                req = new ActiveXObject("Microsoft.XMLHTTP");
            }
            return req;
        }
        utils.createXMLHttpRequest = createXMLHttpRequest;
        function getUrlParams() {
            var url = window.location.href;
            var params = {};
            var index = url.indexOf("?");
            if (index == -1) {
                //---- using hash tag to save state? ----
                index = url.indexOf("#");
            }
            if (index > -1) {
                var paramStr = url.substring(index + 1);
                //---- Chrome and Firefox (and others?) encode the URL but don't unencode it when giving it to us, so we need to do that now ----
                if (!vp.utils.isIE && !vp.utils.isEdge) {
                    paramStr = decodeURIComponent(paramStr);
                }
                params = getCmdParams(paramStr);
            }
            return params;
        }
        utils.getUrlParams = getUrlParams;
        /// returns the directory portion of the current page's URL (excludes the page name)
        function getUrlDirectory() {
            var url = window.location.href;
            var index = url.lastIndexOf("/");
            if (index > -1) {
                url = url.substr(0, index);
            }
            return url;
        }
        utils.getUrlDirectory = getUrlDirectory;
        /// used for floating point comparisons.
        utils.epsilon = .00001;
        /// return true if a <= b (using floating point comparison).
        function floatLeq(a, b, eps) {
            if (eps === void 0) { eps = utils.epsilon; }
            return (b - a) >= -eps;
        }
        utils.floatLeq = floatLeq;
        function floatLess(a, b, eps) {
            if (eps === void 0) { eps = utils.epsilon; }
            return (!floatGeq(a, b, eps));
        }
        utils.floatLess = floatLess;
        /// return true if a >= b (using floating point comparison).
        function floatGeq(a, b, eps) {
            if (eps === void 0) { eps = utils.epsilon; }
            return (a - b) >= -eps;
        }
        utils.floatGeq = floatGeq;
        /// return true if a == b (using floating point comparison).
        function floatEq(a, b, eps) {
            if (eps === void 0) { eps = utils.epsilon; }
            return Math.abs(a - b) <= eps;
        }
        utils.floatEq = floatEq;
        /// return true if a == b (using string or floating point comparison).
        function unitsEq(a, b, eps) {
            if (eps === void 0) { eps = utils.epsilon; }
            var equal = false;
            if (utils.isString(a) && utils.isString(b)) {
                equal = (a == b);
            }
            else {
                equal = floatEq(+a, +b, eps);
            }
            return equal;
        }
        utils.unitsEq = unitsEq;
        /// add "keys" (list of dict properties) for browsers (like IE) that don't yet implement it.
        function keys(obj) {
            var keys = [];
            if (obj.keys) {
                keys = obj.keys;
            }
            else {
                for (var k in obj) {
                    if (obj.hasOwnProperty(k)) {
                        keys.push(k);
                    }
                }
            }
            return keys;
        }
        utils.keys = keys;
        /// return true if object has one or more dictionary keys.
        function hasKey(obj) {
            /// fastest cross-browser test
            var count = 0;
            for (var k in obj) {
                count++;
                break;
            }
            return (count > 0);
        }
        utils.hasKey = hasKey;
        //--- opera doesn't have Object.keys so we use this wrapper ----
        function numberOfKeys(theObject) {
            if (Object.keys)
                return Object.keys(theObject).length;
            var n = 0;
            for (var key in theObject)
                ++n;
            return n;
        }
        utils.numberOfKeys = numberOfKeys;
        /// return the size of the text in a SPAN element whose class is the specified class.
        function measureText(text, spanClass) {
            var span = document.createElement("span");
            document.body.appendChild(span);
            vp.dom.text(span, text);
            vp.dom.setClass(span, spanClass);
            var sz = { width: vp.dom.width(span), height: vp.dom.height(span) };
            document.body.removeChild(span);
            return sz;
        }
        utils.measureText = measureText;
        /// return the size of the text in an SVG element whose class is the specified class.
        function measureSvgText(svgNode, text, className) {
            var textElem = document.createElementNS('http://www.w3.org/2000/svg', "text");
            svgNode.append(textElem);
            vp.dom.setClass(textElem, className);
            var xx = vp.dom.getBounds(textElem);
            var rect = textElem.getBoundingClientRect();
            svgNode.remove(textElem);
            var sz = { width: rect.width, height: rect.height };
            return sz;
        }
        utils.measureSvgText = measureSvgText;
        function routePropCalls(from, to) {
            for (var i = 2; i < arguments.length; i++) {
                var methodName = arguments[i];
                if (vp.utils.isArray(methodName)) {
                    for (var m = 0; m < methodName.length; m++) {
                        var methName = methodName[m];
                        var method = to[methName];
                        from[methName] = makePropRouteCallFunc(from, to, method);
                    }
                }
                else {
                    var method = to[methodName];
                    from[methodName] = makePropRouteCallFunc(from, to, method);
                }
            }
        }
        utils.routePropCalls = routePropCalls;
        function routeFuncCalls(from, to) {
            for (var i = 2; i < arguments.length; i++) {
                var methodName = arguments[i];
                var method = to[methodName];
                from[methodName] = makeFuncRouteCallFunc(from, to, method);
            }
        }
        utils.routeFuncCalls = routeFuncCalls;
        function routePropCallsPost(from, to, postCall) {
            for (var i = 3; i < arguments.length; i++) {
                var methodName = arguments[i];
                var method = to[methodName];
                from[methodName] = makePropRouteCallFunc(from, to, method, postCall);
            }
        }
        utils.routePropCallsPost = routePropCallsPost;
        /// internal (needs to be a separate func due to closure rules.
        function makePropRouteCallFunc(from, to, method, postCall) {
            return function () {
                var result = method.apply(to, arguments);
                //---- if this is not a getter, we want to return "from" as then chaining object ----
                if (arguments.length > 0) {
                    result = from;
                }
                if (vp.utils.isDefined(postCall)) {
                    postCall.apply(from);
                }
                return result;
            };
        }
        /// internal (needs to be a separate func due to closure rules.
        function makeFuncRouteCallFunc(from, to, method, postCall) {
            return function () {
                var result = method.apply(to, arguments);
                if (vp.utils.isDefined(postCall)) {
                    postCall.apply(from);
                }
                return result;
            };
        }
        function generateFunc(args, body, maker) {
            var exp = "function foo(" + args + ")\n" + body + "";
            var func = null;
            if (maker == "eval") {
                func = eval("(" + exp + ")");
            }
            else if (maker == "script") {
                //---- inject a script element ----
                var script = document.createElement("script");
                document.body.appendChild(script);
                script.text = exp;
                func = window["foo"];
            }
            else if (maker == "Function") {
                func = Function(args, body);
            }
            return func;
        }
        utils.generateFunc = generateFunc;
        /* Makes a deep copy of the object.  TODO: replace with faster code. */
        function deepCopy(objectToCopy) {
            var copy = objectToCopy ? JSON.parse(JSON.stringify(objectToCopy)) : null;
            return (copy);
        }
        utils.deepCopy = deepCopy;
        function copyArray(aray) {
            var newArray = null;
            if (aray) {
                if (aray.slice) {
                    newArray = aray.slice(0);
                }
                else if (aray instanceof Float32Array) {
                    newArray = new Float32Array(aray);
                }
                else {
                    newArray = [];
                    //---- pseudo array ----
                    for (var i = 0; i < aray.length; i++) {
                        newArray[i] = aray[i];
                    }
                }
            }
            return newArray;
        }
        utils.copyArray = copyArray;
        function copyMap(map, copyArrays) {
            var newMap = copyMapIntoObj(map, {}, copyArrays);
            return newMap;
        }
        utils.copyMap = copyMap;
        function copyMapIntoObj(from, to, copyArrays) {
            if (from) {
                var keys = vp.utils.keys(from);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var value = from[key];
                    if (vp.utils.isArray(value) && copyArrays) {
                        value = copyArray(value);
                    }
                    to[key] = value;
                }
            }
            return to;
        }
        utils.copyMapIntoObj = copyMapIntoObj;
        function compareArrays(aray1, aray2) {
            var isEqual = true;
            if (!aray1) {
                isEqual = (!aray2);
            }
            else if (!aray2) {
                isEqual = false;
            }
            else {
                isEqual = (aray1.length == aray2.length);
                if (isEqual) {
                    //---- compare each element ----
                    for (var i = 0; i < aray1.length; i++) {
                        if (aray1[i] != aray2[i]) {
                            isEqual = false;
                            break;
                        }
                    }
                }
            }
            return isEqual;
        }
        utils.compareArrays = compareArrays;
        function getCanvasOrSvgParent(elem) {
            var parentElem = elem;
            if (parentElem.rootContainer) {
                //---- canvas element ----
                parentElem = parentElem.rootContainer.canvas;
            }
            else {
                //---- SVG ----
                while (parentElem && parentElem.tagName != "svg") {
                    //---- get parent of group ----
                    parentElem = vp.dom.parent(parentElem);
                }
            }
            return parentElem;
        }
        utils.getCanvasOrSvgParent = getCanvasOrSvgParent;
        /** adjust the x/y offset so that it has a .5/.5 fractional part. */
        function getRootCrispTranslate(container, x, y) {
            var parentElem = this.getCanvasOrSvgParent(container);
            var rc = parentElem.getBoundingClientRect();
            //---- goal is to move this ROOT GROUP to a x.5, y.5 number pixel boundary, relative to our html document ----
            var xSum = rc.left + x;
            var xFraction = xSum - Math.floor(xSum);
            var xOffset = .5 - xFraction;
            var ySum = rc.top + y;
            var yFraction = ySum - Math.floor(ySum);
            var yOffset = .5 - yFraction;
            x += xOffset;
            y += yOffset;
            return { x: x, y: y };
        }
        utils.getRootCrispTranslate = getRootCrispTranslate;
        function lineTypeToDashArray(lineType) {
            ///
            /// TODO: merge with definition of lineType in vuePlotTypes.ts 
            ///
            var lt = (vp.utils.isString(lineType)) ? lineType.toLowerCase() : lineType;
            var value = "";
            if ((lt === "blank") || (lt === 0)) {
                value = "0, 10";
            }
            else if ((lt === "solid") || (lt === 1)) {
                value = "";
            }
            else if ((lt === "dashed") || (lt === 2)) {
                value = "4, 4";
            }
            else if ((lt === "dotted") || (lt === 3)) {
                value = "1, 3";
            }
            else if ((lt === "dotdash") || (lt === 4)) {
                value = "1, 3, 4, 4";
            }
            else if ((lt === "longdash") || (lt === 5)) {
                value = "7, 3";
            }
            else if ((lt === "twodash") || (lt === 6)) {
                value = "2, 2, 6, 2";
            }
            else {
                //---- leave alone (let call specify on/off pattern in a string) ----
                value = lt;
            }
            return value;
        }
        utils.lineTypeToDashArray = lineTypeToDashArray;
        (function (LineType) {
            LineType[LineType["blank"] = 0] = "blank";
            LineType[LineType["solid"] = 1] = "solid";
            LineType[LineType["dashed"] = 2] = "dashed";
            LineType[LineType["dotted"] = 3] = "dotted";
            LineType[LineType["dotDash"] = 4] = "dotDash";
            LineType[LineType["longDash"] = 5] = "longDash";
            LineType[LineType["twoDash"] = 6] = "twoDash";
        })(utils.LineType || (utils.LineType = {}));
        var LineType = utils.LineType;
    })(utils = vp.utils || (vp.utils = {}));
})(vp || (vp = {}));
//---- this file, "_references.ts", must reside in directly in the vueplotCore\VuePlotCore project directory, so ----
//---- that it can correct control the *.ts file processing order, which then controls the order of the classes generated ----
//---- to the vuePlotCore.js file. ----
//---- helpers ----
///<reference path="helpers/array.ts" />
///<reference path="helpers/hsl.ts" />
///<reference path="helpers/math.ts" />
///<reference path="helpers/scanner.ts" />
///<reference path="helpers/string.ts" />
//---- animations ----
///<reference path="animation/animation.ts" />
///<reference path="animation/animationContainer.ts" />
///<reference path="animation/colorAnimation.ts" />
///<reference path="animation/eases.ts" />
///<reference path="animation/dataAnimMgr.ts" />
///<reference path="animation/effects.ts" />
///<reference path="animation/numberAnimation.ts" />
///<reference path="animation/pointsAnimation.ts" />
///<reference path="animation/transformAnimation.ts" />
///<reference path="animation/transition.ts" />
//---- chartFrame ----
///<reference path="chartFrame/axisBase.ts" />
///<reference path="chartFrame/axisData.ts" />
///<reference path="chartFrame/bottomAxis.ts" />
///<reference path="chartFrame/chartFrameEx.ts" />
///<reference path="chartFrame/gridLines.ts" />
///<reference path="chartFrame/leftAxis.ts" />
///<reference path="chartFrame/rightAxis.ts" />
///<reference path="chartFrame/topAxis.ts" />
//---- canvasElements ----
///<reference path="canvas/canvasElement.ts" />
///<reference path="canvas/canvasCircleElement.ts" />
///<reference path="canvas/canvasContainerElement.ts" />
///<reference path="canvas/canvasEllipseElement.ts" />
///<reference path="canvas/canvasGroupElement.ts" />
///<reference path="canvas/canvasImageElement.ts" />
///<reference path="canvas/canvasLineElement.ts" />
///<reference path="canvas/canvasPathElement.ts" />
///<reference path="canvas/canvasPolygonElement.ts" />
///<reference path="canvas/canvasRectElement.ts" />
///<reference path="canvas/canvasTextElement.ts" />
//---- data ----
///<reference path="data/aggAvg.ts" />
///<reference path="data/aggCount.ts" />
///<reference path="data/aggMax.ts" />
///<reference path="data/aggMedian.ts" />
///<reference path="data/aggMin.ts" />
///<reference path="data/aggMode.ts" />
///<reference path="data/aggStdDev.ts" />
///<reference path="data/aggSum.ts" />
///<reference path="data/aggVariance.ts" />
///<reference path="data/dataUtils.ts" />
//---- dom ----
//---- these must be first in this section ----
///<reference path="dom/selectedSet.ts" />
///<reference path="dom/singleWrapper.ts" />
///<reference path="dom/basicSelect.ts" />
///<reference path="dom/canvasSelectedSet.ts" />
///<reference path="dom/canvasUtils.ts" />
///<reference path="dom/colors.ts" />
///<reference path="dom/events.ts" />
///<reference path="dom/inkHitTest.ts" />
///<reference path="dom/insertAppend.ts" />
///<reference path="dom/isFuncs.ts" />
///<reference path="dom/dom.ts" />
///<reference path="dom/styleSheet.ts" />
//---- formatters ----
/// <reference path="formatters/formatters.ts" />
/// <reference path="formatters/excelFormatter.ts" />
//---- geom ----
/// <reference path="geom/basicTypes.ts" />
/// <reference path="geom/matrix4.ts" />
/// <reference path="geom/point2.ts" />
/// <reference path="geom/point3.ts" />
/// <reference path="geom/rect.ts" />
/// <reference path="geom/vector2.ts" />
/// <reference path="geom/vector3.ts" />
/// <reference path="geom/vector4.ts" />
//---- marks ----
/// <reference path="marks/markBase.ts" />
/// <reference path="marks/circleMark.ts" />
/// <reference path="marks/ellipseMark.ts" />
/// <reference path="marks/drawingParams.ts" />
/// <reference path="marks/groupMark.ts" />
/// <reference path="marks/glBuilder.ts" />
/// <reference path="marks/imageMark.ts" />
/// <reference path="marks/jsParser.ts" />
/// <reference path="marks/lineMark.ts" />
/// <reference path="marks/pathMark.ts" />
/// <reference path="marks/pointMark.ts" />
/// <reference path="marks/rect2dMark.ts" />
/// <reference path="marks/rectangleMark.ts" />
/// <reference path="marks/textMark.ts" />
/// <reference path="marks/triangleMark.ts" />
//---- layouts ----
/// <reference path="layouts/quadTree.ts" />
/// <reference path="layouts/dragHelper.ts" />
/// <reference path="layouts/forceLayout.ts" />
//---- paths ----
/// <reference path="paths/buildPie.ts" />
/// <reference path="paths/curveFitting.ts" />
/// <reference path="paths/paths.ts" />
/// <reference path="paths/shapeData.ts" />
//---- plotBox ----
/// <reference path="plotBox/axisOptions.ts" />
/// <reference path="plotBox/plotBox.ts" />
/// <reference path="plotBox/transform3d.ts" />
//---- scales ----
/// <reference path="scales/baseScale.ts" />
/// <reference path="scales/categoryScale.ts" />
/// <reference path="scales/dateScale.ts" />
/// <reference path="scales/linearScale.ts" />
/// <reference path="scales/logScale.ts" />
/// <reference path="scales/niceNumbers.ts" />
//---- utils ----
///<reference path="utils/msgMgr.ts" />
///<reference path="utils/traceMgr.ts" />
///<reference path="utils/utils.ts" />
///-----------------------------------------------------------------------------------------------------------------
/// aggNone.ts.  Copyright (c) 2016 Microsoft Corporation.
///   - part of the vuePlotCore library: count() aggregate class for groupBy/aggregation.
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    var data;
    (function (data) {
        var aggNone = (function () {
            function aggNone() {
            }
            aggNone.prototype.init = function () {
            };
            aggNone.prototype.process = function (value) {
            };
            aggNone.prototype.getResult = function () {
                return null;
            };
            return aggNone;
        }());
        data.aggNone = aggNone;
    })(data = vp.data || (vp.data = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// quternion.ts.  Copyright (c) 2016 Microsoft Corporation.
///            Part of the vuePlotCore library - a quaternion helps you correctly accumulate successive rotations along various axes.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var geom;
    (function (geom) {
        var quaternion = (function () {
            function quaternion(x, y, z, w) {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 1;
                if (x != undefined) {
                    this.x = x;
                }
                if (y != undefined) {
                    this.y = y;
                }
                if (z != undefined) {
                    this.z = z;
                }
                if (w != undefined) {
                    this.w = w;
                }
            }
            quaternion.fromAngleAxis = function (theta, axis) {
                //---- first, normalize the incoming axis vector ----
                var v3 = new geom.vector3(axis[0], axis[1], axis[2]);
                v3 = geom.vector3.normal(v3);
                var ax = v3.x;
                var ay = v3.y;
                var az = v3.z;
                var sin = Math.sin(theta / 2);
                var quat = new quaternion(ax * sin, ay * sin, az * sin, Math.cos(theta / 2));
                return quat;
            };
            quaternion.rotateAngleAxis = function (quat, theta, axis) {
                var quat2 = quaternion.fromAngleAxis(theta, axis);
                var result = quaternion.multiply(quat, quat2);
                return result;
            };
            quaternion.multiply = function (a, b) {
                var x = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
                var y = a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y;
                var z = a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x;
                var w = a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w;
                var quat = new quaternion(x, y, z, w);
                return quat;
            };
            quaternion.toMatrix = function (q) {
                var qx = q.x;
                var qy = q.y;
                var qz = q.z;
                var qw = q.w;
                var mat = geom.matrix4.fromFloats(1 - 2 * (qy * qy + qz * qz), 2 * (qx * qy - qw * qz), 2 * (qx * qz + qw * qy), 0, 2 * (qx * qy + qw * qz), 1 - 2 * (qx * qx + qz * qz), 2 * (qy * qz - qw * qx), 0, 2 * (qx * qz - qw * qy), 2 * (qy * qz + qw * qx), 1 - 2 * (qx * qx + qy * qy), 0, 0, 0, 0, 1);
                return mat;
            };
            return quaternion;
        }());
        geom.quaternion = quaternion;
    })(geom = vp.geom || (vp.geom = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// colorPalettes.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - a set of helper functions for creating color palettes (sets of colors).
///-----------------------------------------------------------------------------------------------------------------
/// <summary>
/// Predefined and custom color palettes.  A color palette is an array of colors that can be
/// used to with an Interpolator or a Scale to sample as discrete or continous colors.
/// 
/// note: below functions are continuous, unless marked as "discrete".
///
/// Predefined:
///     - blueRed              
///     - redGreen              
///     - surface
///     - grays(n)
///     - reds(n)
///     - greens(n)
///     - blues(n)
///     - rainbow(n)            (discrete)
///     - rainbowPairs(n)       (discrete)
///     
/// Custom:
///     - darkLight(cr, ...)        
///     - darkLightDark(cr, cr2)
///     - lightDark(cr, ...)        
///     - hueSteps(cr, n)       (discrete)
///     - analogs(cr)           (discrete)
///     - shades(cr, n)
///     - interploate(colors, steps)
///     
/// </summary>
///-----------------------------------------------------------------------------------------------------------------
"use strict";
var vp;
(function (vp) {
    var colorPalettes;
    (function (colorPalettes) {
        /// <summary>
        /// Predefined color scheme for displaying negative and positive continous values:
        ///     DarkBlue, DarkRed
        /// </summary>
        function blueRed() {
            return [vp.color.colors.darkblue, vp.color.colors.darkred];
        }
        colorPalettes.blueRed = blueRed;
        /// <summary>
        /// Predefined color scheme for displaying negative and positive continous values:
        ///     DarkRed, LightRed, LightGreen, DarkGreen
        /// </summary>
        function redGreen() {
            return [vp.color.colors.darkred, vp.color.rgbFromHsl(0, 1, .8), vp.color.colors.lightgreen, vp.color.colors.darkgreen];
        }
        colorPalettes.redGreen = redGreen;
        /// <summary>
        /// Predefined color scheme for surface colors:
        ///     DarkBlue, Aqua, Yellow, DarkRed
        /// </summary>
        /// <returns></returns>
        function surface() {
            var palette = ["rgb(0, 0, 143)", "rgb(0, 0, 255)", "rgb(0, 255, 255)", "rgb(255, 255, 0)", "rgb(255, 0, 0)", "rgb(128, 0, 0)"];
            var stops = [0, 1 / 8, 3 / 8, 5 / 8, 7 / 8, 1];
            palette.stops = stops;
            return palette;
        }
        colorPalettes.surface = surface;
        function interpolate(colors, steps) {
            var newColors = [];
            var count = colors.length;
            for (var i = 0; i < steps; i++) {
                //---- get index of this color ----
                var index = i / (count + 1);
                var lowIndex = Math.floor(index);
                if (index == lowIndex) {
                    //---- whole number ----
                    var cr = colors[lowIndex];
                    newColors.push(cr);
                    vp.utils.debug("interpolate: i=" + i + ", exact color[" + lowIndex + "]");
                }
                else {
                    //---- stradles two colors ----
                    var cr1 = colors[lowIndex];
                    var cr2 = colors[lowIndex + 1];
                    var percent = index - lowIndex;
                    var crx = vp.color.interpolateColors(cr1, cr2, percent);
                    newColors.push(crx);
                    vp.utils.debug("interpolate: i=" + i + ", lowIndex=" + lowIndex + ", nextIndex=" + (lowIndex + 1) +
                        ", percent=" + percent);
                }
            }
            return newColors;
        }
        colorPalettes.interpolate = interpolate;
        /// <summary>
        /// Predefined color scheme for shades of gray
        /// </summary>
        /// <returns></returns>
        function grays(steps, startPercent, endPercent) {
            startPercent = startPercent || 1;
            endPercent = endPercent || 0;
            return vp.colorPalettes.shades(vp.color.colors.gray, steps, startPercent, endPercent);
        }
        colorPalettes.grays = grays;
        /// <summary>
        /// Predefined color scheme for shades of red
        /// </summary>
        /// <returns></returns>
        function reds(steps) {
            return vp.colorPalettes.shades(vp.color.colors.red, steps);
        }
        colorPalettes.reds = reds;
        /// <summary>
        /// Predefined color scheme for shades of green
        /// </summary>
        /// <returns></returns>
        function greens(steps) {
            return vp.colorPalettes.shades(vp.color.colors.green, steps);
        }
        colorPalettes.greens = greens;
        /// <summary>
        /// Predefined color scheme using the specified number of hues spaced
        /// around the color wheel.
        /// </summary>
        /// <returns></returns>
        function rainbow(steps) {
            var values = [];
            var stepSize = 1 / steps;
            for (var i = 0; i < steps; i++) {
                var hue = i * stepSize;
                values[i] = vp.color.rgbFromHsl(hue, 1, .5);
            }
            return values;
        }
        colorPalettes.rainbow = rainbow;
        /// <summary>
        /// Predefined color scheme using the specified number of hues spaced
        /// around the color wheel.  Each hue generates 2 colors: light and dark versions
        /// of the hue.
        /// </summary>
        /// <returns></returns>
        function rainbowPairs(steps) {
            var values = [];
            var stepSize = 1 / steps;
            for (var i = 0; i < steps; i++) {
                var hue = i * stepSize;
                values.push(vp.color.rgbFromHsl(hue, 1, .3));
                values.push(vp.color.rgbFromHsl(hue, 1, .7));
            }
            return values;
        }
        colorPalettes.rainbowPairs = rainbowPairs;
        function htmlColors(count) {
            var keys = vp.utils.keys(vp.color.colors);
            var values = keys.slice(0, count);
            return values;
        }
        colorPalettes.htmlColors = htmlColors;
        /// <summary>
        /// Generates a custom color scheme, using a dark and light version of each
        /// specifed color.
        /// </summary>
        /// <returns></returns>
        function darkLight(color1) {
            var values = [];
            for (var i = 0; i < arguments.length; i++) {
                var hsl = vp.color.hslFromRgb(arguments[i]);
                values.push(vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), .30));
                values.push(vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), .70));
            }
            return values;
        }
        colorPalettes.darkLight = darkLight;
        /// <summary>
        /// Generates a custom color scheme, using a dark and light version of each
        /// specifed color.
        /// </summary>
        /// <returns></returns>
        function darkLightDark(cr, cr2) {
            var hsl = vp.color.hslFromRgb(cr);
            var hsl2 = vp.color.hslFromRgb(cr2);
            var colors = [
                vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), .20),
                vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), .80),
                vp.color.rgbFromHsl(hsl2.hue(), hsl2.saturation(), .80),
                vp.color.rgbFromHsl(hsl2.hue(), hsl2.saturation(), .20)
            ];
            return colors;
        }
        colorPalettes.darkLightDark = darkLightDark;
        /// <summary>
        /// Generates a custom color scheme, using a light and dark version of each
        /// specifed color.
        /// </summary>
        /// <returns></returns>
        function lightDark(color1) {
            var values = [];
            for (var i = 0; i < arguments.length; i++) {
                var hsl = vp.color.hslFromRgb(arguments[i]);
                values.push(vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), .70));
                values.push(vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), .30));
            }
            return values;
        }
        colorPalettes.lightDark = lightDark;
        /// <summary>
        /// Returns a set of colors whose hues are equally spaces in the color wheel.
        /// </summary>
        /// <param name="color"></param>
        /// <param name="count"></param>
        /// <returns></returns>
        function hueSteps(color, steps) {
            var colors = [];
            var hsl = vp.color.hslFromRgb(color);
            var hue = hsl.hue();
            var step = 1 / steps;
            for (var i = 0; i < steps; i++) {
                var hx = vp.color.normalizeHue(hue + i * step);
                colors[i] = vp.color.rgbFromHsl(hx, hsl.saturation(), hsl.lightness());
            }
            return colors;
        }
        colorPalettes.hueSteps = hueSteps;
        /// <summary>
        /// Returns the set of 4 analog colors, based on the specified color.
        /// </summary>
        /// <param name="color"></param>
        /// <param name="count"></param>
        /// <returns></returns>
        function analogs(color) {
            var colors = [];
            var hsl = vp.color.hslFromRgb(color);
            var hue = hsl.hue();
            var step = 1 / 9;
            colors[0] = color;
            var h1 = vp.color.normalizeHue(hue + step);
            var h2 = vp.color.normalizeHue(hue + .5);
            var h3 = vp.color.normalizeHue(hue + .5 + step);
            colors[1] = vp.color.rgbFromHsl(h1, hsl.saturation(), hsl.lightness());
            colors[2] = vp.color.rgbFromHsl(h2, hsl.saturation(), hsl.lightness());
            colors[3] = vp.color.rgbFromHsl(h3, hsl.saturation(), hsl.lightness());
            return colors;
        }
        colorPalettes.analogs = analogs;
        /// <summary>
        /// Returns the specified number of shades of a color.
        /// </summary>
        /// <param name="color"></param>
        /// <param name="count"></param>
        /// <returns></returns>
        function shades(color, count, startPercent, endPercent) {
            startPercent = (startPercent === undefined) ? .98 : startPercent;
            endPercent = (endPercent === undefined) ? .09 : endPercent;
            if (count < 1) {
                vp.utils.error("Count must be at least 1");
            }
            var colors = [];
            if (count == 1) {
                colors.push(color);
            }
            else {
                var hsl = vp.color.hslFromRgb(color);
                var step = (endPercent - startPercent) / (count - 1);
                var index = 0;
                if (step >= 0) {
                    for (var percent = startPercent; vp.utils.floatLeq(percent, endPercent); percent += step) {
                        colors[index++] = vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), percent);
                    }
                }
                else {
                    for (var percent = startPercent; vp.utils.floatGeq(percent, endPercent); percent += step) {
                        colors[index++] = vp.color.rgbFromHsl(hsl.hue(), hsl.saturation(), percent);
                    }
                }
            }
            return colors;
        }
        colorPalettes.shades = shades;
    })(colorPalettes = vp.colorPalettes || (vp.colorPalettes = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// highBiasScale.ts.  Copyright (c) 2016 Microsoft Corporation.
///     Part of the vuePlotCore library.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var scales;
    (function (scales) {
        /** Transforms data by applying a normalized exponential function; has the effect of "openening up" the data at the high end. */
        var highBiasScaleClass = (function (_super) {
            __extends(highBiasScaleClass, _super);
            function highBiasScaleClass() {
                _super.call(this);
                this.exp4m1 = Math.exp(4.0) - 1;
                //vp.utils.trace("ctr", "highBiasScale");
                this.ctr = "vp.scales.highBiasScaleClass";
                this.scaleName = "highBias";
                this._scaleType = scales.ScaleType.highBias;
            }
            highBiasScaleClass.prototype.domain = function (min, max) {
                if (arguments.length == 0) {
                    return [this._domainMin, this._domainMax];
                }
                this.domainMin(min);
                this.domainMax(max);
                return this;
            };
            highBiasScaleClass.prototype.range = function (min, max) {
                if (arguments.length == 0) {
                    if (arguments.length == 0) {
                        return this._palette;
                    }
                }
                this.palette([min, max]);
                return this;
            };
            highBiasScaleClass.prototype.map = function (value) {
                return this.scale(value);
            };
            highBiasScaleClass.prototype.calcPercent = function (value) {
                var t = (value - this._domainMin) / this._domainDelta;
                //---- to get predictable exp() results, we first scale all data to the same range ----
                //---- scale value to: [0,4.0] and take EXP ----
                value = Math.exp(t * 4.0); // result in range 1-exp(4.0)
                t = vp.data.clamp((value - 1) / this.exp4m1, 0, 1);
                if (this._isRangeClipping) {
                    t = this.clip(t, 0, 1);
                }
                return t;
            };
            return highBiasScaleClass;
        }(scales.baseScale));
        scales.highBiasScaleClass = highBiasScaleClass;
        function createHighBias() {
            return new highBiasScaleClass();
        }
        scales.createHighBias = createHighBias;
    })(scales = vp.scales || (vp.scales = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// lowBiasScale.ts.  Copyright (c) 2016 Microsoft Corporation.
///     Part of the vuePlotCore library.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var scales;
    (function (scales) {
        /** Transforms data by applying a normalized log; has the effect of "openening up" the data at the low end. */
        var lowBiasScaleClass = (function (_super) {
            __extends(lowBiasScaleClass, _super);
            function lowBiasScaleClass() {
                _super.call(this);
                this.log25 = Math.log(25);
                //vp.utils.trace("ctr", "lowBiasScale");
                this.ctr = "vp.scales.lowBiasScaleClass";
                this.scaleName = "lowBias";
                this._scaleType = scales.ScaleType.lowBias;
            }
            lowBiasScaleClass.prototype.domain = function (min, max) {
                if (arguments.length == 0) {
                    return [this._domainMin, this._domainMax];
                }
                this.domainMin(min);
                this.domainMax(max);
                return this;
            };
            lowBiasScaleClass.prototype.range = function (min, max) {
                if (arguments.length == 0) {
                    if (arguments.length == 0) {
                        return this._palette;
                    }
                }
                this.palette([min, max]);
                return this;
            };
            lowBiasScaleClass.prototype.map = function (value) {
                return this.scale(value);
            };
            lowBiasScaleClass.prototype.calcPercent = function (value) {
                var t = (value - this._domainMin) / this._domainDelta;
                //---- to get predictable log() results, we first scale all data to the same range ----
                //---- scale value to: [1,25] and take LOG() ----
                value = Math.log(t * 24 + 1); // result in range 0-log25
                t = vp.data.clamp(value / this.log25, 0, 1);
                if (this._isRangeClipping) {
                    t = this.clip(t, 0, 1);
                }
                return t;
            };
            return lowBiasScaleClass;
        }(scales.baseScale));
        scales.lowBiasScaleClass = lowBiasScaleClass;
        function createLowBias() {
            return new lowBiasScaleClass();
        }
        scales.createLowBias = createLowBias;
    })(scales = vp.scales || (vp.scales = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// dateHelper.ts.  Copyright (c) 2016 Microsoft Corporation.
///     Part of the vuePlotCore library - helper class for scaling and formatting date/time values.
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var dateHelper;
    (function (dateHelper) {
        var monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        var dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        function addIntervalCore(date, units, unitFactor) {
            if (units == TimeUnits.years) {
                //dt = dt.AddYears(unitFactor);
                date.setFullYear(date.getFullYear() + unitFactor);
            }
            else if (units == TimeUnits.quarters) {
                //dt = dt.AddMonths(3 * unitFactor);
                date.setMonth(date.getMonth() + 3 * unitFactor);
            }
            else if (units == TimeUnits.months) {
                //dt = dt.AddMonths(unitFactor);
                date.setMonth(date.getMonth() + unitFactor);
            }
            else if (units == TimeUnits.days) {
                //dt = dt.AddDays(unitFactor);
                date.setDate(date.getDate() + unitFactor);
            }
            else if (units == TimeUnits.hours) {
                //dt = dt.AddHours(unitFactor);
                date.setHours(date.getHours() + unitFactor);
            }
            else if (units == TimeUnits.minutes) {
                //dt = dt.AddMinutes(unitFactor);
                date.setMinutes(date.getMinutes() + unitFactor);
            }
            else if (units == TimeUnits.seconds) {
                //dt = dt.AddSeconds(unitFactor);
                date.setSeconds(date.getSeconds() + unitFactor);
            }
            else {
                //dt = dt.AddMilliseconds(unitFactor);
                date.setMilliseconds(date.getMilliseconds() + unitFactor);
            }
        }
        function findNiceFactor(value, targetIntervals, niceNums) {
            var bestNice = undefined;
            var bestTargetDist = undefined;
            //---- try each nice number ----
            for (var i = 0; i < niceNums.length; i++) {
                var nice = niceNums[i];
                var intervals = Math.ceil(value / nice);
                var dist = Math.abs(targetIntervals - intervals);
                if (i == 0 || dist < bestTargetDist) {
                    bestTargetDist = dist;
                    bestNice = nice;
                }
            }
            return bestNice;
        }
        function getDateScaleValues(minValue, maxValue, targetIntervals) {
            if (targetIntervals === void 0) { targetIntervals = 7; }
            //---- javaScript doesn't support intervals, so we need to do everything on the 2 dates ----
            var ts = maxValue - minValue;
            //var msPerDay = 86400000;
            //var msPerYear = 365 * msPerDay;
            var units = TimeUnits.years;
            var unitFactor = 1;
            var formatString = "yyyy";
            var millisecs = ts;
            var seconds = millisecs / 1000;
            var minutes = seconds / 60;
            var hours = minutes / 60;
            var days = hours / 24;
            var months = days / 30; // approx
            var years = days / 365.25; // approx
            if (years > 3) {
                units = TimeUnits.years;
                unitFactor = findNiceFactor(years, targetIntervals, [500, 250, 100, 50, 25, 10, 1]);
                formatString = "yyyy"; // e.g., "2014"
            }
            else if (years >= 1) {
                units = TimeUnits.quarters;
                unitFactor = 1;
                formatString = "Qq-yy"; // e.g, "Q2-14" (custom to VuePlot; not supported by Excel)
            }
            else if (months >= 4) {
                units = TimeUnits.months;
                unitFactor = 1;
                formatString = "mmm"; // e.g., "Apr"
            }
            else if (days >= 2) {
                units = TimeUnits.days;
                unitFactor = findNiceFactor(days, targetIntervals, [10, 7, 5, 1]);
                formatString = "m/d/yyyy"; // e.g., "10/10/2014"
            }
            else if (hours >= 4) {
                units = TimeUnits.hours;
                unitFactor = findNiceFactor(hours, targetIntervals, [12, 6, 3, 1]);
                formatString = "h AM/PM"; // e.g., "3 PM"
            }
            else if (minutes >= 4) {
                units = TimeUnits.minutes;
                unitFactor = findNiceFactor(minutes, targetIntervals, [30, 15, 10, 5, 1]);
                formatString = "h:mm AM/PM"; // e.g., "3:15 AM"
            }
            else if (seconds >= 4) {
                units = TimeUnits.seconds;
                unitFactor = findNiceFactor(seconds, targetIntervals, [30, 15, 10, 5, 1]);
                formatString = "h:mm:ss AM/PM"; // e.g., "3:15:03 PM"
            }
            else {
                units = TimeUnits.milliSeconds;
                unitFactor = findNiceFactor(millisecs, targetIntervals, [500, 250, 100, 50, 25, 10, 1]);
                formatString = "h:mm:ss.0 AM/PM"; // e.g., "3:15:03.341 AM"
            }
            var dt = new Date(minValue);
            dt = adjustDate(dt, units, unitFactor, -1);
            var dtMax = new Date(maxValue);
            dtMax = adjustDate(dtMax, units, unitFactor, 1);
            var steps = [];
            while (dt <= dtMax) {
                //---- must use .valueOf; otherwise would be same object by reference ----
                steps.push(dt.valueOf());
                addIntervalCore(dt, units, unitFactor);
            }
            return { units: units, unitFactor: unitFactor, steps: steps, formatString: formatString };
        }
        dateHelper.getDateScaleValues = getDateScaleValues;
        //---- adjusts the date up or down, so it is on an even time/date boundary ----
        function adjustDate(dt, units, unitFactor, dir) {
            if (dir > 0) {
                addIntervalCore(dt, units, unitFactor);
            }
            //---- take next lower unit*factor value ----
            if (units == TimeUnits.years) {
                var years = dt.getFullYear();
                years = unitFactor * Math.floor(years / unitFactor);
                dt = new Date(years, 0);
            }
            else if (units == TimeUnits.quarters) {
                var months = dt.getMonth();
                var qtr = months / 3;
                var newQtr = unitFactor * Math.floor(qtr / unitFactor);
                var newMonth = 3 * newQtr;
                dt = new Date(dt.getFullYear(), newMonth);
            }
            else if (units == TimeUnits.months) {
                var months = dt.getMonth();
                months = unitFactor * Math.floor(months / unitFactor);
                dt = new Date(dt.getFullYear(), months);
            }
            else if (units == TimeUnits.days) {
                var days = dt.getDate();
                days = unitFactor * Math.floor(days / unitFactor);
                dt.setDate(days);
                dt.setHours(0, 0, 0, 0); // zero out time
            }
            else if (units == TimeUnits.hours) {
                var hours = dt.getHours();
                hours = unitFactor * Math.floor(hours / unitFactor);
                dt.setHours(hours, 0, 0, 0);
            }
            else if (units == TimeUnits.minutes) {
                var minutes = dt.getMinutes();
                minutes = unitFactor * Math.floor(minutes / unitFactor);
                dt.setMinutes(minutes, 0, 0);
            }
            else if (units == TimeUnits.seconds) {
                var seconds = dt.getSeconds();
                seconds = unitFactor * Math.floor(seconds / unitFactor);
                dt.setSeconds(seconds, 0);
            }
            else if (units == TimeUnits.milliSeconds) {
                var ms = dt.getMilliseconds();
                ms = unitFactor * Math.floor(ms / unitFactor);
                dt.setMilliseconds(ms);
            }
            return dt;
        }
        (function (TimeUnits) {
            TimeUnits[TimeUnits["years"] = 0] = "years";
            TimeUnits[TimeUnits["quarters"] = 1] = "quarters";
            TimeUnits[TimeUnits["months"] = 2] = "months";
            TimeUnits[TimeUnits["days"] = 3] = "days";
            TimeUnits[TimeUnits["hours"] = 4] = "hours";
            TimeUnits[TimeUnits["minutes"] = 5] = "minutes";
            TimeUnits[TimeUnits["seconds"] = 6] = "seconds";
            TimeUnits[TimeUnits["milliSeconds"] = 7] = "milliSeconds";
        })(dateHelper.TimeUnits || (dateHelper.TimeUnits = {}));
        var TimeUnits = dateHelper.TimeUnits;
    })(dateHelper = vp.dateHelper || (vp.dateHelper = {}));
})(vp || (vp = {}));
var vp;
(function (vp) {
    var unitTests;
    (function (unitTests) {
        function test(dtMin, dtMax, desc) {
            var result = vp.dateHelper.getDateScaleValues(dtMin.valueOf(), dtMax.valueOf(), 7);
            var formatter = vp.formatters.createExcelFormatter(result.formatString, "date");
            vp.utils.debug("  getDateScaleValues: " + formatter(dtMin) + " - " + formatter(dtMax) + " (" + desc + ")");
            for (var i = 0; i < result.steps.length; i++) {
                var step = result.steps[i];
                var str = formatter(step);
                vp.utils.debug("    " + str);
            }
        }
        //---- add "export" to include this test ----
        function testDateHelper() {
            vp.utils.debug("running: testArrayFuncs");
            //---- test code for getDateScaleValues() ----
            //test(new Date("10/1/2014 10:12"), new Date("10/1/2014 10:57"), "45 mins");
            //test(new Date("10/1/2014 10:12"), new Date("10/1/2014 11:12"), "1 hour");
            //test(new Date("10/1/2014 10:12"), new Date("10/1/2014 11:27"), "1 hour, 15 mins");
            //test(new Date("10/1/2014 10:12"), new Date("10/2/2014 9:12"), "23 hours");
            //test(new Date("10/1/2014 10:12"), new Date("10/2/2014 11:12"), "25 hours");
            //test(new Date("10/1/2014 10:12"), new Date("10/5/2014 15:12"), "4+ days");
            //test(new Date("10/1/2014 10:12"), new Date("10/13/2014 15:12"), "12+ days");
            //test(new Date("10/1/2014 10:12"), new Date("10/19/2014 15:12"), "18 days");
            //test(new Date("10/1/2014 10:12"), new Date("10/28/2014 15:12"), "27 days");
            //test(new Date("2/1/2014 10:12"), new Date("9/28/2014 15:12"), "7+  months");
            test(new Date("2/1/2013 10:12"), new Date("5/3/2014 15:12"), "15+  months");
        }
    })(unitTests = vp.unitTests || (vp.unitTests = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// niceNumbersAlt.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlot library
///    - alternate method of calculating "nice number" min/max/interval for scales.
///
///    - adapted from: http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var scales;
    (function (scales) {
        /** settings for an attribute (value, scaling, and legend data). */
        var niceNumbersAlt = (function () {
            function niceNumbersAlt() {
            }
            niceNumbersAlt.niceNum = function (range, round) {
                var exponent = Math.floor(Math.log10(range));
                var mantissa = range / Math.pow(10, exponent);
                var niceMantissa = 10;
                if (round) {
                    if (mantissa < 1.5) {
                        niceMantissa = 1;
                    }
                    else if (mantissa < 3) {
                        niceMantissa = 2;
                    }
                    else if (mantissa < 7) {
                        niceMantissa = 5;
                    }
                }
                else {
                    if (mantissa <= 1) {
                        niceMantissa = 1;
                    }
                    else if (mantissa <= 2) {
                        niceMantissa = 2;
                    }
                    else if (mantissa <= 5) {
                        niceMantissa = 5;
                    }
                }
                var niceRange = niceMantissa * Math.pow(10, exponent);
                return niceRange;
            };
            niceNumbersAlt.calculate = function (min, max, steps) {
                var matchSteps = (steps !== undefined);
                if (!matchSteps) {
                    steps = 7; // must have default for calculations to work
                }
                if (steps < 1) {
                    steps = 2;
                }
                var range = max - min; // this.niceNum(max - min, false);
                var interval = this.niceNum(range / steps, true);
                var niceMin = Math.floor(min / interval) * interval;
                var niceMax = Math.ceil(max / interval) * interval;
                var bestSteps = (niceMax - niceMin) / interval;
                if (matchSteps) {
                    if (bestSteps != steps) {
                        //vp.utils.debug("** NEEDED=" + neededSteps + ", steps=" + steps);
                        //range = this.niceNum(max - min, true);
                        //interval = this.niceNum(range / steps, true);
                        //niceMin = Math.floor(min / interval) * interval;
                        //niceMax = Math.ceil(max / interval) * interval;
                        //neededSteps = (niceMax - niceMin) / interval;
                        //vp.utils.assert(neededSteps == steps);
                        //---- ensure we match STEPS exactly ----
                        interval = (niceMax - niceMin) / steps;
                    }
                }
                else {
                    steps = bestSteps;
                }
                return { min: niceMin, max: niceMax, interval: interval, steps: steps };
            };
            niceNumbersAlt.test = function (min, max, steps) {
                vp.utils.debug("min=" + min + ", max=" + max + ", steps=" + steps);
                var result = this.calculate(min, max, steps);
                vp.utils.assert(result.min <= min);
                vp.utils.assert(result.max >= max);
                vp.utils.debug("  results: min=" + result.min + ", max=" + result.max + ", interval=" + result.interval);
            };
            niceNumbersAlt.testRange = function (min, max) {
                for (var steps = 2; steps <= 12; steps++) {
                    this.test(min, max, steps);
                }
                vp.utils.debug("------------------");
            };
            niceNumbersAlt.testAll = function () {
                this.testRange(-33, -11);
                this.testRange(-8.32, 11.2);
                this.testRange(.09, .9);
                this.testRange(5, 89);
                this.testRange(106, 589);
            };
            return niceNumbersAlt;
        }());
        scales.niceNumbersAlt = niceNumbersAlt;
    })(scales = vp.scales || (vp.scales = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// wrapperTests.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///    - works out (in the small) how to design our classes to support function wrapping.
///-----------------------------------------------------------------------------------------------------------------
/// Lessons learned:
///     - Interfaces: use "T" as return signature for wrapper functions
///     - Base Classes: use "T" name as return signature for wrapper functions
///     - Outer Classes: use class name as return signature for all wrapper functions
///     - Select function: should return a concrete version of the IWrapper interface ("IWrapperOuter")
///     
///     - it is important that interfaces return "T" and not "MyInterface<T>" so that the chaining
///       doesn't get stuck at a base interface level - it always needs to reflect the chaining methods of 
///       the outer class.
var vp;
(function (vp) {
    var internal;
    (function (internal) {
        var SmallWrapperImpl = (function () {
            function SmallWrapperImpl() {
            }
            SmallWrapperImpl.prototype.background = function (value) {
                return this;
            };
            SmallWrapperImpl.prototype.close = function () {
                return this;
            };
            SmallWrapperImpl.prototype.foo = function () {
                var abc;
                abc.background("hi there").background("sdf").foo().background("asdf")
                    .background("sdf").foo();
                return this;
            };
            return SmallWrapperImpl;
        }());
        internal.SmallWrapperImpl = SmallWrapperImpl;
        function smallSelect(abc) {
            return new SmallWrapper3Impl();
        }
        internal.smallSelect = smallSelect;
        function testSmallSelect() {
            var wrapper = smallSelect("abc");
            wrapper
                .background("sdf")
                .background("werw")
                .fill("wer")
                .background("wer")
                .close()
                .fill("sdf");
        }
        var SmallWrapper2Base = (function () {
            function SmallWrapper2Base() {
            }
            SmallWrapper2Base.prototype.background = function (value) {
                return this;
            };
            SmallWrapper2Base.prototype.fill = function (value) {
                return this;
            };
            SmallWrapper2Base.prototype.close = function () {
                return this;
            };
            SmallWrapper2Base.prototype.foobar = function () {
                var abc;
                abc.foobar().background("asdf").fill("asdf")
                    .fill("sdf")
                    .background("asdf")
                    .foobar()
                    .fill("asdf")
                    .background("sdf")
                    .fill("er")
                    .foobar()
                    .close()
                    .foobar();
                return this;
            };
            return SmallWrapper2Base;
        }());
        internal.SmallWrapper2Base = SmallWrapper2Base;
        var SmallWrapper2Impl = (function (_super) {
            __extends(SmallWrapper2Impl, _super);
            function SmallWrapper2Impl() {
                _super.apply(this, arguments);
            }
            return SmallWrapper2Impl;
        }(SmallWrapper2Base));
        internal.SmallWrapper2Impl = SmallWrapper2Impl;
        var SmallWrapper3Impl = (function (_super) {
            __extends(SmallWrapper3Impl, _super);
            function SmallWrapper3Impl() {
                _super.apply(this, arguments);
            }
            return SmallWrapper3Impl;
        }(SmallWrapper2Impl));
        internal.SmallWrapper3Impl = SmallWrapper3Impl;
    })(internal = vp.internal || (vp.internal = {}));
})(vp || (vp = {}));
///-----------------------------------------------------------------------------------------------------------------
/// composerMark.ts.  Copyright (c) 2016 Microsoft Corporation.
///    - part of the vuePlotCore library
///-----------------------------------------------------------------------------------------------------------------
var vp;
(function (vp) {
    var marks;
    (function (marks) {
        /** Supports data-based generation of SVG/Canvas group primitives.  Can be used with animations.  Core function
        is "update()". */
        var composerMarkClass = (function (_super) {
            __extends(composerMarkClass, _super);
            function composerMarkClass(container, className, ctrCallback) {
                _super.call(this, container, "g", null, false, className);
                this._elemShaderInstances = {};
                this._ctrCallback = ctrCallback;
                //vp.utils.trace("ctr", "composerMark");
            }
            composerMarkClass.prototype.localShader = function (elem, data, index, isNew, context, transition) {
                var shaderInst = null;
                var anyElem = elem;
                if (isNew) {
                    var instance = this._ctrCallback(elem);
                    this._elemShaderInstances[anyElem] = instance;
                }
                else {
                    shaderInst = this._elemShaderInstances[anyElem];
                }
                //---- call the instance to shade the composed shape ----
                shaderInst.shadeMarks(transition, data.data, index, isNew, context);
                //---- finally, call the user callback, via the baseclass ----
                //super.localShader(elem, data, index, isNew, context, transition); 
            };
            return composerMarkClass;
        }(marks.markBaseClass));
        marks.composerMarkClass = composerMarkClass;
        function createComposerMark(container, className, ctrCallback) {
            return new composerMarkClass(container, className, ctrCallback);
        }
        marks.createComposerMark = createComposerMark;
    })(marks = vp.marks || (vp.marks = {}));
})(vp || (vp = {}));
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    shapeInterfaces.ts - Shape Engine API.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var DrawParams = (function () {
        function DrawParams() {
        }
        return DrawParams;
    }());
    beachParty.DrawParams = DrawParams;
    var AmbientLight = (function () {
        function AmbientLight() {
            this.lightFactor = .25;
            this.color = [1, 1, 1]; // white
        }
        return AmbientLight;
    }());
    beachParty.AmbientLight = AmbientLight;
    var DirectionalLight = (function (_super) {
        __extends(DirectionalLight, _super);
        function DirectionalLight() {
            _super.call(this);
            this.lightFactor = 1;
        }
        return DirectionalLight;
    }(AmbientLight));
    beachParty.DirectionalLight = DirectionalLight;
    var Lighting = (function () {
        function Lighting() {
            this.ambientLight = new AmbientLight();
            //---- currently, these lights are defined in the cubeVertexShader.c shader ----
            this.light1 = new DirectionalLight();
            this.light2 = new DirectionalLight();
        }
        return Lighting;
    }());
    beachParty.Lighting = Lighting;
    (function (ColorEffect) {
        ColorEffect[ColorEffect["none"] = 0] = "none";
        ColorEffect[ColorEffect["setColor"] = 1] = "setColor";
        ColorEffect[ColorEffect["adjustHue"] = 2] = "adjustHue";
        ColorEffect[ColorEffect["adjustSaturation"] = 3] = "adjustSaturation";
        ColorEffect[ColorEffect["adjustValue"] = 4] = "adjustValue";
    })(beachParty.ColorEffect || (beachParty.ColorEffect = {}));
    var ColorEffect = beachParty.ColorEffect;
    /** this can be applied to SELECTED and UNSELECTED shapes. */
    var ColorParams = (function () {
        function ColorParams(colorEffect, color, colorFactor) {
            if (colorEffect === void 0) { colorEffect = ColorEffect.none; }
            if (color === void 0) { color = "yellow"; }
            if (colorFactor === void 0) { colorFactor = .25; }
            this.colorEffect = colorEffect;
            this.color = color;
            this.colorFactor = colorFactor;
        }
        return ColorParams;
    }());
    beachParty.ColorParams = ColorParams;
    var InstancingParams = (function () {
        function InstancingParams(isEnabled) {
            this.isInstancingEnabled = isEnabled;
        }
        return InstancingParams;
    }());
    beachParty.InstancingParams = InstancingParams;
    var FacetBin = (function () {
        function FacetBin() {
        }
        return FacetBin;
    }());
    beachParty.FacetBin = FacetBin;
    var CameraParams = (function () {
        function CameraParams() {
        }
        return CameraParams;
    }());
    beachParty.CameraParams = CameraParams;
    var ShapeStats = (function () {
        function ShapeStats() {
        }
        return ShapeStats;
    }());
    beachParty.ShapeStats = ShapeStats;
    (function (EaseFunction) {
        EaseFunction[EaseFunction["none"] = 0] = "none";
        EaseFunction[EaseFunction["quadratic"] = 1] = "quadratic";
        EaseFunction[EaseFunction["cubic"] = 2] = "cubic";
        EaseFunction[EaseFunction["quartic"] = 3] = "quartic";
        EaseFunction[EaseFunction["quintic"] = 4] = "quintic";
        EaseFunction[EaseFunction["exponential"] = 5] = "exponential";
        EaseFunction[EaseFunction["sine"] = 6] = "sine";
        EaseFunction[EaseFunction["circle"] = 7] = "circle";
    })(beachParty.EaseFunction || (beachParty.EaseFunction = {}));
    var EaseFunction = beachParty.EaseFunction;
    (function (EaseType) {
        EaseType[EaseType["in"] = 0] = "in";
        EaseType[EaseType["out"] = 1] = "out";
        EaseType[EaseType["inOut"] = 2] = "inOut";
    })(beachParty.EaseType || (beachParty.EaseType = {}));
    var EaseType = beachParty.EaseType;
    (function (DrawPrimitive) {
        DrawPrimitive[DrawPrimitive["auto"] = 0] = "auto";
        DrawPrimitive[DrawPrimitive["point"] = 1] = "point";
        DrawPrimitive[DrawPrimitive["triangle"] = 2] = "triangle";
        DrawPrimitive[DrawPrimitive["quad"] = 3] = "quad";
        DrawPrimitive[DrawPrimitive["cube"] = 4] = "cube";
        DrawPrimitive[DrawPrimitive["lineStrip"] = 5] = "lineStrip";
        DrawPrimitive[DrawPrimitive["linePairs"] = 6] = "linePairs";
        DrawPrimitive[DrawPrimitive["thickLine"] = 7] = "thickLine";
    })(beachParty.DrawPrimitive || (beachParty.DrawPrimitive = {}));
    var DrawPrimitive = beachParty.DrawPrimitive;
    var AnimationData = (function () {
        function AnimationData() {
            this.isAnimationEnabled = true;
            this.animationDuration = .45; // .35
            this.isStaggeringEnabled = true;
            this.isStaggerForward = true;
            this.maxStaggerTime = .45; // .35
            this.easeFunction = EaseFunction.quadratic;
            this.easeType = EaseType.out;
        }
        return AnimationData;
    }());
    beachParty.AnimationData = AnimationData;
    (function (HoverMatch) {
        HoverMatch[HoverMatch["none"] = 0] = "none";
        HoverMatch[HoverMatch["point"] = 1] = "point";
        HoverMatch[HoverMatch["square"] = 2] = "square";
    })(beachParty.HoverMatch || (beachParty.HoverMatch = {}));
    var HoverMatch = beachParty.HoverMatch;
    (function (HoverEffect) {
        /** this means that hover has no visual effect on shapes. */
        HoverEffect[HoverEffect["none"] = 0] = "none";
        /** this means that hover shape will be drawn on top with this color. */
        HoverEffect[HoverEffect["setColor"] = 1] = "setColor";
        /** this means that hover shape will be drawn on top with its original color. */
        HoverEffect[HoverEffect["sameColor"] = 2] = "sameColor";
    })(beachParty.HoverEffect || (beachParty.HoverEffect = {}));
    var HoverEffect = beachParty.HoverEffect;
    var HoverParams = (function () {
        function HoverParams(matchType, squareSize, hoverEffect, hoverColor) {
            if (matchType === void 0) { matchType = HoverMatch.point; }
            if (squareSize === void 0) { squareSize = 10; }
            if (hoverEffect === void 0) { hoverEffect = HoverEffect.setColor; }
            if (hoverColor === void 0) { hoverColor = "purple"; }
            this.hoverMatch = matchType;
            this.squareSize = squareSize;
            this.hoverEffect = hoverEffect;
            this.hoverColor = hoverColor;
        }
        return HoverParams;
    }());
    beachParty.HoverParams = HoverParams;
    /** 10 floats (80 bytes). */
    var LayoutResult = (function () {
        function LayoutResult() {
        }
        return LayoutResult;
    }());
    beachParty.LayoutResult = LayoutResult;
    var Shape = (function (_super) {
        __extends(Shape, _super);
        function Shape() {
            _super.apply(this, arguments);
        }
        return Shape;
    }(LayoutResult));
    beachParty.Shape = Shape;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    dataChanger.ts - base class for classes that change data (supports lightweight MVC).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    beachParty.dcRegisterCount = 0;
    beachParty.dcChangedCount = 0;
    beachParty.dcCallbackCount = 0;
    beachParty.dcUnregisterCount = 0;
    /// Lightweight MVC rules:
    ///
    ///    1. each chunk of data shared between classes (e.g. the app, controls, and dialogs) should be associated with exactly one
    ///          owner class.
    ///
    ///    2. [MODEL] any class that owns shared data should:
    ///         - extend the base class "dataChangerClass" 
    ///         - expose the data with a property getter/setter function
    ///         - when the data is changed (thru the setter or directly), the "onDataChanged()" method should be called
    ///
    ///    3. [VIEW-write] any class that changes shared data should:
    ///         - extend the base class "dataChangerClass" 
    ///         - expose the data with a property getter/setter function
    ///         - when the data is changed (thru the setter or directly), the "onDataChanged()" method should be called
    ///
    ///    5. [CONTROLLER] the code creating a VIEW class should call "connectModelView()" to connect shared data changes
    ///         between the view and the associated owner class.
    ///
    /// This way, the model classes don't have to track the connected view classes and the view classes don't have to known who
    /// the owner/model classes are.  It makes model classes easier to maintain, and enables view classes to be reusable.  The 
    /// messy event-connection code is handled by the "connectModelView()" calls.
    var dataChangerClass = (function () {
        function dataChangerClass() {
            this._callbacks = {}; // used to register listeners for changes to specific names
            this._anyCallbacks = []; // used to register listeners for changes for any names
            this._pendingDataChange = {}; // used to set "changer" for an upcoming "onDataChanged()" call
        }
        dataChangerClass.prototype.registerForChange = function (name, callback, context) {
            beachParty.dcRegisterCount++;
            var callbacks = null;
            if (name) {
                //---- register for a specific property ----
                var callbacks = this._callbacks[name];
                if (!callbacks) {
                    callbacks = [];
                    this._callbacks[name] = callbacks;
                }
            }
            else {
                //---- register for any callback ----
                callbacks = this._anyCallbacks;
            }
            var entry = new callbackEntry(context, callback);
            //---- don't add if already there ----
            if (callbacks.indexOf(entry) == -1) {
                callbacks.push(entry);
            }
        };
        dataChangerClass.prototype.registerForRemovableChange = function (name, context, callback) {
            this.registerForChange(name, callback, context);
        };
        dataChangerClass.prototype.registerForAnyChange = function (callback, context) {
            this.registerForChange(null, callback, context);
        };
        dataChangerClass.prototype.unregisterForChanges = function (context, name, clearAnyCallback) {
            beachParty.dcUnregisterCount++;
            var callbacks = null;
            if (clearAnyCallback) {
                //---- unhook caller from anyCallback ----
                callbacks = this._anyCallbacks;
            }
            else if (name) {
                //---- unhook caller from named event ----
                callbacks = this._callbacks[name];
            }
            else {
                //---- unhook caller from all events ----
                var keys = vp.utils.keys(this._callbacks);
                if (keys) {
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        this.unregisterForChanges(context, key);
                    }
                }
            }
            if (callbacks) {
                for (var i = callbacks.length - 1; i >= 0; i--) {
                    var entry = callbacks[i];
                    if (entry.context == context) {
                        callbacks.removeAt(i);
                    }
                }
            }
        };
        dataChangerClass.prototype.onDataChanged = function (name, changedBy) {
            var params = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                params[_i - 2] = arguments[_i];
            }
            beachParty.dcChangedCount++;
            //---- if caller did not specify changedBy, use the "_pendingDataChange" map to get its value ----
            if (!changedBy) {
                changedBy = this._pendingDataChange[name];
                if (changedBy) {
                    //---- clear it ----
                    delete this._pendingDataChange[name];
                }
            }
            changedBy = changedBy || this;
            if (name === null) {
                //---- trigger all names ----
                var keys = vp.utils.keys(this._callbacks);
                for (var i = 0; i < keys.length; i++) {
                    var name = keys[i];
                    var callbacks = this._callbacks[name];
                    this.triggerCallbacks(name, callbacks, changedBy, params);
                }
            }
            else {
                var callbacks = this._callbacks[name];
                this.triggerCallbacks(name, callbacks, changedBy, params);
            }
            //---- trigger ANY callbacks ----
            var callbacks = this._anyCallbacks;
            this.triggerCallbacks(name, callbacks, changedBy, params);
        };
        dataChangerClass.prototype.triggerCallbacks = function (name, callbacks, changedBy, params) {
            if (callbacks) {
                for (var i = 0; i < callbacks.length; i++) {
                    var entry = callbacks[i];
                    var callback = entry.callback;
                    if (!entry.context || entry.context != changedBy) {
                        //callback(name, changedBy);
                        var newParams = [name, changedBy];
                        if (params) {
                            newParams = newParams.concat(params);
                        }
                        beachParty.dcCallbackCount++;
                        callback.apply(undefined, newParams);
                    }
                }
            }
        };
        dataChangerClass.prototype.setDataWithChanger = function (name, value, changer) {
            this._pendingDataChange[name] = changer;
            try {
                this[name](value);
            }
            finally {
                this._pendingDataChange[name] = null;
            }
        };
        return dataChangerClass;
    }());
    beachParty.dataChangerClass = dataChangerClass;
    function connectModelView(model, modelDataName, view, viewDataName) {
        //--- send changes from model to view ----
        model.registerForRemovableChange(modelDataName, view, function (name, changer) {
            var value = model[modelDataName]();
            view.setDataWithChanger(viewDataName, value, model);
        });
        //--- send changes from view to model ----
        view.registerForRemovableChange(viewDataName, model, function (name, changer) {
            var value = view[viewDataName]();
            model.setDataWithChanger(modelDataName, value, view);
        });
    }
    beachParty.connectModelView = connectModelView;
    var callbackEntry = (function () {
        function callbackEntry(context, callback) {
            this.context = context;
            this.callback = callback;
        }
        return callbackEntry;
    }());
    beachParty.callbackEntry = callbackEntry;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    shapeEng.ts - draws animated batches of shapes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var ShapeEngClass = (function () {
        function ShapeEngClass(canvas) {
            this._isShuttingDown = false;
            this._prevWidth = null;
            this._prevHeight = null;
            //---- CONTEXT ----
            this._gl = null;
            this._mostRecentTextureCount = 0;
            this._needTextureSwap = false;
            //---- PER SHAPE stuff ----
            this._pkToDrawIndex = null;
            this._textRects = [];
            //---- what to gather on each draw cycle ----
            this._buildLayoutResults = false;
            this._buildBoundingBoxes = true;
            this._buildNeeded = false;
            this._rebuildAttrBuffers = true;
            this._isLastDrawOfCycle = false;
            this._isSingleDrawNeeded = false;
            this._newCycleNeeded = false;
            this._recordCount = 0;
            //---- misc LAST flags ----
            this._opacityLast = 1;
            this._sizeFactorLast = 1;
            //---- GL ATTRIBUTES ----
            //_vertexCount = 0;
            this._verticesPerRecord = 1;
            this._lastVerticesPerRecord = null;
            //---- BUFFERS ----
            //_usingPointCubes = false;
            this._drawOrderKey = "none";
            this._gridLinesBuffer = null;
            //private _isFirstFilteredStage = false;
            //---- HIT TESTING ----
            this._lastRayHitTestInfo = null;
            this._lastRectHitTestInfo = null;
            this._lastWorld = null;
            this._lerpWorld = null;
            this._hitTestCount = 0; // for this chart
            //---- UNIFORM (shader constants) ----
            this._uniforms = {};
            this._isBlendingEnabled = false;
            this._instantSizeChange = false;
            this._firstDraw = true;
            this._isCullingEnabled = true;
            this._maxColors = 2;
            this._maxColors2 = 2;
            this._primaryColorCount = 0;
            this._isChannelLast = false;
            //---- ANIMATION TIMING ----
            this._toPercentUneased = 1;
            this._toStartTime = 0;
            this._isCycleActive = false;
            this._isUiOpActive = false; // if a drag-based 3D transform is active (keep animation running)
            this._isInertiaActive = false; // if initeria is continuously applying a 3D transform
            this._toPercent = 1;
            this._animCycleCount = 0;
            this._maxPercent = 0;
            this._isSmoothLast = false; // isSmooth setting from last anim cycle
            this._animTimer = null;
            this._omitAnimOnNextBuild = false;
            //---- PERF STATS ----
            this._drawPerf = {};
            this._buildPerf = {};
            this._drawFrameStatsMsg = null;
            this._lastFrameTime = 0;
            this._lastCycleFrameRate = 0;
            this._lastCycleFrameCount = 0;
            this._frameCount = 0;
            this._frameRate = 0;
            this._renderCount = 0;
            this._moveFrameCount = 0;
            this._drawFrameCount = 0;
            this._cycleFrameCount = 0;
            this._nextBuildId = 0;
            //---- events ----
            this.onCycleStart = new beachParty.bpEvent();
            this.onCycleEnd = new beachParty.bpEvent();
            this.onMoveFrame = new beachParty.bpEvent();
            this.onDrawFrame = new beachParty.bpEvent();
            this._canvas = canvas;
            this.init();
        }
        ShapeEngClass.prototype.init = function () {
            //---- specify "preserveDrawingBuffer=true" so we can capture images using toDataUrl() ----
            this._gl = beachParty.glUtils.getContext(this._canvas, { preserveDrawingBuffer: true }); // true });
            this._glInst = null; // set in onDrawPrimitiveChanged()
            this._boundingBoxMgr = new beachParty.boundingBoxMgrClass();
            this._transformer = new beachParty.transformerClass(this._gl);
            this.setOptionsToDefaults();
            beachParty.buildCubeMesh();
            this._bufferMgr = new beachParty.bufferMgrClass(this._gl, this._glInst, this);
            this.processDrawParamChanges(this._drawParams);
        };
        ShapeEngClass.prototype.clearCanvas = function () {
            this.startNewFrame();
        };
        /**
         *  Clears shapes and buffers.
         */
        ShapeEngClass.prototype.resetBuffers = function () {
            this._pkToDrawIndex = null;
            this._shapes = [];
            this._shapeCount = 0;
            this.clearFromBuffers();
            this._bufferMgr.createGlAttributes(this._shapesProgram, true);
            this._boundingBoxMgr = new beachParty.boundingBoxMgrClass();
        };
        /**
        *  Shutdown the shape engine & release as much memory as possible.
       */
        ShapeEngClass.prototype.shutDown = function () {
            this._isShuttingDown = true;
        };
        ShapeEngClass.prototype.onDrawPrimitiveChanged = function (needBufferRebuild, needProgramBuild) {
            var dp = this._drawParams;
            //---- refresh glInst for this build ----
            //---- using POINT and INST together slow perf on IE11, so prevent that ----
            if (dp.useInstancing && dp.drawPrimitive != beachParty.DrawPrimitive.point) {
                this._glInst = beachParty.glUtils.getExtension(this._gl, "ANGLE_instanced_arrays");
            }
            else {
                this._glInst = null;
            }
            //---- update the glInst used by bufferMgr ----
            this._bufferMgr.glInst(this._glInst);
            this._drawPrimitive = dp.drawPrimitive;
            this.onDrawPrimitiveChangedPost(needBufferRebuild, needProgramBuild);
        };
        ShapeEngClass.prototype.overrideDrawPrimitive = function (value) {
            this._drawPrimitive = value;
            this.onDrawPrimitiveChangedPost(true, false);
        };
        ShapeEngClass.prototype.onDrawPrimitiveChangedPost = function (needBufferRebuild, needProgramBuild) {
            this.computeCulling();
            this.onDataOrPrimitiveChanged(needProgramBuild);
            this.createGlUniforms();
            this.markBuildNeeded("onDrawPrimitiveChanged");
            if (needBufferRebuild) {
                this._rebuildAttrBuffers = true;
            }
        };
        ShapeEngClass.prototype.computeCulling = function () {
            this._isCullingEnabled = false;
            if (this._drawPrimitive == beachParty.DrawPrimitive.cube) {
                if (this._drawParams.useCulling) {
                    this._isCullingEnabled = true;
                }
            }
        };
        ShapeEngClass.prototype.rectsDiffer = function (rc, rc2) {
            var isDiff = (rc.left != rc2.left || rc.top != rc2.top || rc.width != rc2.width || rc.height != rc2.height);
            return isDiff;
        };
        ShapeEngClass.prototype.processDrawParamChanges = function (dp) {
            this.onEaseFunctionChanged();
            var newDrawPrim = this._drawParams.drawPrimitive;
            if (newDrawPrim != this._drawPrimitive || (this._glInst != null) != this._drawParams.useInstancing) {
                //---- previous chart changed drawingPrimitive - restore it now ----
                this._drawPrimitive = newDrawPrim;
                this.onDrawPrimitiveChanged(true, false); //  this.onDrawPrimitiveChangedPost(true, false);
            }
            else {
                this.onDrawPrimitiveChanged(false, false); // true);
            }
            this._bufferMgr.createGlAttributes(this._shapesProgram, false);
            this.createGlUniforms();
            //---- rebuild camera if needed ----
            if (this._prevWidth != dp.canvasWidth || this._prevHeight != dp.canvasHeight) {
                this._transformer.updateCamera(false, dp.canvasWidth, dp.canvasHeight);
                this._prevWidth = dp.canvasWidth;
                this._prevHeight = dp.canvasHeight;
            }
        };
        ShapeEngClass.prototype.onEaseFunctionChanged = function () {
            var ad = this._drawParams.animationParams;
            this._easeFunction = utils.getEasingFunction(ad.easeFunction);
        };
        ShapeEngClass.prototype.onCanvasColorChanged = function () {
            var cr = this._drawParams.clearColor;
            if (!cr || cr == "none" || cr == "transparent") {
                var crArray = [0, 0, 0, 0]; // transparent
            }
            else {
                var clearColor = vp.color.getColorFromString(cr);
                if (!clearColor) {
                    var crArray = [0, 0, 0, 0]; // transparent
                }
                else {
                    var crArray = vp.color.makeColorArrayForWebGL(clearColor);
                }
            }
            this._clearColor = crArray;
        };
        ShapeEngClass.prototype.getTotalVertexCount = function () {
            var shapeCount = this._shapeCount;
            var verticesPerRecord = this.getNumVerticesInBuffer();
            var vertexCount = shapeCount * verticesPerRecord;
            return vertexCount;
        };
        ShapeEngClass.prototype.getLastVerticesPerRecord = function () {
            return this._lastVerticesPerRecord;
        };
        ShapeEngClass.prototype.getShapeCount = function () {
            return this._shapeCount;
        };
        ShapeEngClass.prototype.setLastVerticesPerRecord = function () {
            this._lastVerticesPerRecord = this.getNumVerticesInBuffer();
        };
        /** The true vertex count for the current drawing primitive. */
        ShapeEngClass.prototype.getNumVerticesPerShape = function () {
            //auto,         // not seen here, but take its value into account
            //point,
            //triangle,
            //quad,
            //cube,
            //lineStrip,
            //linePairs,
            //thickLine,
            var verticesByPrim = [1, 1, 3, 6, 36, 1, 1, 6];
            var verticesPer = verticesByPrim[this._drawParams.drawPrimitive];
            return verticesPer;
        };
        /** vertex count for buffers. */
        ShapeEngClass.prototype.getNumVerticesInBuffer = function () {
            var vertexCount = 1;
            if (!this._glInst) {
                vertexCount = this.getNumVerticesPerShape();
            }
            return vertexCount;
        };
        ShapeEngClass.prototype.setOptionsToDefaults = function () {
            var dp = new beachParty.DrawParams();
            this._drawParams = dp;
            dp.isBlendingEnabled = false;
            dp.areShapesLines = false;
            dp.useContinuousDrawing = false;
            dp.useWireFrameDraw = false;
            dp.useCulling = false;
            dp.useContinuousColor = false;
            dp.useColorChannels = false;
            dp.useTextures = false;
            dp.useInstancing = false; // be conservative
            dp.sizeFactor = 1;
            dp.shapeOpacity = 1;
            dp.maxGlBufferLength = null;
            dp.animPercentOverride = undefined;
            dp.colorPalette = ["blue", "red", "green"];
            dp.hoverPrimaryKey = null;
            dp.drawOrderKey = null;
            dp.shapeImage = null;
            dp.clearColor = "transparent";
            dp.imagePalette = null;
            dp.drawPrimitive = beachParty.DrawPrimitive.cube;
            dp.facetBins = null;
            dp.canvasWidth = 100;
            dp.canvasHeight = 100;
            var camera = new beachParty.transformerClass(this._gl);
            dp.cameraParams = camera.cameraParams();
            dp.hoverParams = new beachParty.HoverParams();
            dp.animationParams = new beachParty.AnimationData();
            dp.lightParams = new beachParty.Lighting();
            dp.cameraParams = new beachParty.CameraParams();
            this.onCanvasColorChanged();
        };
        /** called when the user has changed the images used to build the texture sheet.  Starts the building of a new texture, if needed. */
        ShapeEngClass.prototype.checkForTexPaletteChanged = function () {
            var texPalette = null;
            //---- shapeMappingPalette takes priority ----
            if (this._shapeMappingPalette && this._shapeMappingPalette.length) {
                texPalette = this._shapeMappingPalette;
            }
            else {
                var imgName = this._drawParams.shapeImage;
                if (imgName && imgName != "none") {
                    texPalette = [imgName];
                }
            }
            if (texPalette != this._texPalette) {
                this.onTexPaletteChanged(texPalette);
                this._texPalette = texPalette;
            }
        };
        ShapeEngClass.prototype.onTexPaletteChanged = function (texPalette) {
            var _this = this;
            var gl = this._gl;
            if (texPalette && texPalette.length) {
                var isShapeNames = (!texPalette[0].contains("."));
                var textureMaker = new beachParty.textureMakerClass(texPalette);
                textureMaker.registerForChange("loaded", function (e) {
                    var texture = textureMaker.getTexture();
                    var potCount = textureMaker.getPotCount();
                    _this.onTextureLoaded(texture, potCount);
                });
                textureMaker.buildAsync(gl, texPalette, isShapeNames);
            }
            else {
                this.onTextureLoaded(null, 0);
                vp.select("#imgDebug")
                    .css("display", "none");
            }
        };
        /** called when a new texture is ready to be applied. */
        ShapeEngClass.prototype.onTextureLoaded = function (newTexture, textureCount) {
            this._mostRecentTexture = newTexture;
            this._mostRecentTextureCount = textureCount;
            this._needTextureSwap = (newTexture != null);
            vp.utils.debug("onTextureLoaded: newTexture=" + newTexture + ", newTextureCount=" + textureCount);
            this.markBuildNeeded("onTextureLoaded");
        };
        ShapeEngClass.prototype.drawShapes = function (shapes) {
            this._shapes = shapes;
            if (this._shapeCount != shapes.length) {
                this.clearFromBuffers();
                this._shapeCount = shapes.length;
            }
            this.buildPlot();
            this._newCycleNeeded = true;
            this.startAnimationIfNeeded();
        };
        ShapeEngClass.prototype.getFacetBins = function () {
            return this._drawParams.facetBins;
        };
        ShapeEngClass.prototype.getPkToDrawIndex = function (key) {
            return this._pkToDrawIndex[key];
        };
        ShapeEngClass.prototype.forceDomApiCall = function () {
            //---- this code is NECESSARY to enable JIT-ing (make a DOM API call) ----
            var canvas = document.createElement("canvas");
            var ctxJit = canvas.getContext("2d");
            ctxJit.globalAlpha = 1;
            ctxJit.font = "16px Tahoma";
        };
        ShapeEngClass.prototype.addToDrawPerf = function (name, start) {
            var now = vp.utils.now();
            var elapsed = now - start;
            this._drawPerf[name] += elapsed;
            return now;
        };
        ShapeEngClass.prototype.addToBuildPerf = function (name, start) {
            var now = vp.utils.now();
            var elapsed = now - start;
            this._buildPerf[name] += elapsed;
            return now;
        };
        ShapeEngClass.prototype.resetDrawPerf = function () {
            this._drawPerf = {};
            this._drawPerf.configDevice = 0;
            this._drawPerf.clear = 0;
            this._drawPerf.applyUniforms = 0;
            this._drawPerf.drawBuffers = 0;
            this._drawPerf.onFrame = 0;
            this._drawPerf.total = 0;
        };
        ShapeEngClass.prototype.resetBuildPerf = function () {
            this._buildPerf = {};
            this._buildPerf.layoutPrep = 0;
            this._buildPerf.preLayout = 0;
            this._buildPerf.layoutEx = 0;
            this._buildPerf.reorderBuffer = 0;
            this._buildPerf.layoutPost = 0;
            this._buildPerf.total = 0;
        };
        ShapeEngClass.prototype.getBuildPerfTime = function (name) {
            return this._buildPerf[name];
        };
        ShapeEngClass.prototype.buildPlot = function () {
            var buildPlotStart = vp.utils.now();
            var buildStart = vp.utils.now();
            this.resetBuildPerf();
            var buildId = this._nextBuildId++;
            try {
                this.updateTransformerFromDrawParmas();
                this.checkForTexPaletteChanged();
                this.buildGlStuff();
                this.fillGlBuffers(buildStart);
            }
            finally {
                //---- clear flags for next build ----
                this._rebuildAttrBuffers = false;
            }
            this.addToBuildPerf("total", buildStart);
            this._buildPerf.glBufferFill = vp.utils.now() - buildPlotStart;
        };
        ShapeEngClass.prototype.setShaderColorPalette = function (newColors, maxColors) {
            //this._colorPalette = newColors;
            var newFloats = (newColors) ? beachParty.glUtils.colorNamesOrValuesToFloats(newColors) : null;
            if (this.isUsingPrimaryBuffers()) {
                this._colorFloats = newFloats;
                this._maxColors = maxColors;
                if (!this._colorFloats2) {
                    this._colorFloats2 = newFloats;
                    this._maxColors2 = maxColors;
                }
            }
            else {
                this._colorFloats2 = newFloats;
                this._maxColors2 = maxColors;
                if (!this._colorFloats) {
                    this._colorFloats = newFloats;
                    this._maxColors = maxColors;
                }
            }
        };
        /** fill buffers with attribute values for each object. */
        ShapeEngClass.prototype.fillGlBuffers = function (buildStart) {
            this._textRects = [];
            //this._spheres = [];
            this._gridLinesBuffer = [];
            this._drawInfos = [];
            //---- to minimize impact on memory, re-use this array (rather than reallocating it) ----
            //this._boundingBoxes = [];
            var fillStart = vp.utils.now();
            var dp = this._drawParams;
            var maxColors = dp.colorPalette.length; // is this all we need?
            this.setShaderColorPalette(dp.colorPalette, maxColors);
            var counters = { next1: 0, next3: 0 };
            var verticesPerRecord = this._verticesPerRecord;
            var layoutStart = vp.utils.now();
            //this._facetLabelRects = [];
            var usingPrimary = this.isUsingPrimaryBuffers();
            var attributes = this._bufferMgr.getAttributesForCycle(usingPrimary);
            var buffers = this._bufferMgr.getNamedBuffers(attributes);
            //---- for now, always re-order the buffer ----
            var reorderResult = null;
            var start = this.addToBuildPerf("reorderBuffer", buildStart);
            //---- if sort order has changed, REORDER record data in FROM buffer ---
            var drawOrderKey = this._drawParams.drawOrderKey;
            if (drawOrderKey != this._drawOrderKey) {
                reorderResult = this._bufferMgr.reorderFromBuffers(verticesPerRecord);
            }
            //---- now its safe to clear this ----
            this._pkToDrawIndex = {};
            this._drawOrderKey = drawOrderKey;
            start = this.addToBuildPerf("layoutPrep", start);
            var drawBufferIndex = 0; // where to put next record layout data
            var verticesPerShape = this.getNumVerticesPerShape();
            var verticesInBuffer = this.getNumVerticesInBuffer();
            var facetBins = this._drawParams.facetBins;
            if (facetBins && facetBins.length) {
                // var facetResult = facetHelper.layout();
                //---- now, do the REGULAR PASS on all facets ----
                for (var i = 0; i < facetBins.length; i++) {
                    var facetOffset = facetBins[i].drawOffset;
                    //---- update drawing context for this facet ----
                    var facetRecordCount = facetBins[i].rowIndexes.length; //  utils.getDataLength(nvBucket);
                    /// NOTE: we do NOT update the scales or the dc bounds - chart draws into first facet bounds and then system offsets x/y as needed afterwards. 
                    /// calcRanges() uses the FIRST facet bounds to set: dc.x, dc.y, dc.width, dc.height also.  
                    this.drawChartOrFacet(verticesPerRecord, buffers, counters, facetOffset, drawBufferIndex, facetRecordCount);
                    var drawInfo = new DrawInfo(drawBufferIndex, facetRecordCount);
                    this._drawInfos.push(drawInfo);
                    drawBufferIndex += facetRecordCount;
                }
            }
            else {
                var shapeCount = this._shapeCount;
                //---- REGULAR PASS (no facets) ----
                this.drawChartOrFacet(verticesPerRecord, buffers, counters, { x: 0, y: 0 }, drawBufferIndex, shapeCount);
                this.addNewDrawingBatch(drawBufferIndex, shapeCount);
            }
            //vp.utils.debug("after layout of all records, keyCount(this._pkToDrawIndex): " + vp.utils.keys(this._pkToDrawIndex).length);
            if (true) {
                //---- add DrawInfo for HOVER SHAPE (will dynamically set the hoverVectorIndex) ----
                this.addNewDrawingBatch(-1, 1);
            }
            this._bufferMgr.allocateBuffers(this._drawInfos);
            var drawIndexes = vp.data.range(0, this._drawInfos.length - 1);
            this._bufferMgr.bindBuffersToArrayData(drawIndexes);
            var elapsed = vp.utils.now() - layoutStart;
            //vp.utils.debug("layoutChartOrFacet took: " + elapsed + " ms");
            var start = vp.utils.now();
            this._bufferMgr.setArraysFromNamedBuffers(attributes, buffers);
            //this.dumpVertexBuffers("FILL toBuffers", verticesPerRecord, buffers);
            if (reorderResult) {
                this._bufferMgr.setArraysFromNamedBuffers(reorderResult.attributes, reorderResult.buffers);
            }
            this._bufferMgr.setFromBufferHasData(true);
            //this.bindGridLinesBuffer();
            this.addToBuildPerf("layoutPost", start);
            var elapsed = vp.utils.now() - fillStart;
            //vp.utils.debug("fillBuffers took: " + elapsed + " ms");
        };
        ShapeEngClass.prototype.addNewDrawingBatch = function (drawBufferIndex, shapeCount) {
            var maxLen = this._drawParams.maxGlBufferLength;
            if (maxLen) {
                while (shapeCount > maxLen) {
                    var drawInfo = new DrawInfo(drawBufferIndex, maxLen);
                    this._drawInfos.push(drawInfo);
                    drawBufferIndex += maxLen;
                    shapeCount -= maxLen;
                }
            }
            var drawInfo = new DrawInfo(drawBufferIndex, shapeCount);
            this._drawInfos.push(drawInfo);
        };
        ShapeEngClass.prototype.getPrimaryColorCount = function () {
            return this._primaryColorCount;
        };
        ShapeEngClass.prototype.hitTestRay = function (ray, mousePt) {
            var itemsFound = [];
            //var textRects = this._textRects;
            var bbCount = this._boundingBoxMgr.getCount();
            //---- do hit testing using bounding spheres, then test at triangle level ----
            var start = vp.utils.now();
            //---- test against 3D objects ----
            for (var i = 0; i < bbCount; i++) {
                var box = this._boundingBoxMgr.getBoxByIndex(i);
                var dist = ray.intersectBox(box);
                if (dist !== null) {
                    var hit = new beachParty.HitTestResult(dist, box.primaryKey, box);
                    itemsFound.push(hit);
                }
            }
            ////---- test against 2d TEXT boxes ----
            //for (var i = 0; i < textRects.length; i++)
            //{
            //    var rc = textRects[i];
            //    if (vp.geom.rectContainsPoint(rc, mousePt))
            //    {
            //        var hit = new HitTestResult(0, rc.primaryKey, rc);
            //        itemsFound.push(hit);
            //    }
            //}
            var elapsed = vp.utils.now() - start;
            //vp.utils.debug("hitTestRay: itemsFound=" + itemsFound.length + ", elapsed: " + elapsed + " ms");
            this._lastRayHitTestInfo = { type: "ray", elapsed: elapsed, itemsFoundCount: itemsFound.length };
            this._hitTestCount++;
            return itemsFound;
        };
        ShapeEngClass.prototype.drawChartOrFacet = function (verticesPerRecord, buffers, counters, facetOffset, drawBufferIndex, dcRecordCount) {
            //---- opt out if just forcing JIT ----
            if (!this._shapeCount) {
                return;
            }
            //vp.utils.debug("layoutChartOrFacet: facetOffset.x=" + facetOffset.x + ", facetOffset.y=" + facetOffset.y);
            var start = vp.utils.now();
            start = this.addToBuildPerf("preLayout", start);
            var textDrawCount = 0;
            var bufferOffset = drawBufferIndex;
            /// NOTE: taking perf measurements each time thru the loop causes a HUGE slowdown in the layout process,
            /// so we now just take a sample at the end (without the layout, fill, process breakdown). 
            for (var fri = 0; fri < dcRecordCount; fri++) {
                //var primaryKey = nv.primaryKey.getRawData(fri) + "";
                var myIndex = fri + bufferOffset;
                var shape = this._shapes[myIndex];
                var primaryKey = shape.primaryKey;
                start = this.addToBuildPerf("layout", start);
                var rect = this.processResultsForHitTesting(fri, primaryKey, shape, facetOffset, drawBufferIndex);
                start = this.addToBuildPerf("process", start);
                //---- for IE code JIT-ing purposes, the fill buffers loop must be in its own function ----
                this._bufferMgr.fillBuffersForRecord(buffers, shape, facetOffset, verticesPerRecord, primaryKey, drawBufferIndex, fri);
                //if (this._tm.colName != null && textDrawCount < this._tm.maxShapes)
                //{
                //    //---- use "fri" (vs. "drawBufferIndex") so that we index nv.* correctly ----
                //    this.drawTextForItem(this._ctx, fri, rect, nv, dr, primaryKey);
                //    textDrawCount++;
                //}
                this._pkToDrawIndex[primaryKey] = drawBufferIndex;
                //start = this.addToBuildPerf("fill", start);
                drawBufferIndex++;
            }
            //var debugMsg = "record drawn: " + i;
            //vp.select("#consoleDiv").text(debugMsg);
            //if (this._lm.colName)
            //{
            //    this.drawLinesBetweenShapes(dc, buffers, facetOffset);
            //}
            start = this.addToBuildPerf("layoutEx", start);
            //vp.utils.debug("finished layout of " + dc.recordCount + " shapes");
            //this.fillGridLinesBuffer(dc, facetOffset);
            this.addToBuildPerf("layoutPost", start);
        };
        ShapeEngClass.prototype.processResultsForHitTesting = function (fri, primaryKey, dr, facetOffset, drawBufferIndex) {
            var rect = null;
            //---- create a bouding-box RECT for hit-testing on this shape ----
            if (dr.opacity > 0) {
                var sizeFactor = this._drawParams.sizeFactor; //  dc.userSizeFactor;
                var hitTestWidth = dr.width * sizeFactor;
                var hitTestHeight = dr.height * sizeFactor;
                rect = vp.geom.createRect(dr.x - hitTestWidth / 2, dr.y - hitTestHeight / 2, hitTestWidth, hitTestHeight);
                if (this._buildBoundingBoxes) {
                    var halfDepth = dr.depth / 2;
                    //---- bug workaround - for some reason, this "halfDepth" results in front/back mappings that are too far apart. ----
                    //---- so, for now, we adjust it here. "10" seems to provide better answers than no adjustment.  ----
                    halfDepth /= 10;
                    this._boundingBoxMgr.addBox(rect.left, rect.top, dr.z - halfDepth, rect.right, rect.bottom, dr.z + halfDepth, dr.theta, primaryKey);
                }
            }
            return rect;
        };
        ShapeEngClass.prototype.isUsingPrimaryBuffers = function () {
            return this._bufferMgr.getUsingPrimaryBuffers();
        };
        ShapeEngClass.prototype.buildTexture = function () {
            var gl = this._gl;
            var newTexture = this._mostRecentTexture;
            var textureCount = this._mostRecentTextureCount;
            /// webGL bug/misunderstanding workaround: seems that creating a new webGL texture somehow corrupts the existing texture activations, so we 
            /// always reactive the existing textures here.
            if (this.isUsingPrimaryBuffers()) {
                //---- move NEW texture to texture1 ----
                this._texture1 = newTexture;
                this._textureCount1 = textureCount;
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, newTexture);
                // vp.utils.debug("new texture assigned to: gl.TEXTURE0");
                //---- rebind prev texture to texture2 ----
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, this._texture2);
            }
            else {
                //---- move NEW texture to texture2 ----
                this._texture2 = newTexture;
                this._textureCount2 = textureCount;
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, newTexture);
                //vp.utils.debug("new texture assigned to: gl.TEXTURE1");
                //---- rebind prev texture to texture0 ----
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this._texture1);
            }
            //vp.utils.debug("buildTexture: texture1=" + this._texture1 + ", texture2=" + this._texture2);
            //this._isAnimatingTexture = true;
        };
        ShapeEngClass.prototype.buildGlStuff = function () {
            var lightParams = this._drawParams.lightParams;
            //---- TODO: sort when using blending and 3D objects ----
            //---- for now, turn off blending if are in a 3D chart ----
            this._isBlendingEnabled = (this._drawParams.isBlendingEnabled && !this._textureCount1 && !this._textureCount2);
            this.onCanvasColorChanged(); // recalculate this._clearColor
            var usingPrimary = this.isUsingPrimaryBuffers();
            //vp.utils.debug("buildNonLayoutStuff: this._usingPrimaryBuffers=" + usingPrimary);
            this.buildTexture();
            var forceVisualBreak = false;
            if (this._firstDraw) {
                this.onDataOrPrimitiveChanged(true);
                //---- is ALL this needed when we change data? ----
                this._bufferMgr.createGlAttributes(this._shapesProgram, true);
                this.createGlUniforms();
                //---- clear hover index ----
                //this._drawParams.hoverPrimaryKey = null;     
                this._rebuildAttrBuffers = true;
                this._firstDraw = false;
                forceVisualBreak = true;
            }
            //---- NOTE: the boundingBoxes only hold FILTERED-IN shapes - you cannot find shapes directly using "vectorIndex" for them ----
            //var filteredInCount = this._drawParams.filteredInShapeCount;        //  this._dataMgr.getFilteredInCount();
            this._boundingBoxMgr.adjustSizeAndClearList(this._shapeCount);
            this._bufferMgr.createAttributeArraysIfNeeded(this._rebuildAttrBuffers, forceVisualBreak);
        };
        ShapeEngClass.prototype.getClosestBox = function (boxes) {
            var box = null;
            var minDist = Number.MAX_VALUE;
            for (var i = 0; i < boxes.length; i++) {
                var b = boxes[i];
                if (i == 0 || b.dist < minDist) {
                    minDist = b.dist;
                    box = b;
                }
            }
            return box;
        };
        ShapeEngClass.prototype.hitTestFromRect = function (rcScreen, isChartRelative, onlyMostCentral) {
            var start = vp.utils.now();
            var boxes = null;
            //vp.utils.debug("hitTestRect: left=" + rcScreen.left + ", top=" + rcScreen.top);
            //---- ensure the _boundingBoxes match the current data set ----
            //if (this._boundingBoxMgr.getCount() == this._shapeCount)
            if (this._boundingBoxMgr.getCount() > 0) {
                //---- adjust for margins ----
                if (isChartRelative) {
                    var left = +rcScreen.left; // - this._frameLeft;
                    var top = +rcScreen.top; // - this._frameTop;
                }
                else {
                    var left = rcScreen.left;
                    var top = rcScreen.top;
                }
                //---- adjust for plot topOffset=10 ----
                //top -= 10;
                rcScreen = vp.geom.createRect(left, top, rcScreen.width, rcScreen.height);
                boxes = beachParty.hitTestRect.intersectUsingTransforms(rcScreen, this._transformer, this._boundingBoxMgr);
                if (onlyMostCentral) {
                    var centralBox = this.getClosestBox(boxes);
                    boxes = (centralBox) ? [centralBox] : [];
                }
                var elapsed = vp.utils.now() - start;
                //vp.utils.debug("hitTestRect: boxes=" + boxes.length + ", elapsed: " + elapsed + " ms");
                this._lastRectHitTestInfo = { type: "rect", elapsed: elapsed, itemsFoundCount: boxes.length };
                this._hitTestCount++;
            }
            return boxes;
        };
        ShapeEngClass.prototype.createGlUniforms = function () {
            var gl = this._gl;
            var program = this._shapesProgram;
            var uniforms = this._uniforms;
            //---- these are constant values (and don't have to be updated again) ----
            var matProjection = this._transformer.getProjection(); // .toFloat32Array();
            beachParty.glUtils.addUniform(uniforms, gl, program, "projectionMatrix", "matrix4fv", matProjection);
            beachParty.glUtils.addUniform(uniforms, gl, program, "invMvpMatrix", "matrix4fv");
            beachParty.glUtils.addUniform(uniforms, gl, program, "invWorldMatrix", "matrix4fv");
            beachParty.glUtils.addUniform(uniforms, gl, program, "colorPalette", "3fv", this._colorFloats);
            beachParty.glUtils.addUniform(uniforms, gl, program, "colorPalette2", "3fv", this._colorFloats2);
            beachParty.glUtils.addUniform(uniforms, gl, program, "isColorDiscrete", "1f");
            beachParty.glUtils.addUniform(uniforms, gl, program, "isColorDiscrete2", "1f");
            beachParty.glUtils.addUniform(uniforms, gl, program, "isColorDirect", "1f");
            beachParty.glUtils.addUniform(uniforms, gl, program, "isColorDirect2", "1f");
            //if (this._usingPointCubes)
            //{
            //    glUtils.addUniform(uniforms, gl, program, "canvasSize", "2f");
            //    glUtils.addUniform(uniforms, gl, program, "szCanvas", "2f");
            //    glUtils.addUniform(uniforms, gl, program, "ndcZ", "1f");
            //    glUtils.addUniform(uniforms, gl, program, "cameraPos", "3fv");
            //    glUtils.addUniform(uniforms, gl, program, "mvpMatrix", "matrix4fv");
            //    glUtils.addUniform(uniforms, gl, program, "worldMatrix", "matrix4fv");
            //}
            //else
            {
                beachParty.glUtils.addUniform(uniforms, gl, program, "cubeVertices", "3fv", beachParty.cubeMesh.vertices);
                beachParty.glUtils.addUniform(uniforms, gl, program, "cubeNormals", "3fv", beachParty.cubeMesh.vertexNormals);
                beachParty.glUtils.addUniform(uniforms, gl, program, "cubeTexCoords", "2fv", beachParty.cubeMesh.uvFrontOnly);
                beachParty.glUtils.addUniform(uniforms, gl, program, "cubeTriangles", "1fv", beachParty.cubeMesh.triangles);
                beachParty.glUtils.addUniform(uniforms, gl, program, "drawingPoints", "1f");
                beachParty.glUtils.addUniform(uniforms, gl, program, "ambientFactor", "1f");
                beachParty.glUtils.addUniform(uniforms, gl, program, "lightFactor1", "1f"); // set in view
                //glUtils.addUniform(uniforms, gl, program, "lightFactor2", "1f");        // set in view
                beachParty.glUtils.addUniform(uniforms, gl, program, "lightingEnabled", "1f");
                beachParty.glUtils.addUniform(uniforms, gl, program, "triangleIndex", "1f", 0);
            }
            //---- these are updated every frame ----
            beachParty.glUtils.addUniform(uniforms, gl, program, "maxColors", "1f");
            beachParty.glUtils.addUniform(uniforms, gl, program, "maxColors2", "1f");
            beachParty.glUtils.addUniform(uniforms, gl, program, "globalOpacity", "1f");
            beachParty.glUtils.addUniform(uniforms, gl, program, "globalOpacity2", "1f");
            beachParty.glUtils.addUniform(uniforms, gl, program, "toPercent", "1f");
            beachParty.glUtils.addUniform(uniforms, gl, program, "toPercentTheta", "1f");
            beachParty.glUtils.addUniform(uniforms, gl, program, "toPercentUneased", "1f");
            beachParty.glUtils.addUniform(uniforms, gl, program, "sizeFactor", "1f");
            beachParty.glUtils.addUniform(uniforms, gl, program, "sizeFactor2", "1f");
            beachParty.glUtils.addUniform(uniforms, gl, program, "modelViewMatrix", "matrix4fv");
            beachParty.glUtils.addUniform(uniforms, gl, program, "normalMatrix", "matrix3fv");
            //---- texture uniforms ----
            beachParty.glUtils.addUniform(uniforms, gl, program, "toPercentFrag", "1f", -1);
            beachParty.glUtils.addUniform(uniforms, gl, program, "usingTexture1", "1f", -1);
            beachParty.glUtils.addUniform(uniforms, gl, program, "usingTexture2", "1f", -1);
            beachParty.glUtils.addUniform(uniforms, gl, program, "uSampler1", "1i", 0);
            beachParty.glUtils.addUniform(uniforms, gl, program, "uSampler2", "1i", 1);
            beachParty.glUtils.addUniform(uniforms, gl, program, "textureCount1", "1f", 0);
            beachParty.glUtils.addUniform(uniforms, gl, program, "textureCount2", "1f", 0);
            //---- hover stuff ----
            beachParty.glUtils.addUniform(uniforms, gl, program, "hoverVectorIndex", "1f", -1);
            beachParty.glUtils.addUniform(uniforms, gl, program, "hoverColor", "3f");
        };
        ShapeEngClass.prototype.onDataOrPrimitiveChanged = function (needRebuild) {
            var shapeCount = this._shapeCount;
            var verticesPerRecord = this.getNumVerticesInBuffer();
            var vertexCount = shapeCount * verticesPerRecord;
            //this._vertexCount = vertexCount;
            this._verticesPerRecord = verticesPerRecord;
            var rebuiltProgram = false;
            //if (false)      // this._drawPrimitive == DrawPrimitive.point)
            //{
            //    var shaderChanged = this.setShaders("pointCube/pointVertex.c",
            //        "pointCube/pointFragment.c");
            //}
            //else
            {
                var shaderChanged = this.setShaders("cubeVertexShader.c", "fragmentShader.c");
            }
            if (needRebuild || shaderChanged) {
                this.buildAndUseGlProgram();
            }
        };
        ShapeEngClass.prototype.getPrimaryKeys = function () {
            var primaryKeys = this._shapes.map(function (shape) { return shape.primaryKey; });
            return primaryKeys;
        };
        ShapeEngClass.prototype.buildAndUseGlProgram = function () {
            var gl = this._gl;
            //---- SHAPES program ----
            var vertexShader = beachParty.glUtils.findAndCompileShader(gl, this._vertexShaderId, true);
            var fragmentShader = beachParty.glUtils.findAndCompileShader(gl, this._fragmentShaderId, false);
            this._shapesProgram = beachParty.glUtils.buildProgram(gl, [vertexShader, fragmentShader]);
            //---- GRID LINES program ----
            var vertexShader = beachParty.glUtils.findAndCompileShader(gl, "gridLinesVertexShader.c", true);
            var fragmentShader = beachParty.glUtils.findAndCompileShader(gl, "gridLinesFragmentShader.c", false);
            this._gridLinesProgram = beachParty.glUtils.buildProgram(gl, [vertexShader, fragmentShader]);
            //---- make SHAPES the current program ----
            gl.useProgram(this._shapesProgram);
        };
        ShapeEngClass.prototype.setShaders = function (fnVertex, fnFragment) {
            var shaderChanged = false;
            if (this._vertexShaderId != fnVertex || this._fragmentShaderId != fnFragment) {
                this._vertexShaderId = fnVertex;
                this._fragmentShaderId = fnFragment;
                shaderChanged = true;
            }
            return shaderChanged;
        };
        ShapeEngClass.prototype.drawToPng = function () {
            return null;
        };
        ShapeEngClass.prototype.setParams = function (dp) {
            this.processDrawParamChanges(dp);
            this.markBuildNeeded("params");
        };
        ShapeEngClass.prototype.getParams = function () {
            return this._drawParams;
        };
        ShapeEngClass.prototype.clearFromBuffers = function () {
            this._firstDraw = true;
            //this._bufferMgr.setFromBufferHasData(false);
            //this._bufferMgr = new bufferMgrClass(this._gl, this._glInst, this);
            //this.processDrawParamChanges();
        };
        ShapeEngClass.prototype.updateStats = function () {
            //---- update stats ----
            var now = vp.utils.now();
            this._frameCount++;
            this._renderCount++;
            var duration = now - this._lastFrameTime;
            if (duration > 1000) {
                var frameCount = this._frameCount;
                this._frameRate = Math.floor(frameCount * 1000 / duration);
                if (this._frameRate > 80) {
                    var a = 9999;
                }
                this._frameCount = 0;
                this._lastFrameTime = now;
                if (true) {
                    var perf = this._drawPerf;
                    var msg = "total=" + round(perf.total) + " ms, configDevice=" + round(perf.configDevice) + ", clear="
                        + round(perf.clear) + ", applyUniforms=" + round(perf.applyUniforms) + ", applyCount=" +
                        beachParty.glUniformClass.uniformSetCount + ", drawBuffers="
                        + round(perf.drawBuffers) + ", stats=" + round(perf.onFrame);
                    this._drawFrameStatsMsg = msg;
                    this.resetDrawPerf();
                }
            }
        };
        ShapeEngClass.prototype.startAnimationIfNeeded = function () {
            this.setTimerForNextFrame();
        };
        ShapeEngClass.prototype.moveFrame = function () {
            this._animTimer = null; // the timer that got us here is now expired
            var isReadyToBuild = (this._renderCount > 0 || this._shapeCount > 0);
            //vp.utils.debug("moveFrame: this._renderCount=" + this._renderCount + ", dataFrame=" + dataFrame +
            //    ", dataFrame.getRecordCount()=" + dataFrame.getRecordCount() + ", x..colName=" + xm.colName + 
            //    ", isReadyToBuild = " + isReadyToBuild);
            if (isReadyToBuild && this._newCycleNeeded) {
                if (this._drawParams.animPercentOverride !== undefined) {
                    vp.utils.debug("moveFrame: texture1=" + this._texture1 + ", texture2=" + this._texture2);
                }
                //---- CAUTION: using IE trace collection API (performance.mark, etc.) may cost PERF ----
                //---- do NOT enable these calls for released builds ----
                //performance.mark("beforeBuildChart");
                //this.buildChart();
                //performance.mark("afterBuildChart");
                //performance.measure("buildChartElapsed");
                //---- make visible after the first chart has been built ----
                this._canvas.style.opacity = "1";
                this._moveFrameCount++;
                ////---- hide canvas2d until animation is complete ----
                //vp.select(this._view.getContext2d())
                //    .css("opacity", ".4")
                //    .css("transition", "opacity .s ease- in -out")
                if (!this._omitAnimOnNextBuild) {
                    //---- start new ANIMATION CYCLE ("toPercent") ----
                    //---- note: this start the animation timing AFTER the chart has been built ----
                    this.onStartOfCycle();
                    this._newCycleNeeded = false;
                }
                this._omitAnimOnNextBuild = false;
            }
            if (this._isCycleActive) {
                this._cycleFrameCount++;
            }
            if (this._instantSizeChange) {
                //---- this gets captured at end of frame, not cycle, because it is set instantly ----
                this._sizeFactorLast = this._drawParams.sizeFactor;
            }
            //---- animation timing ----
            var toPercentOverride = this._drawParams.animPercentOverride;
            if (toPercentOverride !== undefined || this._isCycleActive) {
                this.calcAniPercent();
            }
            //if (this._enableBuildNeededMarkOnNextFrame)
            //{
            //    this._buildNeeded = true;
            //    this._enableBuildNeededMarkOnNextFrame = false;
            //}
            this.onMoveFrame.trigger({});
        };
        ShapeEngClass.prototype.onStartOfCycle = function () {
            vp.utils.debug("onStartOfCycle");
            this._lastFrameTime = vp.utils.now();
            this._bufferMgr.flipIsUsingPrimaryBuffers();
            this._isCycleActive = true;
            //---- set time for start of to/from animation ----
            this._toStartTime = vp.utils.now();
            //this._chartFrameHelper.fadeInOut(false);
            this.onCycleStart.trigger({ sender: this });
            this._cycleFrameCount = 0;
            this._animCycleCount++; //so that cycle number is avail early on
        };
        ShapeEngClass.prototype.calcAniPercent = function (forceMax) {
            var ad = this._drawParams.animationParams;
            //---- use milliseconds for all times here ----
            var aniDuration = 1000 * ad.animationDuration;
            var staggerDuration = 1000 * ad.maxStaggerTime;
            var maxPercent = (ad.isStaggeringEnabled) ? (aniDuration + staggerDuration) / aniDuration : 1;
            var now = vp.utils.now();
            var toPercent = maxPercent;
            var toPercentUneased = maxPercent;
            var elapsed = 0;
            if (ad.isAnimationEnabled && !forceMax) {
                elapsed = now - this._toStartTime;
                toPercent = Math.min(maxPercent, elapsed / aniDuration);
                toPercentUneased = toPercent;
                //---- apply easing ---- 
                if (ad.easeFunction) {
                    toPercent = this.easeInOut(toPercent, maxPercent);
                }
            }
            //vp.utils.debug("toPercentUneased=" + toPercentUneased);
            var toPercentOverride = this._drawParams.animPercentOverride;
            if (toPercentOverride !== undefined) {
                toPercentUneased = toPercentOverride * maxPercent;
                toPercent = toPercentUneased;
            }
            if ((toPercentUneased == maxPercent && this._isCycleActive) || (toPercentOverride !== undefined)) {
                ////---- cycle ended ----
                //this.onEndOfCycle(elapsed);
                //this._isDrawNeeded = true;      // we need one final draw
                this._isLastDrawOfCycle = true;
            }
            this._toPercentUnflipped = toPercentUneased;
            if (!this.isUsingPrimaryBuffers()) {
                //---- flip percent ----
                toPercent = maxPercent - toPercent;
                toPercentUneased = maxPercent - toPercentUneased;
            }
            this._toPercent = toPercent;
            this._toPercentUneased = toPercentUneased;
            this._maxPercent = maxPercent;
        };
        ShapeEngClass.prototype.easeInOut = function (t, maxPercent) {
            var ap = this._drawParams.animationParams;
            var easeFunc = this._easeFunction;
            var easeType = ap.easeType;
            //---- normalize t ----
            t /= maxPercent;
            var value = t;
            //---- divide into IN and OUT cases ----
            if ((t < .5) && (easeType != beachParty.EaseType.out)) {
                var coreValue = easeFunc(t * 2);
                value = coreValue * .5;
            }
            if ((t >= .5) && (easeType != beachParty.EaseType.in)) {
                var coreValue = easeFunc(2 * (1 - t));
                value = .5 + (1 - coreValue) * .5;
            }
            //---- unnormalize value ----
            value *= maxPercent;
            return value;
        };
        ShapeEngClass.prototype.requestAnimationFrame = function (callback) {
            var timer = window.requestAnimationFrame(callback);
            return timer;
        };
        ShapeEngClass.prototype.setTimerForNextFrame = function () {
            var _this = this;
            if (!this._animTimer && !this._isShuttingDown) {
                this._animTimer = this.requestAnimationFrame(function (e) {
                    if (!_this._isShuttingDown) {
                        _this.moveFrame();
                        //---- don't start drawing frames until first chart build has occured ----
                        if (_this._shapes && _this._shapes.length) {
                            _this.drawFrame();
                        }
                        else if (_this._buildNeeded) {
                            _this.startAnimationIfNeeded();
                        }
                    }
                });
            }
        };
        ShapeEngClass.prototype.updateTransformerFromDrawParmas = function () {
            this._transformer.cameraParams(this._drawParams.cameraParams);
        };
        ShapeEngClass.prototype.captureLastWorld = function () {
            var matWorld = this._transformer.world();
            //---- matWorld can be an array or a Float32Array, depending on if insight has been loaded ----
            if (vp.utils.isArray(matWorld)) {
                this._lastWorld = vp.utils.copyArray(matWorld);
            }
            else {
                this._lastWorld = new Float32Array(matWorld);
            }
            //vp.utils.debug("captureLastWorld: matWorld=" + matWorld.toString() + ", this._lastWorld=" + this._lastWorld.toString() +
            //    ", this._lastWorld[6]=" + this._lastWorld[6]);
        };
        ShapeEngClass.prototype.drawFrame = function () {
            var drawFrameStart = vp.utils.now();
            var dfStart = vp.utils.now();
            var dp = this._drawParams;
            this.updateStats();
            var toPercentOverride = dp.animPercentOverride;
            if (dp.useContinuousDrawing || this._isCycleActive || this._isUiOpActive || this._isSingleDrawNeeded || toPercentOverride !== undefined) {
                if (this._isSingleDrawNeeded) {
                    //---- increment this to keep track info correct ----
                    this._nextBuildId++;
                }
                this.drawFrameCore();
                if (this._isSingleDrawNeeded) {
                    this._isSingleDrawNeeded = false;
                    this.captureLastProperties();
                }
            }
            var start = vp.utils.now();
            //this.onDataChanged("drawFrame");
            this.onDrawFrame.trigger({ sender: this });
            this.addToDrawPerf("onFrame", start);
            this.addToDrawPerf("total", dfStart);
            if (this._isLastDrawOfCycle) {
                this._isLastDrawOfCycle = false;
                this.onEndOfCycle(vp.utils.now() - this._toStartTime);
            }
            //---- always set this, so we can keep accurate stats ----
            this.setTimerForNextFrame();
            var drawFrameElapsed = vp.utils.now() - drawFrameStart;
            this._drawPerf.drawFrameElapsed = drawFrameElapsed;
        };
        ShapeEngClass.prototype.captureLastProperties = function () {
            var dp = this._drawParams;
            this._isSmoothLast = dp.useContinuousColor;
            this._isChannelLast = dp.useColorChannels;
            this._opacityLast = dp.shapeOpacity;
            this._sizeFactorLast = dp.sizeFactor;
            this.captureLastWorld();
        };
        ShapeEngClass.prototype.redrawLastFrame = function () {
            this.updateTransformerFromDrawParmas();
            ////---- we change sizeFactor without animation, so user can use gauge to control it with immediate feedback ----
            this._isSingleDrawNeeded = true;
        };
        ShapeEngClass.prototype.markBuildNeeded = function (reason) {
            if (!this._buildNeeded) {
                this._buildNeeded = true;
            }
        };
        ShapeEngClass.prototype.onEndOfCycle = function (duration) {
            var dp = this._drawParams;
            this._needTextureSwap = false;
            this._isCycleActive = false;
            this._lastCycleFrameRate = Math.floor(this._cycleFrameCount * 1000 / duration);
            this._lastCycleFrameCount = this._cycleFrameCount;
            this.captureLastProperties();
            vp.utils.debug("onEndOfCycle: cycleFrameCount=" + this._cycleFrameCount +
                ", continuousDrawing=" + dp.useContinuousDrawing);
            beachParty.hitTestRect.markCacheBuildNeeded(this._transformer, this._boundingBoxMgr);
            var ss = new beachParty.ShapeStats();
            ss.shapeCount = this._shapeCount;
            ss.drawPrimitive = this._drawParams.drawPrimitive;
            ss.isInstancing = (this._glInst != null);
            ss.maxGlBufferLength = dp.maxGlBufferLength;
            ss.bufferMemUsage = this._bufferMgr.getArrayMemoryUsage();
            //ss.isFirstFilterStage = this._isFirstFilteredStage;
            //ss.maxScatterSizeInPixels = this._drawParams.defaultShapeSize;
            ss.totalVertexCount = this.getTotalVertexCount();
            ss.lastCycleFrameCount = this._lastCycleFrameCount;
            ss.lastCycleFrameRate = this._lastCycleFrameRate;
            ss.cycleNum = this._animCycleCount;
            ss.drawBatchCount = this._drawInfos.length;
            ss.glBufferTime = this._buildPerf.glBufferFill;
            ss.glDrawTime = this._drawPerf.drawFrameElapsed;
            this.onCycleEnd.trigger(ss);
        };
        ShapeEngClass.prototype.startNewFrame = function () {
            //var windowMgr = this._opts._windowMgr;
            var gl = this._gl;
            var start = vp.utils.now();
            var startGlFill = vp.utils.now();
            var buildId = this._nextBuildId - 1;
            //addTrace("drawFrame", this._currentChart, TraceEventType.start, "f" + buildId + "-" + this._frameCount);
            //vp.utils.debug("drawFrameCore: frameCount=" + this._frameCount);
            //---- apply various params that may have changed ----
            var dp = this._drawParams;
            beachParty.glUtils.configDevice(gl, dp.canvasWidth, dp.canvasHeight, this._clearColor, this._isBlendingEnabled, this._isCullingEnabled);
            start = this.addToDrawPerf("configDevice", start);
            //---- clear buffers ----
            gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
            return start;
        };
        ShapeEngClass.prototype.drawFrameCore = function () {
            var start = this.startNewFrame();
            start = this.addToDrawPerf("clear", start);
            this.applyUniformsToShaders();
            var startDraw = vp.utils.now();
            start = this.addToDrawPerf("applyUniforms", start);
            //if (!this._usingPointCubes)
            {
                //---- set triangleIndex ----
                this._uniforms.triangleIndex.setValue(0);
            }
            //performance.mark("startDrawBuffers");
            this.drawAllBuffers();
            //performance.mark("endDrawBuffers");
            //performance.measure("drawBuffersElapsed", "startDrawBuffers", "endDrawBuffers");
            this._drawFrameCount++;
            start = this.addToDrawPerf("drawBuffers", start);
            if (!this._isCycleActive) {
                if (this._transformer._transformChanged) {
                    beachParty.hitTestRect.markCacheBuildNeeded(this._transformer, this._boundingBoxMgr);
                    this._transformer._transformChanged = false;
                }
            }
            //this.onDataChanged("drawFrameCore");
            //addTrace("drawFrame", this._currentChart, TraceEventType.end, "f" + buildId + "-" + this._frameCount);
            this._drawPerf.drawBuffers = vp.utils.now() - startDraw;
        };
        ShapeEngClass.prototype.drawAllBuffers = function () {
            this.drawAllShapes();
            //---- known Chrome/Firefox bug workaround: mixing instanced and non-instanced drawing on same ctx ----
            //---- causes a drawing error here; so, we turn off 3D gridlines for these guys ----
            if (!this._glInst || vp.utils.isIE) {
            }
        };
        ShapeEngClass.prototype.drawAllShapes = function () {
            var gl = this._gl;
            var diCount = this._drawInfos.length;
            //---- draw shapes ----
            gl.useProgram(this._shapesProgram);
            var isWireframe = this._drawParams.useWireFrameDraw;
            var glInst = this._glInst;
            var geomType = null;
            if (this._drawParams.drawPrimitive == beachParty.DrawPrimitive.point) {
                geomType = gl.POINTS;
            }
            else if (isWireframe || this._drawParams.drawPrimitive == beachParty.DrawPrimitive.lineStrip) {
                geomType = gl.LINE_STRIP;
            }
            else if (this._drawParams.drawPrimitive == beachParty.DrawPrimitive.linePairs) {
                geomType = gl.LINES;
            }
            else {
                geomType = gl.TRIANGLES;
            }
            var verticesPerShape = this.getNumVerticesPerShape();
            for (var i = 0; i < diCount; i++) {
                var di = this._drawInfos[i];
                if (i == diCount - 1) {
                    this.doHoverDrawPrep();
                }
                if (di.instOffset >= 0) {
                    this._bufferMgr.bindBufferForDrawing(i);
                    if (glInst) {
                        glInst.drawArraysInstancedANGLE(geomType, 0, verticesPerShape, di.instCount);
                    }
                    else {
                        gl.drawArrays(geomType, 0, di.instCount * verticesPerShape);
                    }
                    var error = gl.getError();
                    if (error) {
                    }
                }
            }
        };
        ShapeEngClass.prototype.getGlContext = function () {
            return this._gl;
        };
        ShapeEngClass.prototype.getHoverIndex = function () {
            var hvi = -1;
            //---- draw hover shape on top ----
            var hp = this._drawParams.hoverParams;
            if (hp.hoverEffect != beachParty.HoverEffect.none) {
                var drawOnTop = false;
                var hpk = this._drawParams.hoverPrimaryKey;
                if (hpk !== null) {
                    hvi = this._pkToDrawIndex[hpk]; //  this.getVectorIndexByKey(hpk);
                }
            }
            return hvi;
        };
        ShapeEngClass.prototype.doHoverDrawPrep = function () {
            //---- update hoverIndex in drawInfos[] ----
            var hvi = this.getHoverIndex();
            if (hvi > -1) {
                //---- hover stuff ----
                var hp = this._drawParams.hoverParams;
                var hoverColor = hp.hoverColor;
                //var drawHover = false;
                if (!hoverColor || hoverColor == "none" || hp.hoverEffect == beachParty.HoverEffect.sameColor) {
                    hvi = -1;
                }
                else {
                    var cr3 = vp.color.getColorFromName(hoverColor);
                    var hRed = cr3[0] / 255;
                    var hGreen = cr3[1] / 255;
                    var hBlue = cr3[2] / 255;
                    this._uniforms.hoverColor.setValue(hRed, hGreen, hBlue);
                }
            }
            this._uniforms.hoverVectorIndex.setValue(hvi);
            //---- apply "hvi" to last drawInfos[] ----
            var diCount = this._drawInfos.length;
            var diLast = this._drawInfos[diCount - 1];
            diLast.instOffset = hvi;
            this._bufferMgr.bindBuffersToArrayData([diCount - 1]);
        };
        ShapeEngClass.prototype.applyUniformsToShaders = function () {
            beachParty.glUniformClass.uniformSetCount = 0;
            //---- local variables, for easy access ----
            var opts = this._drawParams;
            var dp = this._drawParams;
            var usingPrimary = this.isUsingPrimaryBuffers();
            //var drawPrim = this._drawPrimitive;
            //var changed = this._uniformsChanged;
            //vp.utils.debug("applyUniformsToShaders: usingPrimary=" + usingPrimary);
            //if (this._usingPointCubes)
            //{
            //    //---- for vertex shader ----
            //    this._uniforms.szCanvas.setValue(this._canvasWidth, this._canvasHeight);
            //    //---- for fragment shader ----
            //    this._uniforms.canvasSize.setValue(this._canvasWidth, this._canvasHeight);
            //    this._uniforms.ndcZ.setValue(this._transformer.getNdcZ());
            //    this._uniforms.cameraPos.setValue(this._transformer.getCameraPosAsArray());
            //    this._uniforms.invMvpMatrix.setValue(this._transformer.getInvMvpMatrix());
            //    this._uniforms.invWorldMatrix.setValue(this._transformer.getInvWorldpMatrix());
            //}
            if (true) {
                //---- toPercent ----
                this._uniforms.toPercent.setValue(this._toPercent);
                this._uniforms.toPercentUneased.setValue(this._toPercentUneased);
            }
            if (true) {
                //---- toPercentTheta ----
                var toPercentTheta = this._toPercent;
                var isPrevLine = (this._lastDrawParams && this._lastDrawParams.areShapesLines);
                var isCurrLine = (this._drawParams.areShapesLines);
                if (isPrevLine) {
                    if (!isCurrLine) {
                        //---- LINE to NON-LINE ----
                        toPercentTheta = (usingPrimary) ? 0 : 1;
                    }
                }
                else {
                    if (isCurrLine) {
                        //---- NON-LINE to LINE ----
                        toPercentTheta = (usingPrimary) ? 1 : 0;
                    }
                }
                this._uniforms.toPercentTheta.setValue(toPercentTheta);
            }
            if (true) {
                //---- color palette ----
                this._uniforms.colorPalette.setValue(this._colorFloats);
                this._uniforms.colorPalette2.setValue(this._colorFloats2);
                this._uniforms.maxColors.setValue(this._maxColors);
                this._uniforms.maxColors2.setValue(this._maxColors2);
            }
            if (true) {
                //---- texture stuff ----
                //---- normalize toFrag ----
                var toFrag = this._toPercent / this._maxPercent;
                var tc1 = this._textureCount1;
                var tc2 = this._textureCount2;
                var isTextureEnabled = this._drawParams.useTextures;
                var ut1 = (this._texture1 != null && isTextureEnabled) ? 1 : 0;
                var ut2 = (this._texture2 != null && isTextureEnabled) ? 1 : 0;
                //---- these do NOT need to be swapped ----
                this._uniforms.toPercentFrag.setValue(toFrag);
                //vp.utils.debug("toFrag=" + toFrag);
                this._uniforms.usingTexture1.setValue(ut1);
                this._uniforms.usingTexture2.setValue(ut2);
                this._uniforms.textureCount1.setValue(tc1);
                this._uniforms.textureCount2.setValue(tc2);
            }
            if (true) {
                var opacity = dp.shapeOpacity;
                var opacityLast = this._opacityLast;
                if (usingPrimary) {
                    var temp = opacity;
                    opacity = opacityLast;
                    opacityLast = temp;
                }
                this._uniforms.globalOpacity.setValue(opacity);
                this._uniforms.globalOpacity2.setValue(opacityLast);
            }
            if (true) {
                //var cm = this._opts.colorMapping();
                var isSmooth = dp.useContinuousColor; //  opts.colorMapping().isContinuous;
                var isSmoothLast = this._isSmoothLast;
                var isChannel = dp.useColorChannels; //  (cm.channelMapping != null);
                var isChannelLast = this._isChannelLast;
                if (usingPrimary) {
                    var temp2 = isSmooth;
                    isSmooth = isSmoothLast;
                    isSmoothLast = temp2;
                    var temp2 = isChannel;
                    isChannel = isChannelLast;
                    isChannelLast = temp2;
                }
                this._uniforms.isColorDiscrete.setValue(!isSmooth);
                this._uniforms.isColorDiscrete2.setValue(!isSmoothLast);
                this._uniforms.isColorDirect.setValue(isChannel);
                this._uniforms.isColorDirect2.setValue(isChannelLast);
            }
            if (true) {
                var sizeFactor = dp.sizeFactor; //  opts.userSizeFactor();
                var sizeFactorLast = this._sizeFactorLast;
                if (usingPrimary) {
                    var temp3 = sizeFactor;
                    sizeFactor = sizeFactorLast;
                    sizeFactorLast = temp3;
                }
                var ptFactor = 1;
                //---- for POINT drawing, we need to compute the size in PIXELS (vs. WORLD space) ----
                if (this._drawParams.drawPrimitive == beachParty.DrawPrimitive.point) {
                    ptFactor = this._transformer.worldSizeToScreen(ptFactor);
                }
                this._uniforms.sizeFactor.setValue(ptFactor * sizeFactor);
                this._uniforms.sizeFactor2.setValue(ptFactor * sizeFactorLast);
            }
            //if (this._cycleIsActive)
            //{
            //    vp.utils.debug("opacity=" + opacity + ", opacityLast=" + opacityLast + ", _toPercentUneased=" + this._toPercentUneased);
            //}
            //if (!this._usingPointCubes)       // changed.lighting)
            {
                var lightParams = opts.lightParams; //  <Lighting>opts.lightingParams();
                //---- ambientFactor ----
                this._uniforms.ambientFactor.setValue(lightParams.ambientLight.lightFactor);
                //---- lights ----
                this._uniforms.lightFactor1.setValue(lightParams.light1.lightFactor);
                //this._uniforms.lightFactor2.setValue(lightParams.light2.lightFactor);
                this._uniforms.lightingEnabled.setValue(lightParams.isLightingEnabled);
            }
            if (true) {
                //---- projection ----
                var matProjection = this._transformer.getProjection(); //.toFloat32Array();
                this._uniforms.projectionMatrix.setValue(matProjection);
                //---- viewMatrix ----
                var matView = this._transformer.getView();
                //this._uniforms.viewMatrix.setValue(matView);        //.toFloat32Array());
                //---- modelViewMatrix ----
                var currWorld = this._transformer.world();
                var lastWorld = this._lastWorld;
                if (lastWorld != null) {
                    //---- LERP the world matrix ----
                    var truePercent = this._toPercent / this._maxPercent;
                    if (this.isUsingPrimaryBuffers()) {
                        var lerpWorld = this.lerpMatrix(truePercent, lastWorld, currWorld);
                    }
                    else {
                        var lerpWorld = this.lerpMatrix(truePercent, currWorld, lastWorld);
                    }
                }
                else {
                    var lerpWorld = currWorld;
                }
                //---- save for use by gridLine drawing ----
                this._lerpWorld = lerpWorld;
                var modelView = new Float32Array(16);
                mat4.multiply(modelView, matView, lerpWorld);
                this._uniforms.modelViewMatrix.setValue(modelView);
                var dpv = (this._drawParams.drawPrimitive == beachParty.DrawPrimitive.point || this._drawParams.drawPrimitive == beachParty.DrawPrimitive.linePairs) ? 1.0 : 0.0;
                this._uniforms.drawingPoints.setValue(dpv);
                var normalMatrix = null;
                normalMatrix = mat3.create();
                //---- this seems to work better for lighting ----
                mat3.fromMat4(normalMatrix, modelView);
                mat3.invert(normalMatrix, normalMatrix);
                mat3.transpose(normalMatrix, normalMatrix);
                this._uniforms.normalMatrix.setValue(normalMatrix);
            }
            //---- set this to -1 for the normal drawing ----
            this._uniforms.hoverVectorIndex.setValue(-1);
            //changed.reset();
        };
        /** "vectorIndex" is the index into the current set of sorted shapes.  It is NOT the unsorted natural record index. */
        ShapeEngClass.prototype.getShapeBoundingBox = function (primaryKey) {
            var bb = this._boundingBoxMgr.getBoxByKey(primaryKey);
            return bb;
        };
        ShapeEngClass.prototype.lerpMatrix = function (percent, fromMat, toMat) {
            var result = new Float32Array(fromMat.length);
            for (var i = 0; i < fromMat.length; i++) {
                var value = vp.data.lerp(percent, fromMat[i], toMat[i]);
                result[i] = value;
            }
            return result;
        };
        return ShapeEngClass;
    }());
    beachParty.ShapeEngClass = ShapeEngClass;
    function round(value) {
        return Math.round(value);
    }
    var BoundingBox = (function () {
        function BoundingBox() {
        }
        return BoundingBox;
    }());
    beachParty.BoundingBox = BoundingBox;
    /** world unit bounds. */
    var Bounds = (function () {
        function Bounds() {
        }
        return Bounds;
    }());
    beachParty.Bounds = Bounds;
    var DrawInfo = (function () {
        function DrawInfo(offset, count) {
            this.instOffset = offset;
            this.instCount = count;
        }
        return DrawInfo;
    }());
    beachParty.DrawInfo = DrawInfo;
    //---- these are the arrays we fill with the vertex data ----
    //---- these arrays are later used to populate the GL buffers for the GPU ----
    var NamedBuffers = (function () {
        function NamedBuffers() {
        }
        return NamedBuffers;
    }());
    beachParty.NamedBuffers = NamedBuffers;
})(beachParty || (beachParty = {}));
//---- NOTE: this file should be directly in the project folder (NOT under "scripts") ----
//---- NOTE #2: this file does NOT need to be referenced by each *.ts file; it will be implicitly referenced by VS/TSC.
/// <reference path="scripts/vuePlotCore.d.ts" /> 
/// <reference path="scripts/thirdParty/gl-matrix.d.ts" /> 
//---- this list of TS files is needed to control the order the files in which the files and processed and loaded ----
/// <reference path="classes/shapeInterfaces.ts" /> 
/// <reference path="classes/dataChanger.ts" /> 
/// <reference path="classes/shapeEng.ts" />
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    boundingBoxMgr.ts - manages the set of bounding boxes as a set of arrays, for minimizing the memory usage.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// An array of BoundingBox class objects requires 156 bytes per object in IE11.  By breaking up data into 
    /// Float32Arrays, we can reduce object size to 44 bytes per object.
    /// Note: this class holds data for EACH RECORD in the current dataset (independent of the filter setting).
    var boundingBoxMgrClass = (function () {
        function boundingBoxMgrClass() {
            this._nextIndex = 0;
            //---- arrays are allocated in adjustSizeAndClearList below. ----
        }
        /**
         *  Allocate Float32Arrays for our properties.
         */
        boundingBoxMgrClass.prototype.adjustSizeAndClearList = function (count) {
            //---- clear boxes for each animation cycle so that we don't end up with entries for FILTERED-OUT shapes ----
            if (true) {
                this._mins = new Float32Array(3 * count);
                this._maxes = new Float32Array(3 * count);
                this._thetas = new Float32Array(count);
                this._distances = new Float32Array(count);
                this._primaryKeys = [];
            }
            this._nextIndex = 0;
        };
        boundingBoxMgrClass.prototype.addBox = function (xMin, yMin, zMin, xMax, yMax, zMax, theta, primaryKey, dist) {
            var index = this._nextIndex++;
            var index3 = index * 3;
            this._mins[index3 + 0] = xMin;
            this._mins[index3 + 1] = yMin;
            this._mins[index3 + 2] = zMin;
            this._maxes[index3 + 0] = xMax;
            this._maxes[index3 + 1] = yMax;
            this._maxes[index3 + 2] = zMax;
            this._thetas[index] = theta;
            this._distances[index] = dist;
            this._primaryKeys[index] = primaryKey;
        };
        boundingBoxMgrClass.prototype.getBoxByKey = function (primaryKey) {
            var index = this._primaryKeys.indexOf(primaryKey);
            var box = null;
            if (index > -1) {
                box = new beachParty.BoundingBox();
                var index3 = index * 3;
                box.xMin = this._mins[index3 + 0];
                box.yMin = this._mins[index3 + 1];
                box.zMin = this._mins[index3 + 2];
                box.xMax = this._maxes[index3 + 0];
                box.yMax = this._maxes[index3 + 1];
                box.zMax = this._maxes[index3 + 2];
                box.theta = this._thetas[index];
                box.dist = this._distances[index];
                box.primaryKey = this._primaryKeys[index];
            }
            return box;
        };
        /** warning - this is a boundBox index only, not the vectorIndex associated with all shapes in draw buffers. */
        boundingBoxMgrClass.prototype.getBoxByIndex = function (boxIndex) {
            var box = new beachParty.BoundingBox();
            var index3 = boxIndex * 3;
            box.xMin = this._mins[index3 + 0];
            box.yMin = this._mins[index3 + 1];
            box.zMin = this._mins[index3 + 2];
            box.xMax = this._maxes[index3 + 0];
            box.yMax = this._maxes[index3 + 1];
            box.zMax = this._maxes[index3 + 2];
            box.theta = this._thetas[boxIndex];
            box.dist = this._distances[boxIndex];
            box.primaryKey = this._primaryKeys[boxIndex];
            return box;
        };
        boundingBoxMgrClass.prototype.getCount = function () {
            var len = (this._primaryKeys) ? this._primaryKeys.length : 0;
            return len;
        };
        return boundingBoxMgrClass;
    }());
    beachParty.boundingBoxMgrClass = boundingBoxMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    bpEvent.ts - lightweight explict event class.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    //---- new experimental class for strongly typed but lightweight events ----
    var bpEvent = (function () {
        function bpEvent() {
            this._hookers = [];
        }
        bpEvent.prototype.attach = function (callerId, callback) {
            var hooker = new hookerClass(callerId, callback);
            this._hookers.push(hooker);
        };
        bpEvent.prototype.detach = function (callerId) {
            var hookers = this._hookers;
            for (var i = 0; i < hookers.length; i++) {
                if (hookers[i]._callId = callerId) {
                    hookers.removeAt(i);
                    break;
                }
            }
        };
        /**
         *  calls all of the callbacks attached to this event.
         * @param e: a map that includes "sender" (the class instance that originated the event) and other parameters.
         */
        bpEvent.prototype.trigger = function (e) {
            var hookers = this._hookers;
            for (var i = 0; i < hookers.length; i++) {
                var hooker = hookers[i];
                var callback = hooker._callback;
                callback(e);
            }
        };
        return bpEvent;
    }());
    beachParty.bpEvent = bpEvent;
    var hookerClass = (function () {
        function hookerClass(callerId, callback) {
            this._callId = callerId;
            this._callback = callback;
        }
        return hookerClass;
    }());
    beachParty.hookerClass = hookerClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    bufferMgr - manages the attributes and gl buffers for a chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// Note: the actual arrays and buffers used here are held (owned) by each attribute. 
    ///
    /// This class manages the "from" and "to" buffers for our set of 15 attributes. Various operations on the underlying data
    /// require this class to manipulate the current "from" buffer (recording records, converting from N to M vertices per record, etc.).
    var bufferMgrClass = (function (_super) {
        __extends(bufferMgrClass, _super);
        function bufferMgrClass(gl, glInst, baseGlVis) {
            _super.call(this);
            //---- buffers are the arrays attached to each glAttribute ----
            this._glAttributes = null;
            this._usingPrimaryBuffers = true;
            this._fromBuffersHaveData = false;
            this._arrayMemoryBytesInUse = 0;
            this._gl = gl;
            this._glInst = glInst;
            //this._dataMgr = dataMgr;
            this._shapeEng = baseGlVis;
        }
        bufferMgrClass.prototype.getArrayMemoryUsage = function () {
            return this._arrayMemoryBytesInUse;
        };
        bufferMgrClass.prototype.createGlAttributes = function (program, force) {
            if (force || !this._glAttributes) {
                var gl = this._gl;
                var glInst = this._glInst;
                var attrs = {};
                this._glAttributes = attrs;
                //---- 15 attributes, 27 floats per vertex ----
                //---- for each of these attributes, we have a "from" and "to" buffer ----
                beachParty.glUtils.addAttribute(attrs, gl, glInst, program, "xyz", 3);
                beachParty.glUtils.addAttribute(attrs, gl, glInst, program, "xyz2", 3);
                beachParty.glUtils.addAttribute(attrs, gl, glInst, program, "size", 3);
                beachParty.glUtils.addAttribute(attrs, gl, glInst, program, "size2", 3);
                //---- color channel mapping ----
                beachParty.glUtils.addAttribute(attrs, gl, glInst, program, "rgbBuff", 3, true, true);
                beachParty.glUtils.addAttribute(attrs, gl, glInst, program, "rgbBuff2", 3, true, true);
                //---- color palette mapping ----
                beachParty.glUtils.addAttribute(attrs, gl, glInst, program, "colorIndex", 1, false, false);
                beachParty.glUtils.addAttribute(attrs, gl, glInst, program, "colorIndex2", 1, false, false);
                //---- image mapping ----
                beachParty.glUtils.addAttribute(attrs, gl, glInst, program, "imageIndex", 1, true, false);
                beachParty.glUtils.addAttribute(attrs, gl, glInst, program, "imageIndex2", 1, true, false);
                //---- line rotation ----
                beachParty.glUtils.addAttribute(attrs, gl, glInst, program, "theta", 1);
                beachParty.glUtils.addAttribute(attrs, gl, glInst, program, "theta2", 1);
                //---- for these, we only have a single buffer ----
                beachParty.glUtils.addAttribute(attrs, gl, glInst, program, "vertexId", 1, true, false, false, true);
                beachParty.glUtils.addAttribute(attrs, gl, glInst, program, "staggerOffset", 1);
                beachParty.glUtils.addAttribute(attrs, gl, glInst, program, "vectorIndex", 1);
            }
        };
        bufferMgrClass.prototype.createAttributeArraysIfNeeded = function (forceNewArrays, forceVisualBreak) {
            if (forceNewArrays || (this._glAttributes && !this._glAttributes.xyz._array)) {
                this.createAttributeArrays(forceVisualBreak);
            }
        };
        /** "forceVisualBreak" should be set to true when a new dataFrame has been loaded, so that we do NOT visually connect the from/to plots.
        Also, the number of records may have changed, which would invalid the visuals anyway. */
        bufferMgrClass.prototype.createAttributeArrays = function (forceVisualBreak) {
            var vertexCount = this._shapeEng.getTotalVertexCount();
            var totalSpace = 0;
            //---- save the FROM vertex data so we can do correct animation (even though the drawingPrimitive is changing) ----
            if (!forceVisualBreak) {
                var tempBuffers = this.copyVertexDataToTemp();
            }
            if (vertexCount > 0) {
                var attrs = this._glAttributes;
                totalSpace = this.createAttributeArraysCore(attrs, vertexCount);
            }
            this._arrayMemoryBytesInUse = totalSpace;
            this._fromBuffersHaveData = false;
            if (tempBuffers) {
                //---- apply temp vertex data to FROM buffers ----
                this.copyTempToFromBuffers(tempBuffers);
                //---- don't reorder, since we built the fromBuffer with the correct order ----
                this._fromBuffersHaveData = false;
            }
            this._shapeEng.setLastVerticesPerRecord();
        };
        bufferMgrClass.prototype.createAttributeArraysCore = function (attrs, totalVertexCount, arrayMap) {
            var keys = vp.utils.keys(attrs);
            var totalSpace = 0;
            var recordCount = this._shapeEng.getShapeCount();
            //vp.utils.debug("--> createAttributeBuffers: recordCount=" + recordCount +
            //    ", totalVertexCount=" + totalVertexCount);
            for (var i = 0; i < keys.length; i++) {
                var name = keys[i];
                var attr = attrs[name];
                if (attr._attrLoc != -1) {
                    var myVertexCount = totalVertexCount;
                    if (name == "vertexId" && this._glInst) {
                        //---- only need one copy of the vertex ids - it will be shared with each instance ----
                        myVertexCount = this._shapeEng.getNumVerticesPerShape();
                    }
                    var numberCount = myVertexCount * attr._sizeInFloats;
                    var array = null;
                    if (attr._isByte) {
                        array = new Int8Array(numberCount);
                        var space = 1 * numberCount;
                    }
                    else {
                        array = new Float32Array(numberCount);
                        var space = 4 * numberCount;
                    }
                    if (arrayMap) {
                        var arrayName = name.substr(0, name.length - 4) + "Array"; // remove last 4 chars
                        arrayMap[arrayName] = array;
                    }
                    else {
                        attr.setArray(array);
                    }
                    //vp.utils.debug("createAttributeBuffers: name=" + name + ", space=" + space);
                    totalSpace += space;
                }
            }
            return totalSpace;
        };
        //dumpVertexBuffers(name: string, verticesPerRecord: number, buffers: NamedBuffers)
        //{
        //    vp.utils.debug("---> dump of: " + name);
        //    for (var i = 0; i < 5; i++)
        //    {
        //        var inx = i * 3 * verticesPerRecord;
        //        var x = buffers.xyzArray[inx + 0];
        //        var y = buffers.xyzArray[inx + 1];
        //        var z = buffers.xyzArray[inx + 2];
        //        vp.utils.debug("  x=" + x + ", y=" + y + ", z=" + z);
        //    }
        //}
        /** make a (single vertex per record) copy of the latest (from/to) vertex data.  */
        bufferMgrClass.prototype.copyVertexDataToTemp = function () {
            var fromVerticesPerRecord = this._shapeEng.getLastVerticesPerRecord();
            var tempBuffers = null;
            if (fromVerticesPerRecord !== null) {
                var usePrimBuff = (!this._usingPrimaryBuffers);
                vp.utils.debug("copyVertexDataToTemp: getting FROM data with usePrimBuff=" + usePrimBuff);
                var attributes = this.getAttributesForCycle(usePrimBuff);
                var fromBuffers = this.getNamedBuffers(attributes);
                if (fromBuffers && fromBuffers.xyzArray) {
                    var drawIndexes = this.buildRecordToDrawIndexes();
                    var recordCount = fromBuffers.xyzArray.length / (3 * fromVerticesPerRecord);
                    //var dataFrame = this._dataMgr.getDataFrame();
                    //var primaryKey = dataFrame.getNumericVector(primaryKeyName);
                    var toVerticesPerRecord = 1;
                    //---- create toBuffers ----
                    tempBuffers = new beachParty.NamedBuffers();
                    this.createAttributeArraysCore(attributes, 1 * recordCount, tempBuffers);
                    var primaryKeys = this._shapeEng.getPrimaryKeys();
                    this.copyVertexBuffers(fromBuffers, tempBuffers, primaryKeys, recordCount, fromVerticesPerRecord, toVerticesPerRecord, drawIndexes);
                }
            }
            return tempBuffers;
        };
        /** copy from temp (single vertex per record) to from buffers.  */
        bufferMgrClass.prototype.copyTempToFromBuffers = function (tempBuffers) {
            var fromVerticesPerRecord = 1;
            var toVerticesPerRecord = this._shapeEng.getNumVerticesInBuffer();
            var usePrimBuff = (!this._usingPrimaryBuffers);
            vp.utils.debug("copyTempToFromBuffers: getting FROM data with usePrimBuff=" + usePrimBuff);
            var attributes = this.getAttributesForCycle(usePrimBuff);
            var toBuffers = this.getNamedBuffers(attributes);
            var drawIndexes = this.buildRecordToDrawIndexes();
            var recordCount = toBuffers.xyzArray.length / (3 * toVerticesPerRecord);
            //var dataFrame = this._dataMgr.getDataFrame();
            //var primaryKey = dataFrame.getNumericVector(primaryKeyName);
            var primaryKeys = this._shapeEng.getPrimaryKeys();
            this.copyVertexBuffers(tempBuffers, toBuffers, primaryKeys, recordCount, fromVerticesPerRecord, toVerticesPerRecord, drawIndexes);
            this.setArraysFromNamedBuffers(attributes, toBuffers);
            //this.dumpVertexBuffers("toBuffers", toVerticesPerRecord, toBuffers);
        };
        /** This rearranges the record values in the "from" buffer to match the current sort order. */
        bufferMgrClass.prototype.reorderFromBuffer = function (fromAttrs, fb, recordCount, verticesPerRecord) {
            //---- the idea is to reorder the entries in fromBuff - to do this, we move entries from fromBuff ----
            //---- to toBuff, and then copy it back to fromBuff when completed.  ----
            var toAttrs = this.getAttributesForCycle(this._usingPrimaryBuffers);
            var tb = this.getNamedBuffers(toAttrs);
            //var isFromPrimary = (fromAttrs.xyzAttr == this._glAttributes.xyz);
            //if (isFromPrimary)
            //{
            //    vp.utils.debug("reorderFromBuffer: moving " + recordCount + " items from PRIMARY to SECONDARY");
            //}
            //else
            //{
            //    vp.utils.debug("reorderFromBuffer: moving " + recordCount + " items from SECONDARY to PRIMARY");
            //}
            var drawIndexes = this.buildRecordToDrawIndexes();
            var primaryKeys = this._shapeEng.getPrimaryKeys();
            this.copyVertexBuffers(fb, tb, primaryKeys, recordCount, verticesPerRecord, verticesPerRecord, drawIndexes);
            //---- now copy data back, in correct order, from TB to FB ----
            this.arrayCopy(tb.xyzArray, fb.xyzArray);
            this.arrayCopy(tb.sizeArray, fb.sizeArray);
            this.arrayCopy(tb.rgbArray, fb.rgbArray);
            this.arrayCopy(tb.colorArray, fb.colorArray);
            this.arrayCopy(tb.imageIndexArray, fb.imageIndexArray);
            this.arrayCopy(tb.staggerOffsetArray, fb.staggerOffsetArray);
            if (fb.thetaArray) {
                this.arrayCopy(tb.thetaArray, fb.thetaArray);
            }
            if (fb.vertexIdArray) {
                this.arrayCopy(tb.vertexIdArray, fb.vertexIdArray);
            }
            if (fb.vectorIndexArray) {
                this.arrayCopy(tb.vectorIndexArray, fb.vectorIndexArray);
            }
        };
        /** copies 1 multiple of vertex data from "fb" to verticesPerRecord multiples at "tb" */
        bufferMgrClass.prototype.copyVertexBuffers = function (fb, tb, primaryKeys, recordCount, fromVerticesPerRecord, toVerticesPerRecord, drawIndexes) {
            //vp.utils.debug("copyVertexBuffers: called");
            for (var ri = 0; ri < recordCount; ri++) {
                var vi = (drawIndexes) ? drawIndexes[ri] : ri;
                var ti = toVerticesPerRecord * vi; // to index
                var ti3 = 3 * ti; // to index for xyz and size
                var key = primaryKeys[ri]; // primaryKey.getRawData(ri) + "";
                var fromVi = this._shapeEng.getPkToDrawIndex(key);
                var fi = fromVerticesPerRecord * fromVi; // from index
                var fi3 = 3 * fi; // from index for xyz and size
                //if (vi < 4)
                //{
                //    vp.utils.debug("reorderFromBuffer: vi=" + vi + ", key=" + key + ", fromVi=" + fromVi);
                //}
                for (var j = 0; j < toVerticesPerRecord; j++) {
                    tb.xyzArray[ti3] = fb.xyzArray[fi3];
                    tb.xyzArray[ti3 + 1] = fb.xyzArray[fi3 + 1];
                    tb.xyzArray[ti3 + 2] = fb.xyzArray[fi3 + 2];
                    tb.sizeArray[ti3] = fb.sizeArray[fi3];
                    tb.sizeArray[ti3 + 1] = fb.sizeArray[fi3 + 1];
                    tb.sizeArray[ti3 + 2] = fb.sizeArray[fi3 + 2];
                    tb.rgbArray[ti3] = fb.rgbArray[fi3];
                    tb.rgbArray[ti3 + 1] = fb.rgbArray[fi3 + 1];
                    tb.rgbArray[ti3 + 2] = fb.rgbArray[fi3 + 2];
                    tb.colorArray[ti] = fb.colorArray[fi];
                    tb.imageIndexArray[ti] = fb.imageIndexArray[fi];
                    tb.staggerOffsetArray[ti] = fb.staggerOffsetArray[fi];
                    if (fb.thetaArray) {
                        tb.thetaArray[ti] = fb.thetaArray[fi];
                    }
                    if (fb.vertexIdArray) {
                        tb.vertexIdArray[ti] = fb.vertexIdArray[fi];
                    }
                    if (fb.vectorIndexArray) {
                        tb.vectorIndexArray[ti] = fb.vectorIndexArray[fi];
                    }
                    ti3 += 3;
                    ti++;
                }
            }
        };
        /** copy a Float32Array or other array type. */
        bufferMgrClass.prototype.arrayCopy = function (fb, tb) {
            for (var i = 0; i < fb.length; i++) {
                tb[i] = fb[i];
            }
        };
        bufferMgrClass.prototype.getAttributesForCycle = function (usingPrimaryBuffers) {
            var attr = {};
            attr.vertexIdAttr = this._glAttributes.vertexId;
            attr.staggerOffsetAttr = this._glAttributes.staggerOffset;
            attr.vectorIndexAttr = this._glAttributes.vectorIndex;
            if (usingPrimaryBuffers) {
                attr.xyzAttr = this._glAttributes.xyz;
                attr.sizeAttr = this._glAttributes.size;
                attr.rgbAttr = this._glAttributes.rgbBuff;
                attr.colorAttr = this._glAttributes.colorIndex;
                attr.imageIndexAttr = this._glAttributes.imageIndex;
                attr.thetaAttr = this._glAttributes.theta;
            }
            else {
                attr.xyzAttr = this._glAttributes.xyz2;
                attr.sizeAttr = this._glAttributes.size2;
                attr.rgbAttr = this._glAttributes.rgbBuff2;
                attr.colorAttr = this._glAttributes.colorIndex2;
                attr.imageIndexAttr = this._glAttributes.imageIndex2;
                attr.thetaAttr = this._glAttributes.theta2;
            }
            return attr;
        };
        bufferMgrClass.prototype.getNamedBuffers = function (attributes) {
            var buffers = new beachParty.NamedBuffers();
            buffers.xyzArray = attributes.xyzAttr._array;
            buffers.sizeArray = attributes.sizeAttr._array;
            buffers.rgbArray = attributes.rgbAttr._array;
            buffers.colorArray = attributes.colorAttr._array;
            buffers.imageIndexArray = attributes.imageIndexAttr._array;
            buffers.thetaArray = attributes.thetaAttr._array;
            buffers.staggerOffsetArray = attributes.staggerOffsetAttr._array;
            buffers.vertexIdArray = attributes.vertexIdAttr._array;
            buffers.vectorIndexArray = attributes.vectorIndexAttr._array;
            return buffers;
        };
        bufferMgrClass.prototype.setArraysFromNamedBuffers = function (attributes, buffers) {
            attributes.xyzAttr.setArray(buffers.xyzArray);
            attributes.sizeAttr.setArray(buffers.sizeArray);
            attributes.rgbAttr.setArray(buffers.rgbArray);
            attributes.colorAttr.setArray(buffers.colorArray);
            attributes.imageIndexAttr.setArray(buffers.imageIndexArray);
            attributes.thetaAttr.setArray(buffers.thetaArray);
            if (attributes.staggerOffsetAttr) {
                attributes.staggerOffsetAttr.setArray(buffers.staggerOffsetArray);
            }
            if (attributes.vertexIdAttr) {
                attributes.vertexIdAttr.setArray(buffers.vertexIdArray);
            }
            if (attributes.vectorIndexAttr) {
                attributes.vectorIndexAttr.setArray(buffers.vectorIndexArray);
            }
        };
        bufferMgrClass.prototype.flipIsUsingPrimaryBuffers = function () {
            this._usingPrimaryBuffers = (!this._usingPrimaryBuffers);
        };
        bufferMgrClass.prototype.glInst = function (value) {
            if (arguments.length == 0) {
                return this._glInst;
            }
            if (value != this._glInst) {
                this._glInst = value;
                this.onDataChanged("glInst");
                this.updateAttributesWithGlInst();
            }
        };
        bufferMgrClass.prototype.updateAttributesWithGlInst = function () {
            if (this._glAttributes) {
                var keys = vp.utils.keys(this._glAttributes);
                var glInst = this._glInst;
                for (var i = 0; i < keys.length; i++) {
                    var name = keys[i];
                    var attr = this._glAttributes[name];
                    attr.glInst(glInst);
                }
            }
        };
        bufferMgrClass.prototype.allocateBuffers = function (drawInfos) {
            this._drawInfos = drawInfos;
            var keys = vp.utils.keys(this._glAttributes);
            for (var i = 0; i < keys.length; i++) {
                var name = keys[i];
                var attr = this._glAttributes[name];
                attr.allocateBuffersForAttr(drawInfos);
            }
        };
        bufferMgrClass.prototype.bindBuffersToArrayData = function (drawIndexes) {
            var keys = vp.utils.keys(this._glAttributes);
            var verticesInBuffer = this._shapeEng.getNumVerticesInBuffer();
            for (var i = 0; i < keys.length; i++) {
                var name = keys[i];
                var attr = this._glAttributes[name];
                attr.bindBuffersToArrayData(drawIndexes, verticesInBuffer);
            }
        };
        bufferMgrClass.prototype.bindBufferForDrawing = function (drawInfoIndex) {
            var keys = vp.utils.keys(this._glAttributes);
            for (var i = 0; i < keys.length; i++) {
                var name = keys[i];
                var attr = this._glAttributes[name];
                attr.bindBufferForDrawing(drawInfoIndex);
            }
        };
        bufferMgrClass.prototype.rebindBuffersAfterProgramSwitch = function () {
            //this._glAttributes.xyz.rebindBuffer();
        };
        bufferMgrClass.prototype.reorderFromBuffers = function (verticesPerRecord) {
            var result = null;
            if (this._fromBuffersHaveData) {
                var fromAttributes = this.getAttributesForCycle(!this._usingPrimaryBuffers);
                var fromBuffers = this.getNamedBuffers(fromAttributes);
                this.reorderFromBuffer(fromAttributes, fromBuffers, this._shapeEng.getShapeCount(), verticesPerRecord);
                result = { attributes: fromAttributes, buffers: fromBuffers };
            }
            return result;
        };
        bufferMgrClass.prototype.setFromBufferHasData = function (value) {
            this._fromBuffersHaveData = value;
        };
        bufferMgrClass.prototype.getUsingPrimaryBuffers = function () {
            return this._usingPrimaryBuffers;
        };
        bufferMgrClass.prototype.buildRecordToDrawIndexes = function () {
            var drawIndexes = null;
            var facetBins = this._shapeEng.getFacetBins();
            if (facetBins) {
                var nextDrawIndex = 0;
                drawIndexes = [];
                for (var b = 0; b < facetBins.length; b++) {
                    var bin = facetBins[b];
                    for (var i = 0; i < bin.rowIndexes.length; i++) {
                        var recordIndex = bin.rowIndexes[i];
                        drawIndexes[recordIndex] = nextDrawIndex++;
                    }
                }
            }
            return drawIndexes;
        };
        bufferMgrClass.prototype.fillBuffersForRecord = function (buffers, dr, facetOffset, verticesPerRecord, primaryKey, vectorIndex, facetRelativeIndex) {
            var innerLoopCount = 0;
            var staggerOffset = 0;
            //---- find next spot for vertices, based on vectorIndex (keep primary/secondary buffers in sync, in spite of sorting ----
            //---- that is, the GL buffers are always in natural (vectorIndex) order. ----
            var next1 = verticesPerRecord * vectorIndex;
            //if (vectorIndex < 4)
            //{
            //    var isFillingPrimary = (buffers.xyzArray == this._glAttributes.xyz._array);
            //    vp.utils.debug("fillBuffersForRecord: fillingPrimary=" + isFillingPrimary +
            //        ", vectorIndex=" + vectorIndex + ", primaryKey=" + primaryKey + ", next1=" + next1);
            //}
            var next3 = 3 * next1;
            if (vectorIndex == 0) {
                //---- this code is NECESSARY to enable JIT-ing (make a DOM API call) ----
                this._shapeEng.forceDomApiCall();
            }
            for (var j = 0; j < verticesPerRecord; j++) {
                buffers.xyzArray[next3] = dr.x;
                buffers.sizeArray[next3] = dr.width;
                buffers.rgbArray[next3] = dr.redChannel;
                next3++;
                buffers.xyzArray[next3] = dr.y;
                buffers.sizeArray[next3] = dr.height;
                buffers.rgbArray[next3] = dr.greenChannel;
                next3++;
                buffers.xyzArray[next3] = dr.z;
                buffers.sizeArray[next3] = dr.depth;
                buffers.rgbArray[next3] = dr.blueChannel;
                next3++;
                buffers.colorArray[next1] = dr.colorIndex;
                if (buffers.imageIndexArray) {
                    buffers.imageIndexArray[next1] = dr.imageIndex;
                }
                if (buffers.staggerOffsetArray) {
                    buffers.staggerOffsetArray[next1] = dr.staggerOffset;
                }
                if (buffers.thetaArray) {
                    buffers.thetaArray[next1] = dr.theta;
                }
                if (buffers.vectorIndexArray) {
                    buffers.vectorIndexArray[next1] = vectorIndex;
                }
                //---- special handling for vertexId ----
                if (buffers.vertexIdArray && !this._glInst) {
                    //---- if glInst is off, do the normal filling of vertexId's for each instance ----
                    buffers.vertexIdArray[next1] = j;
                }
                next1++;
                innerLoopCount++;
            }
            //---- special handling for vertexId ----
            if (buffers.vertexIdArray && this._glInst) {
                var shapeVertexCount = this._shapeEng.getNumVerticesPerShape();
                for (var j = 0; j < shapeVertexCount; j++) {
                    buffers.vertexIdArray[j] = j;
                }
            }
        };
        return bufferMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.bufferMgrClass = bufferMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    easeFuncs.ts - ease functions for animation.
//-------------------------------------------------------------------------------------
var utils;
(function (utils) {
    var EaseFunction = beachParty.EaseFunction;
    function quadratic(t) {
        return t * t;
    }
    function cubic(t) {
        return t * t * t;
    }
    function quartic(t) {
        return t * t * t * t;
    }
    function quintic(t) {
        return t * t * t * t * t;
    }
    function exponential(t) {
        var a = 3;
        return (Math.exp(a * t) - 1) / (Math.exp(a) - 1);
    }
    function sine(t) {
        return 1 - Math.sin(Math.PI * .5 * (1 - t));
    }
    function circle(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    function getEasingFunction(value) {
        var func = null;
        switch (value) {
            case EaseFunction.quadratic:
                func = quadratic;
                break;
            case EaseFunction.cubic:
                func = cubic;
                break;
            case EaseFunction.quartic:
                func = quartic;
                break;
            case EaseFunction.quintic:
                func = quintic;
                break;
            case EaseFunction.sine:
                func = sine;
                break;
            case EaseFunction.exponential:
                func = exponential;
                break;
            case EaseFunction.circle:
                func = circle;
                break;
        }
        return func;
    }
    utils.getEasingFunction = getEasingFunction;
})(utils || (utils = {}));
//----------------------------------------------------------------------
// shaders.ts - generated by buildShaderScript.bat 
//----------------------------------------------------------------------
var shaders = {};
function getTextFromFunc(func) {
    var str = func.toString().replace(/(^[^\n]*\n)|(\n\*\/\})/g, "");
    str = str.replace(/\\r\\n/g, "\r\n");
    str = str.substr(8); // remove junk at start
    str = str.substr(0, str.length - 4); // remove junk at end
    return str;
}
shaders.cubevertexshader = getTextFromFunc(function () {
    /*
    //-------------------------------------------------------------------------------------
    //  Copyright (c) 2015 - Microsoft Corporation.
    //   cubeVertexShader.c - an GLSL vertex shader for drawing non-POINT primitives in BeachParty.
    //-------------------------------------------------------------------------------------
    
    /// NOTE: "light direction" here should be specified as the light position, pointing towards the origin.
    const vec3 crLight = vec3(1.0, 1.0, 1.0);
    const vec3 dirLight = vec3(0, 0, 1);			// z=+1 point to negative z, where shapes are (camera is at (0, 0, 7))
    
    //const vec3 crLight2 = vec3(1.0, 1.0, 1.0);
    //const vec3 dirLight2 = vec3(0, -1, 0);			// from above
    
    //---- constants: set just once ----
    uniform vec3 cubeVertices[24];
    uniform vec3 cubeNormals[24];
    uniform vec2 cubeTexCoords[24];
    uniform float cubeTriangles[36];
    uniform mat4 projectionMatrix;
    
    //---- constants: set on every draw ----
    
    //---- IOS is limited to 128 4xfloat's for their vertex shader, so we reduce color palette size ----
    //---- when compiling the shader.  Effectively, that means that IOS can only use 1 color for selection ----
    
    uniform vec3 colorPalette[@cpSize];		// we replace @cpSize just before we compile this file
    uniform vec3 colorPalette2[@cpSize];
    uniform float isColorDiscrete;
    uniform float isColorDiscrete2;
    uniform float isColorDirect;
    uniform float isColorDirect2;
    uniform float maxColors;
    uniform float maxColors2;
    
    uniform mat3 normalMatrix;
    uniform mat4 modelViewMatrix;
    uniform float lightFactor1;
    uniform float lightFactor2;
    uniform float toPercent;
    uniform float toPercentTheta;
    uniform float toPercentUneased;
    uniform float ambientFactor;
    uniform float triangleIndex;
    uniform float sizeFactor;			// adjust incoming sizes to default sizedFactor=1
    uniform float sizeFactor2;		    // size change can be INSTANT or ANIMATED
    uniform float lightingEnabled;
    uniform float globalOpacity;
    uniform float globalOpacity2;
    uniform float textureCount1;
    uniform float textureCount2;
    uniform float drawingPoints;
    uniform float hoverVectorIndex;
    uniform vec3 hoverColor;
    uniform float canvasWidth;
    uniform float canvasHeight;
    
    //---- attribute buffers ----
    attribute vec3 xyz;
    attribute vec3 xyz2;
    attribute vec3 size;
    attribute vec3 size2;
    attribute float theta;
    attribute float theta2;
    
    //---- attribute buffers that expand bytes into floats ----
    attribute float colorIndex;
    attribute float colorIndex2;
    attribute float imageIndex;
    attribute float imageIndex2;
    attribute float vertexId;
    
    //---- opacity mapping currently not supported ----
    //attribute float opacity;
    //attribute float opacity2;
    
    attribute vec3 rgbBuff;
    attribute vec3 rgbBuff2;
    
    attribute float vectorIndex;
    attribute float staggerOffset;
    
    //---- output to fragment shader ----
    varying vec3 v_color;
    varying float v_opacity;
    varying highp vec2 v_texCoord1;
    varying highp vec2 v_texCoord2;
    //varying vec2 vPosition;
    //varying vec2 vSize;
    
    void main()
    {
        //---- stagger movement & color changes ----
        float toPercentStag = clamp(toPercent + staggerOffset, 0.0, 1.0);
        float toPercenUneasedStag = clamp(toPercentUneased + staggerOffset, 0.0, 1.0);
    
        //---- DISCRETE/CONTINUOUS COLOR PALETTE ----
        vec3 color;
        vec3 color2;
    
        if (isColorDirect == 1.0)
        {
            color = rgbBuff;
        }
        else
        {
            int ci = int(clamp(colorIndex, 0.0, maxColors));
            color = (isColorDiscrete == 1.0) ? (colorPalette[ci]) : (mix(colorPalette[ci], colorPalette[ci + 1], colorIndex - float(ci)));
        }
    
        if (isColorDirect2 == 1.0)
        {
            color2 = rgbBuff2;
        }
        else
        {
            int ci2 = int(clamp(colorIndex2, 0.0, maxColors2));
            color2 = (isColorDiscrete2 == 1.0) ? (colorPalette2[ci2]) : (mix(colorPalette2[ci2], colorPalette2[ci2 + 1], colorIndex2 - float(ci2)));
        }
        vec3 colorMixed = mix(color, color2, toPercenUneasedStag);
    
        //---- set VERTEX ID ----
        int vi = int(cubeTriangles[int(vertexId + 3.0*triangleIndex)]);
    
        //---- INTERPOLATE between from/to values for SIZE and XYZ ----
        vec3 szMixed = mix(size*sizeFactor, size2*sizeFactor2, toPercentStag);
        vec3 posMixed = mix(xyz, xyz2, toPercentStag);
    
        ////---- info for RAY CASTING in fragment shader ----
        mat4 matPMV = projectionMatrix * modelViewMatrix;
    
        //vec4 posNorm = matPMV * vec4(posMixed, 1);
        //vec4 szNorm = matPMV * vec4(szMixed, 1);
        //vec4 szZero = matPMV * vec4(0, 0, 0, 1);
    
        //vSize.x = (szNorm.x - szZero.x) * (canvasWidth / 2.0) / szNorm.w ;
        //vSize.y = (szNorm.y - szZero.y) * (canvasHeight / 2.0) / szNorm.w;
    
        //vPosition.x = (posNorm.x + 1.0) * (canvasWidth / 2.0) / posNorm.w;
        //vPosition.y = (posNorm.y + 1.0) * (canvasHeight / 2.0) / posNorm.w;
        
        //---- rotate line by theta / theta2 ----
        float thetaMix = mix(theta, theta2, toPercentTheta);
        float sint = sin(thetaMix);
        float cost = cos(thetaMix);
        mat3 matRot = mat3(cost, sint, 0, -sint, cost, 0, 0, 0, 1);
        vec3 vertPos = (drawingPoints == 1.0) ? vec3(0, 0, 0) : (cubeVertices[vi] * szMixed);
        vec3 pos = matRot * vertPos + posMixed;
    
        //---- texture coordinates ----
        v_texCoord1 = cubeTexCoords[vi];
        v_texCoord2 = cubeTexCoords[vi];
        v_texCoord1.x = (v_texCoord1.x + imageIndex) / textureCount1;
        v_texCoord2.x = (v_texCoord2.x + imageIndex2) / textureCount2;
    
        //---- LIGHTING ----
        vec3 transNormal = normalize(normalMatrix *  cubeNormals[vi]);
        vec3 totalLight = vec3(ambientFactor, ambientFactor, ambientFactor);
    
        //---- LIGHT # 1 ----
        float dirWeighting = lightFactor1 * max(dot(transNormal, normalize(dirLight)), 0.0);
        totalLight += (dirWeighting * crLight);
    
        //---- LIGHT # 2 ----
        //float dirWeighting2 = lightFactor2 * max(dot(transNormal, normalize(dirLight2)), 0.0);
        //totalLight += (dirWeighting2 * crLight2);
    
        //---- important: do not distort original colors - ensure totalLight dies not exceed 1 ----
        totalLight = clamp(totalLight, vec3(0, 0, 0), vec3(1, 1, 1));
    
        //---- debug ----
        //totalLight = 0.0 + 0.000000001 * totalLight;
    
        v_color = (lightingEnabled == 1.0) ? colorMixed * totalLight : colorMixed;
    
        //---- debug ----
        //v_color = vec3(0, 0, 0) + 0.000000001 * v_color;
        
        //---- hover (total override of lit color) ----
        if (vectorIndex == hoverVectorIndex)
        {
            v_color = hoverColor;
        }
    
        //---- opacity ----
        //v_opacity = mix(opacity*globalOpacity, opacity2*globalOpacity2, toPercenUneasedStag);
        v_opacity = mix(globalOpacity, globalOpacity2, toPercenUneasedStag);
    
        //---- pass values to fragment shader ----
        //gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1);
        gl_Position = matPMV * vec4(pos, 1);
    
        //gl_Position = .0000000001*gl_Position + ((vertexId == 0.0) ? vec4(-.5, -.5, 0, 1) : ((vertexId == 1.0) ? vec4(.5, -.5, 0, 1) : vec4(.5, .5, 0, 1)));
    
        //---- this sets the size of POINT drawing primitives -----
        gl_PointSize = szMixed.x;
    
    }
    */ });
shaders.fragmentshader = getTextFromFunc(function () {
    /*
    //-------------------------------------------------------------------------------------
    //  Copyright (c) 2015 - Microsoft Corporation.
    //    fragmentShader.c - an GLSL fragment shader for drawing in BeachParty.
    //-------------------------------------------------------------------------------------
    
    precision mediump float;
    
    varying vec3 v_color;
    varying float v_opacity;
    
    varying highp vec2 v_texCoord1;
    varying highp vec2 v_texCoord2;
    
    uniform sampler2D uSampler1;		// set to "0"
    uniform sampler2D uSampler2;		// set to "1"
    
    uniform float usingTexture1;
    uniform float usingTexture2;
    uniform float toPercentFrag;
    
    void main()
    {
        //---- hide pixels of opacity=0, even if we are not blending ----
        if (v_opacity == 0.0)
        {
            discard;
        }
    
        //---- Note: vPosition is the center of the shape being drawn ----
    
        ////---- get distance from center of shape ----
        //float xDiff = gl_FragCoord.x - vPosition.x;
        //float yDiff = gl_FragCoord.y - vPosition.y;
    
        //if ((abs(xDiff) > vSize.x) || (abs(yDiff) > vSize.y))
        //{
        //	//discard;
        //}
    
        /// NOTE: the use of "texture2D(uSampler, xx)" when uSampler is not bound to a texture
        /// issues a warning to the Chrome console for every draw.  TODO: figure out a way to avoid this.
    
        //---- compute FROM color ----
        vec4 texColor1 = (usingTexture1 == 1.0) ? texture2D(uSampler1, v_texCoord1) : vec4(1, 1, 1, 1);
    
        //---- compute TO color ----
        vec4 texColor2 = (usingTexture2 == 1.0) ? texture2D(uSampler2, v_texCoord2) : vec4(1, 1, 1, 1);
    
        //---- mix them ----
        vec4 texColorMixed = mix(texColor1, texColor2, toPercentFrag);
    
        //---- debug - JUST USE TEXTRUE REGISTER #1 ----
        //texColorMixed = texture2D(uSampler1, v_texCoord2) + .00001 * texColorMixed;
    
        gl_FragColor = vec4(v_color, v_opacity) * texColorMixed;
    
        //---- debug ----
        //gl_FragColor = .00001*gl_FragColor + vec4(1, 0, 0, 1);
    }
    */ });
shaders.gridlinesvertexshader = getTextFromFunc(function () {
    /*
    //-------------------------------------------------------------------------------------
    //  Copyright (c) 2015 - Microsoft Corporation.
    //   gridLinesVertexShader.c - an GLSL vertex shader for drawing 3D GRLD LINES in BeachParty.
    //-------------------------------------------------------------------------------------
    
    attribute vec3 a_position;
    uniform mat4 u_mvMatrix;
    uniform mat4 u_pMatrix;
    
    void main()
    {
        gl_Position = u_pMatrix * u_mvMatrix * vec4(a_position, 1.0);
    }
    
    
    */ });
shaders.gridlinesfragmentshader = getTextFromFunc(function () {
    /*
    //-------------------------------------------------------------------------------------
    //  Copyright (c) 2015 - Microsoft Corporation.
    //    gridLinesFragmentShader.c - an GLSL fragment shader for drawing 3D GRID LINES in BeachParty.
    //-------------------------------------------------------------------------------------
    
    precision mediump float;
    uniform vec4 u_color;
    
    void main()
    {
        gl_FragColor = u_color;
    
        //---- debug ----
        //gl_FragColor = .00001*gl_FragColor + vec4(1, 0, 0, 1);
    }
    
    */ });
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    shapeUtils.ts - misc. functions that support shapeEng.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    function error(msg) {
        throw msg;
    }
    beachParty.error = error;
    /**
     * This is a minimum webGL drawing routine, to test the "gl" context and help debug more complex code.
     * @param gl
     * @param width
     * @param height
     * @param buildShaders
     * @param buildGlBuffers
     */
    function testGlDraw(gl, width, height, buildShaders, buildGlBuffers) {
        if (buildShaders) {
            //---- init shaders/program ----
            var fragShaderStr = "precision mediump float; void main(void) { gl_FragColor = vec4(1, 0, 1, 1); }";
            var vertexShaderStr = "    void main(void) { gl_Position = vec4(0, 0, 0, 1);  gl_PointSize = 100.0; }";
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexShaderStr);
            gl.compileShader(vertexShader);
            var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragShader, fragShaderStr);
            gl.compileShader(fragShader);
            var shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragShader);
            gl.linkProgram(shaderProgram);
            gl.useProgram(shaderProgram);
        }
        if (buildGlBuffers) {
            //---- init buffers ----
            var vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            var vertices = [1];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            var numVertexItems = 1;
        }
        //---- draw scene ----
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.viewport(0, 0, width, height);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.drawArrays(gl.POINTS, 0, numVertexItems);
    }
    beachParty.testGlDraw = testGlDraw;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    cubeMesh.ts - defines cube vertices, normals, and triangles.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    beachParty.cubeMesh = {};
    /** Defines the geometry for a CUBE object (vertices, normals, and texture coordinates).  Note
        that triangles are defined with FRONT side trinagle points in CCW (counter-clockwise) order. */
    function buildCubeMesh() {
        beachParty.cubeMesh = {};
        beachParty.cubeMesh.vertices = [
            // Front face
            -1.0, -1.0, 1.0,
            1.0, -1.0, 1.0,
            1.0, 1.0, 1.0,
            -1.0, 1.0, 1.0,
            // Back face
            -1.0, -1.0, -1.0,
            -1.0, 1.0, -1.0,
            1.0, 1.0, -1.0,
            1.0, -1.0, -1.0,
            // Top face
            -1.0, 1.0, -1.0,
            -1.0, 1.0, 1.0,
            1.0, 1.0, 1.0,
            1.0, 1.0, -1.0,
            // Bottom face
            -1.0, -1.0, -1.0,
            1.0, -1.0, -1.0,
            1.0, -1.0, 1.0,
            -1.0, -1.0, 1.0,
            // Right face
            1.0, -1.0, -1.0,
            1.0, 1.0, -1.0,
            1.0, 1.0, 1.0,
            1.0, -1.0, 1.0,
            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0, 1.0,
            -1.0, 1.0, 1.0,
            -1.0, 1.0, -1.0
        ];
        //---- normalize the mesh ----
        beachParty.cubeMesh.vertices = beachParty.cubeMesh.vertices.map(function (d, i) { return d / 2; });
        beachParty.cubeMesh.vertexNormals = [
            // Front face
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            // Back face
            0, 0, -1,
            0, 0, -1,
            0, 0, -1,
            0, 0, -1,
            // Top face
            0, 1, 0,
            0, 1, 0,
            0, 1, 0,
            0, 1, 0,
            // Bottom face
            0, -1, 0,
            0, -1, 0,
            0, -1, 0,
            0, -1, 0,
            // Right face
            1, 0, 0,
            1, 0, 0,
            1, 0, 0,
            1, 0, 0,
            // Left face
            -1, 0, 0,
            -1, 0, 0,
            -1, 0, 0,
            -1, 0, 0,
        ];
        beachParty.cubeMesh.uv = [
            // Front
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            // Back
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            // Top
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            // Bottom
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            // Right
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            // Left
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0
        ];
        /** This allows us to draw with perspective camera but still only see the front of a cube (to emulate a 2D view). */
        beachParty.cubeMesh.uvFrontOnly = [
            // Front
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            // Back
            0.0, 0.0,
            0.0, 0.0,
            0.0, 0.0,
            0.0, 0.0,
            // Top
            0.0, 0.0,
            0.0, 0.0,
            0.0, 0.0,
            0.0, 0.0,
            // Bottom
            0.0, 0.0,
            0.0, 0.0,
            0.0, 0.0,
            0.0, 0.0,
            // Right
            0.0, 0.0,
            0.0, 0.0,
            0.0, 0.0,
            0.0, 0.0,
            // Left
            0.0, 0.0,
            0.0, 0.0,
            0.0, 0.0,
            0.0, 0.0
        ];
        //---- these are the indicies (reference the vertexes/uv by index) ----
        beachParty.cubeMesh.triangles =
            [
                //---- FOR 24 VERTICES ----
                0, 1, 2, 0, 2, 3,
                4, 5, 6, 4, 6, 7,
                8, 9, 10, 8, 10, 11,
                12, 13, 14, 12, 14, 15,
                16, 17, 18, 16, 18, 19,
                20, 21, 22, 20, 22, 23 // left (CCW)
            ];
        //---- flip UV vertically (to correct for upside-down bitmap ----
        for (var i = 1; i < beachParty.cubeMesh.uv.length; i += 2) {
            var v = beachParty.cubeMesh.uv[i];
            beachParty.cubeMesh.uv[i] = (v == 0) ? 1 : 0;
        }
        //---- convert to float32Arrays for setting as shader uniform values ----
        beachParty.cubeMesh.vertices = new Float32Array(beachParty.cubeMesh.vertices);
        beachParty.cubeMesh.vertexNormals = new Float32Array(beachParty.cubeMesh.vertexNormals);
        beachParty.cubeMesh.uv = new Float32Array(beachParty.cubeMesh.uv);
        beachParty.cubeMesh.triangles = new Float32Array(beachParty.cubeMesh.triangles);
    }
    beachParty.buildCubeMesh = buildCubeMesh;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    glAttribute.ts - small class to manage a webGL attribute.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// Need a description of how arrays and buffers are allocated for this class...
    var glAttributeClass = (function () {
        function glAttributeClass(gl, glInst, program, nameInShader, sizeInFloats, isByte, normalizeOnGpu, isVertexCommon, isSingleBuffer) {
            if (isVertexCommon === void 0) { isVertexCommon = true; }
            this._gl = gl;
            this._glInst = glInst;
            this._program = program;
            this._sizeInFloats = sizeInFloats;
            this._nameInShader = nameInShader;
            this._isByte = isByte;
            this._normalizeOnGpu = normalizeOnGpu;
            this._isVertexCommon = isVertexCommon;
            this._array = null;
            this._isSingleBuffer = isSingleBuffer;
            var attrLoc = gl.getAttribLocation(program, nameInShader);
            this._attrLoc = attrLoc;
            this._glBuffers = [];
            if (attrLoc == -1) {
                //----for debugging/development purposes, ignore this error ----
                if (nameInShader != "size2" && nameInShader != "theta" && nameInShader != "theta2") {
                }
            }
            else {
                if (isSingleBuffer) {
                    var glBuffer = gl.createBuffer();
                    this._glBuffers.push(glBuffer);
                }
            }
        }
        glAttributeClass.prototype.glInst = function (value) {
            if (arguments.length == 0) {
                return this._glInst;
            }
            this._glInst = value;
            //this.onDataChanged("glInst");
        };
        glAttributeClass.prototype.allocateBuffersForAttr = function (drawInfos) {
            var gl = this._gl;
            this._drawInfos = drawInfos;
            if (!this._isSingleBuffer) {
                if (this._glBuffers.length != drawInfos.length) {
                    //---- deallocate previous buffers ----
                    for (var i = 0; i < this._glBuffers.length; i++) {
                        var oldBuff = this._glBuffers[i];
                        gl.deleteBuffer(oldBuff);
                    }
                    //---- allocate NEW buffers ----
                    this._glBuffers = [];
                    for (var i = 0; i < drawInfos.length; i++) {
                        var glBuffer = gl.createBuffer();
                        this._glBuffers.push(glBuffer);
                    }
                }
            }
        };
        glAttributeClass.prototype.unbindBuffer = function (gl) {
            //---- looks like we don't need to do this on any platform ----
            //if (!vp.utils.isSafari)
            //{
            //    gl.bindBuffer(gl.ARRAY_BUFFER, null);
            //}
        };
        glAttributeClass.prototype.bindBuffersToArrayData = function (drawIndexes, verticesInBuffer) {
            var gl = this._gl;
            var drawInfos = this._drawInfos;
            if (this._isSingleBuffer) {
                var glBuffer = this._glBuffers[0];
                gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, this._array, gl.STATIC_DRAW);
                this.unbindBuffer(gl);
            }
            else {
                //---- bind a buffer to the specified subset, so that we can draw this subset using instancing ----
                if (this._attrLoc !== undefined && this._attrLoc != -1 && this._array != undefined) {
                    //---- bind buffers to subArrays ----
                    var mySizeInFloats = this._sizeInFloats;
                    if (!(this._glInst && this._isVertexCommon)) {
                        mySizeInFloats *= verticesInBuffer;
                    }
                    for (var i = 0; i < drawIndexes.length; i++) {
                        var drawIndex = drawIndexes[i];
                        var drawInfo = drawInfos[drawIndex];
                        var glBuffer = this._glBuffers[drawIndex];
                        var start = drawInfo.instOffset;
                        var end = start + drawInfo.instCount; // - 1;
                        var subarrayView = this._array.subarray(start * mySizeInFloats, end * mySizeInFloats);
                        //vp.utils.debug("bindBuffers: attr=" + this._nameInShader + ", drawIndex=" + drawIndex +
                        //    ", offset=" + drawInfo.instOffset + ", length=" + subarrayView.length);
                        gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, subarrayView, gl.STATIC_DRAW);
                        this.unbindBuffer(gl);
                    }
                }
            }
        };
        glAttributeClass.prototype.bindBufferForDrawing = function (drawInfoIndex) {
            if (this._isSingleBuffer) {
                drawInfoIndex = 0;
            }
            var buffer = this._glBuffers[drawInfoIndex];
            this.bindAttributeToBuffer(buffer);
        };
        glAttributeClass.prototype.bindAttributeToBuffer = function (buffer) {
            var gl = this._gl;
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.enableVertexAttribArray(this._attrLoc);
            var dataType = (this._isByte) ? gl.UNSIGNED_BYTE : gl.FLOAT;
            var normalize = this._normalizeOnGpu;
            gl.vertexAttribPointer(this._attrLoc, this._sizeInFloats, dataType, normalize, 0, 0);
            if (this._isVertexCommon && this._glInst) {
                this._glInst.vertexAttribDivisorANGLE(this._attrLoc, 1);
            }
            this.unbindBuffer(gl);
        };
        glAttributeClass.prototype.setArray = function (array) {
            var gl = this._gl;
            this._array = array;
        };
        return glAttributeClass;
    }());
    beachParty.glAttributeClass = glAttributeClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    glUniform.ts - small class to manage a webGL uniform.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var glUniformClass = (function () {
        function glUniformClass(gl, program, nameInShader, typeStr, initValue) {
            this._gl = gl;
            this._program = program;
            this._nameInShader = nameInShader;
            var uniformLoc = gl.getUniformLocation(program, nameInShader);
            if (uniformLoc == -1) {
                beachParty.error("Cannot locate shader uniform: " + nameInShader);
            }
            this._uniformLoc = uniformLoc;
            this._typeStr = typeStr;
            var setter = null;
            if (typeStr == "1i") {
                setter = gl.uniform1i;
            }
            else if (typeStr == "1f" || typeStr == "f") {
                setter = gl.uniform1f;
            }
            else if (typeStr == "2f") {
                setter = gl.uniform2f;
            }
            else if (typeStr == "3f") {
                setter = gl.uniform3f;
            }
            else if (typeStr == "4f") {
                setter = gl.uniform4f;
            }
            else if (typeStr == "1fv" || typeStr == "fv") {
                setter = gl.uniform1fv;
            }
            else if (typeStr == "2fv") {
                setter = gl.uniform2fv;
            }
            else if (typeStr == "3fv") {
                setter = gl.uniform3fv;
            }
            else if (typeStr == "4fv") {
                setter = gl.uniform4fv;
            }
            else if (typeStr == "matrix3fv") {
                setter = gl.uniformMatrix3fv;
            }
            else if (typeStr == "matrix4fv") {
                setter = gl.uniformMatrix4fv;
            }
            else {
                beachParty.error("Unknown uniform type: " + typeStr);
            }
            this._glSetter = setter;
            if (initValue !== undefined && initValue != null) {
                this.setValue(initValue);
            }
        }
        glUniformClass.prototype.isValueEqual = function (value) {
            if (vp.utils.isArray(value) || value instanceof Float32Array) {
                var eq = vp.arrayEquals(value, this._value);
            }
            else {
                var eq = (value == this._value);
            }
            return eq;
        };
        glUniformClass.prototype.setValue = function (value) {
            var changed = (!this.isValueEqual(value));
            //---- don't call the relative expensive GPU setter unless value has actually changed ----
            if (changed) {
                //vp.utils.debug("goUniform.setValue: name=" + this._nameInShader + ", old=" + this._value + ", new=" + value +
                //    ", changed=" + changed);
                this._value = value;
                glUniformClass.uniformSetCount++;
                if (this._glSetter) {
                    var gl = this._gl;
                    var uniformLoc = this._uniformLoc;
                    if (!uniformLoc) {
                        throw "uniformLoc is null for var name=" + this._nameInShader;
                    }
                    //vp.utils.debug("setValue uniformLoc=" + uniformLoc + ", value=" + value);
                    if (this._typeStr == "matrix4fv") {
                        this._gl.uniformMatrix4fv(uniformLoc, gl.FALSE, value);
                    }
                    else if (this._typeStr == "matrix3fv") {
                        this._gl.uniformMatrix3fv(uniformLoc, gl.FALSE, value);
                    }
                    else {
                        //---- note: we must pass "gl" as the "this" ptr AND must pass all of our params  ----
                        var argArray = vp.utils.toArray(arguments);
                        argArray.insert(0, uniformLoc);
                        //this._glSetter.call(gl, uniformLoc, value);
                        this._glSetter.apply(gl, argArray);
                    }
                    if (gl.getError()) {
                        var msg = "glUniform.setValue error: name=" + this._nameInShader + ", value=" + value + ", uniformLoc=" + uniformLoc;
                        vp.utils.debug(msg);
                        throw msg;
                    }
                }
            }
        };
        glUniformClass.uniformSetCount = 0;
        return glUniformClass;
    }());
    beachParty.glUniformClass = glUniformClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    ts - webGL utility functions.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var glUtils = (function () {
        function glUtils() {
        }
        glUtils.addHostShader = function (name, value) {
            name = name.toLowerCase();
            //alert("adding host resource inner: " + fullName);
            glUtils.hostShaders[name] = value;
        };
        glUtils.error = function (msg) {
            throw msg;
        };
        glUtils.getContext = function (canvas, options) {
            var gl = null;
            try {
                gl = canvas.getContext("webgl", options);
                if (!gl) {
                    gl = canvas.getContext("experimental-webgl", options);
                }
            }
            catch (ex) {
                beachParty.error("error getting WebGL context: " + ex);
            }
            if (!gl) {
                beachParty.error("Unable to initialize WebGL");
            }
            return gl;
        };
        glUtils.getExtension = function (gl, name) {
            var glExt = null;
            var prefixes = ["", "WEBKIT_", "MOZ_"];
            for (var i = 0; i < prefixes.length; i++) {
                var prefix = prefixes[i];
                glExt = gl.getExtension(prefix + name);
                if (glExt) {
                    break;
                }
            }
            return glExt;
        };
        /** read TEXT file sync. from server relative path. */
        glUtils.readServerTextFile = function (relPath) {
            //---- read file SYNC from my host (same directory) ----
            var request = new XMLHttpRequest();
            //---- try to disable caching here by using time as a unique URL argument ----
            //relPath += "?foo=" + Date.now();
            request.open("GET", relPath, false);
            request.send();
            var str = request.responseText;
            return str;
        };
        glUtils.findAndCompileShader = function (gl, shaderId, isVertexShader) {
            shaderId = shaderId.toLowerCase();
            var index = shaderId.indexOf(".");
            if (index > -1) {
                shaderId = shaderId.substr(0, index);
            }
            var win = window;
            var shaderStr = (win && win.shaders) ? win.shaders[shaderId] : null;
            if (window.external && window.external.isHosted) {
            }
            else if (!shaderStr) {
                //var url = getMyPath() + "/../shaders/" + shaderId;    
                var url = "./../shaders/" + shaderId;
                shaderStr = glUtils.readServerTextFile(url);
            }
            var shader = null;
            if (isVertexShader) {
                if (vp.utils.isIOS) {
                    //---- limit the size of colorPalette (normal + selected colors) for iOS to reduce ----
                    //---- its UNIFORM usage, since iOS only supports 128 4xfloat's ----
                    //---- "13" supports 12 normal colors and 1 selected color ----
                    shaderStr = shaderStr.replace(/@cpSize/g, "13");
                }
                else {
                    //---- "28" supports 14 normal and 14 selected colors ----
                    shaderStr = shaderStr.replace(/@cpSize/g, "28");
                }
                shader = gl.createShader(gl.VERTEX_SHADER);
            }
            else {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            }
            gl.shaderSource(shader, shaderStr);
            gl.compileShader(shader);
            var status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!status) {
                var errMsg = gl.getShaderInfoLog(shader);
                beachParty.error("compiling shader: " + shaderId + ", error=" + errMsg);
            }
            return shader;
        };
        glUtils.buildProgram = function (gl, shaders) {
            var program = gl.createProgram();
            for (var i = 0; i < shaders.length; i++) {
                var shader = shaders[i];
                gl.attachShader(program, shader);
            }
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                var errMsg = gl.getProgramInfoLog(program);
                beachParty.error("Error building webGL program: " + errMsg);
            }
            return program;
        };
        glUtils.addAttribute = function (attributeMap, gl, glInst, program, nameInShader, sizeInFloats, isByte, normalizeOnGpu, isVertexCommon, isSingleBuffer) {
            var attr = new beachParty.glAttributeClass(gl, glInst, program, nameInShader, sizeInFloats, isByte, normalizeOnGpu, isVertexCommon, isSingleBuffer);
            attributeMap[nameInShader] = attr;
            return attr;
        };
        glUtils.addUniform = function (uniformMap, gl, program, nameInShader, typeStr, initialValue) {
            var uniform = new beachParty.glUniformClass(gl, program, nameInShader, typeStr, initialValue);
            uniformMap[nameInShader] = uniform;
            return uniform;
        };
        glUtils.colorNamesOrValuesToFloats = function (names) {
            var floats = new Float32Array(names.length * 3);
            var nextOffset = 0;
            for (var i = 0; i < names.length; i++) {
                var name = names[i];
                var rgb;
                if (vp.utils.isString(name)) {
                    rgb = vp.color.getColorFromString(name);
                }
                else {
                    rgb = name;
                }
                floats[nextOffset++] = rgb[0] / 255;
                floats[nextOffset++] = rgb[1] / 255;
                floats[nextOffset++] = rgb[2] / 255;
            }
            return floats;
        };
        glUtils.configDevice = function (gl, width, height, clearColor, useBlending, useCulling) {
            //vp.utils.debug("configDevice: width=" + width + ", height=" + height);
            //---- avoid WebGL errors before window is resized (during initialization) ----
            width = Math.max(0, width);
            height = Math.max(0, height);
            gl.viewport(0, 0, width, height);
            //---- store in custom properties for later use as needed ----
            gl.canvasWidth = width;
            gl.canvasHeight = height;
            //---- CLEAR GL rendering target ----
            gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
            if (useCulling) {
                gl.frontFace(gl.CCW); // counter-clockwise triangles are FRONT faces
                //---- don't understand why, but gl.FRONT seems to match normal non-culled drawing whereas gl.BACK doesn't ----
                gl.cullFace(gl.FRONT); // BACK);              // gl.BACK is the default (do not draw back faces)
                gl.enable(gl.CULL_FACE); // enable culling
            }
            else {
                gl.disable(gl.CULL_FACE);
            }
            gl.enable(gl.DEPTH_TEST);
            //---- init blending ----
            if (useBlending) {
                //---- TODO: for proper blending, we need to sort shapes (mesh primitives) by scaled z value ----
                //---- can we do the sorting somehow on the GPU (gp-gpu)? ----
                //---- CPU idea to try: map z-bound data to a large set of discreet values (say ints from 0-999) ----
                //---- and as they are mapped, assign them to a bucket for that discreet value ----
                //---- then, load all shapes in bucket order.  this just requires 1 pass over data ----
                //---- the z-scaling and bucket assignment, and then 1 more pass for the shape loading.  ----
                //---- much better than a sort of 5 million items, for example! ----
                gl.disable(gl.DEPTH_TEST); // must turn off (takes priority over blending)
                gl.enable(gl.BLEND);
                //var isIE11 = vp.utils.isIE11;
                if (!gl.blendFuncSeparat) {
                    //---- IE11 bug workaround - use simple blending because IE11 doesn't support the below alternative ----
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                }
                else {
                    //---- TODO: this does not exactly match canvas blending, but it is VERY CLOSE ----
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.DST_ALPHA);
                }
            }
            else {
                //---- we can either set to zbuffer testing or blending (but not both) ----
                gl.disable(gl.BLEND);
                gl.enable(gl.DEPTH_TEST);
            }
        };
        //---- shaders loaded by the host of our app (WinSandDance or Power BI) ----
        glUtils.hostShaders = {};
        return glUtils;
    }());
    beachParty.glUtils = glUtils;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    hitTestRect.ts - hit-testing of screen rectangle against set of bounding boxes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var hitTestRect = (function () {
        function hitTestRect() {
        }
        //---- schedule a build the next time we are idle (should only be called AFTER animation is completed) ----
        hitTestRect.markCacheBuildNeeded = function (transformer, boxMgr) {
            this.ndcRects = null;
            this.clearBuildTimer();
            //this.buildTimer = setTimeout((e) =>
            //{
            //    this.clearBuildTimer();
            //    this.buildNdcRects(transformer, boxes);
            //}, 100);
        };
        hitTestRect.clearBuildTimer = function () {
            if (this.buildTimer) {
                clearTimeout(this.buildTimer);
                this.buildTimer = null;
            }
        };
        hitTestRect.buildNdcRects = function (transformer, boxMgr) {
            var bbCount = boxMgr.getCount();
            vp.utils.debug("** buildNdcRects: bbCount=" + bbCount + "**");
            var matWVP = transformer.getWorldViewProjection();
            this.ndcRects = [];
            //---- now, transform & test each box ----
            for (var i = 0; i < bbCount; i++) {
                var box = boxMgr.getBoxByIndex(i);
                var rcBox = this.transformBox(box, matWVP);
                this.ndcRects.push(rcBox);
            }
        };
        hitTestRect.getRectToPtDist = function (rc, pt) {
            //---- for now, just compute distance to center of rc ----
            var cx = (rc.left + rc.right) / 2;
            var cy = (rc.top + rc.bottom) / 2;
            var dx = pt.x - cx;
            var dy = pt.y - cy;
            var dist = dx * dx + dy * dy; // don't need true dist (sqrt)
            return dist;
        };
        hitTestRect.intersectUsingTransforms = function (rcScreen, transformer, boxMgr) {
            /// algorithm: transform each bounding box into NDC and then do simple rect/rect intersection test 
            if (!rcScreen) {
                throw "Error; rcScreen is null";
            }
            if (this.ndcRects === null) {
                this.buildNdcRects(transformer, boxMgr);
            }
            var intersections = [];
            var matWVP = transformer.getWorldViewProjection();
            //---- first, translate mouse rect from screen coordinates into NDC ----
            var mrLeftTop = transformer.viewportUntransformPoint(vp.geom.createVector3(rcScreen.left, rcScreen.top, 0));
            var mrRightBot = transformer.viewportUntransformPoint(vp.geom.createVector3(rcScreen.right, rcScreen.bottom, 0));
            //---- note: y values are swamped here because axis is flipped ----
            var rcMouse = vp.geom.createRect(mrLeftTop.x, mrRightBot.y, mrRightBot.x - mrLeftTop.x, mrLeftTop.y - mrRightBot.y);
            //---- ptMouse is used for distance testing ----
            var ptMouse = { x: (rcMouse.left + rcMouse.right) / 2, y: (rcMouse.top + rcMouse.bottom) / 2 };
            var bbCount = boxMgr.getCount();
            //---- now, transform & test each box ----
            for (var i = 0; i < bbCount; i++) {
                var rcBox = this.ndcRects[i];
                if (rcBox && vp.geom.rectIntersectsRect(rcBox, rcMouse)) {
                    var dist = this.getRectToPtDist(rcBox, ptMouse);
                    var box = boxMgr.getBoxByIndex(i);
                    box.dist = dist;
                    intersections.push(box);
                }
            }
            return intersections;
        };
        hitTestRect.transformBox = function (box, matWVP) {
            //---- transform 8 points of box, and then form bounding rect from new points ----
            var xMin = box.xMin;
            var yMin = box.yMin;
            var zMin = box.zMin;
            var xMax = box.xMax;
            var yMax = box.yMax;
            var zMax = box.zMax;
            //---- allow for z-rotation ----
            if (box.theta) {
                var cx = (xMin + xMax) / 2;
                var cy = (yMin + yMax) / 2;
                var cz = (zMin + zMax) / 2;
                var sin = Math.sin(box.theta);
                var cos = Math.cos(box.theta);
                //var matCenter = mat4.translate(-cx, -cy, -cz);
                //var matPos = mat4.translate(cx, cy, cz);
                var mat = new Float32Array(16);
                mat4.identity(mat);
                //---- (in reverse order): move to center, rotate about z, move back, transform by WorldViewProjection ----
                mat4.multiply(mat, mat, matWVP);
                mat4.translate(mat, mat, [cx, cy, cz]);
                mat4.rotateZ(mat, mat, box.theta);
                mat4.translate(mat, mat, [-cx, -cy, -cz]);
                matWVP = mat;
            }
            var p1 = this.transformPoint(xMin, yMin, zMin, matWVP);
            var p2 = this.transformPoint(xMin, yMax, zMin, matWVP);
            var p3 = this.transformPoint(xMax, yMax, zMin, matWVP);
            var p4 = this.transformPoint(xMax, yMin, zMin, matWVP);
            var p5 = this.transformPoint(xMin, yMin, zMax, matWVP);
            var p6 = this.transformPoint(xMin, yMax, zMax, matWVP);
            var p7 = this.transformPoint(xMax, yMax, zMax, matWVP);
            var p8 = this.transformPoint(xMax, yMin, zMax, matWVP);
            var xMin = Math.min(p1.x, p2.x, p3.x, p4.x, p5.x, p6.x, p7.x, p8.x);
            var yMin = Math.min(p1.y, p2.y, p3.y, p4.y, p5.y, p6.y, p7.y, p8.y);
            var xMax = Math.max(p1.x, p2.x, p3.x, p4.x, p5.x, p6.x, p7.x, p8.x);
            var yMax = Math.max(p1.y, p2.y, p3.y, p4.y, p5.y, p6.y, p7.y, p8.y);
            var rc = vp.geom.createRect(xMin, yMin, xMax - xMin, yMax - yMin);
            return rc;
        };
        hitTestRect.transformPoint = function (x, y, z, matrix) {
            var pos3 = new Float32Array(3);
            vec3.transformMat4(pos3, [x, y, z], matrix);
            var pos3x = vp.geom.createPoint3(pos3[0], pos3[1], pos3[2]);
            return pos3x;
        };
        hitTestRect.intersectUsingFrustrum = function (rcScreen, transformer, origBoxes) {
            /// Our algorithm removes boxes that are outside the bounding frustrum of rcScreen
            /// projected from the near to the far clipping planes.  Any objects that remain must be
            /// in, or overlap with, our frustrum.
            //---- make a copy of the list of boxes ----
            var boxes = vp.utils.copyArray(origBoxes);
            var zNear = 0;
            var zFar = .999;
            //---- get points aligned with near plane ---
            var np1 = transformer.unprojectFromScreen(rcScreen.left, rcScreen.bottom, zNear);
            var np2 = transformer.unprojectFromScreen(rcScreen.left, rcScreen.top, zNear);
            var np3 = transformer.unprojectFromScreen(rcScreen.right, rcScreen.top, zNear);
            var np4 = transformer.unprojectFromScreen(rcScreen.right, rcScreen.bottom, zNear);
            //---- get points aligned with far plane ---
            var fp1 = transformer.unprojectFromScreen(rcScreen.left, rcScreen.bottom, zFar);
            var fp2 = transformer.unprojectFromScreen(rcScreen.left, rcScreen.top, zFar);
            var fp3 = transformer.unprojectFromScreen(rcScreen.right, rcScreen.top, zFar);
            var fp4 = transformer.unprojectFromScreen(rcScreen.right, rcScreen.bottom, zFar);
            //---- eliminate boxes outside of each plane ----
            this.eliminateBoxesOutsidePlane(boxes, np1, np2, np3, np4); // FRONT plane
            this.eliminateBoxesOutsidePlane(boxes, fp1, fp2, np2, np1); // LEFT plane
            this.eliminateBoxesOutsidePlane(boxes, fp1, fp2, fp3, fp4); // BACK plane
            this.eliminateBoxesOutsidePlane(boxes, np4, np3, fp3, fp4); // RIGHT plane
            this.eliminateBoxesOutsidePlane(boxes, np3, np2, fp2, fp3); // TOP plane
            this.eliminateBoxesOutsidePlane(boxes, np4, np1, fp1, fp4); // BOTTOM plane
            return boxes;
        };
        hitTestRect.eliminateBoxesOutsidePlane = function (boxes, p1, p2, p3, p4) {
            var plane = { p1: p2, p2: p2, p3: p3 };
            for (var i = boxes.length - 1; i >= 0; i--) {
                var box = boxes[i];
                if (this.isBoxOutsidePlane(box, plane)) {
                    boxes.removeAt(i);
                }
            }
        };
        hitTestRect.isBoxOutsidePlane = function (box, plane) {
            //---- box is outside if all 8 of its points are outside ----
            var isOutside = true;
            var xMin = box.xMin;
            var yMin = box.yMin;
            var zMin = box.zMin;
            var xMax = box.xMax;
            var yMax = box.yMax;
            var zMax = box.zMax;
            if (!this.isPointOutsidePlane(xMin, yMin, zMin, plane)) {
                isOutside = false;
            }
            else if (!this.isPointOutsidePlane(xMin, yMax, zMin, plane)) {
                isOutside = false;
            }
            else if (!this.isPointOutsidePlane(xMax, yMax, zMin, plane)) {
                isOutside = false;
            }
            else if (!this.isPointOutsidePlane(xMax, yMin, zMin, plane)) {
                isOutside = false;
            }
            else if (!this.isPointOutsidePlane(xMin, yMin, zMax, plane)) {
                isOutside = false;
            }
            else if (!this.isPointOutsidePlane(xMin, yMax, zMax, plane)) {
                isOutside = false;
            }
            else if (!this.isPointOutsidePlane(xMax, yMax, zMax, plane)) {
                isOutside = false;
            }
            else if (!this.isPointOutsidePlane(xMax, yMin, zMax, plane)) {
                isOutside = false;
            }
            return isOutside;
        };
        hitTestRect.isPointOutsidePlane = function (x, y, z, plane) {
            var q = vp.geom.createPoint3(x, y, z);
            //---- compute vector from pt1 of plane to q ----
            var pq = vp.geom.vector3.subtract(plane.p1, q);
            //---- compute normal of plane ----
            var normal = (plane.normal === undefined) ? this.getPlaneNormal(plane) : plane.normal;
            var dotValue = vp.geom.vector3.dot(normal, pq);
            var isOutside = (dotValue < 0);
            return isOutside;
        };
        hitTestRect.getPlaneNormal = function (plane) {
            var vector3 = vp.geom.vector3;
            var u = vector3.subtract(plane.p2, plane.p1);
            var v = vector3.subtract(plane.p3, plane.p1);
            var x = (u.y * v.z) - (u.z - v.y);
            var y = (u.z * v.x) - (u.x - v.z);
            var z = (u.x * v.y) - (u.y - v.x);
            var normal = vp.geom.createVector3(x, y, z);
            plane.normal = normal; // cache for later use
            return normal;
        };
        hitTestRect.ndcRects = null;
        hitTestRect.buildTimer = null;
        return hitTestRect;
    }());
    beachParty.hitTestRect = hitTestRect;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    ray.ts - ray-based hit testing.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** This code adpoted from XNA 4 Ray and BoundingBox classes (Microsoft). */
    var rayClass = (function () {
        function rayClass(position, direction) {
            this.position = position;
            this.direction = direction;
        }
        /** return null if no intersection found; otherwise returns distance to  intersection point. */
        rayClass.prototype.intersectSphere = function (sphere) {
            var spx = sphere.center.x - this.position.x;
            var spy = sphere.center.y - this.position.y;
            var spz = sphere.center.z - this.position.z;
            var num7 = ((spx * spx) + (spy * spy)) + (spz * spz);
            var num2 = sphere.radius * sphere.radius;
            if (num7 <= num2) {
                return 0;
            }
            var num = ((spx * this.direction.x) + (spy * this.direction.y)) + (spz * this.direction.z);
            if (num < 0) {
                return null;
            }
            var num6 = num7 - (num * num);
            if (num6 > num2) {
                return null;
            }
            var num8 = Math.sqrt(num2 - num6);
            return (num - num8);
        };
        /** return null if no intersection found; otherwise returns distance to intersection point. */
        rayClass.prototype.intersectBox = function (box) {
            var num = 0;
            var maxValue = Number.MAX_VALUE;
            if (Math.abs(this.direction.x) < 1E-06) {
                if ((this.position.x < box.xMin) || (this.position.x > box.xMax)) {
                    return null;
                }
            }
            else {
                var num11 = 1 / this.direction.x;
                var num8 = (box.xMin - this.position.x) * num11;
                var num7 = (box.xMax - this.position.x) * num11;
                if (num8 > num7) {
                    var num14 = num8;
                    num8 = num7;
                    num7 = num14;
                }
                num = Math.max(num8, num);
                maxValue = Math.min(num7, maxValue);
                if (num > maxValue) {
                    return null;
                }
            }
            if (Math.abs(this.direction.y) < 1E-06) {
                if ((this.position.y < box.yMin) || (this.position.y > box.yMax)) {
                    return null;
                }
            }
            else {
                var num10 = 1 / this.direction.y;
                var num6 = (box.yMin - this.position.y) * num10;
                var num5 = (box.yMax - this.position.y) * num10;
                if (num6 > num5) {
                    var num13 = num6;
                    num6 = num5;
                    num5 = num13;
                }
                num = Math.max(num6, num);
                maxValue = Math.min(num5, maxValue);
                if (num > maxValue) {
                    return null;
                }
            }
            if (Math.abs(this.direction.z) < 1E-06) {
                if ((this.position.z < box.zMin) || (this.position.z > box.zMax)) {
                    return null;
                }
            }
            else {
                var num9 = 1 / this.direction.z;
                var num4 = (box.zMin - this.position.z) * num9;
                var num3 = (box.zMax - this.position.z) * num9;
                if (num4 > num3) {
                    var num12 = num4;
                    num4 = num3;
                    num3 = num12;
                }
                num = Math.max(num4, num);
                maxValue = Math.min(num3, maxValue);
                if (num > maxValue) {
                    return null;
                }
            }
            return num;
        };
        return rayClass;
    }());
    beachParty.rayClass = rayClass;
    var HitTestResult = (function () {
        function HitTestResult(dist, primaryKey, boundingBox) {
            this.distance = dist;
            this.primaryKey = primaryKey;
            this.boundingBox = boundingBox;
        }
        return HitTestResult;
    }());
    beachParty.HitTestResult = HitTestResult;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    textureMaker.ts - utility class for building shape textures
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var textureMakerClass = (function (_super) {
        __extends(textureMakerClass, _super);
        function textureMakerClass(texPalette) {
            _super.call(this);
            this._shapeCount = 0;
            this._potCount = 0; // nearest powerOfTwo of shapeCount
            this._imagesLoaded = 0;
            this._texPalette = texPalette;
            this._shapeCount = texPalette.length;
            this._potCount = this.nearestPowerOfTwo(this._shapeCount);
        }
        textureMakerClass.prototype.getImageSheet = function () {
            return this._imgSheet;
        };
        textureMakerClass.prototype.getTexture = function () {
            return this._texture;
        };
        textureMakerClass.prototype.getPotCount = function () {
            return this._potCount;
        };
        textureMakerClass.prototype.nearestPowerOfTwo = function (value) {
            var log = Math.log2(value);
            var ceil = Math.ceil(log);
            var pot = Math.pow(2, ceil);
            return pot;
        };
        textureMakerClass.prototype.buildAsync = function (gl, texPalette, isShapeNames) {
            this._gl = gl;
            var texture = null;
            if (texPalette.length == 1) {
                //---- cache only supports single entries ----
                var singleName = texPalette[0];
                texture = textureMakerClass.textureCache[singleName];
            }
            if (texture) {
                //---- texture found in cache! ----
                this._texture = texture;
                ////---- waste time ----
                //var dummy = 3;
                //for (var i = 0; i < 10000; i++)
                //{
                //    for (var j = 0; j < 10000; j++)
                //    {
                //        dummy += i * 3;
                //    }
                //}
                this.onDataChanged("loaded");
            }
            else {
                var texture = gl.createTexture();
                this._texture = texture;
                /// Note: non-power-of-two (NPOT) textures can NOT be used for mipmapping (setting image for each level) .
                //---- try to use powerOfTwo, since quality is MUCH higher ----
                var powerOfTwo = isShapeNames;
                gl.bindTexture(gl.TEXTURE_2D, texture); // normal 2D texture
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // flip texture about Y axis (like normal)
                if (powerOfTwo) {
                    //---- this is the important one, since our images are bigger and we need to shrink them when we map to a shape ----
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST); //_MIPMAP_NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                }
                else {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                }
                if (isShapeNames) {
                    this.buildShapeMakers(texPalette);
                    //---- now, load all of the minmap's manually ----
                    this.makeTextureLevel(0, 1024, 96);
                    this.makeTextureLevel(1, 512, 48);
                    this.makeTextureLevel(2, 256, 24);
                    this.makeTextureLevel(3, 128, 12);
                    this.makeTextureLevel(4, 64, 6); // this is the largest size we currently draw
                    this.makeTextureLevel(5, 32, 3);
                    this.makeTextureLevel(6, 16, 2);
                    this.makeTextureLevel(7, 8, 1.5);
                    this.makeTextureLevel(8, 4, 1.25);
                    this.makeTextureLevel(9, 2, 1.125);
                    //---- have to keep calling until actualWidth (size * nearestPot(shapeCount)) gets down to 1 ----
                    var size = 1;
                    var level = 10;
                    while (true) {
                        this.makeTextureLevel(level, size, 1);
                        var actualWidth = size * this._potCount;
                        if (actualWidth <= 1) {
                            break;
                        }
                        size /= 2;
                        level++;
                    }
                    //---- texture COMPLETED ----
                    this.cacheTextureIfPossible();
                    this.onDataChanged("loaded");
                }
                else {
                    this.loadImagesFromPalette(texPalette);
                }
            }
        };
        textureMakerClass.prototype.buildShapeMakers = function (texPalette) {
            var makers = [];
            for (var i = 0; i < texPalette.length; i++) {
                var name = texPalette[i];
                var maker = {};
                maker.isFilled = name.startsWith("filled ");
                if (name.endsWith("circle")) {
                    maker.shapeMaker = this.circleMaker;
                }
                else if (name.endsWith("square")) {
                    maker.shapeMaker = this.squareMaker;
                }
                else if (name.endsWith("triangle")) {
                    maker.shapeMaker = this.triangleMaker;
                }
                else {
                    throw "Error: unknown texture shape: " + name;
                }
                makers.push(maker);
            }
            this._makers = makers;
        };
        textureMakerClass.prototype.circleMaker = function (ctx, size, strokeSize, xOffset, isFilled) {
            //---- draw the circle ----
            ctx.clearRect(xOffset, 0, size, size);
            var r = size / 2 - strokeSize / 2;
            ctx.beginPath();
            ctx.arc(xOffset + size / 2, size / 2, r, 0, 2 * Math.PI, false);
            if (!isFilled) {
                //---- outline ----
                ctx.lineWidth = strokeSize;
                ctx.strokeStyle = "white";
                ctx.stroke();
            }
            else {
                //---- filled ----
                ctx.fillStyle = "white";
                ctx.fill();
            }
        };
        textureMakerClass.prototype.triangleMaker = function (ctx, size, strokeSize, xOffset, isFilled) {
            //---- draw the triangle ----
            ctx.clearRect(xOffset, 0, size, size);
            if (isFilled) {
                var xMin = xOffset;
                var xMax = xOffset + size;
                var yMin = 0;
                var yMax = size;
            }
            else {
                var fudge = .45 * strokeSize;
                var halfStroke = (strokeSize / 2) + fudge;
                var xMin = xOffset + halfStroke;
                var xMax = xOffset + size - halfStroke;
                var yMin = halfStroke;
                var yMax = size - halfStroke;
            }
            ctx.beginPath();
            ctx.moveTo(xMin, yMax);
            ctx.lineTo((xMin + xMax) / 2, yMin);
            ctx.lineTo(xMax, yMax);
            //ctx.lineTo(xMin, yMax);
            ctx.closePath();
            if (!isFilled) {
                //---- outline ----
                ctx.lineWidth = strokeSize;
                ctx.strokeStyle = "white";
                ctx.stroke();
            }
            else {
                //---- filled ----
                ctx.fillStyle = "white";
                ctx.fill();
            }
        };
        textureMakerClass.prototype.squareMaker = function (ctx, size, strokeSize, xOffset, isFilled) {
            if (isFilled) {
                //---- SOLID square ----
                var fudge = .45 * strokeSize;
                ctx.fillStyle = "white";
                var sz = size - 2 * fudge;
                ctx.fillRect(xOffset + fudge, 0 + fudge, sz, sz);
            }
            else {
                var fudge = .45 * strokeSize;
                var halfStroke = (strokeSize / 2) + fudge;
                var xMin = xOffset + halfStroke;
                var xMax = xOffset + size - halfStroke;
                var yMin = halfStroke;
                var yMax = size - halfStroke;
                //---- OUTLINE rect ----
                ctx.clearRect(xOffset, 0, size, size);
                ctx.lineWidth = strokeSize;
                ctx.strokeStyle = "white";
                ctx.strokeRect(xMin, yMin, xMax - xMin, yMax - yMin);
            }
        };
        /** create an image sheet from loaded image elements. All images will be drawn using the size of the first image. */
        textureMakerClass.prototype.createImageSheet = function (images) {
            var imageCount = images.length;
            var width = images[0].width;
            var height = images[0].height;
            var totalWidth = imageCount * width;
            //---- create canvas we can draw on ----
            var canvasW = vp.select(document.createElement("canvas"))
                .attr("width", totalWidth)
                .attr("height", height);
            //---- get drawing context ----
            var canvas = canvasW[0];
            var ctx = canvas.getContext("2d");
            ctx.translate(0.5, 0.5);
            //---- draw the shapes onto the canvas ----
            for (var i = 0; i < imageCount; i++) {
                var image = images[i];
                //ctx.msImageSmoothingEnabled = true;
                ctx.drawImage(image, 0, 0, image.width, image.height, i * width, 0, width, height);
            }
            return canvas;
        };
        /** create an image sheet from the shapes to be drawn. */
        textureMakerClass.prototype.createShapeImages = function (size, strokeSize) {
            var shapeCount = this._makers.length;
            //---- use next highest power of 2, to keep images looking good ----
            var potShapeCount = this._potCount;
            var actualSize = Math.max(1, size);
            var totalWidth = Math.max(1, potShapeCount * size);
            var totalHeight = actualSize;
            //---- create canvas we can draw on ----
            var canvasW = vp.select(document.createElement("canvas"))
                .attr("width", totalWidth)
                .attr("height", totalHeight);
            //---- get drawing context ----
            var canvas = canvasW[0];
            var ctx = canvas.getContext("2d");
            //---- draw the shapes ----
            for (var i = 0; i < this._makers.length; i++) {
                var maker = this._makers[i];
                maker.shapeMaker(ctx, actualSize, strokeSize, i * actualSize, maker.isFilled);
            }
            return canvas;
        };
        textureMakerClass.prototype.loadImagesFromPalette = function (urls) {
            var _this = this;
            this._images = [];
            this._imagesLoaded = 0;
            for (var i = 0; i < urls.length; i++) {
                var url = urls[i];
                var img = new Image();
                img.onload = function (e) {
                    _this._imagesLoaded++;
                    vp.utils.debug("URL image loaded:" + url);
                    if (_this._imagesLoaded == urls.length) {
                        //---- all needed images have now been loaded ----
                        if (urls.length == 1) {
                            //---- simple case; don't need to create a sheet ----
                            _this.loadTextureFromSheet(img);
                        }
                        else {
                            var imgSheet = _this.createImageSheet(_this._images);
                            _this._imgSheet = imgSheet;
                            _this.loadTextureFromSheet(imgSheet);
                        }
                    }
                };
                this._images.push(img);
                img.src = url;
            }
        };
        /** imgSheet can be HTMLImageElement or canvas. */
        textureMakerClass.prototype.loadTextureFromSheet = function (imgSheet) {
            var gl = this._gl;
            gl.bindTexture(gl.TEXTURE_2D, this._texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imgSheet);
            this.cacheTextureIfPossible();
            this.onDataChanged("loaded");
        };
        textureMakerClass.prototype.cacheTextureIfPossible = function () {
            var _this = this;
            if (this._texPalette.length == 1) {
                var name = this._texPalette[0];
                textureMakerClass.textureCache[name] = this._texture;
            }
            this._texture._id = textureMakerClass.nextTextureId++;
            this._texture.toString = function (e) {
                return "texture#" + _this._texture._id;
            };
        };
        textureMakerClass.prototype.makeTextureLevel = function (level, size, strokeSize) {
            var gl = this._gl;
            var img = this.createShapeImages(size, strokeSize);
            //---- bind this img as the specified level for the texture ----
            //vp.utils.debug("makeTextureLevel: binding img to texture: level=" + level + " width=" + img.width + ", height=" + img.height);
            gl.bindTexture(gl.TEXTURE_2D, this._texture);
            gl.texImage2D(gl.TEXTURE_2D, level, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
            //if (level == 5)
            //{
            //    vp.select("#imgDebug")
            //        .attr("src", img.toDataURL())
            //        .css("display", "block")
            //}
        };
        textureMakerClass.textureCache = {};
        textureMakerClass.nextTextureId = 1;
        return textureMakerClass;
    }(beachParty.dataChangerClass));
    beachParty.textureMakerClass = textureMakerClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    transformer.ts - manages the projection, view, and world matrices for a visualization.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var transformerClass = (function (_super) {
        __extends(transformerClass, _super);
        function transformerClass(gl) {
            _super.call(this);
            this._xRotation = 0;
            this._yRotation = 0;
            this._zRotation = 0;
            this._rcxWorld = null;
            //_baseSizeFactor = 1;
            this._canvasWidth = 1;
            this._canvasHeight = 1;
            this._isOrthoCamera = false;
            this._transformChanged = true;
            /// When "_useScreenUnits" is true:
            ///   - shapes with depth are greatly extruded in Z (looks wrong)
            ///   - rotation about the Y and X axis make the chart disappear.
            /// So, as of 2/3/2015, we are sticking to using perspectiveFOV for non-ortho camera
            /// even though this means we cannot use screen coordinates (which are handy, especially when
            /// specifying the size of shapes).
            //---- when true, use SCREEN units for perspective camera ----
            this._useScreenUnits = false;
            this._gl = gl;
            this.resetMatrices();
            //this.testXnaPick();
        }
        transformerClass.prototype.rebuildProjectionMatrix = function () {
            var cameraPosZ = this._zPos;
            var rads = vp.utils.toRadians(45);
            var gl = this._gl;
            var cw = this._canvasWidth;
            var ch = this._canvasHeight;
            var nearDist = .001;
            var farDist = 20000;
            var margin = 15;
            var cwx = cw - margin;
            var chx = ch - margin;
            var aspect = cwx / chx;
            //vp.utils.debug("rebuildProjectionMatrix: cw=" + cw + ", ch=" + ch + ", aspect=" + aspect);
            this._matProjection = new Float32Array(16);
            if (this._isOrthoCamera) {
                //---- ORTHO: using screen coordinates ----
                this._rcxWorld = { left: -cwx / 2, right: cwx / 2, top: -chx / 2, bottom: chx / 2, front: nearDist, back: farDist };
                var nearPos = -5000; // cameraPosZ - nearDist;
                var farPos = 20000; // cameraPosZ - farDist;
                mat4.ortho(this._matProjection, -cw / 2, cw / 2, ch / 2, -ch / 2, nearPos, farPos);
            }
            else {
                if (this._useScreenUnits) {
                    //---- PERSPECTIVE: using screen coordinates ----
                    this._rcxWorld = { left: -cwx / 2, right: cwx / 2, top: -chx / 2, bottom: chx / 2, front: nearDist, back: farDist };
                    mat4.frustum(this._matProjection, -cw / 2, cw / 2, ch / 2, -ch / 2, nearDist, farDist);
                }
                else {
                    //---- this is the DEFAULT BEACHPARTY CAMERA ----
                    var percentToUse = 1; //.98;
                    var zDepth = 4; // the range of z values in world units where we place models
                    //---- according to this article, the near plane should not be too close to zero ----
                    //---- https://www.opengl.org/archives/resources/faq/technical/depthbuffer.htm ----
                    var nearDist = 1;
                    var farDist = nearDist + 100;
                    //zDepth = 20;  
                    var zBack = -zDepth / 2; // farDist;        
                    var zFront = zDepth / 2; // zNear
                    mat4.perspective(this._matProjection, rads, aspect, nearDist, farDist);
                    var ptWorld = this.unprojectFromScreen(0, 0, undefined, true);
                    var xb = Math.abs(ptWorld.x);
                    var yb = Math.abs(ptWorld.y);
                    //---- PERSPECTIVE: using 3D camera coordinates ----
                    this._rcxWorld = { left: -xb, right: xb, top: yb, bottom: -yb, front: zFront, back: zBack };
                }
            }
        };
        transformerClass.prototype.resetMatrices = function () {
            var zPos = (this._useScreenUnits) ? .001 : 7; // why do we need to specify exactly ".001" for perspective with screen units?
            this._zPos = zPos;
            var cameraPos = vp.geom.createVector3(0, 0, zPos);
            var lookAt = vp.geom.createVector3(0, 0, -1);
            var up = vp.geom.createVector3(0, 1, 0);
            var matrix4View = vp.geom.matrix4.createLookAt(cameraPos, lookAt, up);
            this._matView = new Float32Array(16);
            mat4.lookAt(this._matView, this.toFloatv3(cameraPos), this.toFloatv3(lookAt), this.toFloatv3(up));
            this._cameraLookAt = lookAt;
            this._cameraPos = cameraPos;
            //this._matWorld = vp.geom.matrix4.identity();
            this._matWorld = new Float32Array(16);
            mat4.identity(this._matWorld);
            this.rebuildProjectionMatrix();
            //this.updateRcxWorld();
            this._transformChanged = true;
        };
        transformerClass.prototype.testXnaPick = function () {
            var width = 880;
            var height = 580;
            var near = .001;
            var far = 20000;
            var geom = vp.geom;
            var matrix4 = geom.matrix4;
            var vector3 = geom.vector3;
            var rads = vp.utils.toRadians(45);
            var aspect = width / height;
            var matWorld = matrix4.identity();
            var matView = matrix4.createLookAt(geom.createVector3(0, 0, 7), geom.createVector3(0, 0, 0), geom.createVector3(0, 1, 0));
            var matProjection = matrix4.createPerspectiveFovLH(rads, aspect, near, far); // use LH for this test ONLY!
            var ptNear = transformerClass.unprojectXna(vp.geom.createVector3(875, 575, 0), width, height, matWorld, matView, matProjection);
            var ptFar = transformerClass.unprojectXna(vp.geom.createVector3(875, 575, .9999), width, height, matWorld, matView, matProjection);
            //vp.utils.debug("------------------");
            //vp.utils.debug("ptNear: " + ptNear);
            //vp.utils.debug("ptFar: " + ptFar);
            //vp.utils.debug("------------------");
        };
        transformerClass.prototype.getProjection = function () {
            return this._matProjection;
        };
        transformerClass.prototype.getView = function () {
            return this._matView;
        };
        transformerClass.prototype.world = function (value) {
            if (arguments.length == 0) {
                return this._matWorld;
            }
            if (value) {
                this._matWorld = value;
                this.onDataChanged("world");
            }
        };
        transformerClass.prototype.multiplyTransform = function (matTransform) {
            //---- for RIGHT HAND WebGL - matrix are applied in reverse order (right to left) ----
            //if (false)
            //{
            //    //---- as per Mark Finch's advice, we switched the order here and got ----
            //    //---- the screen-based axis rotation that we wanted! ----
            //    mat4.multiply(this._matWorld, this._matWorld, matTransform);
            //}
            //else
            {
                //---- something changed as of May-27-2015; we seem to be tranforming the CAMERA instead of the SHAPES, so let's try the old order ----
                mat4.multiply(this._matWorld, matTransform, this._matWorld);
            }
            this._transformChanged = true;
        };
        transformerClass.prototype.clearTransforms = function () {
            mat4.identity(this._matWorld);
            this._transformChanged = true;
        };
        transformerClass.prototype.getWorldViewProjection = function () {
            //---- webGL order (mat = mat x new) ----
            var matAll = new Float32Array(16);
            mat4.identity(matAll);
            mat4.multiply(matAll, matAll, this._matProjection);
            mat4.multiply(matAll, matAll, this._matView);
            mat4.multiply(matAll, matAll, this._matWorld);
            return matAll;
        };
        transformerClass.prototype.postProjTransformAdjust = function (v) {
            var w = (v.w == 0) ? 1 : v.w;
            return new vp.geom.vector3(v.x / w, v.y / w, v.z / w);
        };
        /** map a point from MODEL space to SCREEN space. */
        transformerClass.prototype.projectToScreen = function (x, y, z) {
            var pos3x = this.projectToNDC(x, y, z);
            var screenPos = this.viewportTransformPoint(pos3x);
            return screenPos;
        };
        transformerClass.prototype.transformPtWithMatrix = function (x, y, z, mat) {
            var pt = new Float32Array(3);
            vec3.transformMat4(pt, [x, y, z], mat);
            var pos3x = vp.geom.createPoint3(pt[0], pt[1], pt[2]);
            return pos3x;
        };
        /** map a point from MODEL space to NDC space (-1 to 1). */
        transformerClass.prototype.projectToNDC = function (x, y, z) {
            var gl = this._gl;
            //var pos = new vp.geom.vector3(x, y, z);
            z = z || 0;
            var wvp = this.getWorldViewProjection();
            var pos3 = new Float32Array(3);
            vec3.transformMat4(pos3, [x, y, z], wvp);
            var pos3x = vp.geom.createPoint3(pos3[0], pos3[1], pos3[2]);
            return pos3x;
        };
        transformerClass.prototype.unprojectFromNDCUsingMarksApproach = function (x, y) {
            //---- technique for determining zScreen ----
            //---- objPos is the center of the object is camera space ----
            var objPos = [0, 0, 0];
            vec3.transformMat4(objPos, objPos, this._matWorld);
            vec3.transformMat4(objPos, objPos, this._matView);
            //---- dist = lookAt dot (cameraPos - objPos) ----
            var pos = [0, 0, 0];
            vec3.subtract(pos, this.toFloatv3(this._cameraPos), objPos);
            var distance = vec3.dot(this.toFloatv3(this._cameraLookAt), pos);
            //--- zScreen = dist * proj.m22 + proj.m32 (per mark finch) ----
            var matProj = this._matProjection;
            var zScreen = Math.abs(distance * matProj[5] + matProj[6]); // is m32  matProj[6] or matProj[9]?   
            //var test = this.projectToNDC(x, y, 0);
            //zScreen = test.z;
            vp.utils.debug("unproject: distance=" + distance + ", zScreen=" + zScreen);
            var posScr = this.unprojectFromNDCCore(x, y, zScreen);
            return posScr;
        };
        /** map from NDC (-1 to 1) to WORLD space */
        transformerClass.prototype.unprojectFromNDC = function (x, y) {
            var pt = null;
            //---- build ray from near to far plane ----
            var ptNear = this.unprojectFromNDCCore(x, y, 0);
            var ptFar = this.unprojectFromNDCCore(x, y, 1);
            var rayOrigin = ptNear;
            var ptDiffs = vp.geom.vector3.subtract(ptFar, ptNear);
            if (ptDiffs.x == 0 && ptDiffs.y == 0 && ptDiffs.z == 0) {
                pt = ptNear; // ptNear=ptFar
            }
            else {
                var rayDir = vp.geom.vector3.normal(ptDiffs);
                //---- now, caculate the point where ray intersects the z=0 plane ----
                var dist = -rayOrigin.z / rayDir.z;
                dist = 5.8; // this is about what dist should be (actually, 6.999) 
                pt = vp.geom.vector3.add(rayOrigin, vp.geom.vector3.multiply(rayDir, dist));
            }
            return pt;
        };
        transformerClass.prototype.getRayFromScreenPos = function (x, y) {
            var pt = null;
            //---- build ray from near to far plane ----
            var ptn = this.unprojectFromScreen(x, y, 0);
            var ptf = this.unprojectFromScreen(x, y, .9999);
            var ptNear = this.toFloatv3(ptn);
            var ptFar = this.toFloatv3(ptf);
            var rayOrigin = ptNear;
            var rayDir = new Float32Array(3);
            var diffs = new Float32Array(3);
            vec3.subtract(diffs, ptFar, ptNear); // ptNear, ptFar);
            if (diffs[0] == 0 && diffs[1] == 0 && diffs[2] == 0) {
                pt = ptNear; // ptNear=ptFar
            }
            else {
                vec3.normalize(rayDir, diffs);
            }
            var origin = vp.geom.createVector3(rayOrigin[0], rayOrigin[1], rayOrigin[2]);
            var dir = vp.geom.createVector3(rayDir[0], rayDir[1], rayDir[2]);
            var ray = new beachParty.rayClass(origin, dir);
            return ray;
        };
        /** map from NDC (-1 to 1) to WORLD space (using glmatrix library) */
        transformerClass.prototype.unprojectFromNDCEx = function (x, y) {
            var pt = null;
            //---- build ray from near to far plane ----
            var ptNear = this.toFloatv3(this.unprojectFromNDCCore(x, y, 0));
            var ptFar = this.toFloatv3(this.unprojectFromNDCCore(x, y, 1));
            var rayOrigin = ptNear;
            var diffs = new Float32Array(3);
            vec3.subtract(diffs, ptFar, ptNear); // ptNear, ptFar);
            if (diffs[0] == 0 && diffs[1] == 0 && diffs[2] == 0) {
                pt = ptNear; // ptNear=ptFar
            }
            else {
                var rayDir = new Float32Array(3);
                vec3.normalize(rayDir, diffs);
                //---- now, caculate the point where ray intersects the z = 0 plane ----
                var dist = -rayOrigin[2] / rayDir[2]; // .z;
                var product = new Float32Array(3);
                pt = new Float32Array(3);
                vec3.scale(product, rayDir, dist);
                vec3.add(pt, product, rayOrigin);
            }
            return { x: pt[0], y: pt[1], z: pt[2] };
        };
        /** map from HC (-1 to 1) to WORLD space */
        transformerClass.prototype.unprojectFromNDCCore = function (x, y, z, omitWorld) {
            var invProjection = mat4.create();
            mat4.invert(invProjection, this._matProjection);
            var invView = mat4.create();
            mat4.invert(invView, this._matView);
            var invWorld = mat4.create();
            mat4.invert(invWorld, this._matWorld);
            //---- apply INV PROJECTION ----
            var pt3 = new Float32Array(3);
            vec3.transformMat4(pt3, [x, y, z], invProjection);
            //---- apply INV VIEW ----
            var pp = new Float32Array(3);
            vec3.transformMat4(pp, pt3, invView);
            //---- apply INV WORLD ----
            if (omitWorld) {
                vWorld = pp;
            }
            else {
                var vWorld = new Float32Array(3);
                vec3.transformMat4(vWorld, pp, invWorld);
            }
            var posWorld = vp.geom.createPoint3(vWorld[0], vWorld[1], vWorld[2]);
            return posWorld;
        };
        transformerClass.prototype.getInvMvpMatrix = function () {
            var mat = mat4.create();
            mat4.identity(mat);
            mat4.multiply(mat, mat, this._matProjection);
            mat4.multiply(mat, mat, this._matView);
            mat4.multiply(mat, mat, this._matWorld);
            mat4.invert(mat, mat);
            return mat;
        };
        transformerClass.prototype.getInvWorldpMatrix = function () {
            var mat = mat4.create();
            mat4.invert(mat, this._matWorld);
            return mat;
        };
        /** static version of unprojectFromScreen(), XNA style. */
        transformerClass.unprojectXna = function (vScr, vpWidth, vpHeight, matWorld, matView, matProjection) {
            var vpX = 0;
            var vpY = 0;
            var vpMinDepth = 0;
            var vpMaxDepth = 1;
            //---- transform from screen to NDC ---
            var position = new Float32Array(3);
            position[0] = (((vScr.x - vpX) / (vpWidth)) * 2) - 1;
            position[1] = -((((vScr.y - vpY) / (vpHeight)) * 2) - 1);
            position[2] = (vScr.z - vpMinDepth) / (vpMaxDepth - vpMinDepth);
            //---- this is the order that matches XNA results, but may have to be reverse for WebGL: projection, view, world ----
            var mat = mat4.create();
            mat4.identity(mat);
            mat4.multiply(mat, mat, matProjection);
            mat4.multiply(mat, mat, matView);
            mat4.multiply(mat, mat, matWorld);
            mat4.invert(mat, mat);
            //---- transform position with mat ----
            var vector = new Float32Array(3);
            vec3.transformMat4(vector, position, mat);
            //---- adjust vector with "a" ----
            var m14 = mat[3];
            var m24 = mat[7];
            var m34 = mat[11];
            var m44 = mat[15];
            var posWorld = vp.geom.createPoint3(vector[0], vector[1], vector[2]);
            return posWorld;
        };
        transformerClass.withinEpsilon = function (a, b) {
            var epsilon = 1.401298E-45;
            var num = a - b;
            return ((-1.401298E-45 <= num) && (num <= epsilon));
        };
        /** static version of unprojectFromScreen(). */
        transformerClass.unprojectEx = function (vScr, vpWidth, vpHeight, matWorld, matView, matProjection) {
            //---- transform from screen to NDC ---
            var newX = vp.data.mapValue(vScr.x, 0, vpWidth - 1, -1, 1);
            var newY = vp.data.mapValue(vScr.y, 0, vpHeight - 1, 1, -1);
            var newZ = vScr.z;
            //---- invert matrices ----
            var invProjection = mat4.create();
            mat4.invert(invProjection, matProjection);
            var invView = mat4.create();
            mat4.invert(invView, matView);
            var invWorld = mat4.create();
            mat4.invert(invWorld, matWorld);
            //---- apply inverted PROJECTION ----
            var pt4 = new Float32Array(4);
            vec4.transformMat4(pt4, [newX, newY, newZ, 1], invProjection);
            //--- correct with "w" when going from vec4 to vec3 ----
            var w = pt4[3];
            var vp3 = [pt4[0] / w, pt4[1] / w, pt4[2] / w];
            //---- apply inverted VIEW ----
            var ptView = new Float32Array(3);
            vec3.transformMat4(ptView, vp3, invView);
            //---- apply inverted WORLD ----
            var ptWorld = new Float32Array(3);
            vec3.transformMat4(ptWorld, ptView, invWorld);
            var posWorld = vp.geom.createPoint3(ptWorld[0], ptWorld[1], ptWorld[2]);
            return posWorld;
        };
        transformerClass.prototype.getCameraPosAsArray = function () {
            return [this._cameraPos.x, this._cameraPos.y, this._cameraPos.z];
        };
        transformerClass.prototype.getNdcZ = function () {
            //---- before we can unproject screen boundaries to get world space, we need to get the z from projection ----
            var pt3 = this.projectToNDC(0, 0, 0);
            var zNorm = pt3.z;
            return zNorm;
        };
        /** map a point from SCREEN space to MODEL space. */
        transformerClass.prototype.unprojectFromScreen = function (xScreen, yScreen, zNorm, omitWorld) {
            if (zNorm === undefined) {
                zNorm = this.getNdcZ();
            }
            var ptNC = this.viewportUntransformPoint(vp.geom.createVector3(xScreen, yScreen, 0));
            var ptWorld = this.unprojectFromNDCCore(ptNC.x, ptNC.y, zNorm, omitWorld);
            return ptWorld;
        };
        /** maps point from homogeneous space (-1 to +1) to screen space. */
        transformerClass.prototype.viewportTransformPoint = function (v) {
            var gl = this._gl;
            var width = this._canvasWidth;
            var height = this._canvasHeight;
            var newX = vp.data.mapValue(v.x, -1, 1, 0, width);
            var newY = vp.data.mapValue(v.y, -1, 1, height, 0);
            var newZ = v.z; //vp.data.mapValue(v.z, 0, 1, 0, ??);
            return new vp.geom.vector3(newX, newY, newZ);
        };
        /** maps point from screen space to homogeneous space (-1 to +1). */
        transformerClass.prototype.viewportUntransformPoint = function (v) {
            var gl = this._gl;
            var width = this._canvasWidth;
            var height = this._canvasHeight;
            var newX = vp.data.mapValue(v.x, 0, width, -1, 1);
            var newY = vp.data.mapValue(v.y, height, 0, -1, 1);
            var newZ = v.z;
            return new vp.geom.vector3(newX, newY, newZ);
        };
        transformerClass.prototype.scaleMatrix = function (factor, mousePos, isMousePosInWorldUnits) {
            if (isMousePosInWorldUnits) {
                var modelPos = { x: mousePos.x, y: mousePos.y, z: mousePos.z };
            }
            else {
                //---- map mouse position from screen to world coordinates ----
                var modelPos = this.unprojectFromScreen(mousePos.x, mousePos.y);
            }
            this.scaleMatrixAt(factor, modelPos);
        };
        /** here, bounds.x is xMin, bounds.y is yMin.  */
        transformerClass.prototype.worldBoundsToScreen = function (bounds) {
            var min = this.projectToScreen(bounds.x, bounds.y, 0);
            var max = this.projectToScreen(bounds.x + bounds.width, bounds.y + bounds.height, 0);
            //---- in screen coordinates, the Y flips, so the max.y becomes the rc.top ----
            var rc = vp.geom.createRect(min.x, max.y, max.x - min.x, min.y - max.y);
            return rc;
        };
        transformerClass.prototype.worldPointToScreen = function (wx, wy, wz) {
            var ptNew = this.projectToScreen(wx, wy, wz);
            return ptNew;
        };
        transformerClass.prototype.worldSizeToScreen = function (size) {
            var max = this.projectToScreen(size, 0, 0);
            var min = this.projectToScreen(0, 0, 0);
            var sizePx = max.x - min.x;
            return sizePx;
        };
        transformerClass.prototype.screenSizeXToWorld = function (size) {
            var max = this.unprojectFromScreen(size, 0, undefined, true);
            var min = this.unprojectFromScreen(0, 0, undefined, true);
            var sizePx = max.x - min.x;
            return sizePx;
        };
        transformerClass.prototype.screenSizeYToWorld = function (size) {
            var max = this.unprojectFromScreen(0, size, undefined, true);
            var min = this.unprojectFromScreen(0, 0, undefined, true);
            var sizePx = -(max.y - min.y);
            return sizePx;
        };
        transformerClass.prototype.screenSizeZToWorld = function (size) {
            var max = this.unprojectFromScreen(0, 0, size, true);
            var min = this.unprojectFromScreen(0, 0, 0, true);
            var sizePx = -(max.z - min.z);
            return sizePx;
        };
        transformerClass.prototype.mapLinearFromScreenToWorld = function (x, y) {
            //---- used for mapping bounds on the Z plane from screen to world (not for general object mapping) ----
            var xPercent = x / this._canvasWidth;
            var yPercent = (this._canvasHeight - y) / this._canvasHeight; // flip it 
            var wb = this.getWorldBounds();
            var xWorld = wb.left + xPercent * (wb.right - wb.left);
            var yWorld = wb.bottom + yPercent * (wb.top - wb.bottom);
            var pt3 = { x: xWorld, y: yWorld, z: 0 };
            return pt3;
        };
        transformerClass.prototype.screenToWorldBounds = function (rc) {
            var min = this.mapLinearFromScreenToWorld(rc.left, rc.bottom);
            var max = this.mapLinearFromScreenToWorld(rc.right, rc.top);
            var worldBounds = vp.geom.createRect(min.x, min.y, max.x - min.x, max.y - min.y);
            return worldBounds;
        };
        transformerClass.prototype.translateMatrixEx = function (x, y, z) {
            var mat2 = vp.geom.matrix4.createTranslation(x, y, z);
            this.multiplyTransform(mat2);
        };
        transformerClass.prototype.scaleMatrixAt = function (factor, atPos) {
            vp.utils.debug("scaleMatrixAt: factor=" + factor);
            //---- to scale at "atPos", we need to make atPos to the origin ----
            //---- translate by -atPos, scale, translate by +atPos ----
            var mat1 = vp.geom.matrix4.createTranslation(-atPos.x, -atPos.y, -atPos.z);
            var mat2 = vp.geom.matrix4.createScale(factor, factor, factor);
            var mat3 = vp.geom.matrix4.createTranslation(atPos.x, atPos.y, atPos.z);
            //---- until this is reliable, just use a simple scaling ----
            //this.multiplyTransform(mat1);
            this.multiplyTransform(mat2);
            //this.multiplyTransform(mat3);
        };
        transformerClass.prototype.rotateMatrixX = function (value, additive) {
            if (additive === void 0) { additive = true; }
            var aaRot = vp.geom.matrix4.createRotationX(value);
            this.multiplyTransform(aaRot);
        };
        transformerClass.prototype.rotateMatrixY = function (value, additive, usePostZ) {
            if (additive === void 0) { additive = true; }
            if (usePostZ) {
                // instead of premultiplying by Y rotation, we're postmultiplying by Z which gives the effect 
                // rotating around the Y axis while keeping the x rotation fixed.
                mat4.rotateZ(this._matWorld, this._matWorld, value);
                this._transformChanged = true;
            }
            else {
                var aaRot = vp.geom.matrix4.createRotationY(value);
                this.multiplyTransform(aaRot);
            }
        };
        transformerClass.prototype.rotateMatrixZ = function (value) {
            var aaRot = vp.geom.matrix4.createRotationZ(value);
            this.multiplyTransform(aaRot);
        };
        transformerClass.prototype.xRotation = function (value) {
            if (value === undefined) {
                return vp.utils.toDegrees(this._xRotation);
            }
            value = vp.utils.toRadians(value);
            this.rotateMatrixX(value - this._xRotation);
            this._xRotation = value;
        };
        transformerClass.prototype.yRotation = function (value) {
            if (value === undefined) {
                return vp.utils.toDegrees(this._yRotation);
            }
            value = vp.utils.toRadians(value);
            this.rotateMatrixY(value - this._yRotation);
            this._yRotation = value;
        };
        transformerClass.prototype.zRotation = function (value) {
            if (value === undefined) {
                return vp.utils.toDegrees(this._zRotation);
            }
            value = vp.utils.toRadians(value);
            this.rotateMatrixZ(value - this._zRotation);
            this._zRotation = value;
        };
        transformerClass.prototype.getMatrix = function () {
            return this._matWorld;
        };
        /** "width" is the width of the camera's canvas, is pixels.  "height" is height of canvas. */
        transformerClass.prototype.updateCamera = function (isOrthoCamera, width, height) {
            this._canvasWidth = width;
            this._canvasHeight = height;
            this._isOrthoCamera = isOrthoCamera;
            this.rebuildProjectionMatrix();
        };
        transformerClass.prototype.cameraParams = function (cp) {
            if (arguments.length == 0) {
                var cp = new beachParty.CameraParams();
                cp.world = this._matWorld;
                cp.view = this._matView;
                cp.projection = this._matProjection;
                cp.rcxWorld = this._rcxWorld;
                //cp.width = this._canvasWidth;
                //cp.height = this._canvasHeight;
                return cp;
            }
            this._matWorld = cp.world;
            this._matProjection = cp.projection;
            this._matView = cp.view;
            //this._canvasWidth = cp.width;
            //this._canvasHeight = cp.height;
            //---- since we did not this camera, invalidate our own extended camera properties ----
            this._rcxWorld = cp.rcxWorld; //  undefined;
            this._isOrthoCamera = undefined;
            this.onDataChanged("world");
            this.onDataChanged("view");
            this.onDataChanged("projection");
        };
        transformerClass.prototype.getWorldBounds = function () {
            return this._rcxWorld;
        };
        transformerClass.prototype.toFloatv3 = function (v) {
            var a = new Float32Array(3);
            a[0] = v.x;
            a[1] = v.y;
            a[2] = v.z;
            return a;
        };
        return transformerClass;
    }(beachParty.dataChangerClass));
    beachParty.transformerClass = transformerClass;
    var Rect3d = (function () {
        function Rect3d(left, right, top, bottom, front, back) {
            this.left = left;
            this.right = right;
            this.top = top;
            this.bottom = bottom;
            this.front = front;
            this.back = back;
        }
        return Rect3d;
    }());
    beachParty.Rect3d = Rect3d;
})(beachParty || (beachParty = {}));
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.2
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


(function(_global) { 
  "use strict";

  var shim = {};
  if (typeof(exports) === 'undefined') {
    if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      shim.exports = {};
      define(function() {
        return shim.exports;
      });
    } else {
      // gl-matrix lives in a browser, define its namespaces in global
      shim.exports = typeof(window) !== 'undefined' ? window : _global;
    }
  }
  else {
    // gl-matrix lives in commonjs, define its namespaces in exports
    shim.exports = exports;
  }

  (function(exports) {
    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

if(!GLMAT_ARRAY_TYPE) {
    var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
}

if(!GLMAT_RANDOM) {
    var GLMAT_RANDOM = Math.random;
}

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

if(typeof(exports) !== 'undefined') {
    exports.glMatrix = glMatrix;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */

var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec2 = vec2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */

var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    var z = (GLMAT_RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec3 = vec3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */

var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
        out[3] = a[3] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = GLMAT_RANDOM();
    out[1] = GLMAT_RANDOM();
    out[2] = GLMAT_RANDOM();
    out[3] = GLMAT_RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec4 = vec4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x2 Matrix
 * @name mat2
 */

var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2 = mat2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;


/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2d = mat2d;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3x3 Matrix
 * @name mat3
 */

var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};


if(typeof(exports) !== 'undefined') {
    exports.mat3 = mat3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4x4 Matrix
 * @name mat4
 */

var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < GLMAT_EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&
        Math.abs(eyey - centery) < GLMAT_EPSILON &&
        Math.abs(eyez - centerz) < GLMAT_EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};


if(typeof(exports) !== 'undefined') {
    exports.mat4 = mat4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class Quaternion
 * @name quat
 */

var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.quat = quat;
}
;













  })(shim.exports);
})(this);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
///-----------------------------------------------------------------------------------------------------------------
/// structures.ts.  Copyright (c) 2016 Microsoft Corporation.
///    Structure classes for beachPartyChart.
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    (function (MappingSpread) {
        MappingSpread[MappingSpread["normal"] = 0] = "normal";
        MappingSpread[MappingSpread["low"] = 1] = "low";
        MappingSpread[MappingSpread["high"] = 2] = "high";
    })(beachParty.MappingSpread || (beachParty.MappingSpread = {}));
    var MappingSpread = beachParty.MappingSpread;
    (function (BinSorting) {
        BinSorting[BinSorting["none"] = 0] = "none";
        BinSorting[BinSorting["ascending"] = 1] = "ascending";
        BinSorting[BinSorting["descending"] = 2] = "descending";
        BinSorting[BinSorting["nameAscending"] = 3] = "nameAscending";
        BinSorting[BinSorting["nameDescending"] = 4] = "nameDescending";
    })(beachParty.BinSorting || (beachParty.BinSorting = {}));
    var BinSorting = beachParty.BinSorting;
    /** the delimiters that separate tags in a column value. */
    (function (TagDelimiter) {
        TagDelimiter[TagDelimiter["none"] = 0] = "none";
        TagDelimiter[TagDelimiter["semi"] = 1] = "semi";
        TagDelimiter[TagDelimiter["comma"] = 2] = "comma";
        TagDelimiter[TagDelimiter["space"] = 3] = "space";
    })(beachParty.TagDelimiter || (beachParty.TagDelimiter = {}));
    var TagDelimiter = beachParty.TagDelimiter;
    beachParty.TagDelimiters = [null, ";", ",", " "];
    /** parameters for mapping column data to attributes, facets, and axes. */
    var MappingData = (function () {
        function MappingData(attrName, colName, binCount) {
            if (colName === void 0) { colName = ""; }
            if (binCount === void 0) { binCount = 9; }
            this.isLegendBottomUp = false; // entries are added from the bottom to the top
            this.attrName = attrName;
            this.colName = colName;
            this.binCount = binCount;
            //this.maxCategoryBins = 32;
            this.binSorting = BinSorting.none;
            this.forceCategory = false;
            this.spread = MappingSpread.normal;
            this.customScalingCallback = null;
            this.breaks = null;
            this.customScalingCallback = null;
            this.useNiceNumbers = false;
            this.boundColInfo = null;
        }
        return MappingData;
    }());
    beachParty.MappingData = MappingData;
    var SizeMappingData = (function (_super) {
        __extends(SizeMappingData, _super);
        function SizeMappingData(binCount) {
            if (binCount === void 0) { binCount = 4; }
            _super.call(this, "size", "", binCount);
            this.sizePalette = [.25, .5, .75, 1];
            this.isContinuous = false;
        }
        return SizeMappingData;
    }(MappingData));
    beachParty.SizeMappingData = SizeMappingData;
    var LineMappingData = (function (_super) {
        __extends(LineMappingData, _super);
        function LineMappingData(binCount) {
            if (binCount === void 0) { binCount = 9; }
            _super.call(this, "line", "", binCount);
            this.color = "white";
            this.opacity = 1;
            this.size = 1;
            this.lineStyle = "solid";
            this.maxShapes = 9999;
        }
        return LineMappingData;
    }(MappingData));
    beachParty.LineMappingData = LineMappingData;
    var TextMappingData = (function (_super) {
        __extends(TextMappingData, _super);
        function TextMappingData(binCount) {
            if (binCount === void 0) { binCount = 9; }
            _super.call(this, "text", "", binCount);
            this.fontDesc = "12px Tahoma";
            this.color = "white";
            this.opacity = .5;
            this.maxTextLength = 100;
            this.maxShapes = 100;
        }
        return TextMappingData;
    }(MappingData));
    beachParty.TextMappingData = TextMappingData;
    var ShapeMappingData = (function (_super) {
        __extends(ShapeMappingData, _super);
        function ShapeMappingData(binCount) {
            if (binCount === void 0) { binCount = 6; }
            _super.call(this, "shape", "", binCount);
            this.shapePalette = ["filled circle", "filled square", "filled triangle", "circle", "square", "triangle"];
            var usePhotos = false;
            var palette = [];
            if (usePhotos) {
                //---- local photo-based images (test) ----
                for (var i = 1; i < 18; i++) {
                    palette.push("http://localhost/beachPartyApp/photos/p" + i + ".jpg");
                }
            }
            else {
                palette.push("http://localhost/beachPartyApp/photos/LogoOne.jpg");
                palette.push("http://localhost/beachPartyApp/photos/LogoTwo.jpg");
                palette.push("http://localhost/beachPartyApp/photos/LogoThree.jpg");
                palette.push("http://localhost/beachPartyApp/photos/LogoFour.jpg");
                palette.push("http://localhost/beachPartyApp/photos/LogoFive.jpg");
            }
            this.experimentalPalette = palette;
        }
        ShapeMappingData.prototype.getImagePalette = function (useExperimental) {
            var imgPalette = (useExperimental) ? this.experimentalPalette : this.shapePalette;
            return imgPalette;
        };
        return ShapeMappingData;
    }(MappingData));
    beachParty.ShapeMappingData = ShapeMappingData;
    var ImageMappingData = (function (_super) {
        __extends(ImageMappingData, _super);
        function ImageMappingData(binCount) {
            if (binCount === void 0) { binCount = 6; }
            _super.call(this, "image", "", binCount);
        }
        return ImageMappingData;
    }(MappingData));
    beachParty.ImageMappingData = ImageMappingData;
    var ChannelMappingData = (function () {
        function ChannelMappingData() {
        }
        return ChannelMappingData;
    }());
    beachParty.ChannelMappingData = ChannelMappingData;
    var ColorMappingData = (function (_super) {
        __extends(ColorMappingData, _super);
        function ColorMappingData(psName, paletteName, isContinuous, colorSteps, isReversed, isInverted, isCycling) {
            if (psName === void 0) { psName = "Diverging"; }
            if (paletteName === void 0) { paletteName = "RdBu"; }
            if (isContinuous === void 0) { isContinuous = false; }
            if (colorSteps === void 0) { colorSteps = 9; }
            _super.call(this, "color");
            this.paletteSetName = psName;
            this.paletteName = paletteName;
            this.isContinuous = isContinuous;
            //this.colorSteps = colorSteps;           // this will be used to set the inital value of the color steps slider in color panel
            this.binCount = colorSteps; // this will eventually be set to the length of the palette built for this attribute
            this.isReversed = isReversed;
            this.isInverted = isInverted;
            this.isCycling = isCycling;
            this.binCount = colorSteps;
            this.colorPalette = null;
        }
        return ColorMappingData;
    }(MappingData));
    beachParty.ColorMappingData = ColorMappingData;
    var SearchParams = (function () {
        function SearchParams() {
        }
        return SearchParams;
    }());
    beachParty.SearchParams = SearchParams;
    var FacetLayoutInfo = (function () {
        function FacetLayoutInfo() {
        }
        return FacetLayoutInfo;
    }());
    beachParty.FacetLayoutInfo = FacetLayoutInfo;
    var FacetMappingData = (function (_super) {
        __extends(FacetMappingData, _super);
        function FacetMappingData(binCount) {
            if (binCount === void 0) { binCount = 9; }
            _super.call(this, "facet", "", binCount);
            this.facetBounds = null; // if null, system will layout bounds
        }
        return FacetMappingData;
    }(MappingData));
    beachParty.FacetMappingData = FacetMappingData;
    var AxisData = (function () {
        function AxisData() {
            this.isAxisVisible = true;
            this.drawTicks = true;
            this.drawLabels = true;
            this.drawGridLines = false;
        }
        return AxisData;
    }());
    beachParty.AxisData = AxisData;
    var ChartFrameData = (function () {
        function ChartFrameData(isVisible) {
            if (isVisible === void 0) { isVisible = true; }
            this.isVisible = isVisible;
            this.opacity = 1;
            this.labelColor = "white";
            this.tickColor = "white";
            this.padding = null;
            this.xAxis = new AxisData();
            this.yAxis = new AxisData();
            this.zAxis = new AxisData();
        }
        return ChartFrameData;
    }());
    beachParty.ChartFrameData = ChartFrameData;
    (function (TextSearchType) {
        TextSearchType[TextSearchType["exactMatch"] = 0] = "exactMatch";
        TextSearchType[TextSearchType["startsWith"] = 1] = "startsWith";
        TextSearchType[TextSearchType["contains"] = 2] = "contains";
        TextSearchType[TextSearchType["lessThan"] = 3] = "lessThan";
        TextSearchType[TextSearchType["lessThanEqual"] = 4] = "lessThanEqual";
        TextSearchType[TextSearchType["greaterThan"] = 5] = "greaterThan";
        TextSearchType[TextSearchType["greaterThanEqual"] = 6] = "greaterThanEqual";
        TextSearchType[TextSearchType["betweenInclusive"] = 7] = "betweenInclusive";
        TextSearchType[TextSearchType["gtrValueAndLeqValue2"] = 8] = "gtrValueAndLeqValue2";
        TextSearchType[TextSearchType["geqValueAndLessValue2"] = 9] = "geqValueAndLessValue2";
        TextSearchType[TextSearchType["notEqual"] = 10] = "notEqual";
    })(beachParty.TextSearchType || (beachParty.TextSearchType = {}));
    var TextSearchType = beachParty.TextSearchType;
    (function (SearchAction) {
        SearchAction[SearchAction["selectMatches"] = 0] = "selectMatches";
        SearchAction[SearchAction["isolateMatches"] = 1] = "isolateMatches";
        SearchAction[SearchAction["excludeMatches"] = 2] = "excludeMatches";
        SearchAction[SearchAction["returnMatches"] = 3] = "returnMatches";
    })(beachParty.SearchAction || (beachParty.SearchAction = {}));
    var SearchAction = beachParty.SearchAction;
    /// LEGACY - remove ASAP.
    var ColMappings = (function () {
        function ColMappings(x, y, color) {
            this.x = new MappingData(x);
            this.y = new MappingData(y);
            this.color = new ColorMappingData("Sequential", color, false, 5, false);
        }
        return ColMappings;
    }());
    beachParty.ColMappings = ColMappings;
    var PreloadField = (function () {
        function PreloadField(name, desc, calcFieldExp, fieldType, sortedValues, formatting) {
            this.name = name;
            this.description = desc;
            this.calcFieldExp = calcFieldExp;
            this.fieldType = fieldType;
            this.sortedValues = sortedValues;
            this.formatting = formatting;
            this.valueMap = null;
        }
        return PreloadField;
    }());
    beachParty.PreloadField = PreloadField;
    (function (FileType) {
        FileType[FileType["delimited"] = 0] = "delimited";
        FileType[FileType["json"] = 1] = "json";
        FileType[FileType["sql"] = 2] = "sql";
    })(beachParty.FileType || (beachParty.FileType = {}));
    var FileType = beachParty.FileType;
    /** parameters that specify the working data: which data to load and how it should be transformed. */
    var WorkingDataParams = (function () {
        function WorkingDataParams(dataName, path, fileSource) {
            this.dataName = dataName;
            this.filePath = path;
            this.fileSource = fileSource;
            this.primaryKeyCol = null;
            this.hasHeader = true;
            this.fileType = FileType.delimited;
            this.fieldList = [];
        }
        WorkingDataParams.prototype.addField = function (name, desc, calcFieldExp, fieldType, sortedValues) {
            var pf = new PreloadField(name, desc, calcFieldExp, fieldType, sortedValues);
            this.fieldList.push(pf);
        };
        WorkingDataParams.prototype.getField = function (name) {
            var fix = null;
            for (var i = 0; i < this.fieldList.length; i++) {
                var fi = this.fieldList[i];
                if (fi.name == name) {
                    fix = fi;
                    break;
                }
            }
            return fix;
        };
        return WorkingDataParams;
    }());
    beachParty.WorkingDataParams = WorkingDataParams;
    /** Preloaded settings for data files. Users should also be able to create these by saving their current view.
    This also is how we represent the full state of an insight, to be persisted between sessions. */
    var Preload = (function (_super) {
        __extends(Preload, _super);
        function Preload(name, path, description, x, y, color, chart, subLayout) {
            _super.call(this, name, path);
            //this.name = name;
            this.description = description;
            this.tooltipFieldList = null;
            this.showInFileOpen = true;
            //this.addedBy = "rfernand";
            this.hasTimeData = false;
            this.dateAdded = new Date();
            this.colMappings = new ColMappings(x, y, color);
            this.chartName = chart;
            this.subLayout = subLayout;
        }
        return Preload;
    }(WorkingDataParams));
    beachParty.Preload = Preload;
    /** This is the subset of InsightData that is managed by the chart engine. */
    var SystemViewData = (function () {
        function SystemViewData() {
        }
        return SystemViewData;
    }());
    beachParty.SystemViewData = SystemViewData;
    (function (LoadAction) {
        LoadAction[LoadAction["all"] = 0] = "all";
        LoadAction[LoadAction["selection"] = 1] = "selection";
        LoadAction[LoadAction["filter"] = 2] = "filter";
        LoadAction[LoadAction["view"] = 3] = "view";
        LoadAction[LoadAction["data"] = 4] = "data";
    })(beachParty.LoadAction || (beachParty.LoadAction = {}));
    var LoadAction = beachParty.LoadAction;
    (function (NotesSource) {
        NotesSource[NotesSource["none"] = 0] = "none";
        NotesSource[NotesSource["name"] = 1] = "name";
        NotesSource[NotesSource["notes"] = 2] = "notes";
        NotesSource[NotesSource["both"] = 3] = "both";
    })(beachParty.NotesSource || (beachParty.NotesSource = {}));
    var NotesSource = beachParty.NotesSource;
    var InsightData = (function () {
        function InsightData(insightName, notes) {
            if (insightName === void 0) { insightName = ""; }
            if (notes === void 0) { notes = ""; }
            this.preload = new Preload("", null, "");
            this.name = insightName;
            this.notes = notes;
            this.loadAction = LoadAction.all;
            this.notesSource = NotesSource.none;
        }
        return InsightData;
    }());
    beachParty.InsightData = InsightData;
    (function (MarkerType) {
        MarkerType[MarkerType["circleFill"] = 0] = "circleFill";
        MarkerType[MarkerType["rectFill"] = 1] = "rectFill";
        MarkerType[MarkerType["triangleFill"] = 2] = "triangleFill";
        MarkerType[MarkerType["separator"] = 3] = "separator";
        MarkerType[MarkerType["circleOutline"] = 4] = "circleOutline";
        MarkerType[MarkerType["rectOutline"] = 5] = "rectOutline";
        MarkerType[MarkerType["triangleOutline"] = 6] = "triangleOutline";
    })(beachParty.MarkerType || (beachParty.MarkerType = {}));
    var MarkerType = beachParty.MarkerType;
    /**
     * For callers, if you don't know the information for a field, leave it as "undefined" and the dataFrame class
     * will try to calculate it.
     */
    var ColStats = (function () {
        function ColStats(min, max, nanCount, keyCount, sortedKeys) {
            this.min = min;
            this.max = max;
            this.nanCount = nanCount;
            this.keyCount = keyCount;
            this.sortedKeys = sortedKeys;
        }
        return ColStats;
    }());
    beachParty.ColStats = ColStats;
    /**
     * This is information about the specified column, relative to its SandDance-filtered-in values.
      * For callers, if you don't know the information for a field, leave it as "undefined" and the dataFrame class
      * will try to calculate it.
     */
    var ColInfo = (function () {
        function ColInfo(name, desc, colType, calcFieldExp, stats, infoIsComplete) {
            this.name = name;
            this.desc = desc;
            this.colType = colType;
            this.calcFieldExp = calcFieldExp;
            this.stats = stats;
            //---- default is to let system try to fill in missing informaton ----
            this.infoIsComplete = infoIsComplete;
        }
        return ColInfo;
    }());
    beachParty.ColInfo = ColInfo;
    /**
     * This structure extends ColInfo by adding a data vector.
     */
    var DataColumn = (function (_super) {
        __extends(DataColumn, _super);
        function DataColumn(name, desc, colType, calcFieldExp, stats, dataVector) {
            _super.call(this, name, desc, colType, calcFieldExp, stats);
            this.ctr = "DataColumn"; // class marker
        }
        return DataColumn;
    }(ColInfo));
    beachParty.DataColumn = DataColumn;
    /**
     * This specifies a substitution to be made for a specific value of a column.
     */
    var ValueMapEntry = (function () {
        function ValueMapEntry() {
        }
        return ValueMapEntry;
    }());
    beachParty.ValueMapEntry = ValueMapEntry;
    /** Information to rebuild chart as SVG, etc. */
    var ChartRepro = (function () {
        function ChartRepro() {
        }
        return ChartRepro;
    }());
    beachParty.ChartRepro = ChartRepro;
    (function (ChartType) {
        //AggColumn,
        ChartType[ChartType["Bar"] = 0] = "Bar";
        ChartType[ChartType["Column"] = 1] = "Column";
        ChartType[ChartType["Custom"] = 2] = "Custom";
        ChartType[ChartType["Density"] = 3] = "Density";
        ChartType[ChartType["Grid"] = 4] = "Grid";
        ChartType[ChartType["Line"] = 5] = "Line";
        ChartType[ChartType["Links"] = 6] = "Links";
        ChartType[ChartType["Poisson"] = 7] = "Poisson";
        ChartType[ChartType["Radial"] = 8] = "Radial";
        ChartType[ChartType["Random"] = 9] = "Random";
        ChartType[ChartType["Scatter"] = 10] = "Scatter";
        ChartType[ChartType["Scatter3D"] = 11] = "Scatter3D";
        //Squarify,
        ChartType[ChartType["Spiral"] = 12] = "Spiral";
        ChartType[ChartType["Stacks"] = 13] = "Stacks";
        ChartType[ChartType["Violin"] = 14] = "Violin";
        ChartType[ChartType["Xband"] = 15] = "Xband";
        ChartType[ChartType["Yband"] = 16] = "Yband";
    })(beachParty.ChartType || (beachParty.ChartType = {}));
    var ChartType = beachParty.ChartType;
    (function (LayoutType) {
        LayoutType[LayoutType["Default"] = 0] = "Default";
        LayoutType[LayoutType["Grid"] = 1] = "Grid";
        LayoutType[LayoutType["Percent"] = 2] = "Percent";
        LayoutType[LayoutType["Squarify"] = 3] = "Squarify";
        LayoutType[LayoutType["Strips"] = 4] = "Strips";
        //---- for stacks ----
        LayoutType[LayoutType["Cubes"] = 5] = "Cubes";
        LayoutType[LayoutType["ScaleToFit"] = 6] = "ScaleToFit";
        //---- not currently used ----
        LayoutType[LayoutType["Circle"] = 7] = "Circle";
        LayoutType[LayoutType["Poisson"] = 8] = "Poisson";
        LayoutType[LayoutType["Random"] = 9] = "Random";
    })(beachParty.LayoutType || (beachParty.LayoutType = {}));
    var LayoutType = beachParty.LayoutType;
    function getUiName(ct) {
        var uiName = null;
        if (ct == ChartType.Scatter3D) {
            uiName = "Scatter-3D";
        }
        else {
            uiName = ChartType[ct];
        }
        return uiName;
    }
    beachParty.getUiName = getUiName;
    (function (VectorType) {
        VectorType[VectorType["sortOrder"] = 0] = "sortOrder";
        VectorType[VectorType["naturalOrder"] = 1] = "naturalOrder";
        VectorType[VectorType["primaryKeyList"] = 2] = "primaryKeyList";
    })(beachParty.VectorType || (beachParty.VectorType = {}));
    var VectorType = beachParty.VectorType;
    var DataTipData = (function () {
        function DataTipData() {
        }
        return DataTipData;
    }());
    beachParty.DataTipData = DataTipData;
    (function (SelectMode) {
        SelectMode[SelectMode["normal"] = 0] = "normal";
        SelectMode[SelectMode["smartToggle"] = 1] = "smartToggle";
        SelectMode[SelectMode["toggleClear"] = 2] = "toggleClear";
        SelectMode[SelectMode["additive"] = 3] = "additive";
        SelectMode[SelectMode["subtractive"] = 4] = "subtractive";
        SelectMode[SelectMode["intersection"] = 5] = "intersection";
        SelectMode[SelectMode["nonIntersection"] = 6] = "nonIntersection";
    })(beachParty.SelectMode || (beachParty.SelectMode = {}));
    var SelectMode = beachParty.SelectMode;
    (function (SnapshotType) {
        SnapshotType[SnapshotType["none"] = 0] = "none";
        SnapshotType[SnapshotType["plot"] = 1] = "plot";
        SnapshotType[SnapshotType["chart"] = 2] = "chart";
    })(beachParty.SnapshotType || (beachParty.SnapshotType = {}));
    var SnapshotType = beachParty.SnapshotType;
    var ClusteringParams = (function () {
        function ClusteringParams() {
            this.numClusters = 3;
        }
        return ClusteringParams;
    }());
    beachParty.ClusteringParams = ClusteringParams;
    (function (ClusterResultMapping) {
        ClusterResultMapping[ClusterResultMapping["none"] = 0] = "none";
        ClusterResultMapping[ClusterResultMapping["color"] = 1] = "color";
        ClusterResultMapping[ClusterResultMapping["size"] = 2] = "size";
        ClusterResultMapping[ClusterResultMapping["shape"] = 3] = "shape";
    })(beachParty.ClusterResultMapping || (beachParty.ClusterResultMapping = {}));
    var ClusterResultMapping = beachParty.ClusterResultMapping;
    (function (PredefinedCustomChart) {
        //---- flat ----
        PredefinedCustomChart[PredefinedCustomChart["grid"] = 0] = "grid";
        PredefinedCustomChart[PredefinedCustomChart["random"] = 1] = "random";
        PredefinedCustomChart[PredefinedCustomChart["poisson"] = 2] = "poisson";
        PredefinedCustomChart[PredefinedCustomChart["spiral"] = 3] = "spiral";
        PredefinedCustomChart[PredefinedCustomChart["squarify"] = 4] = "squarify";
        //---- mapping ----
        PredefinedCustomChart[PredefinedCustomChart["line"] = 5] = "line";
        PredefinedCustomChart[PredefinedCustomChart["radial"] = 6] = "radial";
        PredefinedCustomChart[PredefinedCustomChart["scatter"] = 7] = "scatter";
        PredefinedCustomChart[PredefinedCustomChart["xband"] = 8] = "xband";
        PredefinedCustomChart[PredefinedCustomChart["yband"] = 9] = "yband";
        PredefinedCustomChart[PredefinedCustomChart["scatter3D"] = 10] = "scatter3D";
        //---- bins ----
        PredefinedCustomChart[PredefinedCustomChart["bar"] = 11] = "bar";
        PredefinedCustomChart[PredefinedCustomChart["column"] = 12] = "column";
        PredefinedCustomChart[PredefinedCustomChart["density"] = 13] = "density";
        PredefinedCustomChart[PredefinedCustomChart["violin"] = 14] = "violin";
        PredefinedCustomChart[PredefinedCustomChart["stacks"] = 15] = "stacks";
        PredefinedCustomChart[PredefinedCustomChart["custom"] = 16] = "custom";
    })(beachParty.PredefinedCustomChart || (beachParty.PredefinedCustomChart = {}));
    var PredefinedCustomChart = beachParty.PredefinedCustomChart;
    (function (CustomColUsage) {
        CustomColUsage[CustomColUsage["none"] = 0] = "none";
        CustomColUsage[CustomColUsage["map"] = 1] = "map";
        CustomColUsage[CustomColUsage["bin"] = 2] = "bin";
    })(beachParty.CustomColUsage || (beachParty.CustomColUsage = {}));
    var CustomColUsage = beachParty.CustomColUsage;
    (function (CustomLayout) {
        CustomLayout[CustomLayout["grid"] = 0] = "grid";
        CustomLayout[CustomLayout["map"] = 1] = "map";
        CustomLayout[CustomLayout["radial"] = 2] = "radial";
        CustomLayout[CustomLayout["random"] = 3] = "random";
        CustomLayout[CustomLayout["poisson"] = 4] = "poisson";
        CustomLayout[CustomLayout["squarify"] = 5] = "squarify";
        CustomLayout[CustomLayout["spiral"] = 6] = "spiral";
        CustomLayout[CustomLayout["stackX"] = 7] = "stackX";
        CustomLayout[CustomLayout["stackY"] = 8] = "stackY";
        CustomLayout[CustomLayout["stackZ"] = 9] = "stackZ";
    })(beachParty.CustomLayout || (beachParty.CustomLayout = {}));
    var CustomLayout = beachParty.CustomLayout;
    (function (LayoutDirection) {
        LayoutDirection[LayoutDirection["fromBottom"] = 0] = "fromBottom";
        LayoutDirection[LayoutDirection["fromLeft"] = 1] = "fromLeft";
        LayoutDirection[LayoutDirection["fromCenter"] = 2] = "fromCenter";
    })(beachParty.LayoutDirection || (beachParty.LayoutDirection = {}));
    var LayoutDirection = beachParty.LayoutDirection;
    (function (TextAlign) {
        TextAlign[TextAlign["left"] = 0] = "left";
        TextAlign[TextAlign["center"] = 1] = "center";
        TextAlign[TextAlign["right"] = 2] = "right";
    })(beachParty.TextAlign || (beachParty.TextAlign = {}));
    var TextAlign = beachParty.TextAlign;
    var CustomParams = (function () {
        function CustomParams() {
            this.xUsage = CustomColUsage.none;
            this.yUsage = CustomColUsage.none;
            this.zUsage = CustomColUsage.none;
            this.layout = CustomLayout.random;
        }
        return CustomParams;
    }());
    beachParty.CustomParams = CustomParams;
    var DataCacheParams = (function () {
        function DataCacheParams() {
            this.cacheLocalFiles = true;
            this.cacheWebFiles = true;
        }
        return DataCacheParams;
    }());
    beachParty.DataCacheParams = DataCacheParams;
    /** on client side. */
    (function (DragAction) {
        DragAction[DragAction["select"] = 0] = "select";
        DragAction[DragAction["zoomIn"] = 1] = "zoomIn";
        DragAction[DragAction["rotate"] = 2] = "rotate";
        DragAction[DragAction["move"] = 3] = "move";
        DragAction[DragAction["wheel"] = 4] = "wheel";
    })(beachParty.DragAction || (beachParty.DragAction = {}));
    var DragAction = beachParty.DragAction;
    (function (ClientTransformMode) {
        ClientTransformMode[ClientTransformMode["none"] = 0] = "none";
        ClientTransformMode[ClientTransformMode["auto"] = 1] = "auto";
        ClientTransformMode[ClientTransformMode["rotate"] = 2] = "rotate";
        ClientTransformMode[ClientTransformMode["pan"] = 3] = "pan";
        ClientTransformMode[ClientTransformMode["wheel"] = 4] = "wheel";
    })(beachParty.ClientTransformMode || (beachParty.ClientTransformMode = {}));
    var ClientTransformMode = beachParty.ClientTransformMode;
    /** effect of dragging mouse/touch on plot, on engine side of things. */
    (function (TransformMode) {
        TransformMode[TransformMode["none"] = 0] = "none";
        TransformMode[TransformMode["move"] = 1] = "move";
        TransformMode[TransformMode["spin"] = 2] = "spin";
        TransformMode[TransformMode["turn"] = 3] = "turn";
        TransformMode[TransformMode["flip"] = 4] = "flip";
        TransformMode[TransformMode["zoom"] = 5] = "zoom";
    })(beachParty.TransformMode || (beachParty.TransformMode = {}));
    var TransformMode = beachParty.TransformMode;
    (function (PanelLocation) {
        PanelLocation[PanelLocation["top"] = 0] = "top";
        PanelLocation[PanelLocation["right"] = 1] = "right";
        PanelLocation[PanelLocation["bottom"] = 2] = "bottom";
        PanelLocation[PanelLocation["left"] = 3] = "left";
    })(beachParty.PanelLocation || (beachParty.PanelLocation = {}));
    var PanelLocation = beachParty.PanelLocation;
    (function (ThemeName) {
        ThemeName[ThemeName["white"] = 0] = "white";
        ThemeName[ThemeName["black"] = 1] = "black";
    })(beachParty.ThemeName || (beachParty.ThemeName = {}));
    var ThemeName = beachParty.ThemeName;
    (function (SampleType) {
        SampleType[SampleType["first"] = 0] = "first";
        SampleType[SampleType["last"] = 1] = "last";
        SampleType[SampleType["random"] = 2] = "random";
    })(beachParty.SampleType || (beachParty.SampleType = {}));
    var SampleType = beachParty.SampleType;
    var DataSampling = (function () {
        function DataSampling(isEnabled, sampleType, sampleCount, sampleThreshold) {
            if (isEnabled === void 0) { isEnabled = true; }
            if (sampleType === void 0) { sampleType = SampleType.first; }
            if (sampleCount === void 0) { sampleCount = 1000; }
            if (sampleThreshold === void 0) { sampleThreshold = 100 * 1000; }
            this.isEnabled = isEnabled;
            this.sampleType = sampleType;
            this.sampleCount = sampleCount;
            this.samplingThreshold = sampleThreshold;
        }
        return DataSampling;
    }());
    beachParty.DataSampling = DataSampling;
    (function (AggType) {
        AggType[AggType["count"] = 0] = "count";
        AggType[AggType["sum"] = 1] = "sum";
        AggType[AggType["median"] = 2] = "median";
        AggType[AggType["average"] = 3] = "average";
        AggType[AggType["min"] = 4] = "min";
        AggType[AggType["max"] = 5] = "max";
        AggType[AggType["stdDev"] = 6] = "stdDev";
        AggType[AggType["variance"] = 7] = "variance";
    })(beachParty.AggType || (beachParty.AggType = {}));
    var AggType = beachParty.AggType;
    (function (DataChangeType) {
        DataChangeType[DataChangeType["datasetChange"] = 0] = "datasetChange";
        DataChangeType[DataChangeType["queryResults"] = 1] = "queryResults";
        DataChangeType[DataChangeType["sampleResults"] = 2] = "sampleResults";
    })(beachParty.DataChangeType || (beachParty.DataChangeType = {}));
    var DataChangeType = beachParty.DataChangeType;
    var AggRange = (function () {
        function AggRange() {
        }
        return AggRange;
    }());
    beachParty.AggRange = AggRange;
    var AggFilter = (function () {
        function AggFilter(colName, isMember, values) {
            this.colName = colName;
            this.isMember = isMember;
            this.values = values;
        }
        return AggFilter;
    }());
    beachParty.AggFilter = AggFilter;
    var DataAggregation = (function () {
        function DataAggregation(aggType, targetCol, groupCols) {
            this.aggType = aggType;
            this.targetCol = targetCol;
            this.groupCols = groupCols;
            this.aggFilters = [];
        }
        return DataAggregation;
    }());
    beachParty.DataAggregation = DataAggregation;
    var AggResult = (function () {
        function AggResult() {
        }
        return AggResult;
    }());
    beachParty.AggResult = AggResult;
    //---- this is specified per column (in pre-query) ----
    (function (nanAction) {
        /** leave NAN values in place */
        nanAction[nanAction["none"] = 0] = "none";
        /** omit records where NAN values are found for this column */
        nanAction[nanAction["omitRecord"] = 1] = "omitRecord";
        /** replace NAN with value linearly interpolated between last/next records with true value */
        nanAction[nanAction["interpolate"] = 2] = "interpolate";
        /** replace NAN with 0 */
        nanAction[nanAction["setToZero"] = 3] = "setToZero";
        /** replace NAN with the user-specified "NAN replacement" value */
        nanAction[nanAction["setToFixedValue"] = 4] = "setToFixedValue";
        /** replace NAN with the MINIMUM value of this column */
        nanAction[nanAction["setToMin"] = 5] = "setToMin";
        /** replace NAN with the MAXIMUM value of this column */
        nanAction[nanAction["setToMax"] = 6] = "setToMax";
        /** replace NAN with the MEAN (average) value of this column */
        nanAction[nanAction["setToMean"] = 7] = "setToMean";
        /** replace NAN with the MEDIAN (middle) value of this column */
        nanAction[nanAction["setToMediam"] = 8] = "setToMediam";
        /** replace NAN with the MODE (most occuring) value of this column */
        nanAction[nanAction["setToMode"] = 9] = "setToMode";
    })(beachParty.nanAction || (beachParty.nanAction = {}));
    var nanAction = beachParty.nanAction;
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    baseLayout.ts - base class for layouts.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** information needed to draw a facet/chart. */
    var baseLayoutClass = (function () {
        function baseLayoutClass(chart, layoutName, chartOptions) {
            if (chartOptions === void 0) { chartOptions = {}; }
            this._is3dChart = false;
            this._visibleColPickers = "";
            this._visibleBinAdjusters = "";
            this._chart = chart;
            this._layoutName = layoutName;
            this._animationData = chart.animationData();
            this._chartBuilder = chart.getChartBuilder();
            this._chartOptions = chartOptions;
            //---- default to showing axes ----
            this._chartBuilder.hideAxes(false);
            this._chartBuilder.isXAxisClickable(true);
            this._chartBuilder.isYAxisClickable(true);
            //---- reset to default transform ----
            var transformMgr = this._chartBuilder.getTransformMgr();
            transformMgr.resetTransform();
        }
        baseLayoutClass.prototype.getIs3dChart = function () {
            return this._is3dChart;
        };
        baseLayoutClass.prototype.getVisibleColPickers = function () {
            return this._visibleColPickers;
        };
        baseLayoutClass.prototype.getVisibleBinAdjusters = function () {
            return this._visibleBinAdjusters;
        };
        baseLayoutClass.prototype.buildScales = function (nv, rcxWorld, filteredRecordCount, facetCount) {
            return this._chartBuilder.buildDefaultScales(nv, rcxWorld, filteredRecordCount, facetCount);
        };
        baseLayoutClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var maxItems = beachParty.cbUtils.getDataLength(dc.nvData, true);
            return maxItems;
        };
        baseLayoutClass.prototype.preLayoutLoop = function (dc) {
        };
        /** to be overwritten by subclass, where appropriated. */
        baseLayoutClass.prototype.adjustScales = function (dc) {
        };
        baseLayoutClass.prototype.layoutDataForRecord = function (i, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            dr.x = beachParty.chartUtils.scaleColData(nv.x, i, scales.x);
            dr.y = beachParty.chartUtils.scaleColData(nv.y, i, scales.y);
            dr.z = beachParty.chartUtils.scaleColData(nv.z, i, scales.z);
            dr.width = beachParty.chartUtils.scaleColData(nv.size, i, scales.size, 1);
            dr.height = dr.width;
            dr.depth = dr.width;
            dr.colorIndex = beachParty.chartUtils.scaleColData(nv.colorIndex, i, scales.colorIndex);
            //colorIndex = Math.floor(colorIndex);
            dr.imageIndex = beachParty.chartUtils.scaleColData(nv.imageIndex, i, scales.imageIndex);
        };
        baseLayoutClass.prototype.scaleColData = function (vector, index, scale, defaultValue) {
            if (defaultValue === void 0) { defaultValue = 0; }
            return beachParty.chartUtils.scaleColData(vector, index, scale, defaultValue);
        };
        return baseLayoutClass;
    }());
    beachParty.baseLayoutClass = baseLayoutClass;
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chart.ts - defines a SandDance chart (axes, plot, and other layers) and the user
//               interaction (tooltips, datatips, drag selection, drag transformations)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var chartClass = (function (_super) {
        __extends(chartClass, _super);
        /// allow for app==null, for custom builds of SandDance.
        function chartClass(app, dataMgr, divElem, isVisible) {
            var _this = this;
            if (isVisible === void 0) { isVisible = true; }
            _super.call(this);
            this._selectMode = beachParty.SelectMode.smartToggle;
            this._cmdId = "";
            //---- DATA properties ----
            this._origColInfos = []; // full set of original columns from table
            this._colInfos = []; // set of FILTERED or SCRUBBED columns (as per preLoad)
            this._recordCount = 0;
            this._filename = "";
            this._selectedCount = 0;
            this._filteredInCount = 0;
            this._selection = [];
            //private _selectedRecords: any[] = [];
            this._isSelectionLocked = false;
            //---- sorting ----
            this._sortItemCol = null;
            this._isItemSortAscending = true;
            this._lastScatterXCol = null;
            this._lastScatterYCol = null;
            this._isChartCustom = false;
            this._customParams = new beachParty.CustomParams();
            this._customSpec = "mx";
            //---- this controls spacing between shapes in layout-type views (work in progress) ----
            this._sizeFactor = .98; // change also in: ViewSettings
            this._separationFactor = .5;
            this._isOrthoCamera = false;
            this._useFacets = false;
            this._lastHoverPos = null;
            this._isVisible = false;
            this._layoutsByChart = {};
            this._toPercentOverride = undefined;
            this._isAnimOverride = false;
            this._isTransformMode = false;
            this._isDataZoomMode = false;
            this._wheelDownTime = 0;
            this._dtMouseDown = 0;
            this._spiralParams = new beachParty.SpiralParams();
            this._prevChartType = null;
            this._autoRebuild = true;
            this._rcPlot = vp.geom.createRect(0, 0, 100, 100);
            this._chartSettings = {};
            this._isEngineDrawing = false;
            this._textOpacity = .5;
            this._maxToolTipColumns = 18; // at 20, we seem to run into a browser limit on total tooltip size
            this._topOfChartUx = 0; // used for EXTENDING the top of chartUX to allow dragging from empty area
            this._deltaOfChartUx = 0; // how much it was extended
            this._showItemCounts = false;
            this._showTitleText = false;
            this._titleText = "";
            this._dragAction = beachParty.DragAction.select;
            this._shapeOpacity = chartClass.defaultOpacity;
            this._canvasColor = "none";
            this._chartColor = "none";
            this._drawingPrimitive = beachParty.DrawPrimitive.cube;
            this._isContinuousDrawing = false;
            this._isTooltipsEnabled = false;
            this._is3dGridAlwaysOn = false;
            this._isWheelInertia = true;
            this._showWheelDuringTransformMode = false;
            this._isLightingAlwaysOn = false;
            this._lightingParams = new beachParty.Lighting();
            this._useNiceNumbers = false;
            this._maxItemCount = 100 * 1000;
            this._isMaxItemCountEnabled = false;
            this._defaultShapeSize = undefined; // when defined, this overrides system's calc for best shape size
            //---- events ----
            this.onActionDectected = new beachParty.bpEvent();
            this.onAttrColNameChange = new beachParty.bpEvent();
            this.onSearchStarted = new beachParty.bpEvent();
            this.onCycleStart = new beachParty.bpEvent();
            this.onCycleEnd = new beachParty.bpEvent();
            this._app = app;
            this._dataMgr = dataMgr;
            this._isVisible = isVisible;
            this._chartSpecs = new beachParty.ChartSpecs(beachParty.ChartType.Random);
            var appSettingsMgr = this._app.getAppSettingsMgr();
            //---- first chart to be created should add the beachParty.css text as a style sheet ----
            if (!chartClass.addedBeachPartyCss) {
                this.addBeachPartyCss();
                chartClass.addedBeachPartyCss = true;
            }
            this._scatterParams = new beachParty.ScatterParams();
            this._flatParams = new beachParty.FlatParams();
            //---- this needs more work (when app in ready) ----
            //dataMgr.onDataChange.attach(this, (e) =>
            //{
            //    this.processDataChange(e.changeFlags);
            //    this.markBuildNeeded("dataChanged");
            //});
            dataMgr.registerForChange("dataFrame", function (e) {
                //this.processDataChange(e.changeFlags);
                //this.markBuildNeeded("dataChanged");
                _this.onDataLoaded();
            });
            dataMgr.registerForChange("selection", function (e) {
                _this.onSelectionChanged();
            });
            dataMgr.registerForChange("filtered", function (e) {
                _this.onFilteredChanged();
            });
            this._lastScatterXCol = null;
            this._lastScatterYCol = null;
            if (appSettingsMgr) {
                //---- use PERSISTED values for properties ----
                this._animationData = appSettingsMgr.animationData();
                this._chartFrameData = appSettingsMgr.getChartFrameData();
                this._hoverParams = appSettingsMgr.getHoverParams();
                this._selectionParams = appSettingsMgr.getSelectionParams();
                this._shapeOpacity = appSettingsMgr.shapeOpacity();
                this._instancingParams = appSettingsMgr.getInstancingParams();
            }
            else {
                //---- use DEFAULT values for properties ----
                this._animationData = new beachParty.AnimationData();
                this._chartFrameData = new beachParty.ChartFrameData();
                this._hoverParams = new beachParty.HoverParams();
                this._selectionParams = new beachParty.SelectionParams();
                this._shapeOpacity = chartClass.defaultOpacity;
                this._instancingParams = new beachParty.InstancingParams();
            }
            this._vsCurrent = this.createViewSettings();
            this.buildAttributes();
            this.buildChartHtml(divElem, isVisible);
            //this._rotateRing = new rotateRingClass(this);
            this._chartBuilder = new beachParty.chartBuilderClass(this._clientElem, this);
            this._facetMgr = new beachParty.facetLabelMgrClass(this, this._facetLabelHolderElem);
            this._chartBuilder.registerForChange("facetLayoutChanged", function (e) {
                var facetLayouts = _this._chartBuilder.getFacetLayoutsInPixels();
                _this._facetMgr.buildLabels(facetLayouts);
            });
            this._chartBuilder.onCycleStart.attach(this, function (cd) {
                _this._isEngineDrawing = true;
                _this.onCycleStart.trigger(cd);
            });
            this._chartBuilder.onCycleEnd.attach(this, function (cs) {
                _this._isEngineDrawing = false;
                cs.cmdId = _this._cmdId;
                cs.cmdTime = 0;
                _this.onCycleEnd.trigger(cs);
            });
            var transformMgr = this._chartBuilder.getTransformMgr();
            this._chartUx.postInit(transformMgr);
            this._chartEng = new beachParty.chartEngClass(this, this._chartBuilder, dataMgr);
            this._chartBuilder.registerForChange("plotBounds", function (e) {
                var rcPlot = _this._chartBuilder.getPlotBounds(true);
                var rcRotateRing = null; // todo: supply this from wheel mgr
                _this.onPlotMoved(rcPlot, rcRotateRing);
            });
            //---- this will processs the initial data ----
            if (this.hasData()) {
                this.processDataChange(beachParty.DataChangeFlags.dataSetChange);
            }
        }
        chartClass.prototype.createViewSettings = function () {
            var settings = this._app.getAppSettingsMgr();
            if (settings) {
                var vs = new ViewSettings(settings.shapeColor(), settings.shapeOpacity());
            }
            else {
                var vs = new ViewSettings();
            }
            return vs;
        };
        chartClass.prototype.getChartUx = function () {
            return this._chartUx;
        };
        chartClass.prototype.hoverPrimaryKey = function (value) {
            if (arguments.length == 0) {
                return this._hoverPrimaryKey;
            }
            if (value != this._hoverPrimaryKey) {
                this._hoverPrimaryKey = value;
                this.onDataChanged("hoverPrimaryKey");
                this.markDrawNeeded("setHoverItem");
            }
        };
        chartClass.prototype.getHoverParams = function () {
            return this._hoverParams;
        };
        chartClass.prototype.autoLoadFile = function (wdp, callback) {
            return this._chartEng.autoLoadFile(wdp, callback);
        };
        chartClass.prototype.applyHover = function (x, y, returnRecord, columnList, showHover, callback) {
            return this._chartEng.applyHover(x, y, returnRecord, columnList, showHover, callback);
        };
        chartClass.prototype.getBinData = function (md, callback) {
            return this._chartEng.getBinData(md, callback);
        };
        chartClass.prototype.testApis = function () {
            //---- test chart API's here ----
            //this.showAxes(false);
            //this.showXGridLines(true);
            //this.showYGridLines(true);
            //this.showAxisTickLabels(false);
            this.enableTwoFingerSwipe(true);
            setTimeout(function (e) {
                //this.axisLabelStyle("fill: red; font-size: 35px");
                //this.showTitleText(false);
                //this.showItemCounts(false);
            }, 1000);
        };
        chartClass.prototype.selectFacetBox = function (index) {
            this._facetMgr.selectFacetLabel(index);
        };
        chartClass.prototype.getIndexOfFacetLabel = function (label) {
            return this._facetMgr.getIndexOfLabel(label);
        };
        chartClass.prototype.animationData = function (value) {
            if (arguments.length == 0) {
                return this._animationData;
            }
            this._animationData = value;
            this.onDataChanged("animationData");
            //---- don't need to trigger a build if this changed ----
            //this.markBuildNeeded("animationData");
        };
        chartClass.prototype.getVisibleColPickers = function () {
            var layout = this._chartBuilder.getLayout();
            var vis = (layout) ? layout.getVisibleColPickers() : "";
            return vis;
        };
        chartClass.prototype.getVisibleBinAdjusters = function () {
            var layout = this._chartBuilder.getLayout();
            var vis = (layout) ? layout.getVisibleBinAdjusters() : "";
            return vis;
        };
        chartClass.prototype.getChartBuilder = function () {
            return this._chartBuilder;
        };
        /**
         * Request a new chart drawing/animation cycle.
         * @param reason
         */
        chartClass.prototype.markBuildNeeded = function (reason) {
            if (this._isVisible) {
                this._chartBuilder.markBuildNeeded(reason);
            }
        };
        /**
         * Request a chart single frame draw (usually for operations like changing hover or size factor).
         * @param reason
         */
        chartClass.prototype.markDrawNeeded = function (reason) {
            if (this._isVisible) {
                this._chartBuilder.redrawLastFrame(reason);
            }
        };
        chartClass.prototype.getRotateRingBounds = function () {
            return this._rcRotateRing;
        };
        chartClass.prototype.getUseNiceNumbers = function () {
            return this._useNiceNumbers;
        };
        chartClass.prototype.getIsDataZoomMode = function () {
            return this._isDataZoomMode;
        };
        chartClass.prototype.enableSelectionSharing = function (value) {
            //this._bpsHelper.enableSelectionSharing(value);
        };
        chartClass.prototype.setPresentationMode = function (value) {
            if (value) {
                var regOptions = { showItemCounts: this._showItemCounts, showTitleText: this.showTitleText };
                this.regOptions(regOptions);
                //---- hide ITEM COUNTS ----
                this.showItemCounts(false);
                //---- show TITLE TEXT ----
                this.showTitleText(true);
                //---- CENTER and adjust-up the titlePanel ----
                vp.select("#titlePanel")
                    .css("text-align", "center")
                    .css("margin-top", "-15px")
                    .css("margin-bottom", "18px");
            }
            else {
                var regOptions = this.regOptions();
                //---- show ITEM COUNTS ----
                this.showItemCounts(regOptions.showItemCounts);
                //---- center TITLE ----
                this.showTitleText(regOptions.showTitleText);
                //---- LEFT-ALIGN and adjust-down the titlePanel ----
                vp.select("#titlePanel")
                    .css("text-align", "left")
                    .css("margin-top", "0")
                    .css("margin-bottom", "0");
            }
        };
        chartClass.prototype.getViewName = function () {
            return this._chartSpecs.getChartName();
        };
        //getSelectedRecords()
        //{
        //    return this._selectedRecords;
        //}
        //getSelectedKeys()
        //{
        //    var keys = this._selectedRecords.map((record) => record["_primaryKey"]);
        //    return keys;
        //}
        //setSelectedRecords(records: any[])
        //{
        //    this._selectedRecords = records;
        //}
        chartClass.prototype.getSelectedCount = function () {
            return this._selectedCount;
        };
        chartClass.prototype.setSelectedCount = function (value) {
            this._selectedCount = value;
        };
        chartClass.prototype.openKnownFile = function (fileName) {
            this._dataMgr.openKnownFile(fileName, false);
        };
        chartClass.prototype.isMaxItemCountEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isMaxItemCountEnabled;
            }
            this._isMaxItemCountEnabled = value;
            this.onDataChanged("isMaxItemCountEnabled");
        };
        chartClass.prototype.staggerForward = function (value) {
            if (arguments.length == 0) {
                return this._animationData.isStaggerForward;
            }
            this._animationData.isStaggerForward = value;
            this.onAnimationDataChanged();
            this.onDataChanged("staggerForward");
        };
        chartClass.prototype.scatterParams = function (value) {
            if (arguments.length == 0) {
                return this._scatterParams;
            }
            this._scatterParams = value;
            this.onDataChanged("scatterParams");
        };
        chartClass.prototype.defaultShapeSize = function (value) {
            if (arguments.length == 0) {
                return this._defaultShapeSize;
            }
            this._defaultShapeSize = value;
            this.onDataChanged("defaultShapeSize");
        };
        chartClass.prototype.getTransformer = function () {
            return this._chartBuilder.getTransformer();
        };
        chartClass.prototype.xAttr = function () {
            return this._xAttr;
        };
        chartClass.prototype.yAttr = function () {
            return this._yAttr;
        };
        chartClass.prototype.zAttr = function () {
            return this._zAttr;
        };
        chartClass.prototype.auxAttr = function () {
            return this._auxAttr;
        };
        chartClass.prototype.colorAttr = function () {
            return this._colorAttr;
        };
        chartClass.prototype.sizeAttr = function () {
            return this._sizeAttr;
        };
        chartClass.prototype.shapeAttr = function () {
            return this._shapeAttr;
        };
        chartClass.prototype.textAttr = function () {
            return this._textAttr;
        };
        chartClass.prototype.facetAttr = function () {
            return this._facetAttr;
        };
        chartClass.prototype.xMapping = function () {
            return this._xAttr.mappingData.apply(this._xAttr, arguments);
        };
        chartClass.prototype.yMapping = function () {
            return this._yAttr.mappingData.apply(this._yAttr, arguments);
        };
        chartClass.prototype.zMapping = function () {
            return this._zAttr.mappingData.apply(this._zAttr, arguments);
        };
        chartClass.prototype.auxMapping = function () {
            return this._auxAttr.mappingData.apply(this._auxAttr, arguments);
        };
        chartClass.prototype.colorMapping = function () {
            return this._colorAttr.mappingData.apply(this._colorAttr, arguments);
        };
        chartClass.prototype.sizeMapping = function () {
            return this._sizeAttr.mappingData.apply(this._sizeAttr, arguments);
        };
        chartClass.prototype.shapeMapping = function () {
            return this._shapeAttr.mappingData.apply(this._shapeAttr, arguments);
        };
        chartClass.prototype.facetMapping = function () {
            return this._facetAttr.mappingData.apply(this._facetAttr, arguments);
        };
        chartClass.prototype.textMapping = function () {
            return this._textAttr.mappingData.apply(this._textAttr, arguments);
        };
        chartClass.prototype.maxItemCount = function (value) {
            if (arguments.length == 0) {
                return this._maxItemCount;
            }
            this._maxItemCount = value;
            this.onDataChanged("maxItemCount");
        };
        chartClass.prototype.isSelectionLocked = function (value) {
            if (arguments.length == 0) {
                return this._isSelectionLocked;
            }
            this._isSelectionLocked = value;
            this.onDataChanged("isSelectionLocked");
        };
        chartClass.prototype.getColInfos = function () {
            return this._colInfos;
        };
        chartClass.prototype.setColInfos = function (value) {
            this._colInfos = value;
        };
        chartClass.prototype.getOrigColInfos = function () {
            return this._origColInfos;
        };
        chartClass.prototype.getPreload = function () {
            return this._preload;
        };
        chartClass.prototype.onDataLoaded = function () {
            var dataMgr = this._dataMgr;
            var dataFrame = dataMgr.getDataFrame();
            var preload = dataMgr.getPreload();
            var dataChangeType = (preload) ? preload.dataChangeType
                : beachParty.DataChangeType.datasetChange;
            //---- tell current chart to change its data ----
            //this._chartRouter.setData(dataFrame, preload);
            var fn = preload.dataName;
            var recordCount = dataFrame.getRecordCount();
            var colInfos = dataMgr.getColInfos(true);
            var origColInfos = dataMgr.getOrigColInfos();
            this._filename = fn;
            this._recordCount = recordCount;
            this._colInfos = colInfos;
            this._origColInfos = origColInfos;
            this._preload = preload;
            //vp.utils.debug("DATAFRAME msg received: recordCount=" + this._recordCount + ", filename=" + this._filename);
            this._selectedCount = 0;
            this._filteredInCount = this._recordCount;
            this.titleText(fn); // title defaults to name of file
            //---- this will tell the app data has changes which will eventually call chart.resetMappingsForNewFile() ----
            this.onDataChanged("dataFrame");
            //---- not needed - this get triggered many times in course of calling chart.resetMappingsForNewFile()  ----
            //this.markBuildNeeded("dataChanged");
        };
        chartClass.prototype.getRecordCount = function () {
            return this._recordCount;
        };
        chartClass.prototype.getFilteredInCount = function () {
            return this._filteredInCount;
        };
        chartClass.prototype.getFileName = function () {
            return this._filename;
        };
        chartClass.prototype.getAppMin = function () {
            return this._app;
        };
        chartClass.prototype.enableTickBoxUI = function (value) {
            vp.utils.debug("enableTickBoxUI: " + value);
            var pe = (value) ? "auto" : "none";
            this.addStyleSheet(".vpxAxisTickBox {pointer-events: " + pe + ";}");
        };
        chartClass.prototype.processDataChange = function (changeFlags) {
            vp.utils.debug("chart.setData called");
            if (changeFlags & beachParty.DataChangeFlags.dataSetChange) {
                var dataFrame = this._dataMgr.getDataFrame();
                var wdParams = new beachParty.WorkingDataParams(dataFrame.getFileName());
                wdParams.forceDataLoad = ((changeFlags & beachParty.DataChangeFlags.dataSetChange) != 0);
                this.onDataLoaded();
            }
            this.markBuildNeeded("dataChanged");
        };
        chartClass.prototype.setChartDebugInfo = function (value) {
        };
        chartClass.prototype.enableTwoFingerSwipe = function (value) {
            this._chartUx.uxMode((value) ? beachParty.UxMode.touch : beachParty.UxMode.rubberBand);
        };
        chartClass.prototype.isEngineDrawing = function () {
            return this._isEngineDrawing;
        };
        chartClass.prototype.selectMode = function (value) {
            if (arguments.length === 0) {
                return this._selectMode;
            }
            this._selectMode = value;
            this.onDataChanged("selectMode");
        };
        chartClass.prototype.textOpacity = function (value) {
            if (arguments.length === 0) {
                return this._textOpacity;
            }
            this._textOpacity = value;
            this.markBuildNeeded("textOpacityChanged");
            this.onDataChanged("textOpacity");
        };
        chartClass.prototype.toPercentOverride = function (value) {
            if (arguments.length === 0) {
                return this._toPercentOverride;
            }
            if (value != this._toPercentOverride) {
                this._toPercentOverride = value;
                this.markBuildNeeded("toPercentOverrideChanged");
                this.onDataChanged("toPercentOverride");
            }
        };
        chartClass.prototype.clearAxisBoxStuff = function () {
            this._axisBoxAttribute = null;
            this._axisBoxKeys = null;
        };
        chartClass.prototype.setDataAndSystemView = function (data, preload, svd, callback) {
            return this._chartEng.setDataAndSystemView(data, preload, svd, callback);
        };
        chartClass.prototype.search = function (colName, value, maxValue, searchType, searchAction, searchRawValues, caseSensitive, selectMode, callback, selectKey) {
            if (searchType === void 0) { searchType = beachParty.TextSearchType.contains; }
            if (searchAction === void 0) { searchAction = beachParty.SearchAction.selectMatches; }
            if (selectMode == undefined) {
                selectMode = this._selectMode;
            }
            return this._chartEng.search(colName, value, maxValue, searchType, searchAction, searchRawValues, caseSensitive, selectMode, callback, selectKey);
        };
        chartClass.prototype.searchEx = function (spList, selectKey, callback) {
            return this._chartEng.searchEx(spList, selectKey, callback);
        };
        chartClass.prototype.processSelectKey = function (selectMode, selectKey) {
            if (selectMode != beachParty.SelectMode.smartToggle) {
                this.clearAxisBoxStuff();
            }
            else {
                selectMode = beachParty.SelectMode.additive; // the default
                if (!selectKey) {
                    this._axisBoxAttribute = null;
                    this._axisBoxKeys = null;
                }
                else {
                    var parts = selectKey.split(".");
                    var attr = parts[0];
                    var key = parts[1];
                    if (attr != this._axisBoxAttribute) {
                        //---- start a new session with this as the first click ----
                        this._axisBoxAttribute = attr;
                        this._axisBoxKeys = {};
                        this._axisBoxKeys[key] = 1;
                    }
                    else {
                        //---- we are within a session of clicks for axis ATTR ----
                        if (this._axisBoxKeys[key] === undefined) {
                            //--- FIRST time clicking on this key within this session ----
                            this._axisBoxKeys[key] = 1;
                        }
                        else {
                            //--- SECOND time clicking on this key within this session ----
                            selectMode = beachParty.SelectMode.subtractive;
                            delete this._axisBoxKeys[key];
                        }
                    }
                }
            }
            return selectMode;
        };
        chartClass.prototype.doSearch = function (legendSource, colName, minValue, maxValue, searchType, selectMode, selectKey) {
            if (selectMode === undefined) {
                selectMode = this._selectMode;
            }
            //---- tell app we are doing a search ----
            var sd = new beachParty.SelectionDesc();
            sd.searchParams = sp;
            sd.legendSource = legendSource;
            sd.selectMode = selectMode;
            var selectionDesc = sd;
            this.onSearchStarted.trigger({ sender: this, selectionDesc: sd });
            var sp = new beachParty.SearchParams();
            sp.colName = colName;
            sp.minValue = minValue;
            sp.maxValue = maxValue;
            sp.selectMode = selectMode;
            sp.searchType = searchType;
            this.searchEx([sp], selectKey);
        };
        chartClass.prototype.isolateSelection = function (callback) {
            this._dataMgr.isolateSelection();
            this.markBuildNeeded("isolate");
        };
        chartClass.prototype.excludeSelection = function (callback) {
            this._dataMgr.excludeSelection();
            this.markBuildNeeded("exclude");
        };
        chartClass.prototype.resetFilter = function (callback) {
            this._dataMgr.resetFilter();
            this.markBuildNeeded("resetFilter");
            //---- callback should be called after data has been changed ----
            if (callback) {
                callback({ sender: this });
            }
        };
        chartClass.prototype.cursorHitTestLoc = function (value) {
            if (arguments.length == 0) {
                var cht = this._cursorHitTestLoc;
                var str = (cht) ? ("{x: " + Math.round(cht.x) + ", y: " + Math.round(cht.y) + "}") : "";
                return str;
            }
            this._cursorHitTestLoc = value;
            this.onDataChanged("cursorHitTestLoc");
        };
        chartClass.prototype.getSelectionParams = function () {
            return this._selectionParams;
        };
        chartClass.prototype.cursorHitTestShape = function (value) {
            if (arguments.length == 0) {
                var str = (this._cursorHitTestShape) ? this._cursorHitTestShape : "";
                return str;
            }
            this._cursorHitTestShape = value;
            this.onDataChanged("cursorHitTestShape");
        };
        chartClass.prototype.showClientFrame = function (value) {
            if (arguments.length == 0) {
                return this._showClientFrame;
            }
            this._showClientFrame = value;
            vp.select(this._clientElem).css("border", (value) ? "1px solid yellow" : "0");
            this.onDataChanged("showClientFrame");
        };
        chartClass.prototype.showGlCanvasFrame = function (value) {
            if (arguments.length == 0) {
                return this._showGlCanvasFrame;
            }
            this._showGlCanvasFrame = value;
            var glCanvasElem = this._chartBuilder.getGlCanvasElem();
            vp.select(glCanvasElem).css("border", (value) ? "1px solid green" : "0");
            this.onDataChanged("showGlCanvasFrame");
        };
        chartClass.prototype.showChartUxFrame = function (value) {
            if (arguments.length == 0) {
                return this._showChartUxFrame;
            }
            this._showChartUxFrame = value;
            vp.select(this._uxElem).css("border", (value) ? "1px solid red" : "0");
            this.onDataChanged("showChartUxFrame");
        };
        chartClass.prototype.showRing = function () {
            //this._currentChart.getPlotBounds((msgBlock) =>
            //{
            //    this._rotateRing.setRotationBounds(msgBlock.rcRotateRing);
            //});
            this._rotateRing.enter();
        };
        chartClass.prototype.getActualToolTipColumns = function () {
            var colNames = this.tooltipColumns();
            //---- if not columns explictly set, use columns in-use by chart ----
            if (colNames == null || colNames.length == 0) {
                colNames = this.getMappedColumns();
            }
            //---- if chart not using any columns, use all columns ----
            if (colNames == null || colNames.length == 0) {
                colNames = this._dataMgr.getDataFrame().getColumnNames();
                //---- filter out system columns ----
                colNames = colNames.filter(function (colName) { return !colName.startsWith("_"); });
            }
            return colNames;
        };
        chartClass.prototype.tooltipColumns = function (value) {
            if (arguments.length == 0) {
                return this._tooltipColumns;
            }
            this._tooltipColumns = value;
            this.onDataChanged("tooltipColumns");
        };
        chartClass.prototype.isItemSortAscending = function (value, tellEngine) {
            if (tellEngine === void 0) { tellEngine = true; }
            if (arguments.length === 0) {
                return this._isItemSortAscending;
            }
            if (value != this._isItemSortAscending) {
                this._isItemSortAscending = value;
                if (tellEngine) {
                    this.onSortParmsChanged(true);
                }
                this.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.sortParams, true, { ascending: value });
                this.onDataChanged("isItemSortAscending");
            }
        };
        chartClass.prototype.setSelectionWithKeys = function (keys) {
            var dataFrame = this._dataMgr.getDataFrame();
            var primaryKeys = dataFrame.getPrimaryKeys(keys, beachParty.VectorType.primaryKeyList);
            this._dataMgr.setSelectionDirect(primaryKeys, null);
        };
        chartClass.prototype.sortItemColumn = function (value, tellEngine) {
            if (tellEngine === void 0) { tellEngine = true; }
            if (arguments.length === 0) {
                return this._sortItemCol;
            }
            if (value != this._sortItemCol) {
                this._sortItemCol = value;
                this.onSortParmsChanged(tellEngine);
                this.onDataChanged("sortItemColumn");
                this.logAction(beachParty.Gesture.select, "sortItemColumn", beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.sortItemColumn, true, null, false, { value: value });
            }
        };
        chartClass.prototype.onSortParmsChanged = function (tellEngine) {
            var _this = this;
            if (tellEngine) {
                //---- put on a timer so we can combine multiple changes to sort params ----
                setTimeout(function (e) {
                    _this._dataMgr.sortData(_this._sortItemCol, _this._isItemSortAscending);
                    _this.markBuildNeeded("sortParamsChanged");
                }, 1);
            }
            this.onDataChanged("sortParams");
        };
        chartClass.prototype.sortIfNeeded = function (colName, isDescending) {
            this.sortItemColumn(colName);
            this.isItemSortAscending(!isDescending);
        };
        chartClass.prototype.isItemSortByColor = function (value) {
            var colName = this._colorAttr.colName();
            if (arguments.length === 0) {
                return (colName == this._sortItemCol);
            }
            if (value) {
                this._sortItemCol = colName;
            }
            else {
                this._sortItemCol = this._lastScatterYCol;
            }
            this.onSortParmsChanged(true);
            this.onDataChanged("isItemSortByColor");
        };
        chartClass.prototype.toggleWheel = function () {
            if (this._dragAction == beachParty.DragAction.select) {
                this.dragAction("wheel");
                vp.select("#wheelButton").attr("data-selected", "true");
            }
            else {
                this.dragAction("select");
                vp.select("#wheelButton").attr("data-selected", "false");
            }
        };
        chartClass.prototype.dragAction = function (value) {
            if (arguments.length == 0) {
                return beachParty.DragAction[this._dragAction];
            }
            this._dragAction = beachParty.DragAction[value];
            var useWheel = (value == "rotate" || value == "move" || value == "wheel");
            //this._chartUx.uxMode((useWheel) ? UxMode.wheel : UxMode.touch);
            var tm = beachParty.ClientTransformMode.none;
            if (value == "rotate") {
                tm = beachParty.ClientTransformMode.rotate;
            }
            else if (value == "move") {
                tm = beachParty.ClientTransformMode.pan;
            }
            else if (value == "wheel") {
                tm = beachParty.ClientTransformMode.wheel;
            }
            this.markBuildNeeded("setTransformMode");
            this.onDataChanged("dragAction");
            this._chartUx.getTouchMgr().isShowingWheel(value == "wheel");
        };
        chartClass.prototype.numColumns = function (value) {
            if (arguments.length == 0) {
                return this._flatParams.numColumns;
            }
            this._flatParams.numColumns = value;
            this.onFlatParamsChanged();
            this.onDataChanged("numColumns");
            this.logAction(beachParty.Gesture.select, "numColumns", beachParty.ElementType.numAdjuster, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { numColumns: value });
        };
        chartClass.prototype.useNiceNumbers = function (value) {
            if (arguments.length == 0) {
                return this._useNiceNumbers;
            }
            this._useNiceNumbers = value;
            this.onDataChanged("useNiceNumbers");
        };
        chartClass.prototype.pulse3DCircleIfAppropriate = function () {
            var settings = this._app.getAppSettingsMgr();
            //---- if in transform mode, but not showing wheel, pulse the ring to remind user where it is ----
            if (this._isTransformMode && !settings._showWheelDuringTransformMode) {
                this._rotateRing.pulse();
            }
        };
        chartClass.prototype.isTransformMode = function () {
            return this._isTransformMode;
        };
        chartClass.prototype.mapByColorChannels = function (value) {
            if (arguments.length == 0) {
                return this._mapByColorChannels;
            }
            this._mapByColorChannels = value;
            this.onDataChanged("mapByColorChannels");
        };
        chartClass.prototype.shapeColor = function (value, omitProcessing) {
            if (arguments.length === 0) {
                return this._shapeColor;
            }
            this._shapeColor = value;
            this._vsCurrent.shapeColor = value;
            if (!omitProcessing) {
                this.logAction(beachParty.Gesture.select, "shapeColor", beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { shapeColor: value });
                this.onShapeColorChanged();
            }
        };
        chartClass.prototype.onShapeColorChanged = function () {
            var cr = beachParty.cbUtils.getBeachPartyColor(this._shapeColor);
            this.markBuildNeeded("setShapeColor");
            var colorAttr = this._colorAttr;
            if (colorAttr) {
                colorAttr.colName(null);
                colorAttr.onMappingChanged(false);
            }
            this.onDataChanged("shapeColor");
        };
        chartClass.prototype.hasData = function () {
            var dataFrame = this.getDataFrame();
            return (this._dataMgr != null && dataFrame.getRecordCount() > 0);
        };
        chartClass.prototype.shapeImage = function (value, omitProcessing) {
            if (arguments.length === 0) {
                return this._shapeImage;
            }
            if (value != this._shapeImage) {
                this._shapeImage = value;
                this._vsCurrent.shapeName = value;
                if (!omitProcessing) {
                    this.onShapeImageChanged();
                    this.logAction(beachParty.Gesture.select, "shapeImage", beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { shapeImage: value });
                }
            }
        };
        chartClass.prototype.getLayoutName = function () {
            return this._chartSpecs.getLayoutName();
        };
        chartClass.prototype.layoutType = function () {
            return this._chartSpecs.layoutType();
        };
        chartClass.prototype.onShapeImageChanged = function () {
            this.markBuildNeeded("setShapeImage");
            this.onDataChanged("shapeImage");
        };
        chartClass.prototype.chartColor = function (value) {
            if (arguments.length === 0) {
                return this._chartColor;
            }
            this._chartColor = value;
            this.onChartColorChanged();
        };
        chartClass.prototype.onChartColorChanged = function () {
            var value = beachParty.cbUtils.getBeachPartyColor(this._chartColor);
            vp.select(this._root)
                .css("background", value);
            this.markBuildNeeded("setChartBackground");
            this.onDataChanged("chartColor");
        };
        chartClass.prototype.canvasColor = function (value) {
            if (arguments.length === 0) {
                return this._canvasColor;
            }
            this._canvasColor = value;
            this.onCanvasColorChanged();
        };
        chartClass.prototype.onCanvasColorChanged = function () {
            var cr = beachParty.cbUtils.getBeachPartyColor(this._canvasColor);
            this.markBuildNeeded("setPlotBackground");
            this.onDataChanged("canvasColor");
        };
        chartClass.prototype.getSpiralSeed = function () {
            return this._spiralParams.seed;
        };
        chartClass.prototype.setSpiralSeed = function (seed) {
            if (seed === undefined) {
                seed = 180 * Math.random();
            }
            this._spiralParams.seed = seed;
            this.markBuildNeeded("setSpiralParams");
            this.logAction(beachParty.Gesture.click, "nextSpiral", beachParty.ElementType.button, beachParty.Action.select, beachParty.Target.chartOptions, true, { nextSpiral: this._spiralParams.seed });
            return seed;
        };
        chartClass.prototype.buildFromTop = function (value) {
            if (arguments.length == 0) {
                return this._flatParams.buildFromTop;
            }
            this._flatParams.buildFromTop = value;
            this.onFlatParamsChanged();
            this.onDataChanged("startFromTop");
            this.logAction(beachParty.Gesture.select, "shapeSeparation", beachParty.ElementType.numAdjuster, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { shapeSeparation: value });
        };
        chartClass.prototype.onFlatParamsChanged = function () {
            this.onDataChanged("flatParams");
            this.markBuildNeeded("flatParamsChanged");
            this.markBuildNeeded("setFlatParams");
        };
        chartClass.prototype.flatParams = function (value) {
            if (arguments.length == 0) {
                return this._flatParams;
            }
            this._flatParams = value;
            this.onFlatParamsChanged();
        };
        chartClass.prototype.spiralParams = function (value) {
            if (arguments.length == 0) {
                return this._spiralParams;
            }
            this._spiralParams = value;
            this.onDataChanged("spiralParams");
        };
        chartClass.prototype.shapeOpacity = function (value, omitProcessing) {
            if (arguments.length === 0) {
                return this._shapeOpacity;
            }
            if (value != this._shapeOpacity) {
                this._shapeOpacity = value;
                this._vsCurrent.shapeOpacity = value;
            }
            if (!omitProcessing) {
                this.markDrawNeeded("setShapeOpacity");
                this.onDataChanged("shapeOpacity");
            }
        };
        chartClass.prototype.shapeOpacityCompleted = function (value) {
            this.logAction(beachParty.Gesture.select, "shapeOpacity", beachParty.ElementType.numAdjuster, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { shapeOpacity: value });
        };
        chartClass.prototype.isDataZoomMode = function (value) {
            if (arguments.length == 0) {
                return this._isDataZoomMode;
            }
            this._isDataZoomMode = value;
            //---- reflect in UI ----
            vp.select("#dataZoomButton")
                .attr("data-selected", value + "");
            if (!value) {
                this.resetTransform();
            }
            this.onDataChanged("isDataZoomMode");
        };
        chartClass.prototype.toggleDataZoom = function (e) {
            //---- toggle mode ----
            this.isDataZoomMode(!this._isDataZoomMode);
            //---- log it ----
            var action = (this._isDataZoomMode) ? beachParty.Action.hide : beachParty.Action.show;
            var targetId = (e) ? e.target.id : "";
            this.logAction(beachParty.Gesture.click, targetId, beachParty.ElementType.button, action, beachParty.Target.dataZoom, true);
        };
        chartClass.prototype.resetDataZoomMode = function () {
            if (this._isDataZoomMode) {
                this.toggleDataZoom(null);
            }
        };
        chartClass.prototype.isCountOrSumOrGrid = function (attrName, layoutType) {
            var chartType = this._chartSpecs.getChartType();
            layoutType = (layoutType === undefined) ? this._chartSpecs.layoutType() : layoutType;
            //---- TODO: clean up this messy chartName/layoutName design ----
            var isGrid = (chartType == beachParty.ChartType.Grid && attrName == "y");
            //var isSquarify = (layoutType == LayoutType.Squarify);
            var isColBar = (chartType == beachParty.ChartType.Column && attrName == "y") || (chartType == beachParty.ChartType.Bar && attrName == "x");
            var isCountSum = (isColBar || isGrid);
            return isCountSum;
        };
        chartClass.prototype.getAttribute = function (name) {
            return this._attributes[name];
        };
        chartClass.prototype.sizeFactor = function (value, animate, omitProcessing) {
            if (arguments.length === 0) {
                return this._sizeFactor;
            }
            if (value != this._sizeFactor) {
                this._sizeFactor = value;
                this._vsCurrent.sizeFactor = value;
                if (!omitProcessing) {
                    this.setSizeFactor(value, animate);
                    this.onDataChanged("sizeFactor");
                }
            }
        };
        chartClass.prototype.setSizeFactor = function (value, animate) {
            this.markDrawNeeded("setSizeFactor");
        };
        chartClass.prototype.sizeFactorCompleted = function (value) {
            this.logAction(beachParty.Gesture.select, "shapeSize", beachParty.ElementType.numAdjuster, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { sizeFactor: value });
        };
        chartClass.prototype.separationFactor = function (value, omitProcessing) {
            if (arguments.length === 0) {
                return this._separationFactor;
            }
            this._separationFactor = value;
            this._vsCurrent.separation = value;
            if (!omitProcessing) {
                //---- record changed size for this chart ----
                this.markBuildNeeded("setSeparationFactor");
                this.onDataChanged("separationFactor");
                this.logAction(beachParty.Gesture.select, "shapeSeparation", beachParty.ElementType.numAdjuster, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { shapeSeparation: value });
            }
        };
        chartClass.prototype.onChartOrLayoutChanged = function () {
            //---- apply user-preferences for this view ----
            this.applyViewSettings();
            //---- notify app ----
            this.onDataChanged("chartOrLayout");
            //---- notify chartBuilder ----
            this.markBuildNeeded("chartOrLayoutChanged");
        };
        chartClass.prototype.isLoggingEnabled = function (value) {
            return this._app.isLoggingEnabled.apply(this._app, arguments);
        };
        chartClass.prototype.applyViewSettings = function () {
            //---- turn off logging while we set various properties as side effect of main property change ----
            this.isLoggingEnabled(false);
            try {
                //---- apply view settings ----
                var dataFrame = this.getDataFrame();
                var cs = this._chartSpecs;
                var key = cs.getChartName() + "^" + cs.getLayoutName() + "^" + dataFrame.getFileName();
                var vs = this._chartSettings[key];
                if (!vs) {
                    vs = this.createViewSettings();
                    this._chartSettings[key] = vs;
                }
                this._vsCurrent = vs;
                if (vs.sizeFactor) {
                    this.sizeFactor(vs.sizeFactor, undefined, true);
                }
                if (vs.shapeOpacity) {
                    this.shapeOpacity(vs.shapeOpacity, true);
                }
                if (vs.shapeColor) {
                    this.shapeColor(vs.shapeColor, true);
                }
                if (vs.separation) {
                    this.separationFactor(vs.separation, true);
                }
                if (vs.shapeName) {
                    this.shapeImage(vs.shapeName, true);
                }
                if (vs.zBinCount) {
                    this._zAttr.binCount(vs.zBinCount, true);
                }
            }
            finally {
                this.isLoggingEnabled(true);
            }
        };
        chartClass.prototype.getLayoutsForCurrentChart = function () {
            var layouts = null;
            var chartName = this._chartSpecs.getChartName();
            /// chartnames: 
            ///     flat, column, density, line, scatter, pie
            ///     violin, graph, cluster, parallel, xxxx, xxxx
            if (chartName == "Flat") {
                layouts = [beachParty.LayoutType.Grid, beachParty.LayoutType.Circle, beachParty.LayoutType.Poisson, beachParty.LayoutType.Random];
            }
            else if (chartName == "Column" || chartName == "Bar") {
                layouts = [beachParty.LayoutType.Grid, beachParty.LayoutType.Squarify, beachParty.LayoutType.Strips, beachParty.LayoutType.Percent, beachParty.LayoutType.Random];
            }
            else if (chartName == "Density") {
                layouts = [beachParty.LayoutType.Grid, beachParty.LayoutType.Circle, beachParty.LayoutType.Poisson, beachParty.LayoutType.Random];
            }
            else if (chartName == "Stacks") {
                layouts = [beachParty.LayoutType.ScaleToFit, beachParty.LayoutType.Cubes];
            }
            return layouts;
        };
        chartClass.prototype.onChartChanged = function (layoutType) {
            var chartType = this._chartSpecs.getChartType();
            if (layoutType !== undefined) {
                //---- remember last used layout for this chart type ----
                this._layoutsByChart[chartType] = layoutType;
            }
            else {
                //---- get user-specified layout for this chart type ----
                layoutType = this._layoutsByChart[chartType];
            }
            if (layoutType === undefined) {
                var layouts = this.getLayoutsForCurrentChart();
                if (layouts && layouts.length) {
                    //---- use first choice for now ----
                    layoutType = layouts[0];
                }
                else {
                    layoutType = beachParty.LayoutType.Default; // no layouts for this chart
                }
            }
            var uiName = this._chartSpecs.getUiChartName();
            if (uiName == "Bar" || uiName == "Column" || uiName == "Grid") {
                layoutType = this.onSizePackingRelatedChanged(true, layoutType); //false);
            }
            //---- make sure count/sum/x/y is updated ----
            this.onDataChanged("xMapping");
            this.onDataChanged("yMapping");
            this._zAttr.limitBinsForStrings(this._chartSpecs.getChartType() != beachParty.ChartType.Stacks);
            this.changeToLayout(layoutType, false);
        };
        chartClass.prototype.customParams = function () {
            return this._customParams;
        };
        /**
         *  called when we change the view (chart type).
         * @param name
         * @param isFromUi
         */
        chartClass.prototype.changeToLayout = function (layoutType, isFromUi) {
            //---- store the new layout value ----
            this._chartSpecs.layoutType(layoutType);
            //---- don't bother updating UI until first data frame is loaded ----
            //this._app.updateUiForLayoutChange();
            if (isFromUi) {
                this.logAction(beachParty.Gesture.select, null, beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.layout, true, { name: name });
            }
            this.onChartOrLayoutChanged();
        };
        chartClass.prototype.logAction = function (gesture, elementId, elementType, action, target, isUndoable, options, forceLog, nonLogOptions) {
            if (this._app) {
                //---- call into our instance ----
                this._app.logAction(gesture, elementId, elementType, action, target, isUndoable, options, forceLog, nonLogOptions);
            }
        };
        chartClass.prototype.clearSelection = function () {
            this._dataMgr.clearSelection();
        };
        chartClass.prototype.isWheelInertia = function (value) {
            if (arguments.length === 0) {
                return this._isWheelInertia;
            }
            this._isWheelInertia = value;
            this.markBuildNeeded("setWheelInertia");
            this.onDataChanged("isWheelInertia");
        };
        chartClass.prototype.showWheelDuringTransformMode = function (value) {
            if (arguments.length == 0) {
                return this._showWheelDuringTransformMode;
            }
            this._showWheelDuringTransformMode = value;
            this.markBuildNeeded("showWheelDuringTransformMode");
            this.onDataChanged("showWheelDuringTransformMode");
        };
        chartClass.prototype.is3dGridAlwaysOn = function (value) {
            if (arguments.length === 0) {
                return this._is3dGridAlwaysOn;
            }
            this._is3dGridAlwaysOn = value;
            this.onDataChanged("is3dGridAlwaysOn");
            this.on3dViewChanged();
        };
        chartClass.prototype.ambientLightLevel = function (value) {
            if (arguments.length === 0) {
                return this._lightingParams.ambientLight.lightFactor;
            }
            this._lightingParams.ambientLight.lightFactor = value;
            this.onDataChanged("ambientLightLevel");
            this.onLightingParamsChanged();
        };
        chartClass.prototype.customSpec = function (value) {
            if (arguments.length == 0) {
                return this._customSpec;
            }
            this._customSpec = value;
            this.onCustomParamChanged();
            this.onDataChanged("customSpec");
        };
        chartClass.prototype.customX = function (value) {
            if (arguments.length == 0) {
                return beachParty.CustomColUsage[this._customParams.xUsage];
            }
            this._customParams.xUsage = beachParty.CustomColUsage[value];
            this.onCustomParamChanged();
            this.onDataChanged("customX");
        };
        chartClass.prototype.customY = function (value) {
            if (arguments.length == 0) {
                return beachParty.CustomColUsage[this._customParams.yUsage];
            }
            this._customParams.yUsage = beachParty.CustomColUsage[value];
            this.onCustomParamChanged();
            this.onDataChanged("customY");
        };
        chartClass.prototype.customZ = function (value) {
            if (arguments.length == 0) {
                return beachParty.CustomColUsage[this._customParams.zUsage];
            }
            this._customParams.zUsage = beachParty.CustomColUsage[value];
            this.onCustomParamChanged();
            this.onDataChanged("customZ");
        };
        chartClass.prototype.customLayout = function (value) {
            if (arguments.length == 0) {
                return beachParty.CustomLayout[this._customParams.layout];
            }
            this._customParams.layout = beachParty.CustomLayout[value];
            this.onCustomParamChanged();
            this.onDataChanged("customLayout");
        };
        chartClass.prototype.applyCustomParams = function () {
            this.onCustomParamChanged();
        };
        chartClass.prototype.takeSnapshot = function (chartBgColor, plotOnly) {
            var url;
            null;
            if (true) {
                var plotCanvas = this._chartBuilder.getGlCanvasElem();
                if (plotOnly) {
                    //---- PNG is messed up for IE/Chrome/Firefox; JPEG seems to work correctly ----
                    url = plotCanvas.toDataURL("image/jpeg", 1);
                }
                else {
                    var rcCanvas = this._chartBuilder.getChartBounds();
                    //---- build canvas the same size as our engine document (to hold plot + axes) ----
                    //---- other parts of snapshot (legends, etc.) will be drawn by the calling client app ----
                    var chartCanvas = document.createElement("canvas");
                    chartCanvas.width = rcCanvas.width;
                    chartCanvas.height = rcCanvas.height;
                    var ctx = chartCanvas.getContext("2d");
                    //---- draw body background ----
                    ctx.fillStyle = chartBgColor;
                    ctx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);
                    //---- get plot bounds ----
                    var rcPlot = this._chartBuilder.getPlotBounds(false);
                    var facetHelper = this._chartBuilder.getFacetHelper();
                    //---- avoid system error when drawing 0-size image ----
                    if (rcPlot.width > 0 && rcPlot.height > 0) {
                        //---- draw plot BACKGROUND ----
                        var cs = getComputedStyle(plotCanvas);
                        if (cs.backgroundColor) {
                            ctx.fillStyle = cs.backgroundColor;
                            ctx.fillRect(rcPlot.left, rcPlot.top, rcPlot.width, rcPlot.height);
                        }
                        //---- draw PLOT ----
                        ctx.drawImage(plotCanvas, rcPlot.left, rcPlot.top);
                    }
                    //---- draw axes ----
                    var svgElem = this._chartBuilder.getSvgDoc();
                    beachParty.drawSvgChildren(ctx, svgElem, rcCanvas, 0, 0, true);
                    //---- draw top/right borders ----
                    //drawHtmlChildren(ctx, this._appMgr.getElement("canvas3d"), null, true);
                    //drawHtmlChildren(ctx, this._root, null, true);
                    //---- PNG is messed up for IE/Chrome/Firefox; JPEG seems to work correctly ----
                    url = chartCanvas.toDataURL("image/jpeg", 1);
                }
            }
            return url;
        };
        chartClass.prototype.captureInsightProperties = function (preload) {
            //---- save VIEW properties ----
            preload.chartName = this._chartSpecs.getChartName();
            preload.subLayout = this._chartSpecs.getLayoutName();
            preload.sizeFactor = this._sizeFactor;
            preload.separationFactor = this._separationFactor;
            preload.shapeOpacity = this._shapeOpacity;
            preload.shapeColor = this._shapeColor;
            preload.shapeImage = this._shapeImage;
            //---- save FLAT PARAMS ----
            var fp = new beachParty.FlatParams();
            fp.buildFromTop = this.buildFromTop();
            fp.numColumns = this.numColumns();
            preload.flatParams = fp;
            //---- sorting stuff ----
            preload.sortCol = this._sortItemCol;
            preload.isSortAscending = this._isItemSortAscending;
            var xm = vp.utils.copyMap(this._xAttr.mappingData(), true);
            var ym = vp.utils.copyMap(this._yAttr.mappingData(), true);
            var zm = vp.utils.copyMap(this._zAttr.mappingData(), true);
            var am = vp.utils.copyMap(this._auxAttr.mappingData(), true);
            var cm = vp.utils.copyMap(this._colorAttr.mappingData(), true);
            var sm = vp.utils.copyMap(this._sizeAttr.mappingData(), true);
            var im = vp.utils.copyMap(this._shapeAttr.mappingData(), true);
            var fm = vp.utils.copyMap(this._facetAttr.mappingData(), true);
            var colMappings = new beachParty.ColMappings(null, null);
            preload.colMappings = colMappings;
            colMappings.x = xm;
            colMappings.y = ym;
            colMappings.z = zm;
            colMappings.aux = am;
            colMappings.color = cm;
            colMappings.size = sm;
            colMappings.shape = im;
            colMappings.facet = fm;
        };
        chartClass.prototype.onCustomParamChanged = function () {
            if (this._chartSpecs.getChartName() != "Custom") {
                this.changeToChart(beachParty.ChartType.Custom);
            }
            this.markBuildNeeded("setCustomParams");
            this.onDataChanged("customParams");
        };
        chartClass.prototype.on3dViewChanged = function () {
            var chartName = this._chartSpecs.getChartName();
            var isLightingChart = (chartName == "Stacks" || chartName == "Scatter-3D");
            var use3DGrid = (chartName == "Stacks" || chartName == "Scatter-3D");
            this._lightingParams.isLightingEnabled = (this._isLightingAlwaysOn || isLightingChart);
            this.onLightingParamsChanged();
            var use3dGrid = (this._is3dGridAlwaysOn || use3DGrid);
            this.markBuildNeeded("set3dGridVisible");
        };
        chartClass.prototype.isLightingAlwaysOn = function (value) {
            if (arguments.length === 0) {
                return this._isLightingAlwaysOn;
            }
            this._isLightingAlwaysOn = value;
            this.onDataChanged("isLightingAlwaysOn");
            this.on3dViewChanged();
        };
        chartClass.prototype.onLightingParamsChanged = function () {
            this.markBuildNeeded("setLightingParams");
        };
        chartClass.prototype.getLightingParanms = function () {
            return this._lightingParams;
        };
        chartClass.prototype.selectedColorEffect = function (value) {
            if (arguments.length == 0) {
                return beachParty.ColorEffect[this._selectionParams.selectedParams.colorEffect];
            }
            this._selectionParams.selectedParams.colorEffect = beachParty.ColorEffect[value];
            this.onDataChanged("selectedColorEffect");
            this.onSelectionParamsChanged();
        };
        chartClass.prototype.unselectedColorEffect = function (value) {
            if (arguments.length == 0) {
                return beachParty.ColorEffect[this._selectionParams.unselectedParams.colorEffect];
            }
            this._selectionParams.unselectedParams.colorEffect = beachParty.ColorEffect[value];
            this.onDataChanged("unselectedColorEffect");
            this.onSelectionParamsChanged();
        };
        chartClass.prototype.selectedColor = function (value) {
            if (arguments.length == 0) {
                return this._selectionParams.selectedParams.color;
            }
            this._selectionParams.selectedParams.color = value;
            this.onDataChanged("selectedColor");
            this.onSelectionParamsChanged();
        };
        chartClass.prototype.unselectedColor = function (value) {
            if (arguments.length == 0) {
                return this._selectionParams.unselectedParams.color;
            }
            this._selectionParams.unselectedParams.color = value;
            this.onDataChanged("unselectedColor");
            this.onSelectionParamsChanged();
        };
        chartClass.prototype.selectedColorFactor = function (value) {
            if (arguments.length == 0) {
                return this._selectionParams.selectedParams.colorFactor;
            }
            this._selectionParams.selectedParams.colorFactor = value;
            this.onDataChanged("selectedColorFactor");
            this.onSelectionParamsChanged();
        };
        chartClass.prototype.unselectedColorFactor = function (value) {
            if (arguments.length == 0) {
                return this._selectionParams.unselectedParams.colorFactor;
            }
            this._selectionParams.unselectedParams.colorFactor = value;
            this.onDataChanged("unselectedColorFactor");
            this.onSelectionParamsChanged();
        };
        chartClass.prototype.onSelectionParamsChanged = function () {
            this.markBuildNeeded("onSelectionParamsChanged");
        };
        chartClass.prototype.hoverOnDetailView = function (value) {
            if (arguments.length == 0) {
                return this._hoverOnDetailView;
            }
            this._hoverOnDetailView = value;
            this.onDataChanged("hoverOnDetailView");
        };
        chartClass.prototype.hoverOnMouseMove = function (value) {
            if (arguments.length == 0) {
                return this._hoverOnMouseMove;
            }
            this._hoverOnMouseMove = value;
            this.onDataChanged("hoverOnMouseMove");
        };
        chartClass.prototype.toolTipElem = function (value) {
            if (arguments.length == 0) {
                return this._toolTipElem;
            }
            this._toolTipElem = value;
            this.onDataChanged("toolTipElem");
        };
        chartClass.prototype.isTooltipsEnabled = function (value) {
            if (arguments.length == 0) {
                var enabled = (this._isTooltipsEnabled && !this._isEngineDrawing);
                return enabled;
            }
            this._isTooltipsEnabled = value;
            this.onDataChanged("isTooltipsEnabled");
        };
        chartClass.prototype.includeNamesInTooltip = function (value) {
            if (arguments.length == 0) {
                return this._includeNamesInTooltip;
            }
            this._includeNamesInTooltip = value;
            this.onDataChanged("includeNamesInTooltip");
        };
        chartClass.prototype.applyHoverCore = function (mousePos, showHover) {
            var hp = this._hoverParams;
            //var primaryKey = null;
            this._lastHoverPos = mousePos;
            var hpk = null;
            var shapeEng = this.getShapeEngine();
            if (hp.hoverMatch == beachParty.HoverMatch.point) {
                var transformMgr = this._chartBuilder.getTransformMgr();
                var ray = transformMgr.getRayFromScreenPos(mousePos.x, mousePos.y);
                var items = shapeEng.hitTestRay(ray, mousePos);
                if (items && items.length) {
                    hpk = items[0].primaryKey;
                }
            }
            else if (hp.hoverMatch == beachParty.HoverMatch.square) {
                var sz = hp.squareSize;
                if (sz >= 1) {
                    var rcScreen = vp.geom.createRect(mousePos.x - sz / 2, mousePos.y - sz / 2, sz, sz);
                    var boxes = shapeEng.hitTestFromRect(rcScreen, false, true);
                    if (boxes && boxes.length) {
                        var box = boxes[0];
                        hpk = box.primaryKey;
                    }
                }
            }
            if (showHover) {
                var pkShow = (showHover) ? hpk : -1;
            }
            //---- return actual primary key to client ----
            return hpk;
        };
        chartClass.prototype.hoverMatch = function (value) {
            if (arguments.length == 0) {
                return beachParty.HoverMatch[this._hoverParams.hoverMatch];
            }
            this._hoverParams.hoverMatch = beachParty.HoverMatch[value];
            this.onDataChanged("hoverMatch");
            this.onHoverParamsChanged();
        };
        chartClass.prototype.hoverEffect = function (value) {
            if (arguments.length == 0) {
                return beachParty.HoverEffect[this._hoverParams.hoverEffect];
            }
            this._hoverParams.hoverEffect = beachParty.HoverEffect[value];
            this.onDataChanged("hoverEffect");
            this.onHoverParamsChanged();
        };
        chartClass.prototype.hoverColor = function (value) {
            if (arguments.length == 0) {
                return this._hoverParams.hoverColor;
            }
            this._hoverParams.hoverColor = value;
            this.onDataChanged("hoverColor");
            this.onHoverParamsChanged();
        };
        chartClass.prototype.hoverSize = function (value) {
            if (arguments.length == 0) {
                return this._hoverParams.squareSize;
            }
            this._hoverParams.squareSize = value;
            this.onDataChanged("hoverSize");
            this.onHoverParamsChanged();
        };
        chartClass.prototype.onHoverParamsChanged = function () {
            this.markBuildNeeded("setHoverParams");
        };
        chartClass.prototype.isAnimationEnabled = function (value) {
            if (arguments.length === 0) {
                return this._animationData.isAnimationEnabled;
            }
            this._animationData.isAnimationEnabled = value;
            this.onAnimationDataChanged();
            this.onDataChanged("isAnimationEnabled");
        };
        chartClass.prototype.isStaggeringEnabled = function (value) {
            if (arguments.length === 0) {
                return this._animationData.isStaggeringEnabled;
            }
            this._animationData.isStaggeringEnabled = value;
            this.onAnimationDataChanged();
            this.onDataChanged("isStaggeringEnabled");
        };
        chartClass.prototype.easeFunction = function (value) {
            if (arguments.length == 0) {
                return beachParty.EaseFunction[this._animationData.easeFunction];
            }
            this._animationData.easeFunction = beachParty.EaseFunction[value];
            this.onAnimationDataChanged();
            this.onDataChanged("easeFunction");
        };
        chartClass.prototype.easeType = function (value) {
            if (arguments.length == 0) {
                return beachParty.EaseType[this._animationData.easeType];
            }
            this._animationData.easeType = beachParty.EaseType[value];
            this.onAnimationDataChanged();
            this.onDataChanged("easeType");
        };
        chartClass.prototype.animationDuration = function (value) {
            if (arguments.length === 0) {
                return this._animationData.animationDuration;
            }
            this._animationData.animationDuration = value;
            this.onAnimationDataChanged();
            this.onDataChanged("animationDuration");
        };
        chartClass.prototype.maxStaggerTime = function (value) {
            if (arguments.length === 0) {
                return this._animationData.maxStaggerTime;
            }
            this._animationData.maxStaggerTime = value;
            this.onAnimationDataChanged();
            this.onDataChanged("maxStaggerTime");
        };
        chartClass.prototype.onAnimationDataChanged = function () {
            this.markBuildNeeded("setAnimationData");
        };
        chartClass.prototype.chartFrameOpacity = function (value) {
            if (arguments.length === 0) {
                return this._chartFrameData.opacity;
            }
            this._chartFrameData.opacity = value;
            this.onDataChanged("chartFrameOpacity");
            this.onChartFrameDataChanged();
        };
        chartClass.prototype.chartFrameData = function () {
            return this._chartFrameData;
        };
        chartClass.prototype.blankValueStr = function () {
            return this._app.getBlankValueStr();
        };
        chartClass.prototype.showXGridLines = function (value) {
            if (arguments.length === 0) {
                return this._chartFrameData.xAxis.drawGridLines;
            }
            this._chartFrameData.xAxis.drawGridLines = value;
            this.onDataChanged("showXGridLines");
            this.onChartFrameDataChanged();
            this.logAction(beachParty.Gesture.click, "xGridLines", beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { xGridLines: value });
        };
        chartClass.prototype.showYGridLines = function (value) {
            if (arguments.length === 0) {
                return this._chartFrameData.yAxis.drawGridLines;
            }
            this._chartFrameData.yAxis.drawGridLines = value;
            this.onDataChanged("showYGridLines");
            this.onChartFrameDataChanged();
            this.logAction(beachParty.Gesture.click, "yGridLines", beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { yGridLines: value });
        };
        chartClass.prototype.onChartFrameDataChanged = function () {
            this.markBuildNeeded("chartFrameChanged");
        };
        chartClass.prototype.isContinuousDrawing = function (value) {
            if (arguments.length == 0) {
                return this._isContinuousDrawing;
            }
            this._isContinuousDrawing = value;
            this.markBuildNeeded("setContinuousDrawing");
            this.onDataChanged("isContinuousDrawing");
        };
        chartClass.prototype.isInstancingEnabled = function (value) {
            if (arguments.length == 0) {
                return this._instancingParams.isInstancingEnabled;
            }
            this._instancingParams.isInstancingEnabled = value;
            this.markBuildNeeded("setInstancingParams");
            this.onDataChanged("isInstancingEnabled");
        };
        chartClass.prototype.drawingPrimitive = function (value) {
            if (arguments.length === 0) {
                return beachParty.DrawPrimitive[this._drawingPrimitive];
            }
            var dpValue = beachParty.DrawPrimitive[value];
            if (dpValue != this._drawingPrimitive) {
                this._drawingPrimitive = dpValue;
                this.setActualDrawingPrimitive();
                this.onDataChanged("drawingPrimitive");
            }
        };
        chartClass.prototype.getActualDrawingPrimitive = function () {
            return this._actualDrawingPrimitive;
        };
        chartClass.prototype.sortItemsByColor = function () {
            var colName = this._colorAttr.colName();
            this.logAction(beachParty.Gesture.click, "sortByColor", beachParty.ElementType.button, beachParty.Action.adjust, beachParty.Target.sortParams, true);
            this.sortItemColumn(colName);
            this.isItemSortAscending(true);
        };
        chartClass.prototype.resetMappingsForNewFile = function (isLoadingInsight, defaultCols) {
            var prevSumByColumn = this._sizeAttr.colName();
            var prevYColumn = this._yAttr.colName();
            var prevChartType = this._chartSpecs.getUiChartName();
            //---- reset all attribute mapping ----
            this._xAttr.clearForDataChanged();
            this._yAttr.clearForDataChanged();
            this._zAttr.clearForDataChanged();
            this._auxAttr.clearForDataChanged();
            this._imageAttr.clearForDataChanged();
            this._facetAttr.clearForDataChanged();
            this._lineAttr.clearForDataChanged();
            this._textAttr.clearForDataChanged();
            this._sizeAttr.clearForDataChanged();
            this._shapeAttr.clearForDataChanged();
            this._colorAttr.clearForDataChanged();
            this._tooltipColumns = null;
            //---- reset these too ----
            this._sortItemCol = null;
            this._isItemSortAscending = true;
            this._lastScatterXCol = null;
            this._lastScatterYCol = null;
            if (!isLoadingInsight) {
                //---- reset all sorting (caution: don't sort multiple times here) ----
                this.sortItemColumn(null, false);
                this.isItemSortAscending(true, false);
                //this.xBinSorting(BinSorting.none, true);
                this._xAttr.binSorting("none", true);
                this._yAttr.binSorting("none", true);
                this._imageAttr.binSorting("none", true);
                this._facetAttr.binSorting("none", true);
                //---- ensure sort UI gets updated ----
                this.onSortParmsChanged(false);
                this._xAttr.colName(defaultCols.x);
                this._yAttr.colName(defaultCols.y);
                this._zAttr.colName(defaultCols.z);
                //this._auxAttr.colName(defaultCols.x);
                this._xAttr.setMappingDataFormatting();
                this._yAttr.setMappingDataFormatting();
                this._zAttr.setMappingDataFormatting();
                this._colorAttr.onMappingChanged(true);
                this._xAttr.onMappingChanged();
                this._yAttr.onMappingChanged();
                this._zAttr.onMappingChanged();
                this._auxAttr.onMappingChanged();
                this._imageAttr.onMappingChanged();
                this._sizeAttr.onMappingChanged();
                this._shapeAttr.onMappingChanged();
                this._facetAttr.onMappingChanged();
                this._lineAttr.onMappingChanged();
                this._textAttr.onMappingChanged();
                //this._currentChart.resetFilter();
                this.resetTransform();
            }
            this.onFilteredChanged();
            this.onSelectionChanged();
        };
        chartClass.prototype.setActualDrawingPrimitive = function () {
            //if (false)      // this._chartName == "Line")
            //{
            //    var value = DrawPrimitive.linePairs;
            //}
            //else
            var value = null;
            if (this._drawingPrimitive == beachParty.DrawPrimitive.auto) {
                //---- for now, ignore user-specified drawPrimitive ----
                if (this.is3DChart(this._prevChartType) || this.is3DChart(this._chartSpecs.getChartType())) {
                    value = beachParty.DrawPrimitive.cube;
                }
                else {
                    value = beachParty.DrawPrimitive.quad;
                }
            }
            else {
                value = this._drawingPrimitive;
            }
            if (value != this._actualDrawingPrimitive) {
                this._actualDrawingPrimitive = value;
                this.markBuildNeeded("setDrawingPrimitive");
            }
        };
        chartClass.prototype.is3DChart = function (chartType) {
            return (chartType == beachParty.ChartType.Scatter3D || chartType == beachParty.ChartType.Stacks);
        };
        chartClass.prototype.chartName = function () {
            return this._chartSpecs.getChartName();
        };
        chartClass.prototype.getDataMgr = function () {
            return this._dataMgr;
        };
        chartClass.prototype.getDataFrame = function () {
            var dataFrame = null;
            if (this._dataMgr) {
                dataFrame = this._dataMgr.getDataFrame();
            }
            return dataFrame;
        };
        chartClass.prototype.onSizePackingRelatedChanged = function (triggerLayoutChange, layoutType) {
            var chartName = this._chartSpecs.getChartName();
            var newLayout = beachParty.LayoutType.Default;
            //---- if SIZE BY is set and chart is column/bar, choose the correct layout ----
            if (this.isCountOrSumOrGrid("x", layoutType) || this.isCountOrSumOrGrid("y", layoutType)) {
                if (chartName == "Flat") {
                    newLayout = beachParty.LayoutType.Grid;
                }
                if (this._auxAttr.isSet()) {
                    //layout = this._appSettingsMgr.sizePacking();
                    newLayout = beachParty.LayoutType.Squarify;
                    if (this._auxAttr.sumLayout() == "strip") {
                        newLayout = beachParty.LayoutType.Strips;
                    }
                }
                else {
                    if (this._auxAttr.countLayout() == "percent") {
                        newLayout = beachParty.LayoutType.Percent;
                    }
                }
                this.changeToLayout(newLayout, false);
            }
            return newLayout;
        };
        chartClass.prototype.isChartUsingBins = function (attrName) {
            var chartName = this._chartSpecs.getChartName();
            var usingBins = false;
            if (chartName == "Bar") {
                usingBins = (attrName == "y");
            }
            else if (chartName == "Column") {
                usingBins = (attrName == "x");
            }
            else if (chartName == "Density") {
                usingBins = (attrName == "x" || attrName == "y");
            }
            else if (chartName == "Violin") {
                usingBins = (attrName == "x" || attrName == "y");
            }
            else if (chartName == "Stacks") {
                usingBins = (attrName == "x" || attrName == "y" || attrName == "z");
            }
            return usingBins;
        };
        chartClass.prototype.getSystemViewData = function (snapShotType, getReproData, chartBgColor, callback) {
            return this._chartEng.getSystemViewData(snapShotType, getReproData, chartBgColor, callback);
        };
        /**
         * return the bounds (ClientRect) of the shape associated with the specified primary key.  The returned bounds
         * are relative to the plot bounds.
         * @param primaryKey
         */
        chartClass.prototype.getShapeBounds = function (primaryKey) {
            var rcShape = null;
            var shapeEng = this.getShapeEngine();
            var bb = shapeEng.getShapeBoundingBox(primaryKey);
            if (bb) {
                var bounds = new beachParty.Bounds();
                bounds.x = bb.xMin;
                bounds.y = bb.yMin;
                bounds.width = bb.xMax - bb.xMin;
                bounds.height = bb.yMax - bb.yMin;
                var transform = this.getTransformer();
                var rc = transform.worldBoundsToScreen(bounds);
                //---- round to nearest pixel ----
                rcShape = vp.geom.createRect(Math.round(rc.left), Math.round(rc.top), Math.round(rc.width), Math.round(rc.height));
            }
            return rcShape;
        };
        chartClass.prototype.getColumnValues = function (columnList, primaryKey) {
            var valueList = [];
            if (primaryKey) {
                var record = this._dataMgr.getDataFrame().getRecordByPrimaryKey(primaryKey);
                for (var i = 0; i < columnList.length; i++) {
                    var colName = columnList[i];
                    var value = record[colName];
                    valueList.push(value);
                }
            }
            return valueList;
        };
        chartClass.prototype.getMemoryUse = function (callback) {
            return this._chartEng.getMemoryUse(callback);
        };
        chartClass.prototype.getEngineEvents = function (callback) {
            return this._chartEng.getEngineEvents(callback);
        };
        /**
         * Find the shape within rcArea that is closest to its center.  Return the values of the specified colNames for the
         * data record associated with the located shape.
         * @param rcArea    - ClientRect of area to search, relative to the plot area of the chart.
         * @param colNames  - Names of columns whose values should be returned.
         * @param callback  - the callback function used to return the results when the operation is complete.
         */
        chartClass.prototype.getMostCentralRecord = function (rcArea, colNames, callback) {
            return this._chartEng.getMostCentralRecord(rcArea, colNames, callback);
        };
        chartClass.prototype.getShapeBoundsAndRecord = function (primaryKey, colNames, callback) {
            return this._chartEng.getShapeBoundsAndRecord(primaryKey, colNames, callback);
        };
        chartClass.prototype.getShapeEngine = function () {
            return this._chartBuilder.getShapeEngine();
        };
        chartClass.prototype.buildAttributes = function () {
            var _this = this;
            var defaultBinCount = chartClass.defaultNumericBins;
            var autoBins = chartClass.autoBins;
            var xMapping = new beachParty.MappingData("x", "", autoBins);
            var yMapping = new beachParty.MappingData("y", "", autoBins);
            var zMapping = new beachParty.MappingData("z", "", 3);
            var auxMapping = new beachParty.MappingData("aux", "", autoBins);
            var imageMapping = new beachParty.ImageMappingData();
            var facetMapping = new beachParty.MappingData("facet", "", defaultBinCount);
            var sizeMapping = new beachParty.SizeMappingData(defaultBinCount);
            var shapeMapping = new beachParty.ShapeMappingData(6); // our only palette right now has 6 shapes
            var lineMapping = new beachParty.LineMappingData(defaultBinCount);
            var textMapping = new beachParty.TextMappingData(defaultBinCount);
            var colorMapping = new beachParty.ColorMappingData();
            var attributes = {};
            this._attributes = attributes;
            var dataFrame = this.getDataFrame();
            //---- build our 11 attributes ----
            attributes.x = new beachParty.attrClass(this, xMapping, beachParty.Target.xMapping);
            attributes.y = new beachParty.attrClass(this, yMapping, beachParty.Target.yMapping);
            attributes.z = new beachParty.attrClass(this, zMapping, beachParty.Target.zMapping);
            attributes.aux = new beachParty.auxAttrClass(this, auxMapping, beachParty.Target.auxMapping);
            attributes.color = new beachParty.colorAttrClass(this._app, this, colorMapping, beachParty.Target.colorMapping, defaultBinCount);
            attributes.size = new beachParty.sizeAttrClass(this, sizeMapping, beachParty.Target.sizeMapping);
            attributes.shape = new beachParty.shapeAttrClass(this, shapeMapping, beachParty.Target.shapeMapping);
            attributes.line = new beachParty.lineAttrClass(this, imageMapping, beachParty.Target.lineMapping);
            attributes.text = new beachParty.textAttrClass(this, imageMapping, beachParty.Target.textMapping);
            attributes.facet = new beachParty.attrClass(this, facetMapping, beachParty.Target.facetMapping, defaultBinCount);
            attributes.image = new beachParty.attrClass(this, imageMapping, beachParty.Target.imageMapping);
            this._xAttr = attributes.x;
            this._yAttr = attributes.y;
            this._zAttr = attributes.z;
            this._auxAttr = attributes.aux;
            this._colorAttr = attributes.color;
            this._facetAttr = attributes.facet;
            this._sizeAttr = attributes.size;
            this._shapeAttr = attributes.shape;
            this._imageAttr = attributes.image;
            this._lineAttr = attributes.line;
            this._textAttr = attributes.text;
            //---- hook "colName" changes from each attribute ----
            var keys = vp.utils.keys(attributes);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var attr = attributes[key];
                //---- hook COL NAME changed ----
                attr.onColNameChange.attach(this, function (e) {
                    _this.onAttrColNameChange.trigger(e);
                    var methodName = "on" + beachParty.chartUtils.capitalizeFirstLetter(e.attrName) + "Changed";
                    var method = _this._chartBuilder[methodName];
                    if (method) {
                        _this._chartBuilder[methodName](); // call with this ptr set correctly
                    }
                    _this.markBuildNeeded(methodName);
                });
                //---- hook MAPPING DATA changed ----
                attr.onMappingDataChange.attach(this, function (e) {
                    _this.markBuildNeeded(e.attrName + "MappingDataChanged");
                    //---- signal events to allow UI to update as needed ----
                    //this.onDataChanged(e.attrName + "Mapping");
                });
                //---- hook MAPPING DATA changed ----
                attr.registerForChange("trueBinCount", function (e) {
                    _this.markBuildNeeded(e.attrName + ": trueBinCountChanged");
                    //---- signal events to allow UI to update as needed ----
                    //this.onDataChanged(e.attrName + "Mapping");
                });
            }
            //this._lineMgr = new lineMgrClass(this, lineMapping, Target.lineMapping);
            //this._textMgr = new textMgrClass(this, textMapping, Target.textMapping);
            this._auxAttr.registerForChange("colName", function (e) {
                _this.onSizePackingRelatedChanged(true);
            });
            this._auxAttr.registerForChange("useStripSum", function (e) {
                _this.onSizePackingRelatedChanged(true);
            });
            this._auxAttr.registerForChange("usePercentMode", function (e) {
                _this.onSizePackingRelatedChanged(true);
            });
            this._zAttr.registerForChange("binCount", function (e) {
                _this._vsCurrent.zBinCount = _this._zAttr.binCount();
            });
        };
        chartClass.prototype.resetTransform = function () {
            var transform = this.getTransformer();
            transform.resetMatrices();
            this.markBuildNeeded("resetTransform");
        };
        chartClass.prototype.getUiChartName = function (value) {
            return this._chartSpecs.getUiChartName();
        };
        chartClass.prototype.rootElement = function () {
            return this._root;
        };
        chartClass.prototype.chartUxElement = function () {
            return this._uxElem;
        };
        chartClass.prototype.clientElement = function () {
            return this._clientElem;
        };
        chartClass.prototype.isVisible = function (value, fadeTime) {
            if (fadeTime === void 0) { fadeTime = 0; }
            if (arguments.length == 0) {
                return this._isVisible;
            }
            this._isVisible = value;
            if (value) {
                //vp.select(this._root).css(value ? "" : "none");
                beachParty.chartUtils.fadeIn(this._root, fadeTime);
                this.markBuildNeeded("isVisible");
            }
            else {
                vp.select(this._root).css(value ? "" : "none");
            }
        };
        chartClass.prototype.showAxes = function (value) {
            var opacity = (value) ? "1" : "0";
            this.addStyleSheet(".vpxAxisLabel,.vpxAxisTick,.vpxAxisTickBox {opacity: " + opacity + "}");
        };
        chartClass.prototype.showAxisTickLabels = function (value) {
            var opacity = (value) ? "1" : "0";
            this.addStyleSheet(".vpxAxisLabel {opacity: " + opacity + "}");
        };
        chartClass.prototype.enableTitlePanel = function (value) {
        };
        chartClass.prototype.showTitlePanel = function (value) {
            vp.select(this._root, "#titlePanel").css("display", (value) ? "" : "none");
        };
        chartClass.prototype.showTitleText = function (value) {
            if (arguments.length === 0) {
                return this._showTitleText;
            }
            this._showTitleText = value;
            this.onDataChanged("showTitleText");
            vp.select("#titleText").css("display", (value) ? "" : "none");
            this.logAction(beachParty.Gesture.click, "showTitle", beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.chartTitle, true, { showTitleText: value });
            this.layoutChart();
            //this._app.layoutScreen();
        };
        chartClass.prototype.showItemCounts = function (value) {
            if (arguments.length === 0) {
                return this._showItemCounts;
            }
            this._showItemCounts = value;
            this.onDataChanged("showItemCounts");
            vp.select("#titleItemCounts").css("display", (value) ? "" : "none");
            this.logAction(beachParty.Gesture.click, "showItemCounts", beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.chartTitle, true, { showItemCounts: value });
            this.layoutChart();
            //this._app.layoutScreen();
        };
        chartClass.prototype.xBins = function (value) {
            return this._xAttr.binCount.apply(this._xAttr, arguments);
        };
        chartClass.prototype.yBins = function (value) {
            return this._yAttr.binCount.apply(this._yAttr, arguments);
        };
        chartClass.prototype.zBins = function (value) {
            return this._zAttr.binCount.apply(this._zAttr, arguments);
        };
        chartClass.prototype.buildChartHtml = function (divElem, isVisible) {
            var _this = this;
            //---- ROOT ----
            var rootW = vp.select(divElem)
                .css("padding", "2px")
                .css("display", (isVisible) ? "" : "none");
            //.css("border", "1px solid white")
            this._root = rootW[0];
            this.buildTitleStuff(rootW);
            //---- CLIENT HOLDER ----
            var clientW = rootW.append("div")
                .id("clientHolder")
                .addClass("flexGrow")
                .css("position", "relative")
                .css("height", "80%");
            //---- CHART UX (positioned later to cover plot area within XY axes) ----
            var chartUxW = clientW.append("div")
                .css("position", "absolute")
                .id("chartUx")
                .css("width", "100%")
                .css("height", "100%")
                .css("z-index", "1002")
                .tabIndex("0");
            //.css("border", "1px solid red")
            //.css("background", "red")
            //.css("opacity", ".3")
            //---- FACET LABEL HOLDER ----
            var flhW = clientW.append("div")
                .id("facetLabelHolder")
                .css("position", "absolute")
                .css("pointer-events", "none")
                .css("width", "100%")
                .css("height", "100%")
                .css("z-index", "1002"); // one higher than svg so they can be clicked
            this._clientElem = clientW[0];
            this._uxElem = chartUxW[0];
            this._facetLabelHolderElem = flhW[0];
            this._chartUx = new beachParty.chartUxClass(this._app, this._dataMgr, this, this._maxToolTipColumns);
            this._chartUx.onActionDectected.attach(this, function (e) {
                if (e.action == "percent" && e.subAction) {
                    _this.toPercentOverride(e.subAction.value);
                }
                else if (e.action == null) {
                    _this.toPercentOverride(undefined);
                }
                _this.onActionDectected.trigger(e);
            });
            this._chartUx.onCursorHitTest.attach(this, function (e) {
                _this.cursorHitTestLoc({ x: e.x, y: e.y });
                _this.cursorHitTestShape(e.primaryKey);
            });
        };
        chartClass.prototype.onBoundsChanged = function () {
            this.layoutChart();
            this._chartBuilder.refreshClientSize();
            this.markBuildNeeded("onBoundsChanged");
        };
        //axisLabelStyle(value?: string)
        //{
        //    if (arguments.length == 0)
        //    {
        //        return this._axisLabelStyle;
        //    }
        //    this._axisLabelStyle = value;
        //    //---- send this rule to engine so it can apply it to axis labels ----
        //    var rule = ".vpxAxisLabel { " + value + "}";
        //    this.addStyleSheet(rule);
        //    this.onDataChanged("axisLabelStyle");
        //}
        //axisLabelSize(value?: number)
        //{
        //    if (arguments.length == 0)
        //    {
        //        return this._axisLabelSize;
        //    }
        //    this._axisLabelSize = value;
        //    this.onDataChanged("axisLabelSize");
        //}
        //axisLabelColor(value?: string)
        //{
        //    if (arguments.length == 0)
        //    {
        //        return this._axisLabelColor;
        //    }
        //    this._axisLabelColor = value;
        //    //---- send this rule to engine so it can apply it to axis labels ----
        //    var rule = ".vpxAxisLabel { fill: " + value + "; }";
        //    this.addStyleSheet(rule);
        //    this.onDataChanged("axisLabelColor");
        //}
        chartClass.prototype.tickBoxStyle = function (value) {
            if (arguments.length == 0) {
                return this._tickBoxStyle;
            }
            this._tickBoxStyle = value;
            //---- send this rule to engine so it can apply it to axis labels ----
            var rule = ".vpxAxisTickBox { " + value + "}";
            this.addStyleSheet(rule);
            this.onDataChanged("tickBoxStyle");
        };
        chartClass.prototype.getIFrameElem = function () {
            return this._iframeElem;
        };
        chartClass.prototype.layoutChart = function () {
            ////---- size clientW according to size of ROOT and TITLE PANEL ----
            //var rootW = vp.select(this._root);
            //var chartHeight = rootW.height();
            //var panelW = vp.select(this._root, "#titlePanel");
            //var titleHeight = panelW.height();
            ////---- set height of CLIENT HOLDER ----
            //var height = Math.max(0, chartHeight - titleHeight);
            //vp.select(this._root, "#clientHolder").height(height);
        };
        chartClass.prototype.onPlotMoved = function (rcPlot, rcRotateRing) {
            //---- screen relative ----
            this._rcPlot = rcPlot;
            //---- update chartUx ----
            vp.select(this._uxElem)
                .css("left", rcPlot.left + "px")
                .css("top", rcPlot.top + "px")
                .css("width", rcPlot.width + "px")
                .css("height", rcPlot.height + "px");
            var touchMgr = this._chartUx.getTouchMgr();
            if (touchMgr) {
                touchMgr.setBounds(rcPlot.left, rcPlot.top, rcPlot.width, rcPlot.height);
            }
            //this.layoutChart();
            //vp.utils.debug("---> onPlotMoved");
        };
        chartClass.prototype.getChartSpecs = function () {
            return this._chartSpecs;
        };
        chartClass.prototype.isShowing3DWheel = function (value) {
            if (arguments.length == 0) {
                return this._isTransformMode;
            }
            this._isTransformMode = value;
            //---- reflect in UI ----
            vp.select("#wheelButton")
                .attr("data-selected", value + "");
            this.onDataChanged("isShowing3DWheel");
        };
        chartClass.prototype.getAxisColumnsInCurrentChart = function () {
            var layout = this._chartBuilder.getLayout();
            var axisMask = layout.getVisibleColPickers();
            var columns = [];
            if (axisMask.contains("x")) {
                columns.push(this._xAttr.colName());
            }
            if (axisMask.contains("y")) {
                columns.push(this._yAttr.colName());
            }
            if (axisMask.contains("a")) {
                var colName = this._auxAttr.colName();
                if (colName) {
                    columns.push(colName);
                }
            }
            if (axisMask.contains("z")) {
                columns.push(this._zAttr.colName());
            }
            return columns;
        };
        chartClass.prototype.getMappedColumns = function () {
            //---- X, Y, Z, AUX ----
            var mappedCols = this.getAxisColumnsInCurrentChart();
            var col;
            //---- FACET ----
            if (col = this._facetAttr.colName()) {
                mappedCols.push(col);
            }
            //---- COLOR ----
            var colorMgr = this._colorAttr;
            if (col = colorMgr.colName()) {
                mappedCols.push(col);
            }
            //---- COLOR CHANNELS ----
            if (col = colorMgr.redColumn()) {
                mappedCols.push(col);
            }
            if (col = colorMgr.greenColumn()) {
                mappedCols.push(col);
            }
            if (col = colorMgr.blueColumn()) {
                mappedCols.push(col);
            }
            if (col = colorMgr.rgbColumn()) {
                mappedCols.push(col);
            }
            //---- SIZE ----
            if (col = this._sizeAttr.colName()) {
                mappedCols.push(col);
            }
            //---- SHAPE ----
            if (col = this._shapeAttr.colName()) {
                mappedCols.push(col);
            }
            //---- IMAGE ----
            if (col = this._imageAttr.colName()) {
                mappedCols.push(col);
            }
            //---- TEXT ----
            if (col = this._textAttr.colName()) {
                mappedCols.push(col);
            }
            //---- LINE ----
            if (col = this._lineAttr.colName()) {
                mappedCols.push(col);
            }
            //---- remove any duplicates ----
            mappedCols = mappedCols.distinct();
            return mappedCols;
        };
        chartClass.prototype.isMappedToXYZ = function (colName) {
            var xm = (this._xAttr.colName() == colName);
            var ym = (this._yAttr.colName() == colName);
            var zm = (this._zAttr.colName() == colName);
            return (xm || ym || zm);
        };
        chartClass.prototype.dataZoom = function (rcZoon, zoomOut) {
            // TODO 
        };
        chartClass.prototype.rectSelect = function (rcBand, selectMode) {
            this.hitTestRectWithSelect(rcBand, selectMode);
            this.logAction(beachParty.Gesture.drag, "canvas", beachParty.ElementType.canvas, beachParty.Action.adjust, beachParty.Target.selection, true, { left: rcBand.left, top: rcBand.top, width: rcBand.width, height: rcBand.height });
        };
        chartClass.prototype.hitTestRectWithSelect = function (rcScreen, selectMode) {
            var pointSelect = (rcScreen.width < 3 && rcScreen.height < 3);
            var hp = this._hoverParams;
            var isChartRelative = true;
            var shapeEng = this.getShapeEngine();
            vp.utils.debug("hitTestRectWithSelect: left=" + rcScreen.left + ", top=" + rcScreen.top +
                ", width=" + rcScreen.width + ", height = " + rcScreen.height);
            if (pointSelect && hp.hoverMatch == beachParty.HoverMatch.square) {
                //---- use center of rcScreen, and size of hoverSquare ----
                var sz = hp.squareSize;
                var cx = rcScreen.left + rcScreen.width / 2;
                var cy = rcScreen.top + rcScreen.height / 2;
                rcScreen = vp.geom.createRect(cx - sz / 2, cy - sz / 2, sz, sz);
                var boxes = shapeEng.hitTestFromRect(rcScreen, isChartRelative, true);
            }
            else {
                var boxes = shapeEng.hitTestFromRect(rcScreen, isChartRelative, false);
            }
            this._dataMgr.updateSelectionFromBoxes(boxes, selectMode);
            this.markBuildNeeded("selectionChanged");
        };
        chartClass.prototype.showChartUx = function (value) {
            vp.select(this._uxElem)
                .css("display", value ? "" : "none");
        };
        chartClass.prototype.buildTitleStuff = function (rootW) {
            var _this = this;
            //---- TITLE PANEL ----
            var titlePanelW = rootW.append("div")
                .id("titlePanel")
                .addClass("flexAuto flexRows titlePanel")
                .css("margin", "20px 10px 10px 80px");
            //---- CHART TITLE ----
            var titleTextW = titlePanelW.append("span")
                .id("titleText")
                .addClass("chartTitleText textPanelItem")
                .css("display", "none")
                .title("Open Data panel to select a new dataset")
                .attach("click", function (e) {
                beachParty.chartUtils.callPanelOpen(e, function (e) {
                    _this.onDataChanged("onTitleTextClicked");
                });
            });
            //---- COUNTS HOLDER ----
            var countsHolderW = titlePanelW.append("div")
                .id("titleItemCounts")
                .addClass("flexColumns countsHolder")
                .css("display", "none");
            //---- ITEM COUNT ----
            countsHolderW.append("span")
                .id("titleItemCount")
                .addClass("chartTitleItems");
            //.attach("click", (e) => this.onDataChanged("onTitleItemsClicked"));    
            //---- FILTERED COUNT ----
            countsHolderW.append("span")
                .id("titleFilteredCount")
                .addClass("chartTitleStats textPanelItem")
                .title("Reset the filter")
                .attach("click", function (e) { return _this.onDataChanged("onTitleStatsClicked"); });
            //---- SELECTED COUNT ----
            countsHolderW.append("span")
                .id("titleSelectedCount")
                .addClass("chartTitleStats textPanelItem")
                .title("Reset the selection")
                .attach("click", function (e) { return _this.onDataChanged("onTitleSelectedClicked"); });
        };
        chartClass.prototype.onSelectionChanged = function () {
            this._selectedCount = this._dataMgr.getSelectedCount();
            if (this._selectedCount == 0) {
                //---- some action cleared the selection - clear all of our selectKey stuff ----
                this.clearAxisBoxStuff();
            }
            //---- update our STATS label ----
            var reason = (this._selectedCount == 0) ? null : (this._selectedCount + "");
            var msg = (reason === null) ? "" : reason + " SELECTED";
            vp.select("#titleSelectedCount")
                .text(msg)
                .css("display", (reason) ? "" : "none");
            this.markBuildNeeded("selectionChanged");
            this.onDataChanged("selectedCount");
        };
        chartClass.prototype.onFilteredChanged = function () {
            vp.utils.debug("filteredChanged received from dataMgr");
            var dataMgr = this._dataMgr;
            this._filteredInCount = dataMgr.getFilteredInCount();
            var isFiltered = (this._filteredInCount != this._recordCount);
            this._colInfos = dataMgr.getColInfos(isFiltered);
            this._chartBuilder.onFilteredChanged(isFiltered);
            //---- update our STATS label ----
            var reason = (this._filteredInCount == this._recordCount) ? null : (this._filteredInCount + "");
            var msg = (reason === null) ? "" : reason + " FILTERED";
            vp.select("#titleFilteredCount")
                .text(msg)
                .css("display", (reason) ? "" : "none");
            this.onDataChanged("filteredInCount");
            this.markBuildNeeded("filterChanged");
        };
        chartClass.prototype.addStyleSheet = function (rule) {
            vp.dom.createStyleSheet(rule);
        };
        chartClass.prototype.setCmdId = function (value) {
            this._cmdId = value;
        };
        chartClass.prototype.onLocalStorageChange = function () {
            //---- nothing currently needed for this now that engine runs out of its iframe ----
        };
        /**
         *  Shutdown the chart & release as much memory as possible.
        */
        chartClass.prototype.shutDown = function () {
            var shapeEngine = this._chartBuilder.getShapeEngine();
            shapeEngine.shutDown();
            this._chartUx.shutDownUI();
        };
        chartClass.prototype.getBounds = function () {
            var rc = vp.select(this._root).getBounds();
            return rc;
        };
        chartClass.prototype.getPlotBounds = function () {
            return this._rcPlot;
        };
        chartClass.prototype.titleText = function (value) {
            if (arguments.length === 0) {
                return this._titleText;
            }
            this._titleText = value;
            vp.select("#titleText").text(value);
            var valueLen = (value) ? value.length : 0;
            this.logAction(beachParty.Gesture.editText, "title", beachParty.ElementType.textBox, beachParty.Action.adjust, beachParty.Target.chartTitle, true, { titleLen: valueLen }, false, { value: value });
            this.onDataChanged("titleText");
        };
        chartClass.prototype.selectXTickBox = function (index) {
            this._chartBuilder.getChartFrameHelper().selectXBoxByIndex(index);
        };
        chartClass.prototype.selectYTickBox = function (index) {
            this._chartBuilder.getChartFrameHelper().selectYBoxByIndex(index);
        };
        /**
         * Used to convert chart name and layout from insight file, UI controls, etc. into chartType.
         * @param chartName
         * @param layoutName
         */
        chartClass.getChartTypeFromName = function (chartName, layoutType) {
            var chartType = null;
            chartName = chartName.toLowerCase();
            //layoutType = layoutType.toLowerCase();
            if (chartName == "flat" || (chartName == "grid" && layoutType != null && layoutType != beachParty.LayoutType.Default)) {
                chartName = beachParty.LayoutType[layoutType];
            }
            if (chartName == "scatter-3d" || chartName == "scatter3d" || chartName == "scatter 3d") {
                chartType = beachParty.ChartType.Scatter3D;
            }
            else {
                var capChartName = beachParty.chartUtils.capitalizeFirstLetter(chartName);
                chartType = beachParty.ChartType[capChartName];
                if (chartType === undefined) {
                    chartType = beachParty.ChartType.Column; // fail soft
                }
            }
            return chartType;
        };
        chartClass.prototype.applyInsightToChart = function (insight) {
            var preload = insight.preload;
            //---- sorting stuff ----
            if (preload.sortCol) {
                this._isItemSortAscending = preload.isSortAscending;
                this.sortItemColumn(preload.sortCol);
            }
            //---- load CLIENT VIEW properties ----
            if (preload.chartName != this._chartSpecs.getChartName() || preload.subLayout != this._chartSpecs.getLayoutName()) {
                var layoutType = beachParty.LayoutType[preload.subLayout];
                var chartType = chartClass.getChartTypeFromName(preload.chartName, layoutType);
                this.changeToChart(chartType, layoutType, beachParty.Gesture.system);
            }
            //---- SIZE FACTOR ----
            if (preload.sizeFactor != this._sizeFactor) {
                this.sizeFactor(preload.sizeFactor);
            }
            //---- SEPARATION FACTOR ----
            if (preload.separationFactor != this._separationFactor) {
                this.separationFactor(preload.separationFactor);
            }
            //---- OPACITY ----
            if (preload.shapeOpacity != this._shapeOpacity) {
                this.shapeOpacity(preload.shapeOpacity);
            }
            //---- IMAGE ----
            if (preload.shapeImage != this._shapeImage) {
                this.shapeImage(preload.shapeImage);
            }
            //---- COLOR ----
            if (preload.shapeColor != this._shapeColor) {
                this.shapeColor(preload.shapeColor);
            }
            //---- FLAT PARAMS ----
            if (preload.flatParams) {
                this.buildFromTop(preload.flatParams.buildFromTop);
                this.numColumns(preload.flatParams.numColumns);
            }
            //---- CHART TITLE ----
            this.titleText(insight.name);
            //---- ATTRIBUTE mappings ----
            var icm = preload.colMappings;
            this.setAttrMapping(this._xAttr, this.copyMapping(icm.x));
            this.setAttrMapping(this._yAttr, this.copyMapping(icm.y));
            this.setAttrMapping(this._zAttr, this.copyMapping(icm.z));
            this.setAttrMapping(this._auxAttr, this.copyMapping(icm.aux));
            this.setAttrMapping(this._facetAttr, this.copyMapping(icm.facet));
            this.setAttrMapping(this._colorAttr, this.copyMapping(icm.color));
            this.setAttrMapping(this._sizeAttr, this.copyMapping(icm.size));
            this.setAttrMapping(this._shapeAttr, this.copyMapping(icm.shape));
            this.setAttrMapping(this._imageAttr, this.copyMapping(icm.image));
            this.setAttrMapping(this._lineAttr, this.copyMapping(icm.line));
            this.setAttrMapping(this._textAttr, this.copyMapping(icm.text));
        };
        chartClass.prototype.setAttrMapping = function (attr, md) {
            var colNameChanged = (attr.colName() != md.colName);
            //---- store the mapping data in the attribute ----
            attr.mappingData(md);
            if (colNameChanged) {
                this.onAttrColNameChange.trigger({ sender: this, attrName: md.attrName, colName: md.colName });
            }
        };
        chartClass.prototype.regOptions = function (value) {
            if (arguments.length == 0) {
                return this._regOptions;
            }
            this._regOptions = value;
            this.onDataChanged("regOptions");
        };
        chartClass.prototype.changeToChart = function (newChartType, layoutType, gesture, uiName, isChartCustom) {
            if (gesture === void 0) { gesture = beachParty.Gesture.click; }
            if (!uiName) {
                uiName = beachParty.getUiName(newChartType);
            }
            var oldChartType = this._chartSpecs.getChartType();
            if (newChartType == beachParty.ChartType.Spiral) {
                this.setSpiralSeed(137.508);
            }
            this._prevChartType = oldChartType;
            var cs = new beachParty.ChartSpecs(newChartType, layoutType); // create a new object (that can be compared to previous settings)
            this._chartSpecs = cs;
            this._isChartCustom = isChartCustom;
            this.setActualDrawingPrimitive();
            //---- set SORT ORDER such that transitions between SCATTER and BAR/COLUMN look their best ----
            if (oldChartType == beachParty.ChartType.Scatter) {
                this._lastScatterYCol = this._yAttr.colName();
                this._lastScatterXCol = this._xAttr.colName();
                if (newChartType == beachParty.ChartType.Column) {
                    this.sortIfNeeded(this._lastScatterYCol);
                    this.staggerForward(true);
                }
                else if (newChartType == beachParty.ChartType.Bar) {
                    this.sortIfNeeded(this._lastScatterXCol);
                    this.staggerForward(true);
                }
            }
            else if (newChartType == beachParty.ChartType.Scatter) {
                if (oldChartType == beachParty.ChartType.Column) {
                    this.sortIfNeeded(this._lastScatterYCol);
                    this.staggerForward(false);
                }
                else if (oldChartType == beachParty.ChartType.Bar) {
                    this.sortIfNeeded(this._lastScatterXCol);
                    this.staggerForward(false);
                }
            }
            if (newChartType == beachParty.ChartType.Line) {
                this.sortItemColumn(this._xAttr.colName());
            }
            this.onChartChanged(layoutType);
            this.onDataChanged("chartName");
        };
        chartClass.prototype.isChartCustom = function () {
            return this._isChartCustom;
        };
        chartClass.prototype.copyMapping = function (md) {
            var newMd = vp.utils.copyMap(md, true);
            if (newMd.colName) {
                //---- validate this column with this data (e.g., is ClusterId col missing?) ----
                var dataFrame = this.getDataFrame();
                if (!dataFrame.getColInfo(newMd.colName)) {
                    newMd.colName = null;
                }
            }
            return newMd;
        };
        chartClass.prototype.getChart = function () {
            return this;
        };
        chartClass.prototype.setAppAutoRebuild = function (autoRebuild, rebuildNow, ignoreFilterStage) {
            if (this._autoRebuild != autoRebuild) {
                this._autoRebuild = autoRebuild;
                this.onDataChanged("autoRebuild");
                vp.utils.debug("setAppAutoRebuild: value=" + autoRebuild + ", rebuildNow=" + rebuildNow);
                if (rebuildNow) {
                    this._chartBuilder.markBuildNeeded("buildNow", ignoreFilterStage);
                }
            }
        };
        chartClass.prototype.isAutoRebuild = function () {
            return this._autoRebuild;
        };
        chartClass.prototype.addBeachPartyCss = function () {
            var str = "\n            /*---- beachParty.css ----*/\n            .vpPlotBody, .directDiv { background: none; font-family: Verdana; font-size: 12px;\n                   touch-action: none; stroke-width: 1; \n                   color: #fff; stroke: #fff; fill: #fff; overflow: hidden; }\n\n             /* support for NEWLINE in tooltip strings */\n            .tooltip-inner { white-space: pre-wrap;  }\n            .canvasElem:focus { outline: 0; }\n\n            .transformWheel {stroke-width: 40px; stroke: gray; fill: none; opacity: 1;\n                             transition: opacity .5s ease-in-out;    }\n\n            .transformWheelCircle {opacity: .3; }\n            .transformWheelVBar { opacity: .3; }\n            .transformWheelHBar { opacity: .3; }\n            .groupMenuBg { fill: black; opacity: .7; stroke: none; }\n            .facetBorder { fill: none; stroke: #777; stroke-width: 1px;  }\n\n            .facetLabel { fill: white; stroke-width: 0; cursor: pointer; }\n                .facetLabel:hover { opacity: .7;  }\n                .facetLabel:active { opacity: .5;  }\n\n            .clickableAxisLabel { color: white;  }\n            .clickableAxisLabel:hover { opacity: .8; }\n\n            .toolTipText {max-width: 400px; white-space: pre-wrap; border: 1px solid gray; background: white; color: blue; \n                          padding-left: 2px; padding-right: 2px; cursor: pointer; max-height: 600px; overflow-y: auto; line-height: 14px;}\n            .toolTipTable { }\n            .toolTipName { font-weight: bold; margin-right: 16px; }\n            .toolTipValue { }\n\n            /* VuePlotPlus.css - contains default styles for vuePlot mark-based controls. */\n            /* reminder: z-index is ignored by SVG shapes, text, and images. */\n\n            /* NOTE: stroke-linecap set to value other than \"butt\" causes line to be drawn with a anti-aliased ending */\n\n            .vpxAxis { stroke: #555; fill: #555; font-family: Tahoma; font-size: 13.33px;  text-anchor:  middle; \n                       text-rendering: optimizeLegibility; shape-rendering: crispEdges; stroke-linecap: butt; stroke-width: 1px;\n            }\n\n            .vpxAxisLine { stroke-width: 1px }\n            .vpxGridLines { stroke: #888; shape-rendering: crispEdges; stroke-linecap: butt; stroke-width: 1px; }\n            .vpxAxisBox { stroke-width: 1px; stroke: #555; fill: none }\n            .vpxAxisTick { stroke-width: 1px }\n            .vpxAxisTickBox { fill: none; stroke: #888; padding-left: 6px; padding-right: 6px; cursor: pointer; stroke-width: 1px;  }\n            .vpxAxisTickBox:hover { fill: #555;  stroke: #555; }\n            .vpxAxisTickBox:active { fill: #888;  }\n            .vpxAxisLabel { stroke: none;  cursor: default;  }\n            .vpxAxisName {font-size: 16px; stroke: none; cursor: default }\n            .vpxXGridLine { stroke-width: 1px; }\n            .vpxYGridLine { stroke-width: 1px;  }\n            .vpxMinorXGridLine { stroke-width: 1px; }\n            .vpxMinorYGridLine { stroke-width: 1px; }\n            ";
            var ss = document.createElement("style");
            document.body.appendChild(ss);
            ss.innerHTML = str;
        };
        chartClass.maxCategoryBins = 999;
        chartClass.maxNumericBins = 999;
        chartClass.maxFacetCategoryBins = 255;
        chartClass.maxFacetNumericBins = 255;
        chartClass.defaultOpacity = .8;
        chartClass.defaultNumericBins = 9;
        chartClass.autoBins = 0;
        chartClass.addedBeachPartyCss = false;
        return chartClass;
    }(beachParty.dataChangerClass));
    beachParty.chartClass = chartClass;
    /** chart settings that are saved with each chartType (current session only). */
    var ViewSettings = (function () {
        function ViewSettings(shapeColor, shapeOpacity, separation, shapeName, sizeFactor, zBinCount) {
            if (shapeColor === void 0) { shapeColor = "blue"; }
            if (shapeOpacity === void 0) { shapeOpacity = 1; }
            if (separation === void 0) { separation = .5; }
            if (shapeName === void 0) { shapeName = "none"; }
            if (sizeFactor === void 0) { sizeFactor = .98; }
            if (zBinCount === void 0) { zBinCount = 3; }
            this.shapeColor = shapeColor;
            this.shapeOpacity = shapeOpacity;
            this.separation = separation;
            this.shapeName = shapeName;
            this.sizeFactor = sizeFactor;
            this.zBinCount = zBinCount;
        }
        return ViewSettings;
    }());
    beachParty.ViewSettings = ViewSettings;
})(beachParty || (beachParty = {}));
//---- NOTE: this file should be directly in the project folder (NOT under "scripts") ----
//---- NOTE: this file does NOT need to be referenced by each *.ts file; it will be implicitly referenced by VS/TSC. ----
//---- NOTE: this file does NOT need to include every *.ts file - just the ones whose order needs to be controlled (for references as *.js is loaded) ----
/// <reference path="scripts/vuePlotCore.d.ts" /> 
/// <reference path="scripts/thirdParty/gl-matrix.d.ts" /> 
/// <reference path="scripts/thirdParty/hammer.d.ts" />  
/// <reference path="scripts/beachPartyShape.d.ts" />  
//---- this list of TS files is needed to control the order the files in which the files and processed and loaded ----
/// <reference path="classes/structures.ts" />  
/// <reference path="layouts/baseLayout.ts" />  
/// <reference path="classes/chart.ts" />
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    drawHtml - draws the specified element and all of its children  of an HTML or SVG parent onto the specified canvas.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /**
     * Try the parent element and its children onto the canvas associated with "ctx".
     * @param ctx
     * @param parent
     * @param drawInfo - an object {tx: number, ty: number} - offset info
     * @param omitParentDraw
     */
    function drawHtmlChildren(ctx, parent, drawInfo, omitParentDraw, idToSkip) {
        if (parent && parent.tagName != "svg") {
            var className = parent.getAttribute("class");
            if (className != "numAdjuster" && parent.id != idToSkip) {
                if (!omitParentDraw) {
                    drawHtmlElement(ctx, parent, drawInfo);
                }
                for (var i = 0; i < parent.childElementCount; i++) {
                    var child = parent.children[i];
                    drawHtmlChildren(ctx, child, drawInfo, false, idToSkip);
                }
            }
        }
    }
    beachParty.drawHtmlChildren = drawHtmlChildren;
    function drawLine(ctx, x1, y1, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
    function isSizeSet(str) {
        return (str != null && str != "" && str != "0" && str != "0px");
    }
    function toNum(str) {
        if (str.endsWith("px")) {
            str = str.substr(0, str.length - 2);
        }
        var value = +str;
        return value;
    }
    function drawHtmlElement(ctx, elem, drawInfo) {
        var rc = elem.getBoundingClientRect();
        var style = getComputedStyle(elem);
        ctx.lineWidth = +style.strokeWidth;
        ctx.globalAlpha = +style.opacity;
        //vp.utils.debug("tag: " + elem.tagName);
        if (elem.id == "yButtonHolder") {
            var a = 9;
        }
        if (style.backgroundColor != null && style.backgroundColor != "") {
            //---- bg color ----
            ctx.fillStyle = style.backgroundColor;
            ctx.fillRect(rc.left, rc.top, rc.width, rc.height);
        }
        if (isSizeSet(style.borderLeftWidth)) {
            //---- border LEFT ----
            ctx.strokeStyle = style.borderLeftColor;
            ctx.lineWidth = +style.borderLeftWidth;
            drawLine(ctx, rc.left, rc.top, rc.left, rc.bottom);
        }
        if (isSizeSet(style.borderTopWidth)) {
            //---- border TOP ----
            ctx.strokeStyle = style.borderTopColor;
            ctx.lineWidth = +style.borderTopWidth;
            drawLine(ctx, rc.left, rc.top, rc.right, rc.top);
        }
        if (isSizeSet(style.borderRightWidth)) {
            //---- border RIGHT ----
            ctx.strokeStyle = style.borderRightColor;
            ctx.lineWidth = +style.borderRightWidth;
            drawLine(ctx, rc.right, rc.top, rc.right, rc.bottom);
        }
        if (isSizeSet(style.borderBottomWidth)) {
            //---- border BOTTOM ----
            ctx.strokeStyle = style.borderBottomColor;
            ctx.lineWidth = +style.borderBottomWidth;
            drawLine(ctx, rc.left, rc.bottom, rc.right, rc.bottom);
        }
        ctx.strokeStyle = style.stroke;
        ctx.fillStyle = style.color;
        if (elem.tagName == "IMG" && rc.width > 0 && rc.height > 0) {
            var src = elem.getAttribute("src");
            var imgElm = elem;
            var imgLeft = rc.left + toNum(elem.style.paddingLeft);
            var imgTop = rc.top + toNum(elem.style.paddingTop);
            ctx.drawImage(imgElm, imgLeft, imgTop, imgElm.width, imgElm.height);
        }
        var transform = style.transform;
        var isRotated = (transform.startsWith("matrix"));
        if (elem.textContent && elem.childElementCount == 0) {
            var padLeft = toNum(style.paddingLeft);
            var padTop = toNum(style.paddingTop);
            var padRight = toNum(style.paddingRight);
            var padBot = toNum(style.paddingBottom);
            //---- adjust rc by padding ----
            rc = vp.geom.createRect(rc.left + padLeft, rc.top + padTop, Math.max(0, rc.width - padLeft - padRight), Math.max(0, rc.height - padTop - padBot));
            //vp.utils.debug("  text=" + elem.textContent);
            var left = rc.left;
            var top = rc.top;
            if (style.verticalAlign == "baseline") {
                var topOffset = .70 * ((isRotated) ? rc.width : rc.height);
                top += topOffset;
            }
            var textAlign = style.textAlign;
            ctx.textAlign = "left";
            if (textAlign && textAlign != "left") {
                ctx.textAlign = textAlign;
                if (textAlign == "center") {
                    left += rc.width / 2;
                }
                else if (textAlign == "right") {
                    left = rc.right;
                }
            }
            ctx.font = style.fontSize + " " + style.fontFamily;
            if (isRotated) {
                ctx.save();
                //---- decode transform (this is not currently working) ----
                //var matStr = transform.substr(7, transform.length - 8);
                //var mm = matStr.split(",");
                //for (var i = 0; i < 6; i++)
                //{
                //    mm[i] = mm[i].trim();
                //}
                //ctx.translate(left, top);
                //ctx.setTransform(+mm[0], +mm[1], +mm[2], +mm[3], +mm[4], +mm[5]);
                //---- hardcode: -90 degree rotation ----
                //ctx.setTransform(1, 0, 0, 1, 0, 0);
                var myLeft = (drawInfo) ? (drawInfo.tx + left) : left;
                var myTop = (drawInfo) ? (drawInfo.ty + top) : top;
                //---- fudge factors ----
                myLeft += 5;
                myTop += 25;
                ctx.translate(myLeft, myTop); // - 20);      // -20 is fudge factor
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = "center";
                left = 0;
                top = 0;
                ctx.fillText(elem.textContent, left, top);
                ctx.restore();
            }
            else {
                ctx.fillText(elem.textContent, left, top);
            }
        }
    }
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    drawSvg - draws child elements of an SVG parent onto the specified canvas.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    function drawSvgChildren(ctx, parent, rcCanvas, xOffset, yOffset, flipY) {
        if (xOffset === void 0) { xOffset = 0; }
        if (yOffset === void 0) { yOffset = 0; }
        if (flipY === void 0) { flipY = true; }
        //---- turns out we should always ignore this ----
        flipY = false;
        //---- offset all children by the location of the group ----
        if (parent.tagName == "g") {
            var transform = parent.getAttribute("transform");
            if (transform && transform.startsWith("translate(")) {
                var str = transform.substr(10, transform.length - 11);
                if (str && str != "" && str != "0") {
                    var parts = str.split(" ");
                    var xt = (parts.length > 0) ? +parts[0] : 0;
                    var yt = (parts.length > 1) ? +parts[1] : 0;
                    xOffset += xt;
                    yOffset += yt;
                }
            }
        }
        for (var i = 0; i < parent.childElementCount; i++) {
            var child = parent.childNodes[i];
            var isHidden = false;
            if (child.getAttribute) {
                isHidden = (child.getAttribute("visibility") == "hidden");
            }
            if (!isHidden && child.style) {
                isHidden = (child.style.visibility == "hidden");
            }
            if (!isHidden) {
                drawSvgElement(ctx, child, rcCanvas, xOffset, yOffset, flipY);
                if (child.childElementCount > 0) {
                    if (child.style.opacity != "0") {
                        drawSvgChildren(ctx, child, rcCanvas, xOffset, yOffset, flipY);
                    }
                }
            }
        }
    }
    beachParty.drawSvgChildren = drawSvgChildren;
    function applyTransform(ctx, transform, xOffset, yOffset) {
        var transformed = false;
        if (transform.startsWith("rotate(")) {
            var str = transform.substr(7, transform.length - 8);
            if (str && str != "" && str != "0") {
                var parts = str.split(" ");
                var angle = (parts.length > 0) ? +parts[0] : 0;
                var x = (parts.length > 1) ? +parts[1] : 0;
                var y = (parts.length > 2) ? +parts[2] : 0;
                ctx.save();
                ctx.translate(x + xOffset, y + yOffset);
                ctx.rotate(angle * Math.PI / 180);
                transformed = true;
            }
        }
        return transformed;
    }
    /**
     * Draw the SVG element into ctx, adding xOffset/yOffset to its calculated location.  If flipY, then assume y value of elelment needs to be drawn
     * at its y-flipped location.
     * @param ctx
     * @param elem
     * @param xOffset
     * @param yOffset
     * @param flipY
     */
    function drawSvgElement(ctx, elem, rcCanvas, xOffset, yOffset, flipY) {
        var tagName = elem.tagName;
        var transformed = false;
        if (tagName != "g" && tagName !== undefined) {
            //vp.utils.debug("drawSvgElement: elem.tagName=" + tagName);
            var transform = elem.getAttribute("transform");
            if (transform) {
                yOffset += +elem.getAttribute("dy");
                transformed = applyTransform(ctx, transform, xOffset, yOffset);
            }
            if (elem.getBBox || elem.getBoundingClientRect) {
                var elemW = vp.select(elem);
                //---- get bounds relative to ctx ----
                var rc = elemW.getBounds(false);
                if (rc.width || rc.height) {
                    if (tagName == "text" && elem.textContent) {
                        var style = getComputedStyle(elem);
                        var text = elem.firstChild.textContent; // otherwise we get doubled text
                        var left = 0;
                        var top = 0;
                        if (transformed) {
                            //---- fudge factor for transformation case ----
                            top += 2;
                            left += 6;
                        }
                        else {
                            left = +elem.getAttribute("x") + xOffset;
                            top = +elem.getAttribute("y") + yOffset;
                            top += +elem.getAttribute("dy");
                        }
                        if (flipY) {
                            top = rcCanvas.height - top;
                        }
                        //vp.utils.debug("   text=" + text);
                        var ta = elem.getAttribute("text-anchor");
                        ctx.textAlign = (ta == "middle") ? "center" : (ta ? ta : "start");
                        ctx.font = style.fontSize + " " + style.fontFamily;
                        ctx.fillStyle = style.fill;
                        ctx.strokeStyle = style.stroke;
                        ctx.globalAlpha = +style.opacity;
                        ctx.fillText(text, left, top);
                    }
                    else if (tagName == "line") {
                        var style = getComputedStyle(elem);
                        var x1 = +elem.getAttribute("x1");
                        var x2 = +elem.getAttribute("x2");
                        //----- on lines, the Y values are flipped ----
                        var y1 = +elem.getAttribute("y1");
                        var y2 = +elem.getAttribute("y2");
                        x1 += xOffset;
                        x2 += xOffset;
                        y1 += yOffset;
                        y2 += yOffset;
                        if (flipY) {
                            y1 = rcCanvas.height - y1;
                            y2 = rcCanvas.height - y2;
                        }
                        if (elem.className.baseVal == "vpxAxisLine") {
                            //---- vertical line ----
                            vp.utils.debug("drawSvgElement: line - x1=" + x1 + ", x2=" + x2 + ", y1=" + y1 + ", y2=" + y2);
                        }
                        ctx.fillStyle = style.fill;
                        ctx.strokeStyle = style.stroke;
                        ctx.lineWidth = +style.strokeWidth;
                        ctx.globalAlpha = +style.opacity;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                    else if (tagName == "rect") {
                        var style = getComputedStyle(elem);
                        var x = +elem.getAttribute("x");
                        var y = +elem.getAttribute("y");
                        var width = +elem.getAttribute("width");
                        var height = +elem.getAttribute("height");
                        x += xOffset;
                        y += yOffset;
                        if (flipY) {
                            y = rcCanvas.height - y;
                        }
                        //vp.utils.debug("drawSvgElement: rect - x=" + x + ", y=" + y + ", width=" + width + ", height=" + height);
                        ctx.fillStyle = style.fill;
                        ctx.strokeStyle = style.stroke;
                        ctx.lineWidth = +style.strokeWidth;
                        ctx.globalAlpha = +style.opacity;
                        if (style.fill != "none") {
                            ctx.fillRect(x, y, width, height);
                        }
                        if (style.stroke != "none") {
                            ctx.strokeRect(x, y, width, height);
                        }
                    }
                }
            }
        }
        if (transformed) {
            ctx.restore();
        }
    }
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    boxPlot - the BoxPlot overlay for an X-Band or Y-Band chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var boxPlotClass = (function () {
        function boxPlotClass() {
        }
        boxPlotClass.run = function (data, xCol, yCol, whiskerType) {
            var totalCount = data.length;
            var groups = data.groupBy(xCol);
            var boxData = groups.map(function (group, index) {
                var ydata = group.values.map(function (data, index) { return data[yCol]; });
                var sdata = ydata.orderByNum();
                var median = 0;
                var q1 = 0;
                var q3 = 0;
                var count = sdata.length;
                var index = Math.floor(count / 2);
                if (count > 1) {
                    //---- we are using "method 2" from this Quartile definition: http://en.wikipedia.org/wiki/Quartile ----
                    if (count % 2) {
                        //---- count is ODD - use middle value ----
                        median = sdata[index];
                        var lowIndex = Math.floor(index / 2);
                        q1 = (sdata[lowIndex] + sdata[lowIndex + 1]) / 2;
                        var highIndex = index + lowIndex;
                        q3 = (sdata[highIndex] + sdata[highIndex + 1]) / 2;
                    }
                    else {
                        //---- count is EVEN - must average 2 middle values ----
                        var before = sdata[index - 1];
                        var after = sdata[index];
                        median = (before + after) / 2;
                        var lowIndex = Math.floor(index / 2);
                        q1 = sdata[lowIndex];
                        q3 = sdata[index + lowIndex + 1];
                    }
                }
                else {
                    median = sdata[0];
                    q1 = median;
                    q3 = median;
                }
                var yMin = sdata[0];
                var yMax = sdata[count - 1];
                var iqr = q3 - q1;
                var lowFence, highFence;
                if (whiskerType == WhiskerType.minMax) {
                    //---- minMax ----
                    lowFence = yMin;
                    highFence = yMax;
                }
                else if (whiskerType == WhiskerType.tukey) {
                    //---- tukey ----
                    lowFence = Math.max(yMin, q1 - 1.5 * iqr);
                    highFence = Math.min(yMax, q3 + 1.5 * iqr);
                }
                else if (whiskerType == WhiskerType.percentiles9to91) {
                    //---- percentiles9to91 ----
                    lowFence = this.getPercentile(sdata, 9);
                    highFence = this.getPercentile(sdata, 91);
                }
                else if (whiskerType == WhiskerType.percentile2to98) {
                    //---- percentile2to98 ----
                    lowFence = this.getPercentile(sdata, 2);
                    highFence = this.getPercentile(sdata, 98);
                }
                else {
                    //---- stdDev ----
                    var stdDev = this.getStdDev(sdata);
                    var mean = sdata.sum() / sdata.length;
                    lowFence = mean - stdDev;
                    highFence = mean + stdDev;
                }
                var outliers = [];
                vp.utils.debug("vp.createBoxPlotData: sdata.length=" + sdata.length);
                //---- build list of outliers ----
                for (var s = 0; s < sdata.length; s++) {
                    //if (s % 300 === 0)
                    //{
                    //    vp.utils.debug("vp.createBoxPlotData: in loop with s=" + s);
                    //}
                    var value = sdata[s];
                    if (value < lowFence) {
                        outliers.push(value);
                    }
                    else if (value > highFence) {
                        outliers.push(value);
                    }
                }
                var result = {
                    name: group.values[0][xCol], lower: q1, middle: median, upper: q3, yMin: yMin, yMax: yMax,
                    lowFence: lowFence, highFence: highFence, outliers: outliers
                };
                vp.utils.debug("vp.createBoxPlotData: result.lower=" + result.lower);
                return result;
            });
            return boxData;
        };
        boxPlotClass.getPercentile = function (sdata, percentile) {
            var index = Math.round(percentile / 100 * (sdata.length - 1));
            var value = sdata[index];
            return value;
        };
        boxPlotClass.getStdDev = function (sdata) {
            var mean = sdata.sum() / sdata.length;
            var diffs = sdata.map(function (value, index) {
                var diffSq = (value - mean) * (value - mean);
                return diffSq;
            });
            var meanDiff = diffs.sum() / sdata.length;
            var stdDev = Math.sqrt(meanDiff);
            return stdDev;
        };
        return boxPlotClass;
    }());
    beachParty.boxPlotClass = boxPlotClass;
    (function (WhiskerType) {
        WhiskerType[WhiskerType["minMax"] = 0] = "minMax";
        WhiskerType[WhiskerType["tukey"] = 1] = "tukey";
        WhiskerType[WhiskerType["percentiles9to91"] = 2] = "percentiles9to91";
        WhiskerType[WhiskerType["percentile2to98"] = 3] = "percentile2to98";
        WhiskerType[WhiskerType["stdDev"] = 4] = "stdDev";
    })(beachParty.WhiskerType || (beachParty.WhiskerType = {}));
    var WhiskerType = beachParty.WhiskerType;
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chartEng.ts - helper routines for code that used to be in the separate chart engine library.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var chartEngClass = (function (_super) {
        __extends(chartEngClass, _super);
        function chartEngClass(chart, chartBuilder, dataMgr) {
            _super.call(this);
            this._chart = chart;
            this._chartBuilder = chartBuilder;
            this._dataMgr = dataMgr;
        }
        chartEngClass.prototype.makeMatrix = function (fakeArray) {
            var mat = new Float32Array(16);
            for (var i = 0; i < 16; i++) {
                mat[i] = fakeArray[i];
            }
            return mat;
        };
        chartEngClass.prototype.buildDataFrameLoadedMsgBlock = function (dataMgr) {
            var key = "dataFrameLoaded";
            var returnData = true;
            var fn = dataMgr.getFilename();
            var recordCount = dataMgr.getDataFrame().getRecordCount();
            var colInfos = (returnData) ? dataMgr.getColInfos(true) : null;
            var origColInfos = (returnData) ? dataMgr.getOrigColInfos() : null;
            var preload = (returnData) ? dataMgr.getPreload() : null;
            var msgBlock = {
                msg: key, fn: fn, recordCount: recordCount, colInfos: colInfos,
                origColInfos: origColInfos, preload: preload
            };
            return msgBlock;
        };
        chartEngClass.prototype.loadDataFromServer = function (wdParams, requestId, callback) {
            var _this = this;
            var dataMgr = this._dataMgr;
            if (!wdParams || dataMgr.isFileLoaded(wdParams)) {
                //---- file is already loaded; process the properties sync ----
                if (callback) {
                    callback();
                }
            }
            else {
                //---- load file and then process the properties ----
                dataMgr.openPreloadAsync(wdParams, function (df) {
                    //---- don't draw twice; let client request the only draw in this sequence ----
                    _this._chartBuilder.cancelRequestedDraw();
                    if (callback) {
                        callback();
                    }
                });
            }
        };
        chartEngClass.prototype.setDataAndSystemView = function (data, preload, svd, callback) {
            var _this = this;
            var dataFrameLoadedMsgBlock = null;
            var selectedChangedMsgBlock = null;
            var filterChangedMsgBlock = null;
            var wdParams = preload;
            var dataMgr = this._dataMgr;
            var cmd = "setDataAndSystemView";
            var transformMgr = this._chartBuilder.getTransformMgr();
            if (data) {
                //---- SET DATA (from local cache) ----
                if (!wdParams) {
                    wdParams = new beachParty.WorkingDataParams();
                }
                dataMgr.setDataDirect(data, wdParams);
                //---- build msg block to describe data change ----
                dataFrameLoadedMsgBlock = this.buildDataFrameLoadedMsgBlock(dataMgr);
                var result = this.setDataAndSystemViewPost(svd, dataFrameLoadedMsgBlock, selectedChangedMsgBlock, filterChangedMsgBlock, transformMgr, dataMgr, cmd);
                if (callback) {
                    callback(result);
                }
            }
            else if (wdParams) {
                //---- we will tell client, so supress normal notification mechanism to ----
                //---- prevent duplicate msg (and subsequent mistakes) ----
                wdParams.supressDataFrameLoadedMsgToClient = true;
                //---- LOAD DATA (known or URL) ----
                this.loadDataFromServer(wdParams, null, function (e) {
                    //---- build msg block to describe data change ----
                    dataFrameLoadedMsgBlock = _this.buildDataFrameLoadedMsgBlock(dataMgr);
                    var result = _this.setDataAndSystemViewPost(svd, dataFrameLoadedMsgBlock, selectedChangedMsgBlock, filterChangedMsgBlock, transformMgr, dataMgr, cmd);
                    if (callback) {
                        callback(result);
                    }
                });
            }
            else {
                var result = this.setDataAndSystemViewPost(svd, dataFrameLoadedMsgBlock, selectedChangedMsgBlock, filterChangedMsgBlock, transformMgr, dataMgr, cmd);
                if (callback) {
                    callback(result);
                }
            }
        };
        chartEngClass.prototype.buildSelectionChangedMsgBlock = function (dataMgr) {
            var key = "selectionChanged";
            var options = { returnData: true };
            //---- return the "filtered selection" (only selected records that are in the FILTERED-IN records) ----
            var selectedCount = dataMgr.getSelectedCount(true);
            var recordCount = dataMgr.getDataFrame().getRecordCount();
            var selectedRecords = null;
            if (options.returnData) {
                selectedRecords = dataMgr.getSelectedRecords(true);
            }
            var msgBlock = { msg: key, selectedCount: selectedCount, recordCount: recordCount, selectedRecords: selectedRecords };
            return msgBlock;
        };
        chartEngClass.prototype.setDataAndSystemViewPost = function (svd, dataFrameLoadedMsgBlock, selectedChangedMsgBlock, filterChangedMsgBlock, transformMgr, dataMgr, cmd) {
            if (svd) {
                //---- set SYSTEM VIEW data ----
                var result2 = this.setSystemView(svd);
                if (result2.selectionChanged) {
                    //---- build msg block to describe selection change ----
                    selectedChangedMsgBlock = this.buildSelectionChangedMsgBlock(dataMgr);
                }
                if (result2.filterChanged) {
                    //---- build msg block to describe filter change ----
                    filterChangedMsgBlock = this.buildFilterChangedMsgBlock(dataMgr);
                }
            }
            var multiMsgBlock = {
                msg: cmd, responseId: 0,
                dataFrameLoadedMsgBlock: dataFrameLoadedMsgBlock,
                selectedChangedMsgBlock: selectedChangedMsgBlock,
                filterChangedMsgBlock: filterChangedMsgBlock
            };
            return multiMsgBlock;
        };
        chartEngClass.prototype.buildFilterChangedMsgBlock = function (dataMgr) {
            var key = "filteredChanged";
            var options = { returnData: true };
            var selectedCount = dataMgr.getSelectedCount(true);
            var filteredInCount = dataMgr.getFilteredInCount();
            var recordCount = dataMgr.getDataFrame().getRecordCount();
            var filteredRecords = null;
            var colInfos = dataMgr.getColInfos(true);
            if (options.returnData) {
                filteredRecords = dataMgr.getSelectedRecords();
            }
            var msgBlock = {
                msg: key, colInfos: colInfos, filteredInCount: filteredInCount, recordCount: recordCount, selectedCount: selectedCount,
                filteredRecords: filteredRecords
            };
            return msgBlock;
        };
        chartEngClass.prototype.setSystemView = function (svd, callback) {
            var filterChanged = false;
            var selectionChanged = false;
            var dataMgr = this._dataMgr;
            var transformMgr = this._chartBuilder.getTransformMgr();
            if (svd.filteredOutKeys) {
                filterChanged = dataMgr.setFilter(svd.filteredOutKeys);
            }
            if (svd.selectedKeys) {
                selectionChanged = dataMgr.setSelectionDirect(svd.selectedKeys, "insight");
            }
            if (svd.worldTransform) {
                var matWorld = this.makeMatrix(svd.worldTransform);
                transformMgr.getTransformer().world(matWorld);
            }
            if (svd.rotationInertia) {
                transformMgr.inertia(svd.rotationInertia);
            }
            var result = { selectionChanged: selectionChanged, filterChanged: filterChanged };
            if (callback) {
                callback(result);
            }
            return result;
        };
        chartEngClass.prototype.search = function (colName, value, maxValue, searchType, searchAction, searchRawValues, caseSensitive, selectMode, callback, selectKey) {
            if (searchType === void 0) { searchType = beachParty.TextSearchType.contains; }
            if (searchAction === void 0) { searchAction = beachParty.SearchAction.selectMatches; }
            var sp = new beachParty.SearchParams();
            sp.caseSensitiveSearch = caseSensitive;
            sp.colName = colName;
            sp.maxValue = maxValue;
            sp.minValue = value;
            sp.searchAction = searchAction;
            sp.searchRawValues = searchRawValues;
            sp.searchType = searchType;
            sp.selectMode = selectMode;
            this.searchEx([sp], selectKey, callback);
        };
        chartEngClass.prototype.searchEx = function (spList, selectKey, callback) {
            var sp = spList[0];
            var selectMode = this._chart.processSelectKey(sp.selectMode, selectKey);
            if (selectMode != sp.selectMode) {
                //---- update the selectMode in each sp ----
                for (var i = 0; i < spList.length; i++) {
                    var sp = spList[i];
                    sp.selectMode = selectMode;
                }
            }
            var results = this._dataMgr.runSearchQuery(spList);
            if (sp.searchAction == beachParty.SearchAction.returnMatches) {
                var rcPlot = this._chartBuilder.getPlotBounds(true);
                callback({ sender: this, rcPlot: rcPlot, results: results });
            }
        };
        chartEngClass.prototype.getSystemViewData = function (snapShotType, getReproData, chartBgColor, callback) {
            var svd = new beachParty.SystemViewData();
            var dataMgr = this._dataMgr;
            var transformMgr = this._chartBuilder.getTransformMgr();
            if (dataMgr.getDataFrame().getRecordCount() > 0) {
                var selectVector = dataMgr.getSelectedVector(false);
                svd.selectedKeys = dataMgr.getDataFrame().vectorToPrimaryKeys(selectVector);
                var filterVector = dataMgr.getFilteredVector(false);
                svd.filteredOutKeys = dataMgr.getDataFrame().vectorToPrimaryKeys(filterVector);
            }
            else {
                svd.selectedKeys = [];
                svd.filteredOutKeys = [];
            }
            svd.worldTransform = transformMgr.getTransformer().world();
            svd.rotationInertia = transformMgr.inertia();
            if (getReproData) {
                svd.chartRepro = this._chartBuilder.getChartRepro();
            }
            //---- did client request a copy of the plot image? ----
            if (snapShotType != beachParty.SnapshotType.none) {
                svd.imageAsUrl = this._chart.takeSnapshot(chartBgColor, snapShotType == beachParty.SnapshotType.plot);
            }
            //---- return result IMMEDIATELY back to caller ----
            callback(svd);
        };
        chartEngClass.prototype.getShapeBoundsAndRecord = function (primaryKey, colNames, callback) {
            var colValues = this._chart.getColumnValues(colNames, primaryKey);
            var rcShape = this._chart.getShapeBounds(primaryKey);
            var rcPlot = this._chartBuilder.getPlotBounds(false, true);
            var msgBlock = {
                msg: "recordAndBounds", colValues: colValues, primaryKey: primaryKey,
                rcShape: rcShape, rcPlot: rcPlot
            };
            callback(msgBlock);
        };
        chartEngClass.prototype.getMostCentralRecord = function (rcArea, colNames, callback) {
            var result = this._chartBuilder.getMostCentralRecord(rcArea, colNames);
            callback(result);
        };
        chartEngClass.prototype.applyHover = function (x, y, returnRecord, columnList, showHover, callback) {
            var primaryKey = this._chart.applyHoverCore({ x: x, y: y }, showHover);
            if (returnRecord) {
                var dataFrame = this._dataMgr.getDataFrame();
                var record = dataFrame.getRecordByPrimaryKey(primaryKey, columnList);
            }
            if (callback) {
                callback(primaryKey, record);
            }
        };
        chartEngClass.prototype.autoLoadFile = function (wdp, callback) {
            var dataMgr = this._dataMgr;
            dataMgr.autoloadFile(wdp, function (dataFrame, dataMgr, wdParams) {
                if (callback) {
                    callback(dataFrame, dataMgr, wdParams);
                }
            });
        };
        chartEngClass.prototype.getBinData = function (md, callback) {
            this._dataMgr.requestBinData(md, function (binResult) {
                var msgBlock = { msg: "binData", param: binResult };
                callback(msgBlock);
            });
        };
        chartEngClass.prototype.getMemoryUse = function (callback) {
            //---- TODO ----
            //var memObjs = <any>{};
            ////---- first build a map of major objects in engine ----
            //var chart = view.getChart();
            //memObjs.bufferMgr = (chart) ? chart.getBufferMgr() : null;
            //memObjs.dataMgr = dataMgr;
            //memObjs.dataFrame = dataFrame;
            //memObjs.chart = chart;
            //memObjs.view = view;
            //memObjs.appMgr = this._appMgr;
            //memObjs.cmdMgr = this;
            //memObjs.windowMgr = this._windowMgr;
            //memObjs.traceMgr = traceMgrClass.instance;
            //memObjs.transformer = view.getTransformer();
            //memObjs.transformMgr = view.getTransformMgr();
            //memObjs.shareMgr = dataMgr.getShareMgr();
            //memObjs.chartFrameHelper = (chart) ? chart._chartFrameHelper : null;
            //memObjs.boundingBoxMgr = (chart) ? chart.getBoundingBoxMgr() : null;
            //var memUse = utils.getMemoryUse(memObjs);
            //var requestId = msgBlock.requestId;
            //this._appMgr.postMessageToParent({ msg: "getMemoryUseResponse", responseId: requestId, memUse: memUse });
        };
        chartEngClass.prototype.getEngineEvents = function (callback) {
            var engineEvents = beachParty.traceMgrClass.instance.getCmds();
            callback({ msg: "getEngineEventsResponse", engineEvents: engineEvents });
        };
        return chartEngClass;
    }(beachParty.dataChangerClass));
    beachParty.chartEngClass = chartEngClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    localStorageMgr - manages local storage (data cachine, data preloads, add-in templates)
//-------------------------------------------------------------------------------------
/// SandDance add-in ideas:
///    - (DONE) custom color palettes, replace std color palettes
///    - (DONE) custom themes (canvas color, shape color, shape image)
///    - (DONE) custom tours 
///    - (DONE) custom scripts  (review and automate actions) 
///    - size palettes
///    - shape palettes (and images)
///    - custom images to use with static shape image
///    - custom facet layouts
///    - custom over/under lays (images) for plots (along with bounds information)
///    - custom CSS for app UI
///    - custom CSS for engine
///    - new "known" files (from WEB URL)
///    - custom 3D mesh shape to draw with (new drawing primitive)
///-----------------------------------------------------------------------------------------
///     Keys of items kept in localStorage (as of Feb-21-2016): refer to beachParty.StorageType
///-----------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var localStorageMgr = (function () {
        function localStorageMgr() {
        }
        localStorageMgr.makeKey = function (storageType, subType, fn, tableName) {
            var key = StorageType[storageType];
            if (subType != StorageSubType.none) {
                key += "^" + StorageSubType[subType];
            }
            if (fn) {
                key += "^" + fn;
            }
            if (tableName) {
                key += "^" + tableName;
            }
            return key;
        };
        localStorageMgr.getLastPartOfKey = function (key) {
            var fn = key;
            var index = key.lastIndexOf("^");
            if (index > -1) {
                fn = fn.substr(index + 1);
            }
            return fn;
        };
        localStorageMgr.dumpKeyValue = function (name, key, value) {
            var preview = (value) ? value.substr(0, 20) : "";
            var length = (value) ? value.length : 0;
            //vp.utils.debug(name + ": key: " + key + ", length: " +
            //    length + ", startsWith: " + preview);
        };
        localStorageMgr.save = function (storageType, subType, fn, value, tableName) {
            var key = this.makeKey(storageType, subType, fn, tableName);
            if (localStorage) {
                try {
                    localStorage[key] = value;
                    this.dumpKeyValue("save", key, value);
                }
                catch (ex) {
                    //---- log but ignore errors ----
                    var msg = "localStorageMgr.save: error=" + ex;
                    vp.utils.debug(msg);
                }
            }
            else if (window.external) {
                var host = window.external;
                host.saveToHostStorage(key, value);
            }
        };
        localStorageMgr.rename = function (storageType, subType, oldFn, newFn) {
            var oldKey = this.makeKey(storageType, subType, oldFn, null);
            var newKey = this.makeKey(storageType, subType, newFn, null);
            if (localStorage) {
                var value = localStorage[oldKey];
                localStorage.removeItem(oldKey);
                localStorage[newKey] = value;
            }
            else if (window.external) {
                var host = window.external;
                host.renameHostStorage(oldKey, newKey);
            }
        };
        localStorageMgr.delete = function (storageType, subType, fn, tableName) {
            var key = this.makeKey(storageType, subType, fn, tableName);
            if (localStorage) {
                localStorage.removeItem(key);
                this.dumpKeyValue("delete", key, null);
            }
            else if (window.external) {
                var host = window.external;
                var value = host.deleteFromHostStorage(key);
            }
        };
        localStorageMgr.get = function (storageType, subType, fn, tableName) {
            var key = this.makeKey(storageType, subType, fn, tableName);
            if (localStorage) {
                var value = localStorage[key];
                this.dumpKeyValue("get", key, value);
            }
            else if (window.external) {
                var host = window.external;
                var value = host.getFromHostStorage(key);
            }
            return value;
        };
        localStorageMgr.isPresent = function (storageType, subType, fn, tableName) {
            var key = this.makeKey(storageType, subType, fn, tableName);
            if (localStorage) {
                var value = localStorage[key];
                var isPresent = (value !== undefined);
                this.dumpKeyValue("isPresent", key, value);
            }
            else if (window.external) {
                var host = window.external;
                var isPresent = (host.isPresentInHostStorage(key) == "true");
            }
            return isPresent;
        };
        localStorageMgr.enumerate = function (storageType, subType, onlyLastPart) {
            var foundItems = [];
            var target = this.makeKey(storageType, subType, null, null);
            if (localStorage) {
                for (var i = 0; i < localStorage.length; i++) {
                    var key = localStorage.key(i);
                    if (key.startsWith(target)) {
                        if (onlyLastPart) {
                            key = this.getLastPartOfKey(key);
                        }
                        foundItems.push(key);
                    }
                }
            }
            else if (window.external) {
                var host = window.external;
                var matches = host.enumerateHostStorage(target);
                foundItems = matches.split(",");
                if (onlyLastPart) {
                    for (var i = 0; i < foundItems.length; i++) {
                        foundItems[i] = this.getLastPartOfKey(foundItems[i]);
                    }
                }
            }
            return foundItems;
        };
        localStorageMgr.hookChanges = function (callback) {
            //vp.utils.debug("hookChanges");
            //vp.events.attach(window, "storage", (e) =>
            //{
            //    callback(e);
            //});
        };
        localStorageMgr.clearAll = function () {
            //---- delete localStorage for all of our settings ----
            if (localStorage) {
                //---- if we do this, let it trigger event to engine ----
                localStorage.clear();
            }
            else if (window.external) {
                var host = window.external;
                var value = host.clearHostStorage();
            }
        };
        return localStorageMgr;
    }());
    beachParty.localStorageMgr = localStorageMgr;
    var CacheEntry = (function () {
        function CacheEntry() {
        }
        return CacheEntry;
    }());
    beachParty.CacheEntry = CacheEntry;
    (function (StorageType) {
        StorageType[StorageType["appSettings"] = 0] = "appSettings";
        StorageType[StorageType["currentTheme"] = 1] = "currentTheme";
        StorageType[StorageType["logTokens"] = 2] = "logTokens";
        StorageType[StorageType["dataFile"] = 3] = "dataFile";
        StorageType[StorageType["insights"] = 4] = "insights";
        StorageType[StorageType["locale"] = 5] = "locale";
        StorageType[StorageType["palette"] = 6] = "palette";
        StorageType[StorageType["preload"] = 7] = "preload";
        StorageType[StorageType["script"] = 8] = "script";
        StorageType[StorageType["sessionShare"] = 9] = "sessionShare";
        StorageType[StorageType["theme"] = 10] = "theme";
        StorageType[StorageType["tour"] = 11] = "tour";
    })(beachParty.StorageType || (beachParty.StorageType = {}));
    var StorageType = beachParty.StorageType;
    (function (StorageSubType) {
        StorageSubType[StorageSubType["none"] = 0] = "none";
        //---- sessionShare ----
        StorageSubType[StorageSubType["selectionChange"] = 1] = "selectionChange";
        StorageSubType[StorageSubType["triggerEngineRead"] = 2] = "triggerEngineRead";
        StorageSubType[StorageSubType["lastSessionState"] = 3] = "lastSessionState";
        StorageSubType[StorageSubType["testResults"] = 4] = "testResults";
        //---- logTokens ----
        StorageSubType[StorageSubType["machineId"] = 5] = "machineId";
        StorageSubType[StorageSubType["sessionId"] = 6] = "sessionId";
        StorageSubType[StorageSubType["sessionToken"] = 7] = "sessionToken";
        //---- files ----
        StorageSubType[StorageSubType["local"] = 8] = "local";
        StorageSubType[StorageSubType["web"] = 9] = "web";
        StorageSubType[StorageSubType["sql"] = 10] = "sql";
    })(beachParty.StorageSubType || (beachParty.StorageSubType = {}));
    var StorageSubType = beachParty.StorageSubType;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    searchUtils.ts - some functions to help search calls when clicking on axes or legends.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var searchUtils = (function () {
        function searchUtils() {
        }
        searchUtils.getValueOfBin = function (binResults, index) {
            var value = null;
            var useMax = false;
            //---- the last tick has an index that is one too large ----
            if (index >= binResults.bins.length) {
                index = binResults.bins.length - 1;
                useMax = true;
            }
            var bin = binResults.bins[index];
            if (bin.otherKeys) {
                value = bin.otherKeys;
            }
            else if (bin instanceof beachParty.BinInfoNum) {
                var numBin = bin;
                //---- to support sorted numeric bins, we need to keep both min/max (ascending min values are insufficient) ----
                //value = (useMax) ? numBin.max : numBin.min;
                value = { min: numBin.min, max: numBin.max };
            }
            else {
                value = bin.name;
            }
            //vp.utils.debug("getValueOfBin: index=" + index + ", value=" + value);
            return value;
        };
        searchUtils.buildSearchInfoOnElem = function (element, labelList, record, binResults, index, colName, isCategory, axisName, buttonType, isLast) {
            var isBar = (buttonType == "bar");
            var value = null;
            if (index >= 0) {
                var valueIndex = (buttonType == "bar") ? index - 1 : index;
                if (binResults) {
                    value = this.getValueOfBin(binResults, index);
                }
                else {
                    value = record.breakValue;
                }
            }
            //---- bar[0] is a dummy, so use prev label on Click ----
            if (isBar) {
                index--;
            }
            //---- bar[0] is a dummy, so don't add last label (will be a duplicate) ----
            if (true) {
                labelList.push(value);
            }
            var infoObj = {};
            element._infoObj = infoObj;
            infoObj.labelList = labelList;
            infoObj.labelIndex = index;
            infoObj.colName = colName;
            infoObj.axisName = axisName;
            infoObj.buttonType = buttonType;
            infoObj.isCategory = isCategory;
            infoObj.isLast = isLast;
            infoObj.useCategoryForBins = (binResults) ? binResults.useCategoryForBins : false;
        };
        searchUtils.searchOnTickOrBarClick = function (e, selectMode) {
            var elem = e.target;
            var infoObj = elem._infoObj;
            //---- extract info stuff into element when we built in ----
            var labels = infoObj.labelList;
            var index = infoObj.labelIndex;
            var colName = infoObj.colName;
            var axisName = infoObj.axisName;
            var buttonType = infoObj.buttonType;
            var isCategory = infoObj.isCategory;
            var isLast = infoObj.isLast;
            var useCategoryForBins = infoObj.useCategoryForBins;
            var sp = new beachParty.SearchParamsEx();
            sp.buttonType = buttonType;
            sp.buttonIndex = index;
            sp.axisName = axisName;
            sp.colName = colName;
            sp.caseSensitiveSearch = false;
            sp.searchAction = beachParty.SearchAction.selectMatches;
            sp.selectMode = selectMode;
            var isBar = (buttonType == "bar");
            //---- there are 8 cases to handle (3 variables: isCategory, bin/value, bar/tick) ----
            searchUtils.searchOnBarClick(elem, sp, isLast, labels, index, isCategory, isBar, useCategoryForBins);
            return sp;
        };
        searchUtils.searchOnBarClick = function (elem, sp, isLast, labels, index, isCategory, isBar, useCategoryForBins) {
            if (isCategory) {
                //---- CATEGORY ----
                sp.minValue = labels[index]; // could be string or string[]
                sp.maxValue = null;
                sp.searchType = beachParty.TextSearchType.exactMatch;
            }
            else {
                //---- NUMBER (or date) ----
                var labelCount = labels.length;
                sp.searchType = beachParty.TextSearchType.geqValueAndLessValue2;
                var value = labels[index];
                if (value.min !== undefined) {
                    //---- BIN: use min/max pair from a COLUMN type plt ----
                    var diff = (useCategoryForBins) ? 1 : 2;
                    if (isLast || (!isBar && index >= labels.length - diff)) {
                        index = labels.length - 1;
                        sp.searchType = beachParty.TextSearchType.betweenInclusive;
                        value = labels[index];
                    }
                    sp.minValue = value.min;
                    sp.maxValue = value.max;
                }
                else {
                    //---- BREAK VALUE: use list of break values from SCATTER type plot ----
                    if (isLast || (!isBar && index >= labels.length - 2)) {
                        index = labels.length - 2;
                        sp.searchType = beachParty.TextSearchType.betweenInclusive;
                    }
                    sp.minValue = labels[index];
                    sp.maxValue = labels[index + 1];
                }
            }
        };
        return searchUtils;
    }());
    beachParty.searchUtils = searchUtils;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    shareMgr - manages sharing of selection and other information among multiple BeachParty sessions.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var shareMgrClass = (function (_super) {
        __extends(shareMgrClass, _super);
        //---- events are async, so we cannot set a flag to know if it is us writing to LS ----
        //_isMySetting = false;
        //---- ISSUES DISCOVERED: ----
        // - For IFRAMES, IE needs to use parent window to hook storage event
        // - Each browser (IE, Chrome, Firefox) has their own localstorage - they can NOT talk to each other using LOCALSTORAGE
        // - Some browsers do NOT support "window.onstorage" form of event hooking
        function shareMgrClass(callback) {
            var _this = this;
            _super.call(this);
            this._callback = null;
            this._isSharingEnabled = true;
            this._changeNumber = 1;
            this._callback = callback;
            //---- our unique session id ----
            this._sessionId = Date.now() + "";
            var win = window;
            beachParty.localStorageMgr.hookChanges(function (e) {
                //vp.utils.debug("******* shareMgr.changeFunc: e.key=" + e.key);
                if (_this._isSharingEnabled) {
                    beachParty.addTrace("localStorage", e.key, beachParty.TraceEventType.point);
                    var myKey = beachParty.localStorageMgr.makeKey(beachParty.StorageType.sessionShare, beachParty.StorageSubType.selectionChange, _this._fn, null);
                    if (e.key == myKey) {
                        _this.processStorageChangedRecord(e.newValue);
                    }
                }
            });
        }
        shareMgrClass.prototype.setFilename = function (fn) {
            this._fn = fn;
            //this._itemId = "session-" + fn;
            //vp.utils.debug("shareName set to: " + this._itemId);
            //---- get current selection ----
            this.onLocalStorageChange();
        };
        shareMgrClass.prototype.processStorageChangedRecord = function (sdStr) {
            if (this._isSharingEnabled) {
                var sdx = JSON.parse(sdStr);
                if (sdx && sdx.changedById != this._sessionId) {
                    //---- watch out for illegal times ----
                    var timeDiff = Math.abs(Date.now() - sdx.changeTime);
                    if (timeDiff < 30 * 1000) {
                        //vp.utils.debug("====> onStorageChanged: myId=" + this._sessionId + ", sdx.filename=" + sdx.filename + ", sdx.changedById=" + sdx.changedById +
                        //    ", sdx.changeNumber=" + sdx.changeNumber);
                        this._callback(sdx);
                    }
                }
            }
        };
        /** this simulates a local storage change. */
        shareMgrClass.prototype.onLocalStorageChange = function () {
            if (this._isSharingEnabled) {
                var strJson = beachParty.localStorageMgr.get(beachParty.StorageType.sessionShare, beachParty.StorageSubType.selectionChange, this._fn);
                if (strJson) {
                    this.processStorageChangedRecord(strJson);
                }
            }
        };
        shareMgrClass.prototype.isSharingEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isSharingEnabled;
            }
            this._isSharingEnabled = value;
            this.onDataChanged("isSharingEnabled");
        };
        shareMgrClass.prototype.setSelection = function (selectedPrimaryKeys) {
            if (this._isSharingEnabled) {
                var sd = new ShareStateData(this._sessionId, this._changeNumber++, this._fn, selectedPrimaryKeys);
                var jsonStr = JSON.stringify(sd);
                beachParty.localStorageMgr.save(beachParty.StorageType.sessionShare, beachParty.StorageSubType.selectionChange, this._fn, jsonStr);
                vp.utils.debug("shareMgr.setSelection: fn=" + this._fn);
            }
        };
        return shareMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.shareMgrClass = shareMgrClass;
    var ShareStateData = (function () {
        function ShareStateData(changedById, changeNumber, fn, selectedPrimaryKeys) {
            this.changedById = changedById;
            this.changeNumber = changeNumber;
            this.changeTime = Date.now();
            this.filename = fn;
            this.selectedPrimaryKeys = selectedPrimaryKeys;
        }
        return ShareStateData;
    }());
    beachParty.ShareStateData = ShareStateData;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    traceMgr.ts - manages trace records.  These can be used to log structured information
//      and then plot the resulting records.  Can be used to diagnose complex, temporal issues with the engine.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var traceMgrClass = (function () {
        function traceMgrClass() {
            this._maxCmds = 5000;
            this._nextIndex = 0;
            traceMgrClass.instance = this;
            this._cmds = [];
        }
        traceMgrClass.prototype.addTrace = function (eventName, name, eventType, durationId) {
            if (durationId === void 0) { durationId = ""; }
            //---- since we cannot currently control the shape palette, simplfy the event types ----
            if (eventType == TraceEventType.point) {
                var et = "point";
            }
            else {
                et = "duration";
            }
            var obj = { time: new Date(), eventName: eventName, name: name, eventType: et, durationId: durationId };
            this._cmds[this._nextIndex] = obj;
            this._nextIndex++;
            //---- we keep cmds in a circular list ----
            if (this._nextIndex >= this._maxCmds) {
                this._nextIndex = 0;
            }
        };
        traceMgrClass.prototype.getCmds = function () {
            var cmds = this._cmds;
            var index = this._nextIndex;
            var forwardCmds = cmds.slice(0, index);
            var backwardCmds = cmds.slice(index, cmds.length);
            var allCmds = backwardCmds.concat(forwardCmds);
            return allCmds;
        };
        return traceMgrClass;
    }());
    beachParty.traceMgrClass = traceMgrClass;
    (function (TraceEventType) {
        TraceEventType[TraceEventType["point"] = 0] = "point";
        TraceEventType[TraceEventType["start"] = 1] = "start";
        TraceEventType[TraceEventType["end"] = 2] = "end";
    })(beachParty.TraceEventType || (beachParty.TraceEventType = {}));
    var TraceEventType = beachParty.TraceEventType;
    function addTrace(traceName, reason, eventType, durationId) {
        if (traceMgrClass.instance) {
            traceMgrClass.instance.addTrace(traceName, reason, eventType, durationId);
        }
    }
    beachParty.addTrace = addTrace;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    barSquarify.ts - builds a Column chart (with inner layout = squrify)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var barSquarifyClass = (function (_super) {
        __extends(barSquarifyClass, _super);
        function barSquarifyClass(chart) {
            _super.call(this, chart, "barSum");
            this._maxPosSumAllFacets = 0;
            this._maxNegSumAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._itemBounds = {}; // map from itemIndex to absolute rectangle bounds of each shape
            this._widthFactor = 0; // adjust each item's bottom/height to fit the tallest bin
            this._inverseSizeFactor = 0; // used to reverse effect of shader sizing
            this._yMargin = 0;
            this._yBetween = 0;
            this._xMin = 0;
            this._xMax = 0;
            this._visibleColPickers = "ya";
            this._visibleBinAdjusters = "y";
            this._chartBuilder.isXAxisClickable(false);
        }
        /** Two responsiblities: 1. compute max count for any bin, over all facets.  2. adjust scales as needed for our chart. */
        barSquarifyClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var ym = this._chart.yMapping();
            var maxPosSum = 0;
            var maxNegSum = 0;
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for consistent facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(ym, dc.layoutFilterVector, dc.nvData.y);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var results = beachParty.chartUtils.computeSumForFacet(dc, data, ym, "y", "size");
                    this._facetBinResults.push(results.binResults);
                    maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                    maxNegSum = Math.max(maxNegSum, results.maxNegSum);
                }
            }
            else {
                var results = beachParty.chartUtils.computeSumForFacet(dc, dc.nvData, ym, "y", "size");
                this._facetBinResults.push(results.binResults);
                maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                maxNegSum = Math.max(maxNegSum, results.maxNegSum);
            }
            this._maxPosSumAllFacets = maxPosSum;
            this._maxNegSumAllFacets = maxNegSum;
            vp.utils.debug("computeFacetStats: maxPosSum=" + maxPosSum + ", maxNegSum=" + maxNegSum);
            //---- return the sum of both as the "max item count" ----
            return maxPosSum + maxNegSum;
        };
        /** Responsiblities:
         1. adjust Y scale to reflect maxCount (across all facets).
         2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
        */
        barSquarifyClass.prototype.adjustScales = function (dc) {
            //---- adjust Y scale to reflect BINS ----
            var results = this._facetBinResults; //[0];
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, results);
            //---- adjust X scale to reflect MAX SUM ----
            var oldScale = dc.scales.x;
            //---- use nice numbers for domain min/max ----
            var nn = vp.scales.niceNumbersAlt.calculate(-this._maxNegSumAllFacets, this._maxPosSumAllFacets);
            dc.scales.x = vp.scales.createLinear()
                .rangeMin(oldScale.rangeMin())
                .rangeMax(oldScale.rangeMax())
                .domainMin(nn.min)
                .domainMax(nn.max);
            //---- mark scale as having pre-computed tickCount ----
            var anyScale = dc.scales.x;
            anyScale._tickCount = nn.steps + 1;
        };
        barSquarifyClass.prototype.assignRecordsToBins = function (nv, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var binAssignments = resultY.assignments;
            var itemBounds = {};
            var itemWidths = []; // the width of each item (per its X column value)
            var itemLefts = []; // the left value of each item within its bin 
            var binPosOffsets = []; // next position for an item in positive part of each bin
            var binNegOffsets = []; // next position for an item in negative part of each bin
            //---- process each (sorted) record ----
            for (var vectorIndex = 0; vectorIndex < filter.length; vectorIndex++) {
                if (!filter[vectorIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binAssign = binAssignments[vectorIndex];
                    if (binPosOffsets[binAssign] === undefined) {
                        binPosOffsets[binAssign] = 0;
                        binNegOffsets[binAssign] = 0;
                    }
                    //---- calculate the relative width of this item ----
                    var itemWidth = nv.size.values[vectorIndex];
                    itemWidths[vectorIndex] = itemWidth;
                    if (itemWidth >= 0) {
                        itemLefts[vectorIndex] = binPosOffsets[binAssign];
                        binPosOffsets[binAssign] += itemWidth;
                    }
                    else {
                        binNegOffsets[binAssign] += itemWidth;
                        itemLefts[vectorIndex] = binNegOffsets[binAssign];
                    }
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    itemWidths[vectorIndex] = 0;
                    itemLefts[vectorIndex] = 0;
                }
            }
            this._itemWidths = itemWidths;
            this._itemLefts = itemLefts;
            var facetWidth = dc.width;
            var facetHeight = dc.height;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the yScale labels ----
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            var xMin = dc.scales.x.scale(-this._maxNegSumAllFacets);
            var xMax = dc.scales.x.scale(this._maxPosSumAllFacets);
            var availWidth = xMax - xMin;
            //// prevent size adjustments in shader by setting our scale factor here to reverse shader shading.
            this._widthFactor = availWidth / (this._maxPosSumAllFacets + this._maxNegSumAllFacets);
            //---- create bounds ----
            var binLefts = [];
            var binBottoms = [];
            var bottom = dc.y + this._yMargin;
            var spacing = dc.spacingFactor; //   this.getSpacingFactor(dc);
            //---- layout each bin ----
            for (var i = 0; i < binsY.length; i++) {
                binBottoms[i] = bottom;
                bottom += (this._binHeight + this._yBetween);
                //---- offset all bins by the same amount to enable comparisons ----
                var xOffset = this._widthFactor * this._maxNegSumAllFacets;
                binLefts[i] = dc.x + xOffset;
                var binSizes = binsY[i].rowIndexes.map(function (itemNum) {
                    if (!filter[itemNum]) {
                        var size = nv.aux.values[itemNum];
                    }
                    else {
                        //---- if it is FILTERED OUT, don't include it in the layout ----
                        var size = 0;
                    }
                    //---- relative size of item ----
                    return size;
                });
                //---- layout records within the bin ----
                var binSum = binSizes.sum();
                var binHeightFactor = binSum / this._maxPosSumAllFacets;
                var binHeight = binHeightFactor * this._binHeight;
                var rc = vp.geom.createRect(binLefts[i], binBottoms[i], this._binWidth, binHeight);
                this.layoutBin(rc, binsY[i].rowIndexes, binSizes, itemBounds, spacing);
            }
            //---- not quite right...----
            this._itemBounds = itemBounds;
            this._binLefts = binLefts;
            this._binBottoms = binBottoms;
            this._itemAssignments = binAssignments;
            //---- setting this to "1" allow us to apply the sizeFactor correctly ----
            this._inverseSizeFactor = 1; // 1 / dc.userSizeFactor;            //  dc.combinedSizeFactor;
        };
        barSquarifyClass.prototype.layoutBin = function (rc, itemIndexes, binSizes, itemBounds, spacing) {
            //---- do a squarify layout for the items in this bin ----
            var squarify = new beachParty.squarifyLayoutClass();
            var cellMargin = spacing; // 0.00001;
            var cells = squarify.layout(binSizes, rc, cellMargin);
            //---- update itemBounds with results----
            for (var b = 0; b < cells.length; b++) {
                var rcItem = cells[b].rect;
                var itemIndex = itemIndexes[b];
                itemBounds[itemIndex] = rcItem;
            }
        };
        barSquarifyClass.prototype.preLayoutLoop = function (dc) {
            //var options = <sandDensityOptions>this._chartOptions;
            //var nv = dc.nvData;
            //var binResults = this._facetBinResults;
            //if (binResults && binResults.length)
            //{
            //    var yResult = binResults[dc.facetIndex];
            //    var binCount = yResult.bins.length;
            //    var width = dc.width;
            //    var height = dc.height;
            //    var approxItemHeight = height / binCount;
            //    var yMargin = .1 * approxItemHeight;
            //    var yBetween = .1 * approxItemHeight;
            //    this._yMargin = yMargin;
            //    this._yBetween = yBetween;
            //    //---- compute itemWidth and itemHeight ----
            //    var itemHeight = (height - 2 * yMargin - (binCount - 1) * yBetween) / binCount;
            //    var itemWidth = width;
            //    this._binWidth = itemWidth;
            //    this._binHeight = itemHeight;
            //    this.assignRecordsToBins(nv, yResult, dc);
            //}
            //---- compute usable part of X axis ----
            var xMin = dc.scales.x.scale(this._maxNegSumAllFacets);
            var xMax = dc.scales.x.scale(this._maxPosSumAllFacets);
            this._xMin = xMin;
            this._xMax = xMax;
            if (this._facetBinResults && dc.facetIndex < this._facetBinResults.length) {
                var facetResult = this._facetBinResults[dc.facetIndex];
                var availWidth = xMax - xMin;
                var result = beachParty.chartUtils.computeBarBinSize(facetResult, availWidth, dc.height);
                this._binWidth = result.binWidth;
                this._binHeight = result.binHeight;
                this._yMargin = result.yMargin;
                this._yBetween = result.yBetween;
                this.assignRecordsToBins(dc.nvData, facetResult, dc);
            }
        };
        barSquarifyClass.prototype.layoutDataForRecord = function (itemIndex, dc, dr) {
            var nv = dc.nvData;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[itemIndex]);
            var visibleIndex = 0;
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var binAssign = this._itemAssignments[itemIndex];
            var left = this._binLefts[binAssign];
            var bottom = this._binBottoms[binAssign];
            var widthFactor = this._widthFactor;
            var inverseSizeFactor = this._inverseSizeFactor;
            var trueWidth = Math.abs(widthFactor * this._itemWidths[itemIndex]);
            //---- layout as STACKED rectangles ----
            dr.x = left + (widthFactor * this._itemLefts[itemIndex]);
            dr.y = bottom + this._binHeight / 2; // place at horizontal center of shape
            dr.x += trueWidth / 2; // place at horizontal center of shape
            dr.z = 0;
            dr.width = inverseSizeFactor * trueWidth;
            dr.height = inverseSizeFactor * this._binHeight;
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, itemIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, itemIndex, dc.scales.imageIndex);
        };
        return barSquarifyClass;
    }(beachParty.baseLayoutClass));
    beachParty.barSquarifyClass = barSquarifyClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    fullCustom.ts - does layout based on custom unit shape grammar.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    ///-------------------------------------------------------------------------------------------------------------------------------------
    var fullCustomClass = (function (_super) {
        __extends(fullCustomClass, _super);
        function fullCustomClass(chart) {
            _super.call(this, chart, "fullCustom");
            this._maxShapeSize = 0;
            this._halfSizeSize = 0;
            this._z = 0;
            //---- for now, show everything ----
            this._visibleColPickers = "xyz";
            this._visibleBinAdjusters = "xyz";
        }
        fullCustomClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            //---- this call modifies the PREPASS scales (for use by the chart frame) ----
            this.modifyXYScales(dc);
            return dc.filteredRecordCount;
        };
        fullCustomClass.prototype.modifyXYScales = function (dc, halfShapeSize) {
            //---- add spacing on both sides of X and Y scales to keep shapes within the borders ----
            if (halfShapeSize != undefined) {
                var xExpand = halfShapeSize;
                var yExpand = halfShapeSize;
            }
            else {
                var sp = this._chart.scatterParams();
                var shapeSize = dc.maxShapeSize;
                if (sp) {
                    var xExpand = sp.percentExpandX * shapeSize;
                    var yExpand = sp.percentExpandY * shapeSize;
                }
                else {
                    var xExpand = .5 * shapeSize;
                    var yExpand = .5 * shapeSize;
                }
            }
            //---- note: expandSpace() for scale in specifed in range units (world units, in this case) ----
            dc.scales.x
                .expandSpace(xExpand);
            dc.scales.y
                .expandSpace(yExpand);
            this._halfSizeSize = xExpand;
        };
        fullCustomClass.prototype.preLayoutLoop = function (dc) {
            //---- this call modifies the FINAL scales (for use by our X/Y mapping) ----
            this.modifyXYScales(dc, this._halfSizeSize);
            this._maxShapeSize = dc.maxShapeSize;
            //---- place our 2D place in middle of Z space ----
            this._z = dc.z + dc.depth / 2;
            this.fullLayout(dc);
        };
        fullCustomClass.prototype.binFixedRange = function (bp) {
        };
        fullCustomClass.prototype.binNearBy = function (bp) {
        };
        fullCustomClass.prototype.parseBinType = function (node, binSpec) {
            var _this = this;
            var binStr = binSpec[1];
            if (binStr == "r") {
                node.binFunc = function (bp) { return _this.binFixedRange(bp); };
            }
            else if (binStr == "n") {
                node.binFunc = function (bp) { return _this.binNearBy(bp); };
            }
            else {
                vp.utils.error("Unrecognized binType: " + binSpec);
            }
        };
        fullCustomClass.prototype.parseLayout = function (node, layoutSpec) {
            var _this = this;
            var ls = layoutSpec;
            if (ls.startsWith("m")) {
                //---- MAP layout ----
                var axis = ls.substr(1);
                node.layoutsByAxis[axis] = function (lp) { return _this.layoutMap(lp); };
            }
            else if (ls.startsWith("r")) {
                //---- RANDOM layout ----
                var axis = ls.substr(1);
                node.layoutsByAxis[axis] = function (lp) { return _this.layoutRandom(lp); };
            }
            else if (ls.startsWith("b")) {
                //---- BAR layout ----
                var axis = ls.substr(1);
                node.layoutsByAxis[axis] = function (lp) { return _this.layoutBar(lp); };
            }
            else if (ls.startsWith("g")) {
                //---- BAR layout ----
                var axis = ls.substr(1);
                node.layoutsByAxis[axis] = function (lp) { return _this.layoutGrid(lp); };
            }
            else if (ls.startsWith("s")) {
                //---- BAR layout ----
                var axis = ls.substr(1);
                node.layoutsByAxis[axis] = function (lp) { return _this.layoutSpine(lp); };
            }
            else {
                vp.utils.error("Unrecognized layoutType: " + layoutSpec);
            }
        };
        fullCustomClass.prototype.getAxisBounds = function (axis, bounds) {
            var rangeMin = bounds[axis];
            var rangeMax = rangeMin + bounds[axis + "Range"];
            return { rangeMin: rangeMin, rangeMax: rangeMax };
        };
        fullCustomClass.prototype.makeScale = function (axis, bounds, colData) {
            var dataMin = colData.values.min();
            var dataMax = colData.values.max();
            var result = this.getAxisBounds(axis, bounds);
            var scale = vp.scales.createLinear();
            scale.domain(dataMin, dataMax);
            scale.range(result.rangeMin, result.rangeMax);
            return scale;
        };
        fullCustomClass.prototype.layoutMap = function (lp) {
            var dc = lp.dc;
            var axis = lp.axis;
            var results = lp.results;
            var bounds = lp.bounds;
            var colData = dc.nvData[axis];
            var scale = this.makeScale(axis, bounds, colData);
            for (var i = 0; i < colData.values.length; i++) {
                var result = this.scaleColData(colData, i, scale);
                results[i].bounds[axis] = result;
            }
        };
        fullCustomClass.prototype.layoutRandom = function (lp) {
            var dc = lp.dc;
            var axis = lp.axis;
            var results = lp.results;
            var bounds = lp.bounds;
            var colData = dc.nvData["random" + axis.toUpperCase()];
            var scale = this.makeScale(axis, bounds, colData);
            for (var i = 0; i < colData.values.length; i++) {
                var result = this.scaleColData(colData, i, scale);
                results[i].bounds[axis] = result;
            }
        };
        fullCustomClass.prototype.getMarginValue = function (dc, spec, axis) {
            var factor = spec - Math.floor(spec);
            if (axis == "x") {
                var maxSize = dc.transformer.screenSizeXToWorld(Math.floor(spec));
            }
            else if (axis == "y") {
                var maxSize = dc.transformer.screenSizeYToWorld(Math.floor(spec));
            }
            else {
                var maxSize = dc.transformer.screenSizeZToWorld(Math.floor(spec));
            }
            var value = dc.maxShapeSize * factor;
            value = Math.min(value, maxSize);
            return value;
        };
        fullCustomClass.prototype.layoutBar = function (lp) {
        };
        fullCustomClass.prototype.layoutSpine = function (lp) {
        };
        fullCustomClass.prototype.layoutGrid = function (lp) {
            var dc = lp.dc;
            var axis = lp.axis;
            var results = lp.results;
            var bounds = lp.bounds;
            var result = this.getAxisBounds(axis, bounds);
            var range = result.rangeMax - result.rangeMin;
            var margin = this.getMarginValue(dc, lp.marginSpec, axis);
            var gap = this.getMarginValue(dc, lp.gapSpec, axis);
            var count = dc.filteredRecordCount;
            var shapeStep = (range - (count - 1) * gap + 2 * margin) / count;
            var offset = result.rangeMin + margin + shapeStep / 2;
            var otherAxis = (axis == "x") ? "y" : ((axis == "z") ? "y" : "x");
            var otherAxisValue = bounds[otherAxis] + (bounds[otherAxis + "Range"] / 2);
            var otherAxisRange = bounds[otherAxis + "Range"] - 2 * dc.itemHalf;
            for (var i = 0; i < count; i++) {
                var bounds = results[i].bounds;
                bounds[axis] = offset;
                bounds[axis + "Range"] = shapeStep;
                //---- fill other axis fully ----
                bounds[otherAxis] = otherAxisValue;
                bounds[otherAxis + "Range"] = otherAxisRange;
                offset += (shapeStep + gap);
            }
        };
        fullCustomClass.prototype.parseSpec = function () {
            var root = null;
            var lastNode = null;
            var spec = this._chart.customSpec();
            var levels = spec.split(">");
            for (var i = 0; i < levels.length; i++) {
                var parts = levels[i].split(".");
                var node = new CustomLayoutNode();
                if (i == 0) {
                    root = node;
                }
                for (var p = 0; p < parts.length; p++) {
                    var part = parts[p];
                    if (part.startsWith("#")) {
                        this.parseBinType(node, part);
                    }
                    else {
                        this.parseLayout(node, part);
                    }
                }
                if (lastNode) {
                    lastNode.childLayout = node;
                }
                lastNode = node;
            }
            return root;
        };
        fullCustomClass.prototype.fullLayout = function (dc) {
            var cl = this.parseSpec();
            var data = this._chart.getDataFrame();
            var bounds = new Bounds3d(dc.x, dc.y, dc.z, dc.width, dc.height, dc.depth);
            this.layoutNextLevel(bounds, data, cl, dc);
        };
        fullCustomClass.prototype.layoutNextLevel = function (bounds, data, cl, dc) {
            if (cl.binFunc) {
                data = cl.binFunc(data);
            }
            //--- need to build scales & extra data on demand (can't rely on NV and SCALES) ----
            //---- build results ----
            var results = [];
            var recordCount = data.getRecordCount();
            for (var i = 0; i < recordCount; i++) {
                var result = new FullLayoutResult();
                var dr = new Bounds3d();
                result.bounds = dr;
                //---- defaults bounds ----
                dr.x = 0;
                dr.y = 0;
                dr.z = 0;
                dr.xRange = this._maxShapeSize;
                dr.yRange = dr.xRange;
                dr.zRange = dc.defaultDepth2d;
                result.data = data.getRecordByVectorIndex(i); // this should get the bin results
                results.push(result);
            }
            var keys = vp.utils.keys(cl.layoutsByAxis);
            var lp = new LayoutParams();
            lp.dc = dc;
            lp.results = results;
            lp.bounds = new Bounds3d(dc.x, dc.y, dc.z, dc.width, dc.height, dc.depth);
            //---- layout each axis spec for this level ----
            for (var k = 0; k < keys.length; k++) {
                var axis = keys[k];
                var layoutFunc = cl.layoutsByAxis[axis];
                lp.axis = axis;
                layoutFunc(lp);
            }
            if (false) {
            }
            else {
                this._results = results;
            }
        };
        /** "bufferIndex" in the 0-based indexed into the sorted data buffers. */
        fullCustomClass.prototype.layoutDataForRecord = function (bufferIndex, dc, dr) {
            //---- apply pre-computed bounds to specified record ----
            var rc = this._results[bufferIndex].bounds;
            dr.x = rc.x;
            dr.y = rc.y;
            dr.z = rc.z;
            dr.width = rc.xRange;
            dr.height = rc.yRange;
            dr.depth = rc.zRange;
            //---- apply default settings to color/image ----
            var nv = dc.nvData;
            var scales = dc.scales;
            dr.colorIndex = this.scaleColData(nv.colorIndex, bufferIndex, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, bufferIndex, dc.scales.imageIndex);
        };
        return fullCustomClass;
    }(beachParty.baseLayoutClass));
    beachParty.fullCustomClass = fullCustomClass;
    var Bounds3d = (function () {
        function Bounds3d(x, y, z, width, height, depth) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (width === void 0) { width = 1; }
            if (height === void 0) { height = 1; }
            if (depth === void 0) { depth = .15; }
            this.x = x;
            this.y = y;
            this.z = z;
            this.xRange = width;
            this.yRange = height;
            this.zRange = depth;
        }
        return Bounds3d;
    }());
    beachParty.Bounds3d = Bounds3d;
    var CustomLayoutNode = (function () {
        function CustomLayoutNode() {
            this.layoutsByAxis = {};
        }
        return CustomLayoutNode;
    }());
    beachParty.CustomLayoutNode = CustomLayoutNode;
    var FullLayoutData = (function () {
        function FullLayoutData() {
        }
        return FullLayoutData;
    }());
    beachParty.FullLayoutData = FullLayoutData;
    var FullLayoutResult = (function () {
        function FullLayoutResult() {
        }
        return FullLayoutResult;
    }());
    beachParty.FullLayoutResult = FullLayoutResult;
    var BinParams = (function () {
        function BinParams() {
        }
        return BinParams;
    }());
    beachParty.BinParams = BinParams;
    var LayoutParams = (function () {
        function LayoutParams() {
            this.marginSpec = 20.15;
            this.gapSpec = 2 * this.marginSpec;
        }
        return LayoutParams;
    }());
    beachParty.LayoutParams = LayoutParams;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    slidingWindow.ts - a sliding window sampler for streaming data. 
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** A sliding window sampler for streaming data.  Keeps the samples received in the last windowLength milliseconds. */
    var slidingWindowClass = (function () {
        function slidingWindowClass(windowLength) {
            this._samples = [];
            this._windowLength = windowLength;
        }
        slidingWindowClass.prototype.addSample = function (value, clear) {
            var now = vp.utils.now();
            var ts = new TimeSample(value, now);
            if (clear) {
                this._samples = [];
            }
            this._samples.push(ts);
            this.removeExpiredEntires();
        };
        slidingWindowClass.prototype.removeExpiredEntires = function () {
            var now = vp.utils.now();
            //---- remove all exipired entires ----
            var expired = now - this._windowLength;
            for (var i = this._samples.length - 1; i >= 0; i--) {
                var sample = this._samples[i];
                if (sample.timeStamp <= expired) {
                    this._samples = this._samples.slice(i + 1);
                    break;
                }
            }
        };
        slidingWindowClass.prototype.getSamples = function () {
            this.removeExpiredEntires();
            return this._samples;
        };
        return slidingWindowClass;
    }());
    beachParty.slidingWindowClass = slidingWindowClass;
    var TimeSample = (function () {
        function TimeSample(value, timeStamp) {
            this.value = value;
            this.timeStamp = timeStamp;
        }
        return TimeSample;
    }());
    beachParty.TimeSample = TimeSample;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    baseControl.ts - base class for menus and controls.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var transformWheelClass = (function (_super) {
        __extends(transformWheelClass, _super);
        function transformWheelClass(svgParent, wheelSize) {
            //super("transformerWheel", null);
            _super.call(this);
            this._partTouched = "";
            this._isActive = true;
            this._wheelSize = 0;
            //this._windowMgr = windowMgr;
            this._svgParent = svgParent;
            //---- create GROUP ----
            var groupW = vp.select(svgParent).append("g")
                .addClass("transformWheel");
            this._group = groupW[0];
            this.show(false); // initially hidden
            this.rebuild();
        }
        transformWheelClass.prototype.rebuild = function () {
            var _this = this;
            var wheelSize = this._wheelSize;
            var size2 = Math.max(0, wheelSize / 2 - 30);
            var groupW = vp.select(this._group)
                .clear();
            //---- CIRCLE ----
            var circle = groupW.append("circle")
                .addClass("transformWheelCircle")
                .attr("r", wheelSize / 2);
            this._circle = circle[0];
            circle[0]._partName = "circle";
            //---- VBAR ----
            var vBar = groupW.append("line")
                .addClass("transformWheelVBar")
                .from(0, -size2)
                .to(0, size2);
            this._vBar = vBar[0];
            vBar[0]._partName = "vBar";
            //---- HBAR ----
            var hBar = groupW.append("line")
                .addClass("transformWheelHBar")
                .from(-size2, 0)
                .to(size2, 0);
            this._hBar = hBar[0];
            hBar[0]._partName = "hBar";
            //---- hook events ----
            circle.attach("mousedown", function (e) { return _this.onPartMouseDown(e, "circle"); });
            hBar.attach("mousedown", function (e) { return _this.onPartMouseDown(e, "hBar"); });
            vBar.attach("mousedown", function (e) { return _this.onPartMouseDown(e, "vBar"); });
            //---- support 2nd finger down here, for temp. wheel operation (while first finger holds wheel down) ----
            circle.attach("pointerdown", function (e) { return _this.onPartMouseDown(e, "circle"); });
            hBar.attach("pointerdown", function (e) { return _this.onPartMouseDown(e, "hBar"); });
            vBar.attach("pointerdown", function (e) { return _this.onPartMouseDown(e, "vBar"); });
            circle.attach("mouseup", function (e) { return _this.onPartMouseUp(e, "circle"); });
            hBar.attach("mouseup", function (e) { return _this.onPartMouseUp(e, "hBar"); });
            vBar.attach("mouseup", function (e) { return _this.onPartMouseUp(e, "vBar"); });
            this.setTooltip(true);
        };
        transformWheelClass.prototype.simulateMouseDown = function (e, canvasElem) {
            var pt = vp.events.mousePosition(e);
            //---- turn off pointer-events on canvas, so that SVG can get our hit-test probe ----
            vp.select(canvasElem).css("pointer-events", "none");
            var elem = vp.events.elementFromPoint(pt.x, pt.y);
            vp.select(canvasElem).css("pointer-events", "");
            var partName = elem._partName;
            vp.utils.debug("simulateMouseDown: elem=" + partName);
            this.onPartMouseDown(e, partName);
        };
        transformWheelClass.prototype.wheelSize = function (value) {
            if (arguments.length == 0) {
                return value;
            }
            if (value < 0) {
                vp.utils.error("transformWheel: wheelSize cannot be negative: " + value);
            }
            this._wheelSize = value;
            this.rebuild();
            this.onDataChanged("wheelSize");
        };
        transformWheelClass.prototype.isActive = function (value) {
            if (arguments.length == 0) {
                return this._isActive;
            }
            this._isActive = value;
            this.show(value);
            this.onDataChanged("isActive");
        };
        transformWheelClass.prototype.setTooltip = function (value) {
            vp.select(this._group)
                .title((value) ? "Use the transform wheel to turn, flip, and spin the current chart in 3D space" : "");
        };
        transformWheelClass.prototype.onPartMouseUp = function (e, part) {
            /// TURN THIS OFF - it is too easy to trigger accidently.
            //if (this._partTouched == "middle")
            //{
            //    //---- touching middle resets TRANSFORMS ----
            //    this._windowMgr.resetStuff();
            //}
            this.partTouched("");
            this.setTooltip(true);
        };
        transformWheelClass.prototype.onPartMouseDown = function (e, part) {
            //vp.select("#consoleDiv").text("onParseMouseDown: part=" + part);
            if (this._isActive) {
                if (part == "vBar" || part == "hBar") {
                    var pt = vp.events.mousePosition(e, this._group);
                    if (this.isPtInMiddle(pt, true)) {
                        part = "middle";
                    }
                }
                this.partTouched(part);
                this.setTooltip(false);
            }
        };
        transformWheelClass.prototype.isPtInMiddle = function (pt, isRelativeToGroup) {
            if (!isRelativeToGroup) {
                //var rcx = vp.select(this._group).getBounds(false);
                var rcx = this._group.getBoundingClientRect();
                pt.x -= rcx.left;
                pt.y -= rcx.top;
            }
            var barSize = 40; // matches .transformWheel stroke-width in .css
            var halfBar = barSize / 2;
            var halfSize = this._wheelSize / 2;
            var middleStart = halfSize - halfBar + halfBar; // +halfBar = fudge factor
            var rc = vp.geom.createRect(middleStart, middleStart, barSize, barSize);
            var inMiddle = (vp.geom.rectContainsPoint(rc, pt));
            return inMiddle;
        };
        transformWheelClass.prototype.partTouched = function (value) {
            if (this._isActive) {
                if (value === undefined) {
                    return this._partTouched;
                }
                this._partTouched = value;
                vp.utils.debug("partToched=" + value);
                this.onDataChanged("partTouched");
            }
        };
        transformWheelClass.prototype.show = function (value) {
            vp.utils.debug("transformWheel: show=" + value);
            //var vis = (value) ? "visible" : "hidden";
            //vp.select(this._group)
            //    .css("visibility", vis);
            var opacity = (value) ? 1 : 0;
            vp.select(this._group)
                .css("opacity", opacity + "")
                .css("pointer-events", (value) ? "" : "none");
        };
        return transformWheelClass;
    }(beachParty.dataChangerClass));
    beachParty.transformWheelClass = transformWheelClass;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// binHelper.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - divides data into either numeric or categorical bins.
///----------------------------------------------------------------------------------------------------------------- 
var beachParty;
(function (beachParty) {
    var binHelper = (function () {
        function binHelper() {
        }
        binHelper.createBins = function (nv, colName, numericBinCount, maxCategoryBins, forceCategory, addIndexes, buildAssignments, binSortOptions, formatter, useNiceNumbers, md) {
            var result = null;
            var colData = nv[colName];
            if (md && !forceCategory) {
                forceCategory = md.forceCategory;
            }
            if (colData) {
                var typeName = colData.colType;
                if ((forceCategory) || (typeName == "string")) {
                    var requestCount = numericBinCount; //    Math.max(numericBinCount, maxCategoryBins);
                    //---- BIN the CATEGORY data ----
                    result = beachParty.binHelperCat.createCatBins(nv, colName, requestCount, addIndexes, buildAssignments, binSortOptions, md);
                }
                else {
                    if (typeName == "date") {
                        //---- BIN the DATE data ----
                        result = beachParty.binHelperDate.createDateBins(nv, colName, numericBinCount, addIndexes, buildAssignments, formatter, useNiceNumbers, md, binSortOptions);
                    }
                    else {
                        //---- BIN the NUMERIC data ----
                        result = beachParty.binHelperNum.createNumBins(nv, colName, numericBinCount, addIndexes, buildAssignments, formatter, useNiceNumbers, md, binSortOptions);
                    }
                    if (binSortOptions && binSortOptions.sortDirection != beachParty.BinSorting.none) {
                        this.sortBins(result, binSortOptions, nv);
                    }
                }
            }
            return result;
        };
        binHelper.splitBinsIntoNamedVectors = function (binResult, nv) {
            var bins = binResult.bins;
            var count = bins.length;
            var buckets = [];
            for (var i = 0; i < count; i++) {
                var bin = bins[i];
                var bucket = this.buildBinBucket(bin, nv);
                buckets.push(bucket);
            }
            return buckets;
        };
        /** for facets: split data from nv into groups, as defined by the bin result "bin". */
        binHelper.buildBinBucket = function (bin, nv) {
            var indexes = bin.rowIndexes; // the indexes in this facet bucket
            var keys = vp.utils.keys(nv);
            var bucket = {};
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var fromNV = nv[key]; // this is a NumericVector or an array of "raw" values (mapping to text attribute)
                var toNV = null;
                if (key != "length" && fromNV) {
                    var fromVector = (fromNV.values) ? fromNV.values : fromNV;
                    var toVector = new Float32Array(indexes.length);
                    var colInfo = (fromNV.colInfo) ? fromNV.colInfo : new beachParty.ColInfo("text", null, "string");
                    toNV = new beachParty.NumericVector(toVector, key, colInfo.colType, colInfo);
                    //---- transfer data for this key (named vector) ----
                    for (var i = 0; i < indexes.length; i++) {
                        var index = indexes[i];
                        var value = fromVector[index];
                        toVector[i] = value;
                    }
                    //---- if STRING, we need to recompute TEXT vector properties: rowsByKey and KeysByRow ---- 
                    if (toNV.colType == "string") {
                        beachParty.cbUtils.rebuildStringKeyIndexes(toNV, indexes, fromNV);
                    }
                    bucket[key] = toNV;
                    bucket.length = toVector.length; // fromVector.length;
                }
            }
            return bucket;
        };
        binHelper.sortBins = function (binningResults, binSortOptions, nv) {
            if (((binSortOptions.sortByAggregateType != "count") && (binSortOptions.sortByAggregateType != "sum")) ||
                (binSortOptions.sortDirection == beachParty.BinSorting.none)) {
                throw "One or more of the supplied binSortOptions values is invalid";
            }
            var result = binningResults;
            var preSortBinIDs = [];
            var postSortBinIDs = []; // Used to update result.assignments
            // Populate preSortBinIDs [needed to later populate postSortBinIDs]
            for (var i = 0; i < result.bins.length; i++) {
                var bin = result.bins[i];
                preSortBinIDs[bin.name] = i;
            }
            if (binSortOptions.sortByAggregateType == "count") {
                //---- Sort the bins by COUNT ----
                if (binSortOptions.sortDirection == beachParty.BinSorting.ascending) {
                    result.bins.sort(function (x, y) {
                        if (x.count > y.count) {
                            return (1);
                        }
                        if (x.count < y.count) {
                            return (-1);
                        }
                        return (0);
                    });
                }
                if (binSortOptions.sortDirection == beachParty.BinSorting.descending) {
                    result.bins.sort(function (x, y) {
                        if (x.count > y.count) {
                            return (-1);
                        }
                        if (x.count < y.count) {
                            return (1);
                        }
                        return (0);
                    });
                }
            }
            else if (binSortOptions.sortByAggregateType == "sum") {
                //---- Sort the bins by COUNT ----
                if (binSortOptions.sortDirection == beachParty.BinSorting.ascending) {
                    result.bins.sort(function (x, y) {
                        if (x.sum > y.sum) {
                            return (1);
                        }
                        if (x.sum < y.sum) {
                            return (-1);
                        }
                        return (0);
                    });
                }
                if (binSortOptions.sortDirection == beachParty.BinSorting.descending) {
                    result.bins.sort(function (x, y) {
                        if (x.sum > y.sum) {
                            return (-1);
                        }
                        if (x.sum < y.sum) {
                            return (1);
                        }
                        return (0);
                    });
                }
            }
            // Compute old-to-new bin ID mappings
            for (var i = 0; i < result.bins.length; i++) {
                var bin = result.bins[i];
                var oldBinID = preSortBinIDs[bin.name];
                postSortBinIDs[oldBinID] = i;
            }
            // Update bin assignments to match the new bin sorting
            if (result.assignments) {
                for (var i = 0; i < result.assignments.length; i++) {
                    var oldBinID = result.assignments[i];
                    var newBinID = postSortBinIDs[oldBinID];
                    result.assignments[i] = newBinID;
                }
            }
        };
        return binHelper;
    }());
    beachParty.binHelper = binHelper;
    var binSortOptionsClass = (function () {
        function binSortOptionsClass() {
        }
        return binSortOptionsClass;
    }());
    beachParty.binSortOptionsClass = binSortOptionsClass;
    var BinInfo = (function () {
        function BinInfo(name, isOther, otherKeys) {
            this.name = name;
            this.count = 0;
            this.rowIndexes = [];
            this.isLast = false;
            this.isOther = isOther;
            this.otherKeys = otherKeys;
            this.sum = 0;
            this.isTagBin = false;
        }
        return BinInfo;
    }());
    beachParty.BinInfo = BinInfo;
    var BinInfoNum = (function (_super) {
        __extends(BinInfoNum, _super);
        function BinInfoNum(name, min, max, actualMin, actualMax, density, ncount, ndensity) {
            _super.call(this, name);
            this.min = min;
            this.max = max;
            this.minLabel = null;
            this.maxLabel = null;
            this.actualMin = actualMin;
            this.actualMax = actualMax;
            this.density = density;
            this.ncount = ncount;
            this.ndensity = ndensity;
        }
        return BinInfoNum;
    }(BinInfo));
    beachParty.BinInfoNum = BinInfoNum;
    var BinResult = (function () {
        function BinResult() {
        }
        return BinResult;
    }());
    beachParty.BinResult = BinResult;
    var BinResultNum = (function (_super) {
        __extends(BinResultNum, _super);
        function BinResultNum() {
            _super.apply(this, arguments);
        }
        return BinResultNum;
    }(BinResult));
    beachParty.BinResultNum = BinResultNum;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// binHelperCat.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - divide the data into bins based on the specified categorical column.
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var binHelperCat = (function () {
        function binHelperCat() {
        }
        binHelperCat.createCatBins = function (nv, colName, maxCategoryBins, addIndexes, buildAssignments, binSortOptions, md) {
            var colDataInfo = nv[colName];
            var typeName = colDataInfo.colType;
            //---- we need the true filter, so we use enterExitFilter (vs. layoutFilter) ----
            var filterVector = nv.enterExitFilter;
            var filter = (filterVector) ? filterVector.values : null;
            var isUsingTags = (md && md.tagDelimiter != undefined && md.tagDelimiter != beachParty.TagDelimiter.none);
            var isUsingFacets = (nv.facet && nv.facet.colName);
            var facetKeys = (isUsingFacets) ? md.allFacetsKeys : null;
            var result0 = binHelperCat.getSortedKeyList(isUsingTags, nv, colName, filter, md, binSortOptions, assignments, buildAssignments, colDataInfo, maxCategoryBins, facetKeys);
            var keyList = result0.keyList;
            var otherKey = result0.otherKey;
            var useOtherBin = result0.useOtherBin;
            var otherKeys = result0.otherKeys;
            var sumColData = result0.sumColData;
            var groups = result0.groups;
            var otherMap = result0.otherMap;
            var otherIndex = result0.otherIndex;
            var binCount = keyList.length;
            //vp.utils.debug("--> binHelperCat: colName=" + colName + ", origCol=" +
            //    colDataInfo.colName + ", keyCount=" + binCount);
            var keyIndexes = {};
            var pkVector = nv.primaryKey;
            var bins = [];
            var assignments = [];
            //---- initialize each bin ----
            for (var i = 0; i < binCount; i++) {
                var name = keyList[i];
                var isOther = false;
                if ((i == binCount - 1) && (useOtherBin)) {
                    //name = "Other";
                    isOther = true;
                }
                if (md && md.labels && md.labels.length) {
                    var displayName = md.labels[i];
                }
                else {
                    var displayName = name;
                    if (md.formatting) {
                        var fmtFunc = vp.formatters.createExcelFormatter(md.formatting, "string");
                        displayName = fmtFunc(displayName);
                    }
                }
                bins[i] = new beachParty.BinInfo(displayName, isOther, (isOther) ? otherKeys : null);
                keyIndexes[name] = i;
                if (isUsingTags) {
                    //---- finish the bin now ----
                    var bin = bins[i];
                    bin.isTagBin = true;
                    var binRecords = groups[name];
                    bin.count = binRecords.length;
                    bin.rowIndexes = binRecords;
                    bin.isOther = true;
                    //---- build otherKeys ----
                    otherKeys = [];
                    for (var b = 0; b < binRecords.length; b++) {
                        var ri = binRecords[b];
                        var primaryKey = pkVector.getRawData(ri) + "";
                        otherKeys.push(primaryKey);
                    }
                    bin.otherKeys = otherKeys;
                }
            }
            if (!isUsingTags) {
                var colData = colDataInfo.values;
                var byVector = colData;
                var filter = (nv.layoutFilter) ? nv.layoutFilter.values : null;
                //---- ASSIGN each record to a BIN ----
                for (var i = 0; i < byVector.length; i++) {
                    var binIndex = 0;
                    var bin = bins[binIndex];
                    if (!filter || !filter[i]) {
                        if (colDataInfo.keyInfo) {
                            var key = "" + colDataInfo.keyInfo.keysByRow[i]; // force to a string, so that IndexOf works
                        }
                        else {
                            var key = "" + colData[i];
                        }
                        var binIndex = keyIndexes[key];
                        if (binIndex === undefined) {
                            if (otherMap && otherMap[key]) {
                                binIndex = otherIndex;
                            }
                            else {
                                //---- this key was not in breaks or sortedKeys; what to do? ----
                                binIndex = bins.length - 1; // for now, put it in the last bin
                            }
                        }
                        //var binIndex = (keyIndexes[key] == undefined) ? -1 : <number>keyIndexes[key]; //var binIndex = keys.indexOf(key);
                        if (binIndex >= binCount || binIndex == -1) {
                            //---- put in last (OTHER) bin ----
                            binIndex = binCount - 1;
                        }
                        if (binIndex == -1) {
                            // If the items have been filtered, then keysByRow will not contain an entry for the filtered-out items.
                            // As a result, 'key' will be undefined and indexOf(key) will return -1.  Since there is no bin for this
                            // item, there is nothing left to do. 
                            // See bug #9792.
                            if (byVector[i] == -1) {
                                continue;
                            }
                        }
                        var bin = bins[binIndex];
                        bin.count++; // count # of key values in this bin
                        if (sumColData) {
                            //---- sum data from NUMERIC sum column ----
                            var sumValue = sumColData[i];
                            bin.sum += sumValue;
                        }
                    }
                    //---- we build these lists for both IN and OUT records ----
                    if (addIndexes) {
                        bin.rowIndexes.push(i);
                    }
                    //----  let FILTERED OUT items fall into bin 0 (but they will not be drawn there) ----
                    if (buildAssignments) {
                        assignments.push(binIndex); // binIndex may be -1 (see comment below)
                    }
                }
            }
            var result = new beachParty.BinResult();
            result.bins = bins;
            result.assignments = assignments;
            result.colName = colName;
            result.isTagBinning = isUsingTags;
            return result;
        };
        binHelperCat.getSortedKeyList = function (isUsingTags, nv, colName, filter, md, binSortOptions, assignments, buildAssignments, colDataInfo, maxCategoryBins, keyList) {
            var keysSorted = false; // even if we get sortedKeys from colInfo, that is the "natural order".  user can override.
            if (isUsingTags) {
                keyList = [];
                var groups = this.groupTags(nv, colName, filter, md, binSortOptions, keyList, assignments, buildAssignments);
            }
            else {
                //---- first, just group the records by their keys ----
                var groups = this.groupRecordsByKey(nv, colName, filter, binSortOptions);
            }
            var sumColData = null;
            if (binSortOptions && binSortOptions.sumByColumn) {
                sumColData = nv[binSortOptions.sumByColumn].values;
            }
            if (!keyList) {
                //---- get preferred list of keys ----
                if (md && md.breaks) {
                    keyList = md.breaks.map(function (value) { return value + ""; });
                }
                else {
                    keyList = beachParty.cbUtils.getFilteredSortedKeys(colDataInfo, nv.layoutFilter);
                    if (!keyList) {
                        keyList = vp.utils.keys(groups);
                        keysSorted = false;
                    }
                }
            }
            //---- now sort keys as needed ----
            var sortDir = binSortOptions.sortDirection;
            var sortByKeyNames = (binSortOptions == undefined ||
                (sortDir == beachParty.BinSorting.nameAscending || sortDir == beachParty.BinSorting.nameDescending));
            if (sortByKeyNames) {
                if (!keysSorted) {
                    //---- sort the keys, if not too many ----
                    var sortMax = 50000;
                    if (keyList.length <= sortMax) {
                        keyList.sort();
                        if (sortDir == beachParty.BinSorting.nameDescending) {
                            keyList.reverse();
                        }
                    }
                }
            }
            else {
                keyList = this.sortByContent(keyList, groups, binSortOptions);
            }
            //---- now it is safe to compute the OTHER column (as per keyList sorted keys) ----
            var useOtherBin = (keyList.length > maxCategoryBins);
            if (useOtherBin) {
                var otherKeys = keyList.slice(maxCategoryBins - 1);
                keyList = keyList.slice(0, maxCategoryBins - 1);
                var otherMap = {};
                //--- build otherList ----
                var otherList = [];
                for (var i = 0; i < otherKeys.length; i++) {
                    var otherKey = otherKeys[i];
                    otherMap[otherKey] = true;
                    var list = groups[otherKey];
                    otherList = otherList.concat(list);
                }
                //---- for now, always put the "other" column at the end of the sorted keys ----
                keyList.push("Other");
                var otherIndex = keyList.length - 1;
                groups["Other"] = otherList;
            }
            return {
                keyList: keyList, otherKey: otherKey, useOtherBin: useOtherBin,
                otherKeys: otherKeys, sumColData: sumColData, groups: groups, otherMap: otherMap,
                otherIndex: otherIndex,
            };
        };
        binHelperCat.groupTags = function (nv, colName, filter, md, binSortOptions, keys, assignments, buildAssignments) {
            var groups = {};
            var colDataInfo = nv[colName];
            //---- ASSIGN each record to 0-N tags ----
            var count = colDataInfo.values.length;
            var delimiter = beachParty.TagDelimiters[md.tagDelimiter];
            for (var i = 0; i < count; i++) {
                //---- only include filtered IN records ----
                if (!filter || !filter[i]) {
                    var tagList = colDataInfo.getRawData(i);
                    var tags = tagList.split(delimiter);
                    if (buildAssignments) {
                        assignments[i] = [];
                    }
                    for (var t = 0; t < tags.length; t++) {
                        var tag = tags[t].trim();
                        //---- add record i to group tag ----
                        var tagArray = groups[tag];
                        if (tagArray === undefined) {
                            //---- new tag/key ----
                            keys.push(tag);
                            tagArray = [];
                            tagArray.keyIndex = keys.length;
                            groups[tag] = tagArray;
                        }
                        tagArray.push(i);
                        if (buildAssignments) {
                            assignments[i].push(tagArray.keyIndex);
                        }
                    }
                }
            }
            return groups;
        };
        binHelperCat.groupRecordsByKey = function (nv, colName, filter, binSortOptions) {
            var groups = {};
            var colDataInfo = nv[colName];
            var numVector = colDataInfo.values;
            var typeName = colDataInfo.colType;
            var isString = (typeName == "string");
            var keysByRow = (colDataInfo.keyInfo) ? colDataInfo.keyInfo.keysByRow : null;
            var aggColName = (binSortOptions) ? (binSortOptions.sumByColumn) : null;
            if (aggColName) {
                var aggColDataInfo = nv[aggColName];
                var aggNumVector = aggColDataInfo.values;
                var aggTypeName = aggColDataInfo.colType;
                var aggIsString = (aggTypeName == "string");
                var aggKeysByRow = (aggColDataInfo.keyInfo) ? aggColDataInfo.keyInfo.keysByRow : null;
            }
            //---- ASSIGN each record to a BIN ----
            for (var i = 0; i < numVector.length; i++) {
                //---- only include filtered IN records ----
                if (!filter || !filter[i]) {
                    var groupValue = (isString) ? keysByRow[i] : (numVector[i] + "");
                    if (aggColName) {
                        var aggValue = (aggIsString) ? +aggKeysByRow[i] : aggNumVector[i];
                    }
                    else {
                        aggValue = +groupValue;
                    }
                    var list = groups[groupValue];
                    if (list == undefined) {
                        list = [];
                        groups[groupValue] = list;
                    }
                    list.push(aggValue);
                }
            }
            return groups;
        };
        binHelperCat.sortByContent = function (keyList, groups, binSortOptions) {
            var count = (binSortOptions.sortByAggregateType == "count");
            var sum = (binSortOptions.sortByAggregateType == "sum");
            //---- compute agg value for each list in group, as indexed by keyList ----
            for (var i = 0; i < keyList.length; i++) {
                var key = keyList[i];
                var list = groups[key];
                if (list) {
                    //---- TODO: replace this calculation of "aggValue" with precomputed bin.sum ----
                    var anyList = list;
                    if (count) {
                        anyList.aggValue = list.length;
                    }
                    else if (sum) {
                        anyList.aggValue = list.sum();
                    }
                }
            }
            //---- sort the keyList by "aggValue" ----
            var newKeyList = keyList.slice(0); // copy before sorting (protect original sources)
            if (binSortOptions.sortDirection == beachParty.BinSorting.ascending) {
                newKeyList.sort(function (xx, yy) {
                    var x = groups[xx];
                    var y = groups[yy];
                    if (x.aggValue > y.aggValue) {
                        return (1);
                    }
                    if (x.aggValue < y.aggValue) {
                        return (-1);
                    }
                    return (0);
                });
            }
            else if (binSortOptions.sortDirection == beachParty.BinSorting.descending) {
                newKeyList.sort(function (xx, yy) {
                    var x = groups[xx];
                    var y = groups[yy];
                    if (x.aggValue > y.aggValue) {
                        return (-1);
                    }
                    if (x.aggValue < y.aggValue) {
                        return (1);
                    }
                    return (0);
                });
            }
            return newKeyList;
        };
        return binHelperCat;
    }());
    beachParty.binHelperCat = binHelperCat;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    binHelperDate.ts - divides up DATE data into bins.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var binHelperDate = (function () {
        function binHelperDate() {
        }
        /// returns an array of {min, max, count, density} bin objects for the specified data and binsize.
        binHelperDate.createDateBins = function (nv, colName, binSize, addIndexes, returnBinAssignments, formatter, useNiceNumbers, md, binSortOptions) {
            var bins = [];
            var assignments = [];
            var usingLocalFormatter = false;
            var recommendedDateFormatString = undefined;
            var numColData = nv[colName];
            var colData = numColData.values;
            var colInfo = numColData.colInfo;
            var breaks = null;
            var customBreaks = false;
            if (md && md.breaks && md.breaks.length) {
                breaks = md.breaks;
                customBreaks = true;
            }
            else {
                breaks = binHelperDate.computeDateBreaks(md, colInfo);
            }
            //---- for numeric bins, binCount is 1 less than break count ----
            var binCount = breaks.length - 1;
            var sumColData = null;
            if (binSortOptions && binSortOptions.sumByColumn) {
                sumColData = nv[binSortOptions.sumByColumn].values;
            }
            var filteredData = colData;
            var typeName = numColData.colType;
            var fixedSizedBuckets = true;
            //---- we need the true filter, so we use enterExitFilter (vs. layoutFilter) ----
            var filterVector = nv.enterExitFilter;
            if (filterVector) {
                //---- use "colData" for building assignments, but "filteredData" for bin boundaries ----
                filteredData = [];
                var filterValues = filterVector.values;
                for (var i = 0; i < colData.length; i++) {
                    if (!filterValues[i]) {
                        filteredData.push(colData[i]);
                    }
                }
            }
            if (binCount > 0) {
                if (md.formatting) {
                    formatter = vp.formatters.createExcelFormatter(md.formatting, typeName);
                }
                var colInfo = numColData.colInfo;
                //---- step 1: build empty bins ----
                var dataMin = breaks[0];
                var dataMax = breaks[binCount]; // for num/date, use [binCount]
                var binStart = dataMin;
                var isDescending = (dataMin > dataMax);
                var numDecimals = vp.data.calcNumDecimals(dataMax, dataMin, binCount);
                var firstNumIndex = 0;
                if (!formatter) {
                    usingLocalFormatter = true;
                }
                var firstNumIndex = 0;
                var nanCount = colInfo.stats.nanCount;
                var nanBinIndex = undefined;
                if (nanCount > 0) {
                    var bin = new beachParty.BinInfoNum("", NaN, NaN);
                    bins.push(bin);
                    binCount++;
                    firstNumIndex++;
                    nanBinIndex = 0;
                }
                if (customBreaks) {
                    var bin = new beachParty.BinInfoNum("", minValue, maxValue);
                    if (!formatter) {
                        var result = vp.dateHelper.getDateScaleValues(dataMin, dataMax, 7);
                        recommendedDateFormatString = result.formatString;
                        formatter = vp.formatters.createExcelFormatter(recommendedDateFormatString, "date");
                    }
                }
                else {
                    //---- TODO: figure out best units to use here ----
                    //---- for now, we use HOURS or multiples thereof ----
                    var result = vp.dateHelper.getDateScaleValues(dataMin, dataMax, 7);
                    var steps = result.steps;
                    recommendedDateFormatString = result.formatString;
                    if (!formatter) {
                        formatter = vp.formatters.createExcelFormatter(recommendedDateFormatString, "date");
                    }
                }
                var binSize = undefined;
                //---- BUILD BINS ----
                for (var i = 0; i < breaks.length - 1; i++) {
                    var minValue = breaks[i];
                    var maxValue = breaks[i + 1];
                    var thisSize = maxValue - minValue;
                    if (binSize === undefined) {
                        binSize = thisSize;
                    }
                    else if (thisSize != binSize) {
                        fixedSizedBuckets = false;
                    }
                    if (customBreaks) {
                        var bin = new beachParty.BinInfoNum("", minValue, maxValue);
                    }
                    else {
                        //var bin = new BinInfoNum("", minValue, maxValue);
                        var iNum = (nanCount > 0) ? i - 1 : i;
                        var binStart = dataMin + (iNum * binSize);
                        if (isDescending) {
                            var binEnd = Math.max(dataMax, binStart + binSize);
                        }
                        else {
                            var binEnd = Math.min(dataMax, binStart + binSize);
                        }
                        var bin = new beachParty.BinInfoNum("", binStart, binEnd);
                    }
                    if (addIndexes) {
                        bin.rowIndexes = [];
                    }
                    bins.push(bin);
                }
                if (bin) {
                    bin.isLast = true;
                }
                //---- step 2: fill bins ----
                var firstBinMin = dataMin; //   bins[firstNumIndex].min;
                for (var i = 0; i < colData.length; i++) {
                    //---- filtered-out shapes will go into bin 0 ----
                    var binIndex = 0;
                    var bin = bins[binIndex];
                    if (!filterValues || !filterValues[i]) {
                        var value = colData[i];
                        if (isNaN(value)) {
                            binIndex = nanBinIndex;
                        }
                        else {
                            //---- find "fltIndex" ----
                            if (fixedSizedBuckets && binSize) {
                                var fltIndex = firstNumIndex + (value - firstBinMin) / binSize;
                            }
                            else {
                                for (var j = 0; j < bins.length; j++) {
                                    var bin = bins[j];
                                    if (value < bin.max || j == (bins.length - 1)) {
                                        fltIndex = j;
                                        break;
                                    }
                                }
                            }
                            binIndex = Math.min(Math.floor(fltIndex), binCount - 1);
                            //---- enforce bin min/max settings for edge cases ----
                            if ((binIndex > firstNumIndex) && (value < bins[binIndex].min)) {
                                binIndex--;
                            }
                            else if ((binIndex < bins.length - 1) && (value >= bins[binIndex].max)) {
                                binIndex++;
                            }
                        }
                        //---- update BIN STATS (only for filtered-IN shapes) ----
                        var bin = bins[binIndex];
                        bin.count = bin.count + 1;
                        if (sumColData) {
                            var sumValue = sumColData[i];
                            bin.sum += sumValue;
                        }
                        if (bin.actualMin === undefined || value < bin.actualMin) {
                            bin.actualMin = value;
                        }
                        if (bin.actualMax === undefined || value > bin.actualMax) {
                            bin.actualMax = value;
                        }
                    }
                    //---- we build these lists for both IN and OUT records ----
                    if (addIndexes) {
                        bin.rowIndexes.push(i);
                    }
                    if (returnBinAssignments) {
                        //---- just let FILTERED OUT items fall into bin 0 assignments (but they will not be put there during drawing) ----
                        assignments[i] = binIndex;
                    }
                }
                //---- add "density" field ----   
                var itemCount = filteredData.length;
                beachParty.binHelperNum.computeBinStats(bins, itemCount);
                //---- assign final labels ----
                for (var i = 0; i < bins.length; i++) {
                    var bin = bins[i];
                    if (md && md.labels && md.labels.length) {
                        var minLabel = md.labels[i];
                        var maxLabel = md.labels[i + 1];
                    }
                    else {
                        var minLabel = formatter(bin.min);
                        var maxLabel = formatter(bin.max);
                    }
                    //bin.name = ((i == 0) ? "" : "> ") + minLabel + " ... " + maxLabel;
                    bin.name = minLabel + " ... " + maxLabel;
                    bin.minLabel = minLabel;
                    bin.maxLabel = maxLabel;
                }
            }
            var retValue = new beachParty.BinResultNum();
            retValue.colName = colName;
            retValue.bins = bins;
            retValue.assignments = assignments;
            retValue.dateFormatString = recommendedDateFormatString;
            retValue.isTagBinning = false;
            return retValue;
        };
        /**
         * Common code for finding the axis/bin break values for date columns.
         * @param md
         * @param colInfo
         */
        binHelperDate.computeDateBreaks = function (md, colInfo) {
            //---- this takes priority ----
            var breaks = md.breaks;
            if (!breaks) {
                var binCount = (md.isBinCountSoft) ? undefined : md.binCount;
                var min = +colInfo.stats.min;
                var max = +colInfo.stats.max;
                //---- handle override of min/max ----
                if (md.minBreak !== undefined) {
                    min = md.minBreak;
                }
                else if (md.minBreakFacet !== undefined) {
                    min = md.minBreakFacet;
                }
                if (md.maxBreak !== undefined) {
                    max = md.maxBreak;
                }
                if (md.maxBreakFacet !== undefined) {
                    max = md.maxBreakFacet;
                }
                if (min == max) {
                    max = min + 1; // make 2 values so that we can have at least 1 bin
                }
                //---- does caller allow nicer (round) numbers? ----
                if (md.useNiceNumbers || binCount === undefined) {
                    if (binCount === undefined) {
                        var result = vp.scales.niceNumbersAlt.calculate(min, max, undefined);
                    }
                    else {
                        //---- uses binCount+1 ----
                        var result = vp.scales.niceNumbersAlt.calculate(min, max, binCount + 1);
                    }
                    min = result.min;
                    max = result.max;
                    if (!binCount) {
                        binCount = result.steps;
                    }
                }
                var stepAmt = (max - min) / binCount;
                breaks = vp.data.range(min, max, stepAmt);
                //---- do we need to add a break value for NAN's? ----
                if (colInfo.stats.nanCount) {
                    breaks.insert(0, Number.NaN);
                }
            }
            return breaks;
        };
        return binHelperDate;
    }());
    beachParty.binHelperDate = binHelperDate;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    binHelperNum.ts - divides up numeric data into bins.  Should only pay attention to the
//    data that is IN the current layout filter (! layoutFilter[index] ).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var binHelperNum = (function () {
        function binHelperNum() {
        }
        /// returns an array of {min, max, count, density} bin objects for the specified data and binsize.
        binHelperNum.createNumBins = function (nv, colName, binSize, addIndexes, returnBinAssignments, formatter, useNiceNumbers, md, binSortOptions) {
            var bins = [];
            var assignments = [];
            var usingLocalFormatter = false;
            nv.enterExitFilter;
            var numColData = nv[colName];
            var colData = numColData.values;
            var colInfo = numColData.colInfo;
            var breaks = null;
            var customBreaks = false;
            if (md && md.breaks && md.breaks.length) {
                breaks = md.breaks;
                customBreaks = true;
            }
            else {
                breaks = binHelperNum.computeNumBreaks(md, colInfo, false);
            }
            //---- for numeric bins, binCount is 1 less than break count ----
            var binCount = breaks.length - 1;
            var sumColData = null;
            if (binSortOptions && binSortOptions.sumByColumn) {
                sumColData = nv[binSortOptions.sumByColumn].values;
            }
            var filteredData = colData;
            var typeName = numColData.colType;
            var fixedSizedBuckets = true;
            //---- we should always use nv.layoutFilter for layouts and binning ----
            var filterVector = nv.layoutFilter;
            if (filterVector) {
                //---- use "colData" for building assignments, but "filteredData" for bin boundaries ----
                filteredData = [];
                var filterValues = filterVector.values;
                for (var i = 0; i < colData.length; i++) {
                    if (!filterValues[i]) {
                        filteredData.push(colData[i]);
                    }
                }
            }
            if (binCount > 0) {
                //---- support case where we are binning with numbers, but have a formatting string from Excel ----
                //---- in this case, ignore the Excel format, and do our own local bin formatting ----
                if (formatter && formatter._colType == "number") {
                    //var isAllIntegers = vp.data.isAllIntegers(filteredData);
                    if (true) {
                        //---- remove the "General" formatter and create a smarter local formatter below ----
                        formatter = null;
                    }
                }
                if (md.formatting) {
                    formatter = vp.formatters.createExcelFormatter(md.formatting, typeName);
                }
                //---- step 1: build empty bins ----
                var dataMin = breaks[0];
                var dataMax = breaks[binCount]; // for num/date, use [binCount]
                var binStart = dataMin;
                var isDescending = (dataMin > dataMax);
                var numDecimals = vp.data.calcNumDecimals(dataMax, dataMin, binCount);
                if (!formatter) {
                    formatter = vp.formatters.createCommaFormatter(numDecimals);
                    usingLocalFormatter = true;
                }
                var binSize = undefined;
                //---- don't rely on stats while filter may be changing (it may be ahead of our view of the data) ----
                //var nanCount = colInfo.stats.nanCount;
                var nanCount = filteredData.count(isNaN);
                var firstNumIndex = 0;
                var nanBinIndex = undefined;
                vp.utils.debug("binHelperNum: colData.length=" + colData.length + ", filteredData.length=" + filteredData.length + ", nanCount=" + nanCount);
                if (nanCount > 0) {
                    var bin = new beachParty.BinInfoNum("", NaN, NaN);
                    bins.push(bin);
                    binCount++;
                    firstNumIndex++;
                    nanBinIndex = 0;
                }
                //---- BUILD BINS ----
                for (var i = 0; i < breaks.length - 1; i++) {
                    var minValue = breaks[i];
                    var maxValue = breaks[i + 1];
                    var thisSize = maxValue - minValue;
                    if (binSize === undefined) {
                        binSize = thisSize;
                    }
                    else if (thisSize != binSize) {
                        fixedSizedBuckets = false;
                    }
                    if (customBreaks) {
                        var bin = new beachParty.BinInfoNum("", minValue, maxValue);
                    }
                    else {
                        var iNum = (nanCount > 0) ? i - 1 : i;
                        var binStart = dataMin + (iNum * binSize);
                        if (isDescending) {
                            var binEnd = Math.max(dataMax, binStart + binSize);
                        }
                        else {
                            var binEnd = Math.min(dataMax, binStart + binSize);
                        }
                        var bin = new beachParty.BinInfoNum("", binStart, binEnd);
                    }
                    if (addIndexes) {
                        bin.rowIndexes = [];
                    }
                    bins.push(bin);
                }
                if (bin) {
                    bin.isLast = true;
                }
                // Make sure that the maximum value is always included as the last bin boundary [because
                // of the inherent float imprecision issues that arise from the way binStart is computed
                // (see the comment below regarding the "BEFORE bin case")]
                bins[binCount - 1].max = isDescending ? dataMin : dataMax;
                //---- step 2: fill bins ----
                var firstBinMin = dataMin; //   bins[firstNumIndex].min;
                //---- NOTE: we use "colData" here (rather than "filteredData") so that we get "binAssignments" for the full set of records ----
                for (var i = 0; i < colData.length; i++) {
                    //---- filtered-out shapes will go into bin 0 ----
                    var binIndex = 0;
                    var bin = bins[binIndex];
                    if (!filterValues || !filterValues[i]) {
                        var value = colData[i];
                        if (isNaN(value)) {
                            binIndex = nanBinIndex;
                        }
                        else {
                            //---- find "fltIndex" ----
                            if (fixedSizedBuckets && binSize) {
                                var fltIndex = firstNumIndex + (value - firstBinMin) / binSize;
                            }
                            else {
                                for (var j = 0; j < bins.length; j++) {
                                    var bin = bins[j];
                                    if (value < bin.max || j == (bins.length - 1)) {
                                        fltIndex = j;
                                        break;
                                    }
                                }
                            }
                            //var binIndex = Math.max(0, Math.floor(fltIndex - hostServices.epsilon));
                            /*
                            // Commented out 2/4/2014: With this code in place, the bin index will sometimes disagree with the bin.min/max values
                            // [eg. in DemoVote, a MedianHomeValue of 200,000 (with 15 columns) will be placed into bin index 3 (200,000.2 to 266,666.93) instead of bin index 2].
                            var binIndex = Math.max(0, Math.floor(fltIndex + hostServices.epsilon));
                            binIndex = Math.min(binIndex, binCount - 1);
                            */
                            binIndex = Math.min(Math.floor(fltIndex), binCount - 1);
                            // If we have, for example, 3 columns: "0 .. 10", "> 10 .. 20", "> 20 .. 30" then we need to
                            // ensure that the value 10 falls into bin[0] (not bin 1) and 20 falls into bin[1] (not bin 2).
                            // Note that we need to do 2 checks for the BEFORE bin case:
                            // Is the value <= the max of the bin before, or is the value equal to the min of the current bin?
                            // We need both since 'max of the bin before' and 'min of the current bin' may NOT be the same value
                            // due to float imprecision. See this in action with the titanic dataset and 15 columns on 'Age':
                            // bins[5].max = 31.999999999999996 yet bins[6].min = 32. 
                            // This happens because:
                            // (5 * binSize) + binSize = 31.999999999999996, but 6 * binSize = 32.
                            //---- enforce bin min/max settings for edge cases ----
                            if ((binIndex > firstNumIndex) && (value < bins[binIndex].min)) {
                                binIndex--;
                            }
                            else if ((binIndex < bins.length - 1) && (value >= bins[binIndex].max)) {
                                binIndex++;
                            }
                        }
                        //---- update BIN STATS (only for filtered-IN shapes) ----
                        var bin = bins[binIndex];
                        bin.count = bin.count + 1;
                        if (sumColData) {
                            var sumValue = sumColData[i];
                            bin.sum += sumValue;
                        }
                        if (bin.actualMin === undefined || value < bin.actualMin) {
                            bin.actualMin = value;
                        }
                        if (bin.actualMax === undefined || value > bin.actualMax) {
                            bin.actualMax = value;
                        }
                    }
                    //---- we build these lists for both IN and OUT records ----
                    if (addIndexes) {
                        bin.rowIndexes.push(i);
                    }
                    if (returnBinAssignments) {
                        //---- just let FILTERED OUT items fall into bin 0 assignments (but they will not be put there during drawing) ----
                        assignments[i] = binIndex;
                    }
                }
                //---- add "density" field ----   
                var itemCount = filteredData.length;
                this.computeBinStats(bins, itemCount);
                if (usingLocalFormatter && typeName == "number") {
                    //---- ensure that label decimal precision is true to the bin's content ----
                    for (var i = 0; i < 5; i++) {
                        if (!this.labelsNeedMoreDecimals(bins, formatter)) {
                            break;
                        }
                        //---- add 1 more decimal to formatter and rebuild labels ----
                        numDecimals++;
                        formatter = vp.formatters.createCommaFormatter(numDecimals);
                    }
                }
                //---- assign final labels ----
                for (var i = 0; i < bins.length; i++) {
                    var bin = bins[i];
                    if (md && md.labels && md.labels.length) {
                        var minLabel = md.labels[i];
                        var maxLabel = md.labels[i + 1];
                    }
                    else {
                        var minLabel = formatter(bin.min);
                        var maxLabel = formatter(bin.max);
                    }
                    //bin.name = ((i == 0) ? "" : "> ") + minLabel + " ... " + maxLabel;
                    bin.name = minLabel + " ... " + maxLabel;
                    bin.minLabel = minLabel;
                    bin.maxLabel = maxLabel;
                }
            }
            var retValue = new beachParty.BinResultNum();
            retValue.colName = colName;
            retValue.bins = bins;
            retValue.assignments = assignments;
            retValue.dateFormatString = null;
            retValue.isTagBinning = false;
            return retValue;
        };
        /**
         * Common code for finding the axis/bin break values for numeric columns.
         * @param md
         * @param colInfo
         */
        binHelperNum.computeNumBreaks = function (md, colInfo, addNanBreakIfNeeded) {
            //---- this takes priority ----
            var breaks = md.breaks;
            if (!breaks) {
                var binCount = (md.isBinCountSoft) ? undefined : md.binCount;
                var min = +colInfo.stats.min;
                var max = +colInfo.stats.max;
                //---- handle override of min/max ----
                if (md.minBreak !== undefined) {
                    min = md.minBreak;
                }
                else if (md.minBreakFacet !== undefined) {
                    min = md.minBreakFacet;
                }
                if (md.maxBreak !== undefined) {
                    max = md.maxBreak;
                }
                if (md.maxBreakFacet !== undefined) {
                    max = md.maxBreakFacet;
                }
                if (min == max) {
                    max = min + 1; // make 2 values so that we can have at least 1 bin
                }
                //---- does caller allow nicer (round) numbers? ----
                if (md.useNiceNumbers || binCount === undefined) {
                    if (binCount === undefined) {
                        var result = vp.scales.niceNumbersAlt.calculate(min, max, undefined);
                    }
                    else {
                        //---- uses binCount+1 ----
                        var result = vp.scales.niceNumbersAlt.calculate(min, max, binCount + 1);
                    }
                    min = result.min;
                    max = result.max;
                    if (!binCount) {
                        binCount = result.steps;
                    }
                }
                var stepAmt = (max - min) / binCount;
                breaks = vp.data.range(min, max, stepAmt);
                //---- do we need to add a break value for NAN's? ----
                if (colInfo.stats.nanCount && addNanBreakIfNeeded) {
                    breaks.insert(0, Number.NaN);
                }
            }
            return breaks;
        };
        binHelperNum.computeBinStats = function (bins, dataItemCount) {
            for (var i = 0; i < bins.length; i++) {
                var bin = bins[i];
                bin.density = bin.count / dataItemCount;
            }
            var maxCount = bins.max(function (data) { return data.count; });
            var maxDensity = bins.max(function (data) { return data.density; });
            for (var i = 0; i < bins.length; i++) {
                var bin = bins[i];
                //---- add "ncount" field (count scaled to maximum of 1) ----
                bin.ncount = bin.count / maxCount;
                //---- add "ndensity" field (density scaled to maximum of 1) ----
                bin.ndensity = bin.density / maxDensity;
            }
        };
        binHelperNum.labelsNeedMoreDecimals = function (bins, formatter) {
            var needMoreDecimals = false;
            for (var i = 0; i < bins.length; i++) {
                var bin = bins[i];
                var displayMin = +formatter(bin.min);
                var displayMax = +formatter(bin.max);
                if (i == 0) {
                    if (bin.actualMin !== undefined) {
                        if (bin.actualMin < displayMin || bin.actualMax > displayMax) {
                            needMoreDecimals = true;
                            break;
                        }
                    }
                }
                else {
                    //---- should be > min and <= max ----
                    if (bin.actualMin !== undefined) {
                        if (bin.actualMin <= displayMin || bin.actualMax > displayMax) {
                            needMoreDecimals = true;
                            break;
                        }
                    }
                }
            }
            return needMoreDecimals;
        };
        return binHelperNum;
    }());
    beachParty.binHelperNum = binHelperNum;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// csv.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - part of the beachParty library
///     - converts a CSV (comma seperated file) into an array of json objects
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// converts a csv string (read from a csv file) into a json object.
    function csvToJson(csv, hasHeader, sepChar, findTypes) {
        var loader = createCsvLoader(hasHeader, sepChar, findTypes);
        return loader.loadFromText(csv);
    }
    beachParty.csvToJson = csvToJson;
    var csvLoaderClass = (function () {
        function csvLoaderClass(hasHeader, sepChar, findTypes, fixupValues) {
            //---- private state ----
            this._colNames = [];
            this._processedHdr = false;
            this._lastLoadRemainder = "";
            this._colCount = 0;
            this._hasHeader = null;
            this._sepChar = "";
            this._quoteChar = "\"";
            this._findTypes = false;
            this._fixupValues = true;
            this._shortRowsCount = 0;
            this._hasHeader = (hasHeader === null) ? false : hasHeader;
            this._findTypes = findTypes;
            this._sepChar = (sepChar === null) ? "\t" : sepChar;
            this._fixupValues = fixupValues;
        }
        /// public: load(csv)
        csvLoaderClass.prototype.loadFromText = function (csv) {
            var startTimeInMs = vp.utils.now();
            var rows = [];
            var scanner = new beachParty.csvScannerClass(csv, this._sepChar, "\"");
            if (!this._processedHdr) {
                if (this._hasHeader) {
                    //---- read first line containing column headers ----
                    var colNum = 0;
                    //---- process first line ----
                    while (true) {
                        var colName = scanner.scan();
                        if (colName === beachParty.csvScannerClass.endOfLine || colName === beachParty.csvScannerClass.endOfFile) {
                            break;
                        }
                        colName = colName.trim();
                        // Check that the column name doesn't contain any invalid chars [that JavaSctipt - or we - may choke on]
                        //if (colName.startsWith("@") || (colName.indexOf("&") != -1))
                        //{
                        //    throw ("Column name '" + colName + "' is invalid: column names cannot contain '&' or start with '@'");
                        //}
                        this._colNames.push(colName);
                    }
                    this._colCount = this._colNames.length;
                }
                this._processedHdr = true;
            }
            var lastRowOffset = 0;
            var malformedRowErrorCount = 0;
            var reportMalformedRowErrors = true;
            while (true) {
                var row = this.collectRowValues(scanner, this._colNames);
                var colsFound = vp.utils.keys(row).length;
                if (colsFound == 0 && scanner.endOfFile()) {
                    break;
                }
                //---- if no header present, take first line of values as the "soft" column count ----
                if (this._colCount == 0) {
                    this._colCount = colsFound;
                }
                if (colsFound < this._colCount) {
                    this._shortRowsCount++;
                    if (this._shortRowsCount < 5) {
                        //---- this is not an error, but we flag it for debugging purposes ----
                        vp.utils.debug("csv short row: rowIndex=" + rows.length + ", expected=" + this._colCount + ", found=" + colsFound);
                    }
                    //---- ensure first row has all names ----
                    if (rows.length == 0) {
                        for (var i = colsFound; i < this._colCount; i++) {
                            var name = this._colNames[i];
                            row[name] = "";
                        }
                    }
                }
                rows.push(row);
                lastRowOffset = i;
            }
            if (this._shortRowsCount) {
                vp.utils.debug("csv total SHORT ROWS=" + this._shortRowsCount);
            }
            //---- test each column to see if all numeric; if so, convert to numbers ----
            if ((this._findTypes) && (rows.length > 0)) {
                var firstRow = rows[0];
                var keys = vp.utils.keys(firstRow);
                //---- test each column ----
                for (var i = 0; i < keys.length; i++) {
                    this.tryToConvertColToNativeType(rows, keys[i]);
                }
            }
            var elapsedMs = new Date().getTime() - startTimeInMs;
            // alert("load() elapsed ms = " + elapsedMs.toString());
            return rows;
        };
        csvLoaderClass.prototype.collectRowValues = function (scanner, colNames) {
            //---- process next line (row) of data ----
            var colNum = 0;
            var row = {};
            while (true) {
                var colValue = scanner.scan();
                if (colValue === beachParty.csvScannerClass.endOfLine || colValue === beachParty.csvScannerClass.endOfFile) {
                    break;
                }
                var colName = (colNum < colNames.length) ? colNames[colNum] : "col" + colNum;
                row[colName] = colValue;
                colNum++;
            }
            return row;
        };
        csvLoaderClass.prototype.tryToConvertColToNativeType = function (rows, colName) {
            if (!this.tryToConvertColToBool(rows, colName)) {
                /// since JavaScript cannot tell the difference between a DATE and a number reliably, don't auto convert to date.
                if (true) {
                    this.tryToConvertColToNumeric(rows, colName);
                }
            }
        };
        csvLoaderClass.prototype.tryToConvertColToNumeric = function (rows, colName) {
            var isNumeric = true;
            var values = [];
            for (var i = 0; i < rows.length; i++) {
                var row = rows[i];
                var str = row[colName];
                if (str) {
                    //---- TODO: add support for various standard number formats (e.g., 35,032.33) ----
                    //---- for now, just remove commas (works for US but not other locales) ----
                    str = str.replace(/,/g, "");
                }
                else {
                    str = "";
                }
                if (!this._fixupValues && str.trim() == "") {
                    //---- convert missing number to null ----
                    values.push(null);
                }
                else {
                    var value = Number(str);
                    if (isNaN(value)) {
                        str = str.toLowerCase();
                        if (str == "null" || str == "na" || str == "") {
                            value = 0;
                        }
                        else {
                            isNumeric = false;
                            break;
                        }
                    }
                    values.push(value);
                }
            }
            if (isNumeric) {
                for (var i = 0; i < rows.length; i++) {
                    var row = rows[i];
                    row[colName] = values[i];
                }
            }
            return isNumeric;
        };
        csvLoaderClass.prototype.tryToConvertColToBool = function (rows, colName) {
            var isBool = true;
            var values = [];
            for (var i = 0; i < rows.length; i++) {
                var row = rows[i];
                var str = row[colName].toLowerCase();
                if (str == "true") {
                    values.push(true);
                }
                else if (str == "false") {
                    values.push(false);
                }
                else {
                    isBool = false;
                    break;
                }
            }
            if (isBool) {
                for (var i = 0; i < rows.length; i++) {
                    var row = rows[i];
                    row[colName] = values[i];
                }
            }
            return isBool;
        };
        csvLoaderClass.prototype.tryToConvertColToDate = function (rows, colName) {
            var isDate = true;
            var values = [];
            for (var i = 0; i < rows.length; i++) {
                var row = rows[i];
                var str = row[colName];
                //---- TODO: add support for various standard date formats (e.g., yyyy-mm-dd) ----
                var value = Date.parse(str);
                if (isNaN(value)) {
                    isDate = false;
                    break;
                }
                values.push(value);
            }
            if (isDate) {
                for (var i = 0; i < rows.length; i++) {
                    var row = rows[i];
                    row[colName] = values[i];
                }
            }
            return isDate;
        };
        return csvLoaderClass;
    }());
    beachParty.csvLoaderClass = csvLoaderClass;
    function createCsvLoader(hasHeader, sepChar, findTypes, fixupValues) {
        if (fixupValues === void 0) { fixupValues = true; }
        return new csvLoaderClass(hasHeader, sepChar, findTypes, fixupValues);
    }
    beachParty.createCsvLoader = createCsvLoader;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// csvColLoader.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - part of the beachParty library
///     - loads columns on demand from a raw block of CSV text.
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var csvColLoaderClass = (function () {
        function csvColLoaderClass(text, hasHeader, sepChar, findTypes, fixupValues) {
            //---- private state ----
            this._colNames = [];
            this._processedHdr = false;
            this._lastLoadRemainder = "";
            this._colCount = 0;
            this._rowCount = 0;
            this._hasHeader = null;
            this._sepChar = "";
            this._quoteChar = "\"";
            this._findTypes = false;
            this._fixupValues = true;
            this._shortRowsCount = 0;
            this._text = text;
            this._hasHeader = (hasHeader === null) ? false : hasHeader;
            this._findTypes = findTypes;
            this._sepChar = (sepChar === null) ? "\t" : sepChar;
            this._fixupValues = fixupValues;
        }
        /** load header and determine col types thru record sampling. */
        csvColLoaderClass.prototype.buildDataFrameWithEmptyVectors = function () {
            var scanner = new beachParty.csvScannerClass(this._text, this._sepChar, "\"");
            this._scanner = scanner;
            //---- read first line containing column headers ----
            this.readHeaderRow(scanner);
            //---- read entire text to build rowIndexes[] ----
            this.buildColRowIndexes(scanner);
            //---- sample records to determine colTypes ----
            var colTypes = this.sampleForColTypes(scanner);
            //---- build DataColum array ----
            var dataColumns = [];
            for (var i = 0; i < colTypes.length; i++) {
                var colName = this._colNames[i];
                var dataCol = new beachParty.DataColumn(colName, null, colTypes[i], null);
                dataCol.data = null;
                dataColumns[i] = dataCol;
            }
            var dataFrame = new beachParty.dataFrameClass(dataColumns);
            return dataFrame;
        };
        csvColLoaderClass.prototype.readRowsWithVectors = function (scanner, vectors, startRow, rowCount) {
            var startOffset = this._colRowIndexes[0][startRow];
            scanner._offset = startOffset;
            for (var i = 0; i < rowCount; i++) {
                //---- process next row ----
                var valueCount = 0;
                for (var i = 0; i < this._colCount; i++) {
                    var vector = vectors[i];
                    var value = scanner.scan();
                    if (value === beachParty.csvScannerClass.endOfLine || value === beachParty.csvScannerClass.endOfFile) {
                        break;
                    }
                    vector.push(value);
                    valueCount++;
                }
                //---- fill missing values ----
                while (valueCount < this._colCount) {
                    //---- add empty values for rest of the row ----
                    var vector = vectors[valueCount++];
                    vector.push("");
                }
                //---- skip extra values ----
                while (value !== beachParty.csvScannerClass.endOfLine && value !== beachParty.csvScannerClass.endOfFile) {
                    value = scanner.scan();
                }
                if (value === beachParty.csvScannerClass.endOfFile) {
                    break;
                }
            }
        };
        csvColLoaderClass.prototype.fillSparseColVectors = function (vectorMap, scanner, colIndexes) {
            //---- process by vector (for now; todo: try processing by row later & compare timings) ----
            for (var i = 0; i < colIndexes.length; i++) {
                var colIndex = colIndexes[i];
                var colName = this._colNames[colIndex];
                var vector = [];
                vectorMap[colName] = vector;
                //---- fill colIndex ----
                for (var r = 0; r < this._rowCount; r++) {
                    var startIndex = this._colRowIndexes[colIndex][r];
                    var endIndex = this._colRowIndexes[colIndex + 1][r] - 1;
                    var value = this._text.substr(startIndex, endIndex - startIndex);
                    if (value.startsWith(this._quoteChar) && value.endsWith(this._quoteChar)) {
                        //---- remove surrounding quotes ----
                        value = value.substr(1, value.length - 2);
                    }
                    vector.push(value);
                }
            }
        };
        csvColLoaderClass.prototype.getRecord = function (rowIndex, colNames) {
            var startOffset = this._colRowIndexes[0][rowIndex];
            var scanner = this._scanner;
            scanner._offset = startOffset;
            var valueCount = 0;
            var record = {};
            for (var i = 0; i < this._colCount; i++) {
                var value = scanner.scan();
                if (value === beachParty.csvScannerClass.endOfLine || value === beachParty.csvScannerClass.endOfFile) {
                    break;
                }
                var name = this._colNames[i];
                record[name] = value;
                valueCount++;
            }
            return record;
        };
        csvColLoaderClass.prototype.loadColumns = function (vectorMap, colNames) {
            var colIndexes = [];
            for (var i = 0; i < colNames.length; i++) {
                var colName = colNames[i];
                var index = this._colNames.indexOf(colName);
                if (index == -1) {
                    throw "loadColumns(): unknown colName=" + colName;
                }
                colIndexes.push(index);
            }
            this.fillSparseColVectors(vectorMap, this._scanner, colIndexes);
        };
        csvColLoaderClass.prototype.sampleForColTypes = function (scanner) {
            //---- number of records to sample ----
            var topCount = 100;
            var middleCount = 100;
            var bottomCount = 100;
            var rowCount = this._rowCount;
            if (rowCount < 1000) {
                //---- just use all data ----
                topCount = rowCount;
                middleCount = 0;
                bottomCount = 0;
            }
            //---- build empty array of vectors ----
            var vectors = [];
            for (var i = 0; i < this._colCount; i++) {
                vectors[i] = [];
            }
            var topIndex = 0;
            var middleIndex = rowCount / 2 - middleCount / 2;
            var bottomIndex = rowCount - bottomCount;
            //---- pseudo random samples, in a way that is repeatable ----
            this.readRowsWithVectors(scanner, vectors, topIndex, topCount);
            this.readRowsWithVectors(scanner, vectors, middleIndex, middleCount);
            this.readRowsWithVectors(scanner, vectors, bottomIndex, bottomCount);
            //---- set colTypes from records[] ----
            var colTypes = [];
            for (var i = 0; i < this._colCount; i++) {
                var colName = this._colNames[i];
                //this.tryToConvertColToNativeType(records, colName);
                var vector = vectors[i];
                var colType = vp.data.getDataType(vector);
                colTypes.push(colType);
            }
            return colTypes;
        };
        csvColLoaderClass.prototype.buildColRowIndexes = function (scanner) {
            //---- build empty array of rowIndexes (one for each column) ----
            var colRowIndexes = [];
            this._colRowIndexes = colRowIndexes;
            //---- build 1 extra for finding end of last column on each row ----
            for (var i = 0; i <= this._colCount; i++) {
                var rowIndexes = [];
                colRowIndexes.push(rowIndexes);
            }
            while (true) {
                //---- record start of next row ----
                var valueCount = 0;
                //---- process next row ----
                while (true) {
                    var startOffset = scanner._offset;
                    var value = scanner.scan();
                    if (value === beachParty.csvScannerClass.endOfLine || value === beachParty.csvScannerClass.endOfFile) {
                        break;
                    }
                    var rowIndexes = colRowIndexes[valueCount];
                    rowIndexes.push(startOffset);
                    valueCount++;
                    if (valueCount == this._colCount) {
                        //---- add end of last column info ----
                        var rowIndexes = colRowIndexes[valueCount];
                        var offset = scanner._offset;
                        if (!scanner.justPassedDelimiter()) {
                            offset++;
                        }
                        rowIndexes.push(offset);
                    }
                }
                if (value === beachParty.csvScannerClass.endOfFile) {
                    break;
                }
            }
            this._rowCount = colRowIndexes[0].length;
        };
        csvColLoaderClass.prototype.readHeaderRow = function (scanner) {
            var colNum = 0;
            this._colNames = [];
            while (true) {
                var colName = scanner.scan();
                if (colName === beachParty.csvScannerClass.endOfLine || colName === beachParty.csvScannerClass.endOfFile) {
                    break;
                }
                if (this._hasHeader) {
                    // Check that the column name doesn't contain any invalid chars [that JavaSctipt - or we - may choke on]
                    //if (colName.startsWith("@") || (colName.indexOf("&") != -1))
                    //{
                    //    throw ("Column name '" + colName + "' is invalid: column names cannot contain '&' or start with '@'");
                    //}
                    colName = colName.trim();
                }
                else {
                    colName = "column" + (colNum + 1);
                }
                this._colNames.push(colName);
            }
            this._colCount = this._colNames.length;
            if (!this._hasHeader) {
                //---- reset scanner to first row ----
                scanner = new beachParty.csvScannerClass(this._text, this._sepChar, "\"");
            }
        };
        return csvColLoaderClass;
    }());
    beachParty.csvColLoaderClass = csvColLoaderClass;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// csvScanner.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - part of the beachParty library
///     - scans values in a CSV (text delimited) file
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var csvScannerClass = (function () {
        function csvScannerClass(text, delimiter, quoteChar) {
            //---- scanner state ----
            this._text = null;
            this._offset = 0;
            this._delimiter = delimiter;
            this._quoteChar = quoteChar;
            this._offset - 0;
            //---- make scanner simpler by collapsing multi char line endings ----
            text = text.replace(/\r\n/g, "\n");
            text = text.replace(/\r/g, "\n");
            this._text = text;
        }
        csvScannerClass.prototype.scan = function () {
            var value = csvScannerClass.endOfFile;
            var offset = this._offset;
            var start = offset;
            var text = this._text;
            if (offset < text.length) {
                var ch = text[offset++];
                if (ch == "\n") {
                    value = csvScannerClass.endOfLine;
                }
                else if (ch == this._delimiter) {
                    value = "";
                }
                else {
                    //---- scan NORMAL value which might contain a quoted subset ----
                    var inQuotedPhrase = false;
                    var foundAQuote = false;
                    value = "";
                    while (true) {
                        if (inQuotedPhrase) {
                            //---- QUOTE mode processing ----
                            if (ch == this._quoteChar) {
                                //---- EMBEDDED quote? ----
                                if (offset < text.length && text[offset] == this._quoteChar) {
                                    value += ch;
                                    offset++; // skip over 2nd quote char
                                }
                                else {
                                    //---- normal ENDING quote ----
                                    inQuotedPhrase = false;
                                    value += ch;
                                }
                            }
                            else {
                                //---- normal char in quote mode ----
                                value += ch;
                            }
                        }
                        else {
                            //---- NORMAL mode processing ----
                            if (ch == this._quoteChar) {
                                foundAQuote = true;
                                inQuotedPhrase = true;
                                value += ch;
                            }
                            else if (ch == this._delimiter) {
                                break;
                            }
                            else if (ch == "\n") {
                                //---- don't consume the newline until our next call ----
                                offset--;
                                break;
                            }
                            else {
                                //---- normal char in normal mode ----
                                value += ch;
                            }
                        }
                        if (offset >= text.length) {
                            break;
                        }
                        ch = text[offset++];
                    }
                    //---- debug ----
                    if (foundAQuote) {
                        //alert("quoted value: " + value);
                        var dummy = 9;
                    }
                    //---- if value is surrounded by quotes, remove them ----
                    if (value.startsWith(this._quoteChar) && value.endsWith(this._quoteChar)) {
                        value = value.substr(1, value.length - 2);
                    }
                }
                this._offset = offset;
            }
            return value;
        };
        csvScannerClass.prototype.justPassedDelimiter = function () {
            var lastOffset = this._offset - 1;
            var text = this._text;
            return (lastOffset >= 0 && lastOffset < text.length && text[lastOffset] === this._delimiter);
        };
        csvScannerClass.prototype.endOfFile = function () {
            return (this._offset >= this._text.length);
        };
        csvScannerClass.endOfLine = -1;
        csvScannerClass.endOfFile = null;
        return csvScannerClass;
    }());
    beachParty.csvScannerClass = csvScannerClass;
    function testCsvScanner() {
        var scanner = new csvScannerClass('abc;def;ghi\n1;2;3\naaa;"bbb";ccc\naaa;"bb""bb";ccc\n', ";", "\"");
        while (true) {
            var value = scanner.scan();
            vp.utils.debug("csvScan: value=" + value);
            if (value == csvScannerClass.endOfFile) {
                break;
            }
        }
    }
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// dataFrame.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - a class to represent a dataset as a set of named vectors.  This is a lightweight version of the NDV data format.
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// Note: dataFrame does NOT change the original data, but it cache numeric vectors on-demand for each column. 
    var dataFrameClass = (function (_super) {
        __extends(dataFrameClass, _super);
        function dataFrameClass(dataColumns) {
            _super.call(this);
            this.ctr = "dataFrameClass";
            this._sortKey = "none"; // colName + "up" or "down"
            this._pkToVectorIndex = {};
            this._recordCount = 0;
            this._getColInfoWorkCount = 0;
            this._isFilterActive = false; // must be pushed to us by dataMgr 
            //this._appMgr = appMgr;
            this._columns = dataColumns;
            this._wdParams = new beachParty.WorkingDataParams("");
            var colMap = {};
            this._colMap = colMap;
            for (var i = 0; i < dataColumns.length; i++) {
                var col = dataColumns[i];
                colMap[col.name] = col;
            }
            this._numericVectorsCache = {};
            //---- code for running in engine or on client ----
            //if (this._appMgr && this._appMgr._dataView)
            //{
            //    var view = this._appMgr._dataView;
            //    var blankValueStr = view.blankValueStr();
            //}
            //else
            {
                var blankValueStr = "<blank>";
            }
            this._recordCount = this.computeRecordCount();
        }
        dataFrameClass.prototype.computeRecordCount = function () {
            var recordCount = 0;
            var cols = this._columns;
            if (cols && cols.length) {
                recordCount = cols[0].data.length;
            }
            return recordCount;
        };
        dataFrameClass.prototype.isFilterActive = function (value) {
            if (arguments.length == 0) {
                return this._isFilterActive;
            }
            this._isFilterActive = value;
            this.onDataChanged("isFilterActive");
        };
        dataFrameClass.prototype.setWdParams = function (wdParams) {
            this._wdParams = wdParams;
        };
        dataFrameClass.prototype.getColTypes = function () {
            var colTypes = this._columns.map(function (col) { return col.colType; });
            return colTypes;
        };
        dataFrameClass.prototype.getColInfos = function () {
            var colInfos = [];
            var columns = this._columns;
            for (var i = 0; i < columns.length; i++) {
                var col = columns[i];
                var colInfo = this.getColInfo(col.name);
                colInfos.push(colInfo);
            }
            return colInfos;
        };
        dataFrameClass.prototype.getColInfo = function (name) {
            var numVector = this.getNumericVector(name);
            var colInfo = numVector.colInfo;
            return colInfo;
        };
        /** returns the type of column (date, number, string).  This value is calculated on demand, and then cached. */
        dataFrameClass.prototype.getColType = function (name) {
            var colType = null;
            var col = this._colMap[name];
            if (col) {
                colType = col.colType;
            }
            return colType;
        };
        /** ensure the specified columns are loaded and the other columns are closed (to minimize memory use). */
        dataFrameClass.prototype.loadColumns = function (colList) {
            //if (this._loader)
            //{
            //    //---- close unneeded columns ----
            //    for (var i = 0; i < this._names.length; i++)
            //    {
            //        var name = this._names[i];
            //        if (systemColNames.indexOf(name) == -1)
            //        {
            //            if (colList.indexOf(name) == -1)
            //            {
            //                this._vectorsByName[name] = null;
            //                this._numericVectorsCache[name] = null;
            //            }
            //        }
            //    }
            //    //---- gather list of columns that we need to load ----
            //    var loadList = [];
            //    for (var i = 0; i < colList.length; i++)
            //    {
            //        var name = colList[i];
            //        if (this._vectorsByName[name] == null)
            //        {
            //            loadList.push(name);
            //        }
            //    }
            //    if (loadList.length)
            //    {
            //        this._loader.loadColumns(this._vectorsByName, loadList);
            //    }
            //}
        };
        dataFrameClass.prototype.rebuildPrimaryKeyIndex = function () {
            var pkMap = {};
            var pkVector = this.getVector(beachParty.primaryKeyName, false);
            for (var i = 0; i < pkVector.length; i++) {
                var pk = pkVector[i];
                pkMap[pk] = i;
            }
            this._pkToVectorIndex = pkMap;
        };
        dataFrameClass.prototype.getColumnNames = function () {
            return this._columns.map(function (col) { return col.name; });
        };
        dataFrameClass.prototype.getPkToVectorIndex = function () {
            return this._pkToVectorIndex;
        };
        dataFrameClass.prototype.getVectorIndexByKey = function (key) {
            var index = this._pkToVectorIndex[key];
            return index;
        };
        dataFrameClass.prototype.vectorToPrimaryKeys = function (vector) {
            var keys = [];
            var pkVector = this.getVector(beachParty.primaryKeyName, false);
            if (vector) {
                for (var i = 0; i < vector.length; i++) {
                    if (vector[i]) {
                        var key = pkVector[i];
                        keys.push(key);
                    }
                }
            }
            return keys;
        };
        dataFrameClass.prototype.getValueMap = function (colName, maxRows, callback) {
            var vm = null;
            var pf = this.getFieldData(colName);
            if (pf && pf.valueMap) {
                vm = pf.valueMap;
            }
            else {
                //---- must build one from values in column ----
                var vector = this.getVector(colName, false);
                var groups = vector.groupBy();
                vm = [];
                for (var i = 0; i < groups.length; i++) {
                    var group = groups[i];
                    var vme = new beachParty.ValueMapEntry();
                    vme.originalValue = group.key;
                    vme.valueCount = group.values.length;
                    vm.push(vme);
                }
            }
            //---- valueMap: sort in descending order of value count (high counts first) ----
            vm = vm.orderByNum(function (e) { return e.valueCount; });
            vm.reverse();
            if (maxRows != undefined) {
                vm = vm.slice(0, maxRows);
            }
            if (callback) {
                callback(vm);
            }
            return vm;
        };
        dataFrameClass.prototype.isColumnName = function (colName) {
            var isCol = (this._colMap[colName] != null);
            return isCol;
        };
        dataFrameClass.prototype.append = function (df) {
            var fromCols = df._columns;
            var toCols = this._columns;
            for (var i = 0; i < fromCols.length; i++) {
                var fromCol = fromCols[i];
                var colName = fromCol.name;
                //---- append "colName" to this dataFrame ----
                var toVector = this.getVector(colName, true);
                if (!toVector) {
                    var newCol = new beachParty.DataColumn(fromCol.name, fromCol.desc, fromCol.colType, fromCol.calcFieldExp, fromCol.stats, fromCol.data.slice(0));
                    toCols.push(newCol);
                    this._colMap[colName] = newCol;
                }
                else {
                    var fromVector = df.getVector(colName, false);
                    for (var v = 0; v < fromVector.length; v++) {
                        var value = fromVector[v];
                        toVector.push(value);
                    }
                }
            }
        };
        dataFrameClass.prototype.isValidFieldName = function (str) {
            var isValid = (str.length > 0);
            for (var i = 0; i < str.length; i++) {
                var ch = str[i];
                if (ch == "_" || (ch >= "0" && ch <= "9") || (ch.toLocaleLowerCase() != ch.toLocaleUpperCase())) {
                }
                else {
                    isValid = false;
                    break;
                }
            }
            return isValid;
        };
        /** replaces column names with "record." in front of them.  Also correct the case-ing of the column names. */
        dataFrameClass.prototype.addRecordKeywordToColumnNames = function (exp) {
            var newExp = "";
            var lastToken = null;
            var TokenType = vp.utils.TokenType;
            //---- build lowerColNames ----
            var lowerColNames = [];
            var cols = this._columns;
            for (var i = 0; i < cols.length; i++) {
                var name = cols[i].name.toLowerCase();
                lowerColNames.push(name);
            }
            //---- get column names ----
            var scanner = new vp.utils.scannerClass(exp);
            scanner.scan(); // get the first token
            var tokenType = scanner.tokenType();
            var token = scanner.token();
            while (tokenType != TokenType.eof) {
                /// TODO: how can we support odd column name chars like "#"?
                if (tokenType == TokenType.id) {
                    if (lastToken != ".") {
                        var lowtok = token.toLowerCase();
                        var index = lowerColNames.indexOf(lowtok);
                        if (index > -1) {
                            //---- add column name ----
                            token = "record." + cols[index].name;
                        }
                        else {
                            if (lowtok == "math") {
                                token = "Math"; // correct case if needed
                            }
                            else if (lowtok == "_primaryKey") {
                                token = "_primaryKey";
                            }
                        }
                    }
                }
                else if (token == "=") {
                    //---- common mistake - fix for user ----
                    token = "==";
                }
                newExp += token;
                lastToken = token;
                scanner.scan();
                tokenType = scanner.tokenType();
                token = scanner.token();
            }
            return newExp;
        };
        dataFrameClass.prototype.isColLoaded = function (colName) {
            return (this._colMap[colName].data != null);
        };
        /** uses "exp" as a JavaScript expression to build a new vector of values. */
        dataFrameClass.prototype.buildCalcVector = function (exp) {
            var newVector = [];
            var recordCount = this._recordCount;
            //----  convert exp from string to func ----
            var expAdj = this.addRecordKeywordToColumnNames(exp);
            var expFunc = null;
            var strMakeFunc = "expFunc = function(record) { return " + expAdj + ";}";
            /// TOD: write a function validator that ensures only columns, standard function, and constants are
            /// used in an expression to create a safeEval().
            //eval(strMakeFunc);      // create function from user expression
            throw "calc fields not currenly supported";
            //for (var i = 0; i < recordCount; i++)
            //{
            //    var record = this.getRecordByVectorIndex(i);
            //    //var _primaryKey = i;
            //    var value = expFunc(record);
            //    newVector.push(value);
            //}
            //return newVector;
        };
        /** applies a filter and produces a new dataFrame object. */
        dataFrameClass.prototype.applyPrefilter = function (exp) {
            var recordCount = this._recordCount;
            var indexes = []; // the records to keep
            //----  convert exp from string to func ----
            var expAdj = this.addRecordKeywordToColumnNames(exp);
            var expFunc = null;
            //eval("expFunc = function(record) { return " + expAdj + ";}");   // create function from exp
            throw "preload filter not currently supported";
            //for (var i = 0; i < recordCount; i++)
            //{
            //    var record = this.getRecordByVectorIndex(i);
            //    var _primaryKey = i;
            //    var value = expFunc(record);
            //    if (value != true)
            //    {
            //        indexes.push(i);
            //    }
            //}
            //var df = this.copyData(indexes);
            //return df;
        };
        /** create a new dataFrame, using the specified fieldList. */
        dataFrameClass.prototype.makeFields = function (fieldList, mergeFields) {
            var newMap = {};
            if (mergeFields) {
                this._columns.forEach(function (col) { return newMap[col.name] = col; });
            }
            for (var i = 0; i < fieldList.length; i++) {
                var fld = fieldList[i];
                var newName = fld.name;
                var exp = fld.calcFieldExp;
                var typeName = fld.fieldType;
                if (exp) {
                    if (this.isValidFieldName(exp)) {
                        //---- just a field rename ("exp" is the name of the source field) ----
                        var fromCol = this._colMap[exp];
                        var newCol = vp.utils.copyMap(fromCol, true);
                        //var vector = <any[]> null;
                        //if (this.isColLoaded(exp))
                        //{
                        //    vector = this.getVector(exp, false);
                        //    vector = vector.slice(0);  // copy vector
                        //}
                        newMap[newName] = newCol;
                    }
                    else {
                    }
                }
                else {
                    //---- use original field name ----
                    if (!newMap[newName]) {
                        var fromCol = this._colMap[newName];
                        var newCol = vp.utils.copyMap(fromCol, true);
                        newMap[newName] = newCol;
                    }
                }
                if (newCol && newCol.data && fld.valueMap && fld.valueMap.length) {
                    this.applyValueMap(fld, newCol.data);
                }
            }
            //---- convert map to array ----
            var newColumns = [];
            for (var k in newMap) {
                var nc = newMap[k];
                newColumns.push(nc);
            }
            var df = new dataFrameClass(newColumns);
            return df;
        };
        dataFrameClass.prototype.loader = function (value) {
            if (arguments.length == 0) {
                return this._loader;
            }
            this._loader = value;
        };
        /**
         *  Make the value substitutions specified by the fld's valueMap (array of valueMapEntry objects).
         * @param fld
         * @param vector
         */
        dataFrameClass.prototype.applyValueMap = function (fld, vector) {
            var valueMap = fld.valueMap;
            for (var i = 0; i < valueMap.length; i++) {
                var entry = valueMap[i];
                if (entry.newValue) {
                    this.applyValueMapEntry(entry, vector);
                }
            }
        };
        dataFrameClass.prototype.applyValueMapEntry = function (entry, vector) {
            var origValue = entry.originalValue;
            var newValue = entry.newValue;
            for (var i = 0; i < vector.length; i++) {
                if (vector[i] == origValue) {
                    vector[i] = newValue;
                }
            }
        };
        dataFrameClass.prototype.sortVectors = function (colName, ascending, colType) {
            /// HISTORICAL NOTE: using JavaScript array sort() for STRINGS on large data tables used to take a long time, so
            /// for a while we were sorting on the server.  Turns out the problem was that we were returning "1" for equal
            /// values, which GREATLY slowed down sorting in many cases.
            //---- NOTE: we can move this onto a background worker thread if/when needed----
            var sortAsNumbers = (colType != "string");
            if (!colName) {
                colName = "_primaryKey";
                ascending = true;
                sortAsNumbers = true;
            }
            //---- extract keys to sort ----
            var keys = [];
            if (colType == "string") {
                var vector = this.getVector(colName, false);
            }
            else {
                var vector = this.getNumericVector(colName, false).values;
            }
            if (!vector) {
                throw "Internal error - sort() called on non-existent colName=" + colName;
            }
            if (sortAsNumbers) {
                for (var i = 0; i < vector.length; i++) {
                    var key = vector[i];
                    keys[i] = { key: +key, index: i };
                }
                vp.utils.debug("calling NUMERIC sort: colName=" + colName + ", ascending=" + ascending + ", length=" + keys.length);
                if (ascending) {
                    keys.sort(function (a, b) { return a.key - b.key; });
                }
                else {
                    keys.sort(function (b, a) { return a.key - b.key; });
                }
            }
            else {
                for (var i = 0; i < vector.length; i++) {
                    var key = vector[i];
                    keys[i] = { key: key + "", index: i };
                }
                vp.utils.debug("calling STRING sort: colName=" + colName + ", ascending=" + ascending + ", length=" + keys.length);
                if (ascending) {
                    keys.sort(function (a, b) { return (a.key < b.key) ? -1 : ((a.key == b.key) ? 0 : 1); });
                }
                else {
                    keys.sort(function (b, a) { return (a.key < b.key) ? -1 : ((a.key == b.key) ? 0 : 1); });
                }
            }
            //vp.utils.debug("sort returned");
            //---- recorder each named vector, in place ----
            //---- this means that all layout routines directly use the sorted data, so they don't have to worry about a "sorted index" ----
            for (var i = 0; i < this._columns.length; i++) {
                var col = this._columns[i];
                var name = col.name;
                var vector = col.data;
                if (vector) {
                    this.reorderVectorInPlace(vector, keys);
                }
            }
            //---- save sort keys for colsOnDemand ----
            this._currentSortKeys = keys;
            this.rebuildPrimaryKeyIndex();
            this._sortKey = colName + (ascending ? "-up" : "-down");
            //---- invalidate our cache of numeric vectors ----
            this._numericVectorsCache = {};
            //---- debug - show first record index of newly sorted records ----
            //var last = riVector.length - 1;
            //vp.utils.debug("after sort, first record index=" + riVector[0] + ", last record index =" + riVector[last]);
        };
        dataFrameClass.prototype.getSortKey = function () {
            return this._sortKey;
        };
        dataFrameClass.prototype.reorderVectorInPlace = function (vector, keys) {
            var prevVector = vp.utils.copyArray(vector);
            for (var i = 0; i < keys.length; i++) {
                var keyEntry = keys[i];
                var index = keyEntry.index;
                var value = prevVector[index];
                vector[i] = value;
            }
        };
        dataFrameClass.prototype.getPreloadField = function (colName) {
            var pf = null;
            var preload = this.getPreload();
            if (preload && preload.fieldList) {
                var fieldList = preload.fieldList;
                for (var i = 0; i < fieldList.length; i++) {
                    if (fieldList[i].name == colName) {
                        pf = fieldList[i];
                        break;
                    }
                }
            }
            return pf;
        };
        dataFrameClass.prototype.addColsToData = function (newInfos, newVectors, callback) {
            for (var i = 0; i < newInfos.length; i++) {
                var ci = newInfos[i];
                var vector = newVectors[i];
                this.addColumn(ci, vector, false);
            }
            this.onDataChanged("colInfos");
            if (callback) {
                var colInfos = this.getColInfos();
                callback(colInfos);
            }
        };
        dataFrameClass.prototype.addColumn = function (ci, vector, notify) {
            if (notify === void 0) { notify = true; }
            var name = ci.name;
            var col = this._colMap[name];
            if (col === undefined) {
                //---- a new column ----
                col = new beachParty.DataColumn(ci.name, ci.desc, ci.colType, ci.calcFieldExp, ci.stats, vector);
                this._columns.push(col);
                this._colMap[name] = col;
            }
            else {
                //---- update an existing column ----
                col.desc = ci.desc;
                col.colType = ci.colType;
                col.calcFieldExp = ci.calcFieldExp;
                col.stats = ci.stats;
                //---- invalidate cache for this column, since we are adding new data ----
                this._numericVectorsCache[name] = null;
            }
            if (!vector) {
                //---- supply default vector of all zeros ----
                var count = this._recordCount;
                vector = [];
                for (var i = 0; i < count; i++) {
                    vector[i] = 0;
                }
            }
            //---- add the data to the newly created column ----
            col.data = vector;
            if (notify) {
                this.onDataChanged("colInfos");
            }
        };
        /* return an object serialized to JSON string */
        dataFrameClass.prototype.toJsonString = function () {
            var str = JSON.stringify(this);
            return str;
        };
        dataFrameClass.jsonToDataFrame = function (jsonData) {
            var newCols = [];
            if (jsonData.length > 0) {
                var record0 = jsonData[0];
                var names = vp.utils.keys(record0);
                for (var c = 0; c < names.length; c++) {
                    var colName = names[c];
                    var newCol = new beachParty.DataColumn(colName);
                    newCol.data = [];
                    newCols.push(newCol);
                }
                for (var r = 0; r < jsonData.length; r++) {
                    var record = jsonData[r];
                    for (var c = 0; c < names.length; c++) {
                        colName = names[c];
                        var col = newCols[c];
                        var value = record[colName];
                        col.data.push(value);
                    }
                }
                //---- postprocessing on each col ----
                for (var c = 0; c < names.length; c++) {
                    var col = newCols[c];
                    //---- compute colType, now that we have all our data ----
                    col.colType = vp.data.getDataType(col.data);
                }
            }
            var df = new dataFrameClass(newCols);
            return df;
        };
        dataFrameClass.prototype.getRecordCount = function () {
            return this._recordCount;
        };
        dataFrameClass.prototype.getPreload = function () {
            return this._wdParams;
        };
        dataFrameClass.prototype.getRecordByPrimaryKey = function (primaryKey, colNames) {
            var vi = this._pkToVectorIndex[primaryKey];
            return this.getRecordByVectorIndex(vi, colNames);
        };
        dataFrameClass.prototype.getRecordByVectorIndex = function (recordIndex, colNames) {
            var record = null;
            if (this._loader) {
                record = this._loader.getRecord(recordIndex, colNames);
            }
            else {
                if (recordIndex >= 0 && recordIndex <= this._recordCount) {
                    record = {};
                    if (!colNames) {
                        colNames = this.getColumnNames();
                    }
                    for (var c = 0; c < colNames.length; c++) {
                        var colName = colNames[c];
                        var vector = this._colMap[colName].data;
                        var value = vector[recordIndex];
                        record[colName] = value;
                    }
                }
            }
            return record;
        };
        dataFrameClass.prototype.toJson = function (maxRecords, indexes) {
            var newData = [];
            if (this._columns && this._columns.length) {
                var names = this.getColumnNames();
                var count = this._recordCount;
                if (maxRecords) {
                    count = Math.min(maxRecords, count);
                }
                if (indexes) {
                    count = Math.min(indexes.length, count);
                }
                for (var r = 0; r < count; r++) {
                    var record = {};
                    var index = (indexes) ? indexes[r] : r;
                    for (var c = 0; c < names.length; c++) {
                        var colName = names[c];
                        var vector = this._colMap[colName].data;
                        record[colName] = vector[index];
                    }
                    newData.push(record);
                }
            }
            return newData;
        };
        /** gets the named vector in its ORIGINAL form (string, date, number). */
        dataFrameClass.prototype.getVector = function (name, invalidateNumericCache) {
            //---- if we are changing the original vector, we need to invalidate the cached version of the numeric vector ----
            if (invalidateNumericCache) {
                this._numericVectorsCache[name] = null;
            }
            var colEntry = this._colMap[name];
            var vector = (colEntry) ? colEntry.data : null;
            if (!vector && this._loader) {
                //---- get column on demand ----
                var myMap = {};
                this._loader.loadColumns(myMap, [name]);
                vector = myMap[name];
                this._colMap[name].data = vector;
                //---- apply value map if present ----
                var fld = this.getFieldData(name);
                if (fld && fld.valueMap && fld.valueMap.length) {
                    this.applyValueMap(fld, vector);
                }
                //---- sort if sortKeys active ----
                if (this._currentSortKeys) {
                    this.reorderVectorInPlace(vector, this._currentSortKeys);
                }
            }
            return vector;
        };
        dataFrameClass.prototype.getFieldData = function (colName) {
            var pf = null;
            if (this._wdParams) {
                var fields = this._wdParams.fieldList;
                if (fields) {
                    for (var i = 0; i < fields.length; i++) {
                        var field = fields[i];
                        if (field.name == colName) {
                            pf = field;
                            break;
                        }
                    }
                }
            }
            return pf;
        };
        dataFrameClass.prototype.invalidateCache = function (colName) {
            this._numericVectorsCache[colName] = null;
        };
        /** gets the named vector in its NUMERIC form. */
        dataFrameClass.prototype.getNumericVector = function (name, forceCategory, allKeys, useCache) {
            if (useCache === void 0) { useCache = true; }
            var numVector = null;
            if (forceCategory) {
                numVector = this.buildNumericCol(name, true, true, allKeys);
            }
            else {
                if (useCache) {
                    //---- use cache for normal requests ----
                    numVector = this._numericVectorsCache[name];
                }
                if (!numVector) {
                    numVector = this.buildNumericCol(name, true, false, allKeys);
                    if (useCache) {
                        this._numericVectorsCache[name] = numVector;
                    }
                }
            }
            //---- now, build and set colInfo ----
            var colInfo = this.buildColumnInfo(name, numVector);
            numVector.colInfo = colInfo;
            return numVector;
        };
        dataFrameClass.prototype.copyData = function (recordIndexes) {
            //---- make a cop of all columns but without data ----
            var newCols = vp.utils.copyArray(this._columns);
            //---- go thru each colum and copy specified rows ----
            for (var i = 0; i < newCols.length; i++) {
                var newCol = newCols[i];
                var name = newCol.name;
                var vector = newCol.data;
                if (recordIndexes) {
                    var newVector = recordIndexes.map(function (recordIndex) {
                        return vector[recordIndex];
                    });
                }
                else {
                    var newVector = vp.utils.copyArray(vector);
                }
                newCol.data = newVector;
            }
            var df = new dataFrameClass(newCols);
            return df;
        };
        dataFrameClass.getSortedKeys = function (name, wdParams) {
            var sortedKeys = null;
            if (wdParams) {
                var colInfo = wdParams.getField(name);
                if (colInfo) {
                    sortedKeys = colInfo.sortedValues;
                }
            }
            return sortedKeys;
        };
        dataFrameClass.prototype.getPrimaryKeys = function (vector, vectorType) {
            var keys = [];
            var pkVector = this.getVector(beachParty.primaryKeyName, false);
            if (vectorType == beachParty.VectorType.sortOrder) {
                for (var ri = 0; ri < vector.length; ri++) {
                    var value = vector[ri];
                    if (value) {
                        var key = pkVector[ri];
                        keys.push(value);
                    }
                }
            }
            else if (vectorType == beachParty.VectorType.primaryKeyList) {
                keys = vector;
            }
            else {
                beachParty.cbUtils.error("getSortOrderKeys: unknown vectorType=" + vectorType);
            }
            return keys;
        };
        dataFrameClass.prototype.buildNumericCol = function (name, forceNumeric, forceCategory, allKeys) {
            //---- first, try dataFrame (map of data vectors) ----
            var colData = this.getVector(name, false);
            var colType = this.getColType(name);
            if (forceCategory) {
                colType = "string";
            }
            var fieldInfo = (this._wdParams) ? this._wdParams.getField(name) : null;
            var desc = (fieldInfo) ? fieldInfo.description : "";
            //---- buildColInfo relies on numericVector, so build it first ----
            var numericVector = dataFrameClass.buildNumericColFromVector(name, colData, colType, forceNumeric, forceCategory, allKeys, this._wdParams);
            //---- now, build and set colInfo ----
            //var colInfo = this.buildColInfo(name, numericVector);
            //numericVector.colInfo = colInfo;
            return numericVector;
        };
        /**
         * Fill in missing information in col, using wdParams and numeric vector.
         * @param col
         * @param numericVector
         */
        dataFrameClass.prototype.completeColInfo = function (col, numericVector) {
            //---- numericVector has already calculated the underlying colType for us ----
            col.colType = numericVector.colType;
            var fieldInfo = (this._wdParams) ? this._wdParams.getField(col.name) : null;
            if (fieldInfo) {
                if (!col.desc) {
                    col.desc = fieldInfo.description;
                }
                if (!col.calcFieldExp) {
                    col.calcFieldExp = fieldInfo.calcFieldExp;
                }
            }
            var mm = this.getFilteredKeysMinMax(numericVector, col.name, col.colType);
            var stats = col.stats;
            if (!stats) {
                var keyLength = (mm.keys) ? mm.keys.length : 0;
                col.stats = new beachParty.ColStats(mm.min, mm.max, mm.nanCount, keyLength, mm.keys);
            }
            else {
                //if (stats.min === undefined)
                //{
                //    stats.min = mm.min;
                //}
                //if (stats.max === undefined)
                //{
                //    stats.max = mm.max;
                //}
                //if (stats.nanCount === undefined)
                //{
                //    stats.nanCount = mm.nanCount;
                //}
                //if (stats.sortedKeys === undefined)
                //{
                //    stats.sortedKeys = mm.keys;
                //}
                //if (stats.keyCount === undefined)
                //{
                //    stats.keyCount = stats.sortedKeys.length;
                //}
                //---- always update stats so they reflect the current filter setting ----
                stats.min = mm.min;
                stats.max = mm.max;
                stats.nanCount = mm.nanCount;
                stats.sortedKeys = mm.keys;
                stats.keyCount = (stats.sortedKeys) ? stats.sortedKeys.length : 0;
            }
            col.infoIsComplete = true;
        };
        dataFrameClass.prototype.getFileName = function () {
            return this._wdParams.dataName;
        };
        dataFrameClass.prototype.clearFilteredColInfosCache = function () {
            //---- cache for filtered colInfos not currently implemented ----
        };
        dataFrameClass.prototype.getIndexOfCol = function (name) {
            var index = -1;
            for (var i = 0; i < this._columns.length; i++) {
                var col = this._columns[i];
                if (col.name == name) {
                    index = i;
                    break;
                }
            }
            return index;
        };
        /**
         * Get a copy of the colInfo for the specified column name.
         * @param colName
         */
        dataFrameClass.prototype.buildColumnInfo = function (colName, numVector) {
            var value = null;
            var col = this._colMap[colName];
            if (numVector && col) {
                var useFilter = this._isFilterActive;
                if (!col.infoIsComplete || useFilter) {
                    this._getColInfoWorkCount++;
                    this.completeColInfo(col, numVector);
                }
            }
            if (col) {
                //---- make a copy of DataColumn and return it as ColInfo ----
                var value = vp.utils.copyMap(col, false);
                value.data = null;
            }
            return value;
        };
        dataFrameClass.prototype.getFilteredKeysMinMax = function (numericVector, colName, colType) {
            var keys = null;
            var min = null;
            var max = null;
            var nanCount = 0;
            //---- must specify TRUE here to get numeric/date values in their correct form ----
            var getNumeric = (colType != "string");
            var vector = this.getFilteredInVector(colName, getNumeric, numericVector);
            if (colType == "string") {
                keys = vector.distinct(); // honor current filter
                min = 0;
                max = keys.length - 1;
                nanCount = 0; // in the future, we might want to count empty strings as NAN's
            }
            else {
                keys = null;
                min = vector.min();
                max = vector.max();
                nanCount = vector.count(isNaN);
                vp.utils.debug("colName=" + colName + ", vector.length=" + vector.length + ", nanCount=" + nanCount);
            }
            return { keys: keys, min: min, max: max, nanCount: nanCount };
        };
        /**
         * Caution - this returns a vector of column values where the FILTERED OUT values have been removed.  This will break code that is expecting
         * a FULL vector (indexes will be wrong).
         * @param colName
         * @param asNumeric
         * @param numericVector
         */
        dataFrameClass.prototype.getFilteredInVector = function (colName, asNumeric, numericVector) {
            if (asNumeric) {
                if (!numericVector) {
                    numericVector = this.getNumericVector(colName);
                }
                var rawVector = numericVector.values;
            }
            else {
                var rawVector = this.getVector(colName, false);
            }
            var filter = this.getFilteredVector(false);
            var newVector = [];
            for (var i = 0; i < rawVector.length; i++) {
                if (!filter || !filter[i]) {
                    newVector.push(rawVector[i]);
                }
            }
            return newVector;
        };
        dataFrameClass.prototype.getFilteredVector = function (invalidateNumericCache) {
            var vector = this.getVector(beachParty.filteredName, invalidateNumericCache);
            return vector;
        };
        dataFrameClass.buildNumericColFromVector = function (name, colData, colType, forceNumeric, forceCategory, allKeys, wdParams) {
            var count = (colData) ? colData.length : 0;
            var newData = new Float32Array(count);
            var numericVector = new beachParty.NumericVector(newData, name, colType);
            if (colData && colData.length) {
                if (colType == "number") {
                    //---- transfer NUMBER values, converting strings to parsed numbers ----
                    for (var i = 0; i < colData.length; i++) {
                        /// number represenations:
                        ///     valid number string --> normal numbers
                        ///     blanks  --> NaN 
                        ///     invalid number string --> NaN
                        //var value: any = +colData[i];
                        var strValue = colData[i];
                        if (strValue === "") {
                            //---- NA (missing) value ----
                            var numValue = NaN;
                        }
                        else {
                            //---- NUMBER or STRING value ----
                            var numValue = +strValue;
                        }
                        newData[i] = numValue;
                    }
                }
                else if (colType == "date") {
                    //---- transfer DATE values, converting strings to parsed date numbers and date objects to date numbers ----
                    for (var i = 0; i < colData.length; i++) {
                        var value = colData[i];
                        //---- BLANK and NON-DATE strings are converted here to NaN's ----
                        if (typeof value == "string") {
                            value = Date.parse(value);
                        }
                        else {
                            value = +value;
                        }
                        newData[i] = value;
                    }
                }
                else {
                    //---- string values ----
                    if (forceNumeric) {
                        var sortedKeys = dataFrameClass.getSortedKeys(name, wdParams);
                        if (sortedKeys) {
                            //---- overrides allKeys ----
                            allKeys = sortedKeys;
                        }
                        //---- convert string to numeric, using dictionary keys & their indexes ----
                        var keyIndexs = dataFrameClass.getStringKeyIndexes(colData, numericVector, allKeys);
                        if (keyIndexs && keyIndexs.length) {
                            newData = keyIndexs;
                        }
                    }
                    else {
                        throw "Error: cannot put string values into a NumericVector";
                    }
                }
            }
            return numericVector;
        };
        dataFrameClass.getStringKeyIndexes = function (data, numericVector, allKeys) {
            var indexesByKey = {};
            var keysByIndex = {};
            var keyIndexes = [];
            var rowsByKey = {};
            var keysByRow = [];
            var sortedKeys = []; // a list of keys in their desired sort order
            var nextKeyId = 0;
            if (data && data.length) {
                if (!allKeys) {
                    //---- pull and sort keys up front to ensure sorted key indexes match indexes used in data ----
                    allKeys = data.groupBy().map(function (g) { return g.key; });
                    sortedKeys = allKeys.sort();
                }
                else {
                    sortedKeys = allKeys.slice(0); // make copy of allKeys
                }
                //---- pre-assign a full set of keys ----
                for (var i = 0; i < sortedKeys.length; i++) {
                    var ak = sortedKeys[i];
                    indexesByKey[ak] = nextKeyId;
                    keysByIndex[nextKeyId] = ak;
                    nextKeyId++;
                }
                //---- convert values from string to number (key index) ----
                for (var i = 0; i < data.length; i++) {
                    var key = data[i] + "";
                    var keyValue = indexesByKey[key];
                    if (keyValue === undefined) {
                        keyValue = nextKeyId++;
                        indexesByKey[key] = keyValue;
                        keysByIndex[keyValue] = key;
                        sortedKeys.push(key);
                    }
                    var rows = rowsByKey[key];
                    if (rows === undefined || !vp.utils.isArray(rows)) {
                        rows = [];
                        rowsByKey[key] = rows;
                    }
                    rows.push(i);
                    keysByRow[i] = key;
                    keyIndexes.push(keyValue);
                }
            }
            numericVector.values = keyIndexes;
            numericVector.keyInfo = new beachParty.KeyInfo(sortedKeys.length, indexesByKey, keysByIndex, rowsByKey, keysByRow, sortedKeys);
            return keyIndexes;
        };
        dataFrameClass.prototype.aggData = function (statInfo) {
            var result = null;
            var statType = statInfo.statType;
            if (statType == beachParty.StatType.count) {
                result = this._recordCount;
            }
            else {
                var colName = statInfo.colName;
                var statTransform = statInfo.colValueTransform;
                var statName = (statType != beachParty.StatType.none) ? beachParty.StatType[statType] : "sum";
                var aggregator = vp.data.createAggregator(statName);
                aggregator.init();
                var vector = this.getVector(colName, false);
                for (var i = 0; i < vector.length; i++) {
                    var value = vector[i];
                    if (statTransform) {
                        value = statTransform(value);
                    }
                    aggregator.process(value);
                }
                result = aggregator.getResult();
            }
            return result;
        };
        dataFrameClass.prototype.getDataColumns = function () {
            return this._columns;
        };
        return dataFrameClass;
    }(beachParty.dataChangerClass));
    beachParty.dataFrameClass = dataFrameClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    dataLoader.ts - loads data (from server if needed) and return a dataFrame.  Applies wdParams as specified.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var dataLoaderClass = (function () {
        function dataLoaderClass(preloadMgr, colsOnDemand, isCachingWebFiles) {
            this._preloadMgr = preloadMgr;
            this._colsOnDemand = colsOnDemand;
            this._isCachingWebFiles = isCachingWebFiles;
        }
        dataLoaderClass.prototype.expandRecordsByKeywordColumn = function (data, colName) {
            if (!vp.utils.isArray(data)) {
                //---- convert DataFrame to JSON, for easier expansion ----
                var df = new beachParty.dataFrameClass(data);
                data = df.toJson();
            }
            var newData = [];
            var colNames = null;
            for (var i = 0; i < data.length; i++) {
                var record = data[i];
                if (colNames == null) {
                    colNames = vp.utils.keys(record);
                }
                var kwValue = record[colName];
                var keyWords = this.getKeywordsFromCommaString(kwValue);
                //---- generate a record for each keyword ----
                for (var k = 0; k < keyWords.length; k++) {
                    var kw = keyWords[k];
                    if (!isNaN(+kw)) {
                        //---- special treatment for keywords that are numbers so that JavaScript doesn't mess things up ----
                        kw += " "; //= "__" + kw;
                    }
                    var newRecord = {};
                    newRecord._origRecordIndex = i;
                    newRecord._copyIndex = k;
                    newRecord.origKeywordValues = kwValue;
                    //---- transfer all fields from record ----
                    for (var c = 0; c < colNames.length; c++) {
                        var cn = colNames[c];
                        if (cn != "") {
                            newRecord[cn] = record[cn];
                        }
                    }
                    //---- update the keyword column ----
                    newRecord[colName] = kw;
                    newData.push(newRecord);
                }
            }
            return newData;
        };
        dataLoaderClass.prototype.loadColumns = function (colMap, loadList) {
            this._csvColLoader.loadColumns(colMap, loadList);
        };
        dataLoaderClass.prototype.getRecord = function (recordIndex, colNames) {
            return this._csvColLoader.getRecord(recordIndex, colNames);
        };
        dataLoaderClass.prototype.getKeywordsFromCommaString = function (str) {
            var parts = str.split(',');
            var keyWords = [];
            for (var p = 0; p < parts.length; p++) {
                var part = parts[p].trim(); //.toLowerCase();
                if (part != "") {
                    keyWords.push(part);
                }
            }
            return keyWords;
        };
        dataLoaderClass.prototype.loadDataFrameFromText = function (text, wdParams) {
            var anyData = null;
            if (text.startsWith("[") || text.startsWith("}")) {
                anyData = JSON.parse(text);
            }
            else {
                var separator = wdParams.separator;
                var hasHeader = wdParams.hasHeader;
                if (this._colsOnDemand) {
                    var csvColLoader = new beachParty.csvColLoaderClass(text, hasHeader, separator, true, true);
                    this._csvColLoader = csvColLoader;
                    anyData = csvColLoader.buildDataFrameWithEmptyVectors();
                }
                else {
                    anyData = beachParty.csvToJson(text, hasHeader, separator, true);
                }
            }
            return anyData;
        };
        dataLoaderClass.prototype.addSysCol = function (dataFrame, name, colType, desc, vector) {
            var colInfo = new beachParty.ColInfo(name, desc, colType, null);
            dataFrame.addColumn(colInfo, vector);
        };
        dataLoaderClass.prototype.addSystemColumns = function (dataFrame, wdParams) {
            this.addSysCol(dataFrame, beachParty.selectedName, "number", "System column where value=1 means the record is selected");
            this.addSysCol(dataFrame, beachParty.filteredName, "number", "System column where value=1 means the record is filtered OUT");
            this.addSysCol(dataFrame, beachParty.randomXName, "number", "System column to provide a random X value for layout");
            this.addSysCol(dataFrame, beachParty.randomYName, "number", "System column to provide a random Y value for layout");
            //---- does table have a pre-defined primary key? ----
            if (wdParams.primaryKeyCol) {
                var pkName = wdParams.primaryKeyCol;
                var pkVector = dataFrame.getVector(pkName, false);
                //---- create an alias column named "primaryKeyName" that points to the same vector as pkName ----
                this.addSysCol(dataFrame, beachParty.primaryKeyName, "number", "System column that uniquely defines each record", pkVector);
            }
            else {
                //---- if no primary key specified, use record index ----
                this.addSysCol(dataFrame, beachParty.primaryKeyName, "number");
                var primaryKeys = dataFrame.getVector(beachParty.primaryKeyName, false);
                for (var i = 0; i < primaryKeys.length; i++) {
                    primaryKeys[i] = i;
                }
            }
            //---- build randomX, randomY ----
            var randomX = dataFrame.getVector(beachParty.randomXName, false);
            var randomY = dataFrame.getVector(beachParty.randomYName, false);
            for (var i = 0; i < primaryKeys.length; i++) {
                randomX[i] = Math.random();
                randomY[i] = Math.random();
            }
            dataFrame.rebuildPrimaryKeyIndex();
        };
        /** open the specified known data file, async.  if "multiValueCol" is true, replicate records
            so that we have 1 record for each value in the specified column of each original record. */
        dataLoaderClass.prototype.loadKnownAsyncCore = function (name, multiValueCol, callback) {
            //vp.utils.debug("loadKnownAsync: name=" + name);
            var lowName = name.toLowerCase(); // support user typing of name with wrong case
            var preload = this._preloadMgr.getFilePreload(lowName);
            if (!preload) {
                throw "Error: unknown known file: " + lowName;
            }
            //---- ensure this has a dataName set ----
            //if (!preload.dataName)
            //{
            //    preload.dataName = preload.name;
            //}
            var anyWindow = window;
            if (lowName == "knowndata") {
                var jsonData = this._preloadMgr.getPreloads();
                var df = beachParty.dataFrameClass.jsonToDataFrame(jsonData);
                var pdResult = this.processData(df.getDataColumns(), preload, multiValueCol);
                if (callback) {
                    callback(pdResult.origDf, pdResult.postDf, pdResult.wdParams);
                }
            }
            else {
                this.openPreloadAsyncCore(preload, multiValueCol, callback);
            }
        };
        /** convert "anyData" into a dataFrame, and then apply wdParams. */
        dataLoaderClass.prototype.processData = function (anyData, wdParams, multiValueCol) {
            ////---- did caller request record duplication to expand each keyword to its own record? ----
            //if (multiValueCol || wdParams.multiValueCol)
            //{
            //    anyData = this.expandRecordsByKeywordColumn(anyData, multiValueCol);
            //}
            //---- convert data (in 1 of N formats) to a dataFrame object ----
            if (vp.utils.isString(anyData)) {
                //---- STRING ----
                anyData = this.loadDataFrameFromText(anyData, wdParams);
            }
            if (vp.utils.isArray(anyData)) {
                var firstItem = (anyData.length > 0) ? anyData[0] : null;
                if (firstItem && firstItem.ctr == "DataColumn") {
                    //---- DATA COLUMN [] ----
                    var df = new beachParty.dataFrameClass(anyData);
                }
                else {
                    //---- JSON [] ----
                    df = beachParty.dataFrameClass.jsonToDataFrame(anyData);
                }
            }
            else if (anyData instanceof beachParty.dataFrameClass) {
                df = anyData;
            }
            else if (anyData.ctr == "dataFrameClass") {
                df = anyData;
            }
            else {
                //---- VECTOR MAP ----
                var keys = vp.utils.keys(anyData);
                var columns = [];
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var data = anyData[key];
                    var colType = vp.data.getDataType(data);
                    var sortedKeys = null;
                    if (colType == "string") {
                        sortedKeys = data.distinct();
                    }
                    var col = new beachParty.DataColumn(key, null, colType, sortedKeys);
                    col.data = anyData[key];
                    columns.push(col);
                }
                var df = new beachParty.dataFrameClass(columns);
            }
            //---- apply WORKING DATA PARAMS ----
            var origDf = df;
            if (wdParams.fieldList && wdParams.fieldList.length) {
                df = df.makeFields(wdParams.fieldList, wdParams.mergeFieldList);
            }
            if (wdParams.prefilter) {
                df = null; //  df.applyPrefilter(wdParams.prefilter);
            }
            if (wdParams.dataAggregation) {
                var jsonRecords = this.runLocalAgg(wdParams);
            }
            df.setWdParams(wdParams);
            this.addSystemColumns(df, wdParams);
            return { origDf: origDf, postDf: df, wdParams: wdParams };
        };
        dataLoaderClass.prototype.runLocalAgg = function (wdParams) {
            var jsonRecords = null;
            //if (this._appMgr)
            //{
            //    var localAgg = this._appMgr._localAgg;
            //    var aggResult = localAgg.runQuery(wdParams.dataAggregation);
            //    var jsonRecords = aggResult.data;
            //}
            return jsonRecords;
        };
        dataLoaderClass.prototype.setWdpResult = function (wdp, aggResult) {
            var aggResult = new beachParty.AggResult();
            //---- transfer all properties but the data ----
            aggResult.wasSampled = aggResult.wasSampled;
            aggResult.wasAggregated = aggResult.wasAggregated;
            aggResult.trueRecordCount = aggResult.trueRecordCount;
            aggResult.aggFilteredRecordCount = aggResult.aggFilteredRecordCount;
            aggResult.data = null;
            wdp.aggResult = aggResult;
        };
        dataLoaderClass.prototype.openPreloadAsyncCore = function (wdParams, multiValueCol, callback) {
            var _this = this;
            var path = wdParams.filePath;
            var fileName = (wdParams.dataName) ? wdParams.dataName : path;
            if (wdParams.fileType == beachParty.FileType.sql) {
                if (wdParams.dataAggregation) {
                    beachParty.fileAccess.readSqlTableAgg(path, wdParams.tableName, wdParams.queryString, wdParams.dataAggregation, function (sqlResult) {
                        var dataFrame = sqlResult.data;
                        var keys = vp.utils.keys(dataFrame);
                        var firstKey = keys[0];
                        var recordCount = dataFrame[firstKey].length;
                        vp.utils.debug("openKnownAsync SUCCEEDED: columns=" + keys.length + ", records=" + recordCount);
                        var pdResult = _this.processData(dataFrame, wdParams, multiValueCol);
                        var wdp = pdResult.wdParams;
                        _this.setWdpResult(wdp, sqlResult);
                        if (callback) {
                            callback(pdResult.origDf, pdResult.postDf, pdResult.wdParams);
                        }
                    }, function (e) {
                        beachParty.cbUtils.onFileOpenError(fileName, e.response);
                    });
                }
                else {
                    beachParty.fileAccess.readSqlTable(path, wdParams.tableName, wdParams.queryString, wdParams.dataSampling, function (sqlResult) {
                        var dataFrame = sqlResult.data;
                        var keys = vp.utils.keys(dataFrame);
                        var firstKey = keys[0];
                        var recordCount = dataFrame[firstKey].length;
                        vp.utils.debug("openKnownAsync SUCCEEDED: columns=" + keys.length + ", records=" + recordCount);
                        var pdResult = _this.processData(dataFrame, wdParams, multiValueCol);
                        var wdp = pdResult.wdParams;
                        _this.setWdpResult(wdp, sqlResult);
                        if (callback) {
                            callback(pdResult.origDf, pdResult.postDf, pdResult.wdParams);
                        }
                    }, function (e) {
                        beachParty.cbUtils.onFileOpenError(fileName, e.response);
                    });
                }
            }
            else {
                this.loadDataFromService(path, fileName, wdParams, multiValueCol, callback);
            }
        };
        dataLoaderClass.prototype.loadDataFromService = function (path, fileName, wdParams, multiValueCol, callback) {
            var _this = this;
            var separator = wdParams.separator;
            if (!separator) {
                separator = (path.endsWith(".csv")) ? "," : "\t";
                wdParams.separator = separator;
            }
            if (this._colsOnDemand) {
                //---- for consistency (and colsOnDemand feature), just read the plain text and parse the text on the client ----
                var format = null;
                separator = null;
            }
            else {
                var format = (wdParams && wdParams.fileType == beachParty.FileType.json) ? beachParty.fileFormat.json : beachParty.fileFormat.csv;
            }
            var csvOptions = { hasHeader: wdParams.hasHeader, sepChar: separator, findTypes: true };
            var convertToDataFrameClass = false; // just return as map of named vectors 
            if (path.startsWith("http://") || path.startsWith("https://")) {
                fn = path;
            }
            else {
                var fn = beachParty.bpDataPath() + "/DataFiles/" + path;
            }
            //---- prevent caching on server ----
            //fn += "?" + Date.now();       
            var localAgg = false; // (this._appMgr) ? this._appMgr._localAgg : null;
            var tryCache = (!wdParams || wdParams.canLoadFromCache);
            if (tryCache) {
                var strCacheEntry = beachParty.localStorageMgr.get(beachParty.StorageType.dataFile, beachParty.StorageSubType.web, path);
                if (strCacheEntry) {
                    var cacheEntry = JSON.parse(strCacheEntry);
                    var dataFrameOrText = cacheEntry.data;
                    //---- always give full data to localAgg ----
                    //if (this._appMgr)
                    //{
                    //    this._appMgr._localAgg.onLocalDataLoaded(dataFrameOrText);
                    //}
                    var pdResult = this.processData(dataFrameOrText, wdParams, multiValueCol);
                    if (callback) {
                        callback(pdResult.origDf, pdResult.postDf, pdResult.wdParams);
                    }
                }
            }
            if (!dataFrameOrText) {
                //---- not found in cache ----
                beachParty.addTrace("serverRequest", path, beachParty.TraceEventType.start);
                beachParty.fileAccess.readFile(fn, format, csvOptions, function (dataFrameOrText) {
                    beachParty.addTrace("serverResponse", path, beachParty.TraceEventType.end);
                    //---- STORE new data in LS CACHE ----
                    if (wdParams.canLoadFromCache && wdParams.fileSource == "url" && _this._isCachingWebFiles) {
                        var obj = { data: dataFrameOrText, wdParams: wdParams };
                        var value = JSON.stringify(obj);
                        beachParty.localStorageMgr.save(beachParty.StorageType.dataFile, beachParty.StorageSubType.web, path, value);
                    }
                    var pdResult = _this.processData(dataFrameOrText, wdParams, multiValueCol);
                    if (callback) {
                        callback(pdResult.origDf, pdResult.postDf, pdResult.wdParams);
                    }
                }, function (e) {
                    beachParty.cbUtils.onFileOpenError(fileName, e.response);
                }, false, convertToDataFrameClass);
            }
        };
        return dataLoaderClass;
    }());
    beachParty.dataLoaderClass = dataLoaderClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    dataMgr.ts - loads and manages data streams used by BeachParty.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    //---- keep in sync with same names in dataServerApp/DataTransformer.cs ----
    beachParty.selectedName = "_selected";
    beachParty.filteredName = "_filtered";
    beachParty.primaryKeyName = "_primaryKey";
    beachParty.randomXName = "_randomX";
    beachParty.randomYName = "_randomY";
    beachParty.systemColNames = [beachParty.selectedName, beachParty.filteredName, beachParty.primaryKeyName, beachParty.randomXName, beachParty.randomYName];
    /** manages:
        - server data requests
        - client-side data requests
        - selection
        - filtering
    */
    var dataMgrClass = (function (_super) {
        __extends(dataMgrClass, _super);
        function dataMgrClass(preloadMgr, isClientEdition, isCachingWebFiles) {
            var _this = this;
            _super.call(this);
            this._fn = null;
            //private _colMappings: any = {};
            this._recordCount = 0;
            this._selectedCount = 0;
            this._filteredInCount = 0;
            this._wdParams = null;
            this._colsOnDemand = false;
            /// selectMode logically belongs on the client, but since the engine processes events from the chart exes, 
            /// we keep it here.  this may change in the future.
            //private _selectMode = SelectMode.toggle;
            //---- events ----
            this.onDataLoadStart = new beachParty.bpEvent();
            this.onDataLoadComplete = new beachParty.bpEvent();
            this.onDataChange = new beachParty.bpEvent();
            this._preloadMgr = preloadMgr;
            this._isClientEdition = isClientEdition;
            this._isCachingWebFiles = isCachingWebFiles;
            //---- don't trip over NULL dataFrame ----
            this._dataFrame = new beachParty.dataFrameClass([]);
            this._shareMgr = new beachParty.shareMgrClass(function (sd) {
                if (_this.hasSelectionChanged(sd.selectedPrimaryKeys)) {
                    _this.setSelectionDirect(sd.selectedPrimaryKeys, "localstorage");
                }
            });
        }
        dataMgrClass.prototype.colsOnDemand = function () {
            return this._colsOnDemand;
        };
        dataMgrClass.prototype.getPrimaryKeys = function (applySelection, applyFilter) {
            var rawVector = this._dataFrame.getVector(beachParty.primaryKeyName, false);
            var selected = (applySelection) ? this.getSelectedVector(false) : null;
            var filter = (applyFilter) ? this.getFilteredVector(false) : null;
            var newVector = [];
            if (rawVector) {
                for (var i = 0; i < rawVector.length; i++) {
                    if ((!selected || selected[i]) && (!filter || !filter[i])) {
                        newVector.push(rawVector[i]);
                    }
                }
            }
            return newVector;
        };
        dataMgrClass.prototype.hasSelectionChanged = function (keyList) {
            var hasChanged = true;
            var selVector = this.getSelectedVector(false);
            var vCount = vector.countOn(selVector);
            //---- quickest check - make sure # of 1's in vector matches length of keyList ----
            if (vCount == keyList.length) {
                var pktoIndex = this._dataFrame.getPkToVectorIndex();
                var hasChanged = false;
                for (var i = 0; i < keyList.length; i++) {
                    var key = keyList[i];
                    var index = pktoIndex[key];
                    if (!selVector[index]) {
                        hasChanged = true;
                        break;
                    }
                }
            }
            return hasChanged;
        };
        dataMgrClass.prototype.setDataDirect = function (dataColumns, wdParams) {
            vp.utils.debug("setDataDirect: calling loader");
            var loader = new beachParty.dataLoaderClass(this._preloadMgr, this._colsOnDemand, this._isCachingWebFiles);
            var result = loader.processData(dataColumns, wdParams);
            vp.utils.debug("setDataDirect: calling setDataAndInfo");
            this.setDataAndInfo(result.origDf, result.postDf, result.wdParams, loader);
            vp.utils.debug("setDataDirect ending");
        };
        dataMgrClass.prototype.loadKnownAsync = function (name, wdParams, callback) {
            var _this = this;
            var loader = new beachParty.dataLoaderClass(this._preloadMgr, this._colsOnDemand, this._isCachingWebFiles);
            loader.loadKnownAsyncCore(name, null, function (origDf, postDf, wdParams) {
                _this.setDataAndInfo(origDf, postDf, wdParams, loader);
                if (callback) {
                    callback(postDf, wdParams);
                }
            });
        };
        //---- subclass should supply this ----
        dataMgrClass.prototype.openKnownFile = function (name, fromUI, callback) {
        };
        //---- subclass should supply this ----
        dataMgrClass.prototype.autoloadFile = function (wdParams, callback) {
        };
        dataMgrClass.prototype.openPreloadAsync = function (wdParams, callback) {
            var _this = this;
            var loader = new beachParty.dataLoaderClass(this._preloadMgr, this._colsOnDemand, this._isCachingWebFiles);
            loader.openPreloadAsyncCore(wdParams, null, function (origDf, postDf, wdParams) {
                _this.setDataAndInfo(origDf, postDf, wdParams, loader);
                if (callback) {
                    callback(postDf);
                }
            });
        };
        /**
         *  returns column values for all selected rows, ignoring the filter.
         * @param names
         * @param asNumeric
         * @param callback
         */
        dataMgrClass.prototype.getSelectedRowsMultiCol = function (names, asNumeric, callback) {
            var nv = {};
            for (var i = 0; i < names.length; i++) {
                var name = names[i];
                nv[name] = this.getSelectedRowsSingleCol(name, asNumeric);
            }
            callback(nv);
        };
        /**
         * returns values of a single column for all selected rows, optionally applying a filter.

         * @param colName
         * @param asNumeric
         */
        dataMgrClass.prototype.getSelectedRowsSingleCol = function (colName, asNumeric, applyFilter) {
            if (asNumeric) {
                var rawVector = this._dataFrame.getNumericVector(colName).values;
            }
            else {
                var rawVector = this._dataFrame.getVector(colName, false);
            }
            var selected = this.getSelectedVector(false);
            var newVector = [];
            var filter = (applyFilter) ? this.getFilteredVector(false) : null;
            for (var i = 0; i < rawVector.length; i++) {
                if (selected[i] && (!filter || filter[i])) {
                    newVector.push(rawVector[i]);
                }
            }
            return newVector;
        };
        dataMgrClass.prototype.getOrigColInfos = function () {
            return this._origColInfos;
        };
        dataMgrClass.prototype.getColKeyCounts = function (colName, sortByCount, isDescendingSort, maxKeys, callback) {
            var rawVector = this._dataFrame.getVector(colName, false);
            var keyCountList = rawVector.groupBy().map(function (g) { return { key: g.key, count: g.values.length }; });
            if (sortByCount) {
                var sortedList = keyCountList.orderByNum(function (g) { return g.count; });
            }
            else {
                var sortedList = keyCountList.orderByStr(function (g) { return g.key; });
            }
            if (isDescendingSort) {
                sortedList = sortedList.reverse();
            }
            if (sortedList.length > maxKeys) {
                sortedList = sortedList.slice(0, maxKeys - 1);
            }
            if (callback) {
                callback(sortedList);
            }
            return sortedList;
        };
        dataMgrClass.prototype.getDataVectors = function (names, asNumeric, callback) {
            var nv = {};
            for (var i = 0; i < names.length; i++) {
                var name = names[i];
                nv[name] = this.getFilteredInVector(name, asNumeric);
            }
            callback(nv);
        };
        dataMgrClass.prototype.getFilteredInVector = function (colName, asNumeric) {
            return this._dataFrame.getFilteredInVector(colName, asNumeric);
        };
        dataMgrClass.prototype.getColInfos = function (applyFilter) {
            var colInfos = this._dataFrame.getColInfos();
            return colInfos;
        };
        dataMgrClass.prototype.isFilterInIuse = function () {
            var inUse = (this._filteredInCount != this._recordCount);
            return inUse;
        };
        dataMgrClass.prototype.buildColInfos = function (df) {
            df.clearFilteredColInfosCache();
            var colInfos = df.getColInfos();
            return colInfos;
        };
        dataMgrClass.prototype.isFileLoaded = function (wdp) {
            var isLoaded = false;
            var wdpCurrent = this._wdParams;
            if (wdpCurrent) {
                isLoaded = (wdpCurrent.filePath == wdp.filePath);
                if (isLoaded) {
                    //---- check to see if field list matches ----
                    if (!beachParty.wdCompare.fieldListsMatch(wdpCurrent.fieldList, wdp.fieldList)) {
                        isLoaded = false;
                    }
                }
                if (isLoaded) {
                    if (wdp.dataAggregation != wdpCurrent.dataAggregation) {
                        isLoaded = false;
                    }
                }
                if (isLoaded) {
                    if (wdp.dataSampling != wdpCurrent.dataSampling) {
                        isLoaded = false;
                    }
                }
            }
            return isLoaded;
        };
        dataMgrClass.prototype.onLocalStorageChange = function () {
            this._shareMgr.onLocalStorageChange();
        };
        dataMgrClass.prototype.getShareMgr = function () {
            return this._shareMgr;
        };
        dataMgrClass.prototype.getDataFrame = function () {
            return this._dataFrame;
        };
        dataMgrClass.prototype.getFilename = function () {
            return this._fn;
        };
        dataMgrClass.prototype.searchExactMatchNumber = function (selection, data, value, maxValue) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (isNaN(+itemValue)) {
                    //---- must do an isNan() test on itemValue ----
                    selection[i] = isNaN(+value) ? 1 : 0;
                }
                else if (itemValue == value) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchExactMatchString = function (selection, data, value, maxValue) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (itemValue == value) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchNotEqual = function (selection, data, value, maxValue) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (isNaN(+itemValue)) {
                    //---- must do an isNan() test on itemValue ----
                    selection[i] = isNaN(+value) ? 0 : 1;
                }
                else if (itemValue != value) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchContains = function (selection, data, value, maxValue) {
            value = value + ""; // force to a string
            for (var i = 0; i < data.length; i++) {
                var str = data[i] + "";
                if (str.contains(value)) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchStartsWith = function (selection, data, value, maxValue) {
            value = value + ""; // force to a string
            for (var i = 0; i < data.length; i++) {
                var str = data[i] + "";
                if (str.startsWith(value)) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchGreaterThan = function (selection, data, value, maxValue, isString) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (itemValue > value) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchGreaterThanEqual = function (selection, data, value, maxValue, isString) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (itemValue >= value) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchLessThan = function (selection, data, value, maxValue, isString) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (itemValue < value) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchLessThanEqual = function (selection, data, value, maxValue, isString) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (itemValue <= value) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchBetweenInclusive = function (selection, data, value, maxValue, isString) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (isNaN(+itemValue)) {
                    //---- must do an isNan() test on itemValue ----
                    selection[i] = isNaN(+value) ? 1 : 0;
                }
                else if (itemValue >= value && itemValue <= maxValue) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchGtrValueAndLeqValue2 = function (selection, data, value, maxValue, isString) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (isNaN(+itemValue)) {
                    //---- must do an isNan() test on itemValue ----
                    selection[i] = isNaN(+value) ? 1 : 0;
                }
                else if (itemValue > value && itemValue <= maxValue) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchGeqValueAndLessValue2 = function (selection, data, value, maxValue, isString) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (isNaN(+itemValue)) {
                    //---- must do an isNan() test on itemValue ----
                    selection[i] = isNaN(+value) ? 1 : 0;
                }
                else if (itemValue >= value && itemValue < maxValue) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchColValueByKeys = function (selection, data, otherKeys) {
            for (var i = 0; i < data.length; i++) {
                var strKey = data[i] + "";
                if (otherKeys.indexOf(strKey) > -1) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.dateToNumber = function (value) {
            var numValue;
            if (vp.utils.isString(value)) {
                var dt = new Date(value);
                numValue = +dt;
            }
            else {
                numValue = +value;
            }
            return numValue;
        };
        dataMgrClass.prototype.runSearchQuery = function (spList) {
            var matchVector = null;
            for (var i = 0; i < spList.length; i++) {
                var sp = spList[i];
                var mvSingle = this.runSearchNode(sp);
                if (i == 0) {
                    matchVector = mvSingle;
                }
                else {
                    //---- AND them together ----
                    for (var i = 0; i < matchVector.length; i++) {
                        matchVector[i] = (matchVector[i] && mvSingle[i]);
                    }
                }
            }
            var sp = spList[0];
            var searchAction = (sp.searchAction === undefined) ? beachParty.SearchAction.selectMatches : sp.searchAction;
            var selectMode = sp.selectMode;
            //if (selectMode === undefined)
            //{
            //    selectMode = this._selectMode;
            //}
            var matches = this.applyMatchVector(matchVector, searchAction, selectMode);
            return matches;
        };
        dataMgrClass.prototype.runSearchNode = function (sp) {
            var matches = null;
            var colName = sp.colName;
            if (colName) {
                matches = this.searchSingleColumn(sp);
            }
            else {
                var colInfos = this._dataFrame.getColInfos();
                //---- OR-together search from each string column ----
                for (var i = 0; i < colInfos.length; i++) {
                    var ci = colInfos[i];
                    //---- why did we used to limit this to strings? ----
                    //if (ci.colType == "string")
                    {
                        sp.colName = ci.name;
                        var oneMatch = this.searchSingleColumn(sp);
                        if (!matches) {
                            matches = oneMatch;
                        }
                        else {
                            //---- OR them together ----
                            for (var j = 0; j < matches.length; j++) {
                                matches[j] = (matches[j] || oneMatch[j]);
                            }
                        }
                    }
                }
            }
            return matches;
        };
        dataMgrClass.prototype.searchSingleColumn = function (sp) {
            var colName = sp.colName;
            var value = sp.minValue;
            var maxValue = sp.maxValue;
            var searchType = sp.searchType;
            var searchAction = (sp.searchAction === undefined) ? beachParty.SearchAction.selectMatches : sp.searchAction;
            if (value === "") {
                searchType = beachParty.TextSearchType.exactMatch;
            }
            var st = beachParty.TextSearchType[searchType];
            vp.utils.debug("search: colName=" + colName + ", value=" + value + ", maxValue=" + maxValue +
                ", searchType=" + st);
            var matchVector = vp.data.dataRepeat(0, this._recordCount);
            var colType = this._dataFrame.getColType(colName);
            if (sp.searchRawValues) {
                colType = "string";
            }
            //---- EXACT search uses original string values ----
            var isString = (colType == "string" || searchType == beachParty.TextSearchType.exactMatch || searchType == beachParty.TextSearchType.startsWith);
            if (isString) {
                //---- get original data vector ----
                var data = this._dataFrame.getVector(colName, false);
                if (!sp.caseSensitiveSearch && colType == "string") {
                    if (vp.utils.isArray(value)) {
                        for (var i = 0; i < value.length; i++) {
                            var val = value[i];
                            value[i] = val.toLowerCase();
                        }
                    }
                    else if (vp.utils.isString(value)) {
                        value = value.toLowerCase();
                    }
                    //---- make lowercase copy of data ----
                    var lowData = data.map(function (d) { return d.toLowerCase(); });
                    data = lowData;
                }
            }
            else {
                //---- get numeric form of vector ----
                var data = this._dataFrame.getNumericVector(colName, false).values.toArray();
            }
            if (colType == "number") {
                value = +value;
                maxValue = (maxValue !== null && maxValue !== undefined) ? +maxValue : value;
            }
            else if (colType == "date") {
                value = this.dateToNumber(value);
                maxValue = (maxValue !== null && maxValue !== undefined) ? this.dateToNumber(maxValue) : value;
            }
            if (vp.utils.isArray(value)) {
                this.searchColValueByKeys(matchVector, data, value);
            }
            else if (searchType == beachParty.TextSearchType.exactMatch) {
                if (colType == "string") {
                    this.searchExactMatchString(matchVector, data, value, maxValue);
                }
                else {
                    this.searchExactMatchNumber(matchVector, data, value, maxValue);
                }
            }
            else if (searchType == beachParty.TextSearchType.notEqual) {
                this.searchNotEqual(matchVector, data, value, maxValue);
            }
            else if (searchType == beachParty.TextSearchType.contains) {
                this.searchContains(matchVector, data, value, maxValue);
            }
            else if (searchType == beachParty.TextSearchType.startsWith) {
                this.searchStartsWith(matchVector, data, value, maxValue);
            }
            else if (searchType == beachParty.TextSearchType.greaterThan) {
                this.searchGreaterThan(matchVector, data, value, maxValue, isString);
            }
            else if (searchType == beachParty.TextSearchType.greaterThanEqual) {
                this.searchGreaterThanEqual(matchVector, data, value, maxValue, isString);
            }
            else if (searchType == beachParty.TextSearchType.lessThan) {
                this.searchLessThan(matchVector, data, value, maxValue, isString);
            }
            else if (searchType == beachParty.TextSearchType.lessThanEqual) {
                this.searchLessThanEqual(matchVector, data, value, maxValue, isString);
            }
            else if (searchType == beachParty.TextSearchType.betweenInclusive) {
                this.searchBetweenInclusive(matchVector, data, value, maxValue, isString);
            }
            else if (searchType == beachParty.TextSearchType.gtrValueAndLeqValue2) {
                this.searchGtrValueAndLeqValue2(matchVector, data, value, maxValue, isString);
            }
            else if (searchType == beachParty.TextSearchType.geqValueAndLessValue2) {
                this.searchGeqValueAndLessValue2(matchVector, data, value, maxValue, isString);
            }
            return matchVector;
        };
        dataMgrClass.prototype.applyMatchVector = function (matchVector, searchAction, selectMode) {
            var matches = null;
            if (searchAction == beachParty.SearchAction.returnMatches) {
                //---- return matches ----
                matches = [];
                //var dataView = this._appMgr.getDataView();
                var pkVector = this._dataFrame.getVector(beachParty.primaryKeyName, false);
                if (matchVector) {
                    for (var i = 0; i < matchVector.length; i++) {
                        if (matchVector[i]) {
                            var key = pkVector[i];
                            //---- TODO ----
                            var rc = null; // dataView.getShapeScreenRect(key);
                            var match = { primaryKey: key, rcBounds: rc };
                            matches.push(match);
                        }
                    }
                }
            }
            else {
                //---- update the selection from the matches ----
                //---- convert from list of 0/1 values to a list of "value=1" record indexes ----
                var selectedIndexes = [];
                if (matchVector) {
                    for (var i = 0; i < matchVector.length; i++) {
                        if (matchVector[i]) {
                            selectedIndexes.push(i);
                        }
                    }
                }
                this.updateSelectionFromVectorIndexes(selectedIndexes, selectMode);
                if (searchAction == beachParty.SearchAction.isolateMatches) {
                    this.isolateSelection();
                }
                else if (searchAction == beachParty.SearchAction.excludeMatches) {
                    this.excludeSelection();
                }
            }
            return matches;
        };
        //getColMappings()
        //{
        //    return this._colMappings;
        //}
        dataMgrClass.prototype.getPreload = function () {
            return this._wdParams;
        };
        /** data can be either JSON array, map of named vectors, or text string. */
        dataMgrClass.prototype.setDataAndInfo = function (origDf, postDf, wdParams, loader) {
            this._dataFrame = postDf;
            this._wdParams = wdParams;
            this._fn = wdParams.dataName;
            if (this._colsOnDemand) {
                postDf.loader(loader);
            }
            this._recordCount = postDf.getRecordCount();
            this.computeSelectedCount();
            this.computeFilteredCount();
            //---- build ORIG colInfos, based on full set of (unchanged) columns in table ----
            this._origColInfos = this.buildColInfos(origDf);
            ////---- build colInfos, based on SCRUBBED set of columns ----
            //this._colInfos = this.buildColInfos(postDf);
            this.onDataChanged("dataFrame");
            //this.onDataChanged("filtered");
            this.onDataChanged("colMappings");
            this.onDataChanged("fn");
            this._shareMgr.setFilename(wdParams.dataName);
        };
        dataMgrClass.prototype.requestBinData = function (md, callback) {
            var sortOptions = new beachParty.binSortOptionsClass();
            sortOptions.sortDirection = md.binSorting;
            sortOptions.sortByAggregateType = "count";
            var maxCount = 0;
            //---- create a NamedVector object for binHelper ----
            var nv = new beachParty.NamedVectors(this._recordCount);
            var dataFrame = this.getDataFrame();
            nv.x = dataFrame.getNumericVector(md.colName);
            nv.primaryKey = dataFrame.getNumericVector(beachParty.primaryKeyName);
            var binResult = beachParty.binHelper.createBins(nv, "x", md.binCount, md.binCount, md.forceCategory, true, true, sortOptions, null, md.useNiceNumbers, md);
            callback(binResult);
        };
        dataMgrClass.prototype.computeSelectedCount = function () {
            var select = this.getSelectedVector(false);
            this._selectedCount = vector.countOn(select);
        };
        dataMgrClass.prototype.computeFilteredCount = function () {
            var filter = this.getFilteredVector(false);
            this._filteredInCount = vector.countOff(filter);
        };
        dataMgrClass.prototype.getFilteredVector = function (invalidateNumericCache) {
            return this._dataFrame.getFilteredVector(invalidateNumericCache);
        };
        dataMgrClass.prototype.getSelectedVector = function (invalidateNumericCache) {
            var vector = this._dataFrame.getVector(beachParty.selectedName, invalidateNumericCache);
            return vector;
        };
        //getRecordIndexVector()
        //{
        //    var vector = this._dataFrame.getVector(primaryKeyName, false);
        //    return vector;
        //}
        dataMgrClass.prototype.updateSelectionFromBoxes = function (origBoxes, selectMode) {
            //---- map origBoxes[] shapeIndex to sorted-data-relative boxIndexes[] ----
            if (origBoxes) {
                var vectorIndexes = [];
                var pkToVectorIndex = this._dataFrame.getPkToVectorIndex();
                for (var i = 0; i < origBoxes.length; i++) {
                    var key = origBoxes[i].primaryKey;
                    var vectorIndex = pkToVectorIndex[key];
                    vectorIndexes.push(vectorIndex);
                }
                this.updateSelectionFromVectorIndexes(vectorIndexes, selectMode);
            }
        };
        /**
         *  Remove any indexes that are not in the current FILTERED IN records.
         * @param indexes
         */
        dataMgrClass.prototype.removeFilteredOutIndexes = function (indexes) {
            var filteredOut = this.getFilteredVector(false);
            var newIndexes = [];
            for (var i = 0; i < indexes.length; i++) {
                var index = indexes[i];
                if (!filteredOut[index]) {
                    newIndexes.push(index);
                }
            }
            return newIndexes;
        };
        dataMgrClass.prototype.updateSelectionFromVectorIndexes = function (indexes, selectMode) {
            //if (selectMode === undefined)
            //{
            //    selectMode = this._selectMode;
            //}
            indexes = this.removeFilteredOutIndexes(indexes);
            var select = this.getSelectedVector(true);
            //---- smart toggle is just treated as "normal" in the plot engine ----
            if (selectMode == beachParty.SelectMode.smartToggle) {
                selectMode = beachParty.SelectMode.normal;
            }
            if (selectMode == beachParty.SelectMode.normal) {
                //---- clear previous selection ----
                vector.clear(select);
            }
            if (selectMode == beachParty.SelectMode.subtractive) {
                for (var i = 0; i < indexes.length; i++) {
                    var recordIndex = indexes[i];
                    select[recordIndex] = 0;
                }
            }
            else if (selectMode == beachParty.SelectMode.intersection) {
                var temp = vp.utils.copyArray(select);
                for (var i = 0; i < indexes.length; i++) {
                    var recordIndex = indexes[i];
                    if (temp[recordIndex] == 1) {
                        temp[recordIndex] = 2;
                    }
                }
                //---- tranfer to select ----
                for (var i = 0; i < temp.length; i++) {
                    select[i] = (temp[i] == 2) ? 1 : 0;
                }
            }
            else if (selectMode == beachParty.SelectMode.nonIntersection) {
                var temp = vp.utils.copyArray(select);
                for (var i = 0; i < indexes.length; i++) {
                    var recordIndex = indexes[i];
                    if (temp[recordIndex] == 1) {
                        temp[recordIndex] = 2;
                    }
                    else {
                        temp[recordIndex] = 1;
                    }
                }
                //---- tranfer to select ----
                for (var i = 0; i < temp.length; i++) {
                    select[i] = (temp[i] == 1) ? 1 : 0;
                }
            }
            else if (selectMode == beachParty.SelectMode.normal || selectMode == beachParty.SelectMode.additive) {
                for (var i = 0; i < indexes.length; i++) {
                    var recordIndex = indexes[i];
                    select[recordIndex] = 1;
                }
            }
            else if (selectMode == beachParty.SelectMode.toggleClear) {
                if (indexes.length == 0) {
                    if (selectMode == beachParty.SelectMode.toggleClear) {
                        //---- clear previous selection ----
                        vector.clear(select);
                    }
                }
                else {
                    for (var i = 0; i < indexes.length; i++) {
                        var recordIndex = indexes[i];
                        //---- toggle each record specified ----
                        select[recordIndex] = (1 - select[recordIndex]);
                    }
                }
            }
            this.onSelectionChanged();
        };
        dataMgrClass.prototype.getVectorFromKeys = function (keys) {
            var vector = vp.data.dataRepeat(0, this._recordCount);
            var pkToVectorIndex = this._dataFrame.getPkToVectorIndex();
            for (var i = 0; i < keys.length; i++) {
                var pk = keys[i];
                var vi = pkToVectorIndex[pk];
                vector[vi] = 1;
            }
            return vector;
        };
        //---- set FILTERED-OUT records to the specified list of primary keys ----
        dataMgrClass.prototype.setFilter = function (filteredOutKeys) {
            //---- optimized for speed, so slightly complex ----
            var isDifferent = false;
            var newVector = null;
            var filter = null;
            var noFilter = (!filteredOutKeys || filteredOutKeys.length == 0);
            if (noFilter) {
                isDifferent = this.isFilterInIuse();
            }
            else {
                //---- must convert keys to vector, and compare vectors ----
                newVector = this.getVectorFromKeys(filteredOutKeys);
                filter = this.getFilteredVector(false);
                isDifferent = vector.compare(filter, newVector);
            }
            if (isDifferent) {
                if (!newVector) {
                    filter = this.getFilteredVector(false);
                    newVector = this.getVectorFromKeys(filteredOutKeys);
                }
                vector.copy(filter, newVector);
                this.computeFilteredCount();
                this.onDataChanged("filtered");
                //---- rebuild colInfos so they reflect new filter setting ----
                this.buildColInfos(this._dataFrame);
                //---- since the filter has been changed, invalidate filter column numeric data cache ----
                this._dataFrame.invalidateCache(beachParty.filteredName);
            }
            return isDifferent;
        };
        dataMgrClass.prototype.forceFilterChangedEvent = function () {
            this.onDataChanged("filtered");
        };
        /** sets the selection vector to the records described by "selectedPrimaryKeys", without applying any boolean operations. */
        dataMgrClass.prototype.setSelectionDirect = function (selectedPrimaryKeys, changeSource) {
            var isDifferent = false;
            var selectVector = null;
            var newVector = null;
            var noSelect = (!selectedPrimaryKeys || selectedPrimaryKeys.length == 0);
            if (noSelect) {
                isDifferent = (this._selectedCount > 0);
            }
            else {
                //---- must convert keys to vector, and compare vectors ----
                newVector = this.getVectorFromKeys(selectedPrimaryKeys);
                selectVector = this.getSelectedVector(false);
                isDifferent = vector.compare(selectVector, newVector);
            }
            if (isDifferent) {
                if (!newVector) {
                    selectVector = this.getSelectedVector(false);
                    newVector = this.getVectorFromKeys(selectedPrimaryKeys);
                }
                vector.copy(selectVector, newVector);
                //---- since the selection has been changed, invalidate its numeric data cache ----
                this._dataFrame.invalidateCache(beachParty.selectedName);
                this.onSelectionChanged(changeSource);
            }
            return isDifferent;
        };
        dataMgrClass.prototype.isolateSelection = function () {
            /// REMINDER: filtered[i] == true (or == 1) means record is filtered OUT of view  
            var select = this.getSelectedVector(false);
            var filter = this.getFilteredVector(true);
            for (var i = 0; i < select.length; i++) {
                //---- don't change filter of filtered-out records ----
                if (!filter[i]) {
                    filter[i] = (1 - select[i]);
                }
            }
            this.onFilterChanged();
            this.clearSelection();
        };
        dataMgrClass.prototype.onFilterChanged = function () {
            this.computeFilteredCount();
            this.onDataChanged("filtered");
            var filterInIuse = this.isFilterInIuse();
            this._dataFrame.isFilterActive(filterInIuse);
        };
        dataMgrClass.prototype.excludeSelection = function () {
            /// REMINDER: filtered[i] == true (or == 1) means record is filtered OUT of view  
            var select = this.getSelectedVector(false);
            var filter = this.getFilteredVector(true);
            for (var i = 0; i < select.length; i++) {
                //---- don't change filter of filtered-out records ----
                if (!filter[i]) {
                    //---- record is filtered out if it IS selected ----
                    filter[i] = select[i];
                }
            }
            this.onFilterChanged();
            this.clearSelection();
        };
        /**
         * returns full records for the selected rows, optionally applying the filter.
         * @param applyFilter
         */
        dataMgrClass.prototype.getSelectedRecords = function (applyFilter) {
            var select = this.getSelectedVector(false);
            var selectedRecords = [];
            var filter = null;
            if (applyFilter) {
                filter = this.getFilteredVector(true);
            }
            if (filter && filter.length) {
                for (var i = 0; i < select.length; i++) {
                    if ((select[i]) && (!filter[i])) {
                        var record = this._dataFrame.getRecordByVectorIndex(i);
                        selectedRecords.push(record);
                    }
                }
            }
            else {
                for (var i = 0; i < select.length; i++) {
                    if (select[i]) {
                        var record = this._dataFrame.getRecordByVectorIndex(i);
                        selectedRecords.push(record);
                    }
                }
            }
            return selectedRecords;
        };
        dataMgrClass.prototype.sortData = function (colName, ascending) {
            var colType = this._dataFrame.getColType(colName);
            this._dataFrame.sortVectors(colName, ascending, colType);
            this.onDataChanged("sortOrder");
        };
        dataMgrClass.prototype.resetFilter = function () {
            var filter = this.getFilteredVector(true);
            vector.clear(filter);
            this.onFilterChanged();
            this.onDataChanged("filterReset");
            //---- this is no longer done in resetFilter ----
            //this.clearSelection();
        };
        dataMgrClass.prototype.clearSelection = function (omitNotify) {
            var select = this.getSelectedVector(true);
            vector.clear(select);
            if (!omitNotify) {
                this.onSelectionChanged();
            }
        };
        dataMgrClass.prototype.onSelectionChanged = function (changeSource) {
            if (changeSource === void 0) { changeSource = "local"; }
            this.computeSelectedCount();
            this.onDataChanged("selection");
            if (changeSource == "local") {
                var select = this.getSelectedVector(false);
                var selectedPrimaryKeys = this._dataFrame.vectorToPrimaryKeys(select);
                this._shareMgr.setSelection(selectedPrimaryKeys);
            }
        };
        dataMgrClass.prototype.getSelectedCount = function (applyFilter) {
            var count = this._selectedCount;
            if (applyFilter && this._recordCount != this._filteredInCount) {
                var select = this.getFilteredInVector(beachParty.selectedName);
                count = vector.countOn(select);
            }
            return count;
        };
        dataMgrClass.prototype.getFilteredInCount = function () {
            return this._filteredInCount;
        };
        dataMgrClass.prototype.getKnownDataPreloads = function () {
            return this._preloadMgr.getPreloads();
        };
        dataMgrClass.prototype.getPreloadMgr = function () {
            return this._preloadMgr;
        };
        return dataMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.dataMgrClass = dataMgrClass;
    (function (DataChangeFlags) {
        DataChangeFlags[DataChangeFlags["dataSetChange"] = 1] = "dataSetChange";
        DataChangeFlags[DataChangeFlags["selectionChange"] = 2] = "selectionChange";
        DataChangeFlags[DataChangeFlags["filterChange"] = 4] = "filterChange";
        DataChangeFlags[DataChangeFlags["columnsChange"] = 8] = "columnsChange";
        DataChangeFlags[DataChangeFlags["dataUpdate"] = 16] = "dataUpdate";
        DataChangeFlags[DataChangeFlags["sortOrder"] = 32] = "sortOrder";
    })(beachParty.DataChangeFlags || (beachParty.DataChangeFlags = {}));
    var DataChangeFlags = beachParty.DataChangeFlags;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// fileAccess.ts.  Copyright (c) 2016 Microsoft Corporation.
///     Part of the beachParty library - functions to read and write files.
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    (function (fileFormat) {
        fileFormat[fileFormat["text"] = 0] = "text";
        fileFormat[fileFormat["json"] = 1] = "json";
        fileFormat[fileFormat["csv"] = 2] = "csv";
        fileFormat[fileFormat["odata"] = 3] = "odata";
        fileFormat[fileFormat["excelSheet"] = 4] = "excelSheet";
        fileFormat[fileFormat["excelAllSheets"] = 5] = "excelAllSheets";
    })(beachParty.fileFormat || (beachParty.fileFormat = {}));
    var fileFormat = beachParty.fileFormat;
    var fileAccess = (function () {
        function fileAccess() {
        }
        /** reads a local text file that is selected by the user. */
        fileAccess.readLocalTextFile = function (userPrompt, callback) {
            //---- add an file input elem so we can promp user for file ----
            var fileElem = document.createElement("input");
            fileElem.setAttribute("type", "file");
            fileElem.style.display = "none";
            document.body.appendChild(fileElem);
            //---- click on it to invoke the dialog ----
            fileElem.click();
            //---- remove the fileElem ----
            document.body.removeChild(fileElem);
            //---- now, initiate the async read ----
            var reader = new FileReader();
            reader.onload = function (f) {
                callback(reader.result);
            };
            var started = false;
            if (fileElem.files.length) {
                var file = fileElem.files[0];
                reader.readAsText(file);
                started = true;
            }
            return started;
        };
        fileAccess.mapToUrlParams = function (map) {
            var str = "";
            if (map) {
                for (var key in map) {
                    if (str == "") {
                        str = "?";
                    }
                    else {
                        str += "&";
                    }
                    str += key + "=" + map[key];
                }
            }
            return str;
        };
        fileAccess.writeFile64 = function (fn, content64) {
            var vp = bpServerPath();
            var serviceUrl = vp + "/putData.asmx/writeFile64";
            var fullUrl = serviceUrl;
            var finalUrl = encodeURI(fullUrl);
            //alert("posting to url: " + finalUrl);
            var body = "fn=" + fn + "&content=" + content64;
            fileAccess.httpPost(finalUrl, body, function (xmlhttp) {
                //alert("writeFile64 succeeded");
            }, function (e) {
                //alert("writeFile64 failed");
            }, false);
        };
        fileAccess.writeFileText = function (fn, text, successCallback, failureCallback) {
            var vp = bpServerPath();
            var serviceUrl = vp + "/putData.asmx/writeFileText";
            var fullUrl = serviceUrl;
            var finalUrl = encodeURI(fullUrl);
            //alert("posting to url: " + finalUrl);
            var body = "fn=" + fn + "&text=" + encodeURIComponent(text);
            var isAsync = (successCallback !== undefined);
            fileAccess.httpPost(finalUrl, body, function (xmlhttp) {
                if (successCallback) {
                    successCallback(xmlhttp);
                }
            }, function (e) {
                if (failureCallback) {
                    failureCallback(e);
                }
            }, isAsync);
        };
        fileAccess.removeDirectory = function (dir) {
            var vp = bpServerPath();
            var serviceUrl = vp + "/putData.asmx/removeDirectory";
            var fullUrl = serviceUrl;
            var finalUrl = encodeURI(fullUrl);
            //alert("posting to url: " + finalUrl);
            var body = "dir=" + dir;
            fileAccess.httpPost(finalUrl, body, function (xmlhttp) {
                //alert("writeFile64 succeeded");
            }, function (e) {
                //alert("writeFile64 failed");
            }, false);
        };
        /** replace every /Date/ value with a javaScript date object. */
        fileAccess.fixUpDatesFromDotNet = function (data) {
            var keys = null;
            if (data.length) {
                //---- JSON array of records ----
                for (var r = 0; r < data.length; r++) {
                    var record = data[r];
                    if (!keys) {
                        keys = vp.utils.keys(record);
                    }
                    for (var k = 0; k < keys.length; k++) {
                        var colName = keys[k];
                        var value = record[colName];
                        if (vp.utils.isString(value)) {
                            var str = value;
                            if (str.startsWith("/Date(")) {
                                str = "new " + str.substr(1, str.length - 2);
                                var date = new Date(str);
                                record[colName] = date;
                            }
                        }
                    }
                }
            }
            else if (data._vectorsByName) {
                //---- DATA FRAME class ----
                var df = data;
                //---- process by vector ----
                var names = df.getColumnNames();
                for (var v = 0; v < names.length; v++) {
                    var name = names[v];
                    var vector = df.getVector(name, true);
                    for (var r = 0; r < vector.length; r++) {
                        var value = vector[r];
                        if (vp.utils.isString(value)) {
                            var str = value;
                            if (str.startsWith("/Date(")) {
                                str = "new " + str.substr(1, str.length - 2);
                                var date = new Date(str);
                                vector[r] = date;
                            }
                        }
                    }
                }
            }
            else if (data) {
                //---- KEY/VECTOR dict ----
                var names = vp.utils.keys(data);
                for (var v = 0; v < names.length; v++) {
                    var name = names[v];
                    var vector = data[name];
                    for (var r = 0; r < vector.length; r++) {
                        var value = vector[r];
                        if (vp.utils.isString(value)) {
                            var str = value;
                            if (str.startsWith("/Date(")) {
                                str = "new " + str.substr(1, str.length - 2);
                                var date = new Date(str);
                                vector[r] = date;
                            }
                        }
                    }
                }
            }
            return data;
        };
        /** read TEXT file sync. from server relative path. */
        fileAccess.readServerTextFile = function (relPath) {
            //---- read file SYNC from my host (same directory) ----
            var request = new XMLHttpRequest();
            //---- try to disable caching here by using time as a unique URL argument ----
            //relPath += "?foo=" + Date.now();
            request.open("GET", relPath, false);
            request.send();
            var str = request.responseText;
            return str;
        };
        /** read binary file sync. from server relative path, into arrayBuff. */
        fileAccess.readServerFileIntoArrayBuff = function (relPath) {
            var request = new XMLHttpRequest();
            request.open("GET", relPath, false);
            request.responseType = 'arraybuffer';
            request.send();
            var uInt8Array = new Uint8Array(request.response);
            return uInt8Array;
        };
        fileAccess.readFile = function (fnOrUlr, format, formatOptions, asyncSuccessCallback, asyncFailCallback, noCache, asDataFrame, addDataPathIfNeeded) {
            //vp.utils.debug("readFile() called");
            if (addDataPathIfNeeded === void 0) { addDataPathIfNeeded = true; }
            format = format || fileFormat.text; // default to TEXT
            var isJson = ((format === fileFormat.json) || (format === fileFormat.odata));
            if (addDataPathIfNeeded && !fnOrUlr.contains(":")) {
                fnOrUlr = bpDataPath() + "/" + fnOrUlr;
            }
            var result = undefined;
            if (format == fileFormat.csv) {
                fileAccess.httpReadCsvViaService(fnOrUlr, formatOptions, function (data) {
                    //---- success ----
                    if (asyncSuccessCallback) {
                        var data = fileAccess.fixUpDatesFromDotNet(data);
                        asyncSuccessCallback(data);
                    }
                    else {
                        result = data;
                    }
                }, function (e) {
                    if (asyncFailCallback) {
                        asyncFailCallback(e);
                    }
                    else {
                        //---- FAILURE ----
                        fileFail("httpReadCsvViaService", fnOrUlr, e);
                    }
                }, (asyncSuccessCallback != null), asDataFrame);
            }
            else if (format == fileFormat.excelSheet || format == fileFormat.excelAllSheets) {
                fileAccess.httpReadExcelViaService(fnOrUlr, format, formatOptions, function (data) {
                    //---- success ----
                    if (asyncSuccessCallback) {
                        var data = fileAccess.fixUpDatesFromDotNet(data);
                        asyncSuccessCallback(data);
                    }
                    else {
                        result = data;
                    }
                }, function (e) {
                    //---- failure ----
                    if (asyncFailCallback) {
                        asyncFailCallback(e);
                    }
                    else {
                        //throw "Error during httpReadCsvViaService: url=" + fnOrUlr + ", error=" + e.response;
                        fileFail("httpReadCsvViaService", fnOrUlr, e);
                    }
                }, (asyncSuccessCallback != null));
            }
            else {
                fileAccess.httpReadViaService(fnOrUlr, isJson, function (data) {
                    //---- success ----
                    if (format === fileFormat.odata) {
                        data = data.results;
                    }
                    //---- sending from server encodes special characters, so we must decode them ----
                    data = fileAccess.removeHtmlEncoding(data);
                    //else if (format === fileFormat.csv)
                    //{
                    //    var start = vp.utils.now();
                    //    var csv = createCsvLoader(formatOptions.hasHeader, formatOptions.sepChar,
                    //        formatOptions.findTypes);
                    //    data = csv.load(data, false);
                    //    var data = fileAccess.fixUpDatesFromDotNet(data);
                    //    var elapsed = vp.utils.now() - start;
                    //    vp.utils.debug("csvLoader.load: " + elapsed + " ms");
                    //}
                    if (asDataFrame) {
                        data = beachParty.dataFrameClass.jsonToDataFrame(data);
                    }
                    if (asyncSuccessCallback) {
                        asyncSuccessCallback(data);
                    }
                    else {
                        result = data;
                    }
                }, function (e) {
                    if (asyncFailCallback) {
                        asyncFailCallback(e);
                    }
                    else {
                        //---- failure ----
                        //throw "Error during httpReadCsvViaService: url=" + fnOrUlr + ", error=" + e.response;
                        fileFail("httpReadCsvViaService", fnOrUlr, e);
                    }
                }, (asyncSuccessCallback != null), noCache);
            }
            return result;
        };
        //---- this seems to be the best way to remove HTML encodings from a string (might compress spaces though) ----
        fileAccess.removeHtmlEncoding = function (value) {
            var div = document.createElement("div");
            div.innerHTML = value;
            var str = div.textContent;
            return str;
        };
        fileAccess.readSqlTable = function (cs, tableName, query, dataSampling, asyncSuccessCallback, asyncFailCallback) {
            if (!query) {
                query = "";
            }
            //---- base URL: http://localhost/bpServerOther/getData.asmx/DownloadDataFromSql ----
            var bpServer = bpServerNextPath();
            //var serviceUrl = bpServer + "Other/getData.asmx/DownloadDataFromSql";
            var serviceUrl = bpServer + "/bpService.asmx/DownloadDataFromSql";
            var fullUrl = serviceUrl + "?cs=" + cs + "&tableName=" + tableName + "&query=" +
                query;
            if (dataSampling && dataSampling.isEnabled) {
                fullUrl += "&sampleThreshold=" + dataSampling.samplingThreshold;
                fullUrl += "&sampleType=" + beachParty.SampleType[dataSampling.sampleType];
                fullUrl += "&sampleCount=" + dataSampling.sampleCount;
            }
            else {
                fullUrl += "&sampleThreshold=-1";
                fullUrl += "&sampleType=none";
                fullUrl += "&sampleCount=-1";
            }
            var finalUrl = encodeURI(fullUrl);
            var isJson = true;
            httpRead(finalUrl, isJson, function (xmlhttp) {
                if (asyncSuccessCallback) {
                    var result = getDataFromResult(xmlhttp, isJson);
                    result.data = fileAccess.fixUpDatesFromDotNet(result.data);
                    asyncSuccessCallback(result);
                }
            }, asyncFailCallback, true);
        };
        fileAccess.readSqlTableAgg = function (cs, tableName, query, dataAgg, asyncSuccessCallback, asyncFailCallback) {
            if (!query) {
                query = "";
            }
            //---- base URL: http://localhost/bpServerOther/getData.asmx/DownloadAggDataFromSql ----
            var bpServer = bpServerPath();
            //var serviceUrl = bpServer + "Other/getData.asmx/DownloadDataFromSql";
            var serviceUrl = bpServer + "/bpService.asmx/DownloadAggDataFromSql";
            var fullUrl = serviceUrl + "?cs=" + cs + "&tableName=" + tableName + "&query=" +
                query;
            fullUrl += "&aggType=" + beachParty.AggType[dataAgg.aggType];
            fullUrl += "&aggColumn=" + dataAgg.targetCol;
            fullUrl += "&groupCols=" + dataAgg.groupCols;
            fullUrl += "&jsonAggFilters=" + JSON.stringify(dataAgg.aggFilters);
            var finalUrl = encodeURI(fullUrl);
            var isJson = true;
            httpRead(finalUrl, isJson, function (xmlhttp) {
                if (asyncSuccessCallback) {
                    var result = getDataFromResult(xmlhttp, isJson);
                    result.data = fileAccess.fixUpDatesFromDotNet(result.data);
                    asyncSuccessCallback(result);
                }
            }, asyncFailCallback, true);
        };
        fileAccess.httpReadIncremental = function (url, isJson, offset, maxSize, successFunc, failFunc, callAsync) {
            var pp = pagePath();
            if (url.startsWith("..")) {
                url = pp + url;
            }
            //var serviceUrl = "http://" + window.location.host + "/VuePlotWeb/Service/Service1.asmx/DownloadText";
            var serviceUrl = pp + "/Service/Service1.asmx/IncrementalDownload";
            var win = window;
            if (win.alertShown === undefined) {
                //alert("read via url: " + serviceUrl);
                win.alertShown = 1;
            }
            var fullUrl = serviceUrl + "?url=" + url + "&offset=" + offset + "&maxSize=" + maxSize;
            httpRead(fullUrl, false, function (xmlhttp) {
                if (successFunc) {
                    var data = getDataFromResult(xmlhttp, isJson);
                    successFunc(data);
                }
            }, failFunc);
        };
        /// starts a async (or calls sync) upload of text to the specified url.
        fileAccess.httpPost = function (url, stringToSend, successFunc, failFunc, isAsync, contentType) {
            var xmlhttp = createXMLHttpRequest();
            xmlhttp.open("POST", url, isAsync);
            if (!contentType) {
                contentType = "application/x-www-form-urlencoded";
            }
            xmlhttp.setRequestHeader("Content-Type", contentType);
            xmlhttp.onreadystatechange = function () {
                if ((xmlhttp.readyState == 4) && (xmlhttp.status != 0)) {
                    if (xmlhttp.status == 200) {
                        if (successFunc != null) {
                            successFunc(xmlhttp);
                        }
                    }
                    else {
                        if (failFunc != null) {
                            failFunc(xmlhttp);
                        }
                    }
                }
            };
            xmlhttp.send(stringToSend);
        };
        ///
        /// download text data from a URL, using a specific service that is expected to
        /// be on the same host as the current host:  http://samehostname/VuePlotWeb/Service/Service1.asmx/DownloadText
        ///
        /// This is to get around problem "cross origin resource sharing".
        ///
        fileAccess.httpReadViaService = function (url, isJson, successFunc, failFunc, isAsync, noCache) {
            isJson = isJson || false;
            noCache = noCache || false;
            var vp = bpServerPath();
            var serviceUrl = vp + "/getData.asmx/DownloadText";
            var win = window;
            if (win.alertShown === undefined) {
                //alert("read via url: " + serviceUrl);
                win.alertShown = 1;
            }
            var httpReadJson = false; // download to us as text
            var finalUrl = serviceUrl + "?url=" + url + "&isJson=" + httpReadJson + "&noCache=" + noCache;
            httpRead(finalUrl, httpReadJson, function (xmlhttp) {
                if (successFunc) {
                    var data = getDataFromResult(xmlhttp, isJson, true);
                    successFunc(data);
                }
            }, failFunc, isAsync, noCache);
        };
        ///
        /// download CSV data (as JSON data) from a URL, using a specific service that is expected to
        /// be on the same host as the current host:  http://samehostname/VuePlotWeb/Service/Service1.asmx/DownloadCsvAsJson
        ///
        /// This is to get around problem "cross origin resource sharing".
        ///
        fileAccess.httpReadCsvViaService = function (url, csvOpts, successFunc, failFunc, isAsync, asDataFrame) {
            if (asDataFrame === void 0) { asDataFrame = false; }
            var vp = bpServerPath();
            //var serviceUrl = vp + "/getData.asmx/DownloadCsvAsJsonVectors";
            var serviceUrl = vp + "/bpService.asmx/DownloadCsvAsJsonVectors";
            var win = window;
            if (win.alertShown === undefined) {
                //alert("read via url: " + serviceUrl);
                win.alertShown = 1;
            }
            var fullUrl = serviceUrl + "?url=" + url + "&delimeter=" + csvOpts.sepChar +
                "&hasHeader=" + csvOpts.hasHeader + "&inferTypes=" + csvOpts.findTypes;
            var finalUrl = encodeURI(fullUrl);
            var isJson = true;
            httpRead(finalUrl, isJson, function (xmlhttp) {
                if (successFunc) {
                    var data = getDataFromResult(xmlhttp, isJson);
                    if (asDataFrame) {
                        //---- convert into a real dataFrame object ----
                        var dataCols = [];
                        for (var i = 0; i < data.names.length; i++) {
                            var name = data.names[i];
                            var vector = data.vectors[i];
                            var dc = new beachParty.DataColumn(name, null, null, null, null, vector);
                            dataCols.push(dc);
                        }
                        var df = new beachParty.dataFrameClass(dataCols);
                        data = df;
                    }
                    data = fileAccess.fixUpDatesFromDotNet(data);
                    successFunc(data);
                }
            }, failFunc, isAsync);
        };
        ///
        /// download Excel data (as JSON data) from a URL, using a specific service that is expected to
        /// be on the same host as the current host:  http://samehostname/VuePlotWeb/Service/Service1.asmx/DownloadExcelAsJson
        ///
        /// This is to get around problem "cross origin resource sharing".
        ///
        fileAccess.httpReadExcelViaService = function (url, format, sheetName, successFunc, failFunc, isAsync) {
            var vp = bpServerPath();
            if (format == fileFormat.excelSheet) {
                var serviceUrl = vp + "/getData.asmx/DownloadExcelSheetAsJson";
                var fullUrl = serviceUrl + "?url=" + url + "&sheetName=" + sheetName;
            }
            else {
                var serviceUrl = vp + "/getData.asmx/DownloadAllExcelSheetsAsJson";
                var fullUrl = serviceUrl + "?url=" + url;
            }
            var win = window;
            if (win.alertShown === undefined) {
                //alert("read via url: " + serviceUrl);
                win.alertShown = 1;
            }
            var finalUrl = encodeURI(fullUrl);
            var isJson = true;
            httpRead(finalUrl, isJson, function (xmlhttp) {
                if (successFunc) {
                    var data = getDataFromResult(xmlhttp, isJson);
                    successFunc(data);
                }
            }, failFunc, isAsync);
        };
        /// reads OData data from the specified url.
        fileAccess.oDataRead = function (url, isJson, successFunc, failFunc) {
            fileAccess.httpReadViaService(url, isJson, function (data) {
                if (successFunc) {
                    if ((data) && (data.results)) {
                        data = data.results;
                    }
                    successFunc(data);
                }
            }, failFunc);
        };
        /// reads all of the OData data from the specified url (adding parameters to the URL to
        /// read each block of data).
        fileAccess.oDataReadAll = function (url, byCount, successFunc, failFunc) {
            if (byCount == null) {
                byCount = 1000;
            }
            var bag = fileAccess.oDataBag;
            bag.error = false;
            bag.data = [];
            bag.total = 0;
            bag.byCount = byCount;
            var self = this;
            var readMore = function () {
                fileAccess.oDataRead(url + "?$skip=" + bag.total + "&$top=" + bag.byCount, true, function (dataChunk) {
                    var chunkSize = dataChunk.length;
                    if (chunkSize > 0) {
                        bag.byCount = chunkSize;
                        //self.dataServices.concat(dataChunk);
                        //bag.data = dataServices.conconcat(bag.data, dataChunk);
                        bag.total = bag.data.length;
                        readMore();
                    }
                    else {
                        if (successFunc != null) {
                            successFunc(bag.data);
                        }
                    }
                }, function (xmlhttp) {
                    if (failFunc != null) {
                        failFunc(xmlhttp);
                    }
                    bag.error = true;
                });
            };
            readMore();
        };
        //---- we use this to store data for multiple calls to oDataReadAll ----
        fileAccess.oDataBag = {};
        return fileAccess;
    }());
    beachParty.fileAccess = fileAccess;
    var incrementalCsvLoader = (function () {
        function incrementalCsvLoader(url, hasHeader, sepChar, findTypes, recordsCallback) {
            this._csvLoader = null;
            this._offset = 0;
            this._recordsCallback = null;
            this._url = null;
            this._recordsCallback = recordsCallback;
            this._url = url;
            this._csvLoader = beachParty.createCsvLoader(hasHeader, sepChar, findTypes);
        }
        incrementalCsvLoader.prototype.readNextCheck = function (size) {
            fileAccess.httpReadIncremental(this._url, false, this._offset, size, function (jsonResult) {
                //---- success: got next chunk ----
                var chunk = jsonResult.data;
                var isMore = jsonResult.isMore;
                this._offset += chunk.length;
                var records = this._csvLoader.load(chunk, true);
                this._recordsCallback(records, isMore);
            }, function (xmlhttp) {
                //---- read failed ----
                throw "Error reading CSV file: " + this._url;
            });
        };
        return incrementalCsvLoader;
    }());
    beachParty.incrementalCsvLoader = incrementalCsvLoader;
    function pagePath() {
        var pp = window.location.href;
        //---- on IE10, running under "localhost", sometimes all the props of "window.location" are ----
        //---- undefined, so we ahndle that here ----
        if (pp === undefined) {
            pp = window.location.toString();
        }
        var index = pp.lastIndexOf("/");
        if (index > 0) {
            pp = pp.substr(0, index);
            index = pp.lastIndexOf("/");
            if (index > 0) {
                pp = pp.substr(0, index);
            }
        }
        return pp;
    }
    beachParty.pagePath = pagePath;
    /// starts a async download of text from the specified url.  if "isJson" is true,
    /// the data is requested in json format.  when the download is finished, either
    /// successFunc or failFunc is called, with the param "xmlhttp".
    ///
    /// if this is a file on a server, the true text is returned in xmlhttp.responseText.  if text is XML,
    /// the XML document object is available in xmlhttp.responseXML.
    function httpRead(url, isJson, successFunc, failFunc, callAsync, noCache) {
        callAsync = (callAsync === undefined) ? true : callAsync;
        var xmlhttp = vp.utils.createXMLHttpRequest();
        xmlhttp.open("GET", url, callAsync);
        if (isJson) {
            xmlhttp.setRequestHeader("accept", "application/json");
        }
        if (noCache) {
            //xmlhttp.setRequestHeader("If-Modified-Since", "Sat, 1 Jan 2015 00:00:00 GMT");
            //---- per http://stackoverflow.com/questions/49547/making-sure-a-web-page-is-not-cached-across-all-browsers ----
            xmlhttp.setRequestHeader("Cache-Control", "no-cache, no-store, must-revalidate"); // HTTP 1.1.
            xmlhttp.setRequestHeader("Pragma", "no-cache"); // HTTP 1.0.
            xmlhttp.setRequestHeader("Expires", "2"); // Proxies.
        }
        xmlhttp.onreadystatechange = function () {
            if ((xmlhttp.readyState == 4) && (xmlhttp.status != 0)) {
                if (xmlhttp.status == 200) {
                    if (successFunc != null) {
                        successFunc(xmlhttp);
                    }
                }
                else {
                    if (failFunc != null) {
                        failFunc(xmlhttp);
                    }
                    else {
                        throw "httpRead failed: url=" + url;
                    }
                }
            }
        };
        xmlhttp.send();
    }
    beachParty.httpRead = httpRead;
    function getMyPath() {
        if (this._appMgr && this._appMgr._beachPartyDir) {
            var path = this._appMgr._beachPartyDir + "/Apps";
        }
        else {
            var path = window.location.href;
            //---- remove any params ----
            var index = path.indexOf("?");
            if (index > -1) {
                path = path.substr(0, index);
            }
            //---- remove the last node ----
            var index = path.lastIndexOf("/");
            if (index > -1) {
                path = path.substr(0, index);
            }
        }
        return path;
    }
    beachParty.getMyPath = getMyPath;
    function pathHelper(nodeName) {
        var getServicePrefix = true;
        var serverPath = window.location.href;
        //---- try easy ones first ----
        if (serverPath.startsWith("http://localhost")) {
            serverPath = "http://localhost/" + nodeName;
        }
        else if (serverPath.contains("azurewebsites")) {
            serverPath = location.protocol + "//" + location.hostname + "/" + nodeName;
        }
        else {
            //---- vibe10 or a named dev machine ----
            if (serverPath.startsWith("http://vibe10") || serverPath.startsWith("https://vibe10")) {
                //---- first, remove any parameters ----
                var index = serverPath.indexOf("?");
                if (index > -1) {
                    serverPath = serverPath.substr(0, index);
                }
                //---- find node that begins with "/build" ----
                index = serverPath.indexOf("/build");
                if (index > 0) {
                    var index2 = serverPath.indexOf("/", index + 1);
                    if (index2 > -1) {
                        serverPath = serverPath.substr(0, index2);
                        serverPath += "/" + nodeName;
                    }
                }
            }
            else {
                serverPath = location.protocol + "//" + location.hostname + "/" + nodeName;
            }
        }
        return serverPath;
    }
    function bpServerPath() {
        ////---- on IE10, running under "localhost", sometimes all the props of "window.location" are ----
        ////---- undefined, so we handle that here ----
        //---- the GOAL of this function: to return the "bpServer" name that belongs to this code.  This is easy ----
        //---- for dev machine (http://localhost/bpServer) but gets somewhat tricky when we are deployed ----
        //---- and the bpServer we want is something like:  http://vibe10/SandCastle/build3/bpServer.  ----
        //var serverPath = window.location.href;
        if (location.href.contains("azurewebsites")) {
            if (location.href.contains("2.azure")) {
                var path = location.protocol + "//beachPartyServer2.azurewebsites.net";
            }
            else {
                var path = location.protocol + "//beachPartyServer.azurewebsites.net";
            }
        }
        else {
            var path = pathHelper("bpServer");
        }
        return path;
    }
    beachParty.bpServerPath = bpServerPath;
    function sandDancePageServer() {
        if (location.href.contains("azurewebsites")) {
            if (location.href.contains("2.azure")) {
                var path = location.protocol + "//beachPartyServer2.azurewebsites.net";
            }
            else {
                var path = location.protocol + "//beachPartyServer.azurewebsites.net";
            }
        }
        else {
            //---- DOM workaround - location.origin not always supported ----
            var path = location.protocol + "//" + location.host;
        }
        return path;
    }
    beachParty.sandDancePageServer = sandDancePageServer;
    function bpServerNextPath() {
        ////---- on IE10, running under "localhost", sometimes all the props of "window.location" are ----
        ////---- undefined, so we handle that here ----
        //---- the GOAL of this function: to return the "bpServer" name that belongs to this code.  This is easy ----
        //---- for dev machine (http://localhost/bpServer) but gets somewhat tricky when we are deployed ----
        //---- and the bpServer we want is something like:  http://vibe10/SandCastle/build3/bpServer.  ----
        //var serverPath = window.location.href;
        if (location.href.contains("azurewebsites")) {
            //var path = location.protocol + "//beachPartyServer.azurewebsites.net";
            throw "SQL not supported on this version of SandDance";
        }
        else {
            var path = pathHelper("bpServerNext");
        }
        return path;
    }
    beachParty.bpServerNextPath = bpServerNextPath;
    function appPath() {
        ////---- on IE10, running under "localhost", sometimes all the props of "window.location" are ----
        ////---- undefined, so we handle that here ----
        //---- the GOAL of this function: to return the "bpServer" name that belongs to this code.  This is easy ----
        //---- for dev machine (http://localhost/BeachPartyApp) but gets somewhat tricky when we are deployed ----
        //---- and the bpServer we want is something like:  http://vibe10/BeachParty/buildXXX/BeachPartyApp.  ----
        if (this._appMgr && this._appMgr._beachPartyDir) {
            var path = this._appMgr._beachPartyDir;
        }
        else {
            var path = pathHelper("beachPartyApp");
        }
        return path;
    }
    beachParty.appPath = appPath;
    function getMyProtocol() {
        var protocol = (location.protocol) ? location.protocol : "http:";
        return protocol;
    }
    function bpDataPath() {
        //return pathHelper("VueBigData");
        var hostName = (window.location.hostname) ? window.location.hostname : "localhost";
        if (hostName.contains("azurewebsites")) {
            //---- HTTP / HTTPS ----
            var dataPath = getMyProtocol();
            if (location.href.contains("2.azure")) {
                dataPath += "//beachpartyserver2.azurewebsites.net/VueBigData";
            }
            else {
                dataPath += "//beachpartyserver.azurewebsites.net/VueBigData";
            }
        }
        else {
            //---- for non-azure, we assume that VueBigData wants http: ----
            dataPath = "http://" + hostName + "/VueBigData";
        }
        return dataPath;
    }
    beachParty.bpDataPath = bpDataPath;
    /// create a instance of the XMLHttpRequest object.
    function createXMLHttpRequest() {
        var req = null;
        if (XMLHttpRequest != null) {
            req = new XMLHttpRequest();
        }
        else {
            req = new ActiveXObject("Microsoft.XMLHTTP");
        }
        return req;
    }
    beachParty.createXMLHttpRequest = createXMLHttpRequest;
    /// convert a XmlHttp response to a json object.
    function getDataFromResult(xmlRequest, isJson, decodeNeeded) {
        //---- try not to use the "responseXML" since it is heavy weight ----
        var data = xmlRequest.response; // on my server, value is here
        if (!data) {
            data = xmlRequest.responseText; // on vibe10, value is here.  why?
        }
        if (data) {
            if (data.startsWith("<?xml")) {
                var index = data.indexOf(">");
                if (index > -1) {
                    var index2 = data.indexOf(">", index + 1);
                    if (index2 > -1) {
                        //---- remove the XML header ----
                        data = data.substr(index2 + 1);
                        //---- remove the xml trailer ----
                        if (data.endsWith("</string>")) {
                            data = data.substr(0, data.length - 9);
                        }
                    }
                }
            }
        }
        ////---- TOGROK: what is this needed? ----
        //if (decodeNeeded)
        //{
        //    data = decodeURIComponent(data);
        //    data = decodeURIComponent(data);
        //}
        if ((data) && (isJson)) {
            //vp.utils.debug("getDataFromResult: json.length=" + vp.formatters.comma(data.length));
            var data = JSON.parse(data);
            if ((data) && (data.d)) {
                data = data.d; // for json data
            }
        }
        return data;
    }
    beachParty.getDataFromResult = getDataFromResult;
    function startServerSort(keys, sortAsNumbers, callback) {
        var jsonData = JSON.stringify(keys);
        var safeJsonData = encodeURIComponent(jsonData); // protect ourselves from "=" and "&" chars in keys
        var body = "sortAsNumbers=" + sortAsNumbers + "&keys=" + safeJsonData;
        var url = bpServerPath() + "/putData.asmx/sortKeys";
        var safeUrl = encodeURI(url);
        fileAccess.httpPost(safeUrl, body, function (xmlhttp) {
            //---- SUCCESS ----
            var data = getDataFromResult(xmlhttp, true);
            callback(data);
        }, function (e) {
            //alert("writeFile64 failed");
        }, false);
    }
    beachParty.startServerSort = startServerSort;
    function logActionToServer(sessionId, gesture, elementId, elementType, action, target, options) {
        var url = bpServerPath() + "/putData.asmx/logAction";
        url += "?sessionId=" + sessionId +
            "&gesture=" + gesture +
            "&elementId=" + elementId +
            "&elementType=" + elementType +
            "&action=" + action +
            "&target=" + target;
        if (options) {
            var keys = vp.utils.keys(options);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = options[key];
                url += "&" + key + "=" + value;
            }
        }
        //action + " & actionSource = " + actionSource + " & p1 = " + p1 + " & p2 = " + p2 + " & p3 = " + p3;
        var safeUrl = encodeURI(url);
        beachParty.httpRead(safeUrl, false, function (xmlhttp) {
            //---- SUCCESS ----
        }, function (e) {
            //---- FAILURE ----
            //fileFail("logActionToServer", "", e);
        }, true);
    }
    beachParty.logActionToServer = logActionToServer;
    //---- TODO: move this into app ----
    //export function logActionToAzureInsights(sessionId: string, gesture: string, elementId: string, elementType: string,
    //    action: string, target: string, options?: any)
    //{
    //    var anyWindow = <any>window;
    //    var appInsightsObj = <Microsoft.ApplicationInsights.AppInsights>anyWindow.appInsights;
    //    if (appInsightsObj)
    //    {
    //        var props = <any>{};
    //        props.sessionId = sessionId;
    //        props.gesture = gesture;
    //        props.elementId = elementId;
    //        props.target = target;
    //        props.timeStamp = +Date.now();
    //        if (options)
    //        {
    //            var keys = vp.utils.keys(options);
    //            for (var i = 0; i < keys.length; i++)
    //            {
    //                var key = keys[i];
    //                var value = options[key];
    //                props[key] = value;
    //            }
    //        }
    //        appInsightsObj.trackEvent(action, props);
    //    }
    //}
    //export function logFeedbackToServer(type: string, feedback: string)
    //{
    //    var url = bpServerPath() + "/putData.asmx/logFeedback";
    //    //---- use "encodeURI" for the overall URL, if needed ----
    //    //---- use "encodeURIComponent" for the values of parameters, if needed ---
    //    url += "?type=" + type + "&feedback=" + encodeURIComponent(feedback);
    //    //---- only log if we are running on Azure, for now ----
    //    var usingAzure = (url.contains("azurewebsites"));
    //    if (true)       // usingAzure)
    //    {
    //        var anyWindow = <any>window;
    //        var appInsightsObj = <Microsoft.ApplicationInsights.AppInsights>anyWindow.appInsights;
    //        var props = <any>{};
    //        props.type = type;
    //        props.feedback = feedback;
    //        if (appInsightsObj)
    //        {
    //            appInsightsObj.trackEvent("feedback", props);
    //        }
    //    }
    //    //else
    //    //{
    //    //    beachParty.httpRead(url, false,
    //    //        function (xmlhttp)
    //    //        {
    //    //            //---- SUCCESS ----
    //    //            var dummy = 1;
    //    //        },
    //    //        function (e)
    //    //        {
    //    //            //---- FAILURE ----
    //    //            var dummy = 0;
    //    //            this.fileFail("logFeedbackToServer", "", e);
    //    //        }, true);
    //    //}
    //}
    function fileFail(callerName, url, e) {
        var dummy = 0;
        throw "Error in " + callerName + ", status=" + e.statusText + "\r\nurl=" + url + "\r\n" + e.responseText;
    }
    function renderWebPageToPng(pageUrl, width, height, msTimeout, callback) {
        var url = bpServerPath() + "/putData.asmx/renderWebPageToPng";
        //---- use "encodeURI" for the overall URL, if needed ----
        //---- use "encodeURIComponent" for the values of parameters, if needed ---
        //---- todo: also pass preload ----
        url += "?pageUrl=" + encodeURIComponent(pageUrl) + "&width=" + width + "&height=" + height + "&msTimeout=" + msTimeout;
        beachParty.httpRead(url, false, function (xmlhttp) {
            //---- SUCCESS ----
            var data = getDataFromResult(xmlhttp, false);
            callback(data);
        }, function (e) {
            //---- FAILURE ----
            fileFail("renderWebPageToPng", pageUrl, e);
        }, true);
    }
    beachParty.renderWebPageToPng = renderWebPageToPng;
    function writeSessionFile(userName, fileName, contents, callback) {
        var body = "userName=" + userName + "&fileName=" + fileName + "&contents=" + contents;
        var safeBody = encodeURIComponent(body);
        //var url = bpServerPath() + "/putData.asmx/writeSessionFile";
        var url = bpServerPath() + "/bpService.asmx/writeSessionFile";
        var safeUrl = encodeURI(url);
        fileAccess.httpPost(safeUrl, safeBody, function (xmlhttp) {
            //---- SUCCESS ----
            var data = getDataFromResult(xmlhttp, false);
            callback(data);
        }, function (e) {
            //---- FAILURE ----
            fileFail("writeSessionFile", fileName, e);
        }, true);
    }
    beachParty.writeSessionFile = writeSessionFile;
    function publishSessionToWebPage(userName, fileName, contents, callback) {
        var bpUrl = location.href;
        var index = bpUrl.indexOf("?");
        if (index > -1) {
            bpUrl = bpUrl.substr(0, index);
        }
        var body = "userName=" + userName + "&fileName=" + fileName + "&contents=" + contents + "&bpUrl=" + bpUrl;
        var safeBody = encodeURIComponent(body);
        //var url = bpServerPath() + "/putData.asmx/writeSessionFile";
        var url = bpServerPath() + "/bpService.asmx/publishSessionToWebPage";
        var safeUrl = encodeURI(url);
        fileAccess.httpPost(safeUrl, safeBody, function (xmlhttp) {
            //---- SUCCESS ----
            var url = getDataFromResult(xmlhttp, false);
            //var myServer = bpServerPath();
            var fullUrl = sandDancePageServer() + "/" + url;
            callback(fullUrl);
        }, function (e) {
            //---- FAILURE ----
            fileFail("publishSessionToWebPage", fileName, e);
        }, true);
    }
    beachParty.publishSessionToWebPage = publishSessionToWebPage;
    function readSessionFile(sessionUrl, callback) {
        //var url = bpServerPath() + "/putData.asmx/readSessionFile?sessionUrl=" + sessionUrl;
        var url = bpServerPath() + "/bpService.asmx/readSessionFile?sessionUrl=" + sessionUrl;
        //var safeUrl = encodeURI(url);
        var httpReadJson = false; // download to us as text
        var async = true;
        httpRead(url, false, function (xmlhttp) {
            //---- SUCCESS (get as raw string, not JSON) ----
            var text = getDataFromResult(xmlhttp, false);
            if (callback) {
                callback(text);
            }
        }, function (e) {
            //---- FAILURE ----
            //throw "readSessionFile: error=" + e.response;
            fileFail("readSessionFile", sessionUrl, e);
        }, async);
    }
    beachParty.readSessionFile = readSessionFile;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// preloadMgr.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - manages the list of preload items (each describes how to load a known file).
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// Note: dataFrame does NOT change the original data, but it cache numeric vectors on-demand for each column. 
    var preloadMgrClass = (function () {
        function preloadMgrClass() {
            this.buildPreloads();
        }
        preloadMgrClass.prototype.getPreloads = function () {
            return this._preloads;
        };
        preloadMgrClass.prototype.getFilePreload = function (name) {
            name = name.toLowerCase();
            var preload = null;
            for (var i = 0; i < this._preloads.length; i++) {
                var pl = this._preloads[i];
                //if (pl.name.toLowerCase() == name)
                if (pl.dataName && pl.dataName.toLowerCase() == name) {
                    preload = pl;
                    break;
                }
            }
            return preload;
        };
        preloadMgrClass.prototype.buildPreloads = function () {
            var preloads = [];
            this._preloads = preloads;
            //var isNextEdition = (this._appMgr._edition != "client");
            //---- DEMOVOTE ORIG ----
            var demoVoteOrig = new beachParty.Preload("DemoVoteOrig", "demovote.txt", "Esri Census data for US merged with 2012 Election results", "Longitude", "Latitude", "Scatter");
            demoVoteOrig.addedBy = "sdrucker";
            demoVoteOrig.dateAdded = new Date("01/01/2014");
            demoVoteOrig.recordCount = 24669;
            demoVoteOrig.fieldList.push(new beachParty.PreloadField("Longitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVoteOrig.fieldList.push(new beachParty.PreloadField("Latitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVoteOrig.mergeFieldList = true;
            demoVoteOrig.showInFileOpen = false; // test mode
            preloads.push(demoVoteOrig);
            //---- DEMOVOTE CLEAN (OK for us to publish) ----
            var demoVoteClearn = new beachParty.Preload("DemoVote", "demovoteclean.txt", "2014 US Census data merged with 2012 Election results", "Longitude", "Latitude", "Scatter");
            demoVoteClearn.addedBy = "sdrucker";
            demoVoteClearn.dateAdded = new Date("03/18/2016");
            demoVoteClearn.recordCount = 24669;
            demoVoteClearn.fieldList.push(new beachParty.PreloadField("Longitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVoteClearn.fieldList.push(new beachParty.PreloadField("Latitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVoteClearn.mergeFieldList = true;
            demoVoteClearn.description = "In the 'DemoVote' dataset, each record represents a US polling place (roughly corresponds to a county)";
            preloads.push(demoVoteClearn);
            //---- DEMOVOTE 5 ----
            var demoVote5 = new beachParty.Preload("DemoVote5", "demovote5.txt", "2014 US Census data merged with 2012 Election results", "Longitude", "Latitude", "Scatter");
            demoVote5.addedBy = "rfernand";
            demoVote5.dateAdded = new Date("9/13/2016");
            demoVote5.recordCount = 5;
            demoVote5.fieldList.push(new beachParty.PreloadField("Longitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVote5.fieldList.push(new beachParty.PreloadField("Latitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVote5.mergeFieldList = true;
            demoVote5.description = "In the 'DemoVote' dataset, each record represents a US polling place (roughly corresponds to a county)";
            demoVote5.showInFileOpen = false;
            preloads.push(demoVote5);
            //---- DEMOVOTE 25 ----
            var demoVote25 = new beachParty.Preload("DemoVote25", "demovote25.txt", "2014 US Census data merged with 2012 Election results", "Longitude", "Latitude", "Scatter");
            demoVote25.addedBy = "rfernand";
            demoVote25.dateAdded = new Date("9/13/2016");
            demoVote25.recordCount = 25;
            demoVote25.fieldList.push(new beachParty.PreloadField("Longitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVote25.fieldList.push(new beachParty.PreloadField("Latitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVote25.mergeFieldList = true;
            demoVote25.description = "In the 'DemoVote' dataset, each record represents a US polling place (roughly corresponds to a county)";
            demoVote25.showInFileOpen = false;
            preloads.push(demoVote25);
            if (true) {
                //---- TrainInst ----
                var trainInst = new beachParty.Preload("TrainInst", "MLVis\\Train.inst.txt", "ML training data");
                trainInst.addedBy = "rfernand (via t-bijia)";
                trainInst.dateAdded = new Date("07/20/2015");
                trainInst.recordCount = 100000;
                trainInst.showInFileOpen = false;
                preloads.push(trainInst);
                //---- Million Rows ----
                var millionRows = new beachParty.Preload("MillionRows", "millionRowsTwoCols.csv", "BeachParty test data");
                millionRows.addedBy = "rfernand (via t-bijia)";
                millionRows.dateAdded = new Date("11/02/2015");
                millionRows.recordCount = 1000000;
                millionRows.showInFileOpen = false;
                preloads.push(millionRows);
                //---- Half Million Rows ----
                var halfMillionRows = new beachParty.Preload("HalfMillionRows", "halfMillionRows.csv", "BeachParty test data");
                halfMillionRows.addedBy = "rfernand";
                halfMillionRows.dateAdded = new Date("1/15/2016");
                halfMillionRows.recordCount = 500000;
                halfMillionRows.showInFileOpen = false;
                preloads.push(halfMillionRows);
            }
            //---- COLLEGES ----
            var colleges = new beachParty.Preload("Colleges", "Colleges.txt", "Data about colleges");
            colleges.addedBy = "sdrucker";
            colleges.dateAdded = new Date("02/01/2016");
            colleges.recordCount = 7804;
            colleges.description = "In the 'Colleges' dataset, each record represents a college and includes attributes like SAT scores and tuition";
            preloads.push(colleges);
            //---- TITANIC ----
            var useNew = true;
            if (useNew) {
                var titanic = new beachParty.Preload("Titanic", "TitanicMaster.txt", "Titanic Passenger Data");
                titanic.colMappings.x.colName = "Age";
                titanic.colMappings.y.colName = "TicketCost";
            }
            else {
                var titanic = new beachParty.Preload("Titanic", "TitanicRevised.txt", "Titanic Passenger Data", "Fare", "Age", "Scatter");
                titanic.addField("CabinClass", "The class of the passenger's ticket", null, null, ["first", "second", "third"]);
                titanic.addField("Survived", "Whether or not the passenger survived", null, null, ["TRUE", "FALSE"]);
                titanic.addField("Name", "The name of the passenger");
                titanic.addField("Gender", "Whether the passenger was a male or a female", null, null, ["male", "female"]);
                titanic.addField("Age", "The age of the passenger at the time of the voyage");
                titanic.addField("TicketNumber", "The ticket number of the passenger");
                titanic.addField("Fare", "How much the passenger paid for his ticket (in US dollars)", null, "number");
                titanic.addField("Embarked", "The city in which the passenger boarded the Titanic");
            }
            titanic.addedBy = "sdrucker";
            titanic.dateAdded = new Date("10/15/2015");
            titanic.recordCount = 2207;
            titanic.description = "In the 'Titanic' dataset, each record represents a passenger on the Titanic's first (and only) voyage";
            preloads.push(titanic);
            //---- TITANIC 5 ----
            var titanic5 = new beachParty.Preload("Titanic5", "Titanic5.txt", "Titanic Passenger Data");
            titanic5.colMappings.x.colName = "Age";
            titanic5.colMappings.y.colName = "TicketCost";
            titanic5.addedBy = "rfernand";
            titanic5.dateAdded = new Date("9/13/2016");
            titanic5.recordCount = 5;
            titanic5.description = "In the 'Titanic' dataset, each record represents a passenger on the Titanic's first (and only) voyage";
            titanic5.showInFileOpen = false;
            preloads.push(titanic5);
            //---- TITANIC 25 ----
            var titanic25 = new beachParty.Preload("Titanic25", "Titanic25.txt", "Titanic Passenger Data");
            titanic25.colMappings.x.colName = "Age";
            titanic25.colMappings.y.colName = "TicketCost";
            titanic25.addedBy = "rfernand";
            titanic25.dateAdded = new Date("9/13/2016");
            titanic25.recordCount = 25;
            titanic25.description = "In the 'Titanic' dataset, each record represents a passenger on the Titanic's first (and only) voyage";
            titanic25.showInFileOpen = false;
            preloads.push(titanic25);
            //---- SALES ----
            var bigSales = new beachParty.Preload("Sales", "bigSalesData.csv", "Generated Sales Data", "Profit", "Sales", "Scatter");
            bigSales.hasTimeData = true;
            bigSales.recordCount = 8399;
            bigSales.description = "In the 'Sales' dataset, each record represents a sale, including customer, product, order, and shipping information";
            preloads.push(bigSales);
            //---- BABY NAMES ----
            var babyNames = new beachParty.Preload("BabyNames", "TopBabyNamesbyState.csv", "Top baby names, by state and year");
            babyNames.hasTimeData = true;
            babyNames.recordCount = 10506;
            babyNames.description = "In the 'BabyNames' dataset, each record represents the top name for each state in a given year";
            preloads.push(babyNames);
            //---- COFFEE SALES ----
            var coffeeSales = new beachParty.Preload("CoffeeSales", "CoffeeSales.txt", "Coffee sales data");
            coffeeSales.hasTimeData = true;
            coffeeSales.recordCount = 4248;
            coffeeSales.description = "In the 'CoffeeSales' dataset, each record represents sales aggregated by market, product type, and other attributes";
            preloads.push(coffeeSales);
            if (true) {
                //---- MGX SMALL ----
                var mgxSmall = new beachParty.Preload("MgxSmall", "mgxSmall.txt", "Microsoft Sales Data");
                mgxSmall.hasTimeData = true;
                mgxSmall.recordCount = 25634;
                mgxSmall.showInFileOpen = false;
                preloads.push(mgxSmall);
                //---- ATHENS CA ----
                var athensCa = new beachParty.Preload("AthensCa", "Athens\\ca_microsoft_analytic.3.txt", "Political Data for California");
                athensCa.hasTimeData = true;
                athensCa.recordCount = 4000000;
                athensCa.showInFileOpen = false;
                preloads.push(athensCa);
                ////---- STATES ----
                //var states = new Preload("States", "CensusData/StateSummary.csv", "US Census data on States (2012)");
                //states.addField("Name", "The state's name");
                //states.addField("Population", "The population of the state in 2012", "CENSUS2010POP");
                //states.addField("Change", "The change in population of the state, since the previous year", "NPOPCHG_2012");
                //states.addField("Births", "The number of births in the state for 2012", "BIRTHS2012");
                //states.addField("Deaths", "The number of deaths in the state for 2012", "DEATHS2012");
                //states.colMappings = new ColMappings("Population", "Longitude", null);
                //states.chartName = "Column";
                //states.prefilter = "Name == 'United States' || Name == 'Alaska' || Name == 'Puerto Rico' || Name == 'Hawaii' || " +
                //"Name.endsWith('Region')";
                //states.recordCount = 50;
                //preloads.push(states);
                ////---- FULLSTATES ----
                //var ttFields = ["Name", "CENSUS2010POP", "NPOPCHG_2012", "BIRTHS2012", "DEATHS2012"];
                //var fullStates = new Preload("FullStates", "CensusData/StateSummary.csv", "US Census data on States (2012)", null,
                //    "Population", "Longitude", null, "Column");
                //fullStates.tooltipFieldList = ttFields;
                //fullStates.recordCount = 57;
                //preloads.push(fullStates);
                //---- RAINFALL ----
                var rainFall = new beachParty.Preload("RainFall", "US-Rainfall.csv", "US Rainfall data");
                rainFall.hasTimeData = true;
                rainFall.addedBy = "dabrown";
                rainFall.dateAdded = new Date("04/02/2014");
                rainFall.recordCount = 240000; // FIX THIS
                rainFall.showInFileOpen = false;
                preloads.push(rainFall);
            }
            //---- MPG ----
            var mpg = new beachParty.Preload("MPG", "MPG.csv", "Car data, including miles/gallon", "cyl", "displ", "class", "Scatter");
            mpg.hasTimeData = true;
            mpg.recordCount = 234;
            mpg.description = "In the MPG dataset, each record represents miles/gallon data on a particular car type";
            preloads.push(mpg);
            if (true) {
                //---- McDonalds ----
                var macDs = new beachParty.Preload("McDonalds", "macD.csv", "Location of all US McDonald's restaurants");
                macDs.recordCount = 43166;
                macDs.showInFileOpen = false;
                preloads.push(macDs);
                //---- PITCHES ----
                var pitches = new beachParty.Preload("Pitches", "baseball-pitches.csv", "Data on baseball pitches", "x", "y", "Scatter");
                pitches.hasTimeData = true;
                pitches.addedBy = "sdrucker";
                pitches.dateAdded = new Date("12/10/2014");
                pitches.recordCount = 134588;
                pitches.showInFileOpen = false;
                preloads.push(pitches);
                //---- IBM ----
                var ibm = new beachParty.Preload("IBM", "stockQuotes/ibm.csv", "IBM Stock Quotes", "Date", "Close", "Scatter");
                ibm.hasTimeData = true;
                ibm.recordCount = 13194;
                ibm.showInFileOpen = false;
                preloads.push(ibm);
                //---- MSFT ----
                var msft = new beachParty.Preload("MSFT", "stockQuotes/msft.csv", "Microsoft Stock Quotes", "Date", "Close", "Scatter");
                msft.hasTimeData = true;
                msft.recordCount = 7115;
                msft.showInFileOpen = false;
                preloads.push(msft);
                //---- APPL ----
                var appl = new beachParty.Preload("APPL", "stockQuotes/appl.csv", "Apple Stock Quotes", "Date", "Close", "Scatter");
                appl.hasTimeData = true;
                appl.recordCount = 8440;
                appl.showInFileOpen = false;
                preloads.push(appl);
                //---- AMZN ----
                var amzn = new beachParty.Preload("AMZN", "stockQuotes/amzn.csv", "Amazon Stock Quotes", "Date", "Close", "Scatter");
                amzn.hasTimeData = true;
                amzn.recordCount = 4288;
                amzn.showInFileOpen = false;
                preloads.push(amzn);
                //---- FACEBOOK ----
                var facebook = new beachParty.Preload("FaceBook", "stockQuotes/fb.csv", "Facebook Stock Quotes", "Date", "Close", "Scatter");
                facebook.hasTimeData = true;
                facebook.recordCount = 511;
                facebook.showInFileOpen = false;
                preloads.push(facebook);
                //---- GOOGLE ----
                var google = new beachParty.Preload("Google", "stockQuotes/googl.csv", "Google Stock Quotes", "Date", "Close", "Scatter");
                google.hasTimeData = true;
                google.recordCount = 2463;
                google.showInFileOpen = false;
                preloads.push(google);
                //---- NETWORK (from Irina) ----
                var network = new beachParty.Preload("Network", "irina/network.csv", "Verizon Data");
                network.hasTimeData = true;
                network.recordCount = 3823;
                network.showInFileOpen = false;
                network.addedBy = "irinasp";
                preloads.push(network);
                //---- SALERIES (from Irina) ----
                var salaries = new beachParty.Preload("Salaries", "irina/salaries.csv", "Salary Data");
                salaries.hasTimeData = true;
                salaries.recordCount = 148654;
                salaries.showInFileOpen = false;
                salaries.addedBy = "irinasp";
                preloads.push(salaries);
                //---- SALERIES20 (from Irina) ----
                var salaries20 = new beachParty.Preload("Salaries20", "irina/salaries20.csv", "Salary Data");
                salaries20.hasTimeData = true;
                salaries20.recordCount = 20019;
                salaries20.showInFileOpen = false;
                salaries20.addedBy = "irinasp";
                preloads.push(salaries20);
                //---- SERVICE AREA (from Irina) ----
                var serviceArea = new beachParty.Preload("ServiceArea", "irina/serviceArea.csv", "Service Data");
                serviceArea.hasTimeData = true;
                serviceArea.recordCount = 42248;
                serviceArea.showInFileOpen = false;
                serviceArea.addedBy = "irinasp";
                preloads.push(serviceArea);
                //---- ADULT CENSUS ----
                var uciAdults = new beachParty.Preload("Adult Census", "http://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data", "Adult Census Data (from UCI repository)", "Col3", "Col4");
                uciAdults.addField("Age", "The age of the person", "Col1", "number");
                uciAdults.addField("WorkClass", "The type of employment that person has", "Col2");
                uciAdults.addField("Fnlwgt", "The census taker's estimate of household population", "Col3", "number");
                uciAdults.addField("Education", "The highest educational category acheived by the person", "Col4");
                uciAdults.addField("EdNum", "The numeric highest educational level acheived by the person", "Col5", "number");
                uciAdults.addField("Marital", "The marital status of the person", "Col6");
                uciAdults.addField("Occupation", "The occupation of the person", "Col7");
                uciAdults.addField("Relationship", "The primary family role of the person", "Col8");
                uciAdults.addField("Race", "The race of the person", "Col9");
                uciAdults.addField("Sex", "The biological sex of the person", "Col10");
                uciAdults.addField("CapitalGain", "Capital gains recorded", "Col11", "number");
                uciAdults.addField("CapitalLoss", "Capital losses recorded", "Col12", "number");
                uciAdults.addField("HoursPerWeek", "The number of hours worked per week by the person", "Col13", "number");
                uciAdults.addField("NativeCountry", "The country where the person was born", "Col14");
                uciAdults.addField("Income", "The income level for the person", "Col15");
                uciAdults.separator = ",";
                uciAdults.hasHeader = false;
                uciAdults.recordCount = 32562;
                uciAdults.showInFileOpen = false;
                preloads.push(uciAdults);
                //---- SQL server test ----
                var sqlServer = new beachParty.Preload("Headtrax (SQL 200K)", "Server=localhost;Database=Headtrax;User ID=vibedemo;Password=vibedemo;Trusted_Connection=False;", "Microsoft Headtrax employee/hire data");
                sqlServer.fileType = beachParty.FileType.sql;
                //sqlServer.tableName = "EmployeeData";
                sqlServer.queryString = "select * from EmployeeData where EmailName is not null";
                sqlServer.dataSampling = new beachParty.DataSampling(true, beachParty.SampleType.first, 25 * 1000, 25 * 1000);
                sqlServer.recordCount = 221353; // FIX THIS
                sqlServer.showInFileOpen = false;
                preloads.push(sqlServer);
                //---- KNOWN DATA (our "preloads" table)  ----
                var knownData = new beachParty.Preload("KnownData", "knownData.json", "The datasets that we know how to open");
                knownData.colMappings = new beachParty.ColMappings("dateAdded", "hasTimeData", null);
                knownData.hasTimeData = true;
                knownData.showInFileOpen = false;
                preloads.push(knownData);
            }
            //---- this must be last ----
            knownData.recordCount = preloads.length;
            //---- set file "fileSource" for all our preloads to "known" ----
            for (var i = 0; i < preloads.length; i++) {
                preloads[i].fileSource = "known";
            }
        };
        return preloadMgrClass;
    }());
    beachParty.preloadMgrClass = preloadMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    vector.ts - helper functions for working with vectors (of dataFrame).
//      - the vector can be a Float32Array or a number[].
//-------------------------------------------------------------------------------------
var vector;
(function (vector_1) {
    /** return the number of entries that are true (or == 1). */
    function countOn(vector) {
        var count = 0;
        if (vector) {
            for (var i = 0; i < vector.length; i++) {
                if (vector[i]) {
                    count++;
                }
            }
        }
        return count;
    }
    vector_1.countOn = countOn;
    /** return the number of entries that are false (or == 0). */
    function countOff(vector) {
        var count = 0;
        if (vector) {
            for (var i = 0; i < vector.length; i++) {
                if (!vector[i]) {
                    count++;
                }
            }
        }
        return count;
    }
    vector_1.countOff = countOff;
    /** set each entry to 0. */
    function clear(vector) {
        if (vector) {
            for (var i = 0; i < vector.length; i++) {
                vector[i] = 0;
            }
        }
    }
    vector_1.clear = clear;
    /** copy contents of source to dest. */
    function copy(dest, source) {
        for (var i = 0; i < dest.length; i++) {
            dest[i] = source[i];
        }
    }
    vector_1.copy = copy;
    /** compare contents of vector to vector2. */
    function compare(vector, vector2) {
        var isDiff = (vector.length != vector2.length);
        if (!isDiff) {
            for (var i = 0; i < vector.length; i++) {
                if (vector[i] != vector2[i]) {
                    isDiff = true;
                    break;
                }
            }
        }
        return isDiff;
    }
    vector_1.compare = compare;
})(vector || (vector = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    wdCompare.ts - compares 2 sets of wdParams.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var wdCompare = (function () {
        function wdCompare() {
        }
        wdCompare.valueEntriesMatch = function (entry1, entry2) {
            var match = true;
            if ((!entry1) || (!entry2)) {
                match = (entry1 == entry2);
            }
            else if (entry1.originalValue != entry2.originalValue) {
                match = false;
            }
            else if (entry1.newValue != entry2.newValue) {
                match = false;
            }
            return match;
        };
        wdCompare.valueMapsMatch = function (map1, map2) {
            var match = true;
            if ((!map1) || (!map2)) {
                match = (map1 == map2);
            }
            else {
                if (map1.length != map2.length) {
                    match = false;
                }
                else {
                    //---- check each entry ----
                    for (var i = 0; i < map1.length; i++) {
                        var f1 = map1[i];
                        var f2 = map2[i];
                        if (!this.valueEntriesMatch(f1, f2)) {
                            match = false;
                            break;
                        }
                    }
                }
            }
            return match;
        };
        wdCompare.fieldsMatch = function (f1, f2) {
            var match = true;
            if ((!f1) || (!f2)) {
                match = (f1 == f2);
            }
            else if (f1.name != f2.name) {
                match = false;
            }
            else if (f1.calcFieldExp != f2.calcFieldExp) {
                match = false;
            }
            else if (f1.description != f2.description) {
                match = false;
            }
            else if (f1.fieldType != f2.fieldType) {
                match = false;
            }
            else if (!vp.arrayEquals(f1.sortedValues, f2.sortedValues)) {
                match = false;
            }
            else if (!this.valueMapsMatch(f1.valueMap, f2.valueMap)) {
                match = false;
            }
            return match;
        };
        wdCompare.fieldListsMatch = function (list1, list2) {
            var match = true;
            if ((!list1) || (!list2)) {
                match = (list1 == list2);
            }
            else {
                if (list1.length != list2.length) {
                    match = false;
                }
                else {
                    //---- check each field ----
                    for (var i = 0; i < list1.length; i++) {
                        var f1 = list1[i];
                        var f2 = list2[i];
                        if (!this.fieldsMatch(f1, f2)) {
                            match = false;
                            break;
                        }
                    }
                }
            }
            return match;
        };
        return wdCompare;
    }());
    beachParty.wdCompare = wdCompare;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    baseLegend.ts - base class for BeachParty interactive legends.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var baseLegendClass = (function (_super) {
        __extends(baseLegendClass, _super);
        function baseLegendClass(chartRouter, legendName, rootName, titleElemName) {
            var _this = this;
            _super.call(this);
            //---- legend sizes ----
            this._maxPaletteHeight = 400;
            this._entryHeight = 0; // dynamically set to match font
            this._entryWidth = 20;
            this._labelVertOffset = 0;
            //---- hard events ----
            this.onSearchRequest = new beachParty.bpEvent();
            this.onPanelRequest = new beachParty.bpEvent();
            this._chartRouter = chartRouter;
            this._legendName = legendName;
            this._md = null;
            var root = vp.select("#" + rootName)
                .addClass("legend")
                .css("position", "relative")
                .css("left", "5px");
            //.css("border", "1px solid red")
            //---- add colName as TITLE ----
            var title = root.append("div")
                .addClass("textButton legendTitle")
                .id(titleElemName)
                .css("position", "relative")
                .css("top", "10px")
                .css("left", "-8px")
                .attach("click", function (e) {
                _this.onPanelRequest.trigger({ e: e });
            });
            //---- create a parent for the table, so we can position the continuous palette using it ----
            var holderParentW = root.append("div")
                .css("position", "relative")
                .css("overflow-y", "auto")
                .css("overflow-x", "hidden")
                .css("max-height", "400px")
                .css("padding-top", "10px"); // so that we don't cut off top label
            this._holderParent = holderParentW[0];
            var legendTableW = holderParentW.append("table")
                .addClass("legendHolder")
                .attr("cell-spacing", "0")
                .attr("cell-padding", "0");
            this._root = root[0];
            this._titleElem = title[0];
            this._legendTable = legendTableW[0];
        }
        baseLegendClass.prototype.doSearch = function (legendName, colName, fromValue, toValue, searchType, selectMode, selectKey) {
            this.onSearchRequest.trigger({
                legendName: legendName, colName: colName, fromValue: fromValue, toValue: toValue, searchType: searchType, selectMode: selectMode, selectKey: selectKey
            });
        };
        baseLegendClass.prototype.getColInfo = function (colName) {
            var chart = this._chartRouter.getChart();
            var dataFrame = chart.getDataFrame();
            var ci = dataFrame.getColInfo(colName);
            return ci;
        };
        baseLegendClass.prototype.show = function (value) {
            vp.select(this._root)
                .css("display", (value) ? "" : "none");
        };
        baseLegendClass.prototype.measureTextAndSetItemHeight = function () {
            //---- measure font & set _entryHeight accordingly ----
            var tempW = vp.select(document.body).append("div")
                .addClass("legendLabel")
                .css("position", "absolute")
                .css("opacity", "0")
                .text("wWgtyTZ"); // some text to measure with
            var rc = tempW.getBounds(null);
            tempW.remove();
            var entryHeight = Math.ceil(6 + rc.height);
            this._entryHeight = entryHeight;
        };
        baseLegendClass.prototype.buildLabelFormatter = function () {
            var md = this._md;
            var formatter = null;
            if (md && md.breaks) {
                var colInfo = this.getColInfo(md.colName);
                var colType = colInfo.colType;
                var minValue = md.breaks[0];
                var maxValue = md.breaks[md.breaks.length - 1];
                if (colType == "number") {
                    //TODO: write and use createNumFormatterFromrange() 
                    formatter = vp.formatters.createNumFormatterFromRange(minValue, maxValue, md.breaks.length);
                }
                else if (colType == "date") {
                    formatter = vp.formatters.createDateFormatterFromRange(minValue, maxValue, md.breaks.length);
                }
                else {
                    formatter = null;
                }
            }
            this._formatter = formatter;
        };
        baseLegendClass.prototype.formatLabel = function (value) {
            var text = value;
            if (this._formatter) {
                text = this._formatter(text);
            }
            if (text == "") {
                var chart = this._chartRouter.getChart();
                text = chart.blankValueStr();
            }
            return text;
        };
        baseLegendClass.prototype.rebuildLegendEx = function (md, breakCount, isNumeric) {
            if (md.isLegendBottomUp) {
                this.rebuildFromBottom(md, breakCount, isNumeric);
            }
            else {
                this.rebuildFromTop(md, breakCount, isNumeric);
            }
        };
        baseLegendClass.prototype.rebuildFromTop = function (md, breakCount, isNumeric) {
            this._md = md;
            //---- adjust bottom margin of title ----
            var entryHeight = this._entryHeight;
            var marg = .5 * entryHeight; // (isNumeric) ? (.35 * entryHeight) : (.3 * entryHeight);
            vp.select(this._titleElem).css("margin-bottom", marg + "px");
            var tableW = vp.select(this._legendTable)
                .clear();
            var lastIndex = (isNumeric) ? (breakCount - 1) : (breakCount - 1);
            this.buildLabelFormatter();
            //---- need to process in ascending value order so that each item can refer to its previous item ---
            //---- and build the click/selection information correctly.  We currently draw first label at top of legend ----
            for (var i = 0; i <= lastIndex; i++) {
                var rowW = tableW.append("tr");
                var isTop = (i == 0);
                var isBottom = (i == lastIndex - 1);
                var addPaletteTick = (i < lastIndex);
                var paletteIndex = i;
                //---- add the TD's ----
                var paletteW = rowW.append("td")
                    .css("padding", "0");
                var tickW = rowW.append("td").css("padding", "0");
                var labelW = rowW.append("td").css("padding", "0");
                if (isNumeric) {
                    //---- NUMERIC AXIS ----
                    if (addPaletteTick) {
                        this.fillPaletteEntry(paletteW, paletteIndex, isTop);
                        this.fillTickEntry(tickW, isBottom);
                    }
                    var yOffset = (isNumeric && i == 0) ? +1 : 0;
                    this.fillLabelEntry(labelW, i, yOffset);
                }
                else {
                    //---- CATEGORY AXIS ----
                    this.fillPaletteEntry(paletteW, i, isTop);
                    this.fillTickEntry(tickW, isBottom);
                    this.fillLabelEntry(labelW, i, 0);
                }
            }
        };
        baseLegendClass.prototype.rebuildFromBottom = function (md, breakCount, isNumeric) {
            this._md = md;
            //---- adjust bottom margin of title ----
            var entryHeight = this._entryHeight;
            var marg = .5 * entryHeight; // (isNumeric) ? (.35 * entryHeight) : (.3 * entryHeight);
            vp.select(this._titleElem).css("margin-bottom", marg + "px");
            var tableW = vp.select(this._legendTable)
                .clear();
            var lastIndex = (isNumeric) ? (breakCount - 1) : (breakCount - 1);
            this.buildLabelFormatter();
            //---- need to process in ascending value order so that each item can refer to its previous item ---
            //---- and build the click/selection information correctly.  We currently draw first label at top of legend ----
            for (var i = 0; i <= lastIndex; i++) {
                var rowW = tableW.prepend("tr");
                var isTop = (i == lastIndex);
                var isBottom = (i == 1);
                var addPaletteTick = (i > 0);
                var paletteIndex = i - 1;
                //---- add the TD's ----
                var paletteW = rowW.append("td")
                    .css("padding", "0");
                var tickW = rowW.append("td").css("padding", "0");
                var labelW = rowW.append("td").css("padding", "0");
                if (isNumeric) {
                    //---- NUMERIC AXIS ----
                    if (addPaletteTick) {
                        this.fillPaletteEntry(paletteW, paletteIndex, isTop);
                        this.fillTickEntry(tickW, isBottom);
                    }
                    var yOffset = (isNumeric && i == 0) ? +1 : 0;
                    this.fillLabelEntry(labelW, i, yOffset);
                }
                else {
                    //---- CATEGORY AXIS ----
                    this.fillPaletteEntry(paletteW, i, isTop);
                    this.fillTickEntry(tickW, isBottom);
                    this.fillLabelEntry(labelW, i, 0);
                }
            }
        };
        baseLegendClass.prototype.selectBox = function (index) {
            var elems = this._paletteElements;
            if (elems && elems.length) {
                if (index < 0) {
                    index += elems.length;
                }
                else {
                    //---- true elements start at index=1 ----
                    index++;
                }
                var elem = elems[index];
                var e = { target: elem };
                this.searchForEntryValues(e);
            }
        };
        baseLegendClass.prototype.search = function (colName, value) {
            var chart = this._chartRouter.getChart();
            chart.search(colName, value);
        };
        baseLegendClass.prototype.searchForEntryValues = function (e) {
            var elem = e.target;
            if (elem.colorIndex !== undefined) {
                //---- get text element from this PALETTE entry ----
                elem = this._textElems[elem.colorIndex];
            }
            var legendName = this._legendName;
            var key = legendName + "." + elem.axisKey; // "color." + elem.innerText;
            this.doSearch(legendName, elem.colName, elem.fromValue, elem.toValue, elem.searchType, undefined, key);
        };
        baseLegendClass.prototype.fillPaletteEntry = function (paletteW, i, isTop) {
        };
        baseLegendClass.prototype.fillTickEntry = function (parentW, addBottom) {
            var tickW = parentW.append("div")
                .addClass("legendTick")
                .css("height", (this._entryHeight - 2) + "px");
            if (addBottom) {
                tickW.css("border-bottom", "1px solid #777");
            }
        };
        baseLegendClass.prototype.fillLabelEntry = function (labelW, i, yOffset) {
        };
        return baseLegendClass;
    }(beachParty.dataChangerClass));
    beachParty.baseLegendClass = baseLegendClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    colorLegend.ts - draws an interactive, continuous/discreet color legend (color palette, ticks, labels).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var colorLegendClass = (function (_super) {
        __extends(colorLegendClass, _super);
        function colorLegendClass(chartRouter, rootName) {
            _super.call(this, chartRouter, "color", rootName, "colorLegendTitle");
            this._lastValue = null;
            this.rebuildLegend();
        }
        colorLegendClass.prototype.colorMapping = function (value) {
            if (arguments.length === 0) {
                return this._cm;
            }
            this._cm = value;
            this.onDataChanged("colorMapping");
            this.rebuildLegend();
        };
        colorLegendClass.prototype.rebuildLegend = function () {
            var cm = this._cm;
            var showLegend = (cm != null && cm.colorPalette != null && cm.colName != null && cm.colName != "");
            //---- show/hide legend ----
            this.show(showLegend);
            if (showLegend) {
                this.measureTextAndSetItemHeight();
                var name = cm.colName;
                vp.select(this._titleElem)
                    .text(name);
                if (this._continuousPalette) {
                    vp.select(this._continuousPalette).remove();
                    this._continuousPalette = null;
                }
                var colorPalette = cm.colorPalette;
                var breaks = cm.breaks;
                var count = colorPalette.length;
                if (breaks && breaks.length < count) {
                    count = breaks.length;
                }
                var colInfo = this.getColInfo(cm.colName);
                var colType = colInfo.colType;
                this._colType = colType;
                this._isNumeric = (colInfo.colType != "string"); // number or date
                this._lastValue = null;
                this._textElems = [];
                this._paletteElements = [];
                this.rebuildLegendEx(cm, breaks.length, this._isNumeric);
            }
        };
        colorLegendClass.prototype.buildContinuousPaletteDiv = function (tdW) {
            var cm = this._cm;
            var colorPalette = cm.colorPalette;
            var count = colorPalette.length;
            //---- as a workaround to appending it to the TD of first row (with rowSpan=999), which produces weird layout issues ----
            //---- we just plop it down as child of holderParent, using absolute positioning. ----
            var holderParentW = vp.select(this._holderParent);
            var paletteW = holderParentW.prepend("div")
                .addClass("continuousColorPalette")
                .css("position", "absolute")
                .css("left", "1px") // place within border
                .css("top", "10px"); // align with labels correctly
            var lg = "linear-gradient(";
            //---- go thru backwards, since we want the LIGHT colors at the top (and client palettes start with DARK) ----
            //for (var i = count - 1; i >= 0; i--)
            for (var i = 0; i < count; i++) {
                if (i != 0) {
                    lg += ",";
                }
                var cr = vp.color.colorFromPalette(colorPalette, i);
                lg += cr;
            }
            lg += ")";
            var paletteHeight = Math.min(this._maxPaletteHeight, this._entryHeight * count);
            //entryHeight = paletteHeight / count;
            //---- CONTINUOUS ----
            paletteW
                .css("background", lg)
                .css("height", paletteHeight + "px")
                .css("width", this._entryWidth + "px")
                .css("pointer-events", "none");
            //.addClass("colorPaletteEntry")
            return paletteW[0];
        };
        colorLegendClass.prototype.fillPaletteEntry = function (parentW, i, isTop) {
            var _this = this;
            var cm = this._cm;
            var colorPalette = cm.colorPalette;
            var breaks = cm.breaks;
            var cr = vp.color.colorFromPalette(colorPalette, i, 0, cm.isCycling);
            var text = (breaks) ? breaks[i] : "";
            if (cm.isContinuous) {
                //---- we will overlay this, so don't draw a color ----
                cr = "transparent";
            }
            //---- this will overlay the regular palette, but it will still be used for hit-testing ----
            if (isTop && cm.isContinuous) {
                this._continuousPalette = this.buildContinuousPaletteDiv(parentW);
                this._paletteElements[i] = this._continuousPalette;
            }
            var colorEntryW = parentW.append("div")
                .css("background-color", cr)
                .addClass("colorPaletteEntry")
                .css("width", this._entryWidth + "px")
                .css("height", (this._entryHeight - 2) + "px") // allow for mouseover, mousedown border without movement
                .customAttr("value", text)
                .attach("click", function (e) { return _this.searchForEntryValues(e); });
            colorEntryW[0].colorIndex = (this._isNumeric) ? (i + 1) : i;
            this._paletteElements[i] = colorEntryW[0];
        };
        colorLegendClass.prototype.fillLabelEntry = function (parentW, i, yOffset) {
            var _this = this;
            var cm = this._cm;
            var breaks = cm.breaks;
            var value = (breaks) ? breaks[i] : "";
            var text = this.formatLabel(value);
            var tooltip = (text == "Other") ? "All other values mapped here" : text;
            var labelW = parentW.append("div")
                .text(text)
                .addClass("clipText legendLabel")
                .title(tooltip)
                .attach("click", function (e) { return _this.searchForEntryValues(e); });
            if (this._isNumeric) {
                parentW
                    .css("position", "relative");
                //---- shift labels up and to the right ----
                labelW
                    .css("position", "relative")
                    .css("left", "8px")
                    .css("top", (yOffset - this._entryHeight / 2) + "px");
            }
            //---- add information to support click/select ----
            labelW[0].colName = cm.colName;
            labelW[0].axisKey = "box" + i;
            if (value == "Other") {
                labelW[0].fromValue = this._lastValue;
                labelW[0].toValue = this._lastValue;
                labelW[0].searchType = beachParty.TextSearchType.greaterThanEqual;
            }
            else if (this._isNumeric) {
                labelW[0].fromValue = (i == 0) ? value : this._lastValue;
                labelW[0].toValue = value;
                labelW[0].searchType = beachParty.TextSearchType.betweenInclusive;
            }
            else {
                labelW[0].fromValue = value;
                labelW[0].toValue = value;
                labelW[0].searchType = beachParty.TextSearchType.exactMatch;
            }
            var colorIndex = i; // (count - 1) - i;
            this._textElems[colorIndex] = labelW[0];
            this._lastValue = value;
        };
        return colorLegendClass;
    }(beachParty.baseLegendClass));
    beachParty.colorLegendClass = colorLegendClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    facetLegend.ts - draws an interactive, continuous/discreet color legend (color palette, ticks, labels).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var facetLegendClass = (function (_super) {
        __extends(facetLegendClass, _super);
        function facetLegendClass(rootName, cm) {
            var _this = this;
            _super.call(this);
            this._fm = cm;
            var root = vp.select("#" + rootName);
            //---- add colName as TITLE ----
            var title = root.append("span")
                .addClass("legendTitle textButton")
                .id("facetLegendTitle")
                .text(cm.colName)
                .attach("click", function (e) {
                _this.onDataChanged("facetColPickerRequest");
            });
            this._rootElem = root[0];
            this._titleElem = title[0];
            this.updateLegend();
        }
        facetLegendClass.prototype.facetMapping = function (value) {
            if (arguments.length === 0) {
                return this._fm;
            }
            this._fm = value;
            this.onDataChanged("facetMapping");
            this.updateLegend();
        };
        facetLegendClass.prototype.updateLegend = function () {
            var cm = this._fm;
            var name = cm.colName;
            vp.select(this._rootElem)
                .css("display", (name) ? "block" : "none");
            vp.select(this._titleElem)
                .text(name);
        };
        return facetLegendClass;
    }(beachParty.dataChangerClass));
    beachParty.facetLegendClass = facetLegendClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    facetLabelMgr.ts - manages the facet labels above each facet.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var facetLabelMgrClass = (function (_super) {
        __extends(facetLabelMgrClass, _super);
        function facetLabelMgrClass(chart, labelHolderElem) {
            _super.call(this);
            this._labelHolderElem = labelHolderElem;
            this._chart = chart;
        }
        facetLabelMgrClass.prototype.buildLabels = function (facetLayouts) {
            var _this = this;
            this._facetLayouts = facetLayouts;
            var rootW = vp.select(this._labelHolderElem);
            //---- clear previous labels ----
            rootW.clear();
            this._labelElements = [];
            if (facetLayouts && facetLayouts.length) {
                for (var i = 0; i < facetLayouts.length; i++) {
                    var fl = facetLayouts[i];
                    var rc = fl.labelBounds;
                    var text = fl.facelLabel;
                    if (!text) {
                        text = "<blank>";
                    }
                    //---- note that the text-align must be specified on the CONTAINTER ----
                    var divW = rootW.append("div")
                        .css("position", "absolute")
                        .css("text-align", "center")
                        .bounds(rc.left, rc.top + 0, rc.width, rc.height);
                    var labelW = divW.append("span")
                        .addClass("textButton facetLabel")
                        .css("pointer-events", "auto")
                        .css("position", "relative") // IE11 bug workaround
                        .text(text)
                        .attach("mousedown", function (e) {
                        //---- don't trigger a "tap" event in touchMgr ----
                        e.handled = true;
                        vp.events.cancelEventBubble(e);
                        vp.events.cancelEventDefault(e);
                        return false;
                    })
                        .attach("click", function (e) {
                        var elem = e.target;
                        var sp = elem.searchParams;
                        var boxKey = "facet." + elem.facetKey;
                        var selectMode = _this._chart.selectMode();
                        _this._chart.doSearch("Facet", sp.colName, sp.minValue, sp.maxValue, sp.searchType, selectMode, boxKey);
                        //---- don't trigger a "tap" event in touchMgr ----
                        vp.events.cancelEventBubble(e);
                        vp.events.cancelEventDefault(e);
                        return false;
                    });
                    labelW[0].searchParams = fl.searchParams;
                    labelW[0].facetKey = "box" + i;
                    this._labelElements.push(labelW[0]);
                }
            }
        };
        facetLabelMgrClass.prototype.getIndexOfLabel = function (label) {
            var index = -1;
            label = label.toLowerCase();
            for (var i = 0; i < this._labelElements.length; i++) {
                var elem = this._labelElements[i];
                if (elem.textContent.toLocaleLowerCase() == label) {
                    index = i;
                    break;
                }
            }
            return index;
        };
        /**
         * Used to select a facel label from the API.
         * @param index
         */
        facetLabelMgrClass.prototype.selectFacetLabel = function (index) {
            var elem = this._labelElements[index];
            var sp = elem.searchParams;
            this._chart.doSearch("Facet", sp.colName, sp.minValue, sp.maxValue, sp.searchType);
        };
        return facetLabelMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.facetLabelMgrClass = facetLabelMgrClass;
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    NumericVector.ts - defines a numeric version of a number, string, or data column.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** this represents a vector, usually extracted from a dataFrame, which has been converted to all numbers. */
    var NumericVector = (function () {
        function NumericVector(values, colName, colType, colInfo) {
            if (values instanceof Float32Array) {
                this.values = values;
            }
            else {
                this.values = new Float32Array(values);
            }
            this.colName = colName;
            this.colType = colType;
            this.colInfo = colInfo;
        }
        NumericVector.prototype.clone = function () {
            var newArray = new Float32Array(this.values);
            var nv = new NumericVector(newArray, this.colName, this.colType, this.colInfo);
            nv.keyInfo = this.keyInfo;
            return nv;
        };
        NumericVector.prototype.getRawData = function (index) {
            var value = (this.keyInfo) ? this.keyInfo.keysByRow[index] : this.values[index];
            return value;
        };
        NumericVector.prototype.count = function (value) {
            var count = 0;
            for (var i = 0; i < this.values.length; i++) {
                if (this.values[i] == value) {
                    count++;
                }
            }
            return count;
        };
        NumericVector.prototype.copy = function (indexes) {
            var newValues = new Float32Array(indexes.length);
            for (var i = 0; i < indexes.length; i++) {
                var index = indexes[i];
                var value = this.values[index];
                newValues[i] = value;
            }
            var nv = new NumericVector(newValues, this.colName, this.colType, this.colInfo);
            if (this.colType == "string") {
                beachParty.cbUtils.rebuildStringKeyIndexes(nv, indexes, this);
            }
            return nv;
        };
        return NumericVector;
    }());
    beachParty.NumericVector = NumericVector;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    namedVectors.ts - manages changes to 3D transform of chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var NamedVectors = (function () {
        function NamedVectors(length, x, y, z, colorIndex, imageIndex, staggerOffset, size, text, facet, selected, layoutFilter, enterExitFilter, primaryKey, randomX, randomY, red, green, blue, aux, rgb) {
            this.length = length;
            this.x = x;
            this.y = y;
            this.z = z;
            this.colorIndex = colorIndex;
            this.imageIndex = imageIndex;
            this.staggerOffset = staggerOffset;
            this.size = size;
            this.text = text;
            this.facet = facet;
            this.selected = selected;
            this.layoutFilter = layoutFilter;
            this.enterExitFilter = enterExitFilter;
            this.primaryKey = primaryKey;
            this.randomX = randomX;
            this.randomY = randomY;
            this.red = red;
            this.green = green;
            this.blue = blue;
            this.rgb = rgb;
            this.aux = aux;
        }
        NamedVectors.prototype.copy = function (indexes) {
            var nv = new NamedVectors(indexes.length);
            var keys = vp.utils.keys(this);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (key != "length" && this[key] != null) {
                    var numericVector = this[key];
                    var vector = numericVector.copy(indexes);
                    nv[key] = vector;
                }
            }
            return nv;
        };
        return NamedVectors;
    }());
    beachParty.NamedVectors = NamedVectors;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    cbUtils.ts - simple utils for this prototype.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var cbUtils = (function () {
        function cbUtils() {
        }
        cbUtils.buildColorsFromName = function () {
            cbUtils._colorFromName.aliceblue = [240, 248, 255];
            cbUtils._colorFromName.antiquewhite = [250, 235, 215];
            cbUtils._colorFromName.aqua = [0, 255, 255];
            cbUtils._colorFromName.aquamarine = [127, 255, 212];
            cbUtils._colorFromName.azure = [240, 255, 255];
            cbUtils._colorFromName.beige = [245, 245, 220];
            cbUtils._colorFromName.bisque = [255, 228, 196];
            cbUtils._colorFromName.black = [0, 0, 0];
            cbUtils._colorFromName.blanchedalmond = [255, 235, 205];
            cbUtils._colorFromName.blue = [0, 0, 255];
            cbUtils._colorFromName.blueviolet = [138, 43, 226];
            cbUtils._colorFromName.brown = [165, 42, 42];
            cbUtils._colorFromName.burlywood = [222, 184, 135];
            cbUtils._colorFromName.cadetblue = [95, 158, 160];
            cbUtils._colorFromName.chartreuse = [127, 255, 0];
            cbUtils._colorFromName.chocolate = [210, 105, 30];
            cbUtils._colorFromName.coral = [255, 127, 80];
            cbUtils._colorFromName.cornflowerblue = [100, 149, 237];
            cbUtils._colorFromName.cornsilk = [255, 248, 220];
            cbUtils._colorFromName.crimson = [220, 20, 60];
            cbUtils._colorFromName.cyan = [0, 255, 255];
            cbUtils._colorFromName.darkblue = [0, 0, 139];
            cbUtils._colorFromName.darkcyan = [0, 139, 139];
            cbUtils._colorFromName.darkgoldenrod = [184, 134, 11];
            cbUtils._colorFromName.darkgray = [169, 169, 169];
            cbUtils._colorFromName.darkgreen = [0, 100, 0];
            cbUtils._colorFromName.darkkhaki = [189, 183, 107];
            cbUtils._colorFromName.darkmagenta = [139, 0, 139];
            cbUtils._colorFromName.darkolivegreen = [85, 107, 47];
            cbUtils._colorFromName.darkorange = [255, 140, 0];
            cbUtils._colorFromName.darkorchid = [153, 50, 204];
            cbUtils._colorFromName.darkred = [139, 0, 0];
            cbUtils._colorFromName.darksalmon = [233, 150, 122];
            cbUtils._colorFromName.darkseagreen = [143, 188, 143];
            cbUtils._colorFromName.darkslateblue = [72, 61, 139];
            cbUtils._colorFromName.darkslategray = [47, 79, 79];
            cbUtils._colorFromName.darkturquoise = [0, 206, 209];
            cbUtils._colorFromName.darkviolet = [148, 0, 211];
            cbUtils._colorFromName.deeppink = [255, 20, 147];
            cbUtils._colorFromName.deepskyblue = [0, 191, 255];
            cbUtils._colorFromName.dimgray = [105, 105, 105];
            cbUtils._colorFromName.dodgerblue = [30, 144, 255];
            cbUtils._colorFromName.firebrick = [178, 34, 34];
            cbUtils._colorFromName.floralwhite = [255, 250, 240];
            cbUtils._colorFromName.forestgreen = [34, 139, 34];
            cbUtils._colorFromName.fuchsia = [255, 0, 255];
            cbUtils._colorFromName.gainsboro = [220, 220, 220];
            cbUtils._colorFromName.ghostwhite = [248, 248, 255];
            cbUtils._colorFromName.gold = [255, 215, 0];
            cbUtils._colorFromName.goldenrod = [218, 165, 32];
            cbUtils._colorFromName.gray = [128, 128, 128];
            cbUtils._colorFromName.green = [0, 128, 0];
            cbUtils._colorFromName.greenyellow = [173, 255, 47];
            cbUtils._colorFromName.honeydew = [240, 255, 240];
            cbUtils._colorFromName.hotpink = [255, 105, 180];
            cbUtils._colorFromName.indianred = [205, 92, 92];
            cbUtils._colorFromName.indigo = [75, 0, 130];
            cbUtils._colorFromName.ivory = [255, 255, 240];
            cbUtils._colorFromName.khaki = [240, 230, 140];
            cbUtils._colorFromName.lavender = [230, 230, 250];
            cbUtils._colorFromName.lavenderblush = [255, 240, 245];
            cbUtils._colorFromName.lawngreen = [124, 252, 0];
            cbUtils._colorFromName.lemonchiffon = [255, 250, 205];
            cbUtils._colorFromName.lightblue = [173, 216, 230];
            cbUtils._colorFromName.lightcoral = [240, 128, 128];
            cbUtils._colorFromName.lightcyan = [224, 255, 255];
            cbUtils._colorFromName.lightgoldenrodyellow = [250, 250, 210];
            cbUtils._colorFromName.lightgray = [211, 211, 211];
            cbUtils._colorFromName.lightgreen = [144, 238, 144];
            cbUtils._colorFromName.lightpink = [255, 182, 193];
            cbUtils._colorFromName.lightsalmon = [255, 160, 122];
            cbUtils._colorFromName.lightseagreen = [32, 178, 170];
            cbUtils._colorFromName.lightskyblue = [135, 206, 250];
            cbUtils._colorFromName.lightslategray = [119, 136, 153];
            cbUtils._colorFromName.lightsteelblue = [176, 196, 222];
            cbUtils._colorFromName.lightyellow = [255, 255, 224];
            cbUtils._colorFromName.lime = [0, 255, 0];
            cbUtils._colorFromName.limegreen = [50, 205, 50];
            cbUtils._colorFromName.linen = [250, 240, 230];
            cbUtils._colorFromName.magenta = [255, 0, 255];
            cbUtils._colorFromName.maroon = [128, 0, 0];
            cbUtils._colorFromName.mediumaquamarine = [102, 205, 170];
            cbUtils._colorFromName.mediumblue = [0, 0, 205];
            cbUtils._colorFromName.mediumorchid = [186, 85, 211];
            cbUtils._colorFromName.mediumpurple = [147, 112, 219];
            cbUtils._colorFromName.mediumseagreen = [60, 179, 113];
            cbUtils._colorFromName.mediumslateblue = [123, 104, 238];
            cbUtils._colorFromName.mediumspringgreen = [0, 250, 154];
            cbUtils._colorFromName.mediumturquoise = [72, 209, 204];
            cbUtils._colorFromName.mediumvioletred = [199, 21, 133];
            cbUtils._colorFromName.midnightblue = [25, 25, 112];
            cbUtils._colorFromName.mintcream = [245, 255, 250];
            cbUtils._colorFromName.mistyrose = [255, 228, 225];
            cbUtils._colorFromName.moccasin = [255, 228, 181];
            cbUtils._colorFromName.navajowhite = [255, 222, 173];
            cbUtils._colorFromName.navy = [0, 0, 128];
            cbUtils._colorFromName.oldlace = [253, 245, 230];
            cbUtils._colorFromName.olive = [128, 128, 0];
            cbUtils._colorFromName.olivedrab = [107, 142, 35];
            cbUtils._colorFromName.orange = [255, 165, 0];
            cbUtils._colorFromName.orangered = [255, 69, 0];
            cbUtils._colorFromName.orchid = [218, 112, 214];
            cbUtils._colorFromName.palegoldenrod = [238, 232, 170];
            cbUtils._colorFromName.palegreen = [152, 251, 152];
            cbUtils._colorFromName.paleturquoise = [175, 238, 238];
            cbUtils._colorFromName.palevioletred = [219, 112, 147];
            cbUtils._colorFromName.papayawhip = [255, 239, 213];
            cbUtils._colorFromName.peachpuff = [255, 218, 185];
            cbUtils._colorFromName.peru = [205, 133, 63];
            cbUtils._colorFromName.pink = [255, 192, 203];
            cbUtils._colorFromName.plum = [221, 160, 221];
            cbUtils._colorFromName.powderblue = [176, 224, 230];
            cbUtils._colorFromName.purple = [128, 0, 128];
            cbUtils._colorFromName.red = [255, 0, 0];
            cbUtils._colorFromName.rosybrown = [188, 143, 143];
            cbUtils._colorFromName.royalblue = [65, 105, 225];
            cbUtils._colorFromName.saddlebrown = [139, 69, 19];
            cbUtils._colorFromName.salmon = [250, 128, 114];
            cbUtils._colorFromName.sandybrown = [244, 164, 96];
            cbUtils._colorFromName.seagreen = [46, 139, 87];
            cbUtils._colorFromName.seashell = [255, 245, 238];
            cbUtils._colorFromName.sienna = [160, 82, 45];
            cbUtils._colorFromName.silver = [192, 192, 192];
            cbUtils._colorFromName.skyblue = [135, 206, 235];
            cbUtils._colorFromName.slateblue = [106, 90, 205];
            cbUtils._colorFromName.slategray = [112, 128, 144];
            cbUtils._colorFromName.snow = [255, 250, 250];
            cbUtils._colorFromName.springgreen = [0, 255, 127];
            cbUtils._colorFromName.steelblue = [70, 130, 180];
            cbUtils._colorFromName.tan = [210, 180, 140];
            cbUtils._colorFromName.teal = [0, 128, 128];
            cbUtils._colorFromName.thistle = [216, 191, 216];
            cbUtils._colorFromName.tomato = [255, 99, 71];
            cbUtils._colorFromName.transparent = [255, 255, 255];
            cbUtils._colorFromName.turquoise = [64, 224, 208];
            cbUtils._colorFromName.violet = [238, 130, 238];
            cbUtils._colorFromName.wheat = [245, 222, 179];
            cbUtils._colorFromName.white = [255, 255, 255];
            cbUtils._colorFromName.whitesmoke = [245, 245, 245];
            cbUtils._colorFromName.yellow = [255, 255, 0];
            cbUtils._colorFromName.yellowgreen = [154, 205, 50];
        };
        /** rebuild the 4 special properties for "toNV", based on info from the larger "fromNV" that toNV was built from. */
        cbUtils.rebuildStringKeyIndexes = function (toNV, indexes, fromNV) {
            var indexesByKey = {};
            var keysByIndex = {};
            var rowsByKey = {};
            var keysByRow = [];
            var nextKeyId = 0;
            var sortedKeys = fromNV.keyInfo.sortedKeys;
            var toVector = toNV.values;
            if (toVector && toVector.length) {
                //---- look like non-numbers; treat as string ----
                for (var i = 0; i < indexes.length; i++) {
                    var fromIndex = indexes[i];
                    var key = fromNV.keyInfo.keysByRow[fromIndex];
                    var keyValue = toVector[i];
                    indexesByKey[key] = keyValue;
                    keysByIndex[keyValue] = key;
                    var rows = rowsByKey[key];
                    if (rows === undefined) {
                        rows = [];
                        rowsByKey[key] = rows;
                        var si = sortedKeys.indexOf(key);
                        if (si == -1) {
                            sortedKeys.push(key);
                        }
                    }
                    rows.push(i);
                    keysByRow[i] = key;
                }
            }
            var keyInfo = new beachParty.KeyInfo(sortedKeys.length, indexesByKey, keysByIndex, rowsByKey, keysByRow, sortedKeys);
            toNV.keyInfo = keyInfo;
        };
        cbUtils.onFileOpenError = function (fileName, ex) {
            //---- separate error msg from stack trace ----
            var fullMsg = ex;
            ex = ex.replace(/&#39;/g, "'");
            var index = ex.indexOf("\r\n");
            if (index > -1) {
                ex = ex.substr(0, index);
            }
            //---- remove .NET error text ----
            index = ex.indexOf("returned an error: ");
            if (index > -1) {
                ex = ex.substr(index + 18);
            }
            var errorMsg = "Could not open '" + fileName + "' (error: " + ex + ").";
            vp.utils.debug(errorMsg);
            //---- this will be caught by the engine's window.onerror & sent back to the client ----
            throw errorMsg;
        };
        cbUtils.getDataLength = function (nv, applyFilter) {
            var length = (nv) ? nv.length : 0;
            if (applyFilter && nv && nv.layoutFilter) {
                var filter = nv.layoutFilter.values;
                length = vector.countOff(filter);
            }
            return length;
        };
        cbUtils.toBool = function (value) {
            var bValue = value;
            if (vp.utils.isString(value)) {
                var str = value.toLowerCase();
                bValue = (str == "true" || str == "1");
            }
            return bValue;
        };
        cbUtils.getMinMax = function (dataNumVector, filterNumVector, md) {
            var min = Number.MAX_VALUE;
            var max = -Number.MAX_VALUE;
            if (dataNumVector) {
                var dataVector = dataNumVector.values;
                var filterVector = (filterNumVector) ? filterNumVector.values : null;
                for (var i = 0; i < dataVector.length; i++) {
                    var value = dataVector[i];
                    if (!filterVector || !filterVector[i]) {
                        if (value < min) {
                            min = value;
                        }
                        if (value > max) {
                            max = value;
                        }
                    }
                }
            }
            else {
                min = 0;
                max = 1;
            }
            if (md.minBreak !== undefined) {
                min = md.minBreak;
            }
            else if (md.minBreakFacet !== undefined) {
                min = md.minBreakFacet;
            }
            if (md.maxBreak !== undefined) {
                max = md.maxBreak;
            }
            else if (md.maxBreakFacet !== undefined) {
                max = md.maxBreakFacet;
            }
            return { min: min, max: max };
        };
        cbUtils.makeRangeScale = function (dataVector, filterVector, rangeMin, rangeMax, constantDefault, md) {
            if (constantDefault === void 0) { constantDefault = 0; }
            var colType = (dataVector) ? dataVector.colType : null;
            var scale = null;
            if (colType == "string" || (md && md.forceCategory)) {
                //---- create CATEGORY scale ----
                /// NOTE: to ensure category scaling works when a filter is active, we need to use the true string key values for
                /// the catKeys, and when scaling, we will pass the true string key value.  This is necessary because when a 
                /// filter is active, the key numbers used in NumericVectors are not consecutive, like they are when the 
                /// filter is not active.
                var catKeys = cbUtils.getFilteredSortedKeys(dataVector, filterVector, md.forceCategory);
                scale = vp.scales.createCategoryKey()
                    .categoryKeys(catKeys)
                    .range(rangeMin, rangeMax);
            }
            else if (colType == "date") {
                var result = cbUtils.getMinMax(dataVector, filterVector, md);
                //---- create DATE scale ----
                var scale = vp.scales.createDate()
                    .domainMin(result.min)
                    .domainMax(result.max)
                    .rangeMin(rangeMin)
                    .rangeMax(rangeMax);
            }
            else {
                //---- create LINEAR scale ---
                var result = cbUtils.getMinMax(dataVector, filterVector, md);
                if (!dataVector) {
                    rangeMin = constantDefault;
                    rangeMax = constantDefault;
                }
                scale = vp.scales.createLinear()
                    .domainMin(result.min)
                    .domainMax(result.max)
                    .rangeMin(rangeMin)
                    .rangeMax(rangeMax);
            }
            this.buildFormatter(md, scale, colType);
            return scale;
        };
        cbUtils.buildFormatter = function (md, scale, colType) {
            if (md && md.formatting) {
                var anyScale = scale;
                anyScale._formatter = vp.formatters.createExcelFormatter(md.formatting, colType);
            }
        };
        /** this is used to scale palette-based attributes (like IMAGE and SHAPE), other than color. */
        cbUtils.makePaletteScale = function (dataVector, filterVector, palette, isContinuous, breaks, md) {
            /// Note: scale input/domain can be Continuous (number, date) or discrete (string).  scale out/range can be continuous or discrete.
            /// Scale construction needs to consider all 4 possible combinations.
            var colType = (dataVector) ? dataVector.colType : null;
            var scale = null;
            if (colType == "string") {
                //---- create CATEGORY scale ----
                //var catKeys = dataVector.keyInfo.sortedKeys;
                var catKeys = cbUtils.getFilteredSortedKeys(dataVector, filterVector);
                scale = vp.scales.createCategoryKey()
                    .categoryKeys(catKeys)
                    .palette(palette);
            }
            else {
                //---- create LINEAR scale ---
                if (breaks && breaks.length) {
                    //---- get min/max from breaks ----
                    var len = breaks.length;
                    var minVal = breaks[0];
                    var maxVal = breaks[len - 1];
                }
                else {
                    //---- get min/max from data ----
                    var result = cbUtils.getMinMax(dataVector, filterVector, md);
                    minVal = result.min;
                    maxVal = result.max;
                }
                scale = vp.scales.createLinear()
                    .domainMin(minVal)
                    .domainMax(maxVal)
                    .palette(palette)
                    .isPaletteDiscrete(!isContinuous);
            }
            this.buildFormatter(md, scale, colType);
            return scale;
        };
        cbUtils.makeLinearScale = function (min, max, rangeMin, rangeMax) {
            var linearScale = vp.scales.createLinear()
                .domainMin(min)
                .domainMax(max)
                .rangeMin(rangeMin)
                .rangeMax(rangeMax);
            return linearScale;
        };
        cbUtils.getCubeDefaultSize = function (shapeCount) {
            var logCount = Math.log10(shapeCount);
            var size = .1 / logCount;
            if (logCount < 3) {
                size *= 4;
            }
            else if (logCount < 3.5) {
                size *= 3;
            }
            else if (logCount < 4) {
                size *= 2;
            }
            //size /= 100;
            return size;
        };
        cbUtils.error = function (msg) {
            throw "Error: " + msg;
        };
        cbUtils.cloneMap = function (map) {
            var newMap = {};
            var keys = vp.utils.keys(map);
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var value = map[key];
                newMap[key] = value;
            }
            return newMap;
        };
        cbUtils.getFilteredSortedKeys = function (colDataInfo, filterVector, sortAsNumeric) {
            var keys = null;
            var hasKeyInfo = colDataInfo.keyInfo;
            var sortedKeys = (hasKeyInfo) ? colDataInfo.keyInfo.sortedKeys : null;
            if (!sortedKeys) {
                //---- force numeric values to strings and sort them ----
                var numKeys = colDataInfo.values.groupBy().map(function (pair) { return pair.key; });
                if (sortAsNumeric) {
                    sortedKeys = numKeys.orderByNum();
                }
                else {
                    sortedKeys = numKeys.orderByStr();
                }
            }
            if (sortedKeys) {
                keys = sortedKeys.slice(0); // duplicate array (since we will change it)
                var colData = colDataInfo.values;
                //---- must remove any key in KEYS that is completely filtered out ----
                if (filterVector) {
                    //---- use "colData" for building assignments, but "filteredData" for bin boundaries ----
                    var filteredData = [];
                    var filterValues = filterVector.values;
                    var inKeys = {};
                    for (var i = 0; i < colData.length; i++) {
                        if (!filterValues[i]) {
                            var key = (hasKeyInfo) ? colDataInfo.keyInfo.keysByRow[i] : (colData[i] + "");
                            inKeys[key] = true;
                        }
                    }
                    //---- test each key in KEYS - preserving the key order ----
                    for (var k = keys.length - 1; k >= 0; k--) {
                        var key = keys[k];
                        if (inKeys[key] === undefined) {
                            keys.removeAt(k);
                        }
                    }
                }
            }
            return keys;
        };
        cbUtils.isImageFile = function (fn) {
            var isImg = false;
            if (fn) {
                var ext = fn.substr(-4).toLowerCase(); // last 4 chars
                isImg = (ext == ".png" || ext == ".jpg" || ext == ".bmp");
            }
            return isImg;
        };
        cbUtils.getSizeOfMap = function (map, objList, forceCheck) {
            var total = 0;
            if (map) {
                if (forceCheck || !objList || objList.indexOf(map) == -1) {
                    if (!forceCheck && objList != null) {
                        //---- add this obj so that we never count it again ----
                        objList.push(map);
                    }
                    var keys = vp.utils.keys(map);
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        total += key.length;
                        var obj = map[key];
                        total += cbUtils.getSizeOfValue(obj, objList);
                    }
                    total += 8 * keys.length; // hashtable estimate
                }
            }
            return total;
        };
        cbUtils.getSizeOfValue = function (value, objList) {
            var total = 0;
            if (value) {
                total = 4; // estimated space for type info
                if (vp.utils.isNumber(value)) {
                    total += 8;
                }
                else if (vp.utils.isString(value)) {
                    total += value.length;
                }
                else if (vp.utils.isDate(value)) {
                    total += 8; // estimate
                }
                else if (value instanceof Float32Array) {
                    total += 4 * value.length;
                }
                else if (vp.utils.isArray(value)) {
                    var aray = value;
                    for (var i = 0; i < aray.length; i++) {
                        total += cbUtils.getSizeOfValue(aray[i], objList);
                    }
                    total += 8 * value.length; // ptrs to strings (estimated)
                }
                else {
                    //---- assume it is a map ----
                    total += cbUtils.getSizeOfMap(value, objList);
                }
            }
            return total;
        };
        /** get the approximate memory used exclusively by the specified objects (overlapping memory not counted).
         * Space used by functions and unusual memory types not counted.
         */
        cbUtils.getMemoryUse = function (memObjMap, memUseMap) {
            if (!memUseMap) {
                memUseMap = {};
            }
            var keys = vp.utils.keys(memObjMap);
            var objList = [];
            //---- build objList ----
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var obj = memObjMap[key];
                objList.push(obj);
            }
            //---- get size of each object ----
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var obj = memObjMap[key];
                var total = cbUtils.getSizeOfMap(obj, objList, true);
                memUseMap[key] = total;
            }
            return memUseMap;
        };
        cbUtils.arrayToString = function (aray, delim) {
            var str = "";
            for (var i = 0; i < aray.length; i++) {
                if (str != "") {
                    str += delim;
                }
                str += aray[i];
            }
            return str;
        };
        cbUtils.stringToArray = function (value, delim) {
            var parts = [];
            if (value) {
                parts = value.split(delim);
            }
            return parts;
        };
        /**
         *  The expression is parsed to ensure it only contains:
            - contant numbers and strings
            - standard JavaScript Math/Date/String functions
            - variables from "allowVariableList".
         * @param expression
         * @param allowedVariableList
         */
        cbUtils.isSafeExpression = function (expression, allowedVariableList) {
            //---- TODO: add parser code here to validate expression as safe ----
            return false;
        };
        /**
         *  Returns a function that be called to evaluate the specified expression.
         * @param expression
         */
        cbUtils.safeEval = function (expression, allowedVariableList) {
            var str = "return " + expression;
            if (!cbUtils.isSafeExpression(expression, allowedVariableList)) {
                throw "unsafe expression passed to safeEval()";
            }
            var func = new Function(str);
            return func;
        };
        /**
 *  Return a valid HTML color string for "cr".
 * @param cr
 */
        cbUtils.getBeachPartyColor = function (cr) {
            if (vp.utils.isString(cr)) {
                var crLow = cr.toLowerCase();
                if (crLow == "beach blue" || crLow == "beachblue") {
                    cr = "#0cf";
                }
                else if (crLow == "none" || crLow == "") {
                    cr = "transparent";
                }
            }
            return cr;
        };
        cbUtils.getBeachPartyName = function (cr) {
            var name = cr;
            if (vp.utils.isString(cr)) {
                var crLow = cr.toLowerCase();
                if (crLow == "transparent") {
                    name = "None";
                }
                else if (crLow == "#0cf" || crLow == "rgb(0, 204, 255)") {
                    name = "BeachBlue";
                }
            }
            return name;
        };
        cbUtils.colorFromName = function (cr) {
            var crLow = cbUtils.getBeachPartyColor(cr);
            cr = cbUtils._colorFromName[cr];
            return cr;
        };
        cbUtils._colorFromName = {};
        return cbUtils;
    }());
    beachParty.cbUtils = cbUtils;
    var SearchParamsEx = (function (_super) {
        __extends(SearchParamsEx, _super);
        function SearchParamsEx() {
            _super.apply(this, arguments);
        }
        return SearchParamsEx;
    }(beachParty.SearchParams));
    beachParty.SearchParamsEx = SearchParamsEx;
    cbUtils.buildColorsFromName();
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    touchMgr.ts - manages the chart touch events (using Hammer.js)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var touchMgrClass = (function (_super) {
        __extends(touchMgrClass, _super);
        function touchMgrClass(div, rubberBand, chart) {
            var _this = this;
            _super.call(this);
            this._inputAction = null; // "swipe", "percent", or "dragRect"
            this._insightIndex = 0;
            this._isHammerEnabled = false;
            this._maxTouchCount = 0; // within a "touch session" 
            this._ptDownInChartUx = false;
            this._lastSessionFinal = 0; // last mouse up time
            this._isPinching = false;
            this._isShowingWheel = false;
            this._transformMode = beachParty.ClientTransformMode.wheel;
            this._ptTouch = null;
            this._wheelTimer = null;
            this._isMouseDown = false;
            this._hasInertia = false;
            this._isCutomRecogEnabled = false;
            //---- removable callbacks for hammer event processing ----
            this._processInputCallback = null;
            this._doubleTabCallback = null;
            this._pinchStartCallback = null;
            this._doublePinchCallback = null;
            this._singlePanCallback = null;
            this._doublePanCallback = null;
            this._triplePanCallback = null;
            //---- prevent entering lower pointer modes as pointers are lifted ----
            this._tripleMode = null;
            this._doubleMode = null;
            //---- for throttling events ----
            this._delayTimer = null;
            this._isTouchEnabled = true;
            //---- events ----
            this.onActionDectected = new beachParty.bpEvent();
            this._div = div;
            this._rubberBandSelector = rubberBand;
            this._chart = chart;
            div.oncontextmenu = function () { return false; };
            //---- build removable callbacks ----
            this._processInputCallback = function (e) { return _this.processHammerInput(e); };
            this._doubleTabCallback = function (e) { return _this.processDoubleTap(e); };
            this._pinchStartCallback = function (e) { return _this.processPinchStart(e); };
            this._doublePinchCallback = function (e) { return _this.processDoublePinch(e); };
            this._singlePanCallback = function (e) { return _this.processSinglePan(e); };
            this._doublePanCallback = function (e) { return _this.processDoublePan(e); };
            this._triplePanCallback = function (e) { return _this.processTriplePan(e); };
        }
        touchMgrClass.prototype.isShowingWheel = function (value) {
            if (arguments.length == 0) {
                return this._isShowingWheel;
            }
            this._isShowingWheel = value;
            this._wheel.isActive(this._isShowingWheel);
            vp.utils.debug("toggleWheel: _isShowingWheel=" + this._isShowingWheel);
            this.onDataChanged("isShowingWheel");
        };
        touchMgrClass.prototype.shutDown = function () {
            this.isHammerEnabled(false);
        };
        touchMgrClass.prototype.setTransformMgr = function (transformMgr) {
            this._transformMgr = transformMgr;
            var wheelSize = 100; // gets resized later
            var svgElem = this._chart.getChartBuilder().getSvgDoc();
            this._svgDoc = svgElem;
            this._chartUxElem = this._chart.chartUxElement();
            this._wheel = new beachParty.transformWheelClass(svgElem, wheelSize);
            this._wheel.isActive(false);
        };
        touchMgrClass.prototype.isHammerEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isHammerEnabled;
            }
            this._isHammerEnabled = value;
            this.onHammerEnabledChanged();
        };
        touchMgrClass.prototype.processPinchStart = function (e) {
            this._doubleMode = "pinch";
            if (!this._tripleMode) {
                this._transformMgr.resetPanAndPinchDeltas();
            }
        };
        touchMgrClass.prototype.processDoublePinch = function (e) {
            if (!this._tripleMode) {
                if (this._isTouchEnabled) {
                    //---- ignore single finger when user is removing 1 finger at a time from pinch ----
                    var pointerCount = e.pointers.length;
                    if (pointerCount == 2) {
                        this._isPinching = true;
                        var touchPos = this.avgTouchPosition(e);
                        //vp.utils.debug("--> pinch event: x==" + touchPos.x + ", y=" + touchPos.y + ", scale=" + e.scale);
                        this._transformMgr.scaleCameraAbsolute(e.scale, touchPos);
                        this.drawSingleFrame("pinchZoom");
                        this.setNextMsgDelay();
                    }
                }
            }
        };
        touchMgrClass.prototype.drawSingleFrame = function (reason) {
            this._chart.getChartBuilder().redrawLastFrame(reason);
        };
        touchMgrClass.prototype.enablePinch = function (mc) {
            var anyHammer = Hammer;
            //---- threshold here is min. scale to recognize event; default=0 ----
            var pinch = mc.add(new anyHammer.Pinch({ pointers: 2, event: "doublePinch", direction: anyHammer.DIRECTION_ALL, time: 750, threshold: .15 }));
            mc.on('pinchstart', this._pinchStartCallback);
            mc.on('doublePinch', this._doublePinchCallback);
            return pinch;
        };
        touchMgrClass.prototype.processSinglePan = function (e) {
            if (!this._doubleMode && !this._tripleMode) {
                //vp.utils.debug("1 FINGER PAN detected");
                if (this._isShowingWheel) {
                    this.onPanEvent(e);
                }
            }
        };
        touchMgrClass.prototype.enablePan1 = function (mc) {
            //---- enable 1 finger PAN ----
            var anyHammer = Hammer;
            //---- threshold here is min. distance to recognize event; default=10 ----
            mc.add(new anyHammer.Pan({ pointers: 1, event: "singlePan", direction: anyHammer.DIRECTION_ALL, threshold: 10 }));
            mc.on("singlePan", this._singlePanCallback);
        };
        touchMgrClass.prototype.enableTap2 = function (mc) {
            //---- enable 2 finger TAP ----
            var anyHammer = Hammer;
            //---- threshold here is amount tab can move around; default=2 ----
            //---- time here is maximum pointer down time for recognition; default=250  ----
            mc.add(new anyHammer.Tap({ pointers: 2, event: "doubleTap", threshold: 9, time: 1000 }));
            mc.on("doubleTap", this._doubleTabCallback);
        };
        touchMgrClass.prototype.processDoubleTap = function (e) {
            if (!this._tripleMode) {
                this._doubleMode = "tap2";
                vp.utils.debug("2 FINGER --TAP-- detected");
                //---- call thru chart so that everything works correctly ----
                //this.toggleWheel();
                this._chart.toggleWheel();
            }
        };
        touchMgrClass.prototype.processDoublePan = function (e) {
            if (!this._tripleMode) {
                this._doubleMode = "pan2";
                vp.utils.debug("2 FINGER PAN detected");
                this.onPanEvent(e, false, true);
            }
        };
        touchMgrClass.prototype.enablePan2 = function (mc) {
            //---- enable 2 finger PAN ----
            var anyHammer = Hammer;
            //---- threshold here is min. distance to recognize event; default=10 ----
            var pan = mc.add(new anyHammer.Pan({ pointers: 2, event: "doublePan", direction: anyHammer.DIRECTION_ALL, threshold: 10 }));
            mc.on("doublePan", this._doublePanCallback);
            return pan;
        };
        touchMgrClass.prototype.enablePinchAndPan2 = function (mc) {
            var pinch = this.enablePinch(mc);
            var pan2 = this.enablePan2(mc);
            pinch.recognizeWith(pan2);
        };
        touchMgrClass.prototype.processTriplePan = function (e) {
            this._tripleMode = "pan3";
            vp.utils.debug("3 FINGER PAN detected");
            this.onPanEvent(e, true, false);
        };
        touchMgrClass.prototype.enablePan3 = function (mc) {
            //---- enable 3 finger PAN ----
            var anyHammer = Hammer;
            //---- threshold here is min. distance to recognize event; default=10 ----
            mc.add(new anyHammer.Pan({ pointers: 3, event: "triplePan", direction: anyHammer.DIRECTION_ALL, threshold: 3 }));
            mc.on("triplePan", this._triplePanCallback);
        };
        touchMgrClass.prototype.onHammerEnabledChanged = function () {
            var value = this._isHammerEnabled;
            if (value) {
                //this._rubberBandSelector.isEnabled(false);
                var myDiv = this._div;
                var anyHammer = window["Hammer"];
                if (anyHammer) {
                    var hammerOpts = { preventDefault: false };
                    //---- use the Hammer.Manager() form to start with no recognizers (so we control exactly what happens) ----
                    var mc = new anyHammer.Manager(myDiv, hammerOpts);
                    this._mc = mc;
                    mc.on("hammer.input", this._processInputCallback);
                    //this.enablePinch(mc);
                    //this.enablePan2(mc);      // this one does not work well with pinch
                    this.enablePinchAndPan2(mc);
                    this.enableTap2(mc);
                    this.enablePan3(mc);
                    this.enablePan1(mc); // use our custom recog for this
                    this.inputAction(null);
                }
            }
            else {
                //this._rubberBandSelector.isEnabled(true);
                if (this._mc) {
                    //---- an attemp to make Hammer release its event handlers, but not yet working ----
                    this._mc.off("hammer.input", this._processInputCallback);
                    this._mc.off("doubleTap", this._doubleTabCallback);
                    this._mc.off("pinchstart", this._pinchStartCallback);
                    this._mc.off("doublePinch", this._doublePinchCallback);
                    this._mc.off("singlePan", this._singlePanCallback);
                    this._mc.off("doublePan", this._doublePanCallback);
                    this._mc.off("triplePan", this._triplePanCallback);
                    //this._mc.remove(xx);
                    this._mc.enabled = false;
                    this._mc = null;
                }
            }
        };
        touchMgrClass.prototype.processHammerInput = function (e) {
            var _this = this;
            if (e.isFinal) {
                //---- when last pointer is lifted, reset our mode protector ----
                vp.utils.debug("input.isFinal=true");
                //---- put on small timer so we finish pending events before clearing this ----
                setTimeout(function (e) {
                    _this._doubleMode = null;
                    _this._tripleMode = null;
                    _this._wheel.partTouched("");
                }, 1);
            }
            this.onInput(e);
        };
        touchMgrClass.prototype.onPanEvent = function (e, forceRotate, forceMove) {
            var rotStep = Math.PI / 64;
            var view = this._chart;
            var lastTouch = this._ptTouch;
            var thisTouch = vp.events.mousePosition(e.srcEvent); //  this.avgTouchPosition(e);
            //vp.utils.debug("onPanEvent: lastTouch.x=" + lastTouch.x + ", .y=" + lastTouch.y);
            var deltaX = thisTouch.x - lastTouch.x;
            var deltaY = thisTouch.y - lastTouch.y;
            var partTouched = this._wheel.partTouched(); //  this.get3dWheelPartTouched(this._ptLastDown);
            this._ptTouch = thisTouch;
            var xDir = (deltaX >= 0) ? 1 : -1;
            var yDir = (deltaY >= 0) ? 1 : -1;
            var delta = (Math.abs(deltaX) > Math.abs(deltaY)) ? deltaX : deltaY;
            var speedFactor = 1 / 100;
            //vp.utils.debug("deltaX=" + deltaX + ", deltaY=" + deltaY);
            var drawReason = null;
            //---- make mouse event look like hammer event, if needed ----
            if (!e.srcEvent) {
                e.srcEvent = e;
            }
            if (!forceRotate) {
                forceRotate = (this._transformMode == beachParty.ClientTransformMode.rotate);
            }
            if (!forceMove) {
                forceMove = (this._transformMode == beachParty.ClientTransformMode.pan);
            }
            if (forceMove) {
                //---- MOVE ----
                this.moveCamera(e);
                drawReason = "moveCamera";
            }
            else {
                //---- ROTATE, AUTO, or WHEEL mode ----
                if (forceRotate) {
                    partTouched = "middle";
                }
                if ((e.srcEvent.ctrlKey && e.srcEvent.shiftKey) || (partTouched == "circle")) {
                    //---- CTRL + SHIFT + drag = SPIN ----
                    //vp.utils.debug("ROTATE-Z: value=" + delta);
                    this._transformMgr.rotateMatrixZ(delta * speedFactor);
                    drawReason = "rotateMatrixZ";
                }
                if ((e.srcEvent.ctrlKey) || (partTouched == "hBar") || (partTouched == "middle")) {
                    //---- CTRL + drag = TURN ----
                    //vp.utils.debug("ROTATE-Y: value=" + -deltaX);
                    //---- workaround until we figure out the right approach here ----
                    var usePostZ = (this._chart.chartName() == "Stacks");
                    this._transformMgr.rotateMatrixY(-deltaX * speedFactor, usePostZ);
                    drawReason = "rotateMatrixY";
                }
                if ((e.srcEvent.shiftKey) || (partTouched == "vBar") || (partTouched == "middle")) {
                    //---- SHIFT + drag = FLIP ----
                    //vp.utils.debug("ROTATE-X: value=" + -deltaY);
                    this._transformMgr.rotateMatrixX(-deltaY * speedFactor);
                    drawReason = "rotateMatrixX";
                }
                if ((!e.srcEvent.shiftKey) && (!e.srcEvent.ctrlKey) && (partTouched == "")) {
                    //---- MOVE ----
                    this.moveCamera(e);
                    drawReason = "moveCamera";
                }
                if (drawReason) {
                    this.drawSingleFrame(drawReason);
                }
            }
            this.setNextMsgDelay();
        };
        touchMgrClass.prototype.moveCamera = function (e) {
            vp.utils.debug("MOVE-X: x=" + e.deltaX + ", y=" + -e.deltaY);
            var mousePos = vp.events.mousePosition(e.srcEvent, this._chartUxElem);
            this._transformMgr.transformMode(beachParty.TransformMode.move);
            this._transformMgr.moveCamera(e.deltaX / 100, -e.deltaY / 100, mousePos);
        };
        touchMgrClass.prototype.setBounds = function (left, top, width, height) {
            //this._svgWidth = width;
            //this._svgHeight = height;
            //---- center the transformWheel ----
            var left = left + width / 2; // circle is drawn from center, so this works
            var top = top + height / 2; // - 10;      // fudge factor
            var wheelSize = Math.max(0, .8 * Math.min(width, height));
            this._wheel.wheelSize(wheelSize);
            vp.select(this._wheel._group)
                .translate(left, top);
        };
        touchMgrClass.prototype.setNextMsgDelay = function () {
            var _this = this;
            this._delayTimer = setTimeout(function (e) {
                _this._delayTimer = null;
                _this._isTouchEnabled = true;
            }, 15);
            this._isTouchEnabled = false;
        };
        touchMgrClass.prototype.inputAction = function (value, subAction, e) {
            if (arguments.length == 0) {
                return this._inputAction;
            }
            this._inputAction = value;
            //vp.utils.debug("touchMgr: inputAction set=" + value);
            if (this._isCutomRecogEnabled) {
                this.onActionDectected.trigger({ sender: this, action: value, subAction: subAction, evt: e });
            }
            if (e) {
                this.processOnAction(e);
            }
        };
        touchMgrClass.prototype.onMouseWheel = function (e) {
            var pt = vp.events.mousePosition(e);
            var factor = (e.wheelDelta > 0) ? 1.3 : (1 / 1.3);
            this._transformMgr.scaleCameraRelative(factor, pt);
            this.drawSingleFrame("mouseWheel");
        };
        /** Called from dataView, based on the chart's onFrame event. */
        touchMgrClass.prototype.onFrame = function () {
            this._hasInertia = this._transformMgr.onFrame();
            if (this._hasInertia) {
                this.drawSingleFrame("hasInertia");
            }
            if ((this._transformMode != beachParty.ClientTransformMode.none) && (!this._isMouseDown)) {
                var showIt = (!this._hasInertia); //  (this._showWheelDuringTransformMode && (!hasInertia));
            }
        };
        touchMgrClass.prototype.avgTouchPosition = function (e) {
            //vp.utils.debug("avgTouchPosition: e=" + e + ", e.pointers=" + e.pointers + ", avgTouchPosition.length=" + e.pointers.length);
            var pt = { x: 0, y: 0 };
            if (e.pointers) {
                //---- hammer.js event ----
                var count = e.pointers.length;
                for (var i = 0; i < count; i++) {
                    var pe = e.pointers[i];
                    var x = (pe.x === undefined) ? pe.clientX : pe.x;
                    var y = (pe.y === undefined) ? pe.clientY : pe.y;
                    //vp.utils.debug("avgTouchPosition: pe[" + i + "]: x=" + x + ", y=" + y);
                    pt.x += x;
                    pt.y += y;
                }
                if (count) {
                    pt.x /= count;
                    pt.y /= count;
                }
            }
            else {
                pt = vp.events.mousePosition(e);
            }
            //vp.utils.debug("avgTouchPosition: x=" + pt.x + ", y=" + pt.y);
            return pt;
        };
        touchMgrClass.prototype.processOnAction = function (e) {
            var action = this._inputAction;
            var origEvent = e.srcEvent;
            if (action == "dragRect") {
                if (!this._isShowingWheel) {
                    //---- route mouseDown to rubberBand ----
                    //vp.utils.debug("touchMgr: routing dragRect event to rubberBandSelector.onRubberDown");
                    this._rubberBandSelector.setMouseDown(this._ptMouseDown);
                    this._chart.enableTickBoxUI(false);
                }
            }
            else if (action == "tap") {
                if (!this._isShowingWheel) {
                    var pt = this._ptMouseDown;
                    if (this.isValidSelectionPos(pt)) {
                        //vp.utils.debug("touchMgr: routing tap event to rubberBandSelector.processExternalTap");
                        this._rubberBandSelector.setMouseDown(pt);
                        this._rubberBandSelector.processExternalUp(origEvent);
                    }
                }
            }
        };
        touchMgrClass.prototype.isValidSelectionPos = function (pt) {
            var isValid = true;
            var elem = vp.events.elementFromPoint(pt.x, pt.y);
            //---- is it a facet label? ----
            var elemW = vp.select(elem);
            if (elemW.hasClass("facetLabel")) {
                isValid = false;
            }
            else {
                //---- is point within the plot rectangle? ----
                var rc = vp.select(this._chartUxElem).getBounds();
                if (!vp.geom.rectContainsPoint(rc, pt)) {
                    isValid = false;
                }
            }
            return isValid;
        };
        touchMgrClass.prototype.detectInputAction = function (e) {
            var touchCount = e.pointers.length;
            //vp.utils.debug("==> touchCount=" + touchCount + ", velocityY=" + e.velocityY + ", deltaY=" + e.deltaY);
            if (touchCount == 1) {
                var isDragging = (Math.abs(e.deltaY) >= 3 || Math.abs(e.deltaX) >= 3);
                if (isDragging && e.deltaTime > 250) {
                    this.inputAction("dragRect", null, e);
                }
            }
            else if (touchCount == 2) {
                if (Math.abs(e.deltaY) > 10) {
                    var dir = (e.deltaY > 0) ? "down" : "up";
                    this._dir = dir;
                    if (Math.abs(e.deltaTime) < 500) {
                        this.inputAction("swipe", { dir: dir }, e);
                        this._insightIndex += (dir == "down") ? 1 : -1;
                    }
                    else {
                        this.inputAction("percent", { dir: dir }, e);
                    }
                }
            }
        };
        touchMgrClass.prototype.onMouseDown = function (e) {
            vp.utils.debug("onMouseDown called");
            var touchCount = e.pointers.length;
            this._transformMgr.onUiOpStart();
            this._isMouseDown = true;
            this._ptTouch = this.avgTouchPosition(e);
            var pt = vp.events.mousePosition(e, this._chartUxElem);
            //this._ptLastDown = pt;
            if (this._wheel.isActive()) {
                this.startWheelTimer();
            }
            //vp.utils.debug("---------------------------------------------------------------------");
            //vp.utils.debug("touchMgr: isFirst=true");
            this._ptMouseDown = vp.events.mousePosition(e.srcEvent);
            var rc = this._chart.getPlotBounds();
            this._ptDownInChartUx = (!e.srcEvent.handled || vp.geom.rectContainsPoint(rc, this._ptMouseDown));
            this.inputAction(null, null, e);
            if (this._isShowingWheel) {
                if (touchCount == 1) {
                    //---- trigger svg mousedown to get benefits of wheel hit testing ----
                    this._wheel.simulateMouseDown(e.srcEvent, this._chartUxElem);
                }
            }
            //---- ensure that mouse capture is OFF ----
            this._maxTouchCount = touchCount;
        };
        touchMgrClass.prototype.onMouseUp = function (e) {
            vp.utils.debug("onMouseUp called");
            //    if (this._inputAction == "dragRect")
            //    {
            //        //---- another UI control has stolen our mouseUp event; simulate our own now ----
            //        this._rubberBandSelector.cancelBanding(true, e);
            //        this._rubberBandSelector.processExternalUp(e);
            //        this.inputAction(null, e);
            //    }
            this._isMouseDown = false;
            this._isPinching = false;
            this._tripleMode = null;
            this._doubleMode = null;
            //vp.utils.debug("touchMgr: isFinal=" + e.isFinal);
            //---- require a min time between events to filter out finger noise ----
            var lastSessionTime = vp.utils.now() - this._lastSessionFinal;
            if (this._ptDownInChartUx) {
                if (this._maxTouchCount == 1 && this._inputAction == null && lastSessionTime > 500) {
                    this.inputAction("tap", null, e);
                }
            }
            this.inputAction(null, e);
            this._lastSessionFinal = vp.utils.now();
            this.stopWheelTimer();
            var hasInertia = this._transformMgr.onUiOpStop();
            if (this._transformMode != beachParty.ClientTransformMode.none) {
                //var showWheel = (this._transformMode == ClientTransformMode.wheel);
                if (this._wheel.isActive() && !hasInertia) {
                    this._wheel.show(true);
                }
            }
            //---- set focus to CANVAS so that we can hook KEYBOARD events ----
            this._chartUxElem.focus();
        };
        touchMgrClass.prototype.stopWheelTimer = function () {
            if (this._wheelTimer) {
                clearTimeout(this._wheelTimer);
                this._wheelTimer = null;
            }
        };
        touchMgrClass.prototype.startWheelTimer = function () {
            var _this = this;
            this.stopWheelTimer();
            if (this._transformMode != beachParty.ClientTransformMode.none) {
                this._wheelTimer = setTimeout(function (e) {
                    //---- after 500 ms of using wheel, hide it until mouse up ----
                    _this._wheel.show(false);
                }, 500);
            }
        };
        touchMgrClass.prototype.onInput = function (e) {
            var touchCount = e.pointers.length;
            if (e.isFirst) {
                this.onMouseDown(e);
            }
            else {
                if (touchCount > this._maxTouchCount) {
                    this._maxTouchCount = touchCount;
                }
            }
            if (!this._inputAction && this._ptDownInChartUx) {
                this.detectInputAction(e);
            }
            if (this._inputAction == "dragRect") {
                if (e.isFinal) {
                    if (!this._isShowingWheel) {
                        this._rubberBandSelector.processExternalUp(e.srcEvent);
                        this._chart.enableTickBoxUI(true);
                    }
                }
                else {
                    if (!this._isShowingWheel) {
                        this._rubberBandSelector.drawBand(e.srcEvent);
                        //---- workaround for IBeam (text) cursor showing up during drag in Chrome ----
                        vp.dom.css(this._chartUxElem, "cursor", "default");
                    }
                }
            }
            else if (this._inputAction == "percent") {
                var percent = Math.floor(.5 * e.deltaY) / 100;
                if (this._dir == "up") {
                    percent = 1 + percent;
                }
                if (percent < 0) {
                    percent = 0;
                }
                else if (percent > 1) {
                    percent = 1;
                }
                this.inputAction("percent", { value: percent }, e);
            }
            if (e.isFinal) {
                this.onMouseUp(e);
            }
        };
        return touchMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.touchMgrClass = touchMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    attr.ts - manages an attribute mapping for a chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var attrClass = (function (_super) {
        __extends(attrClass, _super);
        function attrClass(chart, md, target, userBinCount) {
            _super.call(this);
            this._mappingChangedCount = 0;
            this._isMappingEnabled = true;
            //---- events ----
            this.onColNameChange = new beachParty.bpEvent();
            this.onMappingDataChange = new beachParty.bpEvent();
            this._chart = chart;
            this._app = chart.getAppMin();
            this._md = md;
            this._target = target;
            if (userBinCount == undefined) {
                userBinCount = md.binCount;
            }
            this._customBreaks = "";
            this._customLabels = "";
            this._sliderBinCount = userBinCount;
            this._userNiceNumbers = false;
            this._limitBinsForStrings = true;
            //---- give each attribute a chance to remember info by column for its context ----
            this._colOptMgr = new beachParty.colOptionMgrClass();
        }
        /**
         *  don't store this since it changes whenever data is loaded (including the first load).
         */
        attrClass.prototype.getDataFrame = function () {
            return this._chart.getDataMgr().getDataFrame();
        };
        attrClass.prototype.isSet = function () {
            return (this._md.colName != null && this._md.colName != "");
        };
        attrClass.prototype.mappingData = function (value) {
            if (arguments.length == 0) {
                return this._md;
            }
            value.attrName = this._md.attrName;
            this._md = value;
            this._sliderBinCount = value.binCount;
            this.onDataChanged("sliderBinCount");
            this.onMappingChanged(true);
            //this.onDataChanged("mappingData");
        };
        attrClass.prototype.colName = function (value, omitLogging, rebindColInfo) {
            var md = this._md;
            if (arguments.length === 0) {
                return md.colName;
            }
            if (md.colName != value) {
                md.colName = value;
                vp.utils.debug("colName set to=" + value);
                //---- this is where all the work happens ----
                this.onColNameChanged();
                if (!omitLogging) {
                    this._app.logAction(beachParty.Gesture.select, null, beachParty.ElementType.picklist, beachParty.Action.adjust, this._target, true, { colName: value });
                }
            }
            if (rebindColInfo) {
                md.boundColInfo = null;
            }
        };
        attrClass.prototype.limitBinsForStrings = function (value) {
            if (arguments.length === 0) {
                return this._limitBinsForStrings;
            }
            this._limitBinsForStrings = value;
            this.onDataChanged("limitBinsForStrings");
        };
        attrClass.prototype.defaultBinCountForColumn = function (colName) {
            var ci = this.getDataFrame().getColInfo(colName);
            if (ci.colType == "string") {
                var maxCount = Math.min(beachParty.chartClass.maxCategoryBins, ci.stats.sortedKeys.length);
                var defaultCount = maxCount;
            }
            else {
                var maxCount = beachParty.chartClass.maxNumericBins;
                var defaultCount = beachParty.chartClass.defaultNumericBins;
            }
            var binCount = this._colOptMgr.getBinCount();
            if (binCount === undefined) {
                binCount = defaultCount;
            }
            return { binCount: binCount, maxCount: maxCount };
        };
        attrClass.prototype.getMaxKeysForColumn = function (colName) {
            var maxKeys = null;
            if (colName) {
                var ci = this.getDataFrame().getColInfo(colName);
                if (ci && ci.colType == "string") {
                    maxKeys = ci.stats.max + 1;
                }
            }
            return maxKeys;
        };
        attrClass.prototype.onColNameChanged = function (forceColRemap, omitOnMappingCall) {
            vp.utils.debug("onColNameChanged...");
            var md = this._md;
            if (this._colOptMgr && md.colName) {
                var opts = this._colOptMgr.getOrMakeOptions(md.colName);
                try {
                    //---- apply column-remembered options when we change our colName ----
                    this._isMappingEnabled = false; // prevent multiple calls during this sequence
                    this.forceCategory(opts.forceCategory, true);
                    this.customBreaks(opts.customBreaks, true);
                    this.useCustomBreaks(opts.useCustomBreaks, true);
                    this.customLabels(opts.customLabels, true);
                    this.useCustomLabels(opts.useCustomLabels, true);
                    this.useNiceNumbers(opts.useNiceNumbers, true);
                    if (opts.binCount !== undefined) {
                        this.binCount(opts.binCount, true);
                    }
                    var strBinSort = beachParty.BinSorting[opts.binSort];
                    this.binSorting(strBinSort, false, true);
                    var strSpread = beachParty.MappingSpread[opts.valueSpread];
                    this.valueSpread(strSpread, true);
                    this.setMappingDataFormatting();
                }
                finally {
                    this._isMappingEnabled = true;
                }
            }
            else {
                //---- reset selected properties when column mapping changed to null ----
                this.binSorting("none", false, false);
            }
            if (!omitOnMappingCall) {
                this.onMappingChanged(true);
            }
            //if (this._jsonPanel)
            //{
            //    this.updateAttrPanel(null);
            //}
            this.onDataChanged("colName");
            this.onColNameChange.trigger({ sender: this, attrName: this._md.attrName, colName: this._md.colName });
        };
        attrClass.prototype.calcCustomBreaks = function () {
            var md = this._md;
            //---- reset these by default ----
            md.breaks = null;
            md.minBreak = undefined;
            md.maxBreak = undefined;
            var cb = this._customBreaks;
            if (cb.contains(":")) {
                //---- min:max ----
                var mm = cb.split(":");
                if (mm.length == 2) {
                    md.minBreak = +mm[0];
                    md.maxBreak = +mm[1];
                }
            }
            else {
                var breaks = this.getCommaSeparatedValues(cb);
                md.breaks = breaks;
            }
        };
        attrClass.prototype.getCommaSeparatedValues = function (str) {
            var values = str.split(",");
            //---- trim each label ----
            for (var i = 0; i < values.length; i++) {
                var value = values[i];
                values[i] = value.trim();
            }
            return values;
        };
        attrClass.prototype.onCustomStuffChanged = function () {
            var md = this._md;
            var attrName = md.attrName;
            md.breaks = null;
            md.labels = null;
            if (this._useCustomBreaks && this._customBreaks) {
                this.calcCustomBreaks();
            }
            //---- see if CUSTOM LABELS have changed ----
            if (this._useCustomLabels && this._customLabels) {
                var labels = this.getCommaSeparatedValues(this._customLabels);
                md.labels = labels;
            }
            this.updateNiceNumbersInMapping(md);
            //---- send change to plot engine ----
            this.onMappingChanged();
        };
        attrClass.prototype.onMappingChanged = function (binCountChanged, omitDataChangedCall) {
            if (this._isMappingEnabled) {
                var md = this._md;
                var attrName = md.attrName;
                this._mappingChangedCount++;
                this.triggerColNameChanged();
                if (!binCountChanged) {
                    this.setBinCountFromDefault(omitDataChangedCall);
                }
                //if (this._chartName == "Line")
                //{
                //    this.sortItemColumn(md.colName);
                //}
                var app = this._chart.getAppMin();
                if (app.updateClusterPanel) {
                    app.updateClusterPanel();
                }
                //vp.utils.debug("attrMgr.onMappingChanged called (name=" + md.attrName + ", count=" + this._mappingChangedCount + ")");
                if (!omitDataChangedCall) {
                    this.triggerOnMappingDataChanged();
                }
            }
        };
        attrClass.prototype.triggerOnMappingDataChanged = function () {
            this.onDataChanged("mappingData");
            this.onMappingDataChange.trigger({ sender: this, attrName: this._md.attrName });
        };
        attrClass.prototype.triggerColNameChanged = function () {
            this.onDataChanged("colName");
        };
        attrClass.prototype.setBinCountFromDefault = function (omitNotify) {
            var md = this._md;
            var attrName = md.attrName;
            var chart = this._chart;
            var usingBins = (attrName == "color" || attrName == "size" || attrName == "shape");
            if (!usingBins) {
                usingBins = chart.isChartUsingBins(md.attrName);
            }
            if (md.colName && usingBins) {
                var result = this.defaultBinCountForColumn(md.colName);
                this.binCount(result.binCount, omitNotify);
            }
        };
        /**
         * The UI for bins is done thru "_sliderBinCount".  This is typically "0" for
         * AUTO or "9" (the default setting for non-AUTO capable attributes).  The actual
         * "binCount" in the _mappingData is the value used to the the mapping (which is never "0").
         * @param value
         * @param omitNotify
         */
        attrClass.prototype.sliderBinCount = function (value, omitNotify) {
            if (arguments.length === 0) {
                return this._sliderBinCount;
            }
            if (value != this._sliderBinCount) {
                this._sliderBinCount = value;
                this.onDataChanged("sliderBinCount");
                //---- remember the binCount the current column mapping ----
                var md = this._md;
                this._colOptMgr.setBinCount(md.colName, value);
                this.setTrueBinCount(value, omitNotify);
            }
        };
        attrClass.prototype.setTrueBinCount = function (value, omitNotify) {
            var md = this._md;
            var attrName = md.attrName;
            //---- set true binCount from value; don't exceed allowable maxKeys ----
            var trueBinCount = value;
            if (this._limitBinsForStrings) {
                var maxKeys = this.getMaxKeysForColumn(md.colName);
                if (maxKeys != null && maxKeys < trueBinCount) {
                    trueBinCount = maxKeys;
                }
            }
            vp.utils.debug(attrName + ": setTrueBinCount(): colName=" + md.colName + ", adjValue=" + trueBinCount);
            this.binCount(trueBinCount, omitNotify);
            //---- send change to plot engine ----
            this.onDataChanged("trueBinCount");
        };
        attrClass.prototype.binCount = function (value, omitNotify) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length === 0) {
                return md.binCount;
            }
            if (value != md.binCount) {
                md.binCount = value;
                this.updateNiceNumbersInMapping(md);
                if (!omitNotify) {
                    this.onMappingChanged(true);
                    this._app.logAction(beachParty.Gesture.dial, null, beachParty.ElementType.dial, beachParty.Action.adjust, this._target, true, { binCount: value });
                    this.onDataChanged("binCount");
                }
            }
        };
        attrClass.prototype.binSorting = function (value, disableNotify, skipOptionUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length === 0) {
                return beachParty.BinSorting[md.binSorting];
            }
            md.binSorting = beachParty.BinSorting[value];
            if (!disableNotify) {
                this.onMappingChanged();
                this.onDataChanged("binSorting");
                var logName = attrName + "BinSort";
                this._app.logAction(beachParty.Gesture.select, attrName + "Bins", beachParty.ElementType.radioButton, beachParty.Action.adjust, beachParty.Target.sortParams, true, { logName: beachParty.BinSorting[value] });
            }
            if (!skipOptionUpdate) {
                this._colOptMgr.setBinSort(md.binSorting);
            }
        };
        attrClass.prototype.setMappingDataFormatting = function () {
            var formatting = null;
            var md = this._md;
            if (md.colName) {
                var pf = this.getDataFrame().getPreloadField(md.colName);
                if (pf) {
                    formatting = pf.formatting;
                }
            }
            md.formatting = formatting;
        };
        attrClass.prototype.forceCategory = function (value, skipOptionUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length == 0) {
                return md.forceCategory;
            }
            md.forceCategory = value;
            this.onMappingChanged();
            this.onDataChanged("forceCategory");
            if (!skipOptionUpdate) {
                this._colOptMgr.setForceCategory(value);
            }
        };
        attrClass.prototype.useNiceNumbers = function (value, omitOptionUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length == 0) {
                //return md.useNiceNumbers;
                return this._userNiceNumbers;
            }
            //---- set these in sync ----
            this._userNiceNumbers = value;
            this.updateNiceNumbersInMapping(md);
            if (!omitOptionUpdate) {
                this._colOptMgr.setUseNiceNumbers(value);
            }
            this.onMappingChanged();
            this.onDataChanged("useNiceNumbers");
        };
        attrClass.prototype.updateNiceNumbersInMapping = function (md) {
            var userBinCount = this._sliderBinCount;
            md.useNiceNumbers = (this._userNiceNumbers || userBinCount == 0 ||
                ((md.minBreak !== undefined) && this._useCustomBreaks));
            md.isBinCountSoft = (userBinCount == 0);
            //---- keep md.binCount non-zero ----
            md.binCount = (userBinCount == 0) ? 9 : userBinCount;
        };
        attrClass.prototype.valueSpread = function (value, omitOptionUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length == 0) {
                return beachParty.MappingSpread[md.spread];
            }
            md.spread = beachParty.MappingSpread[value];
            if (!omitOptionUpdate) {
                this._colOptMgr.setValueSpread(md.spread);
            }
            this.onMappingChanged();
            this.onDataChanged("valueSpread");
        };
        attrClass.prototype.useCustomBreaks = function (value, skipOptUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length == 0) {
                return this._useCustomBreaks;
            }
            this._useCustomBreaks = value;
            if (!skipOptUpdate) {
                this._colOptMgr.setUseCustomBreaks(value);
            }
            this.onCustomStuffChanged();
            this.onDataChanged("useCustomBreaks");
        };
        attrClass.prototype.customBreaks = function (value, skipOptUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length == 0) {
                return this._customBreaks;
            }
            this._customBreaks = value;
            if (!skipOptUpdate) {
                this._colOptMgr.setCustomBreaks(value);
            }
            this.onCustomStuffChanged();
            this.onDataChanged("customBreaks");
        };
        attrClass.prototype.useCustomLabels = function (value, skipOptUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length == 0) {
                return this._useCustomLabels;
            }
            this._useCustomLabels = value;
            if (!skipOptUpdate) {
                this._colOptMgr.setUseCustomLabels(value);
            }
            this.onCustomStuffChanged();
            this.onDataChanged("useCustomLabels");
        };
        attrClass.prototype.customLabels = function (value, skipOptUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length == 0) {
                return this._customLabels;
            }
            this._customLabels = value;
            if (!skipOptUpdate) {
                this._colOptMgr.setCustomLabels(value);
            }
            this.onCustomStuffChanged();
            this.onDataChanged("customLabels");
        };
        attrClass.prototype.isLegendBottomUp = function (value, omitOptionUpdate) {
            var md = this._md;
            if (arguments.length == 0) {
                return md.isLegendBottomUp;
            }
            md.isLegendBottomUp = value;
            if (!omitOptionUpdate) {
                this._colOptMgr.setIsLegendBottomUp(value);
            }
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.isLegendBottomUp, true, { value: value });
            this.onDataChanged("isLegendBottomUp");
        };
        attrClass.prototype.clearForDataChanged = function () {
            var md = this._md;
            md.forceCategory = false;
            md.colName = null;
            var defaultBinCount = beachParty.chartClass.defaultNumericBins;
            md.binCount = defaultBinCount;
            this.triggerColNameChanged();
        };
        return attrClass;
    }(beachParty.dataChangerClass));
    beachParty.attrClass = attrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    auxAttr.ts - manages the AUX attribute (for the SIZE BY and LINE BY grouping).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var auxAttrClass = (function (_super) {
        __extends(auxAttrClass, _super);
        function auxAttrClass(chart, md, target) {
            _super.call(this, chart, md, target);
            this._countLayout = CountLayoutType.grid;
            this._sumLayout = SumLayoutType.squarify;
        }
        auxAttrClass.prototype.countLayout = function (value) {
            if (arguments.length == 0) {
                return CountLayoutType[this._countLayout];
            }
            this._countLayout = CountLayoutType[value];
            this.triggerColNameChanged();
            this.onDataChanged("countLayout");
        };
        auxAttrClass.prototype.sumLayout = function (value) {
            if (arguments.length == 0) {
                return SumLayoutType[this._sumLayout];
            }
            this._sumLayout = SumLayoutType[value];
            this.triggerColNameChanged();
            this.onDataChanged("sumLayout");
        };
        return auxAttrClass;
    }(beachParty.attrClass));
    beachParty.auxAttrClass = auxAttrClass;
    (function (CountLayoutType) {
        CountLayoutType[CountLayoutType["grid"] = 0] = "grid";
        CountLayoutType[CountLayoutType["percent"] = 1] = "percent";
    })(beachParty.CountLayoutType || (beachParty.CountLayoutType = {}));
    var CountLayoutType = beachParty.CountLayoutType;
    (function (SumLayoutType) {
        SumLayoutType[SumLayoutType["squarify"] = 0] = "squarify";
        SumLayoutType[SumLayoutType["strip"] = 1] = "strip";
    })(beachParty.SumLayoutType || (beachParty.SumLayoutType = {}));
    var SumLayoutType = beachParty.SumLayoutType;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chartRouter.ts - routes calls from UI to the currently active chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /**
     *  Would like to remove dynamic method routing to current chart and just use this as the
     *  holder of the current chart.  For now, we still need dynamic method routing for panels
     *  that dynamically connect with current chart.
     */
    var chartRouterClass = (function (_super) {
        __extends(chartRouterClass, _super);
        function chartRouterClass() {
            _super.call(this);
        }
        chartRouterClass.prototype.buildMethodRoutingTable = function (chart) {
            //---- build dynamic routine table ----
            var proto = Object.getPrototypeOf(chart);
            var keys = vp.utils.keys(proto);
            for (var i = 0; i < keys.length; i++) {
                var methodName = keys[i];
                if (methodName != "getChart" && methodName != "setChart") {
                    if (typeof chart[methodName] === "function") {
                        var currentChart = this._chart;
                        this[methodName] = this.makeMethod(methodName);
                    }
                }
            }
        };
        /**
         *  make a unique function that correctly captures the method name.
         * @param name
         */
        chartRouterClass.prototype.makeMethod = function (name) {
            var _this = this;
            return function () {
                var chart = _this.getChart();
                if (chart) {
                    return chart[name].apply(chart, arguments);
                }
            };
        };
        chartRouterClass.prototype.setChart = function (chart) {
            if (!this._chart) {
                //---- first chart ----
                this.buildMethodRoutingTable(chart);
            }
            this._chart = chart;
            this.onDataChanged("chart");
        };
        chartRouterClass.prototype.getChart = function () {
            return this._chart;
        };
        return chartRouterClass;
    }(beachParty.dataChangerClass));
    beachParty.chartRouterClass = chartRouterClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chartUx.ts - manages the user interaction with the chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// each chart gets one of these classes to handle UI events.
    var chartUxClass = (function (_super) {
        __extends(chartUxClass, _super);
        function chartUxClass(app, dataMgr, chart, maxToolTipColumns) {
            var _this = this;
            _super.call(this);
            //---- events ----
            this.onActionDectected = new beachParty.bpEvent();
            this.onCursorHitTest = new beachParty.bpEvent();
            this._app = app;
            this._chart = chart;
            this._toolTipMgr = new beachParty.toolTipMgrClass(app, dataMgr, chart, maxToolTipColumns);
            this.buildRubberBand();
            //---- use root of chart (vs uxElem) so Chrome works correctly ----
            var touchRootElem = chart.rootElement();
            this._touchMgr = new beachParty.touchMgrClass(touchRootElem, this._rubberBandSelector, chart);
            this._touchMgr.onActionDectected.attach(this, function (e) {
                _this.onActionDectected.trigger(e);
            });
            var chartUxElem = chart.chartUxElement();
            this._chartUxElem = chartUxElem;
            vp.select(document.body).attach("contextmenu", function (e) {
                vp.events.cancelEventDefault(e);
                vp.events.cancelEventBubble(e);
            });
            vp.select(document.body).attach("MSHoldVisual", function (e) {
                e.preventDefault;
                vp.events.cancelEventDefault(e);
                vp.events.cancelEventBubble(e);
                return false;
            });
            vp.select(window).attach("mouseup", function (e) { return _this.enableEngineUI(true); });
            var eventElemW = vp.select(this._chart.rootElement()); // chartElemUx
            //---- MOUSE MOVE for tooltips ----
            eventElemW.attach("mousemove", function (e) { return _this.onUxMouseMove(e); });
            //---- MOUSE OUT for turning off tooltips ----
            eventElemW.attach("mouseout", function (e) { return _this.onUxMouseOut(e); });
            //---- KEY DOWN for keyboard commands ----
            vp.select(window).attach("keydown", function (e) { return _this.onKeyDown(e); });
            //---- DBL CLICK for reset transform ----
            eventElemW.attach("dblclick", function (e) { return _this.onDblClick(e); });
            //---- MOUSE WHEEL ----
            eventElemW.attach("mousewheel", function (e) { return _this.onMouseWheel(e); });
            //---- MOUSE OVER for 3D circle ----
            //vp.select("#" + this._iframeId).attach("mouseover", (e) => this.onMouseOver(e));
            //---- CONTEXT MENU for toggling data tips on/off ----
            //vp.select(chartUxElem).attach("contextmenu", (e) => this.onPlotContextMenu(e));
        }
        chartUxClass.prototype.shutDownUI = function () {
            this._touchMgr.isHammerEnabled(false);
        };
        chartUxClass.prototype.postInit = function (transformMgr) {
            //---- delayed 2nd part of init ----
            this._touchMgr.setTransformMgr(transformMgr);
            this.uxMode(UxMode.touch);
        };
        chartUxClass.prototype.onDblClick = function (e) {
            //---- why does animatin get turned off here? ----
            this._chart.resetTransform();
        };
        chartUxClass.prototype.onKeyDown = function (e) {
            //---- TODO: add 3D nav keys here ----
            if (e.keyCode == vp.events.keyCodes.escape) {
                //---- why does animatin get turned off here? ----
                this._chart.resetTransform();
                this._chart.resetDataZoomMode();
            }
        };
        chartUxClass.prototype.enableRubberBand = function (value) {
            if (this._rubberBandSelector) {
                this._rubberBandSelector.isEnabled(value);
            }
        };
        //onPlotContextMenu(e)
        //{
        //    //---- TODO: with TOUCH interface, hover does not get set - fix this so that it works just based on current pt ----
        //    vp.utils.debug("chartUx: onPlotContextMenu called");
        //    this._rubberBandSelector.cancelPendingUpEvent();
        //    //---- force hover info to be updated (especially important for TOUCH interface) ----
        //    this.onUxMouseMove(e, (primaryKey, record) =>
        //    {
        //        var primaryKey = this._chart.hoverPrimaryKey();
        //        //vp.utils.debug("chartUx: onMouseMove callback: primaryKey=" + primaryKey);
        //        if (primaryKey)
        //        {
        //            var dataTipMgr = this._app.getDataTipMgr();
        //            var dataTip = dataTipMgr.getDataTip(primaryKey);
        //            //vp.utils.debug("chartUx: onMouseMove callback: dataTip=" + dataTip);
        //            if (dataTip)
        //            {
        //                //---- REMOVE dataTip ----
        //                dataTipMgr.closeDataTip(dataTip);
        //            }
        //            //else
        //            //{
        //            //    //---- ADD dataTip ----
        //            //    var colName = vp.select("#searchCol").text();
        //            //    var pt = vp.events.mousePosition(e);
        //            //    dataTipMgrClass.instance.addDataTip(colName, pt);
        //            //    vp.events.cancelEventBubble(e);
        //            //    vp.events.cancelEventDefault(e);
        //            //}
        //        }
        //    });
        //}
        chartUxClass.prototype.onMouseWheel = function (e) {
            this._touchMgr.onMouseWheel(e);
        };
        chartUxClass.prototype.onUxMouseOut = function (e, callback) {
            //vp.utils.debug("onUxMouseOut: turning tooltips OFF");
            this._mouseInCanvas = false;
            //this._toolTipMgr.hideToolTip();
            if (this._primaryKey != undefined) {
                this.processPrimaryKeyChanged({}, undefined, false, false, null, null);
            }
        };
        chartUxClass.prototype.screenToPlotCoordinates = function (x, y) {
            //---- make it relative to current PLOT ONLY area ----
            var rc = vp.select(this._chartUxElem).getBounds();
            x -= rc.left;
            y -= rc.top;
            return { x: x, y: y };
        };
        chartUxClass.prototype.onUxMouseMove = function (e, callback) {
            var _this = this;
            /// NOTE: hover information (the current hover shape) is used for both tooltips & the 
            /// hover rending effect (2 separate app options).
            var chart = this._chart;
            if (chart.hasData()) {
                //vp.utils.debug("onUxMouseMove: enabling tooltips");
                this._mouseInCanvas = true;
                var hoverEnabled = (chart.hoverEffect() != "none");
                var tooltipsEnabled = chart.isTooltipsEnabled();
                var hoverOnMoveEnabled = chart.hoverOnMouseMove();
                if (hoverEnabled && (tooltipsEnabled || hoverOnMoveEnabled) && e.buttons != 1) {
                    var screenPos = vp.events.mousePosition(e); //, this._chartUxElem);
                    var plotPos = this.screenToPlotCoordinates(screenPos.x, screenPos.y);
                    //vp.utils.debug("onUxMouseMove: mousePos=" + plotPos.x + ", " + plotPos.y);
                    //---- show tooltips if middle/right mouse button pressed, or if tooltips are enabled ----
                    var getRecord = (e.buttons != 0 || tooltipsEnabled);
                    var colList = this._chart.getActualToolTipColumns();
                    chart.applyHover(plotPos.x, plotPos.y, getRecord, colList, hoverOnMoveEnabled, function (primaryKey, record) {
                        if (_this._primaryKey != primaryKey && _this._mouseInCanvas) {
                            _this.processPrimaryKeyChanged(e, primaryKey, getRecord, tooltipsEnabled, record, colList);
                        }
                        _this.onCursorHitTest.trigger({ sender: _this, x: plotPos.x, y: plotPos.y, primaryKey: primaryKey });
                        if (callback) {
                            callback(primaryKey, record);
                        }
                    });
                }
            }
        };
        chartUxClass.prototype.processPrimaryKeyChanged = function (e, primaryKey, getRecord, tooltipsEnabled, record, colList) {
            var chart = this._chart;
            //vp.utils.debug("processPrimaryKeyChanged: old=" + this._primaryKey + ", new=" + primaryKey);
            this._primaryKey = primaryKey;
            if (chart.hoverOnMouseMove()) {
                chart.hoverPrimaryKey(primaryKey);
            }
            if (primaryKey && (getRecord || tooltipsEnabled)) {
                this._toolTipMgr.showToolTipForShape(e, primaryKey, record, colList);
            }
            else {
                //vp.select(this._chartUxElem).title("");
                this._toolTipMgr.hideToolTip();
            }
        };
        chartUxClass.prototype.enableEngineUI = function (value) {
            var charUxElem = this._chartUxElem;
            vp.select(charUxElem)
                .css("pointer-events", (value) ? "" : "none");
            if (!value) {
                //---- set focus so we can get keyboard events ----
                setTimeout(function (e) { return charUxElem; }, 10);
            }
        };
        chartUxClass.prototype.getTouchMgr = function () {
            return this._touchMgr;
        };
        chartUxClass.prototype.uxMode = function (value) {
            if (arguments.length == 0) {
                return this._uxMode;
            }
            this._uxMode = value;
            this.onUxModeChanged();
        };
        chartUxClass.prototype.onUxModeChanged = function () {
            var uxMode = this._uxMode;
            if (this._touchMgr) {
                this._touchMgr.isHammerEnabled(uxMode == UxMode.touch);
            }
            this.enableRubberBand(uxMode == UxMode.rubberBand);
            this.onDataChanged("uxMode");
        };
        chartUxClass.prototype.buildRubberBand = function () {
            var _this = this;
            var chartUxElem = this._chart.chartUxElement();
            this._rubberBandSelector = new beachParty.rubberBandSelectorClass(chartUxElem, true);
            //---- hook the RECT SELECT event ----
            this._rubberBandSelector.attachOnSelect(function (evt, rcScreen, toggle, mouseDownOrigin) {
                if (_this._chart.hasData() && !_this._chart.isSelectionLocked()) {
                    _this.onRubberBandSelect(evt, rcScreen, toggle, mouseDownOrigin);
                }
            });
            this._rubberBandSelector.registerForChange("mouseDown", function (e) {
                //---- mouse vs touch issue: turn off last tooltip info, or it shows wherever user touches screen (if cursor is over a shape) ----
                //this._chart.hideToolTip();
                _this._rubberBandSelector.forceToggle(_this._chart.isDataZoomMode());
                _this.enableEngineUI(false);
            });
            this._rubberBandSelector.isEnabled(true);
        };
        //getPlotBounds()
        //{
        //    var rc = this._chart.getBounds();
        //    return rc;
        //}
        /**
         * Process the window-relative rectangle coordinates from a drag-rectangle
         * mouse operation.
         * @param evt
         * @param rcBand
         * @param toggle
         * @param mouseDownOrigin
         */
        chartUxClass.prototype.onRubberBandSelect = function (evt, rcScreen, toggle, mouseDownOrigin) {
            //---- for now: "toggle" is set when we drag a rectangle with RIGHT mouse button down ----
            if (rcScreen) {
                //---- convert from screen-relative to plot-relative coordinates ----
                var plotPos = this.screenToPlotCoordinates(rcScreen.left, rcScreen.top);
                var rcPlot = vp.geom.createRect(plotPos.x, plotPos.y, rcScreen.width, rcScreen.height);
                vp.utils.debug("onRubberBandSelect: left=" + rcPlot.left + ", top=" + rcPlot.top +
                    ", width=" + rcPlot.width + ", height = " + rcPlot.height);
                if (this._chart.dragAction() == "zoomIn") {
                    toggle = true;
                }
                if (toggle || this._chart.getIsDataZoomMode()) {
                    var zoomIt = true;
                    if (!this._chart.getIsDataZoomMode()) {
                        //---- watch out for accidental use of right click vs. right drag ----
                        zoomIt = (Math.max(rcScreen.width, rcScreen.height) > 4);
                    }
                    if (zoomIt) {
                        this._chart.dataZoom(rcPlot, false);
                    }
                }
                else {
                    var sd = new beachParty.SelectionDesc();
                    sd.legendSource = "rect drag";
                    sd.rectSelect = rcPlot;
                    //---- todo: push event, not method call ----
                    this._app.setSelectionDesc(sd);
                    this._chart.rectSelect(rcPlot, this._chart.selectMode());
                }
            }
        };
        return chartUxClass;
    }(beachParty.dataChangerClass));
    beachParty.chartUxClass = chartUxClass;
    (function (UxMode) {
        UxMode[UxMode["touch"] = 0] = "touch";
        UxMode[UxMode["rubberBand"] = 1] = "rubberBand";
    })(beachParty.UxMode || (beachParty.UxMode = {}));
    var UxMode = beachParty.UxMode;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    colOptionMgr.ts - manages options for columns.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var colOptionMgrClass = (function (_super) {
        __extends(colOptionMgrClass, _super);
        function colOptionMgrClass() {
            _super.call(this);
            this._optionsByColumn = {};
        }
        colOptionMgrClass.prototype.clear = function () {
            this._optionsByColumn = {};
        };
        colOptionMgrClass.prototype.getOrMakeOptions = function (colName) {
            var opts = null;
            if (true) {
                this._colName = colName;
                opts = this._optionsByColumn[colName];
                if (!opts) {
                    opts = new ColumnOptions();
                    this._optionsByColumn[this._colName] = opts;
                }
            }
            return opts;
        };
        colOptionMgrClass.prototype.setForceCategory = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.forceCategory = value;
        };
        colOptionMgrClass.prototype.getForceCategory = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.forceCategory;
        };
        colOptionMgrClass.prototype.setBinSort = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.binSort = value;
        };
        colOptionMgrClass.prototype.getBinSort = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.binSort;
        };
        colOptionMgrClass.prototype.setBinCount = function (colName, count) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.binCount = count;
        };
        colOptionMgrClass.prototype.getBinCount = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.binCount;
        };
        colOptionMgrClass.prototype.setUseCustomBreaks = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.useCustomBreaks = value;
        };
        colOptionMgrClass.prototype.getUseCustomBreaks = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.useCustomBreaks;
        };
        colOptionMgrClass.prototype.setCustomBreaks = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.customBreaks = value;
        };
        colOptionMgrClass.prototype.getCustomBreaks = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.customBreaks;
        };
        colOptionMgrClass.prototype.setUseCustomLabels = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.useCustomLabels = value;
        };
        colOptionMgrClass.prototype.getUseCustomLabels = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.useCustomLabels;
        };
        colOptionMgrClass.prototype.setCustomLabels = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.customLabels = value;
        };
        colOptionMgrClass.prototype.getCustomLabels = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.customLabels;
        };
        colOptionMgrClass.prototype.setUseNiceNumbers = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.useNiceNumbers = value;
        };
        colOptionMgrClass.prototype.getUseNiceNumbers = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.useNiceNumbers;
        };
        colOptionMgrClass.prototype.setValueSpread = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.valueSpread = value;
        };
        colOptionMgrClass.prototype.getValueSpread = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.valueSpread;
        };
        colOptionMgrClass.prototype.setIsLegendBottomUp = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.isLegendBottomUp = value;
        };
        colOptionMgrClass.prototype.getIsLegendBottomUp = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.isLegendBottomUp;
        };
        return colOptionMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.colOptionMgrClass = colOptionMgrClass;
    //---- per column options for session (not persisted) ----
    var ColumnOptions = (function () {
        function ColumnOptions() {
            this.binCount = undefined;
            this.binSort = beachParty.BinSorting.none;
            this.valueSpread = beachParty.MappingSpread.normal;
            this.customBreaks = "";
            this.customLabels = "";
        }
        return ColumnOptions;
    }());
    beachParty.ColumnOptions = ColumnOptions;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    colorAttr.ts - manages a single copy of the COLOR attribute for a chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var colorAttrClass = (function (_super) {
        __extends(colorAttrClass, _super);
        function colorAttrClass(app, chart, md, target, userBinCount) {
            if (userBinCount === void 0) { userBinCount = 0; }
            _super.call(this, chart, md, target, userBinCount);
            this._app = app;
            this._colorColOptMgr = new beachParty.colorColOptionMgrClass(chart.getDataMgr());
            this._colOptMgr = this._colorColOptMgr; // copy for baseclass
            this._colOptMgr.getOrMakeOptions(null);
            this._paletteMgr = app.getPaletteMgr();
        }
        colorAttrClass.prototype.setCustomPalette = function (palette) {
            var md = this._md;
            md.paletteName = "custom";
            md.paletteSetName = null;
            md.colorPalette = palette;
            this.onMappingChanged(false, true);
        };
        /**
         * If stepsRequested==0, compute an automatic value that gives nice results for numeric and date values.  For
           category, use 999 to allow all numbers to show
         */
        colorAttrClass.prototype.stepsRequested = function () {
            var md = this._md;
            var sr = this._sliderBinCount; //  md.colorSteps;
            return sr;
        };
        colorAttrClass.prototype.onMappingChanged = function (rebuildPalette, rebindColInfo) {
            if (this._isMappingEnabled) {
                var cm = this._md;
                var app = this._app;
                _super.prototype.onMappingChanged.call(this, false, true);
                if (this.isSet()) {
                    if (this.isSet() && (!cm.colorPalette || !cm.breaks)) {
                        rebuildPalette = true;
                    }
                    if (rebuildPalette) {
                        cm.breaks = null;
                    }
                    if (rebuildPalette && cm.paletteSetName) {
                        var palette = this._paletteMgr.getPaletteFromSettings(cm.paletteSetName, cm.paletteName, this.stepsRequested(), cm.isReversed, cm.isInverted);
                        cm.colorPalette = palette.values;
                    }
                    //---- use the currently bound FILTERED-IN data set, if available ----
                    var colInfo = cm.boundColInfo;
                    if (rebindColInfo || !colInfo || colInfo.name != cm.colName) {
                        //---- REBIND colInfo to current filter setting ----
                        colInfo = this.getDataFrame().getColInfo(cm.colName);
                        cm.boundColInfo = colInfo;
                    }
                    if (rebuildPalette || rebindColInfo) {
                        beachParty.paletteHelper.buildColorBreaks(cm, colInfo, this._chart.getUseNiceNumbers());
                    }
                }
                //---- push change to UI ----
                vp.select("#colorText")
                    .css("font-style", (cm.colName) ? "italic" : "normal");
                this.triggerOnMappingDataChanged();
                this.onDataChanged("rebuildColorPaletteList");
            }
        };
        colorAttrClass.prototype.getNamedPaletteFromSet = function (setName, name) {
            var cm = this._md;
            var app = this._app;
            name = name.toLowerCase();
            var pa = this._paletteMgr.getPaletteArray(setName, this.stepsRequested(), cm.isReversed, cm.isInverted);
            var palettes = pa.palettes;
            var palette = null;
            for (var i = 0; i < palettes.length; i++) {
                var pal = palettes[i];
                if (pal.name.toLowerCase() == name) {
                    palette = pal;
                    break;
                }
            }
            return palette;
        };
        colorAttrClass.prototype.setPaletteFromName = function (name, omitOptionUpdate) {
            var cm = this._md;
            var app = this._app;
            var pm = this._paletteMgr;
            if (this.isSet()) {
                //---- first try current palette set ----
                var setName = cm.paletteSetName;
                var palette = this.getNamedPaletteFromSet(setName, name);
                if (!palette) {
                    //---- try the other palette sets ----
                    //var setNames = app.getPaletteItems();
                    var setNames = this._paletteMgr.getPaletteItems();
                    for (var i = 0; i < setNames.length; i++) {
                        var setName = setNames[i];
                        if (setName != cm.paletteSetName) {
                            palette = this.getNamedPaletteFromSet(setName, name);
                            if (palette) {
                                break;
                            }
                        }
                    }
                }
                if (!omitOptionUpdate) {
                    this._colorColOptMgr.setPaletteName(name);
                }
                if (palette) {
                    if (setName != cm.paletteSetName) {
                        this.paletteSetName(setName);
                    }
                    this.colorPalette(palette);
                }
            }
        };
        colorAttrClass.prototype.onColNameChanged = function () {
            //---- do normal work ----
            _super.prototype.onColNameChanged.call(this, false, true);
            //---- update COLOR settings per new column ----
            var md = this._md;
            var opts = this._colOptMgr.getOrMakeOptions(md.colName);
            try {
                //---- apply column-remembered options when we change our colName ----
                this._isMappingEnabled = false; // prevent multiple calls during this sequence
                this.paletteSetName(opts.paletteSetName, true);
                this.setPaletteFromName(opts.paletteName, true);
                this.reverseColorPalette(opts.reverseColorPalette, true);
                this.invertColorPalette(opts.invertColorPalette, true);
                this.colorIsContinuous(opts.colorIsContinuous, true);
                this.colorIsCycling(opts.colorIsCycling, true);
                this.redColumn(opts.redColumn, true);
                this.greenColumn(opts.greenColumn, true);
                this.blueColumn(opts.blueColumn, true);
                this.rgbColumn(opts.rgbColumn, true);
                this.zapColorChannels();
                this.onMappingChanged(true, true);
            }
            finally {
                this._isMappingEnabled = true;
                this.onMappingChanged(true);
            }
        };
        colorAttrClass.prototype.zapColorChannels = function () {
            var cm = this._md;
            cm.channelMapping = null;
            this.onDataChanged("redColumn");
            this.onDataChanged("greenColumn");
            this.onDataChanged("blueColumn");
            this.onDataChanged("rgbColumn");
        };
        colorAttrClass.prototype.colorPaletteIndex = function (index) {
            this._paletteMgr.colorPaletteIndex(this, index);
        };
        colorAttrClass.prototype.getColorPaletteEntry = function (index) {
            return this._paletteMgr.getColorPaletteEntry(this, index);
        };
        colorAttrClass.prototype.remapColorData = function () {
            this.onMappingChanged(true, true);
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.button, beachParty.Action.remap, beachParty.Target.colorMapping, true);
        };
        //onColorMappingChanged(rebuildPalette: boolean, rebindColInfo?: boolean)
        //{
        //    this.onMappingChanged(rebuildPalette, rebindColInfo);
        //}
        colorAttrClass.prototype.colorSpread = function (value) {
            var cm = this._md;
            if (arguments.length == 0) {
                return beachParty.MappingSpread[cm.spread];
            }
            cm.spread = beachParty.MappingSpread[value];
            this.onDataChanged("spread");
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.colorSpread, true, { value: value });
            //---- zap the color channel info ----
            this.zapColorChannels();
            this.onMappingChanged(false);
        };
        colorAttrClass.prototype.colorForceCategory = function (value) {
            var cm = this._md;
            if (arguments.length == 0) {
                return cm.forceCategory;
            }
            cm.forceCategory = value;
            this.onDataChanged("forceCategory");
            this.onMappingChanged(false);
        };
        colorAttrClass.prototype.reverseColorPalette = function (value, omitOptionUpdate) {
            var cm = this._md;
            if (arguments.length == 0) {
                return cm.isReversed;
            }
            cm.isReversed = value;
            this.onDataChanged("reverseColorPalette");
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.colorReverse, true, { value: value });
            if (!omitOptionUpdate) {
                this._colorColOptMgr.setReverseColorPalette(value);
            }
            //---- zap the color channel info ----
            this.zapColorChannels();
            this.onMappingChanged(true);
        };
        colorAttrClass.prototype.invertColorPalette = function (value, omitOptionUpdate) {
            var cm = this._md;
            if (arguments.length == 0) {
                return cm.isInverted;
            }
            cm.isInverted = value;
            this.onDataChanged("invertColorPalette");
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.colorInvert, true, { value: value });
            if (!omitOptionUpdate) {
                this._colorColOptMgr.setInvertColorPalette(value);
            }
            //---- zap the color channel info ----
            this.zapColorChannels();
            this.onMappingChanged(true);
        };
        colorAttrClass.prototype.colorIsContinuous = function (value, omitOptionUpdate) {
            var cm = this._md;
            if (arguments.length == 0) {
                return cm.isContinuous;
            }
            cm.isContinuous = value;
            this.onDataChanged("colorIsContinuous");
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.colorContinuous, true, { value: value });
            if (!omitOptionUpdate) {
                this._colorColOptMgr.setColorIsContinuous(value);
            }
            //---- zap the color channel info ----
            this.zapColorChannels();
            this.onMappingChanged(false);
        };
        colorAttrClass.prototype.colorIsCycling = function (value, omitOptionUpdate) {
            var cm = this._md;
            if (arguments.length == 0) {
                return cm.isCycling;
            }
            cm.isCycling = value;
            this.onDataChanged("colorIsCycling");
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.colorCycling, true, { value: value });
            if (!omitOptionUpdate) {
                this._colorColOptMgr.setColorIsCycling(value);
            }
            //---- zap the color channel info ----
            this.zapColorChannels();
            this.onMappingChanged(true);
        };
        colorAttrClass.prototype.redColumn = function (value, omitOptionUpdate) {
            var cm = this._md;
            var ch = cm.channelMapping;
            if (arguments.length == 0) {
                var col = (ch && ch.redColumn) ? ch.redColumn : "";
                return col;
            }
            if (!value && !ch) {
            }
            else {
                if (!omitOptionUpdate) {
                    this._colorColOptMgr.setRedColumn(value);
                }
                if (!ch) {
                    ch = new beachParty.ChannelMappingData;
                    cm.channelMapping = ch;
                }
                ch.redColumn = value;
                this.onDataChanged("redColumn");
                this._app.logAction(beachParty.Gesture.select, "redCol", beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.channelMapping, true, { red: value != null });
                this.onChannelColumnChanged();
            }
        };
        colorAttrClass.prototype.onChannelColumnChanged = function () {
            var cm = this._md;
            var channelIsActive = false;
            if (cm.channelMapping) {
                var cmx = cm.channelMapping;
                if (cmx.redColumn || cmx.greenColumn || cmx.blueColumn || cmx.rgbColumn) {
                    channelIsActive = true;
                }
            }
            if (channelIsActive) {
                //---- zap the colName ----
                cm.colName = null;
                //---- zap the paletteName ----
                //cm.paletteName = null;
                this.onDataChanged("colorPalette");
            }
            else {
                //---- zap the channel ----
                this.zapColorChannels();
            }
            this.onDataChanged("colorColumn");
            this.onMappingChanged(false);
        };
        colorAttrClass.prototype.greenColumn = function (value, omitOptionUpdate) {
            var cm = this._md;
            var ch = cm.channelMapping;
            if (arguments.length == 0) {
                var col = (ch && ch.greenColumn) ? ch.greenColumn : "";
                return col;
            }
            if (!value && !ch) {
            }
            else {
                if (!omitOptionUpdate) {
                    this._colorColOptMgr.setGreenColumn(value);
                }
                if (!ch) {
                    ch = new beachParty.ChannelMappingData;
                    cm.channelMapping = ch;
                }
                ch.greenColumn = value;
                this.onDataChanged("greenColumn");
                this._app.logAction(beachParty.Gesture.select, "greenCol", beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.channelMapping, true, { green: value != null });
                this.onChannelColumnChanged();
            }
        };
        colorAttrClass.prototype.blueColumn = function (value, omitOptionUpdate) {
            var cm = this._md;
            var ch = cm.channelMapping;
            if (arguments.length == 0) {
                var col = (ch && ch.blueColumn) ? ch.blueColumn : "";
                return col;
            }
            if (!value && !ch) {
            }
            else {
                if (!omitOptionUpdate) {
                    this._colorColOptMgr.setBlueColumn(value);
                }
                if (!ch) {
                    ch = new beachParty.ChannelMappingData;
                    cm.channelMapping = ch;
                }
                ch.blueColumn = value;
                this.onDataChanged("blueColumn");
                this._app.logAction(beachParty.Gesture.select, "blueCol", beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.channelMapping, true, { blue: value != null });
                this.onChannelColumnChanged();
            }
        };
        colorAttrClass.prototype.rgbColumn = function (value, omitOptionUpdate) {
            var cm = this._md;
            var ch = cm.channelMapping;
            if (arguments.length == 0) {
                var col = (ch && ch.rgbColumn) ? ch.rgbColumn : "";
                return col;
            }
            if (!value && !ch) {
            }
            else {
                if (!omitOptionUpdate) {
                    this._colorColOptMgr.setRgbColumn(value);
                }
                if (!ch) {
                    ch = new beachParty.ChannelMappingData;
                    cm.channelMapping = ch;
                }
                ch.rgbColumn = value;
                this.onDataChanged("rgbColumn");
                this._app.logAction(beachParty.Gesture.select, "rgbColumn", beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.channelMapping, true, { rgb: value != null });
                this.onChannelColumnChanged();
            }
        };
        //---- supports the palettePicker in the color panel ----
        colorAttrClass.prototype.paletteSetName = function (value, omitOptionUpdate) {
            var cm = this._md;
            if (arguments.length == 0) {
                var setName = (cm.paletteSetName) ? cm.paletteSetName : "Sequential";
                return setName;
            }
            cm.paletteSetName = value;
            if (!omitOptionUpdate) {
                this._colorColOptMgr.setPaletteSetName(value);
            }
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.picklist, beachParty.Action.select, beachParty.Target.paletteSetPickList, true);
            //---- tell the color panel that a user action just happened ----
            //var panel = this._panelMgr.getPanel("colorPanel");
            //panel.onUserAction(null, false);
            this.onDataChanged("rebuildColorPaletteList");
            this.onDataChanged("paletteSetName");
        };
        colorAttrClass.prototype.colorPalette = function (value, omitOptionUpdate) {
            var cm = this._md;
            if (arguments.length == 0) {
                //---- hide colorPalette name when channel mapping is active ----
                return (cm.channelMapping) ? "" : cm.colorPalette;
            }
            cm.colorPalette = value.values;
            cm.paletteName = value.name;
            if (!omitOptionUpdate) {
                this._colorColOptMgr.setPaletteName(value.name);
            }
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.colorPalette, true, { setName: cm.paletteSetName, paletteName: cm.paletteName });
            this.onDataChanged("colorPalette");
            //this.onDataChanged("paletteName");
            //---- zap the color channel info ----
            this.zapColorChannels();
            this.onMappingChanged(true); // false);
        };
        return colorAttrClass;
    }(beachParty.attrClass));
    beachParty.colorAttrClass = colorAttrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    colorColOptionMgr.ts - manages options for COLOR columns.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var colorColOptionMgrClass = (function (_super) {
        __extends(colorColOptionMgrClass, _super);
        function colorColOptionMgrClass(dataMgr) {
            _super.call(this);
            this._dataMgr = dataMgr;
        }
        colorColOptionMgrClass.prototype.setDefaultOptions = function (opts, psSetName, paletteName) {
            opts.paletteSetName = psSetName;
            opts.paletteName = paletteName;
            opts.paletteIndex = undefined; // not yet set
        };
        colorColOptionMgrClass.prototype.setDefaultOptionsByColType = function (colName, opts) {
            if (colName) {
                var dataFrame = this._dataMgr.getDataFrame();
                var colInfo = dataFrame.getColInfo(colName);
                var colType = (colInfo) ? colInfo.colType : "string";
                if (colType == "string") {
                    this.setDefaultOptions(opts, "Qualitative", "Paired");
                }
                else if (colType == "date") {
                    this.setDefaultOptions(opts, "Sequential", "Blues");
                }
                else {
                    this.setDefaultOptions(opts, "Diverging", "RdBu");
                }
            }
        };
        colorColOptionMgrClass.prototype.getOrMakeOptions = function (colName) {
            var opts = null;
            if (true) {
                this._colName = colName;
                opts = this._optionsByColumn[colName];
                if (!opts) {
                    opts = new ColorColumnOptions();
                    this._optionsByColumn[this._colName] = opts;
                    this.setDefaultOptionsByColType(this._colName, opts);
                }
            }
            return opts;
        };
        colorColOptionMgrClass.prototype.setPaletteSetName = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.paletteSetName = value;
        };
        colorColOptionMgrClass.prototype.getPaletteSetName = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.paletteSetName;
        };
        colorColOptionMgrClass.prototype.setPaletteName = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.paletteName = value;
        };
        colorColOptionMgrClass.prototype.getPaletteName = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.paletteName;
        };
        colorColOptionMgrClass.prototype.setPaletteIndex = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.paletteIndex = value;
        };
        colorColOptionMgrClass.prototype.getPaletteIndex = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.paletteIndex;
        };
        colorColOptionMgrClass.prototype.setReverseColorPalette = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.reverseColorPalette = value;
        };
        colorColOptionMgrClass.prototype.getReverseColorPalette = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.reverseColorPalette;
        };
        colorColOptionMgrClass.prototype.setInvertColorPalette = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.invertColorPalette = value;
        };
        colorColOptionMgrClass.prototype.getInvertColorPalette = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.invertColorPalette;
        };
        colorColOptionMgrClass.prototype.setColorIsContinuous = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.colorIsContinuous = value;
        };
        colorColOptionMgrClass.prototype.getColorIsContiuous = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.colorIsContinuous;
        };
        colorColOptionMgrClass.prototype.setColorIsCycling = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.colorIsCycling = value;
        };
        colorColOptionMgrClass.prototype.getColorIsCycling = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.colorIsCycling;
        };
        colorColOptionMgrClass.prototype.setRedColumn = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.redColumn = value;
        };
        colorColOptionMgrClass.prototype.getRedColumn = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.redColumn;
        };
        colorColOptionMgrClass.prototype.setGreenColumn = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.greenColumn = value;
        };
        colorColOptionMgrClass.prototype.getGreenColumn = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.greenColumn;
        };
        colorColOptionMgrClass.prototype.setBlueColumn = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.blueColumn = value;
        };
        colorColOptionMgrClass.prototype.getBlueColumn = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.blueColumn;
        };
        colorColOptionMgrClass.prototype.setRgbColumn = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.rgbColumn = value;
        };
        colorColOptionMgrClass.prototype.getRgbColumn = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.rgbColumn;
        };
        return colorColOptionMgrClass;
    }(beachParty.colOptionMgrClass));
    beachParty.colorColOptionMgrClass = colorColOptionMgrClass;
    //---- per column options for session (not persisted) ----
    var ColorColumnOptions = (function (_super) {
        __extends(ColorColumnOptions, _super);
        function ColorColumnOptions() {
            _super.call(this);
        }
        return ColorColumnOptions;
    }(beachParty.ColumnOptions));
    beachParty.ColorColumnOptions = ColorColumnOptions;
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chartInterfaces.ts - interafaces and min classes for BeachParty chart class.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var KeyInfo = (function () {
        function KeyInfo(keyCount, indexesByKey, keysByIndex, rowsByKey, keysByRow, sortedKeys) {
            this.keyCount = keyCount;
            this.indexesByKey = indexesByKey;
            this.keysByIndex = keysByIndex;
            this.rowsByKey = rowsByKey;
            this.keysByRow = keysByRow;
            this.sortedKeys = sortedKeys;
        }
        return KeyInfo;
    }());
    beachParty.KeyInfo = KeyInfo;
    var NamedPalette = (function () {
        function NamedPalette(name, values) {
            this.name = name;
            this.values = values;
        }
        return NamedPalette;
    }());
    beachParty.NamedPalette = NamedPalette;
    var appMinClass = (function () {
        function appMinClass() {
        }
        appMinClass.prototype.logAction = function (gesture, elementId, elementType, action, target, isUndoable, options, forceLog, nonLogOptions) {
        };
        appMinClass.prototype.getBlankValueStr = function () {
            return "<blank>";
        };
        appMinClass.prototype.getPaletteMgr = function () {
            return null;
        };
        //layoutScreen();
        appMinClass.prototype.getDataTipMgr = function () {
            return null;
        };
        appMinClass.prototype.getAppSettingsMgr = function () {
            return null;
        };
        appMinClass.prototype.getPanelMaster = function () {
            return null;
        };
        appMinClass.prototype.setSelectionDesc = function (selectDesc) {
            return null;
        };
        appMinClass.prototype.isLoggingEnabled = function (value) {
            return false;
        };
        return appMinClass;
    }());
    beachParty.appMinClass = appMinClass;
    var SpiralParams = (function () {
        function SpiralParams() {
            this.seed = 137.508;
        }
        return SpiralParams;
    }());
    beachParty.SpiralParams = SpiralParams;
    var ScatterParams = (function () {
        function ScatterParams(percentExpandX, percentExpandY) {
            if (percentExpandX === void 0) { percentExpandX = .5; }
            if (percentExpandY === void 0) { percentExpandY = .5; }
            this.percentExpandX = percentExpandX;
            this.percentExpandY = percentExpandY;
        }
        return ScatterParams;
    }());
    beachParty.ScatterParams = ScatterParams;
    var FlatParams = (function () {
        function FlatParams() {
            this.numColumns = 0; // not yet specified
            this.buildFromTop = false;
        }
        return FlatParams;
    }());
    beachParty.FlatParams = FlatParams;
    var SelectionParams = (function () {
        function SelectionParams() {
            this.unselectedParams = new beachParty.ColorParams(beachParty.ColorEffect.adjustSaturation, "yellow", .20);
            this.selectedParams = new beachParty.ColorParams(beachParty.ColorEffect.setColor, "yellow", .20);
        }
        return SelectionParams;
    }());
    beachParty.SelectionParams = SelectionParams;
    /**
     *  Describe a draw/animation cycle that is beginning.
     */
    var CycleDesc = (function () {
        function CycleDesc() {
        }
        return CycleDesc;
    }());
    beachParty.CycleDesc = CycleDesc;
    /**
     *  Informaton about a draw/animation cycle that has just ended.
     */
    var CycleStats = (function (_super) {
        __extends(CycleStats, _super);
        function CycleStats() {
            _super.apply(this, arguments);
        }
        return CycleStats;
    }(beachParty.ShapeStats));
    beachParty.CycleStats = CycleStats;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    lineAttr.ts - manages the LINE attribute for a chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var lineAttrClass = (function (_super) {
        __extends(lineAttrClass, _super);
        function lineAttrClass(chart, md, target) {
            _super.call(this, chart, md, target);
        }
        lineAttrClass.prototype.maxLineShapes = function (value, omitLogging) {
            var lm = this._md;
            if (arguments.length == 0) {
                return lm.maxShapes;
            }
            lm.maxShapes = value;
            this.onMappingChanged();
            if (!omitLogging) {
                this._app.logAction(beachParty.Gesture.drag, null, beachParty.ElementType.slider, beachParty.Action.adjust, beachParty.Target.lineMapping, true, { maxShapes: value });
            }
            this.onDataChanged("maxLineShapes");
        };
        lineAttrClass.prototype.lineColor = function (value, omitLogging) {
            var lm = this._md;
            if (arguments.length == 0) {
                return lm.color;
            }
            lm.color = value;
            this.onMappingChanged();
            if (!omitLogging) {
                this._app.logAction(beachParty.Gesture.select, null, beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.lineMapping, true, { lineColor: value });
            }
            this.onDataChanged("lineColor");
        };
        return lineAttrClass;
    }(beachParty.attrClass));
    beachParty.lineAttrClass = lineAttrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    logging.ts - defines structures needed for logging.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    //---- event logging enums - for consistent names ----
    (function (Gesture) {
        Gesture[Gesture["chatBot"] = 0] = "chatBot";
        Gesture[Gesture["click"] = 1] = "click";
        Gesture[Gesture["dblClick"] = 2] = "dblClick";
        Gesture[Gesture["dial"] = 3] = "dial";
        Gesture[Gesture["drag"] = 4] = "drag";
        Gesture[Gesture["editText"] = 5] = "editText";
        Gesture[Gesture["keyDown"] = 6] = "keyDown";
        Gesture[Gesture["none"] = 7] = "none";
        Gesture[Gesture["select"] = 8] = "select";
        Gesture[Gesture["system"] = 9] = "system";
        Gesture[Gesture["automatedTest"] = 10] = "automatedTest";
        Gesture[Gesture["notAvailable"] = 11] = "notAvailable";
    })(beachParty.Gesture || (beachParty.Gesture = {}));
    var Gesture = beachParty.Gesture;
    (function (ElementType) {
        ElementType[ElementType["button"] = 0] = "button";
        ElementType[ElementType["checkbox"] = 1] = "checkbox";
        ElementType[ElementType["canvas"] = 2] = "canvas";
        ElementType[ElementType["none"] = 3] = "none";
        ElementType[ElementType["dial"] = 4] = "dial";
        ElementType[ElementType["insightEntry"] = 5] = "insightEntry";
        ElementType[ElementType["menuItem"] = 6] = "menuItem";
        ElementType[ElementType["numAdjuster"] = 7] = "numAdjuster";
        ElementType[ElementType["slider"] = 8] = "slider";
        ElementType[ElementType["textBox"] = 9] = "textBox";
        ElementType[ElementType["panelTitle"] = 10] = "panelTitle";
        ElementType[ElementType["picklist"] = 11] = "picklist";
        ElementType[ElementType["radioButton"] = 12] = "radioButton";
        ElementType[ElementType["resizer"] = 13] = "resizer";
        ElementType[ElementType["notAvailable"] = 14] = "notAvailable";
    })(beachParty.ElementType || (beachParty.ElementType = {}));
    var ElementType = beachParty.ElementType;
    (function (Action) {
        Action[Action["add"] = 0] = "add";
        Action[Action["adjust"] = 1] = "adjust";
        Action[Action["capture"] = 2] = "capture";
        Action[Action["clear"] = 3] = "clear";
        Action[Action["close"] = 4] = "close";
        Action[Action["create"] = 5] = "create";
        Action[Action["delete"] = 6] = "delete";
        Action[Action["edit"] = 7] = "edit";
        Action[Action["email"] = 8] = "email";
        Action[Action["export"] = 9] = "export";
        Action[Action["hide"] = 10] = "hide";
        Action[Action["import"] = 11] = "import";
        Action[Action["load"] = 12] = "load";
        Action[Action["open"] = 13] = "open";
        Action[Action["pause"] = 14] = "pause";
        Action[Action["play"] = 15] = "play";
        Action[Action["publish"] = 16] = "publish";
        Action[Action["remap"] = 17] = "remap";
        Action[Action["rename"] = 18] = "rename";
        Action[Action["report"] = 19] = "report";
        Action[Action["resume"] = 20] = "resume";
        Action[Action["select"] = 21] = "select";
        Action[Action["show"] = 22] = "show";
        Action[Action["start"] = 23] = "start";
        Action[Action["stop"] = 24] = "stop";
    })(beachParty.Action || (beachParty.Action = {}));
    var Action = beachParty.Action;
    (function (Target) {
        //---- panels ----
        Target[Target["aboutPanel"] = 0] = "aboutPanel";
        Target[Target["aggPanel"] = 1] = "aggPanel";
        Target[Target["appSettings"] = 2] = "appSettings";
        Target[Target["botPanel"] = 3] = "botPanel";
        Target[Target["browsePanel"] = 4] = "browsePanel";
        Target[Target["channelMapping"] = 5] = "channelMapping";
        Target[Target["chartOptions"] = 6] = "chartOptions";
        //chartOptionsPanel,
        Target[Target["chartTitle"] = 7] = "chartTitle";
        Target[Target["colorContinuous"] = 8] = "colorContinuous";
        Target[Target["colorCycling"] = 9] = "colorCycling";
        Target[Target["colorInvert"] = 10] = "colorInvert";
        Target[Target["colorPalette"] = 11] = "colorPalette";
        Target[Target["colorPanel"] = 12] = "colorPanel";
        Target[Target["colorReverse"] = 13] = "colorReverse";
        Target[Target["colorSpread"] = 14] = "colorSpread";
        Target[Target["clusterPanel"] = 15] = "clusterPanel";
        Target[Target["currentPanel"] = 16] = "currentPanel";
        Target[Target["datasetPanel"] = 17] = "datasetPanel";
        Target[Target["dataTip"] = 18] = "dataTip";
        Target[Target["detailsPanel"] = 19] = "detailsPanel";
        Target[Target["documentSize"] = 20] = "documentSize";
        Target[Target["facetPanel"] = 21] = "facetPanel";
        //feedback,
        //feedbackPanel,
        Target[Target["filterPanel"] = 22] = "filterPanel";
        Target[Target["frameStats"] = 23] = "frameStats";
        Target[Target["helpPanel"] = 24] = "helpPanel";
        Target[Target["imageMapping"] = 25] = "imageMapping";
        Target[Target["imagePanel"] = 26] = "imagePanel";
        Target[Target["insights"] = 27] = "insights";
        Target[Target["insightPanel"] = 28] = "insightPanel";
        Target[Target["itemsPanel"] = 29] = "itemsPanel";
        Target[Target["isLegendBottomUp"] = 30] = "isLegendBottomUp";
        Target[Target["layersPanel"] = 31] = "layersPanel";
        Target[Target["lineByPanel"] = 32] = "lineByPanel";
        Target[Target["navPanel"] = 33] = "navPanel";
        Target[Target["palettesPanel"] = 34] = "palettesPanel";
        Target[Target["paletteSetPickList"] = 35] = "paletteSetPickList";
        Target[Target["panelLocation"] = 36] = "panelLocation";
        Target[Target["panelSize"] = 37] = "panelSize";
        Target[Target["panelPin"] = 38] = "panelPin";
        Target[Target["panelTab"] = 39] = "panelTab";
        Target[Target["scriptsPanel"] = 40] = "scriptsPanel";
        Target[Target["searchPanel"] = 41] = "searchPanel";
        Target[Target["selectionPanel"] = 42] = "selectionPanel";
        Target[Target["settingsPanel"] = 43] = "settingsPanel";
        Target[Target["shapePanel"] = 44] = "shapePanel";
        Target[Target["sizePanel"] = 45] = "sizePanel";
        Target[Target["slicerPanel"] = 46] = "slicerPanel";
        Target[Target["snapshot"] = 47] = "snapshot";
        Target[Target["sortItemColumn"] = 48] = "sortItemColumn";
        Target[Target["sortParams"] = 49] = "sortParams";
        Target[Target["sortPanel"] = 50] = "sortPanel";
        Target[Target["sumPanel"] = 51] = "sumPanel";
        Target[Target["tasksPanel"] = 52] = "tasksPanel";
        Target[Target["textPanel"] = 53] = "textPanel";
        Target[Target["themesPanel"] = 54] = "themesPanel";
        Target[Target["timePanel"] = 55] = "timePanel";
        Target[Target["tipsPanel"] = 56] = "tipsPanel";
        Target[Target["tourLoaderPanel"] = 57] = "tourLoaderPanel";
        Target[Target["tourStep"] = 58] = "tourStep";
        Target[Target["unknownPanel"] = 59] = "unknownPanel";
        Target[Target["userResource"] = 60] = "userResource";
        Target[Target["xPanel"] = 61] = "xPanel";
        Target[Target["yPanel"] = 62] = "yPanel";
        Target[Target["zPanel"] = 63] = "zPanel";
        //---- menus ----
        Target[Target["insightMenu"] = 64] = "insightMenu";
        //---- dropdown picklists ----
        Target[Target["columnPicker"] = 65] = "columnPicker";
        Target[Target["chartPicker"] = 66] = "chartPicker";
        Target[Target["layoutPicker"] = 67] = "layoutPicker";
        //---- data ----
        Target[Target["data"] = 68] = "data";
        Target[Target["selection"] = 69] = "selection";
        Target[Target["filter"] = 70] = "filter";
        Target[Target["filterAndSelection"] = 71] = "filterAndSelection";
        //---- attributes ----
        Target[Target["xMapping"] = 72] = "xMapping";
        Target[Target["yMapping"] = 73] = "yMapping";
        Target[Target["zMapping"] = 74] = "zMapping";
        Target[Target["auxMapping"] = 75] = "auxMapping";
        Target[Target["colorMapping"] = 76] = "colorMapping";
        Target[Target["sizeMapping"] = 77] = "sizeMapping";
        Target[Target["shapeMapping"] = 78] = "shapeMapping";
        Target[Target["textMapping"] = 79] = "textMapping";
        Target[Target["lineMapping"] = 80] = "lineMapping";
        Target[Target["facetMapping"] = 81] = "facetMapping";
        Target[Target["sumByMapping"] = 82] = "sumByMapping";
        //---- properties ----
        Target[Target["chartType"] = 83] = "chartType";
        Target[Target["layout"] = 84] = "layout";
        Target[Target["shapeOpacity"] = 85] = "shapeOpacity";
        Target[Target["sizeFactor"] = 86] = "sizeFactor";
        Target[Target["separationFactor"] = 87] = "separationFactor";
        //---- other ----
        Target[Target["app"] = 88] = "app";
        Target[Target["newAppInstance"] = 89] = "newAppInstance";
        Target[Target["undoEntry"] = 90] = "undoEntry";
        Target[Target["redoEntry"] = 91] = "redoEntry";
        Target[Target["insight"] = 92] = "insight";
        Target[Target["searchCol"] = 93] = "searchCol";
        Target[Target["threeDimWheel"] = 94] = "threeDimWheel";
        Target[Target["dataZoom"] = 95] = "dataZoom";
    })(beachParty.Target || (beachParty.Target = {}));
    var Target = beachParty.Target;
    var SelectionDesc = (function () {
        function SelectionDesc() {
        }
        return SelectionDesc;
    }());
    beachParty.SelectionDesc = SelectionDesc;
    var ScriptCmd = (function () {
        //---- params ----
        function ScriptCmd(action, target) {
            this.action = Action[action];
            this.target = Target[target];
        }
        return ScriptCmd;
    }());
    beachParty.ScriptCmd = ScriptCmd;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    paletteHelper.ts - helps client apps build a color, size, and image palettes based on the associated MappingData.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var paletteHelper = (function () {
        function paletteHelper() {
        }
        paletteHelper.buildColorBreaks = function (cm, colInfo, useNiceNumbers) {
            if (cm) {
                var palette = cm.colorPalette;
                var breaks = null;
                var colName = cm.colName;
                if (colName) {
                    if (colInfo) {
                        //palette = colorPalettesClass.getPaletteFromSettings(cm.paletteName, cm.stepsRequested, cm.isReversed);
                        var isCategory = (cm.forceCategory || colInfo.colType == "string");
                        if (isCategory) {
                            var result = this.buildCategoryBreaks(colInfo, palette, cm.isCycling);
                            breaks = result.breaks;
                            palette = result.palette;
                        }
                        else {
                            //---- user-supplied palette overrides cm.binCount ----
                            //if (palette.length > cm.binCount)
                            //{
                            //    //---- shorten palette to # of color steps requested ----
                            //    palette = palette.slice(0, cm.binCount);
                            //}
                            cm.binCount = palette.length;
                            breaks = this.buildNumOrDateBreaks(cm, colInfo, palette, useNiceNumbers);
                        }
                    }
                }
                cm.colorPalette = palette;
                cm.breaks = breaks;
            }
        };
        paletteHelper.buildSizeBreaks = function (sm, colInfo, useNiceNumbers) {
            if (sm) {
                var palette = sm.sizePalette;
                var breaks = null;
                var colName = sm.colName;
                if (colName) {
                    if (colInfo) {
                        //---- the default size palette, for now ----
                        //palette = [.25, .5, .75, 1];
                        var isCategory = (sm.forceCategory || colInfo.colType == "string");
                        if (isCategory) {
                            var result = this.buildCategoryBreaks(colInfo, palette, false);
                            breaks = result.breaks;
                            palette = result.palette;
                        }
                        else {
                            breaks = this.buildNumOrDateBreaks(sm, colInfo, palette, useNiceNumbers);
                        }
                    }
                }
                sm.sizePalette = palette;
                sm.breaks = breaks;
            }
        };
        paletteHelper.buildShapeBreaks = function (im, colInfo, useNiceNumbers, useExperimental) {
            if (im) {
                var palette = im.getImagePalette(useExperimental);
                var breaks = null;
                var colName = im.colName;
                if (colName) {
                    if (colInfo) {
                        var isCategory = (im.forceCategory || colInfo.colType == "string");
                        if (isCategory) {
                            var result = this.buildCategoryBreaks(colInfo, palette, false);
                            breaks = result.breaks;
                            palette = result.palette;
                        }
                        else {
                            breaks = this.buildNumOrDateBreaks(im, colInfo, palette, useNiceNumbers);
                        }
                    }
                }
                im.imagePalette = palette;
                im.breaks = breaks;
            }
        };
        paletteHelper.buildCategoryBreaks = function (colInfo, palette, isCycling) {
            var keys = colInfo.stats.sortedKeys ? colInfo.stats.sortedKeys : colInfo.keys; // support older "keys" format in QuickTest insights
            var keyCount = keys.length;
            if (keyCount < palette.length) {
                palette = palette.slice(0, keyCount);
            }
            var breaks = [];
            if (isCycling) {
                //---- cap this at 250 until we add a virtual listbox to help perf ----
                var breakCount = Math.min(250, keyCount);
                for (var i = 0; i < breakCount; i++) {
                    breaks.push(keys[i]);
                }
            }
            else {
                for (var i = 0; i < palette.length; i++) {
                    if (i == palette.length - 1 && keyCount > palette.length) {
                        breaks.push("Other");
                    }
                    else {
                        breaks.push(keys[i]);
                    }
                }
            }
            return { breaks: breaks, palette: palette };
        };
        paletteHelper.buildNumOrDateBreaks = function (md, colInfo, palette, useNiceNumbers) {
            //var min = +colInfo.min;
            //var max = +colInfo.max;
            //var stepCount = (palette.length) ? palette.length : 1;
            //if (useNiceNumbers)
            //{
            //    var result = vp.scales.niceNumbersAlt.calculate(min, max, stepCount + 1);
            //    min = result.min;
            //    max = result.max;
            //}
            //var stepAmt = (max - min) / stepCount;
            //var breaks = vp.data.range(min, max, stepAmt);
            //return breaks;
            //---- call common code for consistent results ----
            if (colInfo.colType == "date") {
                var breaks = beachParty.binHelperDate.computeDateBreaks(md, colInfo);
            }
            else {
                var breaks = beachParty.binHelperNum.computeNumBreaks(md, colInfo, false);
            }
            return breaks;
        };
        return paletteHelper;
    }());
    beachParty.paletteHelper = paletteHelper;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    rotateRing.ts - displays a slowly pulsing ring in the 3D rotation area, in center of plot area. 
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var rotateRingClass = (function () {
        //_rcRotation = null;
        function rotateRingClass(chart) {
            this._fullOpacity = "1";
            //_radius = 0;               // size of 3D transform center
            this._pulseInterval = 5000;
            this._pulseTimer = null;
            this._pulseDuration = 0;
            this._chart = chart;
            var rootW = vp.select(document.body).append("div")
                .addClass("rotateRing")
                .css("position", "absolute")
                .css("opacity", "0");
            this._root = rootW[0];
        }
        //setRotationBounds(rc)
        //{
        //    this._rcRotation = rc;
        //}
        rotateRingClass.prototype.getRcPlot = function () {
            var rcPlot = this._chart.getBounds();
            return rcPlot;
        };
        rotateRingClass.prototype.getFinalRotationBounds = function () {
            var rcPlot = this.getRcPlot();
            var rcRot = this._chart.getRotateRingBounds();
            var rc = vp.geom.createRect(rcPlot.left + rcRot.left, rcPlot.top + rcRot.top, rcRot.width, rcRot.height);
            return rc;
        };
        rotateRingClass.prototype.enter = function () {
            var _this = this;
            var ring = this._root;
            var rcPlot = this.getRcPlot();
            var rcRing = this.getFinalRotationBounds();
            vp.utils.debug("ENTER");
            //---- FROM size ----
            vp.select(ring)
                .bounds(rcPlot.left, rcPlot.top, rcPlot.width, rcPlot.height)
                .css("border-radius", "0px")
                .css("opacity", "0");
            //---- ENDING bounds/radius ----
            setTimeout(function (e) {
                vp.select(ring)
                    .css("transition", "all .5s ease")
                    .bounds(rcRing.left, rcRing.top, rcRing.width, rcRing.height)
                    .css("border-radius", rcRing.width / 2 + "px")
                    .css("opacity", _this._fullOpacity);
            }, 250);
            //---- FADE OUT ----
            setTimeout(function (e) {
                vp.select(ring)
                    .css("transition", "all .5s ease")
                    .css("opacity", "0");
            }, 1500);
        };
        rotateRingClass.prototype.startPulsing = function () {
            var _this = this;
            this.stopPulsing();
            this._pulseTimer = setInterval(function (e) {
                _this.pulse();
            }, this._pulseInterval);
        };
        rotateRingClass.prototype.stopPulsing = function () {
            if (this._pulseTimer) {
                clearInterval(this._pulseTimer);
                this._pulseTimer = null;
            }
        };
        rotateRingClass.prototype.exit = function () {
            this.stopPulsing();
            var ring = this._root;
            var rcPlot = this.getRcPlot();
            var rcRing = this.getFinalRotationBounds();
            vp.utils.debug("EXIT");
            //---- STARTING bounds/radius ----
            vp.select(ring)
                .css("transition", "all .5 ease")
                .bounds(rcRing.left, rcRing.top, rcRing.width, rcRing.height)
                .css("border-radius", rcRing.width / 2 + "px")
                .css("opacity", this._fullOpacity);
            //---- TO size ----
            setTimeout(function (e) {
                vp.select(ring)
                    .css("transition", "all 3.5 ease")
                    .bounds(rcPlot.left, rcPlot.top, rcPlot.width, rcPlot.height)
                    .css("border-radius", "0px")
                    .css("opacity", "0");
            }, 500);
        };
        rotateRingClass.prototype.pulse = function () {
            //---- update its rcRing (plot may have moved since last enter/pulse) ----
            var ring = this._root;
            var rcRing = this.getFinalRotationBounds();
            vp.utils.debug("PULSE");
            //---- FADE IN ----
            vp.select(ring)
                .bounds(rcRing.left, rcRing.top, rcRing.width, rcRing.height)
                .css("border-radius", rcRing.width / 2 + "px")
                .css("transition", "all .5s ease")
                .css("opacity", this._fullOpacity);
            //---- FADE OUT ----
            setTimeout(function (e) {
                vp.select(ring)
                    .css("opacity", "0");
            }, 500 + this._pulseDuration);
        };
        return rotateRingClass;
    }());
    beachParty.rotateRingClass = rotateRingClass;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// rubberBandSelector.ts.  Copyright (c) 2016 Microsoft Corporation.
/// Part of the beachParty library
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var nextSelectorId = 1;
    var maxHoldDist = 5;
    var holdTime = 2000;
    /** Note: this class hooks mouseDOWN using the chart canvas, and mouseUP using "window",
    so that we can drag outside the chart.  We treat a mouseDOWN with isEnabled=false as a
    notification back to the client (so they can enable an inactive chart).
    
    Also, this control implements its own context menu (when the mouse is not moved for a certain time).  The goal
    is to eventually use the standard browser context menu event in its place. */
    var rubberBandSelectorClass = (function (_super) {
        __extends(rubberBandSelectorClass, _super);
        function rubberBandSelectorClass(dragSelectCanvas, isEnabled) {
            var _this = this;
            _super.call(this);
            //---- state ----
            this._id = nextSelectorId++;
            this._isEnabled = true;
            this._isBanding = false;
            this._ptMouseDown = null;
            this._ptMouseHold = null; // location where user is "holding" (not moving for holdTime ms)
            this._holdTimer = null;
            this._selectCallback = null;
            this._holdCallback = null;
            this._dragSelectCanvas = null;
            this._canvasChanged = false;
            this._mouseDownOrigin = "outsideChart"; // insideActiveChart, insideInactiveChart, outsideChart
            this._isLeftButtonDown = false;
            this._isRightButtonDown = false;
            this._pendingUpEvent = false;
            this._forceToggle = false;
            this._onMouseMoveFunc = null;
            this._onMouseUpFunc = null;
            this._isSetCaptureActive = false;
            //---- turn this off until we change this to look like a context menu on touch screen, with normal menu items ----
            this._isHoldEnabled = false;
            this._isEnabled = isEnabled;
            this._onMouseMoveFunc = function (e) { return _this.onRubberMove(e); };
            this._onMouseUpFunc = function (e) { return _this.onRubberUp(e); };
            this._dragSelectCanvas = dragSelectCanvas;
            var rubberBand = vp.select(document.createElement("span")) //   createTextBlock()
                .id("rubberBandSelector")
                .addClass("rubberBand")
                .css("z-index", "9999")
                .css("display", "none");
            this._rubberBand = rubberBand;
            /// try to prevent rubberBand from taking mouse events from the dragSelectCanvas
            /// but none of these really does the trick.
            rubberBand.css("pointer-events", "none");
            rubberBand[0].disabled = true;
            if (isEnabled) {
                this.hookEvents(false);
            }
        }
        rubberBandSelectorClass.prototype.forceToggle = function (value) {
            if (arguments.length == 0) {
                return this._forceToggle;
            }
            this._forceToggle = value;
            this.onDataChanged("forceToggle");
        };
        rubberBandSelectorClass.prototype.isDragging = function () {
            return this._isBanding;
        };
        rubberBandSelectorClass.prototype.isDraggingRect = function () {
            return (this._isBanding && this._isEnabled);
        };
        rubberBandSelectorClass.prototype.hookEvents = function (canvasChanged) {
            var _this = this;
            //---- always process mouse up, so we can track right mouse button up/down state ----
            vp.select(window).attach("mouseup", function (e) { return _this.onMouseUp(e); });
            this._canvasChanged = canvasChanged;
            var canvas = this._dragSelectCanvas;
            if (canvas) {
                //---- hook MOUSE DOWN ----
                canvas.onmousedown = function (e) { return _this.onRubberDown(e); };
                vp.select(canvas).attach("touchstart", function (e) { return _this.onRubberDown(e); });
                vp.select(canvas).attach("keydown", function (e) {
                    if (e.keyCode == vp.events.keyCodes.escape) {
                        _this.cancelBanding(true, e);
                    }
                });
                //canvas.appendChild(this._rubberBand.getNative());
                document.body.appendChild(this._rubberBand[0]);
            }
        };
        rubberBandSelectorClass.prototype.attachOnSelect = function (callback) {
            this._selectCallback = callback;
        };
        rubberBandSelectorClass.prototype.attachOnHold = function (callback) {
            this._holdCallback = callback;
        };
        rubberBandSelectorClass.prototype.setRubberBand = function (rc) {
            var left = rc.left;
            var top = rc.top;
            //vp.utils.debug("rubberBandSelector.setRubberBand: left=" + rc.left + ", top=" + rc.top + ", width=" + rc.width +
            //    ", height=" + rc.height);
            this._rubberBand
                .css("position", "absolute")
                .css("left", left + "px")
                .css("top", top + "px")
                .width(rc.width + "px")
                .height(rc.height + "px")
                .css("display", "block");
        };
        rubberBandSelectorClass.prototype.showRubberBand = function (value) {
            if (this._rubberBand) {
                this._rubberBand.css("display", (value) ? "block" : "none");
            }
        };
        rubberBandSelectorClass.prototype.cancelBanding = function (clearBanding, evt) {
            this.showRubberBand(false);
            this.clearCapture();
            //---- re-enable text selection by browser (for Chrome, FireFox) ----
            //hostControls.enableElementSelection(document.body, true);
            if (clearBanding) {
                this.clearBanding();
            }
            this.clearHoldTimer();
        };
        rubberBandSelectorClass.prototype.clearCapture = function () {
            if (this._isSetCaptureActive) {
                vp.events.releaseCaptureWindow();
                //vp.utils.debug("rubberBandSelection: RELEASE CAPTURE");
                this._isSetCaptureActive = false;
            }
        };
        rubberBandSelectorClass.prototype.clearBanding = function () {
            //vp.utils.debug("cancelBanding: id=" + this._id);
            this._isBanding = false;
        };
        rubberBandSelectorClass.prototype.isToggleKey = function (evt) {
            return (evt.shiftKey); // (evt.ctrlKey);
        };
        /// debug support: distingish between mouse and touch UP events.
        rubberBandSelectorClass.prototype.onTouchUp = function (evt) {
            //---- click on inactive window? ----
            if (!this._isEnabled) {
                if (this._mouseDownOrigin != "outsideChart") {
                    this.handleClickOnInactiveView(evt);
                }
            }
            else {
                this.onRubberUp(evt);
            }
        };
        rubberBandSelectorClass.prototype.handleClickOnInactiveView = function (evt) {
            var pt = vp.events.mousePosition(evt);
            var rc = this._dragSelectCanvas.getBoundingClientRect();
            if ((rc.width > 0) && (rc.height > 0)) {
                if (vp.geom.rectContainsPoint(rc, pt)) {
                    if (this._selectCallback) {
                        this._selectCallback(evt, null, false, "insideInactiveChart");
                    }
                }
            }
        };
        //---- touchMgr calls this ----
        rubberBandSelectorClass.prototype.setMouseDown = function (pt) {
            this._ptMouseDown = pt;
            this.cancelBanding(true);
        };
        //---- touchMgr calls this ----
        rubberBandSelectorClass.prototype.drawBand = function (evt) {
            var ptCurrent = vp.events.mousePosition(evt);
            var rc = vp.geom.rectFromPoints(ptCurrent, this._ptMouseDown);
            this.setRubberBand(rc);
        };
        //---- touchMgr calls this ----
        rubberBandSelectorClass.prototype.processExternalUp = function (evt) {
            var ptCurrent = vp.events.mousePosition(evt);
            this._mouseDownOrigin = "insideActiveChart";
            var rcBand = vp.geom.rectFromPoints(ptCurrent, this._ptMouseDown);
            var toggle = (this._forceToggle || evt.which == 3 || this.isToggleKey(evt));
            this.cancelBanding(true, evt);
            if (this._selectCallback) {
                //---- pass callback the window-relative rectangle coordinates ----
                this._selectCallback(evt, rcBand, toggle, this._mouseDownOrigin);
            }
        };
        /// debug support: distingish between mouse and touch UP events.
        rubberBandSelectorClass.prototype.onMouseUp = function (evt) {
            //vp.utils.debug("rubberBandSelector: onMouseUp");
            //---- in case things get out of sync, always treat UP event as clearing isRightButtonDown ----
            if (true) {
                this._isRightButtonDown = false;
            }
            //---- including this 2nd UP call on IE causes 2 "clear selection" cmds to be recorded, so we don't include it. ----
            //---- the TOUCH up seem to now be required by rubberBand code for proper operation (vs. MOUSE UP). ----
            //---- BUT, Chrome requires this call. ----
            if ((!vp.utils.isIE) || (window.external && window.external.isHostedInExcel)) {
                //---- click on inactive window? ----
                if (!this._isEnabled) {
                    this.handleClickOnInactiveView(evt);
                }
                else {
                    this.onRubberUp(evt);
                }
            }
        };
        rubberBandSelectorClass.prototype.cancelPendingUpEvent = function () {
            if (this._pendingUpEvent) {
                //vp.utils.debug("rubberbandSelection: cancelling pending UP event");
                this._pendingUpEvent = false;
                this.cancelBanding(true);
            }
        };
        rubberBandSelectorClass.prototype.onRubberUp = function (evt) {
            var _this = this;
            //---- to enable a TOUCH context menu to cancel this potential select event, we give it a chance to fire before we process the UP ----
            this._pendingUpEvent = true;
            setTimeout(function (e) {
                if (_this._pendingUpEvent) {
                    _this._pendingUpEvent = false;
                    _this.onRubberUpCore(evt);
                }
            }, 1);
        };
        rubberBandSelectorClass.prototype.onRubberUpCore = function (evt) {
            //vp.utils.debug("rubberBandSelector.onRubberUpCore: id=" + this._id + ", isBanding=" + this._isBanding);
            this.clearCapture();
            if (this._isEnabled) {
                if (evt.which == 1) {
                    this._isLeftButtonDown = false;
                }
                /// this is triggered for all window mouse move events, so its important to only look at them
                /// when we have started a banding operation.
                if (this._isBanding) {
                    //vp.utils.debug("rubberBandSelector.onUp: id=" + this._id + ", isEnabled=" + this._isEnabled);
                    var cancelEvent = false;
                    this.clearHoldTimer();
                    //try
                    {
                        //this.cancelBanding(false, evt);
                        this.showRubberBand(false);
                        var toggle = (this._forceToggle || evt.which == 3 || this.isToggleKey(evt));
                        if (evt.type == "touchend") {
                            var ptCurrent = this.changedTouchPosition(evt, null);
                        }
                        else {
                            var ptCurrent = vp.events.mousePosition(evt);
                        }
                        var rcBand = vp.geom.rectFromPoints(ptCurrent, this._ptMouseDown);
                        //---- adjust rcBand so it matches actual location ----
                        //var rect = this._dragSelectCanvas.getBoundingClientRect();
                        //vp.utils.debug("rcBand: left=" + rcBand.left + ", top=" + rcBand.top +
                        //    ", width=" + rcBand.width + ", height = " + rcBand.height + ", toggle = " + toggle);
                        //---- allow for a direct click (no movement) ----
                        if (true) {
                            //vp.utils.debug("calling selectCallback from RUBBER BAND...");
                            if (this._selectCallback) {
                                //---- pass callback the window-relative rectangle coordinates ----
                                this._selectCallback(evt, rcBand, toggle, this._mouseDownOrigin);
                            }
                            cancelEvent = true;
                            this.onDataChanged("mouseUp");
                        }
                        //---- if we re banding, do not pass event along ----
                        vp.events.cancelEventDefault(evt);
                        vp.events.cancelEventBubble(evt);
                    }
                    //catch (ex)
                    //{
                    //    vp.utils.debug("Exception in rubber banding: " + ex);
                    //    throw ex;
                    //}
                    //finally
                    //{
                    //    this.cancelBanding(true, evt);
                    //}
                    this.cancelBanding(true, evt);
                }
                else {
                }
            }
            else {
            }
            //---- reset for next mouse down/up ----
            this._mouseDownOrigin = "outsideChart";
        };
        rubberBandSelectorClass.prototype.changedTouchPosition = function (e, elem) {
            var x = e.changedTouches[0].pageX;
            var y = e.changedTouches[0].pageY;
            if (elem) {
                x -= elem.offsetLeft;
                y -= elem.offsetTop;
            }
            return { x: x, y: y };
        };
        rubberBandSelectorClass.prototype.touchPosition = function (e, elem) {
            var x = e.touches[0].pageX;
            var y = e.touches[0].pageY;
            if (elem) {
                x -= elem.offsetLeft;
                y -= elem.offsetTop;
            }
            return { x: x, y: y };
        };
        rubberBandSelectorClass.prototype.onRubberMove = function (evt) {
            //vp.utils.debug("raw rubberband mouseMove");
            try {
                /// this is triggered for all window mouse move events, so its important to only look at them
                /// when we have started a banding operation.
                if (this._isBanding && this._isEnabled) {
                    //vp.utils.debug("rubberBandSelector.onMove: id=" + this._id);
                    if ((this._isLeftButtonDown) && (this._isRightButtonDown)) {
                        //---- user started a 2-button drag (3D panning) - abandon this operation ----
                        this.cancelBanding(true, evt);
                    }
                    else {
                        if (evt.type == "touchmove") {
                            var ptCurrent = this.touchPosition(evt, null);
                        }
                        else {
                            var ptCurrent = vp.events.mousePosition(evt);
                        }
                        var rc = vp.geom.rectFromPoints(ptCurrent, this._ptMouseDown);
                        //vp.utils.debug("rubberBandSelector: onMove: pt="+  ptCurrent + ", rc=" + rc); 
                        this.setRubberBand(rc);
                        //---- if we're banding, do not pass event along ----
                        vp.events.cancelEventDefault(evt);
                        vp.events.cancelEventBubble(evt);
                        //---- HOLD detection ----
                        if (this._isHoldEnabled) {
                            var deltaX = Math.abs(ptCurrent.x - this._ptMouseHold.x);
                            var deltaY = Math.abs(ptCurrent.y - this._ptMouseHold.y);
                            if ((this._ptMouseHold == null) || (Math.max(deltaX, deltaY) > maxHoldDist)) {
                                //---- start a new hold location/time ----
                                this._ptMouseHold = ptCurrent;
                                this.restartHoldTimer();
                            }
                        }
                    }
                }
            }
            catch (ex) {
                vp.utils.debug("MouseMove Exception: " + ex);
            }
        };
        rubberBandSelectorClass.prototype.triggerHoldEvent = function () {
            var ptCurrent = this._ptMouseHold;
            this._ptMouseHold = null;
            this.clearHoldTimer();
            var rcBand = vp.geom.rectFromPoints(ptCurrent, this._ptMouseDown);
            ////---- adjust rcBand so it matches actual location ----
            //var rect = this._dragSelectCanvas.getBoundingClientRect();
            //var toggle = this.isToggleKey(evt);
            //vp.utils.debug("HOLD rcBand: width=" + rcBand.width + ", height=" + rcBand.height);
            if (this._holdCallback) {
                this.clearBanding();
                this._holdCallback(rcBand, this._mouseDownOrigin, ptCurrent);
            }
        };
        rubberBandSelectorClass.prototype.triggerOnDown = function (e) {
            if (this._isEnabled) {
                this.onRubberDown(e);
            }
        };
        rubberBandSelectorClass.prototype.onRubberDown = function (evt) {
            //vp.utils.debug("--> rubberBandSelector.onDown: id=" + this._id + ",isEnabled=" + this._isEnabled);
            if ((evt.which == 1) || (evt.type == "touchstart")) {
                if (!evt.ctrlKey) {
                    this._isLeftButtonDown = true;
                }
            }
            if (evt.which == 3) {
                this._isRightButtonDown = true;
            }
            //---- only process if LEFT DOWN and RIGHT UP (don't response to multi-button drags ----
            if (true) {
                if (this._isBanding) {
                    this.cancelBanding(true, evt);
                }
                else if (this._isEnabled) {
                    // var toggle = this.isToggleKey(evt);
                    //---- prevent text selection by browser during our drag operation (for Chrome, FireFox) ----
                    //enableElementSelection(document.body, false);
                    //---- use chart-relative point & then add chart-relative offset of each series ----
                    if (evt.type == "touchstart") {
                        this._ptMouseDown = this.touchPosition(evt, null);
                    }
                    else {
                        this._ptMouseDown = vp.events.mousePosition(evt);
                    }
                    if (this._isHoldEnabled) {
                        this._ptMouseHold = this._ptMouseDown;
                        this.restartHoldTimer();
                    }
                    this._isBanding = true;
                    //vp.utils.debug("rubberBandSelector: onDown");
                    //vp.utils.debug("rubberBandSelector.onDown: id=" + this._id + ", isBanding=" + this._isBanding);
                    /// when "vp.events.setCapture" tried by rfernand on Feb-27-2015, no mouse events were being sent to element 
                    /// betweeen call and next mouse click.  When "element.setCapture()" called directly, it returned "undefined"
                    /// and seemed to have no effect.  So, it was then turned off.  Normal mouse events work OK for rubberband
                    /// dragging, but behavior is awkward when mouse leaves document boundaries.
                    /// update:  as of Aug-27-2015, found that we were hooking mousedown twice (pointerdown and mousedown events).  As
                    /// a result, we would end up calling "cancelBanding()" on the 2nd time thru this function which would turn off
                    /// the CAPTURE of mouseMove/mouseUP events.  Fixed that, and now setCaptureWindow() is working correctly... almost - 
                    /// new problem: we are not getting events OUTSIDE of our window.
                    vp.events.setCaptureWindow(this._onMouseMoveFunc, this._onMouseUpFunc);
                    vp.utils.debug("rubberbandSelector: SET CAPTURE");
                    this._isSetCaptureActive = true;
                    //vp.select("#consoleDiv").text("rubberbandSelector: SET CAPTURE");
                    this._mouseDownOrigin = "insideActiveChart";
                }
                else {
                    this._mouseDownOrigin = "insideInactiveChart";
                }
            }
            else {
            }
            this.onDataChanged("mouseDown");
            //---- set line style according to which button is pressed ----
            var toggle = (this._forceToggle || evt.which == 3);
            var rbW = vp.select("#rubberBandSelector");
            if (toggle) {
                rbW.addClass("zoomRubberBand");
            }
            else {
                rbW.removeClass("zoomRubberBand");
            }
            //vp.select("#rubberBandSelector").css("border", (toggle) ? "3px double white" : "2px dashed yellow");
        };
        rubberBandSelectorClass.prototype.clearHoldTimer = function () {
            if (this._holdTimer) {
                clearInterval(this._holdTimer);
                this._holdTimer = null;
            }
        };
        /** we cannot just check the time in mousemove because the mouse might not be moving after reaching its destination. */
        rubberBandSelectorClass.prototype.restartHoldTimer = function () {
            var _this = this;
            this.clearHoldTimer();
            if (this._isEnabled) {
                this._holdTimer = setInterval(function () {
                    _this.triggerHoldEvent();
                }, holdTime);
            }
        };
        rubberBandSelectorClass.prototype.isEnabled = function (value) {
            var _this = this;
            if (arguments.length == 0) {
                return this._isEnabled;
            }
            //vp.utils.debug("rubberBandSelector: id=" + this._id + ", setting isEnabled=" + value + ", isBanding=" + this._isBanding);
            this._isEnabled = value;
            var canvas = this._dragSelectCanvas;
            if (!value) {
                this.cancelBanding(true);
                vp.select(canvas).detach("touchstart", function (e) { return _this.onRubberDown(e); });
                canvas.onmousedown = null;
            }
            else {
                vp.select(canvas).attach("touchstart", function (e) { return _this.onRubberDown(e); });
                canvas.onmousedown = function (e) { return _this.onRubberDown(e); };
            }
            vp.events.releaseCaptureWindow(); // a good time to ensure this is off
            return this;
        };
        rubberBandSelectorClass.prototype.dragSelectElement = function (value) {
            if (arguments.length == 0) {
                return this._dragSelectCanvas;
            }
            this._dragSelectCanvas = value;
            this.hookEvents(true);
        };
        return rubberBandSelectorClass;
    }(beachParty.dataChangerClass));
    beachParty.rubberBandSelectorClass = rubberBandSelectorClass;
    function createRubberBandSelector(canvas) {
        return new rubberBandSelectorClass(canvas, false);
    }
    beachParty.createRubberBandSelector = createRubberBandSelector;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    shapeAttr.ts - manages the SHAPE attribute for a chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var shapeAttrClass = (function (_super) {
        __extends(shapeAttrClass, _super);
        function shapeAttrClass(chart, md, target) {
            var _this = this;
            _super.call(this, chart, md, target);
            this._useExperimentalImages = false;
            chart.registerForChange("chart", function (e) {
                _this.onChartTypeChanged();
            });
            //this.registerForChange("binCount", (e) => this.onMappingChanged(true, false, true));
        }
        shapeAttrClass.prototype.onChartTypeChanged = function () {
        };
        shapeAttrClass.prototype.useExperimentalImages = function (value) {
            if (arguments.length == 0) {
                return this._useExperimentalImages;
            }
            this._useExperimentalImages = value;
            this.onDataChanged("useExperimentalImages");
            this.onMappingChanged(true, false, true);
        };
        shapeAttrClass.prototype.onMappingChanged = function (binCountChanged, omitDataChangedCall, rebindColInfo) {
            _super.prototype.onMappingChanged.call(this, binCountChanged, omitDataChangedCall);
            var md = this._md;
            if (md.colName) {
                var colInfo = md.boundColInfo;
                if (rebindColInfo || !colInfo || colInfo.name != md.colName) {
                    //---- REBIND colInfo to current filter setting ----
                    colInfo = this.getDataFrame().getColInfo(md.colName);
                    md.boundColInfo = colInfo;
                }
                if (colInfo && !md.breaks) {
                    beachParty.paletteHelper.buildShapeBreaks(md, colInfo, this._chart.useNiceNumbers(), this._useExperimentalImages);
                }
            }
        };
        return shapeAttrClass;
    }(beachParty.attrClass));
    beachParty.shapeAttrClass = shapeAttrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    sizeAttr.ts - manages the SIZE attribute for a chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var sizeAttrClass = (function (_super) {
        __extends(sizeAttrClass, _super);
        function sizeAttrClass(chart, md, target) {
            var _this = this;
            _super.call(this, chart, md, target);
            chart.registerForChange("chart", function (e) {
                _this.onChartTypeChanged();
            });
        }
        sizeAttrClass.prototype.onChartTypeChanged = function () {
        };
        sizeAttrClass.prototype.onMappingChanged = function (binCountChanged, omitDataChangedCall) {
            _super.prototype.onMappingChanged.call(this, binCountChanged, omitDataChangedCall);
            var md = this._md;
            var rebindColInfo = false;
            if (md.colName) {
                var colInfo = md.boundColInfo;
                if (rebindColInfo || !colInfo || colInfo.name != md.colName) {
                    //---- REBIND colInfo to current filter setting ----
                    colInfo = this.getDataFrame().getColInfo(md.colName);
                    md.boundColInfo = colInfo;
                }
                if (!md.breaks) {
                    beachParty.paletteHelper.buildSizeBreaks(md, colInfo, this._chart.useNiceNumbers());
                }
            }
        };
        return sizeAttrClass;
    }(beachParty.attrClass));
    beachParty.sizeAttrClass = sizeAttrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    textAttr.ts - manages the TEXT attribute for a chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var textAttrClass = (function (_super) {
        __extends(textAttrClass, _super);
        function textAttrClass(chart, md, target) {
            _super.call(this, chart, md, target);
        }
        textAttrClass.prototype.maxTextShapes = function (value, omitLogging) {
            var lm = this._md;
            if (arguments.length == 0) {
                return lm.maxShapes;
            }
            lm.maxShapes = value;
            this.onMappingChanged();
            if (!omitLogging) {
                this._app.logAction(beachParty.Gesture.drag, null, beachParty.ElementType.slider, beachParty.Action.adjust, beachParty.Target.textMapping, true, { maxShapes: value });
            }
            this.onDataChanged("maxTextShapes");
        };
        textAttrClass.prototype.textColor = function (value, omitLogging) {
            var lm = this._md;
            if (arguments.length == 0) {
                return lm.color;
            }
            lm.color = value;
            this.onMappingChanged();
            if (!omitLogging) {
                this._app.logAction(beachParty.Gesture.select, null, beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.textMapping, true, { textColor: value });
            }
            this.onDataChanged("textColor");
        };
        return textAttrClass;
    }(beachParty.attrClass));
    beachParty.textAttrClass = textAttrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    toolTipMgr.ts - manages the (custom drawn) tooltip for the shapes (on the client).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var toolTipMgrClass = (function (_super) {
        __extends(toolTipMgrClass, _super);
        function toolTipMgrClass(app, dataMgr, chart, maxToolTipColumns) {
            _super.call(this);
            this._areToolTipsEnabled = true;
            this._showDelay = 500;
            this._showTimeout = 30 * 1000; // 30 secs
            this._timer = null;
            this._app = app;
            this._dataMgr = dataMgr;
            this._chart = chart;
            this._maxToolTipColumns = maxToolTipColumns;
        }
        toolTipMgrClass.prototype.showToolTipForShape = function (e, primaryKey, record, colNames) {
            var html = "<table class='toolTipTable'>";
            //var keys = vp.utils.keys(record);
            //var includeSysCols = true;
            var colCount = colNames.length;
            if (colCount > 0) {
                var firstSystemName = true;
                var dataFrame = this._dataMgr.getDataFrame();
                for (var i = 0; i < colCount; i++) {
                    var colName = colNames[i];
                    //if (colName.startsWith("_") && !includeSysCols)
                    //{
                    //    continue;
                    //}
                    var colType = dataFrame.getColType(colName);
                    var value = record[colName];
                    var strValue = vp.formatters.formatByType(value, colType);
                    if (i > 0) {
                        if (colName.startsWith("_") && firstSystemName) {
                            //---- skip a row ----
                            firstSystemName = false;
                            html += "<tr><td>&nbsp;</td></tr>";
                        }
                    }
                    //html += "<tr style='white-space: nowrap'>";
                    html += "<tr >";
                    if (this._chart.includeNamesInTooltip()) {
                        html += "<td class='toolTipName'>" + colName + ":</td>";
                    }
                    html += "<td class='toolTipValue'>" + value + "</td></tr>";
                }
                html += "</table>";
            }
            //---- set text / HTML ----
            vp.select(this.getToolTipElem())
                .html(html);
            var pt = vp.events.mousePosition(e);
            this.positionToolTip(pt);
        };
        toolTipMgrClass.prototype.positionToolTip = function (pt) {
            //---- position tooltip so that its bottom is 20 pixels above the pt screen location ----
            //---- show with opacity=0 so we can measure it ----
            var toolTipW = vp.select(this.getToolTipElem());
            if (toolTipW.length) {
                toolTipW
                    .css("opacity", "0")
                    .css("display", "");
                var rc = toolTipW.getBounds(false);
                //---- hide it until timer fires ----
                toolTipW
                    .css("display", "none")
                    .css("opacity", "1");
                //---- move it ----
                var x = pt.x - (rc.width / 2);
                var y = pt.y - (rc.height + 20);
                if (y < 0) {
                    y = pt.y + 40;
                }
                toolTipW
                    .css("left", x + "px")
                    .css("top", y + "px");
                this.startShowTimer();
            }
        };
        toolTipMgrClass.prototype.startShowTimer = function () {
            var _this = this;
            this.clearTimer();
            //vp.utils.debug("startShowTimer");
            this._timer = setTimeout(function (e) { return _this.showToolTip(); }, this._showDelay);
        };
        toolTipMgrClass.prototype.startHideTimer = function () {
            var _this = this;
            this.clearTimer();
            this._timer = setTimeout(function (e) { return _this.hideToolTip(); }, this._showTimeout);
        };
        toolTipMgrClass.prototype.clearTimer = function () {
            if (this._timer) {
                //vp.utils.debug("clearTimer");
                clearTimeout(this._timer);
                this._timer = null;
            }
        };
        toolTipMgrClass.prototype.showToolTip = function () {
            //vp.utils.debug("showToolTip");
            this.clearTimer();
            vp.select(this.getToolTipElem())
                .css("display", "");
            this.startHideTimer();
        };
        toolTipMgrClass.prototype.areToolTipsEnabled = function (value) {
            if (value === undefined) {
                return this._areToolTipsEnabled;
            }
            this._areToolTipsEnabled = value;
            this.onDataChanged("areToolTipsEnabled");
        };
        toolTipMgrClass.prototype.getToolTipElem = function () {
            return this._chart.toolTipElem();
        };
        toolTipMgrClass.prototype.hideToolTip = function () {
            //vp.utils.debug("hideToolTip called");
            this.clearTimer();
            vp.select(this.getToolTipElem())
                .css("display", "none");
        };
        return toolTipMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.toolTipMgrClass = toolTipMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chartFrameHelper.ts - helps a chart to draw the (somewhat complex) chart frame.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var chartFrameHelperClass = (function (_super) {
        __extends(chartFrameHelperClass, _super);
        function chartFrameHelperClass(parent, chartBuilder, dataMgr, transformer, blankStrValue) {
            _super.call(this);
            this._tickLength = 12;
            this._clickTickLength = 12; // preserve space in facets
            this._isYAxisClickable = true;
            this._isXAxisClickable = true;
            this._leftWidth = 0;
            this._bottomHeight = 0;
            this._blankStrValue = "";
            //---- events ----
            this.onTickBoxClick = new beachParty.bpEvent();
            this._chartBuilder = chartBuilder;
            var rootW = vp.select(parent).append("g");
            this._root = rootW[0];
            this._blankStrValue = blankStrValue;
            this._dataMgr = dataMgr;
            this._transformer = transformer;
        }
        chartFrameHelperClass.prototype.getRoot = function () {
            return this._root;
        };
        chartFrameHelperClass.prototype.selectXBoxByIndex = function (index) {
            var xElems = this._xTickBoxElements;
            if (index < 0) {
                index += xElems.length;
            }
            else {
                //---- true elements start at index=1 ----
                index++;
            }
            var elem = xElems[index];
            var e = { target: elem };
            this.doNewSearch(e, "X", elem.innerText);
        };
        chartFrameHelperClass.prototype.selectYBoxByIndex = function (index) {
            var yElems = this._yTickBoxElements;
            if (index < 0) {
                index += yElems.length;
            }
            else {
                //---- true elements start at index=1 ----
                index++;
            }
            var elem = yElems[index];
            var e = { target: elem };
            this.doNewSearch(e, "Y", elem.innerText);
        };
        chartFrameHelperClass.prototype.chartFrameRoot = function () {
            return this._root;
        };
        /**
         * Create a single chartFrame - called multiple times for Facet views.
         */
        chartFrameHelperClass.prototype.createChartFrame = function () {
            var svgParent = this._root;
            //---- create placeholder scales to initialize with ----
            var xData = vp.chartFrame.createAxisData(vp.scales.createLinear());
            var yData = vp.chartFrame.createAxisData(vp.scales.createLinear());
            //var daFrame = plotServices.currentTheme().getDrawingAttributes("chartFrame");
            var daFrame = null;
            //---- create CHART FRAME control ----
            var chartFrame = vp.chartFrame.createChartFrameEx(svgParent, xData, yData)
                .translate(0, 0, true);
            var dp = chartFrame.leftAxis().drawingParams();
            dp.tickLength = (this._isYAxisClickable) ? this._clickTickLength : this._tickLength;
            var dp = chartFrame.bottomAxis().drawingParams();
            dp.tickLength = (this._isXAxisClickable) ? this._clickTickLength : this._tickLength;
            chartFrame.leftAxis().maxPerpendicularSize(this._leftWidth);
            chartFrame.bottomAxis().maxPerpendicularSize(this._bottomHeight);
            return chartFrame;
        };
        chartFrameHelperClass.prototype.getYAxisWidth = function () {
            var width = (this._isYAxisClickable) ? this._clickTickLength : this._tickLength;
            width += this._leftWidth;
            return width;
        };
        chartFrameHelperClass.prototype.getXAxisHeight = function () {
            var height = (this._isXAxisClickable) ? this._clickTickLength : this._tickLength;
            height += this._bottomHeight;
            return height;
        };
        chartFrameHelperClass.prototype.buildFacetFrames = function (width, height, cfd, dc, hideLabels, facetLayoutInPixels, isXAxisClickable, isYAxisClickable) {
            this._isXAxisClickable = isXAxisClickable;
            this._isYAxisClickable = isYAxisClickable;
            var rootW = vp.select(this._root)
                .clear();
            var scales = dc.scales;
            this._facetChartFrames = [];
            var xAttr = null; // attributes.x;
            var yAttr = null; // attributes.y;
            //---- use width/height of first facet (all facets are the same size) ----
            var bounds = facetLayoutInPixels[0].plotBounds;
            //var xAxisData = this.createAxisData(scales.x, xAttr, 0, bounds.width, "x");
            //var yAxisData = this.createAxisData(scales.y, yAttr, bounds.height, 0, "y");
            var xAxisData = this._bigChartFrame.bottomAxis().axisData();
            var yAxisData = this._bigChartFrame.leftAxis().axisData();
            //---- layout facets with latest WIDTH and HEIGHT ----
            //this.updateFacetLayout();
            //---- get THEME drawing attributes for facet labels ----
            //---- clear cached label measurements ----
            //this._xLabelMeasurements = null;
            //this._yLabelMeasurements = null;
            var xBinResults = (scales.x) ? scales.x._binResults : null;
            var yBinResults = (scales.y) ? scales.y._binResults : null;
            for (var i = 0; i < facetLayoutInPixels.length; i++) {
                var bounds = facetLayoutInPixels[i].plotBounds;
                //---- draw debug guidelines: GREEN BOX around INSIDE of facet cell drawing area ----
                //groupWrap.append("rect")
                //    .attr("stroke", "green")
                //    .attr("stroke-width", "1")
                //    .attr("fill", "none")
                //    .bounds(bounds.left, bounds.top, bounds.width, bounds.height, true)
                //    .id("facetGuideLines")
                //var areTitlesClickable = true;  
                var areLeftLabelsClickable = this._isYAxisClickable;
                var areBottomLabelsClickable = this._isXAxisClickable;
                var facetInfo = dc.facetHelper._layout;
                this.createFacetChartFrame(width, height, dc, xBinResults, yBinResults, cfd, xAxisData, yAxisData, i, facetInfo, rootW[0], bounds, areLeftLabelsClickable, areBottomLabelsClickable, hideLabels, scales);
            }
        };
        /**
         * Creates a facet chart frame for "facetIndex" and lays it out according to "bounds".  This is called
         for all facets, not just the left/bottom ones.  For inner facets, just a rectangle border is created.  For all
         facets, a facet label is also created (on top of the frame).
         * @param cfd
         * @param xAxisData
         * @param yAxisData
         * @param facetIndex
         * @param facetInfo
         * @param groupElem
         * @param bounds
         * @param areLeftLabelsClickable
         * @param areBottomLabelsClickable
         * @param hideAxes
         */
        chartFrameHelperClass.prototype.createFacetChartFrame = function (width, height, dc, xBinResults, yBinResults, cfd, xAxisData, yAxisData, facetIndex, facetInfo, groupElem, bounds, areLeftLabelsClickable, areBottomLabelsClickable, hideAxes, scales) {
            var isLeft = (facetIndex % facetInfo.columnCount == 0);
            var isBottom = Math.floor(facetIndex / facetInfo.columnCount) == facetInfo.rowCount - 1;
            var xoff = bounds.left - 1;
            var yoff = bounds.top - 1;
            //---- TODO: find underlying cause for this y-adjustment ----
            if (isBottom) {
                yoff += 0;
            }
            else {
                yoff += 0;
            }
            //---- create CHART FRAME control ----
            var chartFrame = this.createChartFrame();
            chartFrame
                .translate(xoff, yoff)
                .width(bounds.width)
                .height(bounds.height);
            //chartFrame.gridLines()
            //    .opacity(.4)
            this.setChartFrameProps(chartFrame, bounds.width, bounds.height, hideAxes, true, scales, cfd, dc, xAxisData, yAxisData, isLeft, isBottom, false);
            if (!hideAxes) {
                var tickSize = 16;
                var leftAxisWidth = this._bigChartFrame.leftAxis()._measuredSize;
                //---- set options on LEFT AXIS ----
                var leftAxis = chartFrame.leftAxis()
                    .isLabelsVisible(isLeft)
                    .hideInteriorLabels(false)
                    .labelOverflow(vp.chartFrame.LabelOverflow.ellipses);
                var bottomAxisHeight = this._bigChartFrame.bottomAxis()._measuredSize;
                //---- set options on BOTTOM AXIS ----
                var bottomAxis = chartFrame.bottomAxis()
                    .isLabelsVisible(isBottom)
                    .hideInteriorLabels(false)
                    .labelOverflow(vp.chartFrame.LabelOverflow.ellipses)
                    .labelRotation(vp.chartFrame.LabelRotation.auto)
                    .positiveAutoRotation(false);
            }
            chartFrame.build();
            this._facetChartFrames.push(chartFrame);
        };
        /** converts a WORLD space scale to a SCREEN space scale. */
        chartFrameHelperClass.prototype.cloneScale = function (oldScale, attr, rangeMin, rangeMax, axisName) {
            var myScale = null;
            var scaleType = beachParty.MappingSpread.normal;
            var oldScaleType = oldScale.scaleType();
            var anyOldScale = oldScale;
            var domainMin = oldScale.domainMin();
            var domainMax = oldScale.domainMax();
            //---- map domain boundaries using our transform matrix ----
            if (axisName == "x" || axisName == "y") {
                if (anyOldScale._binResults || oldScale.isCategory()) {
                    //---- use break indexes rather than true data ----
                    var count = 0;
                    if (anyOldScale._binResults) {
                        count = anyOldScale._binResults.bins.length;
                    }
                    else if (anyOldScale.getBreaks) {
                        count = anyOldScale.getBreaks();
                    }
                    else if (anyOldScale._categoryKeys) {
                        count = anyOldScale._categoryKeys.length;
                    }
                    if (anyOldScale._useCategoryForBins) {
                        count--;
                    }
                    var result = this.transformScaleDomain(oldScale, axisName, 0, count);
                }
                else {
                    var result = this.transformScaleDomain(oldScale, axisName, domainMin, domainMax);
                }
                domainMin = result.domainMin;
                domainMax = result.domainMax;
            }
            if (oldScaleType == vp.scales.ScaleType.linear) {
                if (scaleType == beachParty.MappingSpread.low) {
                    myScale = vp.scales.createLowBias();
                }
                else if (scaleType == beachParty.MappingSpread.high) {
                    myScale = vp.scales.createHighBias();
                }
                else {
                    myScale = vp.scales.createLinear();
                }
                //vp.utils.debug("cloneScale: axisName=" + axisName);
                myScale
                    .domainMin(domainMin)
                    .domainMax(domainMax)
                    .rangeMin(rangeMin)
                    .rangeMax(rangeMax);
                myScale.preserveBreakPoints = (anyOldScale._binResults != null);
            }
            else if (oldScaleType == vp.scales.ScaleType.dateTime) {
                myScale = vp.scales.createDate()
                    .domainMin(domainMin)
                    .domainMax(domainMax)
                    .rangeMin(rangeMin)
                    .rangeMax(rangeMax);
                //---- map domain boundaries using our transform matrix ----
                myScale.preserveBreakPoints = (anyOldScale._binResults != null);
                myScale._useCategoryForBins = anyOldScale._useCategoryForBins;
            }
            else {
                //var catKeys = vp.utils.keys(oldScale.categoryKeys());
                var catKeys = this.getCategoryKeysInOrder(oldScale);
                //if (false)      // oldScaleType == vp.scales.ScaleType.categoryIndex)
                //{
                //    myScale = vp.scales.createCategoryIndex()
                //        .categoryKeys(catKeys)
                //}
                //else
                if (oldScale.isCategory()) {
                    myScale = vp.scales.createCategoryKey()
                        .categoryKeys(catKeys);
                }
                else {
                    throw "Unsupported scaleType: " + oldScaleType;
                }
                myScale
                    .range(rangeMin, rangeMax);
                myScale.preserveBreakPoints = true;
            }
            //---- convert expandSpace from 3D units to pixels ----
            var expandSpace = oldScale.expandSpace();
            expandSpace = this._transformer.worldSizeToScreen(expandSpace);
            myScale
                .expandSpace(expandSpace);
            return myScale;
        };
        chartFrameHelperClass.prototype.transformScaleDomain = function (scale, axisName, dataMin, dataMax) {
            //var invWorld = this._transformer.getInvWorldpMatrix();
            var matWorld = this._transformer.getInvWorldpMatrix();
            var xxx = this._transformer.getWorldBounds();
            //---- map from NDC bounds to world bounds (for current transform) ---- 
            if (axisName == "x") {
                var ptTrans = this._transformer.transformPtWithMatrix(xxx.left, 0, 0, matWorld);
                var minWorld = ptTrans.x;
                var ptTrans = this._transformer.transformPtWithMatrix(xxx.right, 0, 0, matWorld);
                var maxWorld = ptTrans.x;
            }
            else if (axisName == "y") {
                var ptTrans = this._transformer.transformPtWithMatrix(0, xxx.bottom, 0, matWorld);
                var minWorld = ptTrans.y;
                var ptTrans = this._transformer.transformPtWithMatrix(0, xxx.top, 0, matWorld);
                var maxWorld = ptTrans.y;
            }
            //---- reverse scale the world bounds to get data bounds of current view ----
            var minNewData = vp.data.mapValue(minWorld, scale._palette[0], scale._palette[1], dataMin, dataMax);
            var maxNewData = vp.data.mapValue(maxWorld, scale._palette[0], scale._palette[1], dataMin, dataMax);
            return { domainMin: minNewData, domainMax: maxNewData };
        };
        chartFrameHelperClass.prototype.createAxisData = function (scale, attr, rangeMin, rangeMax, axisName) {
            /// CAUTION: "scale" was built in world space, but rangeMin/rangeMax are in screen pixels.
            //---- todo: put a real, user-controllable value here ----
            var tickCount = 9; // get adjusted below    // scale.getActualBreaks().length;
            if (scale.scaleType() == vp.scales.ScaleType.categoryIndex) {
                tickCount++;
            }
            //---- create special properties added by chartUtils.adjustScaleForBin() ----
            var anyScale = scale;
            var formatter = anyScale._formatter;
            var breaks = anyScale._breaks;
            var labels = anyScale._labels;
            var newScale = this.cloneScale(scale, attr, rangeMin, rangeMax, axisName);
            //---- support case where we are scaling with numbers, but have a formatting string from Excel ----
            //---- in this case, ignore the Excel format, and do our own local formatting because when user has filtered view, ----
            //---- we can provide a closer fit to the values shown.  We may revisit this in the future ----
            if (formatter && formatter._colType == "number") {
            }
            //---- adjust breaks (subbsetting or creating new break values) to match the updated domainMin/domainMax ----
            var preserveBreakPoints = newScale.preserveBreakPoints;
            var domainMin = newScale._domainMin;
            var domainMax = newScale._domainMax;
            var fullBreakCount = (breaks) ? breaks.length : 0;
            if (preserveBreakPoints) {
                //---- subset the full set of break points ----
                var firstIndex = Math.max(0, Math.ceil(domainMin));
                var lastIndex = Math.min(Math.floor(domainMax), fullBreakCount - 1);
                var diff = lastIndex - firstIndex;
                breaks = vp.data.range(firstIndex, lastIndex);
                labels = null;
            }
            else if (breaks && breaks.length > 1) {
                //---- replace breaks with domainMin, domainMax ticks to match current transform ----
                var diff = domainMax - domainMin;
                var steps = diff / (fullBreakCount - 1);
                breaks = vp.data.range(domainMin, domainMax, steps);
                vp.utils.assert(breaks.length == fullBreakCount);
                labels = null; // regen these to match new breaks
            }
            if (breaks && breaks.length) {
                var len = breaks.length;
                //---- for bin-related scales, since breaks could be non-linear, we need to ensure mapping is linear ----
                if (anyScale._binResults && !anyScale._useCategoryForBins) {
                    if (!labels) {
                        //---- create labels from original breaks ----
                        labels = breaks.map(function (data, index) {
                            var binResults = anyScale._binResults;
                            var useCategoryForBins = anyScale._useCategoryForBins;
                            if (binResults) {
                                if (useCategoryForBins) {
                                    var bin = binResults.bins[data];
                                    data = bin.name;
                                }
                                else if (index == breaks.length - 1) {
                                    var bin = binResults.bins[data - 1];
                                    data = bin.maxLabel;
                                }
                                else {
                                    var bin = binResults.bins[data];
                                    data = bin.minLabel;
                                }
                            }
                            else {
                                data = (formatter) ? formatter(data) : (data + "");
                            }
                            return data;
                        });
                    }
                    //---- replace nonlinear breaks with linear breaks ----
                    breaks = vp.data.range(0, len - 1);
                }
                //---- when breaks are specified, they override domainMin/domainMax specifications ----
                newScale
                    .domainMin(breaks[0])
                    .domainMax(breaks[len - 1]);
            }
            else if (anyScale._tickCount) {
                tickCount = anyScale._tickCount;
            }
            var isCategory = (scale.scaleType() == vp.scales.ScaleType.categoryIndex || scale.scaleType() == vp.scales.ScaleType.categoryKey);
            if (isCategory) {
                //var catKeys = scale.categoryKeys();
                var catKeys = this.getCategoryKeysInOrder(anyScale);
                breaks = (catKeys) ? catKeys : null;
            }
            var axisData = vp.chartFrame.createAxisData(newScale, null, tickCount, breaks, labels, formatter);
            return axisData;
        };
        chartFrameHelperClass.prototype.getCategoryKeysInOrder = function (scale) {
            var catKeysObj = scale.categoryKeys();
            var keysOnly = vp.utils.keys(catKeysObj);
            var catKeysInOrder = [];
            for (var k = 0; k < keysOnly.length; k++) {
                var theKey = keysOnly[k];
                var index = catKeysObj[theKey];
                if (theKey == "") {
                    theKey = this._blankStrValue;
                }
                catKeysInOrder[index] = theKey;
            }
            return catKeysInOrder;
        };
        chartFrameHelperClass.prototype.close = function () {
            vp.select(this._root)
                .clear();
            //this._chartFrame.close();       
        };
        chartFrameHelperClass.prototype.fadeInOut = function (show) {
            //var cfd = this._chartFrameData;
            //if (show)
            //{
            //    vp.select(this._chartFrameRoot)
            //        .css("transition", "opacity .25s ease-in-out")
            //        .css("opacity", cfd.opacity + "")
            //}
            //else
            //{
            //    vp.select(this._chartFrameRoot)
            //        .css("transition", "opacity 0s ease-in-out")
            //        .css("opacity", "0")
            //}
        };
        chartFrameHelperClass.prototype.show = function (value) {
            var cfd = this._chartFrameData;
            if (value) {
                vp.select(this._root)
                    .css("opacity", cfd.opacity + "");
            }
            else {
                vp.select(this._root)
                    .css("opacity", "0");
            }
        };
        chartFrameHelperClass.prototype.build = function (width, height, hideAxes, usingFacets, cfd, dc, facetLayoutInPixels, isXAxisClickable, isYAxisClickable) {
            vp.select(this._root)
                .clear();
            //---- axis sizes ----
            var leftWidth = Math.min(100, .25 * width);
            var bottomHeight = Math.min(75, .25 * height);
            if (hideAxes === true || hideAxes == "y" || !cfd.yAxis.isAxisVisible) {
                leftWidth = 0;
            }
            if (hideAxes === true || hideAxes == "x" || !cfd.xAxis.isAxisVisible) {
                bottomHeight = 0;
            }
            this._leftWidth = leftWidth;
            this._bottomHeight = bottomHeight;
            this._hideAxes = hideAxes;
            //---- for now, always build the big chartFrame to get layout info for overall chart ----
            this.buildBigChartFrame(width, height, hideAxes, usingFacets, dc.scales, cfd, dc, isXAxisClickable, isYAxisClickable);
            //if (usingFacets)
            //{
            //    this.buildFacetFrames(width, height, cfd, dc, this._root, scales, hideAxes, facetLayoutInPixels);
            //}
            var rcPlot = this.layoutChartFrames(width, height, dc, cfd);
            //---- ensure we didn't exceed our layout bounds ----
            //if (rcPlot.left < 0 || rcPlot.right > width || rcPlot.top < 0 || rcPlot.bottom > height)
            //{
            //    vp.utils.error("chartFrameHelper.build: bounds of plot exceed client area");
            //}
            return rcPlot;
        };
        chartFrameHelperClass.prototype.layoutChartFrames = function (width, height, dc, cfd) {
            var rcPlot = this._bigChartFrame.plotAreaBounds();
            //var rcPlot = vp.geom.createRect(this._leftWidth, 0, width - this._leftWidth, height - this._bottomHeight);
            var left = rcPlot.left;
            var top = rcPlot.top;
            var width = rcPlot.width;
            var height = rcPlot.height;
            var padding = cfd.padding;
            if (padding) {
                //---- width and height have already been adjusted for 2*padding ----
                left += padding.left;
                top += padding.top;
            }
            //---- workaround for slight errors in chartFrame calculations (positioning of glCanvas must be pixel perfect) ----
            //---- in parallel, we also need to adjust the facet layout to match ----
            if (dc.facetHelper) {
                if (this._hideAxes !== true && this._hideAxes != "x") {
                    left += 10;
                }
                if (this._hideAxes !== true && this._hideAxes != "y") {
                    height -= 20;
                }
            }
            rcPlot = vp.geom.createRect(left, top, width, height);
            return rcPlot;
        };
        chartFrameHelperClass.prototype.buildBigChartFrame = function (width, height, hideAxes, usingFacets, scales, cfd, dc, isXAxisClickable, isYAxisClickable) {
            this._isXAxisClickable = isXAxisClickable;
            this._isYAxisClickable = isYAxisClickable;
            var chartFrame = this.createChartFrame();
            this._bigChartFrame = chartFrame;
            this._chartFrameData = cfd;
            //---- adjust width/height for padding ----
            var padding = cfd.padding;
            if (padding) {
                vp.select(this._root)
                    .translate(padding.left, padding.top);
                width -= (padding.left + padding.right);
                height -= (padding.top + padding.bottom);
            }
            var xAttr = null; // attributes.x;
            var yAttr = null; // attributes.y;
            var xAxisData = this.createAxisData(scales.x, xAttr, 0, width, "x");
            var yAxisData = this.createAxisData(scales.y, yAttr, height, 0, "y");
            this.setChartFrameProps(chartFrame, width, height, hideAxes, usingFacets, scales, cfd, dc, xAxisData, yAxisData, true, true, true);
            chartFrame.build();
        };
        chartFrameHelperClass.prototype.setChartFrameProps = function (chartFrame, width, height, hideAxes, usingFacets, scales, cfd, dc, xAxisData, yAxisData, isLeft, isBottom, isBigChartFrame) {
            vp.select(this._root)
                .css("opacity", cfd.opacity + "");
            chartFrame
                .xAxisData(xAxisData)
                .yAxisData(yAxisData);
            var isGridVisible = (cfd.xAxis.drawGridLines || cfd.yAxis.drawGridLines);
            var showXAxis = (hideAxes !== true && hideAxes != "x" && cfd.xAxis.isAxisVisible);
            var showYAxis = (hideAxes !== true && hideAxes != "y" && cfd.yAxis.isAxisVisible);
            if (hideAxes === true) {
                isGridVisible = false;
            }
            chartFrame
                .width(width)
                .height(height)
                .isLeftAxisVisible(showYAxis)
                .isBottomAxisVisible(showXAxis)
                .isTopAxisVisible(false)
                .isRightAxisVisible(false)
                .isGridLinesVisible(isGridVisible)
                .axesOnOutside(usingFacets && !isBigChartFrame)
                .isBoxVisible(false);
            if (isGridVisible) {
                chartFrame.gridLines()
                    .isXVisible(cfd.xAxis.drawGridLines)
                    .isYVisible(cfd.yAxis.drawGridLines);
            }
            var chartType = dc.toChartType;
            if (hideAxes !== true) {
                var tickSize = 16;
                if (dc.nvData.y) {
                    var areLeftLabelsClickable = this._isYAxisClickable;
                    //---- set options on LEFT AXIS ----
                    var leftAxis = chartFrame.leftAxis()
                        .labelOverflow(vp.chartFrame.LabelOverflow.ellipses);
                    var yBinResults = (scales.y) ? scales.y._binResults : null;
                    var showYTickBoxes = (this._isYAxisClickable && isLeft);
                    this.shadeYAxis(dc, yAxisData, yBinResults, chartType, showYTickBoxes, leftAxis, areLeftLabelsClickable, usingFacets);
                }
                if (dc.nvData.x) {
                    var areBottomLabelsClickable = this._isXAxisClickable;
                    var xBinResults = (scales.x) ? scales.x._binResults : null;
                    //---- set options on BOTTOM AXIS ----
                    var bottomAxis = chartFrame.bottomAxis()
                        .labelOverflow(vp.chartFrame.LabelOverflow.ellipses)
                        .labelRotation(vp.chartFrame.LabelRotation.auto)
                        .positiveAutoRotation(false);
                    var showXTickBoxes = (this._isXAxisClickable && isBottom);
                    this.shadeXAxis(dc, xAxisData, xBinResults, chartType, showXTickBoxes, bottomAxis, areBottomLabelsClickable);
                }
            }
        };
        chartFrameHelperClass.prototype.shadeXAxis = function (dc, xAxisData, xBinResults, chartType, showTickBoxes, bottomAxis, areBottomLabelsClickable) {
            var _this = this;
            var xCol = (dc.xCalcName) ? dc.xCalcName : dc.nvData.x.colName;
            var xIsCat = (dc.nvData.x.colType == "string"); // || (<any>dc.scales.x)._useCategoryForBins);
            var xLast = null;
            var xLastIndex = xAxisData.tickCount() - 1;
            this._xTickBoxElements = [];
            var labelList = [];
            bottomAxis
                .isTickBoxesVisible(showTickBoxes)
                .onShade(function (element, record, index, isNew, isLastNew) {
                if (index == 0) {
                    xLast = null;
                    labelList = [];
                }
                if (areBottomLabelsClickable && isNew) {
                    if (vp.dom.hasClass(element, "vpxAxisLabel")) {
                        element._boxName = "index=" + index; // for event handling
                        vp.select(element)
                            .attach("click", function (e) { return _this.doNewSearch(e, "X", e.target._boxName); })
                            .css("cursor", "pointer")
                            .attr("simpleHighlight", "true")
                            .addClass("clickableAxisLabel");
                        //---- build info needed by CLICK to do search ----
                        beachParty.searchUtils.buildSearchInfoOnElem(element, labelList, record, xBinResults, index, xCol, xIsCat, "x", "tick", isLastNew);
                    }
                    else if (vp.dom.hasClass(element, "vpxAxisTickBox")) {
                        var tickBarTooltip = null;
                        if (xBinResults && index > 0) {
                            var bin = xBinResults.bins[index - 1];
                            var itemCount = bin.count;
                            tickBarTooltip = "Count: " + vp.formatters.formatNumber(itemCount, "0,##0");
                            if (chartType == "columnSumClass") {
                                var itemSum = bin.sum; //  this.computeBinSum(dc, "x", bin.rowIndexes);
                                tickBarTooltip = "Sum: " + vp.formatters.formatNumber(itemSum, "0,##0") + ", " +
                                    tickBarTooltip;
                            }
                        }
                        element._boxName = "index=" + index; // for event handling
                        vp.select(element)
                            .attach("click", function (e) { return _this.doNewSearch(e, "X", e.target._boxName); })
                            .title(tickBarTooltip);
                        //---- build info needed by CLICK to do search ----
                        beachParty.searchUtils.buildSearchInfoOnElem(element, labelList, record, xBinResults, index, xCol, xIsCat, "x", "bar", isLastNew);
                        _this._xTickBoxElements[index] = element;
                    }
                }
            });
        };
        chartFrameHelperClass.prototype.shadeYAxis = function (dc, yAxisData, yBinResults, chartType, showTickBoxes, leftAxis, areLeftLabelsClickable, isFacet) {
            var _this = this;
            var yCol = (dc.yCalcName) ? dc.yCalcName : dc.nvData.y.colName;
            var yIsCat = (dc.nvData.y.colType == "string"); // || (<any>dc.scales.y)._useCategoryForBins);
            var yLast = null;
            //var yLastIndex = yAxisData.tickCount() - 1;
            this._yTickBoxElements = [];
            //--- lock down the width of the Y axis ---
            if (!isFacet) {
                leftAxis.minWidth(this._leftWidth);
            }
            var labelList = [];
            //---- hook the "shaded" event so that we can apply our custom settings on axis labels ----
            leftAxis
                .isTickBoxesVisible(showTickBoxes)
                .onShade(function (element, record, index, isNew, isLastNew) {
                if (index == 0) {
                    yLast = null;
                    labelList = [];
                }
                //---- isNew is set to true if we haven't seen this element before ----
                if (areLeftLabelsClickable && isNew) {
                    if (vp.dom.hasClass(element, "vpxAxisLabel")) {
                        element._boxName = "index=" + index; // for event handling
                        vp.select(element)
                            .attach("click", function (e) { return _this.doNewSearch(e, "Y", e.target._boxName); })
                            .css("cursor", "pointer")
                            .attr("simpleHighlight", "true")
                            .addClass("clickableAxisLabel");
                        //---- build info needed by CLICK to do search ----
                        beachParty.searchUtils.buildSearchInfoOnElem(element, labelList, record, yBinResults, index, yCol, yIsCat, "y", "tick", isLastNew);
                    }
                    else if (vp.dom.hasClass(element, "vpxAxisTickBox")) {
                        var tickBarTooltip = null;
                        if (yBinResults && index > 0) {
                            var bin = yBinResults.bins[index - 1];
                            var itemCount = bin.count;
                            tickBarTooltip = "Count: " + vp.formatters.formatNumber(itemCount, "0,##0");
                            if (chartType == "barSumClass") {
                                var itemSum = bin.sum; //  this.computeBinSum(dc, "y", bin.rowIndexes);
                                tickBarTooltip = "Sum: " + vp.formatters.formatNumber(itemSum, "0,##0") + ", " +
                                    tickBarTooltip;
                            }
                        }
                        element._boxName = "index=" + index; // for event handling
                        vp.select(element)
                            .attach("click", function (e) { return _this.doNewSearch(e, "Y", e.target._boxName); })
                            .title(tickBarTooltip);
                        //---- build info needed by CLICK to do search ----
                        beachParty.searchUtils.buildSearchInfoOnElem(element, labelList, record, yBinResults, index, yCol, yIsCat, "y", "bar", isLastNew);
                        _this._yTickBoxElements[index] = element;
                    }
                }
            });
        };
        chartFrameHelperClass.prototype.doNewSearch = function (e, axisName, boxLabel) {
            //---- tick box click handling has been moved to the chart class ----
            var selectMode = this._chartBuilder.getChart().selectMode();
            var sp = beachParty.searchUtils.searchOnTickOrBarClick(e, selectMode);
            this.onTickBoxClick.trigger({ sender: this, buttonType: sp.buttonType, axisName: sp.axisName, boxLabel: boxLabel, searchParams: sp });
        };
        return chartFrameHelperClass;
    }(beachParty.dataChangerClass));
    beachParty.chartFrameHelperClass = chartFrameHelperClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chartUtils.ts - common functions used by some of the chart classes
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var chartUtils = (function () {
        function chartUtils() {
        }
        chartUtils.fadeIn = function (elem, msDuration) {
            if (msDuration === void 0) { msDuration = 35; }
            var boxW = vp.select(elem);
            //---- workaround bug in Edge where animated fade results in unstable visibility ----
            if (vp.utils.isEdge) {
                msDuration = 0;
            }
            if (msDuration === 0) {
                //---- make visible NOW---
                boxW
                    .css("opacity", "1")
                    .css("display", "")
                    .css("visibility", "")
                    .css("animation", "")
                    .css("animation-fill-mode", "");
            }
            else {
                //---- animate opacity ---
                var anim = "fadeIn " + msDuration + "ms forwards";
                vp.utils.debug("fadeIn: anim=" + anim);
                boxW
                    .css("display", "")
                    .css("visibility", "")
                    .css("animation", anim);
            }
        };
        chartUtils.fadeOut = function (elem, msDuration) {
            if (msDuration === void 0) { msDuration = 35; }
            var boxW = vp.select(elem);
            if (msDuration === 0) {
                //---- make hidden NOW---
                boxW
                    .css("opacity", "0")
                    .css("display", "none")
                    .css("visibility", "")
                    .css("animation", "")
                    .css("animation-fill-mode", "");
            }
            else {
                //---- animate opacity to hide ---
                var anim = "fadeOut " + msDuration + "ms";
                boxW
                    .css("animation", anim)
                    .css("animation-fill-mode", "forwards");
                var anim = "fadeOut " + msDuration + "ms";
                setTimeout(function (e) { return boxW.css("display", "none"); }, msDuration);
            }
        };
        chartUtils.isVisible = function (name) {
            var disp = vp.select("#" + name).css("display");
            return (disp != "none");
        };
        chartUtils.findIgnoreClickElem = function (elem) {
            while (elem) {
                if (elem.ignoreNextClick) {
                    break;
                }
                elem = elem.parentNode;
            }
            return elem;
        };
        chartUtils.callPanelOpen = function (e, callback) {
            if (e) {
                var elem = chartUtils.findIgnoreClickElem(e.target);
                if (elem) {
                    vp.utils.debug("callPanelOpen: elem.id=" + elem.id + " , ignoreClick=found");
                    elem.ignoreNextClick = false;
                }
                else {
                    vp.utils.debug("callPanelOpen: e.target.id=" + e.target.id + ", ignoreClick=NOT found");
                    callback(e);
                }
            }
            else {
                vp.utils.debug("callPanelOpen: e=null");
                callback(e);
            }
        };
        chartUtils.scaleColData = function (vector, index, scale, defaultValue) {
            if (defaultValue === void 0) { defaultValue = 0; }
            var result = defaultValue;
            if (vector) {
                var colValue = vector.values[index];
                var needKey = scale.scaleType() == vp.scales.ScaleType.categoryKey;
                if (needKey) {
                    colValue = (vector.keyInfo) ? vector.keyInfo.keysByIndex[colValue] : (colValue + "");
                }
                //---- handle NAN's by treating them as "0" for now ----
                if (!needKey && isNaN(colValue)) {
                    colValue = 0;
                }
                result = scale.scale(colValue);
            }
            return result;
        };
        chartUtils.setFilteredMinMaxBreak = function (md, layoutFilterVector, nv) {
            //---- filter data using layoutFilterVector ----
            var newVector = [];
            var values = nv.values;
            var keys = null;
            var min = null;
            var max = null;
            if (nv.colType == "string") {
                var nvFilter = new beachParty.NumericVector(layoutFilterVector, "filter", "number");
                keys = beachParty.cbUtils.getFilteredSortedKeys(nv, nvFilter);
                min = 0;
                max = keys.length - 1;
                md.allFacetsKeys = keys;
            }
            else {
                //---- filter the "all facets" data per current filter setting ----
                for (var i = 0; i < values.length; i++) {
                    if (!layoutFilterVector[i]) {
                        newVector.push(values[i]);
                    }
                }
                keys = null;
                min = newVector.min();
                max = newVector.max();
            }
            md.minBreakFacet = min;
            md.maxBreakFacet = max;
            return keys;
        };
        chartUtils.computeBestCountFactor = function (maxCount, shapesPerRow) {
            var breakCount = null;
            if (maxCount <= 1) {
                breakCount = 1;
            }
            else {
                var rowCount = Math.ceil(maxCount / shapesPerRow);
                maxCount = rowCount * shapesPerRow;
                var maxOver = 0;
                var bestFactor = null;
                //---- try various factors, in priority order ----
                var factors = [7, 8, 6, 5, 9, 4, 10, 3, 11, 12, 2];
                for (var i = 0; i < factors.length; i++) {
                    var f = factors[i];
                    var over = rowCount % f;
                    if (over === 0) {
                        breakCount = f;
                        break;
                    }
                    if (i == 0 || over > maxOver) {
                        maxOver = over;
                        bestFactor = f;
                    }
                }
                if (!breakCount) {
                    //---- take next highest factor of 7 ----
                    breakCount = bestFactor;
                    var rowsPerBreak = Math.ceil(rowCount / breakCount);
                    maxCount = rowsPerBreak * breakCount * shapesPerRow;
                }
            }
            return { maxCount: maxCount, tickCount: 1 + breakCount };
        };
        chartUtils.computeMaxBinCountForData = function (dc, nv, cm, binCol) {
            //---- compute single bin (for this facet) ----
            var requestedBins = cm.binCount;
            var sortOptions = new beachParty.binSortOptionsClass();
            sortOptions.sortDirection = cm.binSorting;
            sortOptions.sortByAggregateType = "count";
            var maxCount = 0;
            var binResults = beachParty.binHelper.createBins(nv, binCol, requestedBins, cm.binCount, false, true, true, sortOptions, null, cm.useNiceNumbers, cm);
            if (binResults) {
                var binCount = binResults.bins.length;
                //---- compute maxCount ----
                var maxCount = 0;
                for (var i = 0; i < binCount; i++) {
                    var count = binResults.bins[i].count;
                    maxCount = Math.max(maxCount, count);
                }
            }
            return { maxCount: maxCount, binResults: binResults };
        };
        chartUtils.binTheDataForCount = function (dc, data, cm, binCol) {
            var requestedBins = cm.binCount;
            var sortOptions = new beachParty.binSortOptionsClass();
            sortOptions.sortDirection = cm.binSorting;
            sortOptions.sortByAggregateType = "count";
            var maxCount = 0;
            var binResults = beachParty.binHelper.createBins(data, binCol, requestedBins, cm.binCount, false, true, true, sortOptions, null, cm.useNiceNumbers, cm);
            return binResults;
        };
        chartUtils.computeSumForFacet = function (dc, data, cm, binColumn, sumByColumn) {
            var sortOptions = new beachParty.binSortOptionsClass();
            sortOptions.sortDirection = cm.binSorting;
            sortOptions.sortByAggregateType = "sum";
            sortOptions.sumByColumn = sumByColumn;
            var maxCount = 0;
            var requestedBins = cm.binCount;
            var binResults = beachParty.binHelper.createBins(data, binColumn, requestedBins, requestedBins, false, true, true, sortOptions, null, cm.useNiceNumbers, cm);
            if (binResults) {
                var binCount = binResults.bins.length;
                //cpp.binResults.push(xResult);
                //---- find tallest bin for the current facet ----
                var maxPosSum = 0;
                var maxNegSum = 0;
                for (var i = 0; i < binCount; i++) {
                    var result = this.computeBinNegPosSums(dc, binResults.bins[i], sumByColumn);
                    maxPosSum = Math.max(maxPosSum, result.posSum);
                    maxNegSum = Math.max(maxNegSum, result.negSum);
                }
            }
            return { maxPosSum: maxPosSum, maxNegSum: maxNegSum, binResults: binResults };
        };
        chartUtils.computeBinNegPosSums = function (dc, binResult, sumColumn) {
            var rowIndexes = binResult.rowIndexes;
            var posHeight = 0;
            var negHeight = 0;
            var nv = dc.nvData;
            var values = nv[sumColumn].values;
            for (var i = 0; i < rowIndexes.length; i++) {
                var vectorIndex = rowIndexes[i];
                //---- only process FILTERED-IN records ----
                if (!dc.layoutFilterVector[vectorIndex]) {
                    var height = values[vectorIndex];
                    if (height >= 0) {
                        posHeight += height;
                    }
                    else {
                        negHeight += height;
                    }
                }
            }
            return { posSum: posHeight, negSum: Math.abs(negHeight) };
        };
        chartUtils.getOrderOfBins = function (bins) {
            var isAscend = true;
            var isDescend = true;
            var lastValue = null;
            for (var i = 0; i < bins.length; i++) {
                var value = bins[i].min;
                if (i > 0) {
                    if (value < lastValue) {
                        isAscend = false;
                    }
                    else if (value > lastValue) {
                        isDescend = false;
                    }
                }
                lastValue = value;
            }
            var order = (isAscend) ? +1 : ((isDescend) ? -1 : 0);
            return order;
        };
        //static getUnionOfKeys(appMgr: appMgrClass, axisName: string)
        //{
        //    var colInfos = appMgr.getDataMgr().getColInfos(true);
        //    var colName = appMgr.getDataView().xMapping().colName;
        //    var keys = null;
        //    for (var i = 0; i < colInfos.length; i++)
        //    {
        //        var colInfo = colInfos[i];
        //        if (colInfo.name == colName)
        //        {
        //            keys = colInfo.sortedKeys;
        //            break;
        //        }
        //    }
        //    return keys;
        //}
        chartUtils.adjustScaleForBin = function (scale, binResulsArray, axisName) {
            var scaleType = scale.scaleType();
            var binResults = binResulsArray[0];
            var bins = binResults.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNames = [];
            for (var i = 0; i < bins.length; i++) {
                binNames[i] = bins[i].name;
            }
            if (scaleType == vp.scales.ScaleType.categoryIndex || scaleType == vp.scales.ScaleType.categoryKey) {
                //if (appMgr && axisName)
                //{
                //    binNames = this.getUnionOfKeys(appMgr, axisName);
                //}
                scale.categoryKeys(binNames);
            }
            else {
                //---- looks at each bin value and determines the current sort order ----
                var order = this.getOrderOfBins(bins);
                //---- order = 1 means ascending order ----
                //---- order = 0 means bins are in random order, according to their conseq. min/max values ----
                //---- order = -1 means descending order ----
                var useCategoryForBins = (order != 1);
                if (useCategoryForBins) {
                    var oldScale = scale;
                    scale = vp.scales.createCategoryIndex()
                        .categoryKeys(binNames)
                        .range(oldScale.rangeMin(), oldScale.rangeMax());
                    binResults.useCategoryForBins = true;
                }
                else {
                    var breakValues = [];
                    var labels = [];
                    var numBins = binResults.bins;
                    var anyScale = scale;
                    for (var b = 0; b < numBins.length; b++) {
                        var numBin = numBins[b];
                        breakValues.push(numBin.min);
                        labels.push(numBin.minLabel);
                        if (b == bins.length - 1) {
                            breakValues.push(numBin.max);
                            labels.push(numBin.maxLabel);
                        }
                    }
                    anyScale._breaks = breakValues;
                    anyScale._labels = labels;
                    if (scaleType == vp.scales.ScaleType.dateTime && !anyScale._formatter) {
                        //---- use the formatString returned by the binning function ----
                        var formatString = binResults.dateFormatString;
                        var formatter = vp.formatters.createExcelFormatter(formatString, "date");
                        anyScale._formatter = formatter;
                    }
                }
            }
            var anyScale = scale;
            anyScale._binResults = binResults;
            anyScale._useCategoryForBins = useCategoryForBins;
            return scale;
        };
        chartUtils.getScatterShapeSize = function (dc, recordCount, chart) {
            var maxShapeSize = (chart) ? chart.defaultShapeSize() : null;
            if (maxShapeSize) {
                //---- convert from pixels to world units ----
                maxShapeSize = chart.getTransformer().screenSizeXToWorld(maxShapeSize);
            }
            else {
                var facetCount = (dc.facetHelper) ? dc.facetHelper.facetCount() : 0;
                if (recordCount === undefined || recordCount === null) {
                    recordCount = dc.filteredRecordCount;
                }
                maxShapeSize = this.getScatterShapeSizeEx(recordCount, dc.width, dc.height, facetCount);
            }
            return maxShapeSize;
        };
        /** returns the best shape size (in world units) for a scatter-like chart. */
        chartUtils.getScatterShapeSizeEx = function (filteredRecordCount, width, height, facetCount) {
            var count = filteredRecordCount;
            //---- density-based shape size ----
            var maxShapeSize = Math.sqrt((width * height) / count);
            //---- adjust for spacing ----
            if (facetCount > 1) {
                maxShapeSize *= 1.25;
            }
            else {
                maxShapeSize *= .375; // .25;
            }
            return maxShapeSize;
        };
        chartUtils.computeMaxCountOverFacets = function (dc, nvFacetBuckets) {
            var maxCount = 0;
            if (nvFacetBuckets) {
                for (var i = 0; i < nvFacetBuckets.length; i++) {
                    var nv = nvFacetBuckets[i];
                    var count = nv.layoutFilter.count(0);
                    maxCount = Math.max(maxCount, count);
                }
            }
            else {
                maxCount = dc.filteredRecordCount;
            }
            return maxCount;
        };
        /** Compute the fixed-width and max-height of bins for a Column Chart. This code is shared to encourage consistent layout results for
         * Column Grid, Column Sum.
         */
        chartUtils.computeColumnBinSize = function (facetResult, availWidth, availHeight) {
            var binCount = facetResult.bins.length;
            var approxItemWidth = availWidth / binCount;
            var xMargin = .05 * approxItemWidth;
            var xBetween = .10 * approxItemWidth;
            var binWidth = (availWidth - (2 * xMargin) - (binCount - 1) * xBetween) / binCount;
            var binHeight = availHeight;
            return { binWidth: binWidth, binHeight: binHeight, xMargin: xMargin, xBetween: xBetween };
        };
        /** Compute the max-width and fixed-height of bins for a Bar chart. This code is shared to encourage consistent layout results for
         * Bar Grid, Bar Sum.
         */
        chartUtils.computeBarBinSize = function (facetResult, availWidth, availHeight) {
            var binCount = facetResult.bins.length;
            var approxItemHeight = availHeight / binCount;
            var yMargin = .05 * approxItemHeight;
            var yBetween = .15 * approxItemHeight;
            //---- compute itemWidth and itemHeight ----
            var itemHeight = (availHeight - (2 * yMargin) - (binCount - 1) * yBetween) / binCount;
            var itemWidth = availWidth;
            return { binWidth: itemWidth, binHeight: itemHeight, yMargin: yMargin, yBetween: yBetween };
        };
        chartUtils.capitalizeFirstLetter = function (value) {
            if (value.length) {
                value = value[0].toUpperCase() + value.substr(1);
            }
            return value;
        };
        return chartUtils;
    }());
    beachParty.chartUtils = chartUtils;
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    drawContext.ts - information for layout classes about the drawing/chart context.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** information needed to draw a facet/chart. */
    var DrawContext = (function () {
        function DrawContext(rcxWorld, facetHelper, nvData, scales, recordCount, filteredRecordCount, /*attrInfos: any,*/ userSizeFactor, fromChartType, toChartType, itemSize, transformer, chart) {
            /** used by baseGlVis code the scale size to GL sizes after user layout (transformSizeFactor * userSizeFactor. */
            //combinedSizeFactor: number;
            /* the recommend shape size for equal density layout of shapes.  some charts may use other sizes. */
            this.maxShapeSize = 0;
            /* how does this compare to maxShapeSize? */
            this.itemSize = 0;
            /* this is 1/2 of itemSize. */
            this.itemHalf = 0;
            //---- minimums ----
            this.x = rcxWorld.left;
            this.y = rcxWorld.bottom; // top
            this.z = rcxWorld.back;
            //---- positive sizes ----
            this.width = rcxWorld.right - rcxWorld.left;
            this.height = rcxWorld.top - rcxWorld.bottom;
            this.depth = rcxWorld.front - rcxWorld.back;
            this.facetHelper = facetHelper;
            this.nvData = nvData;
            this.scales = scales;
            this.recordCount = recordCount;
            this.filteredRecordCount = filteredRecordCount;
            //this.attrInfos = attrInfos;
            this.fromChartType = fromChartType;
            this.toChartType = toChartType;
            this.facetIndex = 0;
            //---- sizes ----
            //this.transformSizeFactor = transformSizeFactor;
            this.userSizeFactor = userSizeFactor;
            //this.combinedSizeFactor = combinedSizeFactor;
            //---- is there a difference between itemSize and maxShapeSize? ----
            this.maxShapeSize = beachParty.chartUtils.getScatterShapeSize(this, null, chart);
            this.itemSize = this.maxShapeSize; //   itemSize;
            this.itemHalf = this.itemSize / 2;
            var zSpace = 4;
            this.defaultDepth2d = Math.min(this.itemSize * .05, zSpace * .25);
            this.layoutFilterVector = (nvData.layoutFilter && nvData.layoutFilter.values != null) ? nvData.layoutFilter.values : null;
            if (!this.layoutFilterVector) {
            }
            //---- compute SPACING FACTOR ----
            var marginBase = this.width / 5000;
            if (facetHelper) {
                marginBase *= 5;
            }
            this.spacingFactor = 4 * chart.separationFactor() * marginBase;
            if (recordCount > 10000) {
                this.spacingFactor *= .1; //.2;
            }
            this.transformer = transformer;
            //cellMargin *= 2;             
        }
        return DrawContext;
    }());
    beachParty.DrawContext = DrawContext;
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chartBuilder.ts - does sizing of axes and plot area, followed by layout of specific view/chart type.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var chartBuilderClass = (function (_super) {
        __extends(chartBuilderClass, _super);
        function chartBuilderClass(parentElem, chart) {
            var _this = this;
            _super.call(this);
            this._buildTimer = null;
            this._buildNeededReason = null;
            this._drawNeededReason = "";
            this._isAggChart = false;
            this._isXAxisClickable = true;
            this._isYAxisClickable = true;
            this._shapes = []; // for building chart repro data (stored in Insights)
            this._selectionExists = false;
            this._primaryColorCount = 0;
            this._maxColors = 0; // mapped colors and selection color(s)
            this._prevDrawBounds = null;
            //---- FILTERING ----
            this._isFirstFilteredStage = false; // true if this is first of 2-stage filter cycles (shape engine animation cycles)
            this._isForwardFilter = true;
            //---- FACETS ----
            this._facetHelper = null;
            //---- the part of the client that contains just the plot ----
            this._rcPlotEst = vp.geom.createRect(0, 0, 1, 1); // estimate without axes
            this._rcPlotFinal = vp.geom.createRect(0, 0, 1, 1); // with axes taken into account (this is where plot in drawn within our webGL canvas)
            //---- size of the client area (containing the axes and the plot) ----
            this._clientWidth = 0;
            this._clientHeight = 0;
            this._maxItems = 0; // max items we are drawing?
            this._isSelectionChangeOnly = false;
            //---- PERF STATS ----
            this._buildPerf = {};
            this._drawCount = 0;
            this._buildChartElapsed = 0;
            this._layoutTime = 0;
            //---- events ----
            this.onCycleStart = new beachParty.bpEvent();
            this.onCycleEnd = new beachParty.bpEvent();
            //---- create CANVAS under parent ----
            var parentW = vp.select(parentElem);
            //.css("position", "relative")
            //---- make this exactly size of parent, so we don't have to resize and move it ----
            var canvasElemW = parentW.append("canvas")
                .id("glCanvas")
                .css("left", "0")
                .css("top", "0")
                .css("position", "absolute")
                .css("z-index", "999");
            var svgW = parentW.append("svg")
                .id("svgCanvas")
                .css("left", "0")
                .css("top", "0")
                .css("width", "100%")
                .css("height", "100%")
                .css("position", "absolute")
                .css("z-index", "1001");
            this._parentElem = parentW[0];
            this._glCanvasElem = canvasElemW[0];
            this._svgDoc = svgW[0];
            this.createSvgGroup();
            this._chart = chart;
            this._dataMgr = chart.getDataMgr();
            this._dataMgr.registerForChange("dataFrame", function (e) {
                //---- reset facet settings ----
                _this.onFacetChanged();
                //---- when data changes, reset the gl buffers ----
                _this._shapeEng.clearFromBuffers();
            });
            this._shapeEng = new beachParty.ShapeEngClass(canvasElemW[0]);
            var gl = this._shapeEng.getGlContext();
            this._shapeEng.onDrawFrame.attach(this, function (e) {
                _this._drawNeededReason = null;
                var touchMgr = _this._chart.getChartUx().getTouchMgr();
                touchMgr.onFrame();
            });
            this._shapeEng.onCycleEnd.attach(this, function (ss) {
                //---- trigger our own ON CYCLE END event ----
                var cs = ss;
                cs.buildChartElapsed = _this._buildChartElapsed;
                cs.layoutTime = _this._layoutTime;
                cs.isFirstFilterStage = _this._isFirstFilteredStage;
                cs.isSelectionChangeOnly = _this._isSelectionChangeOnly;
                _this.onCycleEnd.trigger(cs);
                _this._chartFrameHelper.fadeInOut(true);
                //---- 2-stage filter support ----
                var wasFirstFilteredStage = _this._isFirstFilteredStage;
                _this._prevFilter = (_this._nv.enterExitFilter) ? _this._nv.enterExitFilter.clone() : null;
                if (_this._isFirstFilteredStage) {
                    _this._isFirstFilteredStage = false;
                    //---- start new cycle ----
                    _this.markBuildNeeded("isFirstFilteredStage");
                }
                _this._isSelectionChangeOnly = false;
            });
            var transformer = new beachParty.transformerClass(gl); //   this._shapeEng.getTransformer();
            this._transformerMgr = new beachParty.transformMgrClass(gl, transformer);
            this._transformer = this._transformerMgr.getTransformer();
            this.buildChartFrameHelper();
            this._animationData = chart.animationData();
            this.refreshClientSize();
        }
        chartBuilderClass.prototype.getChartBounds = function () {
            var rc = vp.select(this._parentElem).getBounds();
            return rc;
        };
        chartBuilderClass.prototype.onFilteredChanged = function (isForward) {
            //---- this may cause "onEndOfCycle()" to be called, which resets "this._isFirstFilteredStage", so call this first ----
            this.markBuildNeeded("onFilteredChanged");
            this._isFirstFilteredStage = true;
            this._isForwardFilter = isForward;
        };
        chartBuilderClass.prototype.getGlCanvasElem = function () {
            return this._glCanvasElem;
        };
        chartBuilderClass.prototype.getSvgDoc = function () {
            return this._svgDoc;
        };
        chartBuilderClass.prototype.rectsDiffer = function (rc, rc2) {
            var isDiff = (rc.left != rc2.left || rc.top != rc2.top || rc.width != rc2.width || rc.height != rc2.height);
            return isDiff;
        };
        chartBuilderClass.prototype.rebuildCameraIfNeeded = function () {
            var rcFrame = this._rcPlotFinal;
            var rcPrev = this._prevDrawBounds;
            if (!rcPrev || !rcFrame || this.rectsDiffer(rcPrev, rcFrame)) {
                //---- REBUILD CAMERA immediately, so user can call getWorldBounds() ----
                this._transformer.updateCamera(this._transformer._isOrthoCamera, rcFrame.width, rcFrame.height);
                this._prevDrawBounds = rcFrame;
            }
            return rcFrame;
        };
        chartBuilderClass.prototype.getTransformer = function () {
            return this._transformer;
        };
        chartBuilderClass.prototype.getWorldBounds = function () {
            return this._transformer.getWorldBounds();
        };
        chartBuilderClass.prototype.setUpShapeEngParams = function () {
            var dp = this._shapeEng.getParams(); // start with default values
            var chart = this._chart;
            var rcBounds = this.rebuildCameraIfNeeded();
            //---- required parameters ----
            dp.canvasWidth = rcBounds.width;
            dp.canvasHeight = rcBounds.height;
            //---- animation, staggering ----
            this._animationData = this._chart.animationData();
            dp.animationParams = this._animationData;
            //---- drawing params ----
            dp.cameraParams = this._transformer.cameraParams();
            dp.sizeFactor = chart.sizeFactor();
            dp.drawPrimitive = beachParty.DrawPrimitive[chart.drawingPrimitive()];
            dp.useInstancing = this._chart.isInstancingEnabled();
            dp.drawOrderKey = this.getDrawOrderKey();
            dp.facetBins = this.getFacetBins();
            //dp.maxGlBufferLength = 16000;           // keep GL buffers relatively small
            //---- color params ----
            var colorPalette = this._finalColorPalette.slice(0, this._maxColors);
            dp.colorPalette = colorPalette; // contains shapeColor as the first entry
            dp.clearColor = chart.canvasColor();
            //---- selection, hover params ----
            dp.hoverParams = this._chart.getHoverParams();
            dp.hoverPrimaryKey = this._chart.hoverPrimaryKey();
            //---- lighting, opacity, blending ----
            var lightingParamns = this._chart.getLightingParanms();
            dp.lightParams = lightingParamns;
            dp.shapeOpacity = chart.shapeOpacity();
            dp.isBlendingEnabled = (!this._layout.getIs3dChart());
            //---- textures ----
            dp.shapeImage = this._chart.shapeImage();
            dp.useTextures = true;
            this._shapeEng.setParams(dp);
        };
        chartBuilderClass.prototype.getColorPalette = function () {
            var palette = null;
            var cm = this._chart.colorMapping();
            if (cm && cm.colName) {
                palette = cm.colorPalette;
            }
            return palette;
        };
        chartBuilderClass.prototype.getDrawOrderKey = function () {
            var drawOrderKey = null;
            if (this._dataFrame) {
                drawOrderKey = this._dataFrame.getSortKey();
                if (this._facetHelper) {
                    var facetHelper = this._facetHelper;
                    drawOrderKey = facetHelper._colName + "-" + facetHelper._facetCount + "-" + drawOrderKey;
                }
            }
            return drawOrderKey;
        };
        chartBuilderClass.prototype.getFacetBins = function () {
            var facetBins = null;
            if (this._facetHelper) {
                var facetHelper = this._facetHelper;
                var bins = facetHelper.binResult().bins;
                var layout = facetHelper.layout();
                facetBins = [];
                for (var i = 0; i < bins.length; i++) {
                    var fb = new beachParty.FacetBin();
                    fb.rowIndexes = bins[i].rowIndexes;
                    fb.drawOffset = { x: layout.facetBounds[i].x, y: layout.facetBounds[i].y };
                    facetBins.push(fb);
                }
            }
            return facetBins;
        };
        chartBuilderClass.prototype.getShapeEngine = function () {
            return this._shapeEng;
        };
        chartBuilderClass.prototype.createSvgGroup = function () {
            //---- create an svg GROUP element for chart to use for all of its SVG shapes ----
            var svgChartGroup = vp.select(this._svgDoc).append("g");
            //.translate(10, 10)          // account for margin bet. svgdoc & canvas 
            this._svgChartGroup = svgChartGroup[0];
            //---- create an svg GROUP element for the chart frame ----
            var svgChartFrameGroup = vp.select(this._svgDoc).append("g")
                .addClass("chartFrameGroup");
            this._svgChartFrameGroup = svgChartFrameGroup[0];
        };
        /**
         * A chart single frame draw has been requested.
         * @param reason
         */
        chartBuilderClass.prototype.redrawLastFrame = function (reason) {
            //---- ensure there is a last frame to draw ----
            if (this._finalColorPalette) {
                if (!this._drawNeededReason) {
                    this._drawNeededReason = reason;
                }
                this.setUpShapeEngParams();
                this._shapeEng.redrawLastFrame();
            }
        };
        /**
         * A new animation cycle has been requested.
         * @param reason
         */
        chartBuilderClass.prototype.markBuildNeeded = function (reason, ignoreFilterStage) {
            var _this = this;
            if (!this._buildTimer && this._chart.isVisible() && this._chart.isAutoRebuild()) {
                this._buildTimer = setTimeout(function (e) {
                    if (ignoreFilterStage) {
                        _this._isFirstFilteredStage = false;
                    }
                    _this.buildChart();
                }, 100);
                this._buildNeededReason = reason;
                this._isSelectionChangeOnly = (reason == "selectionChanged");
            }
        };
        chartBuilderClass.prototype.cancelBuildTimer = function () {
            if (this._buildTimer) {
                clearTimeout(this._buildTimer);
                this._buildTimer = null;
            }
        };
        chartBuilderClass.prototype.getCol = function (dataFrame, attrName, getOrigData) {
            var vector = null;
            if (attrName) {
                if (getOrigData) {
                    vector = dataFrame.getVector(attrName, false);
                }
                else {
                    vector = dataFrame.getNumericVector(attrName);
                }
            }
            return vector;
        };
        chartBuilderClass.prototype.buildNamedVectors = function (dataFrame) {
            //var attrInfos = this._attrInfos;
            var length = dataFrame.getRecordCount();
            //var bindings = this._chart.getBindings();
            var chart = this._chart;
            //---- get attribute/column mappings ----
            var xMap = chart.xMapping();
            var yMap = chart.yMapping();
            var zMap = chart.zMapping();
            var auxMap = chart.auxMapping();
            var crMap = chart.colorMapping();
            var szMap = chart.sizeMapping();
            var txMap = chart.textMapping();
            var imMap = chart.shapeMapping();
            var faMap = chart.facetMapping();
            var xData = this.getCol(dataFrame, xMap.colName);
            if (this._isAggChart) {
                var dataAgg = this._dataMgr.getPreload().dataAggregation;
                var strAggType = beachParty.AggType[dataAgg.aggType];
                var yData = this.getCol(dataFrame, strAggType);
            }
            else {
                var yData = this.getCol(dataFrame, yMap.colName);
            }
            var zData = this.getCol(dataFrame, zMap.colName);
            var auxData = this.getCol(dataFrame, auxMap.colName);
            var ch = crMap.channelMapping;
            if (ch) {
                var redData = this.getCol(dataFrame, ch.redColumn);
                var greenData = this.getCol(dataFrame, ch.greenColumn);
                var blueData = this.getCol(dataFrame, ch.blueColumn);
                var rgbData = this.getCol(dataFrame, ch.rgbColumn, true);
                this._selectionColor = vp.color.getColorFromName("yellow");
            }
            var sizeData = this.getCol(dataFrame, szMap.colName);
            var colorData = this.getCol(dataFrame, crMap.colName);
            var imageIndexData = this.getCol(dataFrame, imMap.colName);
            var textData = this.getCol(dataFrame, txMap.colName, true);
            var facetData = this.getCol(dataFrame, faMap.colName);
            //---- todo: remove this ----
            var staggerOffsetData = null; // this.getCol(dataFrame, "staggerOffset");
            var selectData = this.getCol(dataFrame, beachParty.selectedName);
            var filterData = this.getCol(dataFrame, beachParty.filteredName);
            var randomXData = this.getCol(dataFrame, beachParty.randomXName);
            var randomYData = this.getCol(dataFrame, beachParty.randomYName);
            //---- try treating primary key vector just like the numeric mapping data ----
            var primaryKeyData = this.getCol(dataFrame, beachParty.primaryKeyName);
            /// support for 2-stage filter/layout:
            ///     layoutFilter - when entry is true, the record should NOT be included in the chart layout
            ///     enterExitFilter - when entry is true, the record WILL be included in the ENTER/EXIT effect
            var nv = new beachParty.NamedVectors(length, xData, yData, zData, colorData, imageIndexData, staggerOffsetData, sizeData, textData, facetData, selectData, filterData, filterData, primaryKeyData, randomXData, randomYData, redData, greenData, blueData, auxData, rgbData);
            if (this._isFirstFilteredStage && this._isForwardFilter) {
                nv.layoutFilter = this._prevFilter;
            }
            return nv;
        };
        chartBuilderClass.prototype.hideAxes = function (value) {
            if (arguments.length == 0) {
                return this._hideAxes;
            }
            this._hideAxes = value;
            this.onDataChanged("hideAxes");
        };
        chartBuilderClass.prototype.isAggChart = function (value) {
            if (arguments.length == 0) {
                return this._isAggChart;
            }
            this._isAggChart = value;
            this.onDataChanged("isAggChart");
        };
        chartBuilderClass.prototype.isXAxisClickable = function (value) {
            if (arguments.length == 0) {
                return this._isXAxisClickable;
            }
            this._isXAxisClickable = value;
            this.onDataChanged("isXAxisClickable");
        };
        chartBuilderClass.prototype.getFacetHelper = function () {
            return this._facetHelper;
        };
        chartBuilderClass.prototype.getTransformMgr = function () {
            return this._transformerMgr;
        };
        chartBuilderClass.prototype.isYAxisClickable = function (value) {
            if (arguments.length == 0) {
                return this._isYAxisClickable;
            }
            this._isYAxisClickable = value;
            this.onDataChanged("isYAxisClickable");
        };
        chartBuilderClass.prototype.updatePlotBounds = function (left, top, width, height, usingFacets, resizeElements) {
            var canvas3dElem = this._glCanvasElem;
            //var canvas2dElem = this._chart.getCanvas2d();
            //---- adjust so we don't overwrite the axes/box of chart ----
            //left++;
            //top++;
            //width = Math.ceil(Math.max(0, width - 2));
            //height = Math.ceil(Math.max(0, height - 3));
            left = Math.round(left);
            top = Math.round(top);
            width = Math.ceil(Math.max(0, width));
            height = Math.ceil(Math.max(0, height));
            if (resizeElements) {
                //---- try to avoid changing size of canvas since it clears the canvas and causes a blinking effect ----
                //---- move the actual resizing to just before we draw to see if that helps to hide the blinking ----
                var rcCurrent = this._rcPlotFinal;
                var canvasW = vp.select(canvas3dElem);
                //var rc = canvasW.getBounds();
                if (rcCurrent.left != left || rcCurrent.top != top) {
                    //---- moving the canvas does not blank it ----
                    canvasW
                        .css("left", left + "px")
                        .css("top", top + "px");
                }
                if (rcCurrent.width != width || rcCurrent.height != height) {
                    vp.utils.debug("SETTING pending size: width=" + width + ", height=" + height);
                    this._pendingCanvasResize = { width: width, height: height };
                }
                this._rcPlotFinal = vp.geom.createRect(left, top, width, height);
            }
            this._rcPlotEst = vp.geom.createRect(left, top, width, height);
            this.onDataChanged("plotBounds");
            this.updateTransformerCamera();
        };
        chartBuilderClass.prototype.getMaxItemsInView = function (nv) {
            var maxItems = 0;
            //---- does client want to override max count? ----
            if (this._chart.isMaxItemCountEnabled()) {
                maxItems = this._chart.maxItemCount();
            }
            else {
                maxItems = beachParty.cbUtils.getDataLength(nv, true);
            }
            return maxItems;
        };
        chartBuilderClass.prototype.clearMinMaxBreaks = function (md) {
            md.minBreakFacet = undefined;
            md.maxBreakFacet = undefined;
        };
        chartBuilderClass.prototype.buildColorScale = function (nv, md) {
            var scale = null;
            //---- default (non mapped) ----
            this._maxColors = (this._selectionExists) ? 2 : 1;
            if (nv && nv.colorIndex) {
                var chart = this._chart;
                var cm = chart.colorMapping();
                var colType = nv.colorIndex.colType;
                var colorCount = this._primaryColorCount;
                //---- unselected colors start at index=0 ----
                //---- selected colors have been moved to offset 14+ in the palette ----
                var maxIndex = colorCount - 1;
                var catKeys = null;
                if (colType == "string" || cm.forceCategory) {
                    //---- create CATEGORY scale ----
                    //---- use currently bound values (based on current/previous filter settings) ----
                    catKeys = cm.boundColInfo.stats.sortedKeys;
                    if (!catKeys) {
                        //---- fallback to current filter settings ----
                        catKeys = beachParty.cbUtils.getFilteredSortedKeys(nv.colorIndex, nv.layoutFilter);
                    }
                }
                if (!cm.isContinuous) {
                    //---- range mapping will be DISCRETE ----
                    if (catKeys) {
                        //---- if keyCount is smaller than color palette, only map to keyCount entries ----
                        var keyCount = catKeys.length;
                        if (keyCount < colorCount) {
                            colorCount = keyCount;
                        }
                        else if (keyCount > colorCount) {
                        }
                    }
                    maxIndex = colorCount - 1;
                    //---- add this so that when we take floor(scaledValue), we correctly map to stepped palette entries ----
                    maxIndex += .999999; // adding another "9" here breaks scaling on WebGL (gets interpreted as a "1")
                }
                this._maxColors = (this._selectionExists) ? (2 * colorCount) : colorCount;
                if (catKeys) {
                    var palette = (cm.isContinuous) ? [0, colorCount - 1] : vp.data.range(0, colorCount - 1);
                    var palette = (false) ? [0, colorCount - 1] : vp.data.range(0, colorCount - 1);
                    //---- CATEGORY scale ----
                    scale = vp.scales.createCategoryKey()
                        .categoryKeys(catKeys)
                        .isPaletteDiscrete(!cm.isContinuous)
                        .palette(palette);
                    if (cm.isCycling) {
                        scale.isRangeClipping(false); // allow values to cycle thru available colors
                    }
                }
                else {
                    var minVal = 0;
                    var maxVal = 0;
                    if (cm.breaks && cm.breaks.length && nv.colorIndex.colType != "string") {
                        //---- get min/max from breaks ----
                        var len = cm.breaks.length;
                        minVal = cm.breaks[0];
                        maxVal = cm.breaks[len - 1];
                    }
                    else {
                        //---- get min/max from data ----
                        var result = beachParty.cbUtils.getMinMax(nv.colorIndex, nv.layoutFilter, md);
                        minVal = result.min;
                        maxVal = result.max;
                    }
                    if (cm.spread == beachParty.MappingSpread.low) {
                        //---- SPREAD LOW scale  ----
                        scale = vp.scales.createLowBias()
                            .domainMin(minVal)
                            .domainMax(maxVal)
                            .range(0, maxIndex);
                    }
                    else if (cm.spread == beachParty.MappingSpread.high) {
                        //---- SPREAD HIGH scale ----
                        scale = vp.scales.createHighBias()
                            .domainMin(minVal)
                            .domainMax(maxVal)
                            .range(0, maxIndex);
                    }
                    else {
                        //---- normal LINEAR scale ----
                        scale = vp.scales.createLinear()
                            .domainMin(minVal)
                            .domainMax(maxVal)
                            .range(0, maxIndex);
                    }
                }
            }
            if (scale && colType) {
                beachParty.cbUtils.buildFormatter(md, scale, colType);
            }
            return scale;
        };
        chartBuilderClass.prototype.refreshClientSize = function () {
            var rc = vp.select(this._parentElem).getBounds();
            this._clientWidth = rc.width;
            this._clientHeight = rc.height;
        };
        chartBuilderClass.prototype.buildChartFrameHelper = function () {
            var _this = this;
            if (!this._chartFrameHelper) {
                var chartFrameGroup = this._svgChartFrameGroup;
                this._chartFrameHelper = new beachParty.chartFrameHelperClass(chartFrameGroup, this, this._dataMgr, this._transformer, this._chart.blankValueStr());
                this._chartFrameHelper.onTickBoxClick.attach(this, function (e) {
                    var selectKey = e.axisName + "." + e.boxLabel;
                    _this._chart.searchEx([e.searchParams], selectKey);
                });
            }
        };
        /// Called as dynamic method when the colName for "chart._attrFacet" has changed.
        chartBuilderClass.prototype.onFacetChanged = function () {
            var fm = this._chart.facetMapping();
            var colName = fm.colName;
            var facetCount = fm.binCount;
            var isUsingFacets = (colName && colName.length);
            if (isUsingFacets) {
                //var rcx = this._transformer._rcxWorld;
                this._facetHelper = new beachParty.facetHelperClass(colName, facetCount, fm.binCount, fm.facetBounds, this._transformer, fm);
            }
            else {
                this._facetHelper = null;
            }
        };
        chartBuilderClass.prototype.onLayoutNameChanged = function () {
            var cs = this._currentChartSpecs;
            var cs2 = this._chart.getChartSpecs();
            if (!cs || !cs2 || !cs.isEqual(cs2)) {
                this.applyNewChartSpecs(cs2);
                this._currentChartSpecs = new ChartSpecs(cs2.getChartType(), cs2.layoutType());
            }
        };
        chartBuilderClass.prototype.applyNewChartSpecs = function (cs) {
            var chartType = cs.getChartType();
            var layoutType = cs.layoutType();
            var usePartyGen = false;
            var layout;
            if (chartType == beachParty.ChartType.Spiral) {
                //---- SPIRAL ----
                if (usePartyGen) {
                    layout = new beachParty.partyGenPlotClass(this._chart, "FlatCircle");
                }
                else {
                    layout = new beachParty.flatCircle(this._chart);
                }
            }
            else if (chartType == beachParty.ChartType.Random) {
                //---- RANCOM ----
                if (usePartyGen) {
                    layout = new beachParty.partyGenPlotClass(this._chart, "FlatRandom");
                }
                else {
                    layout = new beachParty.flatRandom(this._chart);
                }
            }
            else if (chartType == beachParty.ChartType.Poisson) {
                //---- POISSON ----
                layout = new beachParty.partyGenPlotClass(this._chart, "FlatPoisson");
            }
            else if (chartType == beachParty.ChartType.Grid) {
                //---- GRID ----
                if (usePartyGen) {
                    layout = new beachParty.partyGenPlotClass(this._chart, "FlatGrid");
                }
                else {
                    if (layoutType == beachParty.LayoutType.Squarify) {
                        //---- SQUARIFY ----
                        layout = new beachParty.partyGenPlotClass(this._chart, "FlatSquarify");
                    }
                    else {
                        layout = new beachParty.flatGrid(this._chart);
                    }
                }
            }
            else if (chartType == beachParty.ChartType.Scatter) {
                //---- SCATTER ----
                layout = new beachParty.scatterPlotClass(this._chart);
            }
            else if (chartType == beachParty.ChartType.Column) {
                //---- COLUMN ----
                if (usePartyGen) {
                    layout = new beachParty.partyGenPlotClass(this._chart, "ColumnGrid");
                }
                else {
                    if (layoutType == beachParty.LayoutType.Strips) {
                        //---- COLUMN STRIP ----
                        layout = new beachParty.columnSumClass(this._chart);
                    }
                    else if (layoutType == beachParty.LayoutType.Squarify) {
                        //---- COLUMN SQUARIFY ----
                        layout = new beachParty.columnSquarifyClass(this._chart);
                    }
                    else if (layoutType == beachParty.LayoutType.Percent) {
                        //---- COLUMN PERCENT ----
                        layout = new beachParty.columnPercentClass(this._chart);
                    }
                    else {
                        //---- COLUMN ----
                        layout = new beachParty.columnCountClass(this._chart);
                    }
                }
            }
            else if (chartType == beachParty.ChartType.Density) {
                //---- DENSITY ----
                layout = new beachParty.densityGrid(this._chart);
            }
            else if (chartType == beachParty.ChartType.Stacks) {
                //---- STACKS ----
                layout = new beachParty.stacksBinClass(this._chart);
            }
            else if (chartType == beachParty.ChartType.Scatter3D) {
                //---- SCATTER 3D ----
                layout = new beachParty.scatterPlot3dClass(this._chart);
            }
            else if (chartType == beachParty.ChartType.Line) {
                //---- LINE ----
                layout = new beachParty.linePlotClass(this._chart, false, false);
            }
            else if (chartType == beachParty.ChartType.Links) {
                //---- LINKS ----
                layout = new beachParty.linePlotClass(this._chart, true, true);
            }
            else if (chartType == beachParty.ChartType.Radial) {
                //---- RADIAL ----
                layout = new beachParty.radialClass(this._chart);
            }
            else if (chartType == beachParty.ChartType.Xband) {
                //---- X BAND ----
                layout = new beachParty.xBandClass(this._chart);
            }
            else if (chartType == beachParty.ChartType.Yband) {
                //---- Y BAND ----
                layout = new beachParty.yBandClass(this._chart);
            }
            else if (chartType == beachParty.ChartType.Bar) {
                if (usePartyGen) {
                    layout = new beachParty.partyGenPlotClass(this._chart, "BarGrid");
                }
                else {
                    //---- these SUM options are not yet supported for the Bar chart ----
                    //if (layoutType == LayoutType.Strips)
                    //{
                    //    layout = new barSumClass(this._chart);
                    //}
                    //else if (layoutType == LayoutType.Squarify)
                    //{
                    //    layout = new barSquarifyClass(this._chart);
                    //}
                    //else if (layoutType == LayoutType.Percent)
                    //{
                    //    layout = new barPercentClass(this._chart);
                    //}
                    //else
                    {
                        layout = new beachParty.barCountClass(this._chart);
                    }
                }
            }
            else if (chartType == beachParty.ChartType.Violin) {
                //---- VIOLIN ----
                layout = new beachParty.violinClass(this._chart);
            }
            else if (chartType == beachParty.ChartType.Custom) {
                //---- CUSTOM ----
                layout = new beachParty.fullCustomClass(this._chart);
            }
            else {
                vp.utils.error("Unrecognized chart type=" + beachParty.ChartType[+chartType]);
            }
            this._layout = layout;
        };
        chartBuilderClass.prototype.getLayout = function () {
            return this._layout;
        };
        chartBuilderClass.prototype.getChart = function () {
            return this._chart;
        };
        chartBuilderClass.prototype.getClientWidth = function () {
            return this._clientWidth;
        };
        chartBuilderClass.prototype.getClientHeight = function () {
            return this._clientHeight;
        };
        chartBuilderClass.prototype.buildDefaultScales = function (nv, rcxWorld, filteredRecordCount, facetCount) {
            var chart = this._chart;
            //---- camera is positive Z, object are negative Z ----
            var xScale = beachParty.cbUtils.makeRangeScale(nv.x, nv.layoutFilter, rcxWorld.left, rcxWorld.right, undefined, chart.xMapping());
            var yScale = beachParty.cbUtils.makeRangeScale(nv.y, nv.layoutFilter, rcxWorld.bottom, rcxWorld.top, undefined, chart.yMapping());
            var zMin = -2;
            var zMax = zMin + 4;
            var zScale = beachParty.cbUtils.makeRangeScale(nv.z, nv.layoutFilter, zMin, zMax, undefined, chart.zMapping());
            //---- build SIZE scale ----
            var sm = chart.sizeMapping();
            var clientSizePalette = sm.sizePalette;
            var breaks = sm.breaks;
            var szPalette = vp.utils.copyArray(clientSizePalette);
            var sizeScale = beachParty.cbUtils.makePaletteScale(nv.size, nv.layoutFilter, szPalette, null, breaks, chart.sizeMapping());
            //---- build IMAGE INDEX scale ----
            var im = chart.shapeMapping();
            var imagePalette = im.imagePalette;
            var breaks = im.breaks;
            var imgIindexPalette = (imagePalette) ? vp.data.range(0, imagePalette.length - 1) : null;
            var imageScale = beachParty.cbUtils.makePaletteScale(nv.imageIndex, nv.layoutFilter, imgIindexPalette, null, breaks, chart.shapeMapping());
            imageScale.isPaletteDiscrete(true);
            //---- build COLOR scale ----
            var cm = chart.colorMapping();
            var colorIndexScale = this.buildColorScale(nv, cm);
            if (cm.channelMapping) {
                var redScale = beachParty.cbUtils.makeRangeScale(nv.red, nv.layoutFilter, 0, 255, 0, cm);
                var greenScale = beachParty.cbUtils.makeRangeScale(nv.green, nv.layoutFilter, 0, 255, 0, cm);
                var blueScale = beachParty.cbUtils.makeRangeScale(nv.blue, nv.layoutFilter, 0, 255, 0, cm);
            }
            return {
                x: xScale, y: yScale, z: zScale, size: sizeScale, colorIndex: colorIndexScale,
                imageIndex: imageScale, red: redScale, green: greenScale, blue: blueScale,
            };
        };
        chartBuilderClass.prototype.prepassAndFrameBuild = function () {
            this.onLayoutNameChanged();
            var userSizeFactor = this._chart.sizeFactor();
            var usingFacets = (this._facetHelper != null);
            var nv = this.buildNamedVectors(this._dataFrame);
            this._nv = nv;
            //---- for consistent results, always do PREPASS calculations with no chartFrame ----
            this.updatePlotBounds(0, 0, this._clientWidth, this._clientHeight, usingFacets, false);
            //---- build PREPASS scales ----
            var rcxWorld = this.calcRanges(nv, true); // false);
            var recordCount = this.getDataLength();
            var filteredRecordCount = this.getMaxItemsInView(nv);
            var nvBuckets = null;
            var facetCount = 0;
            var facetBinResults = null;
            var chart = this._chart;
            this._currentChartClass = chart.getUiChartName();
            //---- clear facet min/max breaks from last build ----
            var xm = chart.xMapping();
            this.clearMinMaxBreaks(xm);
            var ym = chart.yMapping();
            this.clearMinMaxBreaks(ym);
            var zm = chart.zMapping();
            this.clearMinMaxBreaks(zm);
            if (this._facetHelper) {
                var facetHelper = this._facetHelper;
                var requestedFacets = facetHelper._requestedFacets;
                var maxFacets = facetHelper._maxCategoryFacets;
                var sortOptions = new beachParty.binSortOptionsClass();
                var fm = chart.facetMapping();
                sortOptions.sortDirection = fm.binSorting;
                sortOptions.sortByAggregateType = "count";
                var useNiceNumbers = fm.useNiceNumbers;
                facetBinResults = beachParty.binHelper.createBins(nv, "facet", requestedFacets, maxFacets, fm.forceCategory, true, true, sortOptions, null, useNiceNumbers, fm);
                nvBuckets = beachParty.binHelper.splitBinsIntoNamedVectors(facetBinResults, nv);
                facetHelper.binResult(facetBinResults);
                facetCount = facetHelper.facetCount();
            }
            //---- build ESTIMATED scales, based on estimated rcxWorld (with no chart frame) ----
            var scales = this._layout.buildScales(nv, rcxWorld, filteredRecordCount, facetCount);
            //---- build PREPASS drawContext ----
            var dc = new beachParty.DrawContext(rcxWorld, this._facetHelper, nv, scales, recordCount, filteredRecordCount, /*this._attrInfos,*/ userSizeFactor, this._prevChartClass, this._currentChartClass, userSizeFactor, this._transformer, this._chart);
            this._prepassDc = dc;
            //---- let layout do pre-pass over all facets ----
            var maxItems = this._layout.computeFacetStats(dc, nvBuckets);
            this._maxItems = maxItems;
            //---- let chart make PREPASS scale adjustments ----
            this._layout.adjustScales(dc);
            //---- relay maxItems to appMgr, so he can send to client, if subscribed & changed ----
            //this._chart.getAppMgr().setMaxItemCount(maxItems);
            this.onDataChanged("maxItems");
            //---- build the chart frame & axes ----
            var rcPlot = this.buildChartFrame();
            //---- change bounds of gl canvas to "rcPlot" (these bounds used in calcRanges()) ----
            this.updatePlotBounds(rcPlot.left, rcPlot.top, rcPlot.width, rcPlot.height, usingFacets, true);
            //---- build FINAL scales ----
            var rcxWorld = this.calcRanges(nv, true);
            var scales = this._layout.buildScales(nv, rcxWorld, filteredRecordCount, facetCount);
            //---- build FINAL drawContext ----
            var dc = new beachParty.DrawContext(rcxWorld, this._facetHelper, nv, scales, recordCount, filteredRecordCount, /*this._attrInfos,*/ userSizeFactor, this._prevChartClass, this._currentChartClass, userSizeFactor, this._transformer, this._chart);
            //---- let chart make FINAL scale adjustments ----
            this._layout.adjustScales(dc);
            if (usingFacets) {
                this.buildFacetChartFrames(dc);
            }
            return { dc: dc, facetCount: facetCount, nvBuckets: nvBuckets, facetBinResults: facetBinResults };
        };
        chartBuilderClass.prototype.calcRanges = function (nv, facetAdjust) {
            var rcxWorld = beachParty.cbUtils.cloneMap(this._transformer.getWorldBounds());
            if (facetAdjust && this._facetHelper) {
                var fm = this._chart.facetMapping();
                this._facetHelper.setBinCountFromData(this._dataFrame, nv, nv.facet, fm);
                ////---- adjust for yAxis/xAxis ----
                //var yAxisWidthPx = this._chartFrameHelper.getYAxisWidth();
                //var xAxisHeightPx = this._chartFrameHelper.getXAxisHeight();
                //var yAxisWidth = this._transformer.screenSizeXToWorld(yAxisWidthPx);
                //var xAxisHeight = this._transformer.screenSizeYToWorld(xAxisHeightPx);
                var left = rcxWorld.left; // + yAxisWidth;
                var bottom = rcxWorld.bottom; // + xAxisHeight;
                var facetLayout = this._facetHelper.buildFacetLayout(left, bottom, rcxWorld.right, rcxWorld.top);
                //---- adjust rcxWorld so that we scale to fit into a single facet ----
                var rc0 = facetLayout.facetBounds[0];
                rcxWorld.left = rc0.x;
                rcxWorld.right = rc0.x + rc0.width;
                rcxWorld.top = rc0.y + rc0.height;
                rcxWorld.bottom = rc0.y; // - rc0.height;           // flipped axis
            }
            //---- add width, height, depth ----
            rcxWorld.width = rcxWorld.right - rcxWorld.left;
            rcxWorld.height = rcxWorld.top - rcxWorld.bottom;
            rcxWorld.depth = rcxWorld.front - rcxWorld.back;
            return rcxWorld;
        };
        chartBuilderClass.prototype.buildChartFrame = function () {
            var cfd = this._chart.chartFrameData();
            var usingFacets = (this._facetHelper != null);
            var hideAxes = (this._hideAxes || !cfd.isVisible);
            var dc = this._prepassDc;
            var facetLayoutInPixels = this.getFacetLayoutsInPixels();
            var rcPlot = this._chartFrameHelper.build(this._clientWidth, this._clientHeight, hideAxes, usingFacets, cfd, dc, facetLayoutInPixels, this._isXAxisClickable, this._isYAxisClickable);
            return rcPlot;
        };
        chartBuilderClass.prototype.worldBoundsToSvg = function (bounds) {
            //---- translate to 3D canvas coordiates ----
            var rc = this._transformer.worldBoundsToScreen(bounds);
            //---- offset rc so that it is relative to the SVG doc ----
            var rcp = this._rcPlotFinal; // Est;
            rc = vp.geom.createRect(rcp.left + rc.left, rcp.top + rc.top, rc.width, rc.height);
            return rc;
        };
        chartBuilderClass.prototype.getFacetLayoutsInPixels = function () {
            var fl = null;
            var facetHelper = this._facetHelper;
            if (facetHelper && facetHelper._layout) {
                var bins = facetHelper._binResult.bins;
                fl = [];
                for (var b = 0; b < bins.length; b++) {
                    var bin = bins[b];
                    var isFirst = (b == 0);
                    var layout = new beachParty.FacetLayoutInfo();
                    layout.facelLabel = bin.name;
                    layout.facetIndex = b;
                    layout.plotBounds = this.worldBoundsToSvg(facetHelper._layout.facetBounds[b]);
                    layout.labelBounds = this.worldBoundsToSvg(facetHelper._layout.labelBounds[b]);
                    var sp = new beachParty.SearchParams();
                    sp.colName = facetHelper._colName;
                    if (bin instanceof beachParty.BinInfoNum) {
                        var numBin = bin;
                        sp.minValue = numBin.min;
                        sp.maxValue = numBin.max;
                        sp.searchType = (isFirst) ? beachParty.TextSearchType.betweenInclusive : beachParty.TextSearchType.gtrValueAndLeqValue2;
                    }
                    else {
                        var value = (bin.isOther) ? bin.otherKeys : bin.name;
                        sp.minValue = value;
                        sp.maxValue = value;
                        sp.searchType = beachParty.TextSearchType.exactMatch;
                    }
                    layout.searchParams = sp;
                    fl.push(layout);
                }
            }
            return fl;
        };
        chartBuilderClass.prototype.buildFacetChartFrames = function (dc) {
            var cfd = this._chart.chartFrameData();
            var hideAxes = (this._hideAxes || !cfd.isVisible);
            //var dc = this._prepassDc;
            var facetLayoutInPixels = this.getFacetLayoutsInPixels();
            this._chartFrameHelper.buildFacetFrames(this._clientWidth, this._clientHeight, cfd, dc, hideAxes, facetLayoutInPixels, this._isXAxisClickable, this._isYAxisClickable);
        };
        chartBuilderClass.prototype.getDataLength = function (applyFilter) {
            var length = 0;
            if (this._dataFrame) {
                if (applyFilter) {
                    length = this._dataMgr.getFilteredInCount();
                }
                else {
                    length = this._dataFrame.getRecordCount();
                }
            }
            return length;
        };
        chartBuilderClass.prototype.cancelRequestedDraw = function () {
            this.cancelBuildTimer();
        };
        //enableDrawOnTransform(value: boolean)
        //{
        //    var dp = this._shapeEng.getParams();
        //    dp.drawOnTransformChange = value;
        //    this._shapeEng.setParams(dp);
        //}
        chartBuilderClass.prototype.buildChart = function () {
            this.cancelBuildTimer();
            var startBuild = vp.utils.now();
            var cd = new beachParty.CycleDesc();
            cd.isSelectionChangeOnly = this._isSelectionChangeOnly;
            this.onCycleStart.trigger(cd);
            var chart = this._chart;
            this._dataFrame = chart.getDataFrame();
            if (chart.getRecordCount() > 0) {
                var shapeEng = this._shapeEng;
                //this.rebuildCamera();       // based on new area to draw into???
                //---- prevent accidental drawing before we are ready (as our layouts change the current transform) ----
                //this.enableDrawOnTransform(false);
                this._selectionExists = (this._dataMgr.getSelectedCount() > 0);
                //---- build color palette now, so we have _primaryColorCount for further operations ----
                var shapeColor = this._chart.shapeColor();
                var colorPalette = this.getColorPalette();
                this.buildShaderColorPalette(shapeColor, colorPalette);
                //this._primaryColorCount = this._finalColorPalette.length;
                this.buildChartCore();
                this.applyPendingResizeIfNeeded();
                this.setUpShapeEngParams();
                this._layoutTime = vp.utils.now() - startBuild;
                shapeEng.drawShapes(this._shapes);
                this._drawCount++;
                //this.enableDrawOnTransform(true);
                this._prevChartClass = this._currentChartClass;
                this._buildNeededReason = null;
            }
            else {
                //---- release memory when no file is open ----
                this._shapeEng.clearCanvas();
                this._shapeEng.resetBuffers();
                if (this._chartFrameHelper) {
                    //---- remove chartFrameHelper from parent and release ----
                    vp.select(this._chartFrameHelper.getRoot()).remove();
                    this._chartFrameHelper = null;
                    this.buildChartFrameHelper();
                }
                this._nv = null;
                this._prepassDc = null;
                this._shapes = [];
                this._prevFilter = null;
                var cs2 = this._chart.getChartSpecs();
                this.applyNewChartSpecs(cs2); // force old chart (and its memory) to be released 
                this._layoutTime = vp.utils.now() - startBuild;
            }
            this._buildChartElapsed = vp.utils.now() - startBuild;
        };
        chartBuilderClass.prototype.applyPendingResizeIfNeeded = function () {
            if (this._pendingCanvasResize) {
                vp.utils.debug("RESIZING glCanvas to pending size");
                vp.select(this._glCanvasElem)
                    .attr("width", this._pendingCanvasResize.width)
                    .attr("height", this._pendingCanvasResize.height);
                this._pendingCanvasResize = null;
            }
        };
        chartBuilderClass.prototype.updateTransformerCamera = function () {
            //var shapeEng = this._shapeEng;
            //if (updateParamSize)
            //{
            //    var dp = shapeEng.getParams();
            //    //dp.frameRect = vp.geom.createRect(0, 0, this._canvasWidth, this._canvasHeight);
            //    dp.frameRect = this._rcPlotFinal;
            //    shapeEng.setParams(dp);
            //}
            //shapeEng.rebuildCamera();
            var rcFrame = this._rcPlotEst;
            this._transformer.updateCamera(this._transformer._isOrthoCamera, rcFrame.width, rcFrame.height);
        };
        chartBuilderClass.prototype.buildShaderColorPalette = function (shapeColor, colorPalette) {
            var colorNames = (colorPalette) ? (colorPalette) : [shapeColor];
            this._finalColorPalette = this.adjustColorPaletteForSelection(colorNames);
        };
        chartBuilderClass.prototype.adjustColorPaletteForSelection = function (colorNames) {
            //var dp = this._drawParams;
            var selectionExists = this._selectionExists;
            var triplets = [];
            var count = colorNames.length;
            this._primaryColorCount = count;
            //---- convert color names to normalized triplets (RGB) ----
            for (var i = 0; i < count; i++) {
                var crName = beachParty.cbUtils.getBeachPartyColor(colorNames[i]);
                var rgb = vp.color.getColorFromString(crName);
                triplets.push(rgb);
            }
            //---- apply ColorParams to both unselected (first COUNT) color and selected (next COUNT) ----
            var newPalette = [];
            var sParams = this._chart.getSelectionParams();
            var up = sParams.unselectedParams;
            var sp = sParams.selectedParams;
            up.rgb = vp.color.getColorFromString(up.color);
            sp.rgb = vp.color.getColorFromString(sp.color);
            for (var i = 0; i < count; i++) {
                newPalette[i] = this.applyColorParams(triplets[i], up, selectionExists);
                if (selectionExists && i < 14) {
                    newPalette[i + count] = this.applyColorParams(triplets[i], sp, selectionExists);
                }
            }
            this._maxColors = newPalette.length;
            return newPalette;
        };
        chartBuilderClass.prototype.applyColorParams = function (rgb, cp, selectionExists) {
            var value = rgb;
            if (selectionExists) {
                if (cp.colorEffect == beachParty.ColorEffect.setColor) {
                    value = cp.rgb;
                }
                else if (cp.colorEffect == beachParty.ColorEffect.adjustHue) {
                    var hsl = vp.color.hslFromRgb(rgb);
                    hsl = hsl.adjustHue(cp.colorFactor);
                    value = hsl.toRgb();
                }
                else if (cp.colorEffect == beachParty.ColorEffect.adjustSaturation) {
                    var hsl = vp.color.hslFromRgb(rgb);
                    hsl = hsl.adjustSaturation(cp.colorFactor);
                    value = hsl.toRgb();
                }
                else if (cp.colorEffect == beachParty.ColorEffect.adjustValue) {
                    var hsl = vp.color.hslFromRgb(rgb);
                    hsl = hsl.adjustValue(cp.colorFactor);
                    value = hsl.toRgb();
                }
            }
            return value;
        };
        chartBuilderClass.prototype.getMostCentralRecord = function (rcArea, columnList) {
            var colValues = null;
            var primaryKey = null;
            ////---- try fastest point-test first ----
            //var cx = rcScreen.left + rcScreen.width / 2;
            //var cy = rcScreen.top + rcScreen.height;            //  / 2;
            //var mousePos = { x: cx, y: cy };
            //---- try the slower method ----
            var boxes = this._shapeEng.hitTestFromRect(rcArea, true, true);
            if (boxes && boxes.length) {
                var box = boxes[0];
                colValues = this._chart.getColumnValues(columnList, box.primaryKey);
                primaryKey = box.primaryKey;
            }
            return { primaryKey: primaryKey, colValues: colValues, };
        };
        chartBuilderClass.prototype.getChartFrameHelper = function () {
            return this._chartFrameHelper;
        };
        /**
         * Gets the location of the drawn shapes relative to the CHART'S #clientHolder element.
         * @param useDrawnHeight
         * @param screenRelative - if true, adjusts bounds to be screen relative.
         */
        chartBuilderClass.prototype.getPlotBounds = function (useDrawnHeight, screenRelative) {
            var rc = this._rcPlotFinal;
            if (useDrawnHeight) {
                if (this._facetHelper) {
                    rc = vp.geom.createRect(rc.left, rc.top, rc.width, rc.height - 14);
                }
                else {
                    rc = vp.geom.createRect(rc.left, rc.top, rc.width, rc.height - 1);
                }
            }
            if (screenRelative) {
                var rcGl = vp.select(this._parentElem).getBounds();
                rc = vp.geom.createRect(rc.left + rcGl.left, rc.top + rcGl.top, rc.width, rc.height);
            }
            return rc;
        };
        chartBuilderClass.prototype.buildChartCore = function () {
            var chart = this._chart;
            vp.utils.debug("--- buildChart (chartBuilder): firstReason=" + this._buildNeededReason + ", usingPrimaryBuffers=" + this._shapeEng.isUsingPrimaryBuffers() + " ----");
            var result = this.prepassAndFrameBuild();
            this.onDataChanged("facetLayoutChanged");
            var dc = result.dc;
            var nvBuckets = result.nvBuckets;
            var facetHelper = this._facetHelper;
            var facetCount = result.facetCount; //   (facetHelper) ? facetHelper.facetCount() : 1;
            var facetBinResults = result.facetBinResults;
            this._shapes = [];
            var layoutStart = vp.utils.now();
            var drawBufferIndex = 0;
            if (this._facetHelper) {
                var facetResult = facetHelper.layout();
                //---- now, do the REGULAR PASS on all facets ----
                for (var i = 0; i < facetCount; i++) {
                    var nvBucket = nvBuckets[i];
                    var facetBounds = facetResult.facetBounds[i];
                    var facetOffset = { x: facetBounds.x - dc.x, y: facetBounds.y - dc.y };
                    //if (!this._chart.is3dGridVisible())
                    //{
                    //    //---- add a 2D border around the bounds ----
                    //    var rc = this.worldBoundsToSvg(facetBounds);
                    //    vp.select(this._svgChartGroup).append("rect")
                    //        .addClass("facetBorder")
                    //        .bounds(rc.left, rc.top, rc.width, rc.height);
                    //}
                    //---- update drawing context for this facet ----
                    var facetRecordCount = beachParty.cbUtils.getDataLength(nvBucket);
                    var facetFilteredRecordCount = beachParty.cbUtils.getDataLength(nvBucket, true);
                    dc.facetIndex = i;
                    dc.nvData = nvBucket;
                    dc.recordCount = facetRecordCount;
                    dc.filteredRecordCount = facetFilteredRecordCount;
                    dc.layoutFilterVector = (nvBucket.layoutFilter && nvBucket.layoutFilter.values) ? nvBucket.layoutFilter.values : null;
                    /// NOTE: we do NOT update the scales or the dc bounds - chart draws into first facet bounds and then system offsets x/y as needed afterwards. 
                    /// calcRanges() uses the FIRST facet bounds to set: dc.x, dc.y, dc.width, dc.height also.  
                    this.layoutChartOrFacet(dc, facetOffset, drawBufferIndex);
                    drawBufferIndex += dc.recordCount;
                }
            }
            else {
                //---- REGULAR PASS (no facets) ----
                this.layoutChartOrFacet(dc, { x: 0, y: 0 }, drawBufferIndex);
                var recordCount = this._dataFrame.getRecordCount();
            }
        };
        chartBuilderClass.prototype.addToBuildPerf = function (name, start) {
            var now = vp.utils.now();
            var elapsed = now - start;
            this._buildPerf[name] += elapsed;
            return now;
        };
        chartBuilderClass.prototype.processRecord = function (fri, primaryKey, shape, facetOffset, nv, dc, drawBufferIndex) {
            if (isNaN(shape.x)) {
                shape.x = 0;
            }
            if (isNaN(shape.y)) {
                shape.y = 0;
            }
            if (isNaN(shape.z)) {
                shape.z = 0;
            }
            if (isNaN(shape.width)) {
                shape.width = 0;
            }
            if (isNaN(shape.height)) {
                shape.height = 0;
            }
            if (isNaN(shape.depth)) {
                shape.depth = 0;
            }
            shape.x += facetOffset.x;
            shape.y += facetOffset.y;
            //----  modify color of this shape for selection being active ----
            if (this._selectionExists && nv.selected) {
                if (this._chart.colorMapping().channelMapping != null) {
                    //---- coloring shapes using DIRECT CHANNELS ----
                    if (nv.selected.values[fri]) {
                        var cr = this._selectionColor;
                        shape.redChannel = cr[0];
                        shape.greenChannel = cr[1];
                        shape.blueChannel = cr[2];
                    }
                    else {
                        //---- unselected: use gray value ----
                        var cr = [100, 100, 100];
                        shape.redChannel = cr[0];
                        shape.greenChannel = cr[1];
                        shape.blueChannel = cr[2];
                    }
                }
                else {
                    //---- coloring shapes using COLOR PALETTE ----
                    if (nv.selected.values[fri]) {
                        shape.colorIndex += this._primaryColorCount; // color this with parallel selected color
                    }
                }
            }
            var yOffScreen = -10;
            if (this._isFirstFilteredStage && !this._isForwardFilter) {
                //---- process PREVIOUS filter mapping ----
                //---- WARNING: this "drawBufferIndex" index can cause problems if we change order at same time as filtering! ----
                if (this._prevFilter && this._prevFilter.values[drawBufferIndex]) {
                    //---- move to bottom of screen ----
                    shape.y = yOffScreen;
                    shape.opacity = 0;
                }
            }
            else {
                //---- process CURRENT filter mapping ----
                if (nv.enterExitFilter && nv.enterExitFilter.values[fri]) {
                    //---- move to bottom of screen ----
                    shape.y = yOffScreen;
                    shape.opacity = 0;
                }
                else {
                }
            }
        };
        chartBuilderClass.prototype.addDefaultLayoutResults = function (shape, fri, dc, nv, drawBufferIndex, primaryKey) {
            shape.primaryKey = primaryKey;
            //vp.utils.debug("addDefaultLayoutResults: shape[" + drawBufferIndex + "].primaryKey=" + primaryKey);
            shape.x = 0;
            shape.y = 0;
            shape.z = 0;
            shape.width = 1;
            shape.height = 1;
            shape.depth = 1 / 8;
            shape.colorIndex = 0;
            shape.imageIndex = 0;
            shape.opacity = 1;
            shape.staggerOffset = 0;
            shape.theta = 0;
            shape.redChannel = 0;
            shape.greenChannel = 0;
            shape.blueChannel = 0;
            this.setStaggerOffset(shape, fri, dc);
            if (this._chart.colorMapping().channelMapping != null) {
                var scales = dc.scales;
                if (nv.rgb) {
                    var colorStr = nv.rgb[drawBufferIndex];
                    var cr = vp.color.getColorFromString(colorStr);
                    if (!cr) {
                        //---- when color is missing, default to white ----
                        cr = [255, 255, 255];
                    }
                    shape.redChannel = cr[0];
                    shape.greenChannel = cr[1];
                    shape.blueChannel = cr[2];
                }
                else {
                    shape.redChannel = beachParty.chartUtils.scaleColData(nv.red, drawBufferIndex, scales.red);
                    shape.greenChannel = beachParty.chartUtils.scaleColData(nv.green, drawBufferIndex, scales.green);
                    shape.blueChannel = beachParty.chartUtils.scaleColData(nv.blue, drawBufferIndex, scales.blue);
                }
            }
        };
        chartBuilderClass.prototype.setStaggerOffset = function (shape, facetRelativeIndex, dc) {
            var ad = this._animationData;
            if (ad.isStaggeringEnabled && !this._isSelectionChangeOnly && !this._isFirstFilteredStage) {
                //---- stagger each shape a bit ----
                //---- to stagger shapes in the sorted order, we use "facetRelativeIndex" ----
                var staggerPercent = facetRelativeIndex / dc.recordCount;
                //---- this is now done thru a new "ad.isStaggerForward" boolean, set by the caller ----
                ////---- if we are moving from a COLUMN to a SCATTER, we want to process the HIGH Y values first (values are sorted by Y), so we flip the order ----
                ////---- likewise, if we moving from a BAR to a SCATTER, we want to process the HIGH X values first (values are sorted by X) ----
                //var fromCol = (dc.fromChartType == "columnCountClass" || dc.fromChartType == "columnSumClass");
                //var fromBar = (dc.fromChartType == "barCountClass" || dc.fromChartType == "barSumClass");
                //var flipOrder = (fromCol && dc.toChartType == "scatterPlot") || (fromBar && dc.toChartType == "scatterPlot");
                var flipOrder = (!ad.isStaggerForward);
                //---- we also change flipOrder when usingPrimaryBuffers=true, since the value of "toPercent" will be flipped in the shader ----
                if (this._shapeEng.isUsingPrimaryBuffers()) {
                    flipOrder = !flipOrder;
                }
                if (flipOrder) {
                    staggerPercent = 1 - staggerPercent;
                }
                //---- map all staggerOffset values to between 0 and stagger time as percent of animation time) ----
                shape.staggerOffset = -(staggerPercent * (ad.maxStaggerTime / ad.animationDuration)); // -(maxStaggerTime * staggerPercent);
            }
        };
        chartBuilderClass.prototype.getChartRepro = function () {
            var repro = new beachParty.ChartRepro();
            repro.xFactor = 1; // TODO
            repro.yFactor = 1; // TODO
            repro.zFactor = 1; // TODO
            repro.layoutResults = this._shapes;
            return repro;
        };
        chartBuilderClass.prototype.layoutChartOrFacet = function (dc, facetOffset, drawBufferIndex) {
            //vp.utils.debug("layoutChartOrFacet: facetOffset.x=" + facetOffset.x + ", facetOffset.y=" + facetOffset.y);
            var start = vp.utils.now();
            this._layout.preLayoutLoop(dc);
            var nv = dc.nvData;
            start = this.addToBuildPerf("preLayout", start);
            var textDrawCount = 0;
            var layout = this._layout;
            /// NOTE: taking perf measurements each time thru the loop causes a HUGE slowdown in the layout process,
            /// so we now just take a sample at the end (without the layout, fill, process breakdown). 
            for (var fri = 0; fri < dc.recordCount; fri++) {
                //---- facet data indexes are relative to each facet, so use "fri" (not "bufferDrawIndex") ----
                var primaryKey = nv.primaryKey.getRawData(fri) + "";
                var shape = new beachParty.Shape();
                //---- add default values for this record's layout result ----
                this.addDefaultLayoutResults(shape, fri, dc, nv, drawBufferIndex, primaryKey);
                //---- call chart class to layout the shape for this record ----
                layout.layoutDataForRecord(fri, dc, shape);
                this._shapes.push(shape);
                //start = this.addToBuildPerf("layout", start);
                var rect = this.processRecord(fri, primaryKey, shape, facetOffset, nv, dc, drawBufferIndex);
                //start = this.addToBuildPerf("process", start);
                //if (this._tm.colName != null && textDrawCount < this._tm.maxShapes)
                //{
                //    //---- use "fri" (vs. "drawBufferIndex") so that we index nv.* correctly ----
                //    this.drawTextForItem(this._ctx, fri, rect, nv, dr, primaryKey);
                //    textDrawCount++;
                //}
                drawBufferIndex++;
            }
            //var debugMsg = "record drawn: " + i;
            //vp.select("#consoleDiv").text(debugMsg);
            //if (this._lm.colName)
            //{
            //    this.drawLinesBetweenShapes(dc, buffers, facetOffset);
            //}
            start = this.addToBuildPerf("layoutEx", start);
            //vp.utils.debug("finished layout of " + dc.recordCount + " shapes");
            //this.fillGridLinesBuffer(dc, facetOffset);
            this.addToBuildPerf("layoutPost", start);
        };
        return chartBuilderClass;
    }(beachParty.dataChangerClass));
    beachParty.chartBuilderClass = chartBuilderClass;
    var NamedScales = (function () {
        function NamedScales() {
        }
        return NamedScales;
    }());
    beachParty.NamedScales = NamedScales;
    var ChartSpecs = (function () {
        function ChartSpecs(chartType, layoutType) {
            this._chartType = chartType;
            this._layoutType = layoutType;
        }
        ChartSpecs.prototype.isEqual = function (cs) {
            var eq = (this._chartType == cs._chartType && this._layoutType == cs._layoutType);
            return eq;
        };
        ChartSpecs.prototype.getChartType = function () {
            return this._chartType;
        };
        ChartSpecs.prototype.layoutType = function (value) {
            if (arguments.length == 0) {
                return this._layoutType;
            }
            this._layoutType = value;
        };
        ChartSpecs.prototype.getChartName = function () {
            return beachParty.ChartType[this._chartType];
        };
        ChartSpecs.prototype.getLayoutName = function () {
            return beachParty.LayoutType[this._layoutType];
        };
        ChartSpecs.prototype.getUiChartName = function () {
            var uiName = beachParty.getUiName(this._chartType);
            return uiName;
        };
        return ChartSpecs;
    }());
    beachParty.ChartSpecs = ChartSpecs;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    facetHelper.ts - helps layout facets into a NxM grid.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var facetHelperClass = (function () {
        function facetHelperClass(colName, requestedFacets, maxCategoryFacets, customScreenBounds, transformer, fm) {
            this._colName = colName;
            this._requestedFacets = (requestedFacets > 0) ? requestedFacets : 99;
            this._maxCategoryFacets = (maxCategoryFacets > 0) ? maxCategoryFacets : 999;
            this._customScreenBounds = customScreenBounds;
            this._transformer = transformer;
            this._fm = fm;
        }
        facetHelperClass.prototype.setBinCountFromData = function (dataFrame, nv, dataVector, fm) {
            /// before we do the facet binning, we need to peek ahead and see the number of keys in all of the data ----
            var dataType = dataVector.colType;
            if (this._fm.breaks && this._fm.breaks.length) {
                facetCount = this._fm.breaks.length;
            }
            else if (dataType == "string") {
                var facetCount = Math.min(this._maxCategoryFacets, dataVector.keyInfo.keyCount);
                facetCount = Math.min(this._requestedFacets, facetCount);
            }
            else if (this._fm.forceCategory) {
                var forcedNumVector = dataFrame.getNumericVector(dataVector.colName, true);
                var facetCount = Math.min(this._maxCategoryFacets, forcedNumVector.keyInfo.keyCount);
                facetCount = Math.min(this._requestedFacets, facetCount);
            }
            else if (dataType == "date") {
                var results = beachParty.binHelperDate.createDateBins(nv, "facet", this._requestedFacets, null, null, null, null, fm);
                var facetCount = results.bins.length;
            }
            else {
                //---- number - cannot reply on this._requestedFacets - binHelperNum.createBins() might adjust (e.g., date) ----
                //var facetCount = this._requestedFacets;
                var results = beachParty.binHelperNum.createNumBins(nv, "facet", this._requestedFacets, null, null, null, null, fm);
                var facetCount = results.bins.length;
            }
            this._facetCount = facetCount;
        };
        facetHelperClass.prototype.facetCount = function () {
            return this._facetCount;
        };
        facetHelperClass.prototype.colName = function () {
            return this._colName;
        };
        facetHelperClass.prototype.layout = function () {
            return this._layout;
        };
        facetHelperClass.prototype.binResult = function (value) {
            if (arguments.length === 0) {
                return this._binResult;
            }
            this._binResult = value;
            this._facetCount = value.bins.length;
        };
        facetHelperClass.prototype.buildFacetLayout = function (xMin, yMin, xMax, yMax) {
            var customScreenBounds = this._customScreenBounds;
            var plotBounds = [];
            var labelBounds = [];
            var labelHeight = this._transformer.screenSizeYToWorld(16); // approx height of 16px font + padding
            if (customScreenBounds && customScreenBounds.length) {
                var rowCount = 1; // hard to say
                var colCount = 1; // hard to say
                for (var i = 0; i < customScreenBounds.length; i++) {
                    var rc = customScreenBounds[i];
                    var bounds = this._transformer.screenToWorldBounds(rc);
                    var cellWidth = bounds.width;
                    var cellHeight = bounds.height;
                    var x = bounds.left;
                    var y = bounds.bottom + .05; // why is this fudge needed?
                    //---- make sure all facets are the SAME width and height (critical for shape drawing algorithm and visual comparisons) ----
                    var plotY = y - labelHeight;
                    var plotHeight = Math.max(0, cellHeight - labelHeight);
                    var fb = { x: x, y: plotY, width: cellWidth, height: plotHeight };
                    var lb = { x: x, y: y, width: cellWidth, height: labelHeight };
                    plotBounds.push(fb);
                    labelBounds.push(lb);
                }
            }
            else {
                //---- 8px offsets ----
                var hm = this._transformer.screenSizeXToWorld(8);
                var vm = this._transformer.screenSizeYToWorld(8);
                //---- do NOT add these - they put axis borders in wrong positions relative to glCanvas & chartUX ----
                //---- add margins around overall space ----
                //yMax -= vm;    
                //yMin += vm;    
                //xMin += hm;
                //xMax -= hm;
                //---- adjust to align within client frame ----
                //yMin += vm;
                xMax -= 2 * hm;
                yMax -= 1 * vm;
                yMin += 1 * vm;
                var width = Math.max(0, xMax - xMin);
                var height = Math.max(0, Math.abs(yMax - yMin));
                var aspect = width / height;
                var count = this._facetCount;
                //---- hard code layout for 0-16 cells ----
                var cellsPerRowByCount = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 2, 5: 3, 6: 3, 7: 4, 8: 4, 9: 3, 10: 5, 11: 4, 12: 4, 13: 4, 14: 4, 15: 4, 16: 4 };
                var cellsPerRow = cellsPerRowByCount[count];
                if (cellsPerRow === undefined) {
                    cellsPerRow = Math.ceil(Math.sqrt(aspect * count));
                }
                var rowCount = Math.ceil(count / cellsPerRow);
                //---- space between facets ----
                var approxCellWidth = width / cellsPerRow;
                var xTick = this._transformer.screenSizeXToWorld(12);
                var yTick = this._transformer.screenSizeYToWorld(12);
                var hMargin = xTick + .075 * approxCellWidth;
                var vMargin = yTick + 1.5 * labelHeight;
                var cellWidth = (width - hMargin * (cellsPerRow - 1)) / cellsPerRow;
                var cellHeight = (height - vMargin * (rowCount - 1)) / rowCount;
                var margin2 = 2 * hMargin;
                var yStart = yMax + 2 * vMargin - labelHeight;
                for (var i = 0; i < count; i++) {
                    var colIndex = Math.floor(i % cellsPerRow);
                    var rowIndex = Math.floor(i / cellsPerRow);
                    //---- must align left cells to left edge of container (so labels outside are right next to them) ----
                    var x = xMin + colIndex * (cellWidth + hMargin);
                    //var y = yMin - rowIndex * (cellHeight + vMargin);         // flipped axis
                    var y = yStart - (1 + rowIndex) * (cellHeight + vMargin); // flipped axis
                    //---- make sure all facets are the SAME width and height (critical for shape drawing algorithm and visual comparisons) ----
                    var plotY = y - labelHeight;
                    var plotHeight = Math.max(0, cellHeight - labelHeight);
                    var fb = { x: x, y: plotY, width: cellWidth, height: plotHeight };
                    var lb = { x: x, y: y + plotHeight, width: cellWidth, height: labelHeight };
                    plotBounds.push(fb);
                    labelBounds.push(lb);
                }
            }
            var layout = { facetBounds: plotBounds, labelBounds: labelBounds, rowCount: rowCount, columnCount: cellsPerRow };
            this._layout = layout;
            return layout;
        };
        return facetHelperClass;
    }());
    beachParty.facetHelperClass = facetHelperClass;
    var FacetLayout = (function () {
        function FacetLayout() {
        }
        return FacetLayout;
    }());
    beachParty.FacetLayout = FacetLayout;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    transformMgr.ts - manages changes to 3D transform of chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** manages changes to 3D transform of chart, including relative changes,
      dampening, inerita, transformMode, and transformEnabled. */
    var transformMgrClass = (function (_super) {
        __extends(transformMgrClass, _super);
        function transformMgrClass(gl, transformer) {
            var _this = this;
            _super.call(this);
            this._isInertialEnabled = true;
            this._usePostZ = false;
            //---- this attempts to keep track of our current SCALE and OFFSET and we incrementally change them ----
            this._currentScale = 1;
            this._currentOffsetX = 0;
            this._currentOffsetY = 0;
            this._currentRotationZ = 0;
            this._gl = gl;
            if (!transformer) {
                transformer = new beachParty.transformerClass(gl);
            }
            this._transformer = transformer;
            this._transformMode = beachParty.TransformMode.none;
            //---- hook up dampening ----
            this._xRotDamp = new beachParty.dampenerClass(function (actual) {
                _this._transformer.rotateMatrixX(actual);
            });
            this._yRotDamp = new beachParty.dampenerClass(function (actual) {
                _this._transformer.rotateMatrixY(actual, false, _this._usePostZ);
            });
            this._zRotDamp = new beachParty.dampenerClass(function (actual) {
                _this._transformer.rotateMatrixZ(actual);
            });
            this.resetPanAndPinchDeltas();
        }
        //buildGettersAndSetters()
        //{
        //    this._getterSetters["xRotation"] = (value) => this.xRotation(value);
        //    this._getterSetters["yRotation"] = (value) => this.yRotation(value);
        //    this._getterSetters["zRotation"] = (value) => this.zRotation(value);
        //    this._getterSetters["transformMode"] = (value) => this.transformMode(value);
        //}
        transformMgrClass.prototype.getRayFromScreenPos = function (screenX, screenY) {
            return this._transformer.getRayFromScreenPos(screenX, screenY);
        };
        /** called by dataView when chart frame changes. */
        transformMgrClass.prototype.onFrame = function () {
            var xHas = this._xRotDamp.onFrameApply();
            var yHas = this._yRotDamp.onFrameApply();
            var zHas = this._zRotDamp.onFrameApply();
            this.onDataChanged("frame");
            return (xHas || yHas || zHas);
        };
        transformMgrClass.prototype.getTransformer = function () {
            return this._transformer;
        };
        transformMgrClass.prototype.inertia = function (value) {
            if (arguments.length == 0) {
                var x = this._xRotDamp.inertia();
                var y = this._yRotDamp.inertia();
                var z = this._zRotDamp.inertia();
                return [x, y, z];
            }
            if (value && value.length) {
                this._xRotDamp.inertia(value[0]);
                this._yRotDamp.inertia(value[1]);
                this._zRotDamp.inertia(value[2]);
            }
        };
        transformMgrClass.prototype.resetPanAndPinchDeltas = function () {
            //vp.utils.debug("resetPanAndPinchDeltas");
            this._currentScale = 1;
            this._currentOffsetX = 0;
            this._currentOffsetY = 0;
            this._currentRotationZ = 0;
        };
        transformMgrClass.prototype.onUiOpStart = function () {
            this.onDataChanged("uiOpStart");
            this.resetPanAndPinchDeltas();
            this._xRotDamp.startUiOperation();
            this._yRotDamp.startUiOperation();
            this._zRotDamp.startUiOperation();
        };
        transformMgrClass.prototype.onUiOpStop = function () {
            this.onDataChanged("uiOpStop");
            this.resetPanAndPinchDeltas();
            this._xRotDamp.stopUIOperation();
            this._yRotDamp.stopUIOperation();
            this._zRotDamp.stopUIOperation();
            return this.hasInertia();
        };
        transformMgrClass.prototype.isInertiaEnabled = function (value) {
            if (value === undefined) {
                return this._isInertialEnabled;
            }
            this._isInertialEnabled = value;
            this.onDataChanged("isInertiaEnabled");
        };
        transformMgrClass.prototype.hasInertia = function () {
            var xHas = this._xRotDamp.hasInertia();
            var yHas = this._yRotDamp.hasInertia();
            var zHas = this._zRotDamp.hasInertia();
            var has = (xHas || yHas || zHas);
            return has;
        };
        transformMgrClass.prototype.resetCamera = function () {
            if (this._transformer) {
                this._transformer.resetMatrices();
            }
            //this._xRotDamp.reset();
            //this._yRotDamp.reset();
            //this._zRotDamp.reset();
            this.resetPanAndPinchDeltas();
        };
        transformMgrClass.prototype.applyPanMovement = function (xdiff, ydiff, targetX, targetY, mousePos) {
            var maxDiff = xdiff;
            if (Math.abs(ydiff) > Math.abs(xdiff)) {
                maxDiff = ydiff;
            }
            if (this._transformer) {
                //var inerita = this._isInertialEnabled;
                if (this._transformMode == beachParty.TransformMode.move) {
                    this._transformer.translateMatrixEx(xdiff, ydiff, 0);
                }
                else if (this._transformMode == beachParty.TransformMode.spin) {
                    this.rotateMatrixZ(maxDiff);
                }
                else if (this._transformMode == beachParty.TransformMode.turn) {
                    this.rotateMatrixY(-maxDiff);
                }
                else if (this._transformMode == beachParty.TransformMode.flip) {
                    this.rotateMatrixX(maxDiff);
                }
                else if (this._transformMode == beachParty.TransformMode.zoom) {
                    var factor = (maxDiff > 0) ? 1.3 : 1 / 1.3;
                    this.scaleCameraRelative(factor, mousePos);
                }
            }
        };
        transformMgrClass.prototype.transformMode = function (value) {
            if (value === undefined) {
                var enumName = beachParty.TransformMode[this._transformMode];
                return enumName;
            }
            if (vp.utils.isString(value)) {
                this._transformMode = beachParty.TransformMode[value];
            }
            else {
                this._transformMode = value;
            }
            this.onDataChanged("transformMode");
        };
        transformMgrClass.prototype.resetTransform = function () {
            this.transformMode(beachParty.TransformMode.move);
            if (this._transformer) {
                this._transformer.clearTransforms();
            }
        };
        transformMgrClass.prototype.moveCamera = function (targetX, targetY, mousePos) {
            var xdiff = targetX - this._currentOffsetX;
            var ydiff = targetY - this._currentOffsetY;
            //console.log("pan: " + targetX + ", " + targetY + ", diff=" + xdiff + ", " + ydiff);
            //---- todo: apply change in xy to our current position ----
            this.applyPanMovement(xdiff, ydiff, targetX, targetY, mousePos);
            this._currentOffsetX = targetX;
            this._currentOffsetY = targetY;
        };
        transformMgrClass.prototype.xRotation = function (value) {
            if (value === undefined) {
                return this._transformer.xRotation();
            }
            this._transformer.xRotation(value);
            this.onDataChanged("xRotation");
        };
        transformMgrClass.prototype.yRotation = function (value) {
            if (value === undefined) {
                return this._transformer.yRotation();
            }
            this._transformer.yRotation(value);
            this.onDataChanged("yRotation");
        };
        transformMgrClass.prototype.zRotation = function (value) {
            if (value === undefined) {
                return this._transformer.zRotation();
            }
            this._transformer.zRotation(value);
            this.onDataChanged("zRotation");
        };
        transformMgrClass.prototype.translateCamera = function (x, y, z) {
            this._transformer.translateMatrixEx(-x, -y, -z);
        };
        /** normally adds "value" (in radians) to the current X rotation, in the world matrix.  If additive=false, the x rotation is set
        to "value". */
        transformMgrClass.prototype.rotateMatrixX = function (value, additive, useInertia) {
            if (additive === void 0) { additive = true; }
            if (useInertia === void 0) { useInertia = true; }
            if (this._isInertialEnabled && useInertia) {
                //vp.utils.debug("xRotDamp: target=" + value);
                this._xRotDamp.setTarget(value);
            }
            else {
                this._transformer.rotateMatrixX(value, additive);
            }
        };
        //reverseDampX()
        //{
        //    if (this._isInertialEnabled)
        //    {
        //        this._xRotDamp.reverseAccum();
        //    }
        //    else
        //    {
        //        this._transformer.clearTransforms();
        //    }
        //}
        transformMgrClass.prototype.rotateMatrixY = function (rotStep, usePostZ) {
            this._usePostZ = usePostZ;
            if (this._isInertialEnabled) {
                //vp.utils.debug("yRotDamp: target=" + rotStep);
                this._yRotDamp.setTarget(rotStep);
            }
            else {
                this._transformer.rotateMatrixY(rotStep, false, usePostZ);
            }
        };
        transformMgrClass.prototype.rotateMatrixZ = function (rotStep) {
            if (this._isInertialEnabled) {
                //vp.utils.debug("zRotDamp: target=" + rotStep);
                this._zRotDamp.setTarget(rotStep);
            }
            else {
                this._transformer.rotateMatrixZ(rotStep);
            }
        };
        ///** Rotate the camera about the specified Z axis (relative to the value at the start of this gesture). */
        //rotateMatrixZAbsolute(value: number)
        //{
        //    var rotStep = value - this._currentRotationZ;
        //    this._transformer.rotateMatrixZ(rotStep);
        //    this._currentRotationZ = value;
        //}
        /** Scale the camera by a relative amount. */
        transformMgrClass.prototype.scaleCameraRelative = function (factor, mousePos, isMousePosInWorldUnits) {
            if (factor != 0) {
                var doIt = true;
                if (factor > 1) {
                    doIt = (this._currentScale < 400);
                }
                else {
                    doIt = (this._currentScale > .120);
                }
                if (true) {
                    this._currentScale *= factor;
                    this._transformer.scaleMatrix(factor, mousePos, isMousePosInWorldUnits);
                }
            }
        };
        /** Scale the camera to the specified value (relative to the start of the gesture). */
        transformMgrClass.prototype.scaleCameraAbsolute = function (scale, mousePos) {
            var diffFactor = scale / this._currentScale;
            vp.utils.debug("scaleCameraAbsolute: scale=" + scale + ", currentScale=" + this._currentScale +
                ", diffFactor=" + diffFactor + ", mousePos.x=" + mousePos.x + ", mousePos.y=" + mousePos.y);
            this._transformer.scaleMatrix(diffFactor, mousePos);
            this._currentScale = scale;
        };
        return transformMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.transformMgrClass = transformMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    shapeLegend.ts - draws an interactive, discreet shape legend (shape, ticks, labels).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var shapeLegendClass = (function (_super) {
        __extends(shapeLegendClass, _super);
        function shapeLegendClass(chartRouter, rootName) {
            _super.call(this, chartRouter, "shape", rootName, "shapeLegendTitle");
            this._isNumeric = false;
            this._lastValue = null;
            this._colType = "";
            this.rebuildLegend();
        }
        shapeLegendClass.prototype.shapeMapping = function (value) {
            if (arguments.length === 0) {
                return this._im;
            }
            this._im = value;
            this.onDataChanged("shapeMapping");
            this.rebuildLegend();
        };
        shapeLegendClass.prototype.search = function (colName, value) {
            this.doSearch("Shape", colName, value, value, beachParty.TextSearchType.exactMatch);
        };
        shapeLegendClass.prototype.rebuildLegend = function () {
            var _this = this;
            var im = this._im;
            var showLegend = (im != null && im.imagePalette != null && im.colName != null && im.colName != "");
            //---- show/hide legend ----
            this.show(showLegend);
            if (showLegend) {
                this.measureTextAndSetItemHeight();
                var name = im.colName;
                vp.select(this._titleElem)
                    .text(name);
                var imagePalette = im.imagePalette;
                var breaks = im.breaks;
                var colInfo = this.getColInfo(im.colName);
                var colType = colInfo.colType;
                this._colType = colType;
                var isNumeric = (colType != "string"); // number or date
                this._isNumeric = isNumeric;
                this._lastValue = null;
                this._textElems = [];
                this._paletteElements = [];
                this.buildTexturesOnClient(function (e) {
                    _this.rebuildLegendEx(im, breaks.length, isNumeric);
                });
            }
        };
        shapeLegendClass.prototype.fillLabelEntry = function (parentW, i, yOffset) {
            var _this = this;
            var im = this._im;
            var breaks = im.breaks;
            var value = (breaks) ? breaks[i] : "";
            var text = this.formatLabel(value);
            var tooltip = (text == "Other") ? "All other values mapped here" : text;
            var labelW = parentW.append("div")
                .text(text)
                .addClass("clipText legendLabel")
                .title(tooltip)
                .attach("click", function (e) { return _this.searchForEntryValues(e); });
            if (this._isNumeric) {
                parentW
                    .css("position", "relative");
                //---- shift labels up and to the right ----
                labelW
                    .css("position", "relative")
                    .css("left", "8px")
                    .css("top", (yOffset - this._entryHeight / 2) + "px");
            }
            //---- add information to support click/select ----
            labelW[0].colName = im.colName;
            labelW[0].axisKey = "box" + i;
            if (value == "Other") {
                labelW[0].fromValue = this._lastValue;
                labelW[0].toValue = this._lastValue;
                labelW[0].searchType = beachParty.TextSearchType.greaterThanEqual;
            }
            else if (this._isNumeric) {
                labelW[0].fromValue = (i == 0) ? value : this._lastValue;
                labelW[0].toValue = value;
                labelW[0].searchType = beachParty.TextSearchType.betweenInclusive;
            }
            else {
                labelW[0].fromValue = value;
                labelW[0].toValue = value;
                labelW[0].searchType = beachParty.TextSearchType.exactMatch;
            }
            var colorIndex = i; // (count - 1) - i;
            this._textElems[colorIndex] = labelW[0];
            this._lastValue = value;
        };
        shapeLegendClass.prototype.searchForEntryValues = function (e) {
            var elem = e.target;
            if (elem.imageIndex !== undefined) {
                //---- get text element from this image palette entry ----
                elem = this._textElems[elem.imageIndex];
            }
            var key = "shape." + elem.innerText;
            this.doSearch("Image", elem.colName, elem.fromValue, elem.toValue, elem.searchType, undefined, key);
        };
        shapeLegendClass.prototype.getImageFromSheet = function (imgSheet, width, height, index, count) {
            var srcWidth = imgSheet.width / count;
            var srcHeight = imgSheet.height;
            var canvasW = vp.select(document.createElement("canvas"))
                .attr("width", width)
                .attr("height", height);
            //---- get drawing context ----
            var canvas = canvasW[0];
            var ctx = canvas.getContext("2d");
            //---- draw the selected shape onto the canvas ----
            ctx.clearRect(0, 0, width, height);
            ctx.drawImage(imgSheet, index * srcWidth, 0, srcWidth, srcHeight, 0, 0, width, height);
            return canvas;
        };
        shapeLegendClass.prototype.buildTexturesOnClient = function (callback) {
            var _this = this;
            var im = this._im;
            var texPalette = im.imagePalette;
            var oldCode = false;
            //---- build image as imageSheet ----
            var isShapeNames = (!texPalette[0].contains("."));
            var textureMaker = new beachParty.textureMakerClass(im.imagePalette);
            if (isShapeNames) {
                var drawShapeSize = 32;
                textureMaker.buildShapeMakers(im.imagePalette);
                this._imgSheet = textureMaker.createShapeImages(drawShapeSize, 3);
                callback();
            }
            else {
                textureMaker.registerForChange("loaded", function (e) {
                    _this._imgSheet = textureMaker.getImageSheet();
                    callback();
                });
                //---- create a GL context so textureMaker is happy ----
                var canvas = document.createElement("canvas");
                var gl = beachParty.glUtils.getContext(canvas);
                textureMaker.buildAsync(gl, texPalette, isShapeNames);
            }
        };
        shapeLegendClass.prototype.fillPaletteEntry = function (paletteW, i, isTop) {
            var _this = this;
            var entryWidth = this._entryWidth;
            var entryHeight = this._entryHeight;
            var breaks = this._im.breaks;
            var count = (this._isNumeric) ? (breaks.length - 1) : breaks.length;
            var im = this._im;
            //---- STEPS ----
            //if (count * entryHeight > this._maxPaletteHeight)
            //{
            //    entryHeight = this._maxPaletteHeight / count;
            //}
            var imgIndex = i;
            var text = (breaks) ? breaks[i] : "";
            //---- get image from imageSheet ----
            var drawShapeSize = 32;
            var canvas = this.getImageFromSheet(this._imgSheet, drawShapeSize, drawShapeSize, i, count);
            var cellW = paletteW.append("div")
                .css("width", (entryWidth) + "px")
                .css("height", (entryHeight) + "px")
                .addClass("imagePaletteEntry")
                .customAttr("value", text)
                .css("position", "relative");
            cellW[0].imageIndex = (this._isNumeric) ? (i + 1) : i;
            //---- now add as image within the cell ----
            var shapeSize = entryWidth - 2;
            var left = (entryWidth - shapeSize) / 2;
            var top = (entryHeight - shapeSize) / 2;
            var shapeW = cellW.append("img")
                .addClass("imagePaletteShape")
                .css("width", shapeSize + "px")
                .css("height", shapeSize + "px")
                .css("display", "inline-block")
                .css("left", left + "px")
                .css("top", top + "px")
                .css("position", "absolute")
                .css("object-fit", "contain")
                .attr("src", canvas.toDataURL())
                .attach("click", function (e) { return _this.searchForEntryValues(e); });
            shapeW[0].imageIndex = (this._isNumeric) ? (i + 1) : i;
        };
        return shapeLegendClass;
    }(beachParty.baseLegendClass));
    beachParty.shapeLegendClass = shapeLegendClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    sizeLegend.ts - draws an interactive, continuous/discreet size legend (size palette, ticks, labels).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var sizeLegendClass = (function (_super) {
        __extends(sizeLegendClass, _super);
        function sizeLegendClass(chartRouter, rootName) {
            _super.call(this, chartRouter, "size", rootName, "sizeLegendTitle");
            this._isNumeric = false;
            this._lastValue = null;
            this.rebuildLegend();
        }
        sizeLegendClass.prototype.sizeMapping = function (value) {
            if (arguments.length === 0) {
                return this._sm;
            }
            this._sm = value;
            this.onDataChanged("sizeMapping");
            this.rebuildLegend();
        };
        sizeLegendClass.prototype.search = function (colName, value) {
            this.onSearchRequest.trigger({ legendName: "size", colName: colName, fromValue: value, toValue: value, searchType: beachParty.TextSearchType.exactMatch });
        };
        sizeLegendClass.prototype.rebuildLegend = function () {
            var sm = this._sm;
            var showLegend = (sm != null && sm.sizePalette != null && sm.colName != null && sm.colName != "");
            //---- show/hide legend ----
            this.show(showLegend);
            if (showLegend) {
                var name = sm.colName;
                vp.select(this._titleElem)
                    .text(name);
                this.measureTextAndSetItemHeight();
                var sizePalette = sm.sizePalette;
                var breaks = sm.breaks;
                var count = sizePalette.length;
                if (breaks && breaks.length < count) {
                    count = breaks.length;
                }
                var colInfo = this.getColInfo(sm.colName);
                var isNumeric = (colInfo.colType != "string"); // number or date
                this._isNumeric = isNumeric;
                this._lastValue = null;
                this._textElems = [];
                this._paletteElements = [];
                this.rebuildLegendEx(sm, breaks.length, this._isNumeric);
            }
        };
        sizeLegendClass.prototype.searchForEntryValues = function (e) {
            var elem = e.target;
            if (elem.parentNode && elem.parentNode.sizeIndex !== undefined) {
                elem = elem.parentNode;
            }
            if (elem.sizeIndex !== undefined) {
                //---- get text element from this size palette entry ----
                elem = this._textElems[elem.sizeIndex];
            }
            var key = "size." + elem.innerText;
            this.doSearch("Size", elem.colName, elem.fromValue, elem.toValue, elem.searchType, undefined, key);
        };
        sizeLegendClass.prototype.fillPaletteEntry = function (parentW, i, isTop) {
            var _this = this;
            //---- TODO: continuous size palette not yet supported ---
            var cm = this._sm;
            var sizePalette = cm.sizePalette;
            var breaks = cm.breaks;
            var entryHeight = this._entryHeight;
            var entryWidth = this._entryWidth;
            var isNumeric = this._isNumeric;
            var sz = vp.scales.numberFromDiscretePalette(sizePalette, i);
            var text = (breaks) ? breaks[i] : "";
            //parentW.css("position", "relative")
            var cellW = parentW.append("div")
                .css("width", (entryWidth - 2) + "px")
                .css("height", (entryHeight - 2) + "px")
                .addClass("sizePaletteEntry")
                .customAttr("value", text)
                .attach("click", function (e) { return _this.searchForEntryValues(e); })
                .css("margin-bottom", "-1px") // overlap with next top border
                .css("position", "relative");
            cellW[0].sizeIndex = (isNumeric) ? (i + 1) : i;
            //---- now draw the size shape within the cell ----
            var shapeSize = sz * (entryWidth - 4);
            var left = ((entryWidth - 2) - shapeSize) / 2;
            var top = ((entryHeight - 2) - shapeSize) / 2;
            var shape = cellW.append("span")
                .addClass("sizePaletteShape")
                .css("width", shapeSize + "px")
                .css("height", shapeSize + "px")
                .css("background", "#bbb")
                .css("display", "inline-block")
                .css("margin-top", top + "px")
                .css("margin-left", left + "px");
        };
        sizeLegendClass.prototype.fillLabelEntry = function (parentW, i, yOffset) {
            var _this = this;
            var cm = this._sm;
            var sizePalette = cm.sizePalette;
            var breaks = cm.breaks;
            var entryHeight = this._entryHeight;
            var entryWidth = this._entryWidth;
            var isNumeric = this._isNumeric;
            var value = (breaks) ? breaks[i] : "";
            var text = this.formatLabel(value);
            var tooltip = (text == "Other") ? "All other values mapped here" : text;
            var labelW = parentW.append("div")
                .text(text)
                .addClass("clipText legendLabel")
                .title(tooltip)
                .attach("click", function (e) { return _this.searchForEntryValues(e); });
            if (this._isNumeric) {
                parentW
                    .css("position", "relative");
                //---- shift labels up and to the right ----
                labelW
                    .css("position", "relative")
                    .css("left", "8px")
                    .css("top", (yOffset - this._entryHeight / 2) + "px");
            }
            labelW[0].colName = cm.colName;
            labelW[0].axisKey = "box" + i;
            var lastValue = this._lastValue;
            if (value == "Other") {
                labelW[0].fromValue = lastValue;
                labelW[0].toValue = lastValue;
                labelW[0].searchType = beachParty.TextSearchType.greaterThan;
            }
            else if (isNumeric) {
                labelW[0].fromValue = (i == 0) ? value : lastValue;
                labelW[0].toValue = value;
                labelW[0].searchType = beachParty.TextSearchType.betweenInclusive;
            }
            else {
                labelW[0].fromValue = value;
                labelW[0].toValue = value;
                labelW[0].searchType = beachParty.TextSearchType.exactMatch;
            }
            var sizeIndex = i; // (count - 1) - i;
            this._textElems[sizeIndex] = labelW[0];
            this._lastValue = value;
            //textTop -= entryHeight;
        };
        return sizeLegendClass;
    }(beachParty.baseLegendClass));
    beachParty.sizeLegendClass = sizeLegendClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    textLegend.ts - draws an interactive, continuous/discreet color legend (color palette, ticks, labels).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var textLegendClass = (function (_super) {
        __extends(textLegendClass, _super);
        function textLegendClass(rootName, tm) {
            _super.call(this);
            this._tm = tm;
            var root = vp.select("#" + rootName);
            var colName = (tm) ? tm.colName : "";
            //---- add colName as TITLE ----
            var title = root.append("span")
                .addClass("legendTitle textButton")
                .id("textLegendTitle")
                .text(colName);
            //---- add PALETTE ----
            var palette = root.append("div")
                .addClass("legendPalette");
            this._rootElem = root[0];
            this._titleElem = title[0];
            this._paletteElem = palette[0];
            this.updateLegend();
        }
        textLegendClass.prototype.textMapping = function (value) {
            if (arguments.length === 0) {
                return this._tm;
            }
            this._tm = value;
            this.onDataChanged("textMapping");
            this.updateLegend();
        };
        textLegendClass.prototype.show = function (value) {
            vp.select(this._rootElem)
                .css("display", (value) ? "" : "none");
        };
        textLegendClass.prototype.updateLegend = function () {
            var tm = this._tm;
            if (tm) {
                var name = tm.colName;
                //---- show/hide legend ----
                this.show(name != null);
                vp.select(this._titleElem)
                    .text(name);
                this.rebuildPalette();
            }
        };
        textLegendClass.prototype.rebuildPalette = function () {
            //var cm = this.sm;
            //var colorPalette = cm.colorPalette;
            //var paletteW = vp.select(this._paletteElem);
            //var maxPaletteHeight = 150;
            //var entryHeight = 75;
            //var entryWidth = 20;
            //paletteW
            //    .clear()
            //    .css("width", entryWidth + "px")
            //    .css("opacity", this._opacity+"")
            //var count = colorPalette.length;
            //if (cm.isContinuous)
            //{
            //    var lg = "linear-gradient(";
            //    for (var i = 0; i < count; i++)
            //    {
            //        if (i)
            //        {
            //            lg += ",";
            //        }
            //        var cr = colorPalette[i];
            //        lg += cr;
            //    }
            //    lg += ")";
            //    //---- CONTINUOUS ----
            //    paletteW
            //        .css("background", lg)
            //        .css("height", maxPaletteHeight + "px")
            //}
            //else
            //{
            //    //---- STEPS ----
            //    if (count * entryHeight > maxPaletteHeight)
            //    {
            //        entryHeight = maxPaletteHeight / count;
            //    }
            //    for (var i = 0; i < count; i++)
            //    {
            //        var cr = colorPalette[i];
            //        paletteW.append("div")
            //            .css("background-color", cr)
            //            .addClass("colorPaletteEntry")
            //            .css("width", entryWidth + "px")
            //            .css("height", entryHeight + "px")
            //}
            //}
        };
        return textLegendClass;
    }(beachParty.dataChangerClass));
    beachParty.textLegendClass = textLegendClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    aggColumn.ts - builds a traditional (aggregated) column chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var aggColumnClass = (function (_super) {
        __extends(aggColumnClass, _super);
        function aggColumnClass(chart) {
            _super.call(this, chart, "aggColumn");
            this._maxPosSumAllFacets = 0;
            this._maxNegSumAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._heightFactor = 0; // adjust each item's bottom/height to fit the tallest bin
            this._inverseSizeFactor = 0; // used to reverse effect of shader sizing
            this._xMargin = 0;
            this._xBetween = 0;
            this._yMin = 0;
            this._yMax = 0;
            this._chartBuilder.isAggChart(true);
            this._chartBuilder.hideAxes("y");
        }
        /**
         *  truncate data to a single record.  used to bootstrap the development
         *  of aggregation support.
         * @param data
         */
        aggColumnClass.prototype.fakeAggData = function (data) {
            var keys = vp.utils.keys(data);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var numVector = data[key];
                if (numVector instanceof beachParty.NumericVector) {
                    var firstValue = numVector.values[0];
                    numVector.values = new Float32Array(1);
                    numVector.values[0] = firstValue;
                }
            }
        };
        /** Responsiblities:
            1. compute max count for any bin, over all facets.
            2. return max count
        */
        aggColumnClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var xm = this._chart.xMapping();
            var maxPosSum = 0;
            var maxNegSum = 0;
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for consistent facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    //this.fakeAggData(data);
                    var results = beachParty.chartUtils.computeSumForFacet(dc, data, xm, "x", "y");
                    this._facetBinResults.push(results.binResults);
                    maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                    maxNegSum = Math.max(maxNegSum, results.maxNegSum);
                }
            }
            else {
                //this.fakeAggData(dc.nvData);
                var results = beachParty.chartUtils.computeSumForFacet(dc, dc.nvData, xm, "x", "y");
                this._facetBinResults.push(results.binResults);
                maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                maxNegSum = Math.max(maxNegSum, results.maxNegSum);
            }
            this._maxPosSumAllFacets = maxPosSum;
            this._maxNegSumAllFacets = maxNegSum;
            //---- return the sum of both as the "max item count" ----
            return maxPosSum + maxNegSum;
        };
        /** Responsiblities:
           1. adjust Y scale to reflect maxCount (across all facets).
           2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
       */
        aggColumnClass.prototype.adjustScales = function (dc) {
            //---- adjust X scale to reflect BINS ----
            var results = this._facetBinResults; //[0];
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, results);
            //---- adjust Y scale to reflect MAX SUM ----
            var oldScale = dc.scales.y;
            //---- use nice numbers for domain min/max ----
            var nn = vp.scales.niceNumbersAlt.calculate(-this._maxNegSumAllFacets, this._maxPosSumAllFacets);
            dc.scales.y = vp.scales.createLinear()
                .rangeMin(oldScale.rangeMin())
                .rangeMax(oldScale.rangeMax())
                .domainMin(nn.min)
                .domainMax(nn.max);
            //---- mark scale as having pre-computed tickCount ----
            var anyScale = dc.scales.y;
            anyScale._tickCount = nn.steps + 1;
        };
        aggColumnClass.prototype.assignRecordsToBins = function (nv, resultX, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var binAssignments = resultX.assignments;
            var itemHeights = []; // the height of each item (per its Y column value)
            var itemBottoms = []; // the bottom value of each item with its bin 
            var binPosOffsets = []; // next position for an item in positive part of each bin
            var binNegOffsets = []; // next position for an item in negative part of each bin
            //---- process each (sorted) record ----
            for (var vectorIndex = 0; vectorIndex < filter.length; vectorIndex++) {
                if (!filter[vectorIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binAssign = binAssignments[vectorIndex];
                    if (binPosOffsets[binAssign] === undefined) {
                        binPosOffsets[binAssign] = 0;
                        binNegOffsets[binAssign] = 0;
                    }
                    //---- calculate the relative height of this item ----
                    var itemHeight = nv.y.values[vectorIndex];
                    itemHeights[vectorIndex] = itemHeight;
                    if (itemHeight >= 0) {
                        itemBottoms[vectorIndex] = binPosOffsets[binAssign];
                        binPosOffsets[binAssign] += itemHeight;
                    }
                    else {
                        binNegOffsets[binAssign] += itemHeight;
                        itemBottoms[vectorIndex] = binNegOffsets[binAssign];
                    }
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    itemHeights[vectorIndex] = 0;
                    itemBottoms[vectorIndex] = 0;
                }
            }
            this._itemHeights = itemHeights;
            this._itemBottoms = itemBottoms;
            var facetWidth = dc.width;
            var facetHeight = dc.height;
            var binsX = resultX.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var yMin = dc.scales.y.scale(-this._maxNegSumAllFacets);
            var yMax = dc.scales.y.scale(this._maxPosSumAllFacets);
            var availHeight = yMax - yMin;
            /// prevent size adjustments in shader by setting our scale factor here to reverse shader shading.
            this._heightFactor = availHeight / (this._maxPosSumAllFacets + this._maxNegSumAllFacets);
            //---- create bounds ----
            var binLefts = [];
            var binBottoms = [];
            var left = dc.x + this._xMargin; // + dc.itemHalf;
            var bottom = dc.y; // + dc.itemHalf;
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += (this._binWidth + this._xBetween);
                //---- offset all bins by the same amount to enable comparisons ----
                var yOffset = this._heightFactor * this._maxNegSumAllFacets;
                binBottoms[i] = bottom + yOffset;
            }
            this._binLefts = binLefts;
            this._binBottoms = binBottoms;
            this._itemAssignments = binAssignments;
            this._inverseSizeFactor = 1 / dc.userSizeFactor; //  dc.combinedSizeFactor;
        };
        aggColumnClass.prototype.preLayoutLoop = function (dc) {
            //---- compute usable part of Y axis ----
            var yMin = dc.scales.y.scale(this._maxNegSumAllFacets);
            var yMax = dc.scales.y.scale(this._maxPosSumAllFacets);
            this._yMin = yMin;
            this._yMax = yMax;
            if (this._facetBinResults && dc.facetIndex < this._facetBinResults.length) {
                var facetResult = this._facetBinResults[dc.facetIndex];
                var availHeight = yMax - yMin;
                var result = beachParty.chartUtils.computeColumnBinSize(facetResult, dc.width, availHeight);
                this._binWidth = result.binWidth;
                this._binHeight = result.binHeight;
                this._xMargin = result.xMargin;
                this._xBetween = result.xBetween;
                this.assignRecordsToBins(dc.nvData, facetResult, dc);
            }
        };
        aggColumnClass.prototype.layoutDataForRecord = function (itemIndex, dc, dr) {
            var nv = dc.nvData;
            var visibleIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[itemIndex]);
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var binAssign = this._itemAssignments[itemIndex];
            var left = this._binLefts[binAssign];
            var bottom = this._binBottoms[binAssign];
            var heightFactor = this._heightFactor;
            var inverseSizeFactor = this._inverseSizeFactor;
            var trueHeight = Math.abs(heightFactor * this._itemHeights[itemIndex]);
            //---- layout as STACKED rectangles ----
            dr.x = left + this._binWidth / 2; // place at horizontal center of shape
            dr.y = bottom + (heightFactor * this._itemBottoms[itemIndex]);
            dr.y += trueHeight / 2; // place at vertical center of shape
            dr.z = 0;
            dr.height = inverseSizeFactor * trueHeight;
            dr.width = inverseSizeFactor * this._binWidth;
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, itemIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, itemIndex, dc.scales.imageIndex);
        };
        return aggColumnClass;
    }(beachParty.baseLayoutClass));
    beachParty.aggColumnClass = aggColumnClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    barCount.ts - builds a sand Bar chart (unit histogram, where units are arranged in a grid within each column).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var barCountClass = (function (_super) {
        __extends(barCountClass, _super);
        function barCountClass(chart) {
            _super.call(this, chart, "barCount");
            this._maxCountAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._yMargin = 0;
            this._yBetween = 0;
            this._xMin = 0; // start of x space for our drawing (as per x scale)
            this._xMax = 0; // end of x space for drawing (as per x scale)
            this._visibleColPickers = "ya";
            this._visibleBinAdjusters = "y";
            this._chartBuilder.isXAxisClickable(false);
        }
        /** Responsiblities:
            1. compute max count for any bin, over all facets.
            2. return max count
        */
        barCountClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var maxCount = 0;
            var ym = this._chart.yMapping();
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for consistent facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(ym, dc.layoutFilterVector, dc.nvData.y);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var results = beachParty.chartUtils.computeMaxBinCountForData(dc, data, ym, "y");
                    this._facetBinResults.push(results.binResults);
                    maxCount = Math.max(maxCount, results.maxCount);
                }
            }
            else {
                var results = beachParty.chartUtils.computeMaxBinCountForData(dc, dc.nvData, ym, "y");
                this._facetBinResults.push(results.binResults);
                maxCount = results.maxCount;
            }
            //---- does client want to override max count? ----
            if (this._chart.isMaxItemCountEnabled()) {
                maxCount = this._chart.maxItemCount();
            }
            this._maxCountAllFacets = maxCount;
            return maxCount;
        };
        /** Responsiblities:
           1. adjust Y scale to reflect maxCount (across all facets).
           2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
       */
        barCountClass.prototype.adjustScales = function (dc) {
            //---- adjust X scale ----
            this.xScaleAdjust(dc);
            //---- adjust Y scale ----
            var results = this._facetBinResults; //[0];
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, results);
        };
        /** create a new linear scale for X, based on the maximum count for a full bar. */
        barCountClass.prototype.xScaleAdjust = function (dc) {
            var oldScale = dc.scales.x;
            //---- adjust maxCount so that it represents a full bar, for our x scale max ----
            var maxCount = this._maxCountAllFacets;
            var binResults = this._facetBinResults;
            var yResult = binResults[0];
            //---- ESTIMATE itemWidth and itemHeight using full space of canvas ----
            var cb = this._chartBuilder;
            this.preLayoutLoopCore(yResult, cb.getClientWidth(), cb.getClientHeight(), yResult.bins.length);
            //---- NOTE: itemHeight is the height of a single bin container ----
            var aspect = this._itemWidth / this._itemHeight;
            //var aspect = this._itemHeight / this._itemWidth;
            var factor = Math.ceil(Math.sqrt(aspect * maxCount));
            var shapesPerCol = Math.ceil(maxCount / factor);
            var colCount = Math.ceil(maxCount / shapesPerCol);
            //---- lock these values in now ----
            this._shapesPerCol = shapesPerCol;
            this._newColCount = colCount;
            //var maxCountForRow = rowCount * Math.ceil(maxCount / rowCount);
            var result = beachParty.chartUtils.computeBestCountFactor(maxCount, shapesPerCol);
            var maxCountForCol = result.maxCount;
            dc.scales.x = vp.scales.createLinear()
                .rangeMin(oldScale.rangeMin())
                .rangeMax(oldScale.rangeMax())
                .domainMin(0)
                .domainMax(maxCountForCol);
            //---- mark scale as being for chunk-based count ----
            var anyScale = dc.scales.x;
            anyScale._tickCount = result.tickCount;
            dc.xCalcName = "_count"; // so we know this is a calc field
        };
        barCountClass.prototype.assignRecordsToBins = function (nv, resultY, dc, maxBinCountForAllFacets) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignY = resultY.assignments;
            var rowToBinNum = [];
            var rowToBinIndex = [];
            var binCounts = [];
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            //---- process each (sorted) record ----
            for (var i = 0; i < filter.length; i++) {
                var recordIndex = i;
                if (!filter[recordIndex]) {
                    //--- assignments must be indexed by the recordIndex ----
                    var binIndexY = allAssignY[recordIndex];
                    rowToBinNum[recordIndex] = binIndexY;
                    if (binCounts[binIndexY] === undefined) {
                        binCounts[binIndexY] = 0;
                    }
                    //---- this shape's index within its bin ----
                    rowToBinIndex[recordIndex] = binCounts[binIndexY];
                    binCounts[binIndexY] += 1;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    rowToBinNum[recordIndex] = 0;
                    rowToBinIndex[recordIndex] = 0;
                }
            }
            var maxCount = maxBinCountForAllFacets;
            var width = dc.width;
            var height = dc.height;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            //---- create bounds for each BAR bin ----
            var binTops = [];
            var binWidths = [];
            var bottom = dc.y + this._yMargin; // dc.y - height + this._yMargin;
            for (var i = 0; i < binsY.length; i++) {
                binTops[i] = bottom;
                if (binCounts[i] === undefined) {
                    binCounts[i] = 0;
                }
                binWidths[i] = binCounts[i] / maxCount * width;
                bottom += (this._itemHeight + this._yBetween);
            }
            this._binTops = binTops;
            this._binWidths = binWidths;
            this._rowToBinNum = rowToBinNum;
            this._rowToBinIndex = rowToBinIndex;
            //---- set up GRID params ----
            var aspect = this._itemWidth / this._itemHeight;
            //var colCount = this._shapesPerCol;          //  Math.ceil(Math.sqrt(aspect * maxCount));
            //this._colCount = colCount;
            //this._rowCount = rowCount;
            var maxShapeSize = this._itemWidth / this._newColCount;
            maxShapeSize = Math.min(maxShapeSize, .85 * this._itemHeight / this._shapesPerCol);
            this._maxShapeSize = maxShapeSize; //  / dc.transformSizeFactor;
            vp.utils.debug("preLayoutLoopCore: itemWidth=" + this._itemWidth + ", itemHeight=" + this._itemHeight +
                ", maxShapeSize=" + this._maxShapeSize);
            this._nextIndex = 0;
            return maxCount;
        };
        barCountClass.prototype.preLayoutLoop = function (dc) {
            //this.preLayoutLoopCore(dc, true);
            var shapesPerCol = this._shapesPerCol;
            var maxCountFullCol = shapesPerCol * Math.ceil(this._maxCountAllFacets / shapesPerCol);
            //---- don't use all of Y space; let scale determine boundaries ----
            //---- this is needed because sometimes scale may be larger than maxCount. ----
            //---- also, we should allow for optional expand space in range ----
            var xMin = dc.scales.x.scale(0);
            var xMax = dc.scales.x.scale(maxCountFullCol);
            this._xMin = xMin;
            this._xMax = xMax;
            var availWidth = xMax - xMin;
            var availHeight = dc.height;
            var binResults = this._facetBinResults;
            if (binResults && binResults.length) {
                var yResult = binResults[dc.facetIndex];
                this.preLayoutLoopCore(yResult, availWidth, availHeight, yResult.bins.length);
                this.assignRecordsToBins(dc.nvData, yResult, dc, this._maxCountAllFacets);
            }
        };
        barCountClass.prototype.preLayoutLoopCore = function (yResult, availWidth, availHeight, binCount) {
            var result = beachParty.chartUtils.computeBarBinSize(yResult, availWidth, availHeight);
            this._itemWidth = result.binWidth;
            this._itemHeight = result.binHeight;
            this._yMargin = result.yMargin;
            this._yBetween = result.yBetween;
        };
        barCountClass.prototype.layoutDataForRecord = function (recordIndex, dc, dr) {
            var nv = dc.nvData;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[recordIndex]);
            var visibleIndex = 0;
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var binIndexX = this._rowToBinNum[recordIndex];
            var top = this._binTops[binIndexX];
            var bottom = dc.y; // dc.y - dc.height;
            var binWidth = this._binWidths[binIndexX];
            if (this._chartOptions.layout == "Random") {
                var xr = nv.randomX.values[recordIndex];
                var yr = nv.randomY.values[recordIndex];
                dr.x = dc.x + xr * binWidth;
                dr.y = top + yr * this._itemHeight;
            }
            else {
                //---- GRID layout ----
                var indexInBin = this._rowToBinIndex[recordIndex];
                var rowNum = indexInBin % this._shapesPerCol;
                var colNum = Math.floor(indexInBin / this._shapesPerCol);
                //---- center shapes within their x-locations ----
                dr.x = dc.x + ((.5 + colNum) / this._newColCount) * this._itemWidth;
                //---- center shapes relative to their row bottom ----
                dr.y = top + ((.5 + rowNum) / this._shapesPerCol) * this._itemHeight;
            }
            var scaleFactor = this.scaleColData(nv.size, recordIndex, dc.scales.size, 1);
            dr.width = this._maxShapeSize * scaleFactor;
            dr.height = dr.width;
            dr.z = 0;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, recordIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, recordIndex, dc.scales.imageIndex);
        };
        return barCountClass;
    }(beachParty.baseLayoutClass));
    beachParty.barCountClass = barCountClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    barSum.ts - builds a summed sand Bar chart (where each item is a rectangle, stacked on to right of each other, with width
//   proportional to x column value.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var barSumClass = (function (_super) {
        __extends(barSumClass, _super);
        function barSumClass(chart) {
            _super.call(this, chart, "barSum");
            this._maxPosSumAllFacets = 0;
            this._maxNegSumAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._widthFactor = 0; // adjust each item's bottom/height to fit the tallest bin
            this._inverseSizeFactor = 0; // used to reverse effect of shader sizing
            this._yMargin = 0;
            this._yBetween = 0;
            this._xMin = 0;
            this._xMax = 0;
            this._visibleColPickers = "ya";
            this._visibleBinAdjusters = "y";
            this._chartBuilder.isXAxisClickable(false);
        }
        /** Two responsiblities: 1. compute max count for any bin, over all facets.  2. adjust scales as needed for our chart. */
        barSumClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var ym = this._chart.yMapping();
            var maxPosSum = 0;
            var maxNegSum = 0;
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for consistent facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(ym, dc.layoutFilterVector, dc.nvData.y);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var results = beachParty.chartUtils.computeSumForFacet(dc, data, ym, "y", "size");
                    this._facetBinResults.push(results.binResults);
                    maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                    maxNegSum = Math.max(maxNegSum, results.maxNegSum);
                }
            }
            else {
                var results = beachParty.chartUtils.computeSumForFacet(dc, dc.nvData, ym, "y", "size");
                this._facetBinResults.push(results.binResults);
                maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                maxNegSum = Math.max(maxNegSum, results.maxNegSum);
            }
            this._maxPosSumAllFacets = maxPosSum;
            this._maxNegSumAllFacets = maxNegSum;
            vp.utils.debug("computeFacetStats: maxPosSum=" + maxPosSum + ", maxNegSum=" + maxNegSum);
            //---- return the sum of both as the "max item count" ----
            return maxPosSum + maxNegSum;
        };
        /** Responsiblities:
         1. adjust Y scale to reflect maxCount (across all facets).
         2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
        */
        barSumClass.prototype.adjustScales = function (dc) {
            //---- adjust Y scale to reflect BINS ----
            var results = this._facetBinResults; //[0];
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, results);
            //---- adjust X scale to reflect MAX SUM ----
            var oldScale = dc.scales.x;
            //---- use nice numbers for domain min/max ----
            var nn = vp.scales.niceNumbersAlt.calculate(-this._maxNegSumAllFacets, this._maxPosSumAllFacets);
            dc.scales.x = vp.scales.createLinear()
                .rangeMin(oldScale.rangeMin())
                .rangeMax(oldScale.rangeMax())
                .domainMin(nn.min)
                .domainMax(nn.max);
            //---- mark scale as having pre-computed tickCount ----
            var anyScale = dc.scales.x;
            anyScale._tickCount = nn.steps + 1;
        };
        barSumClass.prototype.assignRecordsToBins = function (nv, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var binAssignments = resultY.assignments;
            var itemWidths = []; // the width of each item (per its X column value)
            var itemLefts = []; // the left value of each item within its bin 
            var binPosOffsets = []; // next position for an item in positive part of each bin
            var binNegOffsets = []; // next position for an item in negative part of each bin
            //---- process each (sorted) record ----
            for (var vectorIndex = 0; vectorIndex < filter.length; vectorIndex++) {
                if (!filter[vectorIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binAssign = binAssignments[vectorIndex];
                    if (binPosOffsets[binAssign] === undefined) {
                        binPosOffsets[binAssign] = 0;
                        binNegOffsets[binAssign] = 0;
                    }
                    //---- calculate the relative width of this item ----
                    var itemWidth = nv.size.values[vectorIndex];
                    itemWidths[vectorIndex] = itemWidth;
                    if (itemWidth >= 0) {
                        itemLefts[vectorIndex] = binPosOffsets[binAssign];
                        binPosOffsets[binAssign] += itemWidth;
                    }
                    else {
                        binNegOffsets[binAssign] += itemWidth;
                        itemLefts[vectorIndex] = binNegOffsets[binAssign];
                    }
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    itemWidths[vectorIndex] = 0;
                    itemLefts[vectorIndex] = 0;
                }
            }
            this._itemWidths = itemWidths;
            this._itemLefts = itemLefts;
            var facetWidth = dc.width;
            var facetHeight = dc.height;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the yScale labels ----
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            var xMin = dc.scales.x.scale(-this._maxNegSumAllFacets);
            var xMax = dc.scales.x.scale(this._maxPosSumAllFacets);
            var availWidth = xMax - xMin;
            //// prevent size adjustments in shader by setting our scale factor here to reverse shader shading.
            this._widthFactor = availWidth / (this._maxPosSumAllFacets + this._maxNegSumAllFacets);
            //---- create bounds ----
            var binLefts = [];
            var binBottoms = [];
            var bottom = dc.y + this._yMargin;
            for (var i = 0; i < binsY.length; i++) {
                binBottoms[i] = bottom;
                bottom += (this._binHeight + this._yBetween);
                //---- offset all bins by the same amount to enable comparisons ----
                var xOffset = this._widthFactor * this._maxNegSumAllFacets;
                binLefts[i] = dc.x + xOffset;
            }
            this._binLefts = binLefts;
            this._binBottoms = binBottoms;
            this._itemAssignments = binAssignments;
            //---- setting this to "1" allow us to apply the sizeFactor correctly ----
            this._inverseSizeFactor = 1; // 1 / dc.userSizeFactor;            //  dc.combinedSizeFactor;
        };
        barSumClass.prototype.preLayoutLoop = function (dc) {
            //var options = <sandDensityOptions>this._chartOptions;
            //var nv = dc.nvData;
            //var binResults = this._facetBinResults;
            //if (binResults && binResults.length)
            //{
            //    var yResult = binResults[dc.facetIndex];
            //    var binCount = yResult.bins.length;
            //    var width = dc.width;
            //    var height = dc.height;
            //    var approxItemHeight = height / binCount;
            //    var yMargin = .1 * approxItemHeight;
            //    var yBetween = .1 * approxItemHeight;
            //    this._yMargin = yMargin;
            //    this._yBetween = yBetween;
            //    //---- compute itemWidth and itemHeight ----
            //    var itemHeight = (height - 2 * yMargin - (binCount - 1) * yBetween) / binCount;
            //    var itemWidth = width;
            //    this._binWidth = itemWidth;
            //    this._binHeight = itemHeight;
            //    this.assignRecordsToBins(nv, yResult, dc);
            //}
            //---- compute usable part of X axis ----
            var xMin = dc.scales.x.scale(this._maxNegSumAllFacets);
            var xMax = dc.scales.x.scale(this._maxPosSumAllFacets);
            this._xMin = xMin;
            this._xMax = xMax;
            if (this._facetBinResults && dc.facetIndex < this._facetBinResults.length) {
                var facetResult = this._facetBinResults[dc.facetIndex];
                var availWidth = xMax - xMin;
                var result = beachParty.chartUtils.computeBarBinSize(facetResult, availWidth, dc.height);
                this._binWidth = result.binWidth;
                this._binHeight = result.binHeight;
                this._yMargin = result.yMargin;
                this._yBetween = result.yBetween;
                this.assignRecordsToBins(dc.nvData, facetResult, dc);
            }
        };
        barSumClass.prototype.layoutDataForRecord = function (itemIndex, dc, dr) {
            var nv = dc.nvData;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[itemIndex]);
            var visibleIndex = 0;
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var binAssign = this._itemAssignments[itemIndex];
            var left = this._binLefts[binAssign];
            var bottom = this._binBottoms[binAssign];
            var widthFactor = this._widthFactor;
            var inverseSizeFactor = this._inverseSizeFactor;
            var trueWidth = Math.abs(widthFactor * this._itemWidths[itemIndex]);
            //---- layout as STACKED rectangles ----
            dr.x = left + (widthFactor * this._itemLefts[itemIndex]);
            dr.y = bottom + this._binHeight / 2; // place at horizontal center of shape
            dr.x += trueWidth / 2; // place at horizontal center of shape
            dr.z = 0;
            dr.width = inverseSizeFactor * trueWidth;
            dr.height = inverseSizeFactor * this._binHeight;
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, itemIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, itemIndex, dc.scales.imageIndex);
        };
        return barSumClass;
    }(beachParty.baseLayoutClass));
    beachParty.barSumClass = barSumClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    columnCount.ts - builds a sand Column chart (unit histogram, where units are arranged in a grid within each column).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** this chart groups the items into N bins (using the X column), and then lays out the item's shapes in a grid for each column. All layout is
     * done based on "_maxCountAllFacets" - the maximum # of items in any bin (across all facets).  This determines the "_shapesPerRow"
     * and the "_rowCount".  Each column then drawn according to these variables.
      */
    var columnCountClass = (function (_super) {
        __extends(columnCountClass, _super);
        function columnCountClass(chart) {
            _super.call(this, chart, "columnCount");
            this._maxCountAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._maxShapeWidth = 1;
            this._maxShapeHeight = 1;
            this._xMargin = 0;
            this._yMin = 0; // bottom of y space for our drawing (as per y scale)
            this._yMax = 0; // top of y space for drawing (as per y scale)
            this._xBetween = 0;
            this._visibleColPickers = "xa";
            this._visibleBinAdjusters = "x";
            this._chartBuilder.isYAxisClickable(false);
        }
        /** Responsiblities:
            1. compute max count for any bin, over all facets.
            2. compute xMin, xMax for all data (across facets).
            3. return max count
        */
        columnCountClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var maxCount = 0;
            var xm = this._chart.xMapping();
            //---- compute min/max over all data for consistent facet binning ----
            beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var results = beachParty.chartUtils.computeMaxBinCountForData(dc, data, xm, "x");
                    this._facetBinResults.push(results.binResults);
                    maxCount = Math.max(maxCount, results.maxCount);
                }
            }
            else {
                var results = beachParty.chartUtils.computeMaxBinCountForData(dc, dc.nvData, xm, "x");
                this._facetBinResults.push(results.binResults);
                maxCount = results.maxCount;
            }
            //---- does client want to override max count? ----
            if (this._chart.isMaxItemCountEnabled()) {
                maxCount = this._chart.maxItemCount();
            }
            //vp.utils.debug("columnClass.computeFacetStats: dc.filteredCount=" + dc.filteredRecordCount + ", maxBinCountForAllFacets=" + maxCount);
            this._maxCountAllFacets = maxCount;
            vp.utils.debug("columnCount.computeFacetStats: maxCount=" + maxCount + ", filtered OUT count=" + vector.countOn(dc.nvData.layoutFilter.values));
            return maxCount;
        };
        /** Responsiblities:
            1. adjust Y scale to reflect maxCount (across all facets).
            2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
        */
        columnCountClass.prototype.adjustScales = function (dc) {
            //---- adjust X scale to reflect BINS ----
            var results = this._facetBinResults; // [0];
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, results, "x");
            //---- adjust Y scale to reflect MAX COUNT ----
            this.yScaleAdjust(dc);
        };
        /** create a new linear scale for Y, based on the maximum count for a full column. */
        columnCountClass.prototype.yScaleAdjust = function (dc) {
            var oldScale = dc.scales.y;
            //---- adjust maxCount so that it represents a full column, for our y scale max ----
            var maxCount = this._maxCountAllFacets;
            var binResults = this._facetBinResults;
            if (binResults && binResults.length) {
                var xResult = binResults[0];
                //---- ESTIMATE itemWidth and itemHeight using full space of canvas ----
                var cb = this._chartBuilder;
                this.preLayoutLoopCore(xResult, cb.getClientWidth(), cb.getClientHeight(), xResult.bins.length);
            }
            var binAspect = this._binWidth / this._binHeight;
            var shapesPerRow = Math.ceil(Math.sqrt(binAspect * maxCount));
            this._shapesPerRow = shapesPerRow; // lock this value in now for consistent results
            //vp.utils.debug("maxCount=" + maxCount + ", aspect=" + aspect + ", shapesPerRow=" + shapesPerRow);
            var result = beachParty.chartUtils.computeBestCountFactor(maxCount, shapesPerRow);
            var maxCountForCol = result.maxCount;
            //---- range may not be set for oldScale since it probably didn't have an associated data column ----
            var rangeMin = dc.y; // - dc.height;
            var rangeMax = dc.y + dc.height;
            dc.scales.y = vp.scales.createLinear()
                .rangeMin(rangeMin)
                .rangeMax(rangeMax)
                .domainMin(0)
                .domainMax(maxCountForCol);
            //---- mark scale as having pre-computed tickCount ----
            var anyScale = dc.scales.y;
            anyScale._tickCount = result.tickCount;
            dc.yCalcName = "_count"; // so we know this is a calc field
        };
        columnCountClass.prototype.assignRecordsToBins = function (nv, resultX, dc, maxBinCountForAllFacets) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignX = resultX.assignments;
            var rowToBinNum = [];
            var rowToBinIndex = [];
            var binCounts = [];
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            //vp.utils.debug("columnClass.assignRecordsToBins: dc.filteredCount=" + dc.filteredRecordCount + ", maxBinCountForAllFacets=" + maxBinCountForAllFacets);
            //---- process each (sorted) record ----
            for (var i = 0; i < dc.recordCount; i++) {
                var shapeIndex = i;
                if (!isFiltered || !filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = allAssignX[shapeIndex];
                    rowToBinNum[shapeIndex] = binIndexX;
                    if (binCounts[binIndexX] === undefined) {
                        binCounts[binIndexX] = 0;
                    }
                    //---- this shape's index within its bin ----
                    rowToBinIndex[shapeIndex] = binCounts[binIndexX];
                    binCounts[binIndexX] += 1;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    rowToBinNum[shapeIndex] = 0;
                    rowToBinIndex[shapeIndex] = 0;
                }
            }
            var maxCount = maxBinCountForAllFacets;
            var width = dc.width;
            var height = this._yMax - this._yMin; //  dc.height;
            var binsX = resultX.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            //---- create bounds of each bin ----
            var binLefts = [];
            var binHeights = [];
            var left = dc.x + this._xMargin;
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                binHeights[i] = binCounts[i] / maxCount * height;
                left += (this._binWidth + this._xBetween);
            }
            this._binLefts = binLefts;
            this._binHeights = binHeights;
            this._rowToBinNum = rowToBinNum;
            this._rowToBinIndex = rowToBinIndex;
            //---- set up GRID params ----
            var shapesPerRow = this._shapesPerRow; // use precomputed (locked in) value  
            var rowCount = Math.ceil(maxCount / shapesPerRow);
            //this._colCount = colCount;
            this._rowCount = rowCount;
            var maxShapeWidth = .85 * this._binWidth / this._shapesPerRow;
            var maxShapeHeight = .85 * this._binHeight / this._rowCount;
            this._maxShapeWidth = maxShapeWidth; //  / dc.transformSizeFactor;
            this._maxShapeHeight = maxShapeHeight; //  / dc.transformSizeFactor;
            //vp.utils.debug("assignRecordsToBins: itemWidth=" + this._itemWidth + ", itemHeight=" + this._itemHeight + ", shapesPerRow=" + shapesPerRow +
            //    ", rowCount = " + rowCount + ", maxShapeWidth=" + maxShapeWidth); 
            this._nextIndex = 0;
            return maxCount;
        };
        columnCountClass.prototype.preLayoutLoop = function (dc) {
            vp.utils.debug("columnCount.preLayoutLoop: filtered OUT count=" + vector.countOn(dc.nvData.layoutFilter.values));
            var shapesPerRow = this._shapesPerRow;
            var maxCountFullRow = shapesPerRow * Math.ceil(this._maxCountAllFacets / shapesPerRow);
            //---- don't use all of Y space; let scale determine boundaries ----
            //---- this is needed because sometimes scale may be larger than maxCount. ----
            //---- also, we should allow for optional expand space in range ----
            var yMin = dc.scales.y.scale(0);
            var yMax = dc.scales.y.scale(maxCountFullRow);
            this._yMin = yMin;
            this._yMax = yMax;
            var availWidth = dc.width;
            var availHeight = yMax - yMin;
            var binResults = this._facetBinResults;
            if (binResults && binResults.length) {
                var xResult = binResults[dc.facetIndex];
                this.preLayoutLoopCore(xResult, availWidth, availHeight, xResult.bins.length);
                this.assignRecordsToBins(dc.nvData, xResult, dc, this._maxCountAllFacets);
            }
        };
        columnCountClass.prototype.preLayoutLoopCore = function (xResult, availWidth, availHeight, binCount) {
            var result = beachParty.chartUtils.computeColumnBinSize(xResult, availWidth, availHeight);
            this._binWidth = result.binWidth;
            this._binHeight = result.binHeight;
            this._xMargin = result.xMargin;
            this._xBetween = result.xBetween;
        };
        /** "bufferIndex" in the 0-based indexed into the sorted data buffers. */
        columnCountClass.prototype.layoutDataForRecord = function (bufferIndex, dc, dr) {
            var nv = dc.nvData;
            var visibleIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[bufferIndex]);
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var binIndexX = this._rowToBinNum[bufferIndex];
            var left = this._binLefts[binIndexX];
            //var bottom = dc.y - dc.height;
            var bottom = this._yMin;
            var binHeight = this._binHeights[binIndexX];
            if (this._chartOptions.layout == "Random") {
                var xr = nv.randomX.values[bufferIndex];
                var yr = nv.randomY.values[bufferIndex];
                dr.x = left + xr * this._binWidth;
                dr.y = bottom + yr * binHeight;
            }
            else {
                //---- GRID layout ----
                var indexInBin = this._rowToBinIndex[bufferIndex];
                var colNum = indexInBin % this._shapesPerRow;
                var rowNum = Math.floor(indexInBin / this._shapesPerRow);
                //---- center shapes within their x-locations ----
                dr.x = left + ((.5 + colNum) / this._shapesPerRow) * this._binWidth;
                //---- center shapes relative to their row bottom ----
                dr.y = bottom + ((.5 + rowNum) / this._rowCount) * this._binHeight;
            }
            dr.z = 0;
            var scaleFactor = this.scaleColData(nv.size, bufferIndex, dc.scales.size, 1);
            dr.width = this._maxShapeWidth * scaleFactor;
            dr.height = this._maxShapeHeight * scaleFactor;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, bufferIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, bufferIndex, dc.scales.imageIndex);
        };
        return columnCountClass;
    }(beachParty.baseLayoutClass));
    beachParty.columnCountClass = columnCountClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    columnPercent.ts - builds a sand 100% Column chart (unit histogram, where units are arranged in a grid within each column).  Columns are all of 
//    a fixed height with a variable width.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** this chart groups the items into N bins (using the X column), and then lays out the item's shapes in a grid for each column. All layout is
     * done based on "_maxCountAllFacets" - the maximum # of items in any bin (across all facets).  This determines the "_shapesPerRow"
     * and the "_rowCount".  Each column then drawn according to these variables.
      */
    var columnPercentClass = (function (_super) {
        __extends(columnPercentClass, _super);
        function columnPercentClass(chart) {
            _super.call(this, chart, "columnPercent");
            this._maxCountAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._maxShapeWidth = 1;
            this._maxShapeHeight = 1;
            this._xMargin = 0;
            this._yMin = 0; // bottom of y space for our drawing (as per y scale)
            this._yMax = 0; // top of y space for drawing (as per y scale)
            this._xBetween = 0;
            //---- experimental ----
            this._stretchWidth = true;
            this._visibleColPickers = "xa";
            this._visibleBinAdjusters = "x";
            this._chartBuilder.isYAxisClickable(false);
        }
        /** Responsiblities:
            1. compute max count for any bin, over all facets.
            2. compute xMin, xMax for all data (across facets).
            3. return max count
        */
        columnPercentClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var maxCount = 0;
            var xm = this._chart.xMapping();
            //---- compute min/max over all data for consistent facet binning ----
            beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var results = beachParty.chartUtils.computeMaxBinCountForData(dc, data, xm, "x");
                    this._facetBinResults.push(results.binResults);
                    maxCount = Math.max(maxCount, results.maxCount);
                }
            }
            else {
                var results = beachParty.chartUtils.computeMaxBinCountForData(dc, dc.nvData, xm, "x");
                this._facetBinResults.push(results.binResults);
                maxCount = results.maxCount;
            }
            //---- does client want to override max count? ----
            if (this._chart.isMaxItemCountEnabled()) {
                maxCount = this._chart.maxItemCount();
            }
            //vp.utils.debug("columnClass.computeFacetStats: dc.filteredCount=" + dc.filteredRecordCount + ", maxBinCountForAllFacets=" + maxCount);
            this._maxCountAllFacets = maxCount;
            return maxCount;
        };
        /** Responsiblities:
            1. adjust Y scale to reflect maxCount (across all facets).
            2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
        */
        columnPercentClass.prototype.adjustScales = function (dc) {
            //---- adjust X scale to reflect BINS ----
            var results = this._facetBinResults; // [0];
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, results, "x");
            //---- adjust Y scale to reflect MAX COUNT ----
            this.yScaleAdjust(dc);
        };
        /** create a new linear scale for Y, from 0 to 1. */
        columnPercentClass.prototype.yScaleAdjust = function (dc) {
            var oldScale = dc.scales.y;
            //---- adjust maxCount so that it represents a full column, for our y scale max ----
            var maxCount = this._maxCountAllFacets;
            var binResults = this._facetBinResults;
            if (binResults && binResults.length) {
                var xResult = binResults[0];
                //---- ESTIMATE itemWidth and itemHeight using full space of canvas ----
                var cb = this._chartBuilder;
                this.preLayoutLoopCore(xResult, cb.getClientWidth(), cb.getClientHeight(), xResult.bins.length);
            }
            var binAspect = this._binWidth / this._binHeight;
            var shapesPerRow = Math.ceil(Math.sqrt(binAspect * maxCount));
            this._oldShapesPerRow = shapesPerRow; // lock this value in now for consistent results
            //vp.utils.debug("maxCount=" + maxCount + ", aspect=" + aspect + ", shapesPerRow=" + shapesPerRow);
            //var result = chartUtils.computeBestCountFactor(maxCount, shapesPerRow);
            //---- range may not be set for oldScale since it probably didn't have an associated data column ----
            var rangeMin = dc.y; // - dc.height;
            var rangeMax = dc.y + dc.height;
            dc.scales.y = vp.scales.createLinear()
                .rangeMin(rangeMin)
                .rangeMax(rangeMax)
                .domainMin(0)
                .domainMax(1);
            //---- mark scale as having pre-computed tickCount ----
            var anyScale = dc.scales.y;
            anyScale._tickCount = 6; // result.tickCount;
            dc.yCalcName = "_percent"; // so we know this is a calc field
        };
        columnPercentClass.prototype.assignRecordsToBins = function (nv, resultX, dc, maxBinCountForAllFacets) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignX = resultX.assignments;
            var rowToBinNum = [];
            var rowToBinIndex = [];
            var binCounts = [];
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            //vp.utils.debug("columnClass.assignRecordsToBins: dc.filteredCount=" + dc.filteredRecordCount + ", maxBinCountForAllFacets=" + maxBinCountForAllFacets);
            //---- process each (sorted) record ----
            for (var i = 0; i < dc.recordCount; i++) {
                var shapeIndex = i;
                if (!isFiltered || !filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = allAssignX[shapeIndex];
                    rowToBinNum[shapeIndex] = binIndexX;
                    if (binCounts[binIndexX] === undefined) {
                        binCounts[binIndexX] = 0;
                    }
                    //---- this shape's index within its bin ----
                    rowToBinIndex[shapeIndex] = binCounts[binIndexX];
                    binCounts[binIndexX] += 1;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    rowToBinNum[shapeIndex] = 0;
                    rowToBinIndex[shapeIndex] = 0;
                }
            }
            var maxCount = maxBinCountForAllFacets;
            var width = dc.width;
            var height = this._yMax - this._yMin; //  dc.height;
            var binsX = resultX.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            //---- create bounds ----
            var binLefts = [];
            var binWidths = [];
            var binRowCounts = [];
            var shapesPerRow = [];
            var oldShapesPerRow = this._oldShapesPerRow; // use precomputed (locked in) value  
            if (this._stretchWidth) {
                var centerOfNextBin = dc.x + this._xMargin; // + this._binWidth / 2 ;
            }
            else {
                var centerOfNextBin = dc.x + this._xMargin + this._binWidth / 2;
            }
            var maxRowCount = Math.ceil(maxCount / oldShapesPerRow);
            var totalShapeWidth = this._binWidth / oldShapesPerRow;
            for (var i = 0; i < binsX.length; i++) {
                shapesPerRow[i] = Math.ceil(binCounts[i] / maxRowCount);
                binRowCounts[i] = binCounts[i] / shapesPerRow[i];
                if (this._stretchWidth) {
                    binWidths[i] = this._binWidth;
                    binLefts[i] = centerOfNextBin;
                }
                else {
                    binWidths[i] = totalShapeWidth * shapesPerRow[i];
                    binLefts[i] = centerOfNextBin - binWidths[i] / 2;
                }
                centerOfNextBin += (this._binWidth + this._xBetween);
                vp.utils.debug("assignRecordsToBins: binLefts[i]=" + binLefts[i] + ", binWidths[i]=" + binWidths[i] + ", rowCounts[i]=" + binRowCounts[i] +
                    ", shapesPerRow[i]=" + shapesPerRow[i]);
            }
            this._binLefts = binLefts;
            this._binWidths = binWidths;
            this._shapesPerRow = shapesPerRow;
            this._rowToBinNum = rowToBinNum;
            this._rowToBinIndex = rowToBinIndex;
            this._binRowCounts = binRowCounts;
            //---- set up GRID params ----
            //this._colCount = colCount;
            this._rowCount = maxRowCount;
            var maxShapeWidth = this.shapeSize(this._binWidth / oldShapesPerRow);
            var maxShapeHeight = this.shapeSize(this._binHeight / this._rowCount);
            this._maxShapeWidth = maxShapeWidth; //  / dc.transformSizeFactor;
            this._maxShapeHeight = maxShapeHeight; //  / dc.transformSizeFactor;
            //vp.utils.debug("assignRecordsToBins: itemWidth=" + this._itemWidth + ", itemHeight=" + this._itemHeight + ", shapesPerRow=" + shapesPerRow +
            //    ", rowCount = " + rowCount + ", maxShapeWidth=" + maxShapeWidth); 
            this._nextIndex = 0;
            return maxCount;
        };
        columnPercentClass.prototype.preLayoutLoop = function (dc) {
            var oldShapesPerRow = this._oldShapesPerRow;
            var maxCountFullRow = oldShapesPerRow * Math.ceil(this._maxCountAllFacets / oldShapesPerRow);
            //---- don't use all of Y space; let scale determine boundaries ----
            //---- this is needed because sometimes scale may be larger than maxCount. ----
            //---- also, we should allow for optional expand space in range ----
            var yMin = dc.scales.y.scale(0);
            var yMax = dc.scales.y.scale(maxCountFullRow);
            this._yMin = yMin;
            this._yMax = yMax;
            var availWidth = dc.width;
            var availHeight = yMax - yMin;
            var binResults = this._facetBinResults;
            if (binResults && binResults.length) {
                var xResult = binResults[dc.facetIndex];
                this.preLayoutLoopCore(xResult, availWidth, availHeight, xResult.bins.length);
                this.assignRecordsToBins(dc.nvData, xResult, dc, this._maxCountAllFacets);
            }
        };
        columnPercentClass.prototype.preLayoutLoopCore = function (xResult, availWidth, availHeight, binCount) {
            var result = beachParty.chartUtils.computeColumnBinSize(xResult, availWidth, availHeight);
            this._binWidth = result.binWidth;
            this._binHeight = result.binHeight;
            this._xMargin = result.xMargin;
            this._xBetween = result.xBetween;
        };
        columnPercentClass.prototype.shapeSize = function (maxSize) {
            var gap = Math.min(.02, .15 * maxSize);
            return maxSize - gap;
        };
        /** "bufferIndex" in the 0-based indexed into the sorted data buffers. */
        columnPercentClass.prototype.layoutDataForRecord = function (bufferIndex, dc, dr) {
            var nv = dc.nvData;
            var visibleIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[bufferIndex]);
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var binIndexX = this._rowToBinNum[bufferIndex];
            var left = this._binLefts[binIndexX];
            //var bottom = dc.y - dc.height;
            var bottom = this._yMin;
            var binWidth = this._binWidths[binIndexX];
            var shapesPerMyRow = this._shapesPerRow[binIndexX];
            //---- GRID layout ----
            var indexInBin = this._rowToBinIndex[bufferIndex];
            var colNum = indexInBin % shapesPerMyRow;
            var rowNum = Math.floor(indexInBin / shapesPerMyRow);
            var scaleFactor = this.scaleColData(nv.size, bufferIndex, dc.scales.size, 1);
            var shapeWidth = this.shapeSize(this._binWidth / shapesPerMyRow);
            var myRowCount = this._binRowCounts[binIndexX];
            var fullHeight = this._binHeight / myRowCount;
            var shapeHeight = this.shapeSize(fullHeight);
            vp.utils.debug("shapeHeight=" + shapeHeight);
            dr.width = shapeWidth * scaleFactor;
            dr.height = shapeHeight * scaleFactor;
            dr.depth = dc.defaultDepth2d;
            //---- center shapes within their x-locations ----
            dr.x = left + ((.5 + colNum) / shapesPerMyRow) * binWidth;
            //---- center shapes relative to their row bottom ----
            //dr.y = bottom + ((.5 + rowNum) / this._rowCount) * this._binHeight;
            dr.y = bottom + (.5 + rowNum) * fullHeight;
            dr.z = 0;
            dr.colorIndex = this.scaleColData(nv.colorIndex, bufferIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, bufferIndex, dc.scales.imageIndex);
        };
        return columnPercentClass;
    }(beachParty.baseLayoutClass));
    beachParty.columnPercentClass = columnPercentClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    columnSquarify.ts - builds a Column chart (with inner layout = squrify)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var columnSquarifyClass = (function (_super) {
        __extends(columnSquarifyClass, _super);
        function columnSquarifyClass(chart) {
            _super.call(this, chart, "columnSquarify");
            this._maxPosSumAllFacets = 0;
            this._maxNegSumAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._itemBounds = {}; // map from itemIndex to absolute rectangle bounds of each shape
            this._heightFactor = 0; // adjust each item's bottom/height to fit the tallest bin
            this._inverseSizeFactor = 0; // used to reverse effect of shader sizing
            this._xMargin = 0;
            this._xBetween = 0;
            this._yMin = 0;
            this._yMax = 0;
            this._visibleColPickers = "xa";
            this._visibleBinAdjusters = "x";
            this._chartBuilder.isYAxisClickable(false);
        }
        /** Responsiblities:
            1. compute max count for any bin, over all facets.
            2. return max count
        */
        columnSquarifyClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var xm = this._chart.xMapping();
            var maxPosSum = 0;
            var maxNegSum = 0;
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for consistent facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var results = beachParty.chartUtils.computeSumForFacet(dc, data, xm, "x", "aux");
                    this._facetBinResults.push(results.binResults);
                    maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                    maxNegSum = Math.max(maxNegSum, results.maxNegSum);
                }
            }
            else {
                var results = beachParty.chartUtils.computeSumForFacet(dc, dc.nvData, xm, "x", "aux");
                this._facetBinResults.push(results.binResults);
                maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                maxNegSum = Math.max(maxNegSum, results.maxNegSum);
            }
            this._maxPosSumAllFacets = maxPosSum;
            this._maxNegSumAllFacets = maxNegSum;
            //---- return the sum of both as the "max item count" ----
            return maxPosSum + maxNegSum;
        };
        /** Responsiblities:
           1. adjust Y scale to reflect maxCount (across all facets).
           2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
       */
        columnSquarifyClass.prototype.adjustScales = function (dc) {
            //---- adjust X scale to reflect BINS ----
            var results = this._facetBinResults; //[0];
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, results);
            //---- adjust Y scale to reflect MAX SUM ----
            var oldScale = dc.scales.y;
            //---- use nice numbers for domain min/max ----
            var nn = vp.scales.niceNumbersAlt.calculate(-this._maxNegSumAllFacets, this._maxPosSumAllFacets);
            dc.scales.y = vp.scales.createLinear()
                .rangeMin(oldScale.rangeMin())
                .rangeMax(oldScale.rangeMax())
                .domainMin(nn.min)
                .domainMax(nn.max);
            //---- mark scale as having pre-computed tickCount ----
            var anyScale = dc.scales.y;
            anyScale._tickCount = nn.steps + 1;
        };
        columnSquarifyClass.prototype.assignRecordsToBins = function (nv, resultX, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var binAssignments = resultX.assignments;
            var itemBounds = {};
            var facetWidth = dc.width;
            var facetHeight = dc.height;
            var binsX = resultX.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var yMin = dc.scales.y.scale(-this._maxNegSumAllFacets);
            var yMax = dc.scales.y.scale(this._maxPosSumAllFacets);
            var availHeight = yMax - yMin;
            /// prevent size adjustments in shader by setting our scale factor here to reverse shader shading.
            this._heightFactor = availHeight / (this._maxPosSumAllFacets + this._maxNegSumAllFacets);
            //---- create bounds ----
            var binLefts = [];
            var binBottoms = [];
            var left = dc.x + this._xMargin; // + dc.itemHalf;
            var bottom = dc.y;
            var top = bottom + dc.height;
            var spacing = dc.spacingFactor; //   this.getSpacingFactor(dc);
            //---- layout each bin ----
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += (this._binWidth + this._xBetween);
                //---- offset all bins by the same amount to enable comparisons ----
                var yOffset = this._heightFactor * this._maxNegSumAllFacets;
                binBottoms[i] = bottom + yOffset;
                var binSizes = binsX[i].rowIndexes.map(function (itemNum) {
                    if (!filter[itemNum]) {
                        var size = nv.aux.values[itemNum];
                    }
                    else {
                        //---- if it is FILTERED OUT, don't include it in the layout ----
                        var size = 0;
                    }
                    //---- relative size of item ----
                    return size;
                });
                //---- layout records within the bin ----
                var binSum = binSizes.sum();
                var binHeightFactor = binSum / this._maxPosSumAllFacets;
                var binHeight = binHeightFactor * this._binHeight;
                var rc = vp.geom.createRect(binLefts[i], binBottoms[i], this._binWidth, binHeight);
                this.layoutBin(rc, binsX[i].rowIndexes, binSizes, itemBounds, spacing);
            }
            //---- not quite right...----
            this._itemBounds = itemBounds;
            this._binLefts = binLefts;
            this._binBottoms = binBottoms;
            this._itemAssignments = binAssignments;
            //---- setting this to "1" allow us to apply the sizeFactor correctly ----
            this._inverseSizeFactor = 1; // 1 / dc.userSizeFactor;            //  dc.combinedSizeFactor;
        };
        columnSquarifyClass.prototype.layoutBin = function (rc, itemIndexes, binSizes, itemBounds, spacing) {
            //---- do a squarify layout for the items in this bin ----
            var squarify = new beachParty.squarifyLayoutClass();
            var cellMargin = spacing; // 0.00001;
            var cells = squarify.layout(binSizes, rc, cellMargin);
            //---- update itemBounds with results----
            for (var b = 0; b < cells.length; b++) {
                var rcItem = cells[b].rect;
                var itemIndex = itemIndexes[b];
                itemBounds[itemIndex] = rcItem;
            }
        };
        columnSquarifyClass.prototype.preLayoutLoop = function (dc) {
            //---- compute usable part of Y axis ----
            var yMin = dc.scales.y.scale(this._maxNegSumAllFacets);
            var yMax = dc.scales.y.scale(this._maxPosSumAllFacets);
            this._yMin = yMin;
            this._yMax = yMax;
            if (this._facetBinResults && dc.facetIndex < this._facetBinResults.length) {
                var facetResult = this._facetBinResults[dc.facetIndex];
                var availHeight = yMax - yMin;
                var result = beachParty.chartUtils.computeColumnBinSize(facetResult, dc.width, availHeight);
                this._binWidth = result.binWidth;
                this._binHeight = result.binHeight;
                this._xMargin = result.xMargin;
                this._xBetween = result.xBetween;
                this.assignRecordsToBins(dc.nvData, facetResult, dc);
            }
        };
        columnSquarifyClass.prototype.layoutDataForRecord = function (itemIndex, dc, dr) {
            var nv = dc.nvData;
            var visibleIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[itemIndex]);
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var inverseSizeFactor = this._inverseSizeFactor;
            //---- layout as rectangles in our facet/plot space ----
            if (!layoutFilterVector[itemIndex]) {
                //---- IN FILTER - give it the next rcArray ----
                var rc = this._itemBounds[itemIndex];
            }
            else {
                //---- OUT OF FILTER; give it default rc ----
                var rc = vp.geom.createRect(0, 0, 1, 1);
            }
            var isRect = false; // (shapeType == ShapeType.rectangle);
            var fillCell = true;
            if (fillCell) {
                dr.width = rc.width / dc.userSizeFactor; // dc.combinedSizeFactor;
                dr.height = rc.height / dc.userSizeFactor; // dc.combinedSizeFactor;
            }
            //else
            //{
            //    dr.width = this._maxShapeSize * this.scaleColData(nv.size, i, scales.size, 1);
            //    dr.height = dr.width;
            //}
            dr.depth = dc.defaultDepth2d;
            //---- center drawing within cell ----
            dr.x = rc.left + rc.width / 2;
            //---- work around facet vs. non-facet inconsistency in bottom/top usage ----
            dr.y = Math.min(rc.bottom, rc.top) + rc.height / 2; // rc.top
            dr.z = 0;
            dr.height = inverseSizeFactor * rc.height;
            dr.width = inverseSizeFactor * rc.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, itemIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, itemIndex, dc.scales.imageIndex);
        };
        return columnSquarifyClass;
    }(beachParty.baseLayoutClass));
    beachParty.columnSquarifyClass = columnSquarifyClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    columnSum.ts - builds a summed sand Column chart (where each item is a rectangle, stacked on top of each other, with height
//   proportional to y column value.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var columnSumClass = (function (_super) {
        __extends(columnSumClass, _super);
        function columnSumClass(chart) {
            _super.call(this, chart, "columnSum");
            this._maxPosSumAllFacets = 0;
            this._maxNegSumAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._heightFactor = 0; // adjust each item's bottom/height to fit the tallest bin
            this._inverseSizeFactor = 0; // used to reverse effect of shader sizing
            this._xMargin = 0;
            this._xBetween = 0;
            this._yMin = 0;
            this._yMax = 0;
            this._visibleColPickers = "xa";
            this._visibleBinAdjusters = "x";
            this._chartBuilder.isYAxisClickable(false);
        }
        /** Responsiblities:
            1. compute max count for any bin, over all facets.
            2. return max count
        */
        columnSumClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var xm = this._chart.xMapping();
            var maxPosSum = 0;
            var maxNegSum = 0;
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for consistent facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var results = beachParty.chartUtils.computeSumForFacet(dc, data, xm, "x", "aux");
                    this._facetBinResults.push(results.binResults);
                    maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                    maxNegSum = Math.max(maxNegSum, results.maxNegSum);
                }
            }
            else {
                var results = beachParty.chartUtils.computeSumForFacet(dc, dc.nvData, xm, "x", "aux");
                this._facetBinResults.push(results.binResults);
                maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                maxNegSum = Math.max(maxNegSum, results.maxNegSum);
            }
            this._maxPosSumAllFacets = maxPosSum;
            this._maxNegSumAllFacets = maxNegSum;
            //---- return the sum of both as the "max item count" ----
            return maxPosSum + maxNegSum;
        };
        /** Responsiblities:
           1. adjust Y scale to reflect maxCount (across all facets).
           2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
       */
        columnSumClass.prototype.adjustScales = function (dc) {
            //---- adjust X scale to reflect BINS ----
            var results = this._facetBinResults; //[0];
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, results);
            //---- adjust Y scale to reflect MAX SUM ----
            var oldScale = dc.scales.y;
            //---- use nice numbers for domain min/max ----
            var nn = vp.scales.niceNumbersAlt.calculate(-this._maxNegSumAllFacets, this._maxPosSumAllFacets);
            dc.scales.y = vp.scales.createLinear()
                .rangeMin(oldScale.rangeMin())
                .rangeMax(oldScale.rangeMax())
                .domainMin(nn.min)
                .domainMax(nn.max);
            //---- mark scale as having pre-computed tickCount ----
            var anyScale = dc.scales.y;
            anyScale._tickCount = nn.steps + 1;
        };
        columnSumClass.prototype.assignRecordsToBins = function (nv, resultX, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var binAssignments = resultX.assignments;
            var itemHeights = []; // the height of each item (per its Y column value)
            var itemBottoms = []; // the bottom value of each item with its bin 
            var binPosOffsets = []; // next position for an item in positive part of each bin
            var binNegOffsets = []; // next position for an item in negative part of each bin
            //---- process each (sorted) record ----
            for (var vectorIndex = 0; vectorIndex < filter.length; vectorIndex++) {
                if (!filter[vectorIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binAssign = binAssignments[vectorIndex];
                    if (binPosOffsets[binAssign] === undefined) {
                        binPosOffsets[binAssign] = 0;
                        binNegOffsets[binAssign] = 0;
                    }
                    //---- calculate the relative height of this item ----
                    var itemHeight = nv.aux.values[vectorIndex];
                    itemHeights[vectorIndex] = itemHeight;
                    if (itemHeight >= 0) {
                        itemBottoms[vectorIndex] = binPosOffsets[binAssign];
                        binPosOffsets[binAssign] += itemHeight;
                    }
                    else {
                        binNegOffsets[binAssign] += itemHeight;
                        itemBottoms[vectorIndex] = binNegOffsets[binAssign];
                    }
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    itemHeights[vectorIndex] = 0;
                    itemBottoms[vectorIndex] = 0;
                }
            }
            this._itemHeights = itemHeights;
            this._itemBottoms = itemBottoms;
            var facetWidth = dc.width;
            var facetHeight = dc.height;
            var binsX = resultX.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var yMin = dc.scales.y.scale(-this._maxNegSumAllFacets);
            var yMax = dc.scales.y.scale(this._maxPosSumAllFacets);
            var availHeight = yMax - yMin;
            /// prevent size adjustments in shader by setting our scale factor here to reverse shader shading.
            this._heightFactor = availHeight / (this._maxPosSumAllFacets + this._maxNegSumAllFacets);
            //---- create bounds ----
            var binLefts = [];
            var binBottoms = [];
            var left = dc.x + this._xMargin; // + dc.itemHalf;
            var bottom = dc.y; // + dc.itemHalf;
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += (this._binWidth + this._xBetween);
                //---- offset all bins by the same amount to enable comparisons ----
                var yOffset = this._heightFactor * this._maxNegSumAllFacets;
                binBottoms[i] = bottom + yOffset;
            }
            this._binLefts = binLefts;
            this._binBottoms = binBottoms;
            this._itemAssignments = binAssignments;
            //---- setting this to "1" allow us to apply the sizeFactor correctly ----
            this._inverseSizeFactor = 1; // 1 / dc.userSizeFactor;            //  dc.combinedSizeFactor;
        };
        columnSumClass.prototype.preLayoutLoop = function (dc) {
            //---- compute usable part of Y axis ----
            var yMin = dc.scales.y.scale(this._maxNegSumAllFacets);
            var yMax = dc.scales.y.scale(this._maxPosSumAllFacets);
            this._yMin = yMin;
            this._yMax = yMax;
            if (this._facetBinResults && dc.facetIndex < this._facetBinResults.length) {
                var facetResult = this._facetBinResults[dc.facetIndex];
                var availHeight = yMax - yMin;
                var result = beachParty.chartUtils.computeColumnBinSize(facetResult, dc.width, availHeight);
                this._binWidth = result.binWidth;
                this._binHeight = result.binHeight;
                this._xMargin = result.xMargin;
                this._xBetween = result.xBetween;
                this.assignRecordsToBins(dc.nvData, facetResult, dc);
            }
        };
        columnSumClass.prototype.layoutDataForRecord = function (itemIndex, dc, dr) {
            var nv = dc.nvData;
            var visibleIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[itemIndex]);
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var binAssign = this._itemAssignments[itemIndex];
            var left = this._binLefts[binAssign];
            var bottom = this._binBottoms[binAssign];
            var heightFactor = this._heightFactor;
            var inverseSizeFactor = this._inverseSizeFactor;
            var trueHeight = Math.abs(heightFactor * this._itemHeights[itemIndex]);
            //---- layout as STACKED rectangles ----
            dr.x = left + this._binWidth / 2; // place at horizontal center of shape
            dr.y = bottom + (heightFactor * this._itemBottoms[itemIndex]);
            dr.y += trueHeight / 2; // place at vertical center of shape
            dr.z = 0;
            dr.height = inverseSizeFactor * trueHeight;
            dr.width = inverseSizeFactor * this._binWidth;
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, itemIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, itemIndex, dc.scales.imageIndex);
        };
        return columnSumClass;
    }(beachParty.baseLayoutClass));
    beachParty.columnSumClass = columnSumClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    densityCircle.ts - builds a density chart (2D histogram, with CIRCLE layout within each heatmap tile). 
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var densityCircle = (function (_super) {
        __extends(densityCircle, _super);
        function densityCircle(chart) {
            _super.call(this, chart, "densityCircle");
            //---- all facet results ----
            this._xFacetBinResults = null;
            this._yFacetBinResults = null;
            this._phyloSeed = 137.508; // "golden angle"
            this._radius = 0;
            this._spacing = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._sideMargin = 0;
            this._betweenMargin = 0;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "xy";
        }
        /** Adjust scales as needed for our chart. */
        densityCircle.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._xFacetBinResults = [];
            this._yFacetBinResults = [];
            var xm = this._chart.xMapping();
            var ym = this._chart.yMapping();
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var xResults = beachParty.chartUtils.binTheDataForCount(dc, data, xm, "x");
                    this._xFacetBinResults.push(xResults);
                    var yResults = beachParty.chartUtils.binTheDataForCount(dc, data, ym, "y");
                    this._yFacetBinResults.push(yResults);
                }
            }
            else {
                var xResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, xm, "x");
                this._xFacetBinResults.push(xResults);
                var yResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, ym, "y");
                this._yFacetBinResults.push(yResults);
            }
            //---- adjust X scale ----
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, [xResults]);
            //---- adjust Y scale ----
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, [yResults]);
            return dc.filteredRecordCount;
        };
        densityCircle.prototype.computeCircleParams = function (rcxWorld, maxRecordsInABin) {
            var xSize = this._itemWidth;
            var ySize = this._itemHeight;
            this._radius = Math.min(xSize, ySize);
            this._spacing = .5 * this._radius / Math.sqrt(maxRecordsInABin);
            this._nextIndex = 0;
            //this._center.x = (rcxWorld.right + rcxWorld.left) / 2;
            //this._center.y = (rcxWorld.bottom + rcxWorld.top) / 2;
        };
        densityCircle.prototype.assignRecordsToBins = function (nv, resultX, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var isFiltered = (dc.layoutFilterVector != null);
            var filter = dc.layoutFilterVector;
            //var isFiltered = dc.data.isFilteredOutOfLayout();
            var allAssignX = resultX.assignments;
            var allAssignY = resultY.assignments;
            var binIndexesX = [];
            var binIndexesY = [];
            var binRelativeIndexes = [];
            var binCounts = {}; // will use string as our 3d index   (facet, x, y)
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            for (var i = 0; i < filter.length; i++) {
                var shapeIndex = i; // sri[i];        // process shape indexes, in sorted order
                if (!filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = allAssignX[shapeIndex];
                    var binIndexY = allAssignY[shapeIndex];
                    binIndexesX[shapeIndex] = binIndexX;
                    binIndexesY[shapeIndex] = binIndexY;
                    //---- update bin COUNTS ----
                    //---- we are called once for each facet, so we don't need that in our countKey anymore ----
                    var countKey = binIndexX + "," + binIndexY;
                    if (binCounts[countKey] === undefined) {
                        binCounts[countKey] = 0;
                    }
                    var binRelativeIndex = binCounts[countKey];
                    binRelativeIndexes[shapeIndex] = binRelativeIndex;
                    binCounts[countKey] = binRelativeIndex + 1;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    binIndexesX[shapeIndex] = 0;
                    binIndexesY[shapeIndex] = 0;
                }
            }
            //---- find max # of entries in any bin ----
            var maxCount = 0;
            var keys = vp.utils.keys(binCounts);
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var count = binCounts[key];
                maxCount = Math.max(count, maxCount);
            }
            var width = dc.width;
            var height = dc.height;
            var binsX = resultX.bins;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            //---- create bounds ----
            var binLefts = [];
            var binTops = [];
            var left = dc.x + this._sideMargin;
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += (this._itemWidth + this._betweenMargin);
            }
            var top = dc.y + this._sideMargin + this._itemHeight;
            for (var i = 0; i < binsY.length; i++) {
                binTops[i] = top;
                top += (this._itemHeight + this._betweenMargin);
            }
            this._binLefts = binLefts;
            this._binTops = binTops;
            this._binIndexesX = binIndexesX;
            this._binIndexesY = binIndexesY;
            this._binRelativeIndexes = binRelativeIndexes;
            return maxCount;
        };
        densityCircle.prototype.preLayoutLoop = function (dc) {
            var options = this._chartOptions;
            var nv = dc.nvData;
            //---- use pre-computed bins ----
            var xResult = this._xFacetBinResults[dc.facetIndex];
            var yResult = this._yFacetBinResults[dc.facetIndex];
            var xBinCount = xResult.bins.length;
            var yBinCount = yResult.bins.length;
            var width = dc.width;
            var height = dc.height;
            var sideMargin = .002 * dc.width;
            var betweenMargin = 3 * sideMargin;
            this._sideMargin = sideMargin;
            this._betweenMargin = betweenMargin;
            //---- compute itemWidth and itemHeight ----
            var itemWidth = (width - 2 * sideMargin - (xBinCount - 1) * betweenMargin) / xBinCount;
            var itemHeight = (height - 2 * sideMargin - (yBinCount - 1) * betweenMargin) / yBinCount;
            this._itemWidth = itemWidth;
            this._itemHeight = itemHeight;
            var maxRecordsInABin = this.assignRecordsToBins(nv, xResult, yResult, dc);
            var rcBin = vp.geom.createRect(this._binLefts[0], this._binTops[0], this._itemWidth, this._itemHeight);
            this.computeCircleParams(rcBin, maxRecordsInABin);
        };
        densityCircle.prototype.layoutDataForRecord = function (recordIndex, dc, dr) {
            var nv = dc.nvData;
            var rowIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[recordIndex]);
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var left = this._binLefts[binIndexX];
            var top = this._binTops[binIndexY];
            var cx = left + this._itemWidth / 2;
            var cy = top - this._itemHeight / 2;
            //var cx = this._center.x;
            //var cy = this._center.y;
            var binRelativeIndex = this._binRelativeIndexes[recordIndex];
            var r = this._spacing * Math.sqrt(binRelativeIndex);
            var theta = Math.PI / 180 * (binRelativeIndex * this._phyloSeed);
            dr.x = cx + r * Math.sin(theta);
            dr.y = cy + r * Math.cos(theta);
            dr.z = 0;
            dr.width = dc.maxShapeSize * this.scaleColData(nv.size, recordIndex, dc.scales.size, 1);
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, recordIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, recordIndex, dc.scales.imageIndex);
        };
        return densityCircle;
    }(beachParty.baseLayoutClass));
    beachParty.densityCircle = densityCircle;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    densityGrid.ts - builds a density chart (2D histogram, with grid layout within each heatmap tile). 
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var densityGrid = (function (_super) {
        __extends(densityGrid, _super);
        function densityGrid(chart) {
            _super.call(this, chart, "densityGrid");
            //---- all facet results ----
            this._xFacetBinResults = null;
            this._yFacetBinResults = null;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._hMargin = 0;
            this._vMargin = 0;
            this._hBetween = 0;
            this._vBetween = 0;
            this._xglobalmax = 1;
            this._yglobalmax = 1;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "xy";
        }
        /** Adjust scales as needed for our chart. */
        densityGrid.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._xFacetBinResults = [];
            this._yFacetBinResults = [];
            var xm = this._chart.xMapping();
            var ym = this._chart.yMapping();
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for consistent facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
                beachParty.chartUtils.setFilteredMinMaxBreak(ym, dc.layoutFilterVector, dc.nvData.y);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var xResults = beachParty.chartUtils.binTheDataForCount(dc, data, xm, "x");
                    this._xFacetBinResults.push(xResults);
                    var yResults = beachParty.chartUtils.binTheDataForCount(dc, data, ym, "y");
                    this._yFacetBinResults.push(yResults);
                }
            }
            else {
                var xResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, xm, "x");
                this._xFacetBinResults.push(xResults);
                var yResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, ym, "y");
                this._yFacetBinResults.push(yResults);
            }
            this.adjustScales(dc);
            return dc.filteredRecordCount;
        };
        densityGrid.prototype.adjustScales = function (dc) {
            //---- adjust X scale ----
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, [this._xFacetBinResults[0]]);
            //---- adjust Y scale ----
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, [this._yFacetBinResults[0]]);
        };
        densityGrid.prototype.assignRecordsToBins = function (nv, resultX, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignX = resultX.assignments;
            var allAssignY = resultY.assignments;
            var binIndexesX = [];
            var binIndexesY = [];
            var binRelativeIndexes = [];
            this._binCounts = {}; // will use string as our 3d index   (facet, x, y)
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            for (var i = 0; i < filter.length; i++) {
                var shapeIndex = i; // sri[i];        // process shape indexes, in sorted order
                if (!filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = allAssignX[shapeIndex];
                    var binIndexY = allAssignY[shapeIndex];
                    binIndexesX[shapeIndex] = binIndexX;
                    binIndexesY[shapeIndex] = binIndexY;
                    //---- we are called once for each facet, so we don't need that in our countKey anymore ----
                    var countKey = binIndexX + "," + binIndexY;
                    if (this._binCounts[countKey] === undefined) {
                        this._binCounts[countKey] = 0;
                    }
                    //binIndexes[shapeIndex] = binCounts[countKey];
                    this._binCounts[countKey] += 1;
                    var binRelativeIndex = this._binCounts[countKey];
                    binRelativeIndexes[shapeIndex] = binRelativeIndex;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    binIndexesX[shapeIndex] = 0;
                    binIndexesY[shapeIndex] = 0;
                }
            }
            //---- find max # of entries in any bin ----
            var maxCount = 0;
            var keys = vp.utils.keys(this._binCounts);
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var count = this._binCounts[key];
                maxCount = Math.max(count, maxCount);
            }
            var width = dc.width;
            var height = dc.height;
            var binsX = resultX.bins;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            //---- create bounds ----
            var binLefts = [];
            var binTops = [];
            var left = dc.x + this._hMargin;
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += (this._itemWidth + this._hBetween);
            }
            var top = dc.y + this._vMargin + this._itemHeight;
            for (var i = 0; i < binsY.length; i++) {
                binTops[i] = top;
                top += (this._itemHeight + this._vBetween);
            }
            this._binLefts = binLefts;
            this._binTops = binTops;
            this._binIndexesX = binIndexesX;
            this._binIndexesY = binIndexesY;
            this._binRelativeIndexes = binRelativeIndexes;
            return maxCount;
        };
        densityGrid.prototype.preLayoutLoop = function (dc) {
            var options = this._chartOptions;
            var nv = dc.nvData;
            //---- use pre-computed bins ----
            var xResult = this._xFacetBinResults[dc.facetIndex];
            var yResult = this._yFacetBinResults[dc.facetIndex];
            var xBinCount = xResult.bins.length;
            var yBinCount = yResult.bins.length;
            var width = dc.width;
            var height = dc.height;
            var hMargin = 2 * dc.itemSize;
            var hBetween = .1 * (dc.width / xBinCount);
            var vMargin = 2 * dc.itemSize;
            var vBetween = .2 * (dc.height / yBinCount);
            this._hMargin = hMargin;
            this._hBetween = hBetween;
            this._vMargin = vMargin;
            this._vBetween = vBetween;
            //---- compute itemWidth and itemHeight ----
            var itemWidth = (width - 2 * hMargin - (xBinCount - 1) * hBetween) / xBinCount;
            var itemHeight = (height - 2 * vMargin - (yBinCount - 1) * vBetween) / yBinCount;
            var ySpace = .1 * itemHeight;
            var binHeight = itemHeight - ySpace;
            this._itemWidth = itemWidth;
            this._itemHeight = itemHeight;
            var maxRecordsInABin = this.assignRecordsToBins(nv, xResult, yResult, dc);
            this._maxCount = maxRecordsInABin;
            var rcBin = vp.geom.createRect(this._binLefts[0], this._binTops[0], this._itemWidth, this._itemHeight);
            this._xglobalmax = Math.max(Math.ceil(Math.sqrt(this._maxCount)), 1);
            this._yglobalmax = Math.max(Math.ceil(this._maxCount / this._xglobalmax), 1);
            this._xspace = this._itemWidth / (this._xglobalmax);
            this._yspace = this._itemHeight / (this._yglobalmax);
            this._space = Math.min(this._xspace, this._yspace);
            var maxShapeSize = Math.min(.85 * this._itemWidth / this._xglobalmax, .85 * this._itemHeight / this._yglobalmax);
            this._maxShapeSize = maxShapeSize; //   / dc.transformSizeFactor;
        };
        densityGrid.prototype.layoutDataForRecord = function (recordIndex, dc, dr) {
            var nv = dc.nvData;
            var rowIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[recordIndex]);
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var left = this._binLefts[binIndexX];
            var top = this._binTops[binIndexY];
            var cx = left + this._itemWidth / 2;
            var cy = top - this._itemHeight / 2;
            var binRelativeIndex = this._binRelativeIndexes[recordIndex] - 1;
            var countKey = binIndexX + "," + binIndexY;
            var binCount = 0;
            if (this._binCounts[countKey] === undefined) {
                binCount = 0;
            }
            else {
                binCount = this._binCounts[countKey];
            }
            var xlocalmax = Math.max(Math.ceil(Math.sqrt(binCount)), 1);
            var ylocalmax = Math.max(Math.ceil(binCount / xlocalmax), 1);
            var maxWidth = xlocalmax * this._space;
            var maxHeight = ylocalmax * this._space;
            var xrel = binRelativeIndex % xlocalmax;
            var yrel = Math.floor(binRelativeIndex / xlocalmax);
            dr.x = cx - maxWidth / 2.0 + xrel * this._space;
            dr.y = cy + maxHeight / 2.0 - yrel * this._space;
            dr.z = 0;
            dr.width = this._maxShapeSize;
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, recordIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, recordIndex, dc.scales.imageIndex);
        };
        return densityGrid;
    }(beachParty.baseLayoutClass));
    beachParty.densityGrid = densityGrid;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    densityRandom.ts - builds a density chart (2D histogram, with RANDOM layout within each heatmap tile). 
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var densityRandom = (function (_super) {
        __extends(densityRandom, _super);
        function densityRandom(chart) {
            _super.call(this, chart, "densityRandom");
            //---- all facet results ----
            this._xFacetBinResults = null;
            this._yFacetBinResults = null;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._hMargin = 0;
            this._vMargin = 0;
            this._hBetween = 0;
            this._vBetween = 0;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "xy";
        }
        /** Adjust scales as needed for our chart. */
        densityRandom.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._xFacetBinResults = [];
            this._yFacetBinResults = [];
            var xm = this._chart.xMapping();
            var ym = this._chart.yMapping();
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var xResults = beachParty.chartUtils.binTheDataForCount(dc, data, xm, "x");
                    this._xFacetBinResults.push(xResults);
                    var yResults = beachParty.chartUtils.binTheDataForCount(dc, data, ym, "y");
                    this._yFacetBinResults.push(yResults);
                }
            }
            else {
                var xResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, xm, "x");
                this._xFacetBinResults.push(xResults);
                var yResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, ym, "y");
                this._yFacetBinResults.push(yResults);
            }
            //---- adjust X scale ----
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, [xResults]);
            //---- adjust Y scale ----
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, [yResults]);
            return dc.filteredRecordCount;
        };
        densityRandom.prototype.assignRecordsToBins = function (nv, resultX, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignX = resultX.assignments;
            var allAssignY = resultY.assignments;
            var binIndexesX = [];
            var binIndexesY = [];
            var binCounts = {}; // will use string as our 3d index   (facet, x, y)
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            for (var i = 0; i < filter.length; i++) {
                var shapeIndex = i; // sri[i];        // process shape indexes, in sorted order
                if (!filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = allAssignX[shapeIndex];
                    var binIndexY = allAssignY[shapeIndex];
                    binIndexesX[shapeIndex] = binIndexX;
                    binIndexesY[shapeIndex] = binIndexY;
                    //---- we are called once for each facet, so we don't need that in our countKey anymore ----
                    var countKey = binIndexX + "," + binIndexY;
                    if (binCounts[countKey] === undefined) {
                        binCounts[countKey] = 0;
                    }
                    //binIndexes[shapeIndex] = binCounts[countKey];
                    binCounts[countKey] += 1;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    binIndexesX[shapeIndex] = 0;
                    binIndexesY[shapeIndex] = 0;
                }
            }
            //---- find max # of entries in any bin ----
            var maxCount = 0;
            var keys = vp.utils.keys(binCounts);
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var count = binCounts[key];
                maxCount = Math.max(count, maxCount);
            }
            var width = dc.width;
            var height = dc.height;
            var binsX = resultX.bins;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            //---- create bounds ----
            var binLefts = [];
            var binTops = [];
            var left = dc.x + this._hMargin;
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += (this._itemWidth + this._hBetween);
            }
            var top = (dc.y - height) + this._vMargin + this._itemHeight;
            for (var i = 0; i < binsY.length; i++) {
                binTops[i] = top;
                top += (this._itemHeight + this._vBetween);
            }
            this._binLefts = binLefts;
            this._binTops = binTops;
            this._binIndexesX = binIndexesX;
            this._binIndexesY = binIndexesY;
            return maxCount;
        };
        densityRandom.prototype.preLayoutLoop = function (dc) {
            var options = this._chartOptions;
            var nv = dc.nvData;
            //---- use pre-computed bins ----
            var xResult = this._xFacetBinResults[dc.facetIndex];
            var yResult = this._yFacetBinResults[dc.facetIndex];
            var xBinCount = xResult.bins.length;
            var yBinCount = yResult.bins.length;
            var width = dc.width;
            var height = dc.height;
            var hMargin = 2 * dc.itemSize;
            var hBetween = .1 * (dc.width / xBinCount);
            var vMargin = 2 * dc.itemSize;
            var vBetween = .2 * (dc.height / yBinCount);
            this._hMargin = hMargin;
            this._hBetween = hBetween;
            this._vMargin = vMargin;
            this._vBetween = vBetween;
            //---- compute itemWidth and itemHeight ----
            var itemWidth = (width - 2 * hMargin - (xBinCount - 1) * hBetween) / xBinCount;
            var itemHeight = (height - 2 * vMargin - (yBinCount - 1) * vBetween) / yBinCount;
            var ySpace = .1 * itemHeight;
            var binHeight = itemHeight - ySpace;
            this._itemWidth = itemWidth;
            this._itemHeight = itemHeight;
            var maxRecordsInABin = this.assignRecordsToBins(nv, xResult, yResult, dc);
            var rcBin = vp.geom.createRect(this._binLefts[0], this._binTops[0], this._itemWidth, this._itemHeight);
        };
        densityRandom.prototype.layoutDataForRecord = function (recordIndex, dc, dr) {
            var nv = dc.nvData;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (dc.layoutFilterVector && dc.layoutFilterVector[recordIndex]);
            var rowIndex = 0;
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            //var trueRecordIndex = nv.recordIndex[recordIndex];
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var left = this._binLefts[binIndexX];
            var top = this._binTops[binIndexY];
            var xr = nv.randomX.values[recordIndex];
            var yr = nv.randomY.values[recordIndex];
            dr.x = left + xr * this._itemWidth;
            dr.y = top - yr * this._itemHeight;
            dr.z = 0;
            dr.width = dc.maxShapeSize * this.scaleColData(nv.size, recordIndex, dc.scales.size, 1);
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, recordIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, recordIndex, dc.scales.imageIndex);
        };
        return densityRandom;
    }(beachParty.baseLayoutClass));
    beachParty.densityRandom = densityRandom;
    var sandDensityOptions = (function () {
        function sandDensityOptions(columns, rows, layout) {
            this.columns = columns;
            this.rows = rows;
            this.layout = layout;
        }
        return sandDensityOptions;
    }());
    beachParty.sandDensityOptions = sandDensityOptions;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    flatCircle.ts - builds a phylogenic circle (spiral) layout of sand shapes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var flatCircle = (function (_super) {
        __extends(flatCircle, _super);
        function flatCircle(chart) {
            _super.call(this, chart, "flatCircle");
            //_phyloSeed = 137.508;           // "golden angle"
            this._maxCount = 0;
            this._radius = 0;
            this._spacing = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape_center = { x: 0, y: 0 };
            this._center = { x: 0, y: 0 };
            this._maxShapeSize = 1;
            this._maxCountOverFacets = 0;
            this._visibleColPickers = "";
            this._visibleBinAdjusters = "";
            this._chartBuilder.hideAxes(true);
        }
        flatCircle.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            this._maxCountOverFacets = beachParty.chartUtils.computeMaxCountOverFacets(dc, nvFacetBuckets);
            return this._maxCountOverFacets;
        };
        flatCircle.prototype.preLayoutLoop = function (dc) {
            var margin = 2 * dc.maxShapeSize; //   dc.itemSize;
            var xSize = dc.width - (margin);
            var ySize = dc.height - (margin);
            this._maxCount = dc.filteredRecordCount;
            this._radius = Math.min(xSize, ySize);
            this._spacing = .5 * this._radius / Math.sqrt(this._maxCount);
            this._nextIndex = 0;
            this._center.x = dc.x + dc.width / 2;
            this._center.y = dc.y + dc.height / 2;
            this._maxShapeSize = beachParty.chartUtils.getScatterShapeSize(dc, this._maxCountOverFacets, this._chart);
        };
        flatCircle.prototype.layoutDataForRecord = function (i, dc, dr) {
            var nv = dc.nvData;
            var sp = this._chart.spiralParams();
            var filtered = (dc.layoutFilterVector && dc.layoutFilterVector[i]);
            var rowIndex = 0;
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            //---- filtered code can calc stuff here, but it will not be used ----
            var cx = this._center.x;
            var cy = this._center.y;
            var r = this._spacing * Math.sqrt(rowIndex);
            var theta = Math.PI / 180 * (rowIndex * sp.seed);
            dr.x = cx + r * Math.sin(theta);
            dr.y = cy + r * Math.cos(theta);
            dr.z = 0;
            dr.width = this._maxShapeSize * this.scaleColData(nv.size, i, dc.scales.size, 1);
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, i, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, i, dc.scales.imageIndex);
        };
        return flatCircle;
    }(beachParty.baseLayoutClass));
    beachParty.flatCircle = flatCircle;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    flatGrid.ts - builds a GROD 2d layout of sand shapes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var flatGrid = (function (_super) {
        __extends(flatGrid, _super);
        function flatGrid(chart) {
            _super.call(this, chart, "flatGrid");
            //---- all facets info ----
            this._maxCountAllFacets = 0;
            this._colCount = 0;
            this._rowCount = 0;
            this._nextIndex = 0;
            this._maxShapeWidth = 1;
            this._maxShapeHeight = 1;
            this._itemSize = 0;
            this._visibleColPickers = "y";
            this._visibleBinAdjusters = "";
            this._chartBuilder.hideAxes(true);
        }
        flatGrid.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            this._maxCountAllFacets = beachParty.chartUtils.computeMaxCountOverFacets(dc, nvFacetBuckets);
            this._itemSize = dc.itemSize;
            return this._maxCountAllFacets;
        };
        flatGrid.prototype.buildScales = function (nv, rcxWorld, filteredRecordCount, facetCount) {
            var result = this._chartBuilder.buildDefaultScales(nv, rcxWorld, filteredRecordCount, facetCount);
            var margin = this._itemSize / 4;
            var fp = this._chart.flatParams();
            //---- override X and Y scales - force the domain to [0..1] ----
            result.x = beachParty.cbUtils.makeLinearScale(0, 1, rcxWorld.left + margin, rcxWorld.right - margin);
            if (fp.buildFromTop) {
                result.y = beachParty.cbUtils.makeLinearScale(0, 1, rcxWorld.top - margin, rcxWorld.bottom + margin);
            }
            else {
                result.y = beachParty.cbUtils.makeLinearScale(0, 1, rcxWorld.bottom + margin, rcxWorld.top - margin);
            }
            return result;
        };
        flatGrid.prototype.preLayoutLoop = function (dc) {
            var maxCount = this._maxCountAllFacets;
            var fp = this._chart.flatParams();
            var colCount = fp.numColumns;
            if (!colCount) {
                //---- num of columns not specified by user; compute it so that shapes are square ----
                var aspect = dc.width / dc.height;
                colCount = Math.ceil(Math.sqrt(aspect * maxCount));
            }
            var rowCount = Math.ceil(maxCount / colCount);
            this._colCount = colCount;
            this._rowCount = rowCount;
            //---- use .85 to allow some space between shapes ----
            var spaceFactor = 1 - (.15 * this._chart.separationFactor());
            this._maxShapeWidth = spaceFactor * dc.width / this._colCount;
            this._maxShapeHeight = spaceFactor * dc.height / this._rowCount;
            this._nextIndex = 0;
        };
        /** "bufferIndex" in the 0-based indexed into the sorted data buffers. */
        flatGrid.prototype.layoutDataForRecord = function (bufferIndex, dc, dr) {
            //---- flat grid layout ----
            var nv = dc.nvData;
            var scales = dc.scales;
            var filtered = (dc.layoutFilterVector && dc.layoutFilterVector[bufferIndex]);
            //---- "layoutIndex" is the index into the FILTERED-IN shapes that are being layed out in this plot. */
            var layoutIndex = 0;
            if (!filtered) {
                layoutIndex = this._nextIndex++;
            }
            var xData = layoutIndex % this._colCount;
            var yData = Math.floor(layoutIndex / this._colCount);
            dr.x = scales.x.scale((xData + .5) / this._colCount);
            dr.y = scales.y.scale((yData + .5) / this._rowCount);
            dr.z = 0;
            var sizeFactor = this.scaleColData(nv.size, bufferIndex, dc.scales.size, 1);
            dr.width = this._maxShapeWidth * sizeFactor;
            dr.height = this._maxShapeHeight * sizeFactor;
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, bufferIndex, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, bufferIndex, dc.scales.imageIndex);
        };
        return flatGrid;
    }(beachParty.baseLayoutClass));
    beachParty.flatGrid = flatGrid;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    flatRandom.ts - builds a random 2d layout of sand shapes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var flatRandom = (function (_super) {
        __extends(flatRandom, _super);
        function flatRandom(chart) {
            _super.call(this, chart, "flatRandom");
            this._randomX = [];
            this._randomY = [];
            this._maxShapeSize = 1;
            this._nextRandIndex = 0;
            this._itemSize = 0;
            this._visibleColPickers = "";
            this._visibleBinAdjusters = "";
            this._chartBuilder.hideAxes(true);
        }
        flatRandom.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            this._itemSize = dc.maxShapeSize; // dc.itemSize;
            return _super.prototype.computeFacetStats.call(this, dc, nvFacetBuckets);
        };
        flatRandom.prototype.buildScales = function (nv, rcxWorld, filteredRecordCount, facetCount) {
            var result = this._chartBuilder.buildDefaultScales(nv, rcxWorld, filteredRecordCount, facetCount);
            var itemSize = this._itemSize;
            //---- override X and Y scales - force the domain to [0..1] ----
            result.x = beachParty.cbUtils.makeLinearScale(0, 1, rcxWorld.left + itemSize, rcxWorld.right - itemSize);
            result.y = beachParty.cbUtils.makeLinearScale(0, 1, rcxWorld.bottom + itemSize, rcxWorld.top - itemSize);
            return result;
        };
        flatRandom.prototype.preLayoutLoop = function (dc) {
            this._maxShapeSize = dc.maxShapeSize;
            this._nextRandIndex = 0;
        };
        flatRandom.prototype.layoutDataForRecord = function (i, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            var ri = 0;
            if (dc.layoutFilterVector && (!dc.layoutFilterVector[i])) {
                ri = this._nextRandIndex++;
            }
            var xr = nv.randomX.values[ri];
            var yr = nv.randomY.values[ri];
            dr.x = scales.x.scale(xr);
            dr.y = scales.y.scale(yr);
            dr.z = 0;
            dr.width = this._maxShapeSize * this.scaleColData(nv.size, i, scales.size, 1);
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, i, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, i, dc.scales.imageIndex);
        };
        return flatRandom;
    }(beachParty.baseLayoutClass));
    beachParty.flatRandom = flatRandom;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    linePlot.ts - builds a 2D line plot from pairs of records describing the FROM and TO positions.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var linePlotClass = (function (_super) {
        __extends(linePlotClass, _super);
        function linePlotClass(chart, useLinePrim, useLinePairs) {
            _super.call(this, chart, "linePlot");
            this._ptLast = null;
            this._inverseSizeFactor = 0;
            this._useLinePrim = false;
            this._useLinePairs = false;
            this._useLinePrim = useLinePrim;
            this._useLinePairs = useLinePairs;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "";
            if (useLinePairs) {
                var shapeEng = this._chartBuilder.getShapeEngine();
                shapeEng.overrideDrawPrimitive(beachParty.DrawPrimitive.linePairs);
            }
        }
        linePlotClass.prototype.preLayoutLoop = function (dc) {
            this._ptLast = null;
            this._inverseSizeFactor = 1 / dc.userSizeFactor; // / dc.combinedSizeFactor;
            //this._uniformsChanged.lines = true;
        };
        linePlotClass.prototype.positionLine = function (x1, y1, x2, y2) {
            var xdiff = x1 - x2;
            var ydiff = y1 - y2;
            var width = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
            var cx = (x1 + x2) / 2;
            var cy = (y1 + y2) / 2;
            var theta = Math.atan2(ydiff, xdiff);
            return { cx: cx, cy: cy, width: width, theta: theta };
        };
        linePlotClass.prototype.layoutDataForRecord = function (i, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            var sx = this.scaleColData(nv.x, i, scales.x);
            var sy = this.scaleColData(nv.y, i, scales.y);
            var sz = this.scaleColData(nv.size, i, scales.size, 1);
            if (this._useLinePrim) {
                dr.x = sx;
                dr.y = sy;
                dr.width = sz;
                dr.height = dr.width;
            }
            else {
                if (this._ptLast == null) {
                    dr.x = 0;
                    dr.y = 0;
                    dr.width = 0;
                    dr.height = 0;
                }
                else {
                    var result = this.positionLine(sx, sy, this._ptLast.x, this._ptLast.y);
                    dr.x = result.cx;
                    dr.y = result.cy;
                    dr.width = sz * this._inverseSizeFactor * result.width; // prevent shader from scaling this width
                    dr.height = .005; // 1;
                    dr.theta = result.theta;
                }
            }
            dr.z = -0; // for correct rotation about Y axis
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, i, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, i, dc.scales.imageIndex);
            this._ptLast = { x: sx, y: sy };
        };
        return linePlotClass;
    }(beachParty.baseLayoutClass));
    beachParty.linePlotClass = linePlotClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    partyGenPlot.ts - creates a custom plot based on recursive binning and space division, as 
//          developed in the PartyGen tool.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var partyGenPlotClass = (function (_super) {
        __extends(partyGenPlotClass, _super);
        function partyGenPlotClass(chart, chartType) {
            _super.call(this, chart, "partyGenPlot");
            //---- all facets info ----
            this._maxCountAllFacets = 0;
            this._maxShapeSize = 0;
            this._nextInFilterIndex = 0;
            this._fillCell = false; // whether shapes should fill their layout cells
            this._chartType = chartType;
            this._dataDivider1 = new beachParty.DataDivider();
            this._dataDivider2 = new beachParty.DataDivider();
            this._dataDivider3 = new beachParty.DataDivider();
            this._dataDivider4 = new beachParty.DataDivider();
            this._spaceDivider1 = new beachParty.SpaceDivider();
            this._spaceDivider2 = new beachParty.SpaceDivider();
            this._spaceDivider3 = new beachParty.SpaceDivider();
            this._spaceDivider4 = new beachParty.SpaceDivider();
            if (chartType == "FlatSquarify") {
                this._visibleColPickers = "y";
                this._visibleBinAdjusters = "";
            }
            this._shapeMaker = new beachParty.ShapeMaker(null, beachParty.ShapeType.none);
        }
        partyGenPlotClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            this._maxCountAllFacets = beachParty.chartUtils.computeMaxCountOverFacets(dc, nvFacetBuckets);
            //---- call this now so that "this._hideAxes" gets set in time to take effect ----
            this.applyPresets(dc);
            return this._maxCountAllFacets;
        };
        partyGenPlotClass.prototype.applyPresets = function (dc) {
            this.resetDividersAndShapes(dc);
            var chartType = this._chartType;
            var xm = this._chart.xMapping();
            var ym = this._chart.yMapping();
            var chart = this._chart;
            var chartBuilder = this._chartBuilder;
            this._fillCell = false;
            if (chartType == "Scatter") {
                this._spaceDivider4.spaceType = beachParty.SpaceType.plotXY;
            }
            else if (chartType == "FlatCircle") {
                this._spaceDivider4.spaceType = beachParty.SpaceType.fillOut;
                chartBuilder.hideAxes(true);
            }
            else if (chartType == "FlatGrid") {
                this._spaceDivider4.spaceType = beachParty.SpaceType.packXY;
                this._spaceDivider4.reverse = true; // flipped Y
                chartBuilder.hideAxes(true);
            }
            else if (chartType == "FlatRandom") {
                this._spaceDivider4.spaceType = beachParty.SpaceType.random;
                chartBuilder.hideAxes(true);
            }
            else if (chartType == "FlatSquarify") {
                //var marginBase = dc.width / 5000;
                //if (this._facetHelper)
                //{
                //    marginBase *= 5;
                //}
                //var cellMargin = view.separationFactor() * marginBase;       // (dc.filteredRecordCount) ? (dc.width / Math.sqrt(dc.filteredRecordCount)) : 0;
                this._spaceDivider4.spaceType = beachParty.SpaceType.squarify;
                this._spaceDivider4.cellMargin = dc.spacingFactor;
                chartBuilder.hideAxes(true);
                this._fillCell = true;
            }
            else if (chartType == "FlatPoisson") {
                this._spaceDivider4.spaceType = beachParty.SpaceType.poisson;
                chartBuilder.hideAxes(true);
            }
            else if (chartType == "ColumnGrid") {
                this._dataDivider3.colName = xm.colName;
                this._dataDivider3.groupCount = xm.binCount;
                this._dataDivider3.groupSorting = xm.binSorting;
                this._spaceDivider3.spaceType = beachParty.SpaceType.fillX;
                this._spaceDivider3.cellMargin = dc.width / 50;
                this._spaceDivider4.spaceType = beachParty.SpaceType.packXY;
                this._spaceDivider4.reverse = true; // flipped Y
                chartBuilder.hideAxes(true);
            }
            else if (chartType == "BarGrid") {
                this._dataDivider3.colName = ym.colName;
                this._dataDivider3.groupCount = ym.binCount;
                this._dataDivider3.groupSorting = ym.binSorting;
                this._spaceDivider3.spaceType = beachParty.SpaceType.fillY;
                this._spaceDivider3.cellMargin = dc.width / 50;
                //this._spaceDivider3.reverse = true; 
                this._spaceDivider4.spaceType = beachParty.SpaceType.packYX;
                this._spaceDivider4.reverse = true; // flipped Y
                chartBuilder.hideAxes(true);
            }
        };
        partyGenPlotClass.prototype.resetDividersAndShapes = function (dc) {
            this._chartBuilder.hideAxes(false);
            if (this._chartType == "FlatSquarify") {
                //---- this is still messy while chart type /layout design in flux ----
                var primaryCol = this._chart.auxMapping().colName;
                if (!primaryCol) {
                    primaryCol = this._chart.xMapping().colName;
                }
            }
            else {
                var primaryCol = this._chart.xMapping().colName;
            }
            var secondaryCol = this._chart.yMapping().colName;
            this._spaceDivider1.xStat.colName = primaryCol;
            this._spaceDivider2.xStat.colName = primaryCol;
            this._spaceDivider3.xStat.colName = primaryCol;
            this._spaceDivider4.xStat.colName = primaryCol;
            this._spaceDivider1.yStat.colName = secondaryCol;
            this._spaceDivider2.yStat.colName = secondaryCol;
            this._spaceDivider3.yStat.colName = secondaryCol;
            this._spaceDivider4.yStat.colName = secondaryCol;
            this._dataDivider1.colName = primaryCol;
            this._dataDivider2.colName = primaryCol;
            this._dataDivider3.colName = primaryCol;
            this._dataDivider1.groupCount = 5;
            this._dataDivider2.groupCount = 5;
            this._dataDivider3.groupCount = 5;
            beachParty.maxContainers = 0; // off by default
            this._spaceDivider1.margin = 0;
            this._spaceDivider2.margin = 0;
            this._spaceDivider3.margin = 0;
            this._spaceDivider4.margin = 0;
            this._spaceDivider1.cellMargin = 0;
            this._spaceDivider2.cellMargin = 0;
            this._spaceDivider3.cellMargin = 0;
            this._spaceDivider4.cellMargin = 0;
            this._spaceDivider1.spaceType = beachParty.SpaceType.none;
            this._spaceDivider2.spaceType = beachParty.SpaceType.none;
            this._spaceDivider3.spaceType = beachParty.SpaceType.none;
            this._spaceDivider4.spaceType = beachParty.SpaceType.packXY;
            this._spaceDivider1.reverse = false;
            this._spaceDivider2.reverse = false;
            this._spaceDivider3.reverse = false;
            this._spaceDivider4.reverse = false;
            this._spaceDivider1.hAlign = beachParty.HAlign.left;
            this._spaceDivider2.hAlign = beachParty.HAlign.left;
            this._spaceDivider3.hAlign = beachParty.HAlign.left;
            this._spaceDivider4.hAlign = beachParty.HAlign.left;
            this._spaceDivider1.vAlign = beachParty.VAlign.bottom;
            this._spaceDivider2.vAlign = beachParty.VAlign.bottom;
            this._spaceDivider3.vAlign = beachParty.VAlign.bottom;
            this._spaceDivider4.vAlign = beachParty.VAlign.bottom;
            this._spaceDivider1.xStat.peerScale = false;
            this._spaceDivider2.xStat.peerScale = false;
            this._spaceDivider3.xStat.peerScale = false;
            this._spaceDivider4.xStat.peerScale = false;
            this._spaceDivider1.yStat.peerScale = false;
            this._spaceDivider2.yStat.peerScale = false;
            this._spaceDivider3.yStat.peerScale = false;
            this._spaceDivider4.yStat.peerScale = false;
        };
        partyGenPlotClass.prototype.addDivider = function (dividers, dd, sd, layers) {
            if (layers === void 0) { layers = []; }
            var divider = new beachParty.ChartDivider();
            divider.dd = dd;
            divider.sd = sd;
            divider.shapeLayers = layers;
            dividers.push(divider);
            return divider;
        };
        /** called for each facet. */
        partyGenPlotClass.prototype.preLayoutLoop = function (dc) {
            this.applyPresets(dc);
            this._maxShapeSize = dc.maxShapeSize;
            this._shapeMaker.shapeSize = this._maxShapeSize;
            this._spaceDivider4.xRandom = (dc.nvData.randomX) ? dc.nvData.randomX.values : null;
            this._spaceDivider4.yRandom = (dc.nvData.randomY) ? dc.nvData.randomY.values : null;
            var rc = vp.geom.createRect(dc.x, dc.y, dc.width, dc.height);
            //---- build "dividers" ----
            var dividers = [];
            if (this._dataDivider1.colName && this._spaceDivider1.spaceType != beachParty.SpaceType.none) {
                this.addDivider(dividers, this._dataDivider1, this._spaceDivider1);
            }
            if (this._dataDivider2.colName && this._spaceDivider2.spaceType != beachParty.SpaceType.none) {
                this.addDivider(dividers, this._dataDivider2, this._spaceDivider2);
            }
            if (this._dataDivider3.colName && this._spaceDivider3.spaceType != beachParty.SpaceType.none) {
                this.addDivider(dividers, this._dataDivider3, this._spaceDivider3);
            }
            if (this._spaceDivider4.spaceType != beachParty.SpaceType.none) {
                this.addDivider(dividers, this._dataDivider4, this._spaceDivider4);
            }
            //---- get a dataFrame of the records for this facet ----
            var facetIndexes = null;
            if (dc.facetHelper) {
                facetIndexes = dc.facetHelper.binResult().bins[dc.facetIndex].rowIndexes;
            }
            var origDataFrame = this._chart.getDataFrame();
            var dataFrame = origDataFrame.copyData(facetIndexes);
            if (dc.filteredRecordCount != dc.recordCount) {
                var indexes = [];
                var filter = dc.layoutFilterVector;
                var count = dataFrame.getRecordCount();
                //---- filter data before layout ----
                for (var i = 0; i < count; i++) {
                    if (!filter[i]) {
                        indexes.push(i);
                    }
                }
                dataFrame = dataFrame.copyData(indexes);
            }
            //---- build the rcArray's for each container ----
            this.genLayout(null, rc, dataFrame, dividers, 0);
            this._nextInFilterIndex = 0;
        };
        partyGenPlotClass.prototype.genLayout = function (svg, rc, dataFrame, dividers, divideLevel) {
            //var shapeMakers = [shapeMaker];
            //---- GENERATE containers ----
            var root = new beachParty.Container(dataFrame, 0);
            root.binAndGen(dividers);
            //---- MEASURE sizes & stats ----
            var results = root.measure(dividers);
            //---- LAYOUT all containers ----
            var leafRcArray = [];
            var cellData = beachParty.CellData.fromRect(rc, beachParty.CellShape.rectangle);
            root.layout(dividers, cellData, results.scaleData, svg, leafRcArray);
            this._leafRcArray = leafRcArray;
        };
        partyGenPlotClass.prototype.layoutDataForRecord = function (i, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            var filter = dc.layoutFilterVector;
            if (!filter[i]) {
                //---- IN FILTER - give it the next rcArray ----
                var index = this._nextInFilterIndex++;
                var cellData = this._leafRcArray[index];
                var rc = cellData.rect;
            }
            else {
                //---- OUT OF FILTER; give it default rc ----
                var rc = vp.geom.createRect(0, 0, 1, 1);
            }
            var isRect = false; // (shapeType == ShapeType.rectangle);
            if (this._fillCell) {
                dr.width = rc.width; // / dc.userSizeFactor;       // dc.combinedSizeFactor;
                dr.height = rc.height; // / dc.userSizeFactor;     // dc.combinedSizeFactor;
            }
            else {
                dr.width = this._maxShapeSize * this.scaleColData(nv.size, i, scales.size, 1);
                dr.height = dr.width;
            }
            dr.depth = dc.defaultDepth2d;
            //---- center drawing within cell ----
            dr.x = rc.left + rc.width / 2;
            //---- work around facet vs. non-facet inconsistency in bottom/top usage ----
            dr.y = Math.min(rc.bottom, rc.top) + rc.height / 2; // rc.top
            dr.z = 0;
            if (isRect) {
                dr.x -= dr.width / 2;
                dr.y -= dr.height / 2;
            }
            dr.colorIndex = this.scaleColData(nv.colorIndex, i, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, i, dc.scales.imageIndex);
        };
        return partyGenPlotClass;
    }(beachParty.baseLayoutClass));
    beachParty.partyGenPlotClass = partyGenPlotClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    sandRadial.ts - builds a 2D scatter plot of sand shapes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var radialClass = (function (_super) {
        __extends(radialClass, _super);
        function radialClass(chart) {
            _super.call(this, chart, "radial");
            this._cx = 0;
            this._cy = 0;
            this._maxShapeSize = 1;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "";
            this._chartBuilder.hideAxes(true);
        }
        radialClass.prototype.buildScales = function (nv, rcxWorld, filteredRecordCount, facetCount) {
            //---- modify X and Y scales - force the RANGE to [0..2*PI], [0..maxRadius] ----
            var maxRadius = Math.min(rcxWorld.width / 2, rcxWorld.height / 2);
            var rcx = beachParty.cbUtils.cloneMap(rcxWorld);
            //---- scales.x RANGE: 0-2*PI ----
            rcx.left = 0;
            rcx.right = 2 * Math.PI;
            rcx.width = rcxWorld.right - rcxWorld.left;
            //---- scales.y RANGE: 0-maxRadius ----
            rcx.top = maxRadius;
            rcx.bottom = 0;
            rcx.height = rcxWorld.top - rcxWorld.bottom;
            var result = this._chartBuilder.buildDefaultScales(nv, rcx, filteredRecordCount, facetCount);
            return result;
        };
        radialClass.prototype.preLayoutLoop = function (dc) {
            this._cx = dc.x + dc.width / 2;
            this._cy = dc.y + dc.height / 2;
            this._maxShapeSize = dc.maxShapeSize;
        };
        radialClass.prototype.layoutDataForRecord = function (i, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            var theta = -(Math.PI / 2 + this.scaleColData(nv.x, i, scales.x));
            var radius = this.scaleColData(nv.y, i, scales.y);
            dr.x = this._cx + radius * Math.cos(theta);
            dr.y = this._cy + radius * Math.sin(theta);
            dr.z = 0;
            dr.width = this._maxShapeSize * this.scaleColData(nv.size, i, scales.size, 1);
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, i, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, i, dc.scales.imageIndex);
        };
        return radialClass;
    }(beachParty.baseLayoutClass));
    beachParty.radialClass = radialClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    scatterPlot.ts - builds a 2D scatter plot of sand shapes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    ///-------------------------------------------------------------------------------------------------------------------------------------
    /// Chart Layout rules:
    ///     1. to honor the 2-stage filter, only layout the records not removed by dc.layoutFilterVector.
    ///     2. dc.filteredRecordCount correctly counts the filtered-in records (as per the 2-stage filter)
    ///     3. honor facets by using dc.x, dc.y, dc.width, dc.height for the bounds of the facet/chart
    ///     4. CAUTION with overriding "buildScales()" since it is called TWICE (computeFacetStats & final scales) (not per facet)
    ///     5. If you build info for shapes, be consistent with its index (suggest using true shapeIndex rather than facet-relative index)
    ///     6. use "computeFacetStats(dc, data)" for operations across facets (like maxBinCount used by Column chart) AND to adjust scales.
    ///-------------------------------------------------------------------------------------------------------------------------------------
    ///-------------------------------------------------------------------------------------------------------------------------------------
    /// CAUTION: the below info is this comment needs to be checked for accuracy (as of 9/18/2016) - rfernand.
    ///
    /// chartBuilder layout steps: (charts should override the CHART.xxx() calls)
    ///     - prepassAndFrameBuild()
    ///         - buildNamedVectors()
    ///
    ///         - //---- build PREPASS info ----
    ///         - updateChartBounds()       // with 0 size chartFrame
    ///         - calcRanges()
    ///         - buildScales()
    ///         - dc = new DrawContext()
    ///         - CHART.computeFacetStats()               // chart should compute stats across all facets
    ///         - CHART.adjustScales()
    ///         - chartFrameHelper.build()      // build Y and X axes
    ///
    ///         - //---- build FINAL info ----
    ///         - updateChartBounds()           // finalize space for plot area
    ///         - calcRanges()
    ///         - buildScales()                 // build scales using finalized space
    ///         - dc = new DrawContext()
    ///         - CHART.adjustScales()          // adjust scales
    ///     - getAttributesForCycle()
    ///     - getNamedBuffers()
    ///     - for each facet:
    ///         - layoutChartOrFacet()              
    ///             - CHART.preLayoutLoop()
    ///             - for each record:
    ///                 - CHART.layoutDataForRecord()
    ///                 - processRecord()
    ///                 - fillBuffersForRecord()
    ///             - fillGridLinesBuffer()
    ///-------------------------------------------------------------------------------------------------------------------------------------
    var scatterPlotClass = (function (_super) {
        __extends(scatterPlotClass, _super);
        function scatterPlotClass(chart) {
            _super.call(this, chart, "scatterPlot");
            this._maxShapeSize = 0;
            this._halfSizeSize = 0;
            this._z = 0;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "";
        }
        scatterPlotClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            //---- this call modifies the PREPASS scales (for use by the chart frame) ----
            this.modifyXYScales(dc);
            return dc.filteredRecordCount;
        };
        scatterPlotClass.prototype.modifyXYScales = function (dc, halfShapeSize) {
            //---- add spacing on both sides of X and Y scales to keep shapes within the borders ----
            if (halfShapeSize != undefined) {
                var xExpand = halfShapeSize;
                var yExpand = halfShapeSize;
            }
            else {
                var sp = this._chart.scatterParams();
                var shapeSize = dc.maxShapeSize;
                if (sp) {
                    var xExpand = sp.percentExpandX * shapeSize;
                    var yExpand = sp.percentExpandY * shapeSize;
                }
                else {
                    var xExpand = .5 * shapeSize;
                    var yExpand = .5 * shapeSize;
                }
            }
            //---- note: expandSpace() for scale in specifed in range units (world units, in this case) ----
            dc.scales.x
                .expandSpace(xExpand);
            dc.scales.y
                .expandSpace(yExpand);
            this._halfSizeSize = xExpand;
        };
        scatterPlotClass.prototype.preLayoutLoop = function (dc) {
            //---- this call modifies the FINAL scales (for use by our X/Y mapping) ----
            this.modifyXYScales(dc, this._halfSizeSize);
            this._maxShapeSize = dc.maxShapeSize;
            //---- place our 2D place in middle of Z space ----
            this._z = dc.z + dc.depth / 2;
        };
        /** "bufferIndex" in the 0-based indexed into the sorted data buffers. */
        scatterPlotClass.prototype.layoutDataForRecord = function (bufferIndex, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            dr.x = this.scaleColData(nv.x, bufferIndex, scales.x);
            dr.y = this.scaleColData(nv.y, bufferIndex, scales.y);
            dr.z = this._z; // for correct rotation about Y axis
            dr.width = this._maxShapeSize * this.scaleColData(nv.size, bufferIndex, scales.size, 1);
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, bufferIndex, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, bufferIndex, dc.scales.imageIndex);
        };
        return scatterPlotClass;
    }(beachParty.baseLayoutClass));
    beachParty.scatterPlotClass = scatterPlotClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    scatterplot3d.ts - builds a 3D scatter plot.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var scatterPlot3dClass = (function (_super) {
        __extends(scatterPlot3dClass, _super);
        function scatterPlot3dClass(chart) {
            _super.call(this, chart, "scatterPlot3d");
            this._maxShapeSize = 0;
            this._visibleColPickers = "xyz";
            this._visibleBinAdjusters = "";
            var transformMgr = this._chartBuilder.getTransformMgr();
            //---- zoom camera out a bit so we can see full bounding box ----
            transformMgr.scaleCameraRelative(1 / 1.3, { x: 0, y: 0 });
            this._is3dChart = true;
        }
        scatterPlot3dClass.prototype.preLayoutLoop = function (dc) {
            this._maxShapeSize = dc.maxShapeSize; //  chartUtils.getScatterShapeSize(dc);
        };
        scatterPlot3dClass.prototype.layoutDataForRecord = function (i, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            dr.x = this.scaleColData(nv.x, i, scales.x);
            dr.y = this.scaleColData(nv.y, i, scales.y);
            dr.z = this.scaleColData(nv.z, i, scales.z);
            dr.width = this._maxShapeSize * this.scaleColData(nv.size, i, scales.size, 1);
            dr.height = dr.width;
            dr.depth = dr.width; // .1 / dc.combinedSizeFactor;
            dr.colorIndex = this.scaleColData(nv.colorIndex, i, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, i, dc.scales.imageIndex);
        };
        return scatterPlot3dClass;
    }(beachParty.baseLayoutClass));
    beachParty.scatterPlot3dClass = scatterPlot3dClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    stacksBins.ts - builds a stacked (in Z) 2D histogram, wheere each stack in a set of NxN substacks.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var stacksBinClass = (function (_super) {
        __extends(stacksBinClass, _super);
        function stacksBinClass(chart) {
            _super.call(this, chart, "stacksBin");
            //---- all facet results ----
            this._xFacetBinResults = null;
            this._yFacetBinResults = null;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._hMargin = 0;
            this._vMargin = 0;
            this._hBetween = 0;
            this._vBetween = 0;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "xyz";
            var transformMgr = this._chartBuilder.getTransformMgr();
            //---- initially rotate about X axis 45 degrees for perspective view ----
            transformMgr.rotateMatrixX(Math.PI / 4.0, false, false);
            //---- zoom camera out a bit so we can see full bounding box ----
            transformMgr.scaleCameraRelative(1 / 1.3, { x: 0, y: 0 });
            this._is3dChart = true;
        }
        /** Adjust scales as needed for our chart. */
        stacksBinClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._xFacetBinResults = [];
            this._yFacetBinResults = [];
            var xm = this._chart.xMapping();
            var ym = this._chart.yMapping();
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for CONSISTENT facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
                beachParty.chartUtils.setFilteredMinMaxBreak(ym, dc.layoutFilterVector, dc.nvData.y);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var xResults = beachParty.chartUtils.binTheDataForCount(dc, data, xm, "x");
                    this._xFacetBinResults.push(xResults);
                    var yResults = beachParty.chartUtils.binTheDataForCount(dc, data, ym, "y");
                    this._yFacetBinResults.push(yResults);
                }
            }
            else {
                var allData = dc.nvData;
                var xResults = beachParty.chartUtils.binTheDataForCount(dc, allData, xm, "x");
                this._xFacetBinResults.push(xResults);
                var yResults = beachParty.chartUtils.binTheDataForCount(dc, allData, ym, "y");
                this._yFacetBinResults.push(yResults);
            }
            //---- adjust X scale ----
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, [xResults]);
            //---- adjust Y scale ----
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, [yResults]);
            return dc.filteredRecordCount;
        };
        stacksBinClass.prototype.assignRecordsToBins = function (nv, resultX, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var binWidthCount = this._chart.zMapping().binCount;
            var binHeightCount = this._chart.zMapping().binCount;
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignX = resultX.assignments;
            var allAssignY = resultY.assignments;
            var binIndexesX = [];
            var binIndexesY = [];
            var stackIndexes = [];
            var binCounts = {}; // will use string as our 3d index   (facet, x, y)
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            for (var i = 0; i < filter.length; i++) {
                var shapeIndex = i; // sri[i];        // process shape indexes, in sorted order
                if (!filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = allAssignX[shapeIndex];
                    var binIndexY = allAssignY[shapeIndex];
                    binIndexesX[shapeIndex] = binIndexX;
                    binIndexesY[shapeIndex] = binIndexY;
                    //---- we are called once for each facet, so we don't need that in our countKey anymore ----
                    var countKey = binIndexX + "," + binIndexY;
                    if (binCounts[countKey] === undefined) {
                        binCounts[countKey] = 0;
                    }
                    stackIndexes[shapeIndex] = binCounts[countKey];
                    binCounts[countKey] += 1;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    binIndexesX[shapeIndex] = 0;
                    binIndexesY[shapeIndex] = 0;
                    stackIndexes[shapeIndex] = 0;
                }
            }
            //---- find max # of entries in any bin ----
            var maxCount = 0;
            var keys = vp.utils.keys(binCounts);
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var count = binCounts[key];
                maxCount = Math.max(count, maxCount);
            }
            //---- number of cubes in a stack should be a whole number ----
            var maxCubesInAStack = Math.ceil(maxCount / (binWidthCount * binHeightCount));
            this._maxCubesInAStack = maxCubesInAStack;
            var binDepth = dc.depth / maxCubesInAStack;
            //binDepth = Math.min(this._itemWidth, this._itemHeight, binDepth);
            this._binDepth = binDepth;
            /*
            var totalZHeight = 4;
            this._binDepth = totalZHeight / maxCount;
            this._itemDepth = .9 * this._binDepth;           // .9 * this._binDepth;
            */
            var width = dc.width;
            var height = dc.height;
            var binsX = resultX.bins;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            //---- create bounds ----
            var binLefts = [];
            var binTops = [];
            var left = dc.x + this._hMargin;
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += (this._binWidth + this._hBetween);
            }
            var top = dc.y + this._vMargin + this._binHeight;
            for (var i = 0; i < binsY.length; i++) {
                binTops[i] = top;
                top += (this._binHeight + this._vBetween);
            }
            this._binLefts = binLefts;
            this._binTops = binTops;
            this._binIndexesX = binIndexesX;
            this._binIndexesY = binIndexesY;
            this._stackIndexes = stackIndexes;
            return maxCount;
        };
        stacksBinClass.prototype.preLayoutLoop = function (dc) {
            var binWidthCount = this._chart.zMapping().binCount;
            var binHeightCount = this._chart.zMapping().binCount;
            var options = this._chartOptions;
            var nv = dc.nvData;
            //---- use pre-computed bins ----
            var xResult = this._xFacetBinResults[dc.facetIndex];
            var yResult = this._yFacetBinResults[dc.facetIndex];
            var xBinCount = xResult.bins.length;
            var yBinCount = yResult.bins.length;
            var width = dc.width;
            var height = dc.height;
            var hMargin = 2 * dc.itemSize;
            var hBetween = .1 * (dc.width / xBinCount);
            var vMargin = 2 * dc.itemSize;
            var vBetween = .2 * (dc.height / yBinCount);
            this._hMargin = hMargin;
            this._hBetween = hBetween;
            this._vMargin = vMargin;
            this._vBetween = vBetween;
            //---- compute itemWidth and itemHeight ----
            var binWidth = (width - 2 * hMargin - (xBinCount - 1) * hBetween) / xBinCount;
            var binHeight = (height - 2 * vMargin - (yBinCount - 1) * vBetween) / yBinCount;
            var ySpace = .1 * binHeight;
            var binHeight = binHeight - ySpace;
            //---- limit size, so we don't get slow ----
            this._binWidth = binWidth;
            this._binHeight = binHeight;
            var innerMargin = .001; // ??? what should inner margin be?
            var innerBetween = .001; // ?? what should innerBetween be?
            var potItemWidth = (binWidth - 2 * innerMargin - (binWidthCount - 1) * innerBetween) / binWidthCount;
            var potItemHeight = (binHeight - 2 * innerMargin - (binHeightCount - 1) * innerBetween) / binHeightCount;
            this._itemWidth = Math.min(potItemWidth, potItemHeight);
            this._itemHeight = Math.min(potItemWidth, potItemHeight);
            // this._itemWidth = Math.min(.2, binWidth);
            // this._itemHeight = Math.min(.2, binHeight);
            this._space = Math.min(1.1 * this._itemWidth, 1.1 * this._itemHeight);
            this._leftOff = (binWidth - this._itemWidth) / 2;
            this._topOff = (binHeight - this._itemHeight) / 2;
            var maxRecordsInABin = this.assignRecordsToBins(nv, xResult, yResult, dc);
            var rcBin = vp.geom.createRect(this._binLefts[0], this._binTops[0], this._binWidth, this._binHeight);
        };
        stacksBinClass.prototype.layoutDataForRecord = function (recordIndex, dc, dr) {
            var stackWidth = this._chart.zMapping().binCount;
            var stackHeight = this._chart.zMapping().binCount;
            var nv = dc.nvData;
            var filtered = (dc.layoutFilterVector && dc.layoutFilterVector[recordIndex]);
            var rowIndex = 0;
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            //var trueRecordIndex = nv.recordIndex[recordIndex];
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var left = this._binLefts[binIndexX];
            var top = this._binTops[binIndexY];
            //---- stackIndex in an index into a 1x1 stack; must adjust for our stackWidth and stackHeight ----
            var stackIndex = this._stackIndexes[recordIndex];
            var zlocalmax = stackWidth * stackHeight;
            var layernum = Math.floor(stackIndex / zlocalmax);
            var layerindex = stackIndex % zlocalmax;
            var xrel = layerindex % stackWidth;
            var yrel = Math.floor(layerindex / stackWidth);
            dr.x = left + (xrel * this._space);
            dr.y = top + (yrel * this._space);
            // var z = -2.0 + (layernum * this._itemHeight * 1.1);
            dr.width = Math.abs(this._itemWidth);
            dr.height = Math.abs(this._itemHeight);
            var stackDepth = this._binDepth;
            if (this._chartOptions.layout == "Cubes") {
                //----- make the shapes as close to cubes as possible ----
                stackDepth = 1.1 * Math.abs(dr.width);
                dr.depth = dr.width;
            }
            else {
                //----- try to make the tallest column fill our z-range (this is the current "Stacks" view) ----
                //---- support for variable size columns (most useful if stackcount=1) ----
                if (nv.size && nv.size.count) {
                    dr.width = dr.width * this.scaleColData(nv.size, recordIndex, dc.scales.size, 1);
                    dr.height = dr.width;
                }
                //---- this keeps the shapes from becomming too distorted, so we don't always fill the space ----
                stackDepth = Math.min(this._binDepth, dr.width);
                dr.depth = .9 * stackDepth;
            }
            dr.z = dc.z + (layernum * stackDepth) + stackDepth / 2;
            dr.colorIndex = this.scaleColData(nv.colorIndex, recordIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, recordIndex, dc.scales.imageIndex);
        };
        return stacksBinClass;
    }(beachParty.baseLayoutClass));
    beachParty.stacksBinClass = stacksBinClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    trueCustom.ts - builds a generalized custom chart from specified parameters.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var trueCustomClass = (function (_super) {
        __extends(trueCustomClass, _super);
        function trueCustomClass(chart) {
            _super.call(this, chart, "trueCustom");
            this._xFacetBinResults = null;
            this._yFacetBinResults = null;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._isFlat = false; // true if no bins are defined 
            //---- for spiral layout ----
            this._radius = 0;
            this._spacing = 0;
            this._center = { x: 0, y: 0 };
            //---- indexed by countKey, holds an array of pts for each bin (produced by bestPoission layout) ----
            this._binPts = {};
            this._binRects = {};
            this._hMargin = 0;
            this._vMargin = 0;
            this._hBetween = 0;
            this._vBetween = 0;
            this._xglobalmax = 1;
            this._yglobalmax = 1;
        }
        /** Adjust scales as needed for our chart. */
        trueCustomClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var cp = this._chart.customParams();
            this._customParams = cp;
            this._layoutName = beachParty.CustomLayout[cp.layout];
            var facetHelper = dc.facetHelper;
            this._xFacetBinResults = [];
            this._yFacetBinResults = [];
            var xm = this._chart.xMapping();
            var ym = this._chart.yMapping();
            var cp = this._customParams;
            this._isFlat = (cp.xUsage != beachParty.CustomColUsage.bin && cp.yUsage != beachParty.CustomColUsage.bin);
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    if (cp.xUsage == beachParty.CustomColUsage.bin) {
                        var xResults = beachParty.chartUtils.binTheDataForCount(dc, data, xm, "x");
                        this._xFacetBinResults.push(xResults);
                    }
                    if (cp.yUsage == beachParty.CustomColUsage.bin) {
                        var yResults = beachParty.chartUtils.binTheDataForCount(dc, data, ym, "y");
                        this._yFacetBinResults.push(yResults);
                    }
                }
            }
            else {
                if (cp.xUsage == beachParty.CustomColUsage.bin) {
                    var xResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, xm, "x");
                    this._xFacetBinResults.push(xResults);
                }
                if (cp.yUsage == beachParty.CustomColUsage.bin) {
                    var yResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, ym, "y");
                    this._yFacetBinResults.push(yResults);
                }
            }
            //---- adjust X scale ----
            if (xResults) {
                dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, [xResults]);
            }
            //---- adjust Y scale ----
            if (yResults) {
                dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, [yResults]);
            }
            var returnValue = dc.filteredRecordCount;
            if (this._layoutName == "Spiral") {
                this._maxCountOverFacets = beachParty.chartUtils.computeMaxCountOverFacets(dc, nvFacetBuckets);
                returnValue = this._maxCountOverFacets;
            }
            return returnValue;
        };
        trueCustomClass.prototype.assignRecordsToBins = function (nv, resultX, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignX = (resultX) ? resultX.assignments : null;
            var allAssignY = (resultY) ? resultY.assignments : null;
            var binIndexesX = [];
            var binIndexesY = [];
            var binRelativeIndexes = [];
            this._binCounts = {}; // will use string as our 3d index   (facet, x, y)
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            for (var i = 0; i < filter.length; i++) {
                var shapeIndex = i; // sri[i];        // process shape indexes, in sorted order
                if (!filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = (allAssignX) ? allAssignX[shapeIndex] : 0;
                    var binIndexY = (allAssignY) ? allAssignY[shapeIndex] : 0;
                    binIndexesX[shapeIndex] = binIndexX;
                    binIndexesY[shapeIndex] = binIndexY;
                    //---- we are called once for each facet, so we don't need that in our countKey anymore ----
                    var countKey = binIndexX + "," + binIndexY;
                    if (this._binCounts[countKey] === undefined) {
                        this._binCounts[countKey] = 0;
                    }
                    //binIndexes[shapeIndex] = binCounts[countKey];
                    this._binCounts[countKey] += 1;
                    var binRelativeIndex = this._binCounts[countKey];
                    binRelativeIndexes[shapeIndex] = binRelativeIndex;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    binIndexesX[shapeIndex] = 0;
                    binIndexesY[shapeIndex] = 0;
                }
            }
            //---- find max # of entries in any bin ----
            var maxCount = 0;
            var keys = vp.utils.keys(this._binCounts);
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var count = this._binCounts[key];
                maxCount = Math.max(count, maxCount);
            }
            var width = dc.width;
            var height = dc.height;
            if (resultX) {
                //---- build an array of the bin names for the xScale labels ----
                var binsX = resultX.bins;
                var binNamesX = [];
                for (var i = 0; i < binsX.length; i++) {
                    binNamesX[i] = binsX[i].name;
                }
            }
            if (resultY) {
                var binsY = resultY.bins;
                var binNamesY = [];
                for (var i = 0; i < binsY.length; i++) {
                    binNamesY[i] = binsY[i].name;
                }
            }
            //---- create bounds ----
            var binLefts = [];
            var binTops = [];
            var left = dc.x + this._hMargin;
            var top = dc.y + this._vMargin + this._itemHeight;
            if (binsX) {
                for (var i = 0; i < binsX.length; i++) {
                    binLefts[i] = left;
                    left += (this._itemWidth + this._hBetween);
                }
            }
            else {
                binLefts[0] = left;
            }
            if (binsY) {
                for (var i = 0; i < binsY.length; i++) {
                    binTops[i] = top;
                    top += (this._itemHeight + this._vBetween);
                }
            }
            else {
                binTops[0] = top;
            }
            this._binLefts = binLefts;
            this._binTops = binTops;
            this._binIndexesX = binIndexesX;
            this._binIndexesY = binIndexesY;
            this._binRelativeIndexes = binRelativeIndexes;
            this.prepLayouts(dc, nv, keys);
            return maxCount;
        };
        trueCustomClass.prototype.prepLayouts = function (dc, nv, keys) {
            //---- poisson/squarify: layout shapes within each bin now ----
            var cp = this._customParams;
            var binPts = {};
            this._binPts = binPts;
            var binRects = {};
            this._binRects = binRects;
            if (cp.layout == beachParty.CustomLayout.poisson) {
                var rc = vp.geom.createRect(0, 0, this._itemWidth, this._itemHeight);
                for (var k = 0; k < keys.length; k++) {
                    var key = keys[k];
                    var count = this._binCounts[key];
                    if (count > 0) {
                        var poisson = new beachParty.bestPoisson();
                        var pts = poisson.layout(rc, count);
                        binPts[key] = pts;
                    }
                }
            }
            else if (cp.layout == beachParty.CustomLayout.squarify) {
                var rc = vp.geom.createRect(0, 0, this._itemWidth, this._itemHeight);
                for (var k = 0; k < keys.length; k++) {
                    var key = keys[k];
                    var count = this._binCounts[key];
                    if (count > 0) {
                        var squarifyLayout = new beachParty.squarifyLayoutClass();
                        var marginBase = dc.width / 5000;
                        if (this._chartBuilder.getFacetHelper()) {
                            marginBase *= 5;
                        }
                        var cellMargin = this._chart.separationFactor() * marginBase;
                        var xVector = nv.x.values;
                        var cellArray = squarifyLayout.layout(xVector, rc, cellMargin);
                        var rects = cellArray.map(function (d) { return d.rect; });
                        binRects[key] = rects;
                    }
                }
            }
            //---- set the type of layout now (so we don't have to cacl it each time in layoutRecord) ----
            var layoutFunc = null;
            if (cp.layout == beachParty.CustomLayout.grid) {
                layoutFunc = this.gridLayout;
            }
            else if (cp.layout == beachParty.CustomLayout.map) {
                layoutFunc = this.mapLayout;
            }
            else if (cp.layout == beachParty.CustomLayout.radial) {
                layoutFunc = this.radialLayout;
            }
            else if (cp.layout == beachParty.CustomLayout.random) {
                layoutFunc = this.randomLayout;
            }
            else if (cp.layout == beachParty.CustomLayout.poisson) {
                layoutFunc = this.poissonLayout;
            }
            else if (cp.layout == beachParty.CustomLayout.squarify) {
                layoutFunc = this.squarifyLayout;
            }
            else if (cp.layout == beachParty.CustomLayout.spiral) {
                layoutFunc = this.spiralLayout;
            }
            this._layoutFunc = layoutFunc;
        };
        trueCustomClass.prototype.preLayoutLoop = function (dc) {
            var options = this._chartOptions;
            var nv = dc.nvData;
            //---- use pre-computed bins ----
            var xResult = (this._xFacetBinResults.length) ? this._xFacetBinResults[dc.facetIndex] : null;
            var yResult = (this._yFacetBinResults.length) ? this._yFacetBinResults[dc.facetIndex] : null;
            var xBinCount = (xResult) ? xResult.bins.length : 1;
            var yBinCount = (yResult) ? yResult.bins.length : 1;
            var width = dc.width;
            var height = dc.height;
            var hMargin = 2 * dc.itemSize;
            var hBetween = .1 * (dc.width / xBinCount);
            var vMargin = 2 * dc.itemSize;
            var vBetween = .2 * (dc.height / yBinCount);
            this._hMargin = hMargin;
            this._hBetween = hBetween;
            this._vMargin = vMargin;
            this._vBetween = vBetween;
            //---- compute itemWidth and itemHeight ----
            var itemWidth = (width - 2 * hMargin - (xBinCount - 1) * hBetween) / xBinCount;
            var itemHeight = (height - 2 * vMargin - (yBinCount - 1) * vBetween) / yBinCount;
            var ySpace = .1 * itemHeight;
            var binHeight = itemHeight - ySpace;
            this._itemWidth = itemWidth;
            this._itemHeight = itemHeight;
            var maxRecordsInABin = this.assignRecordsToBins(nv, xResult, yResult, dc);
            this._maxCount = maxRecordsInABin;
            var rcBin = vp.geom.createRect(this._binLefts[0], this._binTops[0], this._itemWidth, this._itemHeight);
            this._xglobalmax = Math.max(Math.ceil(Math.sqrt(this._maxCount)), 1);
            this._yglobalmax = Math.max(Math.ceil(this._maxCount / this._xglobalmax), 1);
            this._xspace = this._itemWidth / (this._xglobalmax);
            this._yspace = this._itemHeight / (this._yglobalmax);
            this._space = Math.min(this._xspace, this._yspace);
            var maxShapeSize = Math.min(.85 * this._itemWidth / this._xglobalmax, .85 * this._itemHeight / this._yglobalmax);
            this._maxShapeSize = maxShapeSize; //   / dc.transformSizeFactor;
            var margin = 2 * dc.maxShapeSize; //   dc.itemSize;
            var xSize = dc.width - (margin);
            var ySize = dc.height - (margin);
            var cp = this._customParams;
            if (cp.layout == beachParty.CustomLayout.spiral) {
                //---- for spiral layout ----
                this._maxCount = dc.filteredRecordCount;
                this._radius = Math.min(xSize, ySize);
                this._spacing = .5 * this._radius / Math.sqrt(this._maxCount);
                this._nextIndex = 0;
                this._center.x = dc.x + dc.width / 2;
                this._center.y = dc.y + dc.height / 2;
                this._maxShapeSize = beachParty.chartUtils.getScatterShapeSize(dc, this._maxCountOverFacets, this._chart);
            }
        };
        trueCustomClass.prototype.mapLayout = function (recordIndex, dc, dr, left, top, width, height) {
            var nv = dc.nvData;
            var cp = this._customParams;
            if (cp.xUsage == beachParty.CustomColUsage.map) {
                dr.x = this.scaleColData(nv.x, recordIndex, dc.scales.x);
            }
            if (cp.yUsage == beachParty.CustomColUsage.map) {
                dr.y = this.scaleColData(nv.y, recordIndex, dc.scales.y);
            }
            if (cp.zUsage == beachParty.CustomColUsage.map) {
                dr.z = this.scaleColData(nv.z, recordIndex, dc.scales.z);
            }
        };
        trueCustomClass.prototype.radialLayout = function (recordIndex, dc, dr, left, top, width, height) {
            var nv = dc.nvData;
            var theta = -(Math.PI / 2 + this.scaleColData(nv.x, recordIndex, dc.scales.x));
            var radius = this.scaleColData(nv.y, recordIndex, dc.scales.y);
            //---- cx and cy are the center of the bin that this shape belongs to ----
            var cx = left + this._itemWidth / 2;
            var cy = top - this._itemHeight / 2;
            dr.x = cx + radius * Math.cos(theta);
            dr.y = cy + radius * Math.sin(theta);
        };
        trueCustomClass.prototype.spiralLayout = function (recordIndex, dc, dr, left, top, width, height) {
            var nv = dc.nvData;
            var sp = this._chart.spiralParams();
            var filtered = (dc.layoutFilterVector && dc.layoutFilterVector[recordIndex]);
            var rowIndex = 0;
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            //---- filtered code can calc stuff here, but it will not be used ----
            var cx = this._center.x;
            var cy = this._center.y;
            var r = this._spacing * Math.sqrt(rowIndex);
            var theta = Math.PI / 180 * (rowIndex * sp.seed);
            dr.x = cx + r * Math.sin(theta);
            dr.y = cy + r * Math.cos(theta);
        };
        trueCustomClass.prototype.randomLayout = function (recordIndex, dc, dr, left, top, width, height) {
            var nv = dc.nvData;
            dr.x = left + width * nv.randomX.values[recordIndex];
            dr.y = top - height * nv.randomY.values[recordIndex];
        };
        trueCustomClass.prototype.squarifyLayout = function (recordIndex, dc, dr, left, top, width, height) {
            var binRelativeIndex = this._binRelativeIndexes[recordIndex] - 1;
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var countKey = binIndexX + "," + binIndexY;
            var rects = this._binRects[countKey];
            var rc = rects[binRelativeIndex];
            dr.x = left + rc.left - rc.width / 2;
            dr.y = top - rc.top + rc.height / 2;
            dr.width = 3 * rc.width;
            dr.height = 3 * rc.height;
        };
        trueCustomClass.prototype.poissonLayout = function (recordIndex, dc, dr, left, top, width, height) {
            var binRelativeIndex = this._binRelativeIndexes[recordIndex] - 1;
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var countKey = binIndexX + "," + binIndexY;
            var pts = this._binPts[countKey];
            var pt = pts[binRelativeIndex];
            dr.x = left + pt[0];
            dr.y = top - pt[1];
        };
        trueCustomClass.prototype.gridLayout = function (recordIndex, dc, dr, left, top, width, height) {
            var binRelativeIndex = this._binRelativeIndexes[recordIndex] - 1;
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var countKey = binIndexX + "," + binIndexY;
            var binCount = 0;
            if (this._binCounts[countKey] === undefined) {
                binCount = 0;
            }
            else {
                binCount = this._binCounts[countKey];
            }
            var xlocalmax = Math.max(Math.ceil(Math.sqrt(binCount)), 1);
            var ylocalmax = Math.max(Math.ceil(binCount / xlocalmax), 1);
            var maxWidth = xlocalmax * this._space;
            var maxHeight = ylocalmax * this._space;
            var xrel = binRelativeIndex % xlocalmax;
            var yrel = Math.floor(binRelativeIndex / xlocalmax);
            //---- cx and cy are the center of the bin that this shape belongs to ----
            var cx = left + this._itemWidth / 2;
            var cy = top - this._itemHeight / 2;
            dr.x = cx - maxWidth / 2.0 + xrel * this._space;
            dr.y = cy + maxHeight / 2.0 - yrel * this._space;
        };
        trueCustomClass.prototype.layoutDataForRecord = function (recordIndex, dc, dr) {
            var nv = dc.nvData;
            var rowIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[recordIndex]);
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var left = this._binLefts[binIndexX];
            var top = this._binTops[binIndexY];
            //---- predefine with defaults ----
            dr.x = 0;
            dr.y = 0;
            dr.z = 0;
            dr.width = this._maxShapeSize;
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, recordIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, recordIndex, dc.scales.imageIndex);
            //---- let layout override defaults it cares about ----
            this._layoutFunc(recordIndex, dc, dr, left, top, this._itemWidth, this._itemHeight);
        };
        return trueCustomClass;
    }(beachParty.baseLayoutClass));
    beachParty.trueCustomClass = trueCustomClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    sandViolin.ts - builds a unit violin plot (2D histogram, with variable width, with RANDOM layout within each heatmap tile). 
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var violinClass = (function (_super) {
        __extends(violinClass, _super);
        //_chartOptions = new sandDensityOptions(5, 5, "Circle");
        function violinClass(chart) {
            _super.call(this, chart, "violin");
            //---- all facet results ----
            this._xFacetBinResults = null;
            this._yFacetBinResults = null;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._xSpacing = 0;
            this._ySpacing = 0;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "xy";
        }
        /** Adjust scales as needed for our chart. */
        violinClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._xFacetBinResults = [];
            this._yFacetBinResults = [];
            var xm = this._chart.xMapping();
            var ym = this._chart.yMapping();
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for CONSISTENT facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
                beachParty.chartUtils.setFilteredMinMaxBreak(ym, dc.layoutFilterVector, dc.nvData.y);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var xResults = beachParty.chartUtils.binTheDataForCount(dc, data, xm, "x");
                    this._xFacetBinResults.push(xResults);
                    var yResults = beachParty.chartUtils.binTheDataForCount(dc, data, ym, "y");
                    this._yFacetBinResults.push(yResults);
                }
            }
            else {
                var xResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, xm, "x");
                this._xFacetBinResults.push(xResults);
                var yResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, ym, "y");
                this._yFacetBinResults.push(yResults);
            }
            this.adjustScales(dc);
            return dc.filteredRecordCount;
        };
        violinClass.prototype.adjustScales = function (dc) {
            //---- adjust X scale ----
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, [this._xFacetBinResults[0]]);
            //---- adjust Y scale ----
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, [this._yFacetBinResults[0]]);
        };
        violinClass.prototype.assignRecordsToBins = function (nv, resultX, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignX = resultX.assignments;
            var allAssignY = resultY.assignments;
            var binIndexesX = [];
            var binIndexesY = [];
            var binCounts = {}; // will use string as our 3d index   (facet, x, y)
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            var lastFacetIndex = 0;
            for (var i = 0; i < filter.length; i++) {
                var shapeIndex = i; // sri[i];        // process shape indexes, in sorted order
                if (!filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = allAssignX[shapeIndex];
                    var binIndexY = allAssignY[shapeIndex];
                    binIndexesX[shapeIndex] = binIndexX;
                    binIndexesY[shapeIndex] = binIndexY;
                    if (facetAssignments) {
                        var facetIndex = facetAssignments[shapeIndex];
                        if (i == 0) {
                            lastFacetIndex = facetIndex;
                        }
                        else {
                            if (facetIndex != lastFacetIndex) {
                                vp.utils.debug("----> ERROR: facetIndex changed");
                            }
                        }
                    }
                    //---- update bin COUNTS ----
                    //---- we are called once for each facet, so we don't need that in our countKey anymore ----
                    var countKey = binIndexX + "," + binIndexY;
                    if (binCounts[countKey] === undefined) {
                        binCounts[countKey] = 0;
                    }
                    binCounts[countKey] += 1;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    binIndexesX[shapeIndex] = 0;
                    binIndexesY[shapeIndex] = 0;
                }
            }
            //---- find max # of entries in any bin ----
            var maxCount = 0;
            var keys = vp.utils.keys(binCounts);
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var count = binCounts[key];
                maxCount = Math.max(count, maxCount);
            }
            var width = dc.width;
            var height = dc.height;
            var binsX = resultX.bins;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            //---- create bounds for each bin ----
            var binLefts = [];
            var binTops = [];
            var binWidths = [];
            //---- compute binLefts[] ----
            var left = dc.x + (this._xSpacing / 2);
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += this._boxWidth;
            }
            //---- compute binTops[] ----
            var top = dc.y + this._boxHeight - (this._ySpacing / 2);
            for (var i = 0; i < binsY.length; i++) {
                binTops[i] = top;
                top += this._boxHeight;
            }
            //---- compute binWidths[] ----
            for (var i = 0; i < binsX.length; i++) {
                for (var j = 0; j < binsY.length; j++) {
                    //---- compute width of this bin ----
                    var countKey = i + "," + j;
                    var count = binCounts[countKey];
                    if (count === undefined) {
                        count = 0;
                    }
                    var binWidth = vp.data.mapValue(count, 0, maxCount, 0, this._maxBinWidth);
                    binWidths[countKey] = binWidth;
                }
            }
            this._binLefts = binLefts;
            this._binTops = binTops;
            this._binWidths = binWidths;
            this._binIndexesX = binIndexesX;
            this._binIndexesY = binIndexesY;
            return maxCount;
        };
        violinClass.prototype.preLayoutLoop = function (dc) {
            var options = this._chartOptions;
            var nv = dc.nvData;
            //---- use pre-computed bins ----
            var xResult = this._xFacetBinResults[dc.facetIndex];
            var yResult = this._yFacetBinResults[dc.facetIndex];
            var xBinCount = xResult.bins.length;
            var yBinCount = yResult.bins.length;
            var xSpacing = .02 * dc.height;
            var ySpacing = .02 * dc.height;
            //---- compute itemWidth and itemHeight ----
            var boxWidth = dc.width / xBinCount;
            var boxHeight = dc.height / yBinCount;
            var itemWidth = Math.max(0, boxWidth - xSpacing);
            var itemHeight = Math.max(0, boxHeight - ySpacing);
            this._xSpacing = xSpacing;
            this._maxBinWidth = itemWidth;
            this._boxWidth = boxWidth;
            this._ySpacing = ySpacing;
            this._binHeight = itemHeight;
            this._boxHeight = boxHeight;
            var maxRecordsInABin = this.assignRecordsToBins(nv, xResult, yResult, dc);
        };
        violinClass.prototype.layoutDataForRecord = function (recordIndex, dc, dr) {
            var nv = dc.nvData;
            var filtered = (dc.layoutFilterVector && dc.layoutFilterVector[recordIndex]);
            var rowIndex = 0;
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var left = this._binLefts[binIndexX];
            var top = this._binTops[binIndexY];
            var xr = nv.randomX.values[recordIndex];
            var yr = nv.randomY.values[recordIndex];
            var countKey = binIndexX + "," + binIndexY;
            var binWidth = this._binWidths[countKey];
            var innerLeft = left + (this._maxBinWidth / 2) - (binWidth / 2);
            dr.x = innerLeft + (xr * binWidth);
            dr.y = top - (yr * this._binHeight);
            dr.z = 0;
            dr.width = dc.maxShapeSize * this.scaleColData(nv.size, recordIndex, dc.scales.size, 1);
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, recordIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, recordIndex, dc.scales.imageIndex);
        };
        return violinClass;
    }(beachParty.baseLayoutClass));
    beachParty.violinClass = violinClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    xBand.ts - builds a horizontal rug plot (a 1D scatterplot)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var xBandClass = (function (_super) {
        __extends(xBandClass, _super);
        function xBandClass(chart) {
            _super.call(this, chart, "xBand");
            this._maxShapeSize = 0;
            this._halfSizeSize = 0;
            this._z = 0;
            this._visibleColPickers = "x";
            this._visibleBinAdjusters = "";
            this._chartBuilder.hideAxes("y");
        }
        xBandClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            //---- this call modifies the PREPASS scales (for use by the chart frame) ----
            this.modifyXYScales(dc);
            return dc.filteredRecordCount;
        };
        xBandClass.prototype.modifyXYScales = function (dc, halfShapeSize) {
            //---- add spacing on both sides of X and Y scales to keep shapes within the borders ----
            if (!halfShapeSize) {
                halfShapeSize = (dc.maxShapeSize / 2); //  * dc.transformSizeFactor;       //  dc.combinedSizeFactor;
            }
            //---- note: expandSpace() for scale in specifed in range units (world units, in this case) ----
            dc.scales.x
                .expandSpace(halfShapeSize);
            dc.scales.y
                .expandSpace(halfShapeSize);
            this._halfSizeSize = halfShapeSize;
        };
        xBandClass.prototype.preLayoutLoop = function (dc) {
            //---- this call modifies the FINAL scales (for use by our X/Y mapping) ----
            this.modifyXYScales(dc, this._halfSizeSize);
            this._maxShapeSize = dc.maxShapeSize;
            //---- place our 2D place in middle of Z space ----
            this._z = dc.z + dc.depth / 2;
        };
        /** "bufferIndex" in the 0-based indexed into the sorted data buffers. */
        xBandClass.prototype.layoutDataForRecord = function (bufferIndex, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            dr.x = this.scaleColData(nv.x, bufferIndex, scales.x);
            dr.y = 0;
            dr.z = this._z; // for correct rotation about Y axis
            var usingShape = (this._chart.shapeImage() != "none");
            if (usingShape) {
                dr.height = this._maxShapeSize * this.scaleColData(nv.size, bufferIndex, scales.size, 1);
                dr.width = dr.height;
            }
            else {
                dr.height = 30 * this._maxShapeSize;
                dr.width = .1 * this._maxShapeSize;
            }
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, bufferIndex, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, bufferIndex, dc.scales.imageIndex);
        };
        return xBandClass;
    }(beachParty.baseLayoutClass));
    beachParty.xBandClass = xBandClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    yBand.ts - builds a vertical rug plot (a 1D scatterplot)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var yBandClass = (function (_super) {
        __extends(yBandClass, _super);
        function yBandClass(chart) {
            _super.call(this, chart, "yBand");
            this._maxShapeSize = 0;
            this._halfSizeSize = 0;
            this._z = 0;
            this._visibleColPickers = "y";
            this._visibleBinAdjusters = "";
            this._chartBuilder.hideAxes("x");
        }
        yBandClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            //---- this call modifies the PREPASS scales (for use by the chart frame) ----
            this.modifyXYScales(dc);
            return dc.filteredRecordCount;
        };
        yBandClass.prototype.modifyXYScales = function (dc, halfShapeSize) {
            //---- add spacing on both sides of X and Y scales to keep shapes within the borders ----
            if (!halfShapeSize) {
                halfShapeSize = (dc.maxShapeSize / 2); //  * dc.transformSizeFactor;       //  dc.combinedSizeFactor;
            }
            //---- note: expandSpace() for scale in specifed in range units (world units, in this case) ----
            dc.scales.x
                .expandSpace(halfShapeSize);
            dc.scales.y
                .expandSpace(halfShapeSize);
            this._halfSizeSize = halfShapeSize;
        };
        yBandClass.prototype.preLayoutLoop = function (dc) {
            //---- this call modifies the FINAL scales (for use by our X/Y mapping) ----
            this.modifyXYScales(dc, this._halfSizeSize);
            this._maxShapeSize = dc.maxShapeSize;
            //---- place our 2D place in middle of Z space ----
            this._z = dc.z + dc.depth / 2;
        };
        /** "bufferIndex" in the 0-based indexed into the sorted data buffers. */
        yBandClass.prototype.layoutDataForRecord = function (bufferIndex, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            dr.x = 0;
            dr.y = this.scaleColData(nv.y, bufferIndex, scales.y);
            dr.z = this._z; // for correct rotation about Y axis
            var usingShape = (this._chart.shapeImage() != "none");
            if (usingShape) {
                dr.height = this._maxShapeSize * this.scaleColData(nv.size, bufferIndex, scales.size, 1);
                dr.width = dr.height;
            }
            else {
                dr.width = 30 * this._maxShapeSize;
                dr.height = .1 * this._maxShapeSize;
            }
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, bufferIndex, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, bufferIndex, dc.scales.imageIndex);
        };
        return yBandClass;
    }(beachParty.baseLayoutClass));
    beachParty.yBandClass = yBandClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    bestPoisson.ts - does "best candidate" algorithm using a high resolution hit testing grid.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var bestCache = {}; // caches pts for layout consistency between changes
    var bestPoisson = (function () {
        function bestPoisson() {
        }
        bestPoisson.prototype.distSquared = function (p1, p2) {
            var dx = p1[0] - p2[0];
            var dy = p1[1] - p2[1];
            var dist = dx * dx + dy * dy;
            return dist;
        };
        /** if any points in cellPts are closer to pt than minDist, return that new minDist. */
        bestPoisson.prototype.checkCellPoints = function (minDist, pt, cellPts) {
            for (var i = 0; i < cellPts.length; i++) {
                var cellPt = cellPts[i];
                var dist = this.distSquared(pt, cellPt);
                if (dist < minDist) {
                    minDist = dist;
                }
            }
            return minDist;
        };
        bestPoisson.prototype.checkGrid = function (minDist, pt, r, c) {
            //vp.utils.debug("checkGrid: x=" + pt[0] + ", y=" + pt[1] + ", r=" + r + ", c=" + c);
            if (r >= 0 && r < this.grid.length) {
                var row = this.grid[r];
                if (c >= 0 && c < row.length) {
                    var cellPts = row[c];
                    if (cellPts.length) {
                        minDist = this.checkCellPoints(minDist, pt, cellPts);
                    }
                }
            }
            return minDist;
        };
        /** returns the DIST between pt and closest of points in grid/pts. */
        bestPoisson.prototype.findClosest = function (pts, pt) {
            var minDist = Number.MAX_VALUE;
            var col = Math.floor((pt[0] - this.rc.left) / this.cellWidth);
            var row = Math.floor((pt[1] - this.rc.top) / this.cellHeight);
            minDist = this.checkGrid(minDist, pt, row - 1, col - 1);
            minDist = this.checkGrid(minDist, pt, row - 1, col);
            minDist = this.checkGrid(minDist, pt, row - 1, col + 1);
            minDist = this.checkGrid(minDist, pt, row, col - 1);
            minDist = this.checkGrid(minDist, pt, row, col);
            minDist = this.checkGrid(minDist, pt, row, col + 1);
            minDist = this.checkGrid(minDist, pt, row + 1, col - 1);
            minDist = this.checkGrid(minDist, pt, row + 1, col);
            minDist = this.checkGrid(minDist, pt, row + 1, col + 1);
            return minDist;
        };
        bestPoisson.prototype.findBestPoissonCandidate = function (pts, rc, maxSamples, grid) {
            var bestPt = null;
            var bestDist = 0;
            var width = rc.width;
            var height = rc.height;
            for (var i = 0; i < maxSamples; i++) {
                var pt = [rc.left + width * Math.random(), rc.top + height * Math.random()];
                var dist = this.findClosest(pts, pt);
                if (i == 0 || dist > bestDist) {
                    bestPt = pt;
                    bestDist = dist;
                }
            }
            return bestPt;
        };
        bestPoisson.prototype.makeGrid = function (rowCount, colCount) {
            var grid = [];
            for (var r = 0; r < rowCount; r++) {
                var row = [];
                grid[r] = row;
                for (var c = 0; c < colCount; c++) {
                    row[c] = [];
                }
            }
            return grid;
        };
        bestPoisson.prototype.layout = function (rc, count, maxSamples) {
            if (maxSamples === void 0) { maxSamples = 30; }
            var pts = [];
            if (count && rc && rc.width > 0 && rc.height > 0) {
                var cacheKey = rc.left + "," + rc.top + "," + rc.width + "," + rc.height + "," + count;
                if (bestCache[cacheKey]) {
                    pts = bestCache[cacheKey];
                }
                else {
                    //---- compute cell size, for hit-testing points ----
                    var aspect = rc.width / rc.height;
                    //var cellWidth = aspect * Math.sqrt(count);
                    //var cellHeight = count / cellWidth;
                    var colCount = Math.ceil(Math.sqrt(aspect * count));
                    var rowCount = Math.ceil(count / colCount);
                    var cellWidth = rc.width / colCount;
                    var cellHeight = rc.height / rowCount;
                    //---- make them so small, they can only hold max of 1 optimially distributed points ----
                    //cellWidth /= 10;
                    //cellHeight /= 10;
                    //---- make cells bigger so that checking neighbor will check 2-3 sizes bigger than optimally distributed points ----
                    //---- FACTOR is critical for perf: the lower the factor, the smaller the avg count of a grid cell & the faster we can check a candidate. ----
                    //---- FACTOR is critical for quality of layout - if it is too small, local clumping results. ----
                    var exp3 = Math.max(.1, Math.log10(count) - 3);
                    var factor = 1 / (10 * exp3);
                    cellWidth *= factor;
                    cellHeight *= factor;
                    var colCount = Math.ceil(rc.width / cellWidth);
                    var rowCount = Math.ceil(rc.height / cellHeight);
                    var grid = this.makeGrid(rowCount, colCount);
                    //---- update this vars ----
                    this.cellHeight = cellHeight;
                    this.cellWidth = cellWidth;
                    this.grid = grid;
                    this.rc = rc;
                    for (var i = 0; i < count; i++) {
                        var pt = this.findBestPoissonCandidate(pts, rc, maxSamples, grid);
                        //---- add to grid ----
                        var col = Math.floor((pt[0] - this.rc.left) / this.cellWidth);
                        var row = Math.floor((pt[1] - this.rc.top) / this.cellHeight);
                        grid[row][col].push(pt);
                        pts.push(pt);
                    }
                    //---- calculate the avg grid cell count ----
                    var entryCouint = 0;
                    var cellCount = 0;
                    for (var i = 0; i < rowCount; i++) {
                        var rr = grid[i];
                        for (var c = 0; c < colCount; c++) {
                            var cells = rr[c];
                            entryCouint += cells.length;
                            cellCount++;
                        }
                    }
                    this.avgCellCount = entryCouint / cellCount;
                }
                bestCache[cacheKey] = pts;
            }
            return pts;
        };
        return bestPoisson;
    }());
    beachParty.bestPoisson = bestPoisson;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    choropletHelper.ts - helps read & process shapes from geoJSON files.
//-------------------------------------------------------------------------------------
//var mediumSales: any[];
var beachParty;
(function (beachParty) {
    var choroplethHelper = (function () {
        function choroplethHelper() {
        }
        choroplethHelper.atBottom = function (coords) {
            var firstEntry = coords[0];
            var bottom = ((firstEntry.length == 2) && (!isNaN(firstEntry[0])));
            return bottom;
        };
        choroplethHelper.buildPath = function (rc, ranges, coords) {
            var linePath = "";
            for (var a = 0; a < coords.length; a++) {
                var coordA = coords[a];
                var atBottom = this.atBottom(coordA);
                if (atBottom) {
                    linePath = this.makePathPart(rc, linePath, coordA, ranges);
                }
                else {
                    for (var b = 0; b < coordA.length; b++) {
                        var coorB = coordA[b];
                        linePath = this.makePathPart(rc, linePath, coorB, ranges);
                    }
                }
            }
            //vp.utils.debug("buildPath: linePath=" + linePath);
            return linePath;
        };
        choroplethHelper.makePathPart = function (rc, linePath, coords, ranges) {
            linePath += "M ";
            for (var c = 0; c < coords.length; c++) {
                var coord = coords[c];
                var x = coord[0];
                var y = coord[1];
                var xScaled = vp.data.mapValue(x, ranges.xMin, ranges.xMax, rc.left, rc.right);
                var yScaled = vp.data.mapValue(y, ranges.yMin, ranges.yMax, rc.bottom, rc.top);
                if (c == 1) {
                    linePath += "L ";
                }
                linePath += xScaled + "," + yScaled + " ";
            }
            return linePath;
        };
        choroplethHelper.computeXYRange = function (ranges, coords) {
            for (var a = 0; a < coords.length; a++) {
                var coordA = coords[a];
                var atBottom = this.atBottom(coordA);
                if (atBottom) {
                    this.computeXYRangeEx(ranges, coordA);
                }
                else {
                    for (var b = 0; b < coordA.length; b++) {
                        var coorB = coordA[b];
                        this.computeXYRangeEx(ranges, coorB);
                    }
                }
            }
        };
        choroplethHelper.computeXYRangeEx = function (ranges, coords) {
            for (var g = 0; g < coords.length; g++) {
                var coord = coords[g];
                var x = coord[0];
                var y = coord[1];
                if (isNaN(x) || isNaN(y)) {
                    vp.utils.debug("NAN found: x=" + x + ", y=" + y);
                }
                ranges.xMin = Math.min(x, ranges.xMin);
                ranges.xMax = Math.max(x, ranges.xMax);
                ranges.yMin = Math.min(y, ranges.yMin);
                ranges.yMax = Math.max(y, ranges.yMax);
            }
        };
        choroplethHelper.getShapeCoords = function (geoJson, shapeName) {
            var features = geoJson.features;
            for (var i = 0; i < features.length; i++) {
                var feature = features[i];
                if (feature.properties.NAME == shapeName) {
                    var coords = feature.geometry.coordinates;
                    break;
                }
            }
            return coords;
        };
        choroplethHelper.getShapeCoordsByIndex = function (geoJson, index) {
            var feature = geoJson.features[index];
            var coords = null;
            if (feature) {
                var name = feature.properties.NAME;
                var coords = feature.geometry.coordinates;
                coords.name = name;
            }
            return coords;
        };
        return choroplethHelper;
    }());
    beachParty.choroplethHelper = choroplethHelper;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// colorPalettes.ts.
///     - A thin TypeScript wrapper for [the third party code] colorbrewer_schemes.js [lightly modified]
///      plus some of our own helper methods.
///-----------------------------------------------------------------------------------------------------------------
/*
-------------------------------------------------------------- START OF THIRD PARTY NOTICE ------------------------------------------------------------------------
This file is based on or incorporates material from the projects listed below (collectively, "Third Party Code"). Microsoft is not the original author of the Third Party Code.
The original copyright notice and the license under which Microsoft received such Third Party Code, are set forth below.
Such licenses and notices are provided for informational purposes only.
Microsoft licenses the Third Party Code to you under the terms set forth in the EULA for the Microsoft Product.
Microsoft reserves all other rights not expressly granted under this agreement, whether by implication, estoppel or otherwise.

jeanlauliac-colorbrewer
Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The Pennsylvania State University.
Provided for Informational Purposes Only
Apache 2.0 License
Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions and limitations under the License.
----------------------------------------------------------- END OF THIRD PARTY NOTICE -----------------------------------------------------------------------------
*/
/*
 * This product includes color specifications and designs developed by Cynthia
 * Brewer (http://colorbrewer.org/).  https://groups.google.com/forum/?fromgroups=#!topic/d3-js/iyXFgJR1JY0
 */
var beachParty;
(function (beachParty) {
    var colorPalettesClass = (function () {
        function colorPalettesClass() {
        }
        colorPalettesClass.getColorSchemeNames = function (colorSchemeType) {
            var colorSchemes = colorPalettesClass.colorBrewerSchemes; // For shorthand
            var colorSchemeNames = [];
            switch (colorSchemeType) {
                case "sequential":
                    colorSchemeNames = colorSchemes.sequentialColorSchemes;
                    break;
                case "diverging":
                    colorSchemeNames = colorSchemes.divergingColorSchemes;
                    break;
                case "qualitative":
                    colorSchemeNames = colorSchemes.qualitativeColorSchemes;
                    break;
                case "custom":
                    colorSchemeNames = colorSchemes.customColorSchemes;
                    break;
                default:
                    throw "Unknown colorSchemeType '" + colorSchemeType + "'";
            }
            return (colorSchemeNames);
        };
        colorPalettesClass.getColorSchemeByName = function (colorSchemeName) {
            var colorSchemes = colorPalettesClass.colorBrewerSchemes; // For shorthand
            if (colorSchemes[colorSchemeName] != null) {
                return (colorSchemes[colorSchemeName]);
            }
            else {
                throw "Unknown colorSchemeName '" + colorSchemeName + "'";
            }
        };
        colorPalettesClass.getColorPaletteTypeFromName = function (paletteName) {
            var classes = ["sequential", "diverging", "qualitative", "custom"];
            var ptn = null;
            for (var i = 0; i < classes.length; i++) {
                var className = classes[i];
                var names = this.getColorSchemeNames(className);
                if (names.indexOf(paletteName) > -1) {
                    ptn = className;
                    break;
                }
            }
            return ptn;
        };
        colorPalettesClass.getPaletteFromSettings = function (colorSchemeName, numSteps, reverse, invertColors) {
            var palette = null;
            var scheme = this.getColorSchemeByName(colorSchemeName);
            //var scheme = colorPalettesClass.getPalettesFromColorScheme(colorSchemeName, i, reverse);
            if (scheme) {
                //---- build scheme array, so we can call getPaletteFromSteps() ----
                var schemeArray = [];
                var keys = vp.utils.keys(scheme);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var value = scheme[key];
                    schemeArray.push(value);
                }
                palette = this.getPaletteFromSteps(colorSchemeName, schemeArray, numSteps);
                /// palettes in this class are defined from LIGHT to DARK but clients expect them as DARK to LIGHT, so we 
                /// reverse the requested orders.  
                reverse = (!reverse);
                if (palette) {
                    if (reverse) {
                        palette = vp.utils.copyArray(palette).reverse();
                    }
                    if (invertColors) {
                        palette = vp.utils.copyArray(palette);
                        for (var i = 0; i < palette.length; i++) {
                            var cr = palette[i];
                            palette[i] = colorPalettesClass.invertThisColor(cr);
                        }
                    }
                }
            }
            return palette;
        };
        colorPalettesClass.invertThisColor = function (cr) {
            var rgbArray = vp.color.getColorFromString(cr);
            //---- invert the color components for this color ----
            for (var c = 0; c < 3; c++) {
                rgbArray[c] = 255 - rgbArray[c];
            }
            //---- convert back to color string ----
            var newCr = vp.color.toColor(rgbArray);
            return newCr;
        };
        // Qualitative schemes are special in that they don't all contain the same number of palettes:
        //   4 schemes contain palettes with 2 to 8 colors
        //   2 schemes contain palettes with 2 to 9 colors
        //   2 schemes contain palettes with 2 to 12 colors
        // Consequently when we display Qualitative schemes sometime we show all 8 schemes (if we need up to 8 colors), sometimes
        // we show 4 schemes (if we need up to 9 colors), and sometimes we only show 2 schemes (if we need up to 12 colors).
        // So when a selection is made we only have the RELATIVE scheme index (eg. "the 3rd qualitative scheme with 9 colors").
        // This method provides a way to convert the relative scheme index into an ABSOLUTE scheme index.
        colorPalettesClass.getQualitativeColorSchemeIndex = function (relativeSchemeIndex, numColors) {
            var colorSchemeNames = colorPalettesClass.getColorSchemeNames("qualitative");
            var countOfSchemesWithRequiredNumberOfColors = 0;
            for (var i = 0; i < colorSchemeNames.length; i++) {
                var colorSchemeName = colorSchemeNames[i];
                var colorScheme = colorPalettesClass.getColorSchemeByName(colorSchemeName);
                if (colorScheme[numColors] || (numColors == 1)) {
                    if (countOfSchemesWithRequiredNumberOfColors == relativeSchemeIndex) {
                        return (i);
                    }
                    countOfSchemesWithRequiredNumberOfColors++;
                }
            }
            throw "Unable to find the absolute scheme index for relative index " + relativeSchemeIndex + " in 'Qualitative' schemes containing " + numColors + " colors";
        };
        // Makes an array of SandDance palettes using ALL the schemes of type "qualitative", but including only those schemes that contain a palette with numQualitativeColors.
        // Note: A SandDance palette is an array of [r,g,b] color arrays.
        colorPalettesClass.getQualitativePalettes = function (numQualitativeColors, reverseColors, invertColors) {
            return (colorPalettesClass.getPalettesFromColorSchemeType("qualitative", numQualitativeColors, reverseColors, invertColors));
        };
        colorPalettesClass.getPaletteFromSteps = function (paletteName, scheme, stepsRequested) {
            var palette = [];
            if (stepsRequested == 1) {
                // Palette[0] has 2 colors, so if only one color is desired then we create a single-color SandDance palette using the first color of Palette[0]
                var schemeIndex = (scheme.length > 1) ? 1 : 0;
                palette.push(scheme[schemeIndex][0]);
            }
            else if (stepsRequested == 2 && scheme.length > 1) {
                // Palette[1] has 3 colors; use first and last.  Don't use Palette[0] - it was built incorrectly.
                var schemeIndex = (scheme.length > 1) ? 1 : 0;
                palette.push(scheme[schemeIndex][0]);
                palette.push(scheme[schemeIndex][2]);
            }
            else {
                var maxColorsInPaletteArray = scheme.length + 1;
                var stepCount = Math.min(maxColorsInPaletteArray, stepsRequested);
                palette = scheme[stepCount - 2]; // Palette[0] has 2 colors   
            }
            palette.name = paletteName;
            return palette;
        };
        // Makes an array of SandDance palettes using ALL the schemes of the specified type, but including only those schemes that contain a palette with numDesiredColors.
        // Note: A SandDance palette is an array of [r,g,b] color arrays.
        colorPalettesClass.getPalettesFromColorSchemeType = function (colorSchemeType, numDesiredColors, reverseColors, invertColors) {
            var colorSchemeNames = colorPalettesClass.getColorSchemeNames(colorSchemeType);
            var palettes = [];
            if (numDesiredColors < 1) {
                throw "The specified number of desired colors must be at least 1";
            }
            for (var i = 0; i < colorSchemeNames.length; i++) {
                var name = colorSchemeNames[i];
                var candidatePaletteArray = colorPalettesClass.getPalettesFromColorScheme(colorSchemeType, i, reverseColors, invertColors);
                var maxColorsInPaletteArray = candidatePaletteArray.length + 1;
                var palette = this.getPaletteFromSteps(name, candidatePaletteArray, numDesiredColors);
                palettes.push(palette);
            }
            return (palettes);
        };
        // Makes an array of SandDance palettes using ALL the palettes in the color scheme of the specified type/index.
        // Note: A SandDance palette is an array of [r,g,b] color arrays.
        colorPalettesClass.getPalettesFromColorScheme = function (colorSchemeType, colorSchemeIndex, reverseColors, invertColors) {
            var colorSchemeNames = colorPalettesClass.getColorSchemeNames(colorSchemeType);
            // If colorSchemeIndex is greater than the number of schemes [of the specified type] then we default to scheme 0
            if ((colorSchemeIndex < 0) || (colorSchemeIndex >= colorSchemeNames.length)) {
                colorSchemeIndex = 0;
            }
            var colorSchemeName = colorSchemeNames[colorSchemeIndex];
            var paletteArray = colorPalettesClass.getPalettesFromColorSchemeName(colorSchemeName, reverseColors, invertColors);
            return (paletteArray);
        };
        // Makes an array of SandDance palettes using ALL the palettes in the named color scheme.
        // Note: A SandDance palette is an array of [r,g,b] color arrays.
        colorPalettesClass.getPalettesFromColorSchemeName = function (colorSchemeName, reverseColors, invertColors) {
            var palettes = [];
            var colorScheme = colorPalettesClass.getColorSchemeByName(colorSchemeName);
            var colorSchemePaletteNames = vp.utils.keys(colorScheme);
            /// palettes in this class are defined from LIGHT to DARK but clients expect them as DARK to LIGHT, so we 
            /// reverse the requested orders.  
            var actualReverse = (!reverseColors);
            for (var colorSchemePaletteNameIndex = 0; colorSchemePaletteNameIndex < colorSchemePaletteNames.length; colorSchemePaletteNameIndex++) {
                var colorSchemePaletteName = colorSchemePaletteNames[colorSchemePaletteNameIndex]; // Eg. "3"
                var colorSchemePalette = colorScheme[colorSchemePaletteName]; // An array of strings of the form "rgb(rrr,ggg,bbb)"
                var palette = []; // An array of rgb arrays
                // Convert each color in the color-scheme palette from "rgb(r,g,b)" to [r,g,b], then add that color array to our palette
                for (var i = 0; i < colorSchemePalette.length; i++) {
                    try {
                        //---- we no longer need rgb arrays on the client ----
                        //var rgbArray: number[] = colorPalettesClass.getRgbColorArrayFromRgbColorString(colorSchemePalette[i]);
                        var rgbString = colorSchemePalette[i];
                        if (invertColors) {
                            rgbString = colorPalettesClass.invertThisColor(rgbString);
                        }
                        if (actualReverse) {
                            var rIndex = (colorSchemePalette.length - 1) - i;
                            palette[rIndex] = rgbString;
                        }
                        else {
                            palette.push(rgbString);
                        }
                    }
                    catch (err) {
                        throw err + " in color scheme '" + colorSchemeName + "',  palette '" + colorSchemePaletteName + "'.";
                    }
                }
                palettes.push(palette);
            }
            return (palettes);
        };
        colorPalettesClass.getRgbColorArrayFromRgbColorString = function (rgbColorString) {
            var colorsArray = rgbColorString.replace("rgb(", "").replace(")", "").split(','); // rgbColorStrings is an array of string of the form "rgb(rrr, ggg, bbb)"
            var rgbArray = [];
            if (colorsArray.length == 3) {
                rgbArray.push(parseInt(colorsArray[0]));
                rgbArray.push(parseInt(colorsArray[1]));
                rgbArray.push(parseInt(colorsArray[2]));
            }
            else {
                throw "Malformed rgb() value '" + rgbColorString + "'";
            }
            return (rgbArray);
        };
        colorPalettesClass.MaxQualitativeColors = 12;
        // This is the "heart" of colorbrewer_schemes.js 
        colorPalettesClass.colorBrewerSchemes = {
            // Note: These 3 members were not part of the original colorbrewer_schemes.js 
            divergingColorSchemes: ['Spectral', 'RdYlGn', 'RdBu', 'PiYG', 'PRGn', 'RdYlBu', 'BrBG', 'RdGy', 'PuOr'],
            //qualitativeColorSchemesOld: ['Khronos', 'Accent', 'Dark2', 'Pastel2', 'Set2', 'Pastel1', 'Set1', 'Paired', 'Set3'], // MUST be ordered by number of palettes
            qualitativeColorSchemes: ['Set3', 'Paired', 'Set1', 'Pastel1', 'Set2', 'Pastel2', 'Dark2', 'Accent', 'Khronos'],
            sequentialColorSchemes: ["Blues", "Greens", "Greys", "Oranges", "Purples", "Reds", "BuGn", "BuPu", "GnBu", "OrRd", "PuBu", "PuBuGn",
                "PuRd", "RdPu", "YlGn", "YlGnBu", "YlOrBu", "YlOrRd"],
            customColorSchemes: ["SpectralEx", "RedGreen", "RedBlue"],
            // Diverging color schemes [all palettes have 2..11 colors]
            Spectral: { 2: ['rgb(252,141,89)', 'rgb(153,213,148)'], 3: ['rgb(252,141,89)', 'rgb(255,255,191)', 'rgb(153,213,148)'], 4: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(171,221,164)', 'rgb(43,131,186)'], 5: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(255,255,191)', 'rgb(171,221,164)', 'rgb(43,131,186)'], 6: ['rgb(213,62,79)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(230,245,152)', 'rgb(153,213,148)', 'rgb(50,136,189)'], 7: ['rgb(213,62,79)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(230,245,152)', 'rgb(153,213,148)', 'rgb(50,136,189)'], 8: ['rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)'], 9: ['rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)'], 10: ['rgb(158,1,66)', 'rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)', 'rgb(94,79,162)'], 11: ['rgb(158,1,66)', 'rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)', 'rgb(94,79,162)'] },
            RdYlGn: { 2: ['rgb(252,141,89)', 'rgb(145,207,96)'], 3: ['rgb(252,141,89)', 'rgb(255,255,191)', 'rgb(145,207,96)'], 4: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(166,217,106)', 'rgb(26,150,65)'], 5: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(255,255,191)', 'rgb(166,217,106)', 'rgb(26,150,65)'], 6: ['rgb(215,48,39)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(217,239,139)', 'rgb(145,207,96)', 'rgb(26,152,80)'], 7: ['rgb(215,48,39)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(217,239,139)', 'rgb(145,207,96)', 'rgb(26,152,80)'], 8: ['rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(217,239,139)', 'rgb(166,217,106)', 'rgb(102,189,99)', 'rgb(26,152,80)'], 9: ['rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(217,239,139)', 'rgb(166,217,106)', 'rgb(102,189,99)', 'rgb(26,152,80)'], 10: ['rgb(165,0,38)', 'rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(217,239,139)', 'rgb(166,217,106)', 'rgb(102,189,99)', 'rgb(26,152,80)', 'rgb(0,104,55)'], 11: ['rgb(165,0,38)', 'rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(217,239,139)', 'rgb(166,217,106)', 'rgb(102,189,99)', 'rgb(26,152,80)', 'rgb(0,104,55)'] },
            RdBu: { 2: ['rgb(239,138,98)', 'rgb(103,169,207)'], 3: ['rgb(239,138,98)', 'rgb(247,247,247)', 'rgb(103,169,207)'], 4: ['rgb(202,0,32)', 'rgb(244,165,130)', 'rgb(146,197,222)', 'rgb(5,113,176)'], 5: ['rgb(202,0,32)', 'rgb(244,165,130)', 'rgb(247,247,247)', 'rgb(146,197,222)', 'rgb(5,113,176)'], 6: ['rgb(178,24,43)', 'rgb(239,138,98)', 'rgb(253,219,199)', 'rgb(209,229,240)', 'rgb(103,169,207)', 'rgb(33,102,172)'], 7: ['rgb(178,24,43)', 'rgb(239,138,98)', 'rgb(253,219,199)', 'rgb(247,247,247)', 'rgb(209,229,240)', 'rgb(103,169,207)', 'rgb(33,102,172)'], 8: ['rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(209,229,240)', 'rgb(146,197,222)', 'rgb(67,147,195)', 'rgb(33,102,172)'], 9: ['rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(247,247,247)', 'rgb(209,229,240)', 'rgb(146,197,222)', 'rgb(67,147,195)', 'rgb(33,102,172)'], 10: ['rgb(103,0,31)', 'rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(209,229,240)', 'rgb(146,197,222)', 'rgb(67,147,195)', 'rgb(33,102,172)', 'rgb(5,48,97)'], 11: ['rgb(103,0,31)', 'rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(247,247,247)', 'rgb(209,229,240)', 'rgb(146,197,222)', 'rgb(67,147,195)', 'rgb(33,102,172)', 'rgb(5,48,97)'] },
            PiYG: { 2: ['rgb(233,163,201)', 'rgb(161,215,106)'], 3: ['rgb(233,163,201)', 'rgb(247,247,247)', 'rgb(161,215,106)'], 4: ['rgb(208,28,139)', 'rgb(241,182,218)', 'rgb(184,225,134)', 'rgb(77,172,38)'], 5: ['rgb(208,28,139)', 'rgb(241,182,218)', 'rgb(247,247,247)', 'rgb(184,225,134)', 'rgb(77,172,38)'], 6: ['rgb(197,27,125)', 'rgb(233,163,201)', 'rgb(253,224,239)', 'rgb(230,245,208)', 'rgb(161,215,106)', 'rgb(77,146,33)'], 7: ['rgb(197,27,125)', 'rgb(233,163,201)', 'rgb(253,224,239)', 'rgb(247,247,247)', 'rgb(230,245,208)', 'rgb(161,215,106)', 'rgb(77,146,33)'], 8: ['rgb(197,27,125)', 'rgb(222,119,174)', 'rgb(241,182,218)', 'rgb(253,224,239)', 'rgb(230,245,208)', 'rgb(184,225,134)', 'rgb(127,188,65)', 'rgb(77,146,33)'], 9: ['rgb(197,27,125)', 'rgb(222,119,174)', 'rgb(241,182,218)', 'rgb(253,224,239)', 'rgb(247,247,247)', 'rgb(230,245,208)', 'rgb(184,225,134)', 'rgb(127,188,65)', 'rgb(77,146,33)'], 10: ['rgb(142,1,82)', 'rgb(197,27,125)', 'rgb(222,119,174)', 'rgb(241,182,218)', 'rgb(253,224,239)', 'rgb(230,245,208)', 'rgb(184,225,134)', 'rgb(127,188,65)', 'rgb(77,146,33)', 'rgb(39,100,25)'], 11: ['rgb(142,1,82)', 'rgb(197,27,125)', 'rgb(222,119,174)', 'rgb(241,182,218)', 'rgb(253,224,239)', 'rgb(247,247,247)', 'rgb(230,245,208)', 'rgb(184,225,134)', 'rgb(127,188,65)', 'rgb(77,146,33)', 'rgb(39,100,25)'] },
            PRGn: { 2: ['rgb(175,141,195)', 'rgb(127,191,123)'], 3: ['rgb(175,141,195)', 'rgb(247,247,247)', 'rgb(127,191,123)'], 4: ['rgb(123,50,148)', 'rgb(194,165,207)', 'rgb(166,219,160)', 'rgb(0,136,55)'], 5: ['rgb(123,50,148)', 'rgb(194,165,207)', 'rgb(247,247,247)', 'rgb(166,219,160)', 'rgb(0,136,55)'], 6: ['rgb(118,42,131)', 'rgb(175,141,195)', 'rgb(231,212,232)', 'rgb(217,240,211)', 'rgb(127,191,123)', 'rgb(27,120,55)'], 7: ['rgb(118,42,131)', 'rgb(175,141,195)', 'rgb(231,212,232)', 'rgb(247,247,247)', 'rgb(217,240,211)', 'rgb(127,191,123)', 'rgb(27,120,55)'], 8: ['rgb(118,42,131)', 'rgb(153,112,171)', 'rgb(194,165,207)', 'rgb(231,212,232)', 'rgb(217,240,211)', 'rgb(166,219,160)', 'rgb(90,174,97)', 'rgb(27,120,55)'], 9: ['rgb(118,42,131)', 'rgb(153,112,171)', 'rgb(194,165,207)', 'rgb(231,212,232)', 'rgb(247,247,247)', 'rgb(217,240,211)', 'rgb(166,219,160)', 'rgb(90,174,97)', 'rgb(27,120,55)'], 10: ['rgb(64,0,75)', 'rgb(118,42,131)', 'rgb(153,112,171)', 'rgb(194,165,207)', 'rgb(231,212,232)', 'rgb(217,240,211)', 'rgb(166,219,160)', 'rgb(90,174,97)', 'rgb(27,120,55)', 'rgb(0,68,27)'], 11: ['rgb(64,0,75)', 'rgb(118,42,131)', 'rgb(153,112,171)', 'rgb(194,165,207)', 'rgb(231,212,232)', 'rgb(247,247,247)', 'rgb(217,240,211)', 'rgb(166,219,160)', 'rgb(90,174,97)', 'rgb(27,120,55)', 'rgb(0,68,27)'] },
            RdYlBu: { 2: ['rgb(252,141,89)', 'rgb(145,191,219)'], 3: ['rgb(252,141,89)', 'rgb(255,255,191)', 'rgb(145,191,219)'], 4: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(171,217,233)', 'rgb(44,123,182)'], 5: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(255,255,191)', 'rgb(171,217,233)', 'rgb(44,123,182)'], 6: ['rgb(215,48,39)', 'rgb(252,141,89)', 'rgb(254,224,144)', 'rgb(224,243,248)', 'rgb(145,191,219)', 'rgb(69,117,180)'], 7: ['rgb(215,48,39)', 'rgb(252,141,89)', 'rgb(254,224,144)', 'rgb(255,255,191)', 'rgb(224,243,248)', 'rgb(145,191,219)', 'rgb(69,117,180)'], 8: ['rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,144)', 'rgb(224,243,248)', 'rgb(171,217,233)', 'rgb(116,173,209)', 'rgb(69,117,180)'], 9: ['rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,144)', 'rgb(255,255,191)', 'rgb(224,243,248)', 'rgb(171,217,233)', 'rgb(116,173,209)', 'rgb(69,117,180)'], 10: ['rgb(165,0,38)', 'rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,144)', 'rgb(224,243,248)', 'rgb(171,217,233)', 'rgb(116,173,209)', 'rgb(69,117,180)', 'rgb(49,54,149)'], 11: ['rgb(165,0,38)', 'rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,144)', 'rgb(255,255,191)', 'rgb(224,243,248)', 'rgb(171,217,233)', 'rgb(116,173,209)', 'rgb(69,117,180)', 'rgb(49,54,149)'] },
            BrBG: { 2: ['rgb(216,179,101)', 'rgb(90,180,172)'], 3: ['rgb(216,179,101)', 'rgb(245,245,245)', 'rgb(90,180,172)'], 4: ['rgb(166,97,26)', 'rgb(223,194,125)', 'rgb(128,205,193)', 'rgb(1,133,113)'], 5: ['rgb(166,97,26)', 'rgb(223,194,125)', 'rgb(245,245,245)', 'rgb(128,205,193)', 'rgb(1,133,113)'], 6: ['rgb(140,81,10)', 'rgb(216,179,101)', 'rgb(246,232,195)', 'rgb(199,234,229)', 'rgb(90,180,172)', 'rgb(1,102,94)'], 7: ['rgb(140,81,10)', 'rgb(216,179,101)', 'rgb(246,232,195)', 'rgb(245,245,245)', 'rgb(199,234,229)', 'rgb(90,180,172)', 'rgb(1,102,94)'], 8: ['rgb(140,81,10)', 'rgb(191,129,45)', 'rgb(223,194,125)', 'rgb(246,232,195)', 'rgb(199,234,229)', 'rgb(128,205,193)', 'rgb(53,151,143)', 'rgb(1,102,94)'], 9: ['rgb(140,81,10)', 'rgb(191,129,45)', 'rgb(223,194,125)', 'rgb(246,232,195)', 'rgb(245,245,245)', 'rgb(199,234,229)', 'rgb(128,205,193)', 'rgb(53,151,143)', 'rgb(1,102,94)'], 10: ['rgb(84,48,5)', 'rgb(140,81,10)', 'rgb(191,129,45)', 'rgb(223,194,125)', 'rgb(246,232,195)', 'rgb(199,234,229)', 'rgb(128,205,193)', 'rgb(53,151,143)', 'rgb(1,102,94)', 'rgb(0,60,48)'], 11: ['rgb(84,48,5)', 'rgb(140,81,10)', 'rgb(191,129,45)', 'rgb(223,194,125)', 'rgb(246,232,195)', 'rgb(245,245,245)', 'rgb(199,234,229)', 'rgb(128,205,193)', 'rgb(53,151,143)', 'rgb(1,102,94)', 'rgb(0,60,48)'] },
            RdGy: { 2: ['rgb(239,138,98)', 'rgb(153,153,153)'], 3: ['rgb(239,138,98)', 'rgb(255,255,255)', 'rgb(153,153,153)'], 4: ['rgb(202,0,32)', 'rgb(244,165,130)', 'rgb(186,186,186)', 'rgb(64,64,64)'], 5: ['rgb(202,0,32)', 'rgb(244,165,130)', 'rgb(255,255,255)', 'rgb(186,186,186)', 'rgb(64,64,64)'], 6: ['rgb(178,24,43)', 'rgb(239,138,98)', 'rgb(253,219,199)', 'rgb(224,224,224)', 'rgb(153,153,153)', 'rgb(77,77,77)'], 7: ['rgb(178,24,43)', 'rgb(239,138,98)', 'rgb(253,219,199)', 'rgb(255,255,255)', 'rgb(224,224,224)', 'rgb(153,153,153)', 'rgb(77,77,77)'], 8: ['rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(224,224,224)', 'rgb(186,186,186)', 'rgb(135,135,135)', 'rgb(77,77,77)'], 9: ['rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(255,255,255)', 'rgb(224,224,224)', 'rgb(186,186,186)', 'rgb(135,135,135)', 'rgb(77,77,77)'], 10: ['rgb(103,0,31)', 'rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(224,224,224)', 'rgb(186,186,186)', 'rgb(135,135,135)', 'rgb(77,77,77)', 'rgb(26,26,26)'], 11: ['rgb(103,0,31)', 'rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(255,255,255)', 'rgb(224,224,224)', 'rgb(186,186,186)', 'rgb(135,135,135)', 'rgb(77,77,77)', 'rgb(26,26,26)'] },
            PuOr: { 2: ['rgb(241,163,64)', 'rgb(153,142,195)'], 3: ['rgb(241,163,64)', 'rgb(247,247,247)', 'rgb(153,142,195)'], 4: ['rgb(230,97,1)', 'rgb(253,184,99)', 'rgb(178,171,210)', 'rgb(94,60,153)'], 5: ['rgb(230,97,1)', 'rgb(253,184,99)', 'rgb(247,247,247)', 'rgb(178,171,210)', 'rgb(94,60,153)'], 6: ['rgb(179,88,6)', 'rgb(241,163,64)', 'rgb(254,224,182)', 'rgb(216,218,235)', 'rgb(153,142,195)', 'rgb(84,39,136)'], 7: ['rgb(179,88,6)', 'rgb(241,163,64)', 'rgb(254,224,182)', 'rgb(247,247,247)', 'rgb(216,218,235)', 'rgb(153,142,195)', 'rgb(84,39,136)'], 8: ['rgb(179,88,6)', 'rgb(224,130,20)', 'rgb(253,184,99)', 'rgb(254,224,182)', 'rgb(216,218,235)', 'rgb(178,171,210)', 'rgb(128,115,172)', 'rgb(84,39,136)'], 9: ['rgb(179,88,6)', 'rgb(224,130,20)', 'rgb(253,184,99)', 'rgb(254,224,182)', 'rgb(247,247,247)', 'rgb(216,218,235)', 'rgb(178,171,210)', 'rgb(128,115,172)', 'rgb(84,39,136)'], 10: ['rgb(127,59,8)', 'rgb(179,88,6)', 'rgb(224,130,20)', 'rgb(253,184,99)', 'rgb(254,224,182)', 'rgb(216,218,235)', 'rgb(178,171,210)', 'rgb(128,115,172)', 'rgb(84,39,136)', 'rgb(45,0,75)'], 11: ['rgb(127,59,8)', 'rgb(179,88,6)', 'rgb(224,130,20)', 'rgb(253,184,99)', 'rgb(254,224,182)', 'rgb(247,247,247)', 'rgb(216,218,235)', 'rgb(178,171,210)', 'rgb(128,115,172)', 'rgb(84,39,136)', 'rgb(45,0,75)'] },
            // custom schemes
            SpectralEx: { 2: ['rgb(215,25,28)', 'rgb(43,131,186)'], 3: ['rgb(215,25,28)', 'rgb(255,255,191)', 'rgb(43,131,186)'], 4: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(171,221,164)', 'rgb(43,131,186)'], 5: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(255,255,191)', 'rgb(171,221,164)', 'rgb(43,131,186)'], 6: ['rgb(215,25,28)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(230,245,152)', 'rgb(153,213,148)', 'rgb(43,131,186)'], 7: ['rgb(215,25,28)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(230,245,152)', 'rgb(153,213,148)', 'rgb(43,131,186)'], 8: ['rgb(215,25,28)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(43,131,186)'], 9: ['rgb(215,25,28)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(43,131,186)'], 10: ['rgb(215,25,28)', 'rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)', 'rgb(43,131,186)'], 11: ['rgb(215,25,28)', 'rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)', 'rgb(43,131,186)'] },
            RedGreen: { 2: ["rgb(255, 0, 0)", "rgb(127, 255, 127)"] },
            RedBlue: { 2: ["rgb(255, 0, 0)", "rgb(0, 0, 255)"] },
            // Qualitative color schemes
            // [Palettes with 2..6 colors]
            Khronos: { 2: ['rgb(157,190,127)', 'rgb(255,255,255)'], 3: ['rgb(157,190,127)', 'rgb(232,109,113)', 'rgb(255,255,255)'], 4: ['rgb(157,190,127)', 'rgb(232,109,113)', 'rgb(194,195,178)', 'rgb(255,255,255)'], 5: ['rgb(157,190,127)', 'rgb(232,109,113)', 'rgb(252,238,78)', 'rgb(238,160,41)', 'rgb(255,255,255)'], 6: ['rgb(157,190,127)', 'rgb(232,109,113)', 'rgb(252,238,78)', 'rgb(238,160,41)', 'rgb(194,195,178)', 'rgb(255,255,255)'] },
            // [Palettes with 2..8 colors]
            Accent: { 2: ['rgb(127,201,127)', 'rgb(190,174,212)'], 3: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)'], 4: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)', 'rgb(255,255,153)'], 5: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)', 'rgb(255,255,153)', 'rgb(56,108,176)'], 6: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)', 'rgb(255,255,153)', 'rgb(56,108,176)', 'rgb(240,2,127)'], 7: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)', 'rgb(255,255,153)', 'rgb(56,108,176)', 'rgb(240,2,127)', 'rgb(191,91,23)'], 8: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)', 'rgb(255,255,153)', 'rgb(56,108,176)', 'rgb(240,2,127)', 'rgb(191,91,23)', 'rgb(102,102,102)'] },
            Dark2: { 2: ['rgb(27,158,119)', 'rgb(217,95,2)'], 3: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)'], 4: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)', 'rgb(231,41,138)'], 5: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)', 'rgb(231,41,138)', 'rgb(102,166,30)'], 6: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)', 'rgb(231,41,138)', 'rgb(102,166,30)', 'rgb(230,171,2)'], 7: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)', 'rgb(231,41,138)', 'rgb(102,166,30)', 'rgb(230,171,2)', 'rgb(166,118,29)'], 8: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)', 'rgb(231,41,138)', 'rgb(102,166,30)', 'rgb(230,171,2)', 'rgb(166,118,29)', 'rgb(102,102,102)'] },
            Pastel2: { 2: ['rgb(179,226,205)', 'rgb(253,205,172)'], 3: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)'], 4: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)', 'rgb(244,202,228)'], 5: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)', 'rgb(244,202,228)', 'rgb(230,245,201)'], 6: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)', 'rgb(244,202,228)', 'rgb(230,245,201)', 'rgb(255,242,174)'], 7: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)', 'rgb(244,202,228)', 'rgb(230,245,201)', 'rgb(255,242,174)', 'rgb(241,226,204)'], 8: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)', 'rgb(244,202,228)', 'rgb(230,245,201)', 'rgb(255,242,174)', 'rgb(241,226,204)', 'rgb(204,204,204)'] },
            Set2: { 2: ['rgb(102,194,165)', 'rgb(252,141,98)'], 3: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)'], 4: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)', 'rgb(231,138,195)'], 5: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)', 'rgb(231,138,195)', 'rgb(166,216,84)'], 6: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)', 'rgb(231,138,195)', 'rgb(166,216,84)', 'rgb(255,217,47)'], 7: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)', 'rgb(231,138,195)', 'rgb(166,216,84)', 'rgb(255,217,47)', 'rgb(229,196,148)'], 8: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)', 'rgb(231,138,195)', 'rgb(166,216,84)', 'rgb(255,217,47)', 'rgb(229,196,148)', 'rgb(179,179,179)'] },
            // [Palettes with 2..9 colors]
            Pastel1: { 2: ['rgb(251,180,174)', 'rgb(179,205,227)'], 3: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)'], 4: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)'], 5: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)', 'rgb(254,217,166)'], 6: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)', 'rgb(254,217,166)', 'rgb(255,255,204)'], 7: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)', 'rgb(254,217,166)', 'rgb(255,255,204)', 'rgb(229,216,189)'], 8: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)', 'rgb(254,217,166)', 'rgb(255,255,204)', 'rgb(229,216,189)', 'rgb(253,218,236)'], 9: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)', 'rgb(254,217,166)', 'rgb(255,255,204)', 'rgb(229,216,189)', 'rgb(253,218,236)', 'rgb(242,242,242)'] },
            Set1: { 2: ['rgb(228,26,28)', 'rgb(55,126,184)'], 3: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)'], 4: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)'], 5: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)', 'rgb(255,127,0)'], 6: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)', 'rgb(255,127,0)', 'rgb(255,255,51)'], 7: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)', 'rgb(255,127,0)', 'rgb(255,255,51)', 'rgb(166,86,40)'], 8: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)', 'rgb(255,127,0)', 'rgb(255,255,51)', 'rgb(166,86,40)', 'rgb(247,129,191)'], 9: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)', 'rgb(255,127,0)', 'rgb(255,255,51)', 'rgb(166,86,40)', 'rgb(247,129,191)', 'rgb(153,153,153)'] },
            // [Palettes with 2..12 colors]
            Paired: { 2: ['rgb(166,206,227)', 'rgb(31,120,180)'], 3: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)'], 4: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)'], 5: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)'], 6: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)'], 7: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)'], 8: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)', 'rgb(255,127,0)'], 9: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)', 'rgb(255,127,0)', 'rgb(202,178,214)'], 10: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)', 'rgb(255,127,0)', 'rgb(202,178,214)', 'rgb(106,61,154)'], 11: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)', 'rgb(255,127,0)', 'rgb(202,178,214)', 'rgb(106,61,154)', 'rgb(255,255,153)'], 12: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)', 'rgb(255,127,0)', 'rgb(202,178,214)', 'rgb(106,61,154)', 'rgb(255,255,153)', 'rgb(177,89,40)'] },
            Set3: { 2: ['rgb(141,211,199)', 'rgb(255,255,179)'], 3: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)'], 4: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)'], 5: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)'], 6: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)'], 7: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)'], 8: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)', 'rgb(252,205,229)'], 9: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)', 'rgb(252,205,229)', 'rgb(217,217,217)'], 10: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)', 'rgb(252,205,229)', 'rgb(217,217,217)', 'rgb(188,128,189)'], 11: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)', 'rgb(252,205,229)', 'rgb(217,217,217)', 'rgb(188,128,189)', 'rgb(204,235,197)'], 12: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)', 'rgb(252,205,229)', 'rgb(217,217,217)', 'rgb(188,128,189)', 'rgb(204,235,197)', 'rgb(255,237,111)'] },
            // Sequential color schemes [all palettes have 2..9 colors]
            Blues: { 2: ['rgb(222,235,247)', 'rgb(158,202,225)'], 3: ['rgb(222,235,247)', 'rgb(158,202,225)', 'rgb(49,130,189)'], 4: ['rgb(239,243,255)', 'rgb(189,215,231)', 'rgb(107,174,214)', 'rgb(33,113,181)'], 5: ['rgb(239,243,255)', 'rgb(189,215,231)', 'rgb(107,174,214)', 'rgb(49,130,189)', 'rgb(8,81,156)'], 6: ['rgb(239,243,255)', 'rgb(198,219,239)', 'rgb(158,202,225)', 'rgb(107,174,214)', 'rgb(49,130,189)', 'rgb(8,81,156)'], 7: ['rgb(239,243,255)', 'rgb(198,219,239)', 'rgb(158,202,225)', 'rgb(107,174,214)', 'rgb(66,146,198)', 'rgb(33,113,181)', 'rgb(8,69,148)'], 8: ['rgb(247,251,255)', 'rgb(222,235,247)', 'rgb(198,219,239)', 'rgb(158,202,225)', 'rgb(107,174,214)', 'rgb(66,146,198)', 'rgb(33,113,181)', 'rgb(8,69,148)'], 9: ['rgb(247,251,255)', 'rgb(222,235,247)', 'rgb(198,219,239)', 'rgb(158,202,225)', 'rgb(107,174,214)', 'rgb(66,146,198)', 'rgb(33,113,181)', 'rgb(8,81,156)', 'rgb(8,48,107)'] },
            Greens: { 2: ['rgb(229,245,224)', 'rgb(161,217,155)'], 3: ['rgb(229,245,224)', 'rgb(161,217,155)', 'rgb(49,163,84)'], 4: ['rgb(237,248,233)', 'rgb(186,228,179)', 'rgb(116,196,118)', 'rgb(35,139,69)'], 5: ['rgb(237,248,233)', 'rgb(186,228,179)', 'rgb(116,196,118)', 'rgb(49,163,84)', 'rgb(0,109,44)'], 6: ['rgb(237,248,233)', 'rgb(199,233,192)', 'rgb(161,217,155)', 'rgb(116,196,118)', 'rgb(49,163,84)', 'rgb(0,109,44)'], 7: ['rgb(237,248,233)', 'rgb(199,233,192)', 'rgb(161,217,155)', 'rgb(116,196,118)', 'rgb(65,171,93)', 'rgb(35,139,69)', 'rgb(0,90,50)'], 8: ['rgb(247,252,245)', 'rgb(229,245,224)', 'rgb(199,233,192)', 'rgb(161,217,155)', 'rgb(116,196,118)', 'rgb(65,171,93)', 'rgb(35,139,69)', 'rgb(0,90,50)'], 9: ['rgb(247,252,245)', 'rgb(229,245,224)', 'rgb(199,233,192)', 'rgb(161,217,155)', 'rgb(116,196,118)', 'rgb(65,171,93)', 'rgb(35,139,69)', 'rgb(0,109,44)', 'rgb(0,68,27)'] },
            Greys: { 2: ['rgb(240,240,240)', 'rgb(189,189,189)'], 3: ['rgb(240,240,240)', 'rgb(189,189,189)', 'rgb(99,99,99)'], 4: ['rgb(247,247,247)', 'rgb(204,204,204)', 'rgb(150,150,150)', 'rgb(82,82,82)'], 5: ['rgb(247,247,247)', 'rgb(204,204,204)', 'rgb(150,150,150)', 'rgb(99,99,99)', 'rgb(37,37,37)'], 6: ['rgb(247,247,247)', 'rgb(217,217,217)', 'rgb(189,189,189)', 'rgb(150,150,150)', 'rgb(99,99,99)', 'rgb(37,37,37)'], 7: ['rgb(247,247,247)', 'rgb(217,217,217)', 'rgb(189,189,189)', 'rgb(150,150,150)', 'rgb(115,115,115)', 'rgb(82,82,82)', 'rgb(37,37,37)'], 8: ['rgb(255,255,255)', 'rgb(240,240,240)', 'rgb(217,217,217)', 'rgb(189,189,189)', 'rgb(150,150,150)', 'rgb(115,115,115)', 'rgb(82,82,82)', 'rgb(37,37,37)'], 9: ['rgb(255,255,255)', 'rgb(227,227,227)', 'rgb(200,200,200)', 'rgb(145,145,145)', 'rgb(127,127,127)', 'rgb(117,117,117)', 'rgb(89,89,89)', 'rgb(62,62,62)', 'rgb(34,34,34)'] },
            Oranges: { 2: ['rgb(254,230,206)', 'rgb(253,174,107)'], 3: ['rgb(254,230,206)', 'rgb(253,174,107)', 'rgb(230,85,13)'], 4: ['rgb(254,237,222)', 'rgb(253,190,133)', 'rgb(253,141,60)', 'rgb(217,71,1)'], 5: ['rgb(254,237,222)', 'rgb(253,190,133)', 'rgb(253,141,60)', 'rgb(230,85,13)', 'rgb(166,54,3)'], 6: ['rgb(254,237,222)', 'rgb(253,208,162)', 'rgb(253,174,107)', 'rgb(253,141,60)', 'rgb(230,85,13)', 'rgb(166,54,3)'], 7: ['rgb(254,237,222)', 'rgb(253,208,162)', 'rgb(253,174,107)', 'rgb(253,141,60)', 'rgb(241,105,19)', 'rgb(217,72,1)', 'rgb(140,45,4)'], 8: ['rgb(255,245,235)', 'rgb(254,230,206)', 'rgb(253,208,162)', 'rgb(253,174,107)', 'rgb(253,141,60)', 'rgb(241,105,19)', 'rgb(217,72,1)', 'rgb(140,45,4)'], 9: ['rgb(255,245,235)', 'rgb(254,230,206)', 'rgb(253,208,162)', 'rgb(253,174,107)', 'rgb(253,141,60)', 'rgb(241,105,19)', 'rgb(217,72,1)', 'rgb(166,54,3)', 'rgb(127,39,4)'] },
            Purples: { 2: ['rgb(239,237,245)', 'rgb(188,189,220)'], 3: ['rgb(239,237,245)', 'rgb(188,189,220)', 'rgb(117,107,177)'], 4: ['rgb(242,240,247)', 'rgb(203,201,226)', 'rgb(158,154,200)', 'rgb(106,81,163)'], 5: ['rgb(242,240,247)', 'rgb(203,201,226)', 'rgb(158,154,200)', 'rgb(117,107,177)', 'rgb(84,39,143)'], 6: ['rgb(242,240,247)', 'rgb(218,218,235)', 'rgb(188,189,220)', 'rgb(158,154,200)', 'rgb(117,107,177)', 'rgb(84,39,143)'], 7: ['rgb(242,240,247)', 'rgb(218,218,235)', 'rgb(188,189,220)', 'rgb(158,154,200)', 'rgb(128,125,186)', 'rgb(106,81,163)', 'rgb(74,20,134)'], 8: ['rgb(252,251,253)', 'rgb(239,237,245)', 'rgb(218,218,235)', 'rgb(188,189,220)', 'rgb(158,154,200)', 'rgb(128,125,186)', 'rgb(106,81,163)', 'rgb(74,20,134)'], 9: ['rgb(252,251,253)', 'rgb(239,237,245)', 'rgb(218,218,235)', 'rgb(188,189,220)', 'rgb(158,154,200)', 'rgb(128,125,186)', 'rgb(106,81,163)', 'rgb(84,39,143)', 'rgb(63,0,125)'] },
            Reds: { 2: ['rgb(254,224,210)', 'rgb(252,146,114)'], 3: ['rgb(254,224,210)', 'rgb(252,146,114)', 'rgb(222,45,38)'], 4: ['rgb(254,229,217)', 'rgb(252,174,145)', 'rgb(251,106,74)', 'rgb(203,24,29)'], 5: ['rgb(254,229,217)', 'rgb(252,174,145)', 'rgb(251,106,74)', 'rgb(222,45,38)', 'rgb(165,15,21)'], 6: ['rgb(254,229,217)', 'rgb(252,187,161)', 'rgb(252,146,114)', 'rgb(251,106,74)', 'rgb(222,45,38)', 'rgb(165,15,21)'], 7: ['rgb(254,229,217)', 'rgb(252,187,161)', 'rgb(252,146,114)', 'rgb(251,106,74)', 'rgb(239,59,44)', 'rgb(203,24,29)', 'rgb(153,0,13)'], 8: ['rgb(255,245,240)', 'rgb(254,224,210)', 'rgb(252,187,161)', 'rgb(252,146,114)', 'rgb(251,106,74)', 'rgb(239,59,44)', 'rgb(203,24,29)', 'rgb(153,0,13)'], 9: ['rgb(255,245,240)', 'rgb(254,224,210)', 'rgb(252,187,161)', 'rgb(252,146,114)', 'rgb(251,106,74)', 'rgb(239,59,44)', 'rgb(203,24,29)', 'rgb(165,15,21)', 'rgb(103,0,13)'] },
            BuGn: { 2: ['rgb(229,245,249)', 'rgb(153,216,201)'], 3: ['rgb(229,245,249)', 'rgb(153,216,201)', 'rgb(44,162,95)'], 4: ['rgb(237,248,251)', 'rgb(178,226,226)', 'rgb(102,194,164)', 'rgb(35,139,69)'], 5: ['rgb(237,248,251)', 'rgb(178,226,226)', 'rgb(102,194,164)', 'rgb(44,162,95)', 'rgb(0,109,44)'], 6: ['rgb(237,248,251)', 'rgb(204,236,230)', 'rgb(153,216,201)', 'rgb(102,194,164)', 'rgb(44,162,95)', 'rgb(0,109,44)'], 7: ['rgb(237,248,251)', 'rgb(204,236,230)', 'rgb(153,216,201)', 'rgb(102,194,164)', 'rgb(65,174,118)', 'rgb(35,139,69)', 'rgb(0,88,36)'], 8: ['rgb(247,252,253)', 'rgb(229,245,249)', 'rgb(204,236,230)', 'rgb(153,216,201)', 'rgb(102,194,164)', 'rgb(65,174,118)', 'rgb(35,139,69)', 'rgb(0,88,36)'], 9: ['rgb(247,252,253)', 'rgb(229,245,249)', 'rgb(204,236,230)', 'rgb(153,216,201)', 'rgb(102,194,164)', 'rgb(65,174,118)', 'rgb(35,139,69)', 'rgb(0,109,44)', 'rgb(0,68,27)'] },
            BuPu: { 2: ['rgb(224,236,244)', 'rgb(136,86,167)'], 3: ['rgb(224,236,244)', 'rgb(158,188,218)', 'rgb(136,86,167)'], 4: ['rgb(237,248,251)', 'rgb(179,205,227)', 'rgb(140,150,198)', 'rgb(136,65,157)'], 5: ['rgb(237,248,251)', 'rgb(179,205,227)', 'rgb(140,150,198)', 'rgb(136,86,167)', 'rgb(129,15,124)'], 6: ['rgb(237,248,251)', 'rgb(191,211,230)', 'rgb(158,188,218)', 'rgb(140,150,198)', 'rgb(136,86,167)', 'rgb(129,15,124)'], 7: ['rgb(237,248,251)', 'rgb(191,211,230)', 'rgb(158,188,218)', 'rgb(140,150,198)', 'rgb(140,107,177)', 'rgb(136,65,157)', 'rgb(110,1,107)'], 8: ['rgb(247,252,253)', 'rgb(224,236,244)', 'rgb(191,211,230)', 'rgb(158,188,218)', 'rgb(140,150,198)', 'rgb(140,107,177)', 'rgb(136,65,157)', 'rgb(110,1,107)'], 9: ['rgb(247,252,253)', 'rgb(224,236,244)', 'rgb(191,211,230)', 'rgb(158,188,218)', 'rgb(140,150,198)', 'rgb(140,107,177)', 'rgb(136,65,157)', 'rgb(129,15,124)', 'rgb(77,0,75)'] },
            GnBu: { 2: ['rgb(224,243,219)', 'rgb(168,221,181)'], 3: ['rgb(224,243,219)', 'rgb(168,221,181)', 'rgb(67,162,202)'], 4: ['rgb(240,249,232)', 'rgb(186,228,188)', 'rgb(123,204,196)', 'rgb(43,140,190)'], 5: ['rgb(240,249,232)', 'rgb(186,228,188)', 'rgb(123,204,196)', 'rgb(67,162,202)', 'rgb(8,104,172)'], 6: ['rgb(240,249,232)', 'rgb(204,235,197)', 'rgb(168,221,181)', 'rgb(123,204,196)', 'rgb(67,162,202)', 'rgb(8,104,172)'], 7: ['rgb(240,249,232)', 'rgb(204,235,197)', 'rgb(168,221,181)', 'rgb(123,204,196)', 'rgb(78,179,211)', 'rgb(43,140,190)', 'rgb(8,88,158)'], 8: ['rgb(247,252,240)', 'rgb(224,243,219)', 'rgb(204,235,197)', 'rgb(168,221,181)', 'rgb(123,204,196)', 'rgb(78,179,211)', 'rgb(43,140,190)', 'rgb(8,88,158)'], 9: ['rgb(247,252,240)', 'rgb(224,243,219)', 'rgb(204,235,197)', 'rgb(168,221,181)', 'rgb(123,204,196)', 'rgb(78,179,211)', 'rgb(43,140,190)', 'rgb(8,104,172)', 'rgb(8,64,129)'] },
            OrRd: { 2: ['rgb(254,232,200)', 'rgb(253,187,132)'], 3: ['rgb(254,232,200)', 'rgb(253,187,132)', 'rgb(227,74,51)'], 4: ['rgb(254,240,217)', 'rgb(253,204,138)', 'rgb(252,141,89)', 'rgb(215,48,31)'], 5: ['rgb(254,240,217)', 'rgb(253,204,138)', 'rgb(252,141,89)', 'rgb(227,74,51)', 'rgb(179,0,0)'], 6: ['rgb(254,240,217)', 'rgb(253,212,158)', 'rgb(253,187,132)', 'rgb(252,141,89)', 'rgb(227,74,51)', 'rgb(179,0,0)'], 7: ['rgb(254,240,217)', 'rgb(253,212,158)', 'rgb(253,187,132)', 'rgb(252,141,89)', 'rgb(239,101,72)', 'rgb(215,48,31)', 'rgb(153,0,0)'], 8: ['rgb(255,247,236)', 'rgb(254,232,200)', 'rgb(253,212,158)', 'rgb(253,187,132)', 'rgb(252,141,89)', 'rgb(239,101,72)', 'rgb(215,48,31)', 'rgb(153,0,0)'], 9: ['rgb(255,247,236)', 'rgb(254,232,200)', 'rgb(253,212,158)', 'rgb(253,187,132)', 'rgb(252,141,89)', 'rgb(239,101,72)', 'rgb(215,48,31)', 'rgb(179,0,0)', 'rgb(127,0,0)'] },
            PuBu: { 2: ['rgb(236,231,242)', 'rgb(166,189,219)'], 3: ['rgb(236,231,242)', 'rgb(166,189,219)', 'rgb(43,140,190)'], 4: ['rgb(241,238,246)', 'rgb(189,201,225)', 'rgb(116,169,207)', 'rgb(5,112,176)'], 5: ['rgb(241,238,246)', 'rgb(189,201,225)', 'rgb(116,169,207)', 'rgb(43,140,190)', 'rgb(4,90,141)'], 6: ['rgb(241,238,246)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(116,169,207)', 'rgb(43,140,190)', 'rgb(4,90,141)'], 7: ['rgb(241,238,246)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(116,169,207)', 'rgb(54,144,192)', 'rgb(5,112,176)', 'rgb(3,78,123)'], 8: ['rgb(255,247,251)', 'rgb(236,231,242)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(116,169,207)', 'rgb(54,144,192)', 'rgb(5,112,176)', 'rgb(3,78,123)'], 9: ['rgb(255,247,251)', 'rgb(236,231,242)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(116,169,207)', 'rgb(54,144,192)', 'rgb(5,112,176)', 'rgb(4,90,141)', 'rgb(2,56,88)'] },
            PuBuGn: { 2: ['rgb(236,226,240)', 'rgb(166,189,219)'], 3: ['rgb(236,226,240)', 'rgb(166,189,219)', 'rgb(28,144,153)'], 4: ['rgb(246,239,247)', 'rgb(189,201,225)', 'rgb(103,169,207)', 'rgb(2,129,138)'], 5: ['rgb(246,239,247)', 'rgb(189,201,225)', 'rgb(103,169,207)', 'rgb(28,144,153)', 'rgb(1,108,89)'], 6: ['rgb(246,239,247)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(103,169,207)', 'rgb(28,144,153)', 'rgb(1,108,89)'], 7: ['rgb(246,239,247)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(103,169,207)', 'rgb(54,144,192)', 'rgb(2,129,138)', 'rgb(1,100,80)'], 8: ['rgb(255,247,251)', 'rgb(236,226,240)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(103,169,207)', 'rgb(54,144,192)', 'rgb(2,129,138)', 'rgb(1,100,80)'], 9: ['rgb(255,247,251)', 'rgb(236,226,240)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(103,169,207)', 'rgb(54,144,192)', 'rgb(2,129,138)', 'rgb(1,108,89)', 'rgb(1,70,54)'] },
            PuRd: { 2: ['rgb(231,225,239)', 'rgb(201,148,199)'], 3: ['rgb(231,225,239)', 'rgb(201,148,199)', 'rgb(221,28,119)'], 4: ['rgb(241,238,246)', 'rgb(215,181,216)', 'rgb(223,101,176)', 'rgb(206,18,86)'], 5: ['rgb(241,238,246)', 'rgb(215,181,216)', 'rgb(223,101,176)', 'rgb(221,28,119)', 'rgb(152,0,67)'], 6: ['rgb(241,238,246)', 'rgb(212,185,218)', 'rgb(201,148,199)', 'rgb(223,101,176)', 'rgb(221,28,119)', 'rgb(152,0,67)'], 7: ['rgb(241,238,246)', 'rgb(212,185,218)', 'rgb(201,148,199)', 'rgb(223,101,176)', 'rgb(231,41,138)', 'rgb(206,18,86)', 'rgb(145,0,63)'], 8: ['rgb(247,244,249)', 'rgb(231,225,239)', 'rgb(212,185,218)', 'rgb(201,148,199)', 'rgb(223,101,176)', 'rgb(231,41,138)', 'rgb(206,18,86)', 'rgb(145,0,63)'], 9: ['rgb(247,244,249)', 'rgb(231,225,239)', 'rgb(212,185,218)', 'rgb(201,148,199)', 'rgb(223,101,176)', 'rgb(231,41,138)', 'rgb(206,18,86)', 'rgb(152,0,67)', 'rgb(103,0,31)'] },
            RdPu: { 2: ['rgb(253,224,221)', 'rgb(250,159,181)'], 3: ['rgb(253,224,221)', 'rgb(250,159,181)', 'rgb(197,27,138)'], 4: ['rgb(254,235,226)', 'rgb(251,180,185)', 'rgb(247,104,161)', 'rgb(174,1,126)'], 5: ['rgb(254,235,226)', 'rgb(251,180,185)', 'rgb(247,104,161)', 'rgb(197,27,138)', 'rgb(122,1,119)'], 6: ['rgb(254,235,226)', 'rgb(252,197,192)', 'rgb(250,159,181)', 'rgb(247,104,161)', 'rgb(197,27,138)', 'rgb(122,1,119)'], 7: ['rgb(254,235,226)', 'rgb(252,197,192)', 'rgb(250,159,181)', 'rgb(247,104,161)', 'rgb(221,52,151)', 'rgb(174,1,126)', 'rgb(122,1,119)'], 8: ['rgb(255,247,243)', 'rgb(253,224,221)', 'rgb(252,197,192)', 'rgb(250,159,181)', 'rgb(247,104,161)', 'rgb(221,52,151)', 'rgb(174,1,126)', 'rgb(122,1,119)'], 9: ['rgb(255,247,243)', 'rgb(253,224,221)', 'rgb(252,197,192)', 'rgb(250,159,181)', 'rgb(247,104,161)', 'rgb(221,52,151)', 'rgb(174,1,126)', 'rgb(122,1,119)', 'rgb(73,0,106)'] },
            YlGn: { 2: ['rgb(247,252,185)', 'rgb(49,163,84)'], 3: ['rgb(247,252,185)', 'rgb(173,221,142)', 'rgb(49,163,84)'], 4: ['rgb(255,255,204)', 'rgb(194,230,153)', 'rgb(120,198,121)', 'rgb(35,132,67)'], 5: ['rgb(255,255,204)', 'rgb(194,230,153)', 'rgb(120,198,121)', 'rgb(49,163,84)', 'rgb(0,104,55)'], 6: ['rgb(255,255,204)', 'rgb(217,240,163)', 'rgb(173,221,142)', 'rgb(120,198,121)', 'rgb(49,163,84)', 'rgb(0,104,55)'], 7: ['rgb(255,255,204)', 'rgb(217,240,163)', 'rgb(173,221,142)', 'rgb(120,198,121)', 'rgb(65,171,93)', 'rgb(35,132,67)', 'rgb(0,90,50)'], 8: ['rgb(255,255,229)', 'rgb(247,252,185)', 'rgb(217,240,163)', 'rgb(173,221,142)', 'rgb(120,198,121)', 'rgb(65,171,93)', 'rgb(35,132,67)', 'rgb(0,90,50)'], 9: ['rgb(255,255,229)', 'rgb(247,252,185)', 'rgb(217,240,163)', 'rgb(173,221,142)', 'rgb(120,198,121)', 'rgb(65,171,93)', 'rgb(35,132,67)', 'rgb(0,104,55)', 'rgb(0,69,41)'] },
            YlGnBu: { 2: ['rgb(237,248,177)', 'rgb(44,127,184)'], 3: ['rgb(237,248,177)', 'rgb(127,205,187)', 'rgb(44,127,184)'], 4: ['rgb(255,255,204)', 'rgb(161,218,180)', 'rgb(65,182,196)', 'rgb(34,94,168)'], 5: ['rgb(255,255,204)', 'rgb(161,218,180)', 'rgb(65,182,196)', 'rgb(44,127,184)', 'rgb(37,52,148)'], 6: ['rgb(255,255,204)', 'rgb(199,233,180)', 'rgb(127,205,187)', 'rgb(65,182,196)', 'rgb(44,127,184)', 'rgb(37,52,148)'], 7: ['rgb(255,255,204)', 'rgb(199,233,180)', 'rgb(127,205,187)', 'rgb(65,182,196)', 'rgb(29,145,192)', 'rgb(34,94,168)', 'rgb(12,44,132)'], 8: ['rgb(255,255,217)', 'rgb(237,248,177)', 'rgb(199,233,180)', 'rgb(127,205,187)', 'rgb(65,182,196)', 'rgb(29,145,192)', 'rgb(34,94,168)', 'rgb(12,44,132)'], 9: ['rgb(255,255,217)', 'rgb(237,248,177)', 'rgb(199,233,180)', 'rgb(127,205,187)', 'rgb(65,182,196)', 'rgb(29,145,192)', 'rgb(34,94,168)', 'rgb(37,52,148)', 'rgb(8,29,88)'] },
            YlOrBu: { 2: ['rgb(255,247,188)', 'rgb(217,95,14)'], 3: ['rgb(255,247,188)', 'rgb(254,196,79)', 'rgb(217,95,14)'], 4: ['rgb(255,255,212)', 'rgb(254,217,142)', 'rgb(254,153,41)', 'rgb(204,76,2)'], 5: ['rgb(255,255,212)', 'rgb(254,217,142)', 'rgb(254,153,41)', 'rgb(217,95,14)', 'rgb(153,52,4)'], 6: ['rgb(255,255,212)', 'rgb(254,227,145)', 'rgb(254,196,79)', 'rgb(254,153,41)', 'rgb(217,95,14)', 'rgb(153,52,4)'], 7: ['rgb(255,255,212)', 'rgb(254,227,145)', 'rgb(254,196,79)', 'rgb(254,153,41)', 'rgb(236,112,20)', 'rgb(204,76,2)', 'rgb(140,45,4)'], 8: ['rgb(255,255,229)', 'rgb(255,247,188)', 'rgb(254,227,145)', 'rgb(254,196,79)', 'rgb(254,153,41)', 'rgb(236,112,20)', 'rgb(204,76,2)', 'rgb(140,45,4)'], 9: ['rgb(255,255,229)', 'rgb(255,247,188)', 'rgb(254,227,145)', 'rgb(254,196,79)', 'rgb(254,153,41)', 'rgb(236,112,20)', 'rgb(204,76,2)', 'rgb(153,52,4)', 'rgb(102,37,6)'] },
            YlOrRd: { 2: ['rgb(255,237,160)', 'rgb(240,59,32)'], 3: ['rgb(255,237,160)', 'rgb(254,178,76)', 'rgb(240,59,32)'], 4: ['rgb(255,255,178)', 'rgb(254,204,92)', 'rgb(253,141,60)', 'rgb(227,26,28)'], 5: ['rgb(255,255,178)', 'rgb(254,204,92)', 'rgb(253,141,60)', 'rgb(240,59,32)', 'rgb(189,0,38)'], 6: ['rgb(255,255,178)', 'rgb(254,217,118)', 'rgb(254,178,76)', 'rgb(253,141,60)', 'rgb(240,59,32)', 'rgb(189,0,38)'], 7: ['rgb(255,255,178)', 'rgb(254,217,118)', 'rgb(254,178,76)', 'rgb(253,141,60)', 'rgb(252,78,42)', 'rgb(227,26,28)', 'rgb(177,0,38)'], 8: ['rgb(255,255,204)', 'rgb(255,237,160)', 'rgb(254,217,118)', 'rgb(254,178,76)', 'rgb(253,141,60)', 'rgb(252,78,42)', 'rgb(227,26,28)', 'rgb(177,0,38)'], 9: ['rgb(255,255,204)', 'rgb(255,237,160)', 'rgb(254,217,118)', 'rgb(254,178,76)', 'rgb(253,141,60)', 'rgb(252,78,42)', 'rgb(227,26,28)', 'rgb(189,0,38)', 'rgb(128,0,38)'] },
        };
        return colorPalettesClass;
    }());
    beachParty.colorPalettesClass = colorPalettesClass;
    (function (KnownPalettes) {
        //---- diverging ----
        KnownPalettes[KnownPalettes["Spectral"] = 0] = "Spectral";
        KnownPalettes[KnownPalettes["RdYlGn"] = 1] = "RdYlGn";
        KnownPalettes[KnownPalettes["RdBu"] = 2] = "RdBu";
        KnownPalettes[KnownPalettes["PiYG"] = 3] = "PiYG";
        KnownPalettes[KnownPalettes["PRGn"] = 4] = "PRGn";
        KnownPalettes[KnownPalettes["RdYlBu"] = 5] = "RdYlBu";
        KnownPalettes[KnownPalettes["BrBG"] = 6] = "BrBG";
        KnownPalettes[KnownPalettes["RdGy"] = 7] = "RdGy";
        KnownPalettes[KnownPalettes["PuOr"] = 8] = "PuOr";
        KnownPalettes[KnownPalettes["separator1"] = 9] = "separator1";
        //---- sequential ----
        KnownPalettes[KnownPalettes["Blues"] = 10] = "Blues";
        KnownPalettes[KnownPalettes["Greens"] = 11] = "Greens";
        KnownPalettes[KnownPalettes["Greys"] = 12] = "Greys";
        KnownPalettes[KnownPalettes["Oranges"] = 13] = "Oranges";
        KnownPalettes[KnownPalettes["Purples"] = 14] = "Purples";
        KnownPalettes[KnownPalettes["Reds"] = 15] = "Reds";
        KnownPalettes[KnownPalettes["separator2"] = 16] = "separator2";
        KnownPalettes[KnownPalettes["BuGn"] = 17] = "BuGn";
        KnownPalettes[KnownPalettes["BuPu"] = 18] = "BuPu";
        KnownPalettes[KnownPalettes["GnBu"] = 19] = "GnBu";
        KnownPalettes[KnownPalettes["OrRd"] = 20] = "OrRd";
        KnownPalettes[KnownPalettes["PuBu"] = 21] = "PuBu";
        KnownPalettes[KnownPalettes["PuBuGn"] = 22] = "PuBuGn";
        KnownPalettes[KnownPalettes["separator3"] = 23] = "separator3";
        KnownPalettes[KnownPalettes["PuRd"] = 24] = "PuRd";
        KnownPalettes[KnownPalettes["RdPu"] = 25] = "RdPu";
        KnownPalettes[KnownPalettes["YlGn"] = 26] = "YlGn";
        KnownPalettes[KnownPalettes["YlGnBu"] = 27] = "YlGnBu";
        KnownPalettes[KnownPalettes["YlOrBu"] = 28] = "YlOrBu";
        KnownPalettes[KnownPalettes["YlOrRd"] = 29] = "YlOrRd";
        KnownPalettes[KnownPalettes["separator4"] = 30] = "separator4";
        //---- qualitative ----
        KnownPalettes[KnownPalettes["Accent"] = 31] = "Accent";
        KnownPalettes[KnownPalettes["Dark2"] = 32] = "Dark2";
        KnownPalettes[KnownPalettes["Paired"] = 33] = "Paired";
        KnownPalettes[KnownPalettes["Pastel1"] = 34] = "Pastel1";
        KnownPalettes[KnownPalettes["Pastel2"] = 35] = "Pastel2";
        KnownPalettes[KnownPalettes["Set1"] = 36] = "Set1";
        KnownPalettes[KnownPalettes["Set2"] = 37] = "Set2";
        KnownPalettes[KnownPalettes["Set3"] = 38] = "Set3";
    })(beachParty.KnownPalettes // for UI access to palettes
     || (beachParty.KnownPalettes // for UI access to palettes
     = {}));
    var KnownPalettes // for UI access to palettes
     = beachParty.KnownPalettes // for UI access to palettes
    ;
})(beachParty || (beachParty = {}));
var beachParty;
(function (beachParty) {
    var colorTest = (function () {
        function colorTest() {
        }
        colorTest.colorBrewerSchemesEx = {
            // "Note": These 3 members were not part of the original colorbrewer_schemes.js 
            "divergingColorSchemes": ["Spectral", "RdYlGn", "RdBu", "PiYG", "PRGn", "RdYlBu", "BrBG", "RdGy", "PuOr"],
            //"qualitativeColorSchemesOld": ["Khronos", "Accent", "Dark2", "Pastel2", "Set2", "Pastel1", "Set1", "Paired", "Set3"], // MUST be ordered by number of palettes
            "qualitativeColorSchemes": ["Set3", "Paired", "Set1", "Pastel1", "Set2", "Pastel2", "Dark2", "Accent", "Khronos"],
            "sequentialColorSchemes": ["Blues", "Greens", "Greys", "Oranges", "Purples", "Reds", "BuGn", "BuPu", "GnBu", "OrRd", "PuBu", "PuBuGn",
                "PuRd", "RdPu", "YlGn", "YlGnBu", "YlOrBu", "YlOrRd"],
            "customColorSchemes": ["SpectralEx", "RedGreen", "RedBlue"],
            // Diverging color schemes [all palettes have 2..11 colors]
            "Spectral": { "2": ["rgb(252,141,89)", "rgb(153,213,148)"], "3": ["rgb(252,141,89)", "rgb(255,255,191)", "rgb(153,213,148)"], "4": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(171,221,164)", "rgb(43,131,186)"], "5": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(255,255,191)", "rgb(171,221,164)", "rgb(43,131,186)"], "6": ["rgb(213,62,79)", "rgb(252,141,89)", "rgb(254,224,139)", "rgb(230,245,152)", "rgb(153,213,148)", "rgb(50,136,189)"], "7": ["rgb(213,62,79)", "rgb(252,141,89)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(230,245,152)", "rgb(153,213,148)", "rgb(50,136,189)"], "8": ["rgb(213,62,79)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(50,136,189)"], "9": ["rgb(213,62,79)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(50,136,189)"], "10": ["rgb(158,1,66)", "rgb(213,62,79)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(50,136,189)", "rgb(94,79,162)"], "11": ["rgb(158,1,66)", "rgb(213,62,79)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(50,136,189)", "rgb(94,79,162)"] },
            "RdYlGn": { "2": ["rgb(252,141,89)", "rgb(145,207,96)"], "3": ["rgb(252,141,89)", "rgb(255,255,191)", "rgb(145,207,96)"], "4": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(166,217,106)", "rgb(26,150,65)"], "5": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(255,255,191)", "rgb(166,217,106)", "rgb(26,150,65)"], "6": ["rgb(215,48,39)", "rgb(252,141,89)", "rgb(254,224,139)", "rgb(217,239,139)", "rgb(145,207,96)", "rgb(26,152,80)"], "7": ["rgb(215,48,39)", "rgb(252,141,89)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(217,239,139)", "rgb(145,207,96)", "rgb(26,152,80)"], "8": ["rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(217,239,139)", "rgb(166,217,106)", "rgb(102,189,99)", "rgb(26,152,80)"], "9": ["rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(217,239,139)", "rgb(166,217,106)", "rgb(102,189,99)", "rgb(26,152,80)"], "10": ["rgb(165,0,38)", "rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(217,239,139)", "rgb(166,217,106)", "rgb(102,189,99)", "rgb(26,152,80)", "rgb(0,104,55)"], "11": ["rgb(165,0,38)", "rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(217,239,139)", "rgb(166,217,106)", "rgb(102,189,99)", "rgb(26,152,80)", "rgb(0,104,55)"] },
            "RdBu": { "2": ["rgb(239,138,98)", "rgb(103,169,207)"], "3": ["rgb(239,138,98)", "rgb(247,247,247)", "rgb(103,169,207)"], "4": ["rgb(202,0,32)", "rgb(244,165,130)", "rgb(146,197,222)", "rgb(5,113,176)"], "5": ["rgb(202,0,32)", "rgb(244,165,130)", "rgb(247,247,247)", "rgb(146,197,222)", "rgb(5,113,176)"], "6": ["rgb(178,24,43)", "rgb(239,138,98)", "rgb(253,219,199)", "rgb(209,229,240)", "rgb(103,169,207)", "rgb(33,102,172)"], "7": ["rgb(178,24,43)", "rgb(239,138,98)", "rgb(253,219,199)", "rgb(247,247,247)", "rgb(209,229,240)", "rgb(103,169,207)", "rgb(33,102,172)"], "8": ["rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(209,229,240)", "rgb(146,197,222)", "rgb(67,147,195)", "rgb(33,102,172)"], "9": ["rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(247,247,247)", "rgb(209,229,240)", "rgb(146,197,222)", "rgb(67,147,195)", "rgb(33,102,172)"], "10": ["rgb(103,0,31)", "rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(209,229,240)", "rgb(146,197,222)", "rgb(67,147,195)", "rgb(33,102,172)", "rgb(5,48,97)"], "11": ["rgb(103,0,31)", "rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(247,247,247)", "rgb(209,229,240)", "rgb(146,197,222)", "rgb(67,147,195)", "rgb(33,102,172)", "rgb(5,48,97)"] },
            "PiYG": { "2": ["rgb(233,163,201)", "rgb(161,215,106)"], "3": ["rgb(233,163,201)", "rgb(247,247,247)", "rgb(161,215,106)"], "4": ["rgb(208,28,139)", "rgb(241,182,218)", "rgb(184,225,134)", "rgb(77,172,38)"], "5": ["rgb(208,28,139)", "rgb(241,182,218)", "rgb(247,247,247)", "rgb(184,225,134)", "rgb(77,172,38)"], "6": ["rgb(197,27,125)", "rgb(233,163,201)", "rgb(253,224,239)", "rgb(230,245,208)", "rgb(161,215,106)", "rgb(77,146,33)"], "7": ["rgb(197,27,125)", "rgb(233,163,201)", "rgb(253,224,239)", "rgb(247,247,247)", "rgb(230,245,208)", "rgb(161,215,106)", "rgb(77,146,33)"], "8": ["rgb(197,27,125)", "rgb(222,119,174)", "rgb(241,182,218)", "rgb(253,224,239)", "rgb(230,245,208)", "rgb(184,225,134)", "rgb(127,188,65)", "rgb(77,146,33)"], "9": ["rgb(197,27,125)", "rgb(222,119,174)", "rgb(241,182,218)", "rgb(253,224,239)", "rgb(247,247,247)", "rgb(230,245,208)", "rgb(184,225,134)", "rgb(127,188,65)", "rgb(77,146,33)"], "10": ["rgb(142,1,82)", "rgb(197,27,125)", "rgb(222,119,174)", "rgb(241,182,218)", "rgb(253,224,239)", "rgb(230,245,208)", "rgb(184,225,134)", "rgb(127,188,65)", "rgb(77,146,33)", "rgb(39,100,25)"], "11": ["rgb(142,1,82)", "rgb(197,27,125)", "rgb(222,119,174)", "rgb(241,182,218)", "rgb(253,224,239)", "rgb(247,247,247)", "rgb(230,245,208)", "rgb(184,225,134)", "rgb(127,188,65)", "rgb(77,146,33)", "rgb(39,100,25)"] },
            "PRGn": { "2": ["rgb(175,141,195)", "rgb(127,191,123)"], "3": ["rgb(175,141,195)", "rgb(247,247,247)", "rgb(127,191,123)"], "4": ["rgb(123,50,148)", "rgb(194,165,207)", "rgb(166,219,160)", "rgb(0,136,55)"], "5": ["rgb(123,50,148)", "rgb(194,165,207)", "rgb(247,247,247)", "rgb(166,219,160)", "rgb(0,136,55)"], "6": ["rgb(118,42,131)", "rgb(175,141,195)", "rgb(231,212,232)", "rgb(217,240,211)", "rgb(127,191,123)", "rgb(27,120,55)"], "7": ["rgb(118,42,131)", "rgb(175,141,195)", "rgb(231,212,232)", "rgb(247,247,247)", "rgb(217,240,211)", "rgb(127,191,123)", "rgb(27,120,55)"], "8": ["rgb(118,42,131)", "rgb(153,112,171)", "rgb(194,165,207)", "rgb(231,212,232)", "rgb(217,240,211)", "rgb(166,219,160)", "rgb(90,174,97)", "rgb(27,120,55)"], "9": ["rgb(118,42,131)", "rgb(153,112,171)", "rgb(194,165,207)", "rgb(231,212,232)", "rgb(247,247,247)", "rgb(217,240,211)", "rgb(166,219,160)", "rgb(90,174,97)", "rgb(27,120,55)"], "10": ["rgb(64,0,75)", "rgb(118,42,131)", "rgb(153,112,171)", "rgb(194,165,207)", "rgb(231,212,232)", "rgb(217,240,211)", "rgb(166,219,160)", "rgb(90,174,97)", "rgb(27,120,55)", "rgb(0,68,27)"], "11": ["rgb(64,0,75)", "rgb(118,42,131)", "rgb(153,112,171)", "rgb(194,165,207)", "rgb(231,212,232)", "rgb(247,247,247)", "rgb(217,240,211)", "rgb(166,219,160)", "rgb(90,174,97)", "rgb(27,120,55)", "rgb(0,68,27)"] },
            "RdYlBu": { "2": ["rgb(252,141,89)", "rgb(145,191,219)"], "3": ["rgb(252,141,89)", "rgb(255,255,191)", "rgb(145,191,219)"], "4": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(171,217,233)", "rgb(44,123,182)"], "5": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(255,255,191)", "rgb(171,217,233)", "rgb(44,123,182)"], "6": ["rgb(215,48,39)", "rgb(252,141,89)", "rgb(254,224,144)", "rgb(224,243,248)", "rgb(145,191,219)", "rgb(69,117,180)"], "7": ["rgb(215,48,39)", "rgb(252,141,89)", "rgb(254,224,144)", "rgb(255,255,191)", "rgb(224,243,248)", "rgb(145,191,219)", "rgb(69,117,180)"], "8": ["rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,144)", "rgb(224,243,248)", "rgb(171,217,233)", "rgb(116,173,209)", "rgb(69,117,180)"], "9": ["rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,144)", "rgb(255,255,191)", "rgb(224,243,248)", "rgb(171,217,233)", "rgb(116,173,209)", "rgb(69,117,180)"], "10": ["rgb(165,0,38)", "rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,144)", "rgb(224,243,248)", "rgb(171,217,233)", "rgb(116,173,209)", "rgb(69,117,180)", "rgb(49,54,149)"], "11": ["rgb(165,0,38)", "rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,144)", "rgb(255,255,191)", "rgb(224,243,248)", "rgb(171,217,233)", "rgb(116,173,209)", "rgb(69,117,180)", "rgb(49,54,149)"] },
            "BrBG": { "2": ["rgb(216,179,101)", "rgb(90,180,172)"], "3": ["rgb(216,179,101)", "rgb(245,245,245)", "rgb(90,180,172)"], "4": ["rgb(166,97,26)", "rgb(223,194,125)", "rgb(128,205,193)", "rgb(1,133,113)"], "5": ["rgb(166,97,26)", "rgb(223,194,125)", "rgb(245,245,245)", "rgb(128,205,193)", "rgb(1,133,113)"], "6": ["rgb(140,81,10)", "rgb(216,179,101)", "rgb(246,232,195)", "rgb(199,234,229)", "rgb(90,180,172)", "rgb(1,102,94)"], "7": ["rgb(140,81,10)", "rgb(216,179,101)", "rgb(246,232,195)", "rgb(245,245,245)", "rgb(199,234,229)", "rgb(90,180,172)", "rgb(1,102,94)"], "8": ["rgb(140,81,10)", "rgb(191,129,45)", "rgb(223,194,125)", "rgb(246,232,195)", "rgb(199,234,229)", "rgb(128,205,193)", "rgb(53,151,143)", "rgb(1,102,94)"], "9": ["rgb(140,81,10)", "rgb(191,129,45)", "rgb(223,194,125)", "rgb(246,232,195)", "rgb(245,245,245)", "rgb(199,234,229)", "rgb(128,205,193)", "rgb(53,151,143)", "rgb(1,102,94)"], "10": ["rgb(84,48,5)", "rgb(140,81,10)", "rgb(191,129,45)", "rgb(223,194,125)", "rgb(246,232,195)", "rgb(199,234,229)", "rgb(128,205,193)", "rgb(53,151,143)", "rgb(1,102,94)", "rgb(0,60,48)"], "11": ["rgb(84,48,5)", "rgb(140,81,10)", "rgb(191,129,45)", "rgb(223,194,125)", "rgb(246,232,195)", "rgb(245,245,245)", "rgb(199,234,229)", "rgb(128,205,193)", "rgb(53,151,143)", "rgb(1,102,94)", "rgb(0,60,48)"] },
            "RdGy": { "2": ["rgb(239,138,98)", "rgb(153,153,153)"], "3": ["rgb(239,138,98)", "rgb(255,255,255)", "rgb(153,153,153)"], "4": ["rgb(202,0,32)", "rgb(244,165,130)", "rgb(186,186,186)", "rgb(64,64,64)"], "5": ["rgb(202,0,32)", "rgb(244,165,130)", "rgb(255,255,255)", "rgb(186,186,186)", "rgb(64,64,64)"], "6": ["rgb(178,24,43)", "rgb(239,138,98)", "rgb(253,219,199)", "rgb(224,224,224)", "rgb(153,153,153)", "rgb(77,77,77)"], "7": ["rgb(178,24,43)", "rgb(239,138,98)", "rgb(253,219,199)", "rgb(255,255,255)", "rgb(224,224,224)", "rgb(153,153,153)", "rgb(77,77,77)"], "8": ["rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(224,224,224)", "rgb(186,186,186)", "rgb(135,135,135)", "rgb(77,77,77)"], "9": ["rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(255,255,255)", "rgb(224,224,224)", "rgb(186,186,186)", "rgb(135,135,135)", "rgb(77,77,77)"], "10": ["rgb(103,0,31)", "rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(224,224,224)", "rgb(186,186,186)", "rgb(135,135,135)", "rgb(77,77,77)", "rgb(26,26,26)"], "11": ["rgb(103,0,31)", "rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(255,255,255)", "rgb(224,224,224)", "rgb(186,186,186)", "rgb(135,135,135)", "rgb(77,77,77)", "rgb(26,26,26)"] },
            "PuOr": { "2": ["rgb(241,163,64)", "rgb(153,142,195)"], "3": ["rgb(241,163,64)", "rgb(247,247,247)", "rgb(153,142,195)"], "4": ["rgb(230,97,1)", "rgb(253,184,99)", "rgb(178,171,210)", "rgb(94,60,153)"], "5": ["rgb(230,97,1)", "rgb(253,184,99)", "rgb(247,247,247)", "rgb(178,171,210)", "rgb(94,60,153)"], "6": ["rgb(179,88,6)", "rgb(241,163,64)", "rgb(254,224,182)", "rgb(216,218,235)", "rgb(153,142,195)", "rgb(84,39,136)"], "7": ["rgb(179,88,6)", "rgb(241,163,64)", "rgb(254,224,182)", "rgb(247,247,247)", "rgb(216,218,235)", "rgb(153,142,195)", "rgb(84,39,136)"], "8": ["rgb(179,88,6)", "rgb(224,130,20)", "rgb(253,184,99)", "rgb(254,224,182)", "rgb(216,218,235)", "rgb(178,171,210)", "rgb(128,115,172)", "rgb(84,39,136)"], "9": ["rgb(179,88,6)", "rgb(224,130,20)", "rgb(253,184,99)", "rgb(254,224,182)", "rgb(247,247,247)", "rgb(216,218,235)", "rgb(178,171,210)", "rgb(128,115,172)", "rgb(84,39,136)"], "10": ["rgb(127,59,8)", "rgb(179,88,6)", "rgb(224,130,20)", "rgb(253,184,99)", "rgb(254,224,182)", "rgb(216,218,235)", "rgb(178,171,210)", "rgb(128,115,172)", "rgb(84,39,136)", "rgb(45,0,75)"], "11": ["rgb(127,59,8)", "rgb(179,88,6)", "rgb(224,130,20)", "rgb(253,184,99)", "rgb(254,224,182)", "rgb(247,247,247)", "rgb(216,218,235)", "rgb(178,171,210)", "rgb(128,115,172)", "rgb(84,39,136)", "rgb(45,0,75)"] },
            // custom schemes
            "SpectralEx": { "2": ["rgb(215,25,28)", "rgb(43,131,186)"], "3": ["rgb(215,25,28)", "rgb(255,255,191)", "rgb(43,131,186)"], "4": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(171,221,164)", "rgb(43,131,186)"], "5": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(255,255,191)", "rgb(171,221,164)", "rgb(43,131,186)"], "6": ["rgb(215,25,28)", "rgb(252,141,89)", "rgb(254,224,139)", "rgb(230,245,152)", "rgb(153,213,148)", "rgb(43,131,186)"], "7": ["rgb(215,25,28)", "rgb(252,141,89)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(230,245,152)", "rgb(153,213,148)", "rgb(43,131,186)"], "8": ["rgb(215,25,28)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(43,131,186)"], "9": ["rgb(215,25,28)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(43,131,186)"], "10": ["rgb(215,25,28)", "rgb(213,62,79)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(50,136,189)", "rgb(43,131,186)"], "11": ["rgb(215,25,28)", "rgb(213,62,79)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(50,136,189)", "rgb(43,131,186)"] },
            "RedGreen": { "2": ["rgb(255, 0, 0)", "rgb(127, 255, 127)"] },
            "RedBlue": { "2": ["rgb(255, 0, 0)", "rgb(0, 0, 255)"] },
            // Qualitative color schemes
            // [Palettes with 2..6 colors]
            "Khronos": { "2": ["rgb(157,190,127)", "rgb(255,255,255)"], "3": ["rgb(157,190,127)", "rgb(232,109,113)", "rgb(255,255,255)"], "4": ["rgb(157,190,127)", "rgb(232,109,113)", "rgb(194,195,178)", "rgb(255,255,255)"], "5": ["rgb(157,190,127)", "rgb(232,109,113)", "rgb(252,238,78)", "rgb(238,160,41)", "rgb(255,255,255)"], "6": ["rgb(157,190,127)", "rgb(232,109,113)", "rgb(252,238,78)", "rgb(238,160,41)", "rgb(194,195,178)", "rgb(255,255,255)"] },
            "Accent": { "2": ["rgb(127,201,127)", "rgb(190,174,212)"], "3": ["rgb(127,201,127)", "rgb(190,174,212)", "rgb(253,192,134)"], "4": ["rgb(127,201,127)", "rgb(190,174,212)", "rgb(253,192,134)", "rgb(255,255,153)"], "5": ["rgb(127,201,127)", "rgb(190,174,212)", "rgb(253,192,134)", "rgb(255,255,153)", "rgb(56,108,176)"], "6": ["rgb(127,201,127)", "rgb(190,174,212)", "rgb(253,192,134)", "rgb(255,255,153)", "rgb(56,108,176)", "rgb(240,2,127)"], "7": ["rgb(127,201,127)", "rgb(190,174,212)", "rgb(253,192,134)", "rgb(255,255,153)", "rgb(56,108,176)", "rgb(240,2,127)", "rgb(191,91,23)"], "8": ["rgb(127,201,127)", "rgb(190,174,212)", "rgb(253,192,134)", "rgb(255,255,153)", "rgb(56,108,176)", "rgb(240,2,127)", "rgb(191,91,23)", "rgb(102,102,102)"] },
            "Dark2": { "2": ["rgb(27,158,119)", "rgb(217,95,2)"], "3": ["rgb(27,158,119)", "rgb(217,95,2)", "rgb(117,112,179)"], "4": ["rgb(27,158,119)", "rgb(217,95,2)", "rgb(117,112,179)", "rgb(231,41,138)"], "5": ["rgb(27,158,119)", "rgb(217,95,2)", "rgb(117,112,179)", "rgb(231,41,138)", "rgb(102,166,30)"], "6": ["rgb(27,158,119)", "rgb(217,95,2)", "rgb(117,112,179)", "rgb(231,41,138)", "rgb(102,166,30)", "rgb(230,171,2)"], "7": ["rgb(27,158,119)", "rgb(217,95,2)", "rgb(117,112,179)", "rgb(231,41,138)", "rgb(102,166,30)", "rgb(230,171,2)", "rgb(166,118,29)"], "8": ["rgb(27,158,119)", "rgb(217,95,2)", "rgb(117,112,179)", "rgb(231,41,138)", "rgb(102,166,30)", "rgb(230,171,2)", "rgb(166,118,29)", "rgb(102,102,102)"] },
            "Pastel2": { "2": ["rgb(179,226,205)", "rgb(253,205,172)"], "3": ["rgb(179,226,205)", "rgb(253,205,172)", "rgb(203,213,232)"], "4": ["rgb(179,226,205)", "rgb(253,205,172)", "rgb(203,213,232)", "rgb(244,202,228)"], "5": ["rgb(179,226,205)", "rgb(253,205,172)", "rgb(203,213,232)", "rgb(244,202,228)", "rgb(230,245,201)"], "6": ["rgb(179,226,205)", "rgb(253,205,172)", "rgb(203,213,232)", "rgb(244,202,228)", "rgb(230,245,201)", "rgb(255,242,174)"], "7": ["rgb(179,226,205)", "rgb(253,205,172)", "rgb(203,213,232)", "rgb(244,202,228)", "rgb(230,245,201)", "rgb(255,242,174)", "rgb(241,226,204)"], "8": ["rgb(179,226,205)", "rgb(253,205,172)", "rgb(203,213,232)", "rgb(244,202,228)", "rgb(230,245,201)", "rgb(255,242,174)", "rgb(241,226,204)", "rgb(204,204,204)"] },
            "Set2": { "2": ["rgb(102,194,165)", "rgb(252,141,98)"], "3": ["rgb(102,194,165)", "rgb(252,141,98)", "rgb(141,160,203)"], "4": ["rgb(102,194,165)", "rgb(252,141,98)", "rgb(141,160,203)", "rgb(231,138,195)"], "5": ["rgb(102,194,165)", "rgb(252,141,98)", "rgb(141,160,203)", "rgb(231,138,195)", "rgb(166,216,84)"], "6": ["rgb(102,194,165)", "rgb(252,141,98)", "rgb(141,160,203)", "rgb(231,138,195)", "rgb(166,216,84)", "rgb(255,217,47)"], "7": ["rgb(102,194,165)", "rgb(252,141,98)", "rgb(141,160,203)", "rgb(231,138,195)", "rgb(166,216,84)", "rgb(255,217,47)", "rgb(229,196,148)"], "8": ["rgb(102,194,165)", "rgb(252,141,98)", "rgb(141,160,203)", "rgb(231,138,195)", "rgb(166,216,84)", "rgb(255,217,47)", "rgb(229,196,148)", "rgb(179,179,179)"] },
            "Pastel1": { "2": ["rgb(251,180,174)", "rgb(179,205,227)"], "3": ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)"], "4": ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)", "rgb(222,203,228)"], "5": ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)", "rgb(222,203,228)", "rgb(254,217,166)"], "6": ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)", "rgb(222,203,228)", "rgb(254,217,166)", "rgb(255,255,204)"], "7": ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)", "rgb(222,203,228)", "rgb(254,217,166)", "rgb(255,255,204)", "rgb(229,216,189)"], "8": ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)", "rgb(222,203,228)", "rgb(254,217,166)", "rgb(255,255,204)", "rgb(229,216,189)", "rgb(253,218,236)"], "9": ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)", "rgb(222,203,228)", "rgb(254,217,166)", "rgb(255,255,204)", "rgb(229,216,189)", "rgb(253,218,236)", "rgb(242,242,242)"] },
            "Set1": { "2": ["rgb(228,26,28)", "rgb(55,126,184)"], "3": ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)"], "4": ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)", "rgb(152,78,163)"], "5": ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)", "rgb(152,78,163)", "rgb(255,127,0)"], "6": ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)", "rgb(152,78,163)", "rgb(255,127,0)", "rgb(255,255,51)"], "7": ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)", "rgb(152,78,163)", "rgb(255,127,0)", "rgb(255,255,51)", "rgb(166,86,40)"], "8": ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)", "rgb(152,78,163)", "rgb(255,127,0)", "rgb(255,255,51)", "rgb(166,86,40)", "rgb(247,129,191)"], "9": ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)", "rgb(152,78,163)", "rgb(255,127,0)", "rgb(255,255,51)", "rgb(166,86,40)", "rgb(247,129,191)", "rgb(153,153,153)"] },
            "Paired": { "2": ["rgb(166,206,227)", "rgb(31,120,180)"], "3": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)"], "4": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)"], "5": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)"], "6": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)", "rgb(227,26,28)"], "7": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)", "rgb(227,26,28)", "rgb(253,191,111)"], "8": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)", "rgb(227,26,28)", "rgb(253,191,111)", "rgb(255,127,0)"], "9": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)", "rgb(227,26,28)", "rgb(253,191,111)", "rgb(255,127,0)", "rgb(202,178,214)"], "10": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)", "rgb(227,26,28)", "rgb(253,191,111)", "rgb(255,127,0)", "rgb(202,178,214)", "rgb(106,61,154)"], "11": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)", "rgb(227,26,28)", "rgb(253,191,111)", "rgb(255,127,0)", "rgb(202,178,214)", "rgb(106,61,154)", "rgb(255,255,153)"], "12": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)", "rgb(227,26,28)", "rgb(253,191,111)", "rgb(255,127,0)", "rgb(202,178,214)", "rgb(106,61,154)", "rgb(255,255,153)", "rgb(177,89,40)"] },
            "Set3": { "2": ["rgb(141,211,199)", "rgb(255,255,179)"], "3": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)"], "4": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)"], "5": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)"], "6": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)"], "7": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)", "rgb(179,222,105)"], "8": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)", "rgb(179,222,105)", "rgb(252,205,229)"], "9": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)", "rgb(179,222,105)", "rgb(252,205,229)", "rgb(217,217,217)"], "10": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)", "rgb(179,222,105)", "rgb(252,205,229)", "rgb(217,217,217)", "rgb(188,128,189)"], "11": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)", "rgb(179,222,105)", "rgb(252,205,229)", "rgb(217,217,217)", "rgb(188,128,189)", "rgb(204,235,197)"], "12": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)", "rgb(179,222,105)", "rgb(252,205,229)", "rgb(217,217,217)", "rgb(188,128,189)", "rgb(204,235,197)", "rgb(255,237,111)"] },
            // Sequential color schemes [all palettes have 2..9 colors]
            "Blues": { "2": ["rgb(222,235,247)", "rgb(158,202,225)"], "3": ["rgb(222,235,247)", "rgb(158,202,225)", "rgb(49,130,189)"], "4": ["rgb(239,243,255)", "rgb(189,215,231)", "rgb(107,174,214)", "rgb(33,113,181)"], "5": ["rgb(239,243,255)", "rgb(189,215,231)", "rgb(107,174,214)", "rgb(49,130,189)", "rgb(8,81,156)"], "6": ["rgb(239,243,255)", "rgb(198,219,239)", "rgb(158,202,225)", "rgb(107,174,214)", "rgb(49,130,189)", "rgb(8,81,156)"], "7": ["rgb(239,243,255)", "rgb(198,219,239)", "rgb(158,202,225)", "rgb(107,174,214)", "rgb(66,146,198)", "rgb(33,113,181)", "rgb(8,69,148)"], "8": ["rgb(247,251,255)", "rgb(222,235,247)", "rgb(198,219,239)", "rgb(158,202,225)", "rgb(107,174,214)", "rgb(66,146,198)", "rgb(33,113,181)", "rgb(8,69,148)"], "9": ["rgb(247,251,255)", "rgb(222,235,247)", "rgb(198,219,239)", "rgb(158,202,225)", "rgb(107,174,214)", "rgb(66,146,198)", "rgb(33,113,181)", "rgb(8,81,156)", "rgb(8,48,107)"] },
            "Greens": { "2": ["rgb(229,245,224)", "rgb(161,217,155)"], "3": ["rgb(229,245,224)", "rgb(161,217,155)", "rgb(49,163,84)"], "4": ["rgb(237,248,233)", "rgb(186,228,179)", "rgb(116,196,118)", "rgb(35,139,69)"], "5": ["rgb(237,248,233)", "rgb(186,228,179)", "rgb(116,196,118)", "rgb(49,163,84)", "rgb(0,109,44)"], "6": ["rgb(237,248,233)", "rgb(199,233,192)", "rgb(161,217,155)", "rgb(116,196,118)", "rgb(49,163,84)", "rgb(0,109,44)"], "7": ["rgb(237,248,233)", "rgb(199,233,192)", "rgb(161,217,155)", "rgb(116,196,118)", "rgb(65,171,93)", "rgb(35,139,69)", "rgb(0,90,50)"], "8": ["rgb(247,252,245)", "rgb(229,245,224)", "rgb(199,233,192)", "rgb(161,217,155)", "rgb(116,196,118)", "rgb(65,171,93)", "rgb(35,139,69)", "rgb(0,90,50)"], "9": ["rgb(247,252,245)", "rgb(229,245,224)", "rgb(199,233,192)", "rgb(161,217,155)", "rgb(116,196,118)", "rgb(65,171,93)", "rgb(35,139,69)", "rgb(0,109,44)", "rgb(0,68,27)"] },
            "Greys": { "2": ["rgb(240,240,240)", "rgb(189,189,189)"], "3": ["rgb(240,240,240)", "rgb(189,189,189)", "rgb(99,99,99)"], "4": ["rgb(247,247,247)", "rgb(204,204,204)", "rgb(150,150,150)", "rgb(82,82,82)"], "5": ["rgb(247,247,247)", "rgb(204,204,204)", "rgb(150,150,150)", "rgb(99,99,99)", "rgb(37,37,37)"], "6": ["rgb(247,247,247)", "rgb(217,217,217)", "rgb(189,189,189)", "rgb(150,150,150)", "rgb(99,99,99)", "rgb(37,37,37)"], "7": ["rgb(247,247,247)", "rgb(217,217,217)", "rgb(189,189,189)", "rgb(150,150,150)", "rgb(115,115,115)", "rgb(82,82,82)", "rgb(37,37,37)"], "8": ["rgb(255,255,255)", "rgb(240,240,240)", "rgb(217,217,217)", "rgb(189,189,189)", "rgb(150,150,150)", "rgb(115,115,115)", "rgb(82,82,82)", "rgb(37,37,37)"], "9": ["rgb(255,255,255)", "rgb(227,227,227)", "rgb(200,200,200)", "rgb(145,145,145)", "rgb(127,127,127)", "rgb(117,117,117)", "rgb(89,89,89)", "rgb(62,62,62)", "rgb(34,34,34)"] },
            "Oranges": { "2": ["rgb(254,230,206)", "rgb(253,174,107)"], "3": ["rgb(254,230,206)", "rgb(253,174,107)", "rgb(230,85,13)"], "4": ["rgb(254,237,222)", "rgb(253,190,133)", "rgb(253,141,60)", "rgb(217,71,1)"], "5": ["rgb(254,237,222)", "rgb(253,190,133)", "rgb(253,141,60)", "rgb(230,85,13)", "rgb(166,54,3)"], "6": ["rgb(254,237,222)", "rgb(253,208,162)", "rgb(253,174,107)", "rgb(253,141,60)", "rgb(230,85,13)", "rgb(166,54,3)"], "7": ["rgb(254,237,222)", "rgb(253,208,162)", "rgb(253,174,107)", "rgb(253,141,60)", "rgb(241,105,19)", "rgb(217,72,1)", "rgb(140,45,4)"], "8": ["rgb(255,245,235)", "rgb(254,230,206)", "rgb(253,208,162)", "rgb(253,174,107)", "rgb(253,141,60)", "rgb(241,105,19)", "rgb(217,72,1)", "rgb(140,45,4)"], "9": ["rgb(255,245,235)", "rgb(254,230,206)", "rgb(253,208,162)", "rgb(253,174,107)", "rgb(253,141,60)", "rgb(241,105,19)", "rgb(217,72,1)", "rgb(166,54,3)", "rgb(127,39,4)"] },
            "Purples": { "2": ["rgb(239,237,245)", "rgb(188,189,220)"], "3": ["rgb(239,237,245)", "rgb(188,189,220)", "rgb(117,107,177)"], "4": ["rgb(242,240,247)", "rgb(203,201,226)", "rgb(158,154,200)", "rgb(106,81,163)"], "5": ["rgb(242,240,247)", "rgb(203,201,226)", "rgb(158,154,200)", "rgb(117,107,177)", "rgb(84,39,143)"], "6": ["rgb(242,240,247)", "rgb(218,218,235)", "rgb(188,189,220)", "rgb(158,154,200)", "rgb(117,107,177)", "rgb(84,39,143)"], "7": ["rgb(242,240,247)", "rgb(218,218,235)", "rgb(188,189,220)", "rgb(158,154,200)", "rgb(128,125,186)", "rgb(106,81,163)", "rgb(74,20,134)"], "8": ["rgb(252,251,253)", "rgb(239,237,245)", "rgb(218,218,235)", "rgb(188,189,220)", "rgb(158,154,200)", "rgb(128,125,186)", "rgb(106,81,163)", "rgb(74,20,134)"], "9": ["rgb(252,251,253)", "rgb(239,237,245)", "rgb(218,218,235)", "rgb(188,189,220)", "rgb(158,154,200)", "rgb(128,125,186)", "rgb(106,81,163)", "rgb(84,39,143)", "rgb(63,0,125)"] },
            "Reds": { "2": ["rgb(254,224,210)", "rgb(252,146,114)"], "3": ["rgb(254,224,210)", "rgb(252,146,114)", "rgb(222,45,38)"], "4": ["rgb(254,229,217)", "rgb(252,174,145)", "rgb(251,106,74)", "rgb(203,24,29)"], "5": ["rgb(254,229,217)", "rgb(252,174,145)", "rgb(251,106,74)", "rgb(222,45,38)", "rgb(165,15,21)"], "6": ["rgb(254,229,217)", "rgb(252,187,161)", "rgb(252,146,114)", "rgb(251,106,74)", "rgb(222,45,38)", "rgb(165,15,21)"], "7": ["rgb(254,229,217)", "rgb(252,187,161)", "rgb(252,146,114)", "rgb(251,106,74)", "rgb(239,59,44)", "rgb(203,24,29)", "rgb(153,0,13)"], "8": ["rgb(255,245,240)", "rgb(254,224,210)", "rgb(252,187,161)", "rgb(252,146,114)", "rgb(251,106,74)", "rgb(239,59,44)", "rgb(203,24,29)", "rgb(153,0,13)"], "9": ["rgb(255,245,240)", "rgb(254,224,210)", "rgb(252,187,161)", "rgb(252,146,114)", "rgb(251,106,74)", "rgb(239,59,44)", "rgb(203,24,29)", "rgb(165,15,21)", "rgb(103,0,13)"] },
            "BuGn": { "2": ["rgb(229,245,249)", "rgb(153,216,201)"], "3": ["rgb(229,245,249)", "rgb(153,216,201)", "rgb(44,162,95)"], "4": ["rgb(237,248,251)", "rgb(178,226,226)", "rgb(102,194,164)", "rgb(35,139,69)"], "5": ["rgb(237,248,251)", "rgb(178,226,226)", "rgb(102,194,164)", "rgb(44,162,95)", "rgb(0,109,44)"], "6": ["rgb(237,248,251)", "rgb(204,236,230)", "rgb(153,216,201)", "rgb(102,194,164)", "rgb(44,162,95)", "rgb(0,109,44)"], "7": ["rgb(237,248,251)", "rgb(204,236,230)", "rgb(153,216,201)", "rgb(102,194,164)", "rgb(65,174,118)", "rgb(35,139,69)", "rgb(0,88,36)"], "8": ["rgb(247,252,253)", "rgb(229,245,249)", "rgb(204,236,230)", "rgb(153,216,201)", "rgb(102,194,164)", "rgb(65,174,118)", "rgb(35,139,69)", "rgb(0,88,36)"], "9": ["rgb(247,252,253)", "rgb(229,245,249)", "rgb(204,236,230)", "rgb(153,216,201)", "rgb(102,194,164)", "rgb(65,174,118)", "rgb(35,139,69)", "rgb(0,109,44)", "rgb(0,68,27)"] },
            "BuPu": { "2": ["rgb(224,236,244)", "rgb(136,86,167)"], "3": ["rgb(224,236,244)", "rgb(158,188,218)", "rgb(136,86,167)"], "4": ["rgb(237,248,251)", "rgb(179,205,227)", "rgb(140,150,198)", "rgb(136,65,157)"], "5": ["rgb(237,248,251)", "rgb(179,205,227)", "rgb(140,150,198)", "rgb(136,86,167)", "rgb(129,15,124)"], "6": ["rgb(237,248,251)", "rgb(191,211,230)", "rgb(158,188,218)", "rgb(140,150,198)", "rgb(136,86,167)", "rgb(129,15,124)"], "7": ["rgb(237,248,251)", "rgb(191,211,230)", "rgb(158,188,218)", "rgb(140,150,198)", "rgb(140,107,177)", "rgb(136,65,157)", "rgb(110,1,107)"], "8": ["rgb(247,252,253)", "rgb(224,236,244)", "rgb(191,211,230)", "rgb(158,188,218)", "rgb(140,150,198)", "rgb(140,107,177)", "rgb(136,65,157)", "rgb(110,1,107)"], "9": ["rgb(247,252,253)", "rgb(224,236,244)", "rgb(191,211,230)", "rgb(158,188,218)", "rgb(140,150,198)", "rgb(140,107,177)", "rgb(136,65,157)", "rgb(129,15,124)", "rgb(77,0,75)"] },
            "GnBu": { "2": ["rgb(224,243,219)", "rgb(168,221,181)"], "3": ["rgb(224,243,219)", "rgb(168,221,181)", "rgb(67,162,202)"], "4": ["rgb(240,249,232)", "rgb(186,228,188)", "rgb(123,204,196)", "rgb(43,140,190)"], "5": ["rgb(240,249,232)", "rgb(186,228,188)", "rgb(123,204,196)", "rgb(67,162,202)", "rgb(8,104,172)"], "6": ["rgb(240,249,232)", "rgb(204,235,197)", "rgb(168,221,181)", "rgb(123,204,196)", "rgb(67,162,202)", "rgb(8,104,172)"], "7": ["rgb(240,249,232)", "rgb(204,235,197)", "rgb(168,221,181)", "rgb(123,204,196)", "rgb(78,179,211)", "rgb(43,140,190)", "rgb(8,88,158)"], "8": ["rgb(247,252,240)", "rgb(224,243,219)", "rgb(204,235,197)", "rgb(168,221,181)", "rgb(123,204,196)", "rgb(78,179,211)", "rgb(43,140,190)", "rgb(8,88,158)"], "9": ["rgb(247,252,240)", "rgb(224,243,219)", "rgb(204,235,197)", "rgb(168,221,181)", "rgb(123,204,196)", "rgb(78,179,211)", "rgb(43,140,190)", "rgb(8,104,172)", "rgb(8,64,129)"] },
            "OrRd": { "2": ["rgb(254,232,200)", "rgb(253,187,132)"], "3": ["rgb(254,232,200)", "rgb(253,187,132)", "rgb(227,74,51)"], "4": ["rgb(254,240,217)", "rgb(253,204,138)", "rgb(252,141,89)", "rgb(215,48,31)"], "5": ["rgb(254,240,217)", "rgb(253,204,138)", "rgb(252,141,89)", "rgb(227,74,51)", "rgb(179,0,0)"], "6": ["rgb(254,240,217)", "rgb(253,212,158)", "rgb(253,187,132)", "rgb(252,141,89)", "rgb(227,74,51)", "rgb(179,0,0)"], "7": ["rgb(254,240,217)", "rgb(253,212,158)", "rgb(253,187,132)", "rgb(252,141,89)", "rgb(239,101,72)", "rgb(215,48,31)", "rgb(153,0,0)"], "8": ["rgb(255,247,236)", "rgb(254,232,200)", "rgb(253,212,158)", "rgb(253,187,132)", "rgb(252,141,89)", "rgb(239,101,72)", "rgb(215,48,31)", "rgb(153,0,0)"], "9": ["rgb(255,247,236)", "rgb(254,232,200)", "rgb(253,212,158)", "rgb(253,187,132)", "rgb(252,141,89)", "rgb(239,101,72)", "rgb(215,48,31)", "rgb(179,0,0)", "rgb(127,0,0)"] },
            "PuBu": { "2": ["rgb(236,231,242)", "rgb(166,189,219)"], "3": ["rgb(236,231,242)", "rgb(166,189,219)", "rgb(43,140,190)"], "4": ["rgb(241,238,246)", "rgb(189,201,225)", "rgb(116,169,207)", "rgb(5,112,176)"], "5": ["rgb(241,238,246)", "rgb(189,201,225)", "rgb(116,169,207)", "rgb(43,140,190)", "rgb(4,90,141)"], "6": ["rgb(241,238,246)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(116,169,207)", "rgb(43,140,190)", "rgb(4,90,141)"], "7": ["rgb(241,238,246)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(116,169,207)", "rgb(54,144,192)", "rgb(5,112,176)", "rgb(3,78,123)"], "8": ["rgb(255,247,251)", "rgb(236,231,242)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(116,169,207)", "rgb(54,144,192)", "rgb(5,112,176)", "rgb(3,78,123)"], "9": ["rgb(255,247,251)", "rgb(236,231,242)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(116,169,207)", "rgb(54,144,192)", "rgb(5,112,176)", "rgb(4,90,141)", "rgb(2,56,88)"] },
            "PuBuGn": { "2": ["rgb(236,226,240)", "rgb(166,189,219)"], "3": ["rgb(236,226,240)", "rgb(166,189,219)", "rgb(28,144,153)"], "4": ["rgb(246,239,247)", "rgb(189,201,225)", "rgb(103,169,207)", "rgb(2,129,138)"], "5": ["rgb(246,239,247)", "rgb(189,201,225)", "rgb(103,169,207)", "rgb(28,144,153)", "rgb(1,108,89)"], "6": ["rgb(246,239,247)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(103,169,207)", "rgb(28,144,153)", "rgb(1,108,89)"], "7": ["rgb(246,239,247)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(103,169,207)", "rgb(54,144,192)", "rgb(2,129,138)", "rgb(1,100,80)"], "8": ["rgb(255,247,251)", "rgb(236,226,240)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(103,169,207)", "rgb(54,144,192)", "rgb(2,129,138)", "rgb(1,100,80)"], "9": ["rgb(255,247,251)", "rgb(236,226,240)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(103,169,207)", "rgb(54,144,192)", "rgb(2,129,138)", "rgb(1,108,89)", "rgb(1,70,54)"] },
            "PuRd": { "2": ["rgb(231,225,239)", "rgb(201,148,199)"], "3": ["rgb(231,225,239)", "rgb(201,148,199)", "rgb(221,28,119)"], "4": ["rgb(241,238,246)", "rgb(215,181,216)", "rgb(223,101,176)", "rgb(206,18,86)"], "5": ["rgb(241,238,246)", "rgb(215,181,216)", "rgb(223,101,176)", "rgb(221,28,119)", "rgb(152,0,67)"], "6": ["rgb(241,238,246)", "rgb(212,185,218)", "rgb(201,148,199)", "rgb(223,101,176)", "rgb(221,28,119)", "rgb(152,0,67)"], "7": ["rgb(241,238,246)", "rgb(212,185,218)", "rgb(201,148,199)", "rgb(223,101,176)", "rgb(231,41,138)", "rgb(206,18,86)", "rgb(145,0,63)"], "8": ["rgb(247,244,249)", "rgb(231,225,239)", "rgb(212,185,218)", "rgb(201,148,199)", "rgb(223,101,176)", "rgb(231,41,138)", "rgb(206,18,86)", "rgb(145,0,63)"], "9": ["rgb(247,244,249)", "rgb(231,225,239)", "rgb(212,185,218)", "rgb(201,148,199)", "rgb(223,101,176)", "rgb(231,41,138)", "rgb(206,18,86)", "rgb(152,0,67)", "rgb(103,0,31)"] },
            "RdPu": { "2": ["rgb(253,224,221)", "rgb(250,159,181)"], "3": ["rgb(253,224,221)", "rgb(250,159,181)", "rgb(197,27,138)"], "4": ["rgb(254,235,226)", "rgb(251,180,185)", "rgb(247,104,161)", "rgb(174,1,126)"], "5": ["rgb(254,235,226)", "rgb(251,180,185)", "rgb(247,104,161)", "rgb(197,27,138)", "rgb(122,1,119)"], "6": ["rgb(254,235,226)", "rgb(252,197,192)", "rgb(250,159,181)", "rgb(247,104,161)", "rgb(197,27,138)", "rgb(122,1,119)"], "7": ["rgb(254,235,226)", "rgb(252,197,192)", "rgb(250,159,181)", "rgb(247,104,161)", "rgb(221,52,151)", "rgb(174,1,126)", "rgb(122,1,119)"], "8": ["rgb(255,247,243)", "rgb(253,224,221)", "rgb(252,197,192)", "rgb(250,159,181)", "rgb(247,104,161)", "rgb(221,52,151)", "rgb(174,1,126)", "rgb(122,1,119)"], "9": ["rgb(255,247,243)", "rgb(253,224,221)", "rgb(252,197,192)", "rgb(250,159,181)", "rgb(247,104,161)", "rgb(221,52,151)", "rgb(174,1,126)", "rgb(122,1,119)", "rgb(73,0,106)"] },
            "YlGn": { "2": ["rgb(247,252,185)", "rgb(49,163,84)"], "3": ["rgb(247,252,185)", "rgb(173,221,142)", "rgb(49,163,84)"], "4": ["rgb(255,255,204)", "rgb(194,230,153)", "rgb(120,198,121)", "rgb(35,132,67)"], "5": ["rgb(255,255,204)", "rgb(194,230,153)", "rgb(120,198,121)", "rgb(49,163,84)", "rgb(0,104,55)"], "6": ["rgb(255,255,204)", "rgb(217,240,163)", "rgb(173,221,142)", "rgb(120,198,121)", "rgb(49,163,84)", "rgb(0,104,55)"], "7": ["rgb(255,255,204)", "rgb(217,240,163)", "rgb(173,221,142)", "rgb(120,198,121)", "rgb(65,171,93)", "rgb(35,132,67)", "rgb(0,90,50)"], "8": ["rgb(255,255,229)", "rgb(247,252,185)", "rgb(217,240,163)", "rgb(173,221,142)", "rgb(120,198,121)", "rgb(65,171,93)", "rgb(35,132,67)", "rgb(0,90,50)"], "9": ["rgb(255,255,229)", "rgb(247,252,185)", "rgb(217,240,163)", "rgb(173,221,142)", "rgb(120,198,121)", "rgb(65,171,93)", "rgb(35,132,67)", "rgb(0,104,55)", "rgb(0,69,41)"] },
            "YlGnBu": { "2": ["rgb(237,248,177)", "rgb(44,127,184)"], "3": ["rgb(237,248,177)", "rgb(127,205,187)", "rgb(44,127,184)"], "4": ["rgb(255,255,204)", "rgb(161,218,180)", "rgb(65,182,196)", "rgb(34,94,168)"], "5": ["rgb(255,255,204)", "rgb(161,218,180)", "rgb(65,182,196)", "rgb(44,127,184)", "rgb(37,52,148)"], "6": ["rgb(255,255,204)", "rgb(199,233,180)", "rgb(127,205,187)", "rgb(65,182,196)", "rgb(44,127,184)", "rgb(37,52,148)"], "7": ["rgb(255,255,204)", "rgb(199,233,180)", "rgb(127,205,187)", "rgb(65,182,196)", "rgb(29,145,192)", "rgb(34,94,168)", "rgb(12,44,132)"], "8": ["rgb(255,255,217)", "rgb(237,248,177)", "rgb(199,233,180)", "rgb(127,205,187)", "rgb(65,182,196)", "rgb(29,145,192)", "rgb(34,94,168)", "rgb(12,44,132)"], "9": ["rgb(255,255,217)", "rgb(237,248,177)", "rgb(199,233,180)", "rgb(127,205,187)", "rgb(65,182,196)", "rgb(29,145,192)", "rgb(34,94,168)", "rgb(37,52,148)", "rgb(8,29,88)"] },
            "YlOrBu": { "2": ["rgb(255,247,188)", "rgb(217,95,14)"], "3": ["rgb(255,247,188)", "rgb(254,196,79)", "rgb(217,95,14)"], "4": ["rgb(255,255,212)", "rgb(254,217,142)", "rgb(254,153,41)", "rgb(204,76,2)"], "5": ["rgb(255,255,212)", "rgb(254,217,142)", "rgb(254,153,41)", "rgb(217,95,14)", "rgb(153,52,4)"], "6": ["rgb(255,255,212)", "rgb(254,227,145)", "rgb(254,196,79)", "rgb(254,153,41)", "rgb(217,95,14)", "rgb(153,52,4)"], "7": ["rgb(255,255,212)", "rgb(254,227,145)", "rgb(254,196,79)", "rgb(254,153,41)", "rgb(236,112,20)", "rgb(204,76,2)", "rgb(140,45,4)"], "8": ["rgb(255,255,229)", "rgb(255,247,188)", "rgb(254,227,145)", "rgb(254,196,79)", "rgb(254,153,41)", "rgb(236,112,20)", "rgb(204,76,2)", "rgb(140,45,4)"], "9": ["rgb(255,255,229)", "rgb(255,247,188)", "rgb(254,227,145)", "rgb(254,196,79)", "rgb(254,153,41)", "rgb(236,112,20)", "rgb(204,76,2)", "rgb(153,52,4)", "rgb(102,37,6)"] },
            "YlOrRd": { "2": ["rgb(255,237,160)", "rgb(240,59,32)"], "3": ["rgb(255,237,160)", "rgb(254,178,76)", "rgb(240,59,32)"], "4": ["rgb(255,255,178)", "rgb(254,204,92)", "rgb(253,141,60)", "rgb(227,26,28)"], "5": ["rgb(255,255,178)", "rgb(254,204,92)", "rgb(253,141,60)", "rgb(240,59,32)", "rgb(189,0,38)"], "6": ["rgb(255,255,178)", "rgb(254,217,118)", "rgb(254,178,76)", "rgb(253,141,60)", "rgb(240,59,32)", "rgb(189,0,38)"], "7": ["rgb(255,255,178)", "rgb(254,217,118)", "rgb(254,178,76)", "rgb(253,141,60)", "rgb(252,78,42)", "rgb(227,26,28)", "rgb(177,0,38)"], "8": ["rgb(255,255,204)", "rgb(255,237,160)", "rgb(254,217,118)", "rgb(254,178,76)", "rgb(253,141,60)", "rgb(252,78,42)", "rgb(227,26,28)", "rgb(177,0,38)"], "9": ["rgb(255,255,204)", "rgb(255,237,160)", "rgb(254,217,118)", "rgb(254,178,76)", "rgb(253,141,60)", "rgb(252,78,42)", "rgb(227,26,28)", "rgb(189,0,38)", "rgb(128,0,38)"] },
        };
        return colorTest;
    }());
    beachParty.colorTest = colorTest;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    container.ts - layout class that manages a set of sub-containers or shapes.
//-------------------------------------------------------------------------------------
//var mediumSales: any[];
var beachParty;
(function (beachParty) {
    var Container = (function () {
        function Container(data, level, binMap) {
            this.statType = null;
            this.statColName = "";
            this.inputData = data;
            this.childData = new beachParty.frameOrArrayClass(data, data._groupName);
            this.name = data._groupName;
            this.children = [];
            this.level = level;
            this.binMap = (binMap) ? binMap : {};
            //---- add my binInfo to binMap ----
            if (data._groupColName) {
                this.binMap = vp.utils.copyMap(this.binMap);
                this.binMap[data._groupColName] = data._groupName;
            }
        }
        Container.prototype.binAndGen = function (dividers) {
            var divideLevel = this.level;
            if (divideLevel < dividers.length) {
                var dataDivider = dividers[divideLevel].dd;
                //var spaceDivider = <SpaceDivider> dividers[divideLevel].sd;
                //---- divide the DATA ----
                var dataGroups = dataDivider.divide(this.inputData);
                if (dataGroups) {
                    //---- data was BINNED ----
                    this.childData = new beachParty.frameOrArrayClass(dataGroups, this.inputData._groupName);
                    if (divideLevel != dividers.length - 1) {
                        //---- not at leaf, so create subContainers ----
                        var childLevel = divideLevel + 1;
                        //---- create child containers for each data group ----
                        for (var i = 0; i < dataGroups.length; i++) {
                            var childData = dataGroups[i];
                            var child = new Container(childData, childLevel, this.binMap);
                            this.children.push(child);
                            if (true) {
                                //---- use next set of dividers on this ----
                                child.binAndGen(dividers);
                            }
                        }
                    }
                }
            }
        };
        Container.prototype.measure = function (dividers) {
            var scaleData = new ScaleData();
            if (dividers && dividers.length) {
                var divider = dividers[this.level];
                var spaceDivider = divider.sd;
                var xStat = spaceDivider.xStat;
                var yStat = spaceDivider.yStat;
                if (this.children.length === 0) {
                    //---- process LEAF container ----
                    var data = this.childData;
                    scaleData.minCount = data.length;
                    scaleData.maxCount = data.length;
                    if (xStat.colName) {
                        var vector = data.getNumericVectorFromStat(xStat).values;
                        scaleData.xMin = vector.min();
                        scaleData.xMax = vector.max();
                    }
                    if (yStat.colName) {
                        var vector = data.getNumericVectorFromStat(yStat).values;
                        scaleData.yMin = vector.min();
                        scaleData.yMax = vector.max();
                    }
                    var shapeData = this.aggOrCopy(this.childData, divider);
                    this.shapeData = shapeData;
                    scaleData.allLeafData = shapeData;
                }
                else {
                    //---- process INNER container ----
                    for (var i = 0; i < this.children.length; i++) {
                        var child = this.children[i];
                        var results = child.measure(dividers);
                        var sd = results.scaleData;
                        if (i == 0) {
                            scaleData = sd;
                        }
                        else {
                            scaleData.minCount = Math.min(scaleData.minCount, sd.minCount);
                            scaleData.maxCount = Math.max(scaleData.maxCount, sd.maxCount);
                            scaleData.xMin = Math.min(scaleData.xMin, sd.xMin);
                            scaleData.xMax = Math.max(scaleData.xMax, sd.xMax);
                            scaleData.yMin = Math.min(scaleData.yMin, sd.yMin);
                            scaleData.yMax = Math.max(scaleData.yMax, sd.yMax);
                            if (scaleData.allLeafData) {
                                var dataCopy = scaleData.allLeafData.copyData();
                                dataCopy.append(sd.allLeafData);
                                scaleData.allLeafData = dataCopy;
                            }
                            else {
                                scaleData.allLeafData = sd.allLeafData;
                            }
                        }
                    }
                }
            }
            return { scaleData: scaleData };
        };
        Container.prototype.layout = function (dividers, cellData, scaleData, svg, leafRcArray) {
            var primaryShapeSize = null;
            if (dividers && dividers.length) {
                var div0 = dividers[0];
                if (div0.shapeLayers && div0.shapeLayers.length) {
                    primaryShapeSize = div0.shapeLayers[0].shapeSize;
                }
            }
            if (this.level < dividers.length) {
                var divider = dividers[this.level];
                var spaceDivider = divider.sd;
                //---- divide the SPACE ----
                var cellArray = spaceDivider.divide(cellData, this.name, this.childData, primaryShapeSize, scaleData, svg);
                //---- call LAYOUT for children, if any ----
                for (var i = 0; i < this.children.length; i++) {
                    var child = this.children[i];
                    var cdChild = cellArray[i];
                    if (child && cdChild) {
                        child.layout(dividers, cdChild, scaleData, svg, leafRcArray);
                    }
                }
                //---- for last divider PAIR, assign shapes ----
                if (this.level == dividers.length - 1) {
                    //---- ASSIGN SHAPES ----
                    if (leafRcArray) {
                        for (var i = 0; i < cellArray.length; i++) {
                            var cellData = cellArray[i];
                            leafRcArray.push(cellData);
                        }
                    }
                }
                //---- render each layer of shapes ----
                var shapeMakers = divider.shapeLayers;
                for (var i = 0; i < shapeMakers.length; i++) {
                    var shapeMaker = shapeMakers[i];
                    shapeMaker.generate(cellArray, this.shapeData, scaleData.allLeafData);
                }
            }
        };
        Container.prototype.addAggColumn = function (df, record, stat, colName, statType) {
            if (!stat) {
                stat = new beachParty.StatInfo(colName, statType);
            }
            if (stat.colName) {
                if (true) {
                    var aggColName = stat.getAggColName();
                    if (record[aggColName] == undefined && record[stat.colName] == undefined) {
                        var value = df.aggData(stat);
                        record[aggColName] = value;
                    }
                }
            }
        };
        Container.prototype.aggOrCopy = function (anyData, divider) {
            var newData = null;
            if (anyData.single) {
                newData = anyData.single.copyData();
            }
            else {
                var dfa = anyData.array;
                var records = [];
                var sd = divider.sd;
                //---- process each group of data into record ----
                for (var i = 0; i < dfa.length; i++) {
                    //---- create an aggregated record ----
                    var record = {};
                    var df = dfa[i];
                    var value = null;
                    //---- add each col of binColumns ----
                    var keys = vp.utils.keys(this.binMap);
                    for (var b = 0; b < keys.length; b++) {
                        var colName = keys[b];
                        value = this.binMap[colName];
                        record[colName] = value;
                    }
                    //---- add my binCol and value ----
                    var colName = df._groupColName;
                    value = df._groupName;
                    record[colName] = value;
                    //---- for the X, Y, and Color columns, if they are not category columns, we aggregate their data ----
                    //---- and add the colName/value to the aggregate record. ----
                    this.addAggColumn(df, record, sd.xStat);
                    this.addAggColumn(df, record, sd.yStat);
                    //---- add COLOR column, from each shapeMaker ----
                    var shapeMakers = divider.shapeLayers;
                    for (var s = 0; s < shapeMakers.length; s++) {
                        var shapeMaker = shapeMakers[s];
                        this.addAggColumn(df, record, null, shapeMaker.fillColorMapping.colName, shapeMaker.fillColorStat);
                        this.addAggColumn(df, record, null, shapeMaker.strokeColorMapping.colName, shapeMaker.strokeColorStat);
                    }
                    records.push(record);
                }
                newData = beachParty.dataFrameClass.jsonToDataFrame(records);
            }
            return newData;
        };
        return Container;
    }());
    beachParty.Container = Container;
    var ScaleData = (function () {
        function ScaleData() {
        }
        return ScaleData;
    }());
    beachParty.ScaleData = ScaleData;
    var ChartDivider = (function () {
        function ChartDivider(svg, dd, sd, shapeMaker1, shapeMaker2) {
            this.dd = dd || new beachParty.DataDivider();
            this.sd = sd || new beachParty.SpaceDivider();
            shapeMaker1 = shapeMaker1 || new beachParty.ShapeMaker(svg, beachParty.ShapeType.rectangle);
            shapeMaker2 = shapeMaker2 || new beachParty.ShapeMaker(svg, beachParty.ShapeType.none);
            this.shapeLayers = [shapeMaker1, shapeMaker2];
        }
        return ChartDivider;
    }());
    beachParty.ChartDivider = ChartDivider;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    dataDivider.ts - divides data into groups.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var DataDivider = (function () {
        function DataDivider(colName, groupCount, groupingType, aggregateType, groupSorting) {
            if (colName === void 0) { colName = ""; }
            if (groupCount === void 0) { groupCount = 5; }
            if (groupingType === void 0) { groupingType = GroupingType.bin; }
            if (aggregateType === void 0) { aggregateType = AggregateType.none; }
            if (groupSorting === void 0) { groupSorting = beachParty.BinSorting.none; }
            this.colName = colName;
            this.groupingType = groupingType;
            this.aggregateType = aggregateType;
            this.groupCount = groupCount;
            this.groupSorting = groupSorting;
        }
        DataDivider.prototype.divide = function (dataFrame) {
            var _this = this;
            var newData = null; // default output
            //vp.utils.debug("dataDivider.divide: orig data.length=" + data.length);
            if (this.colName && this.groupingType != GroupingType.none && dataFrame.getRecordCount()) {
                if (this.groupingType == GroupingType.bin) {
                    var requestedBins = this.groupCount;
                    var sortOptions = new beachParty.binSortOptionsClass();
                    sortOptions.sortDirection = this.groupSorting;
                    sortOptions.sortByAggregateType = "count";
                    var maxCount = 0;
                    //---- create a NamedVector object for binHelper ----
                    var nv = new beachParty.NamedVectors(dataFrame.getRecordCount());
                    nv.x = dataFrame.getNumericVector(this.colName);
                    var binResults = beachParty.binHelper.createBins(nv, "x", requestedBins, requestedBins, false, true, true, sortOptions, null, false);
                    var bins = binResults.bins;
                    newData = bins.map(function (bin) {
                        var group = dataFrame.copyData(bin.rowIndexes);
                        group._groupName = bin.name;
                        group._groupColName = _this.colName;
                        return group;
                    });
                }
            }
            return newData;
        };
        return DataDivider;
    }());
    beachParty.DataDivider = DataDivider;
    (function (GroupingType) {
        GroupingType[GroupingType["none"] = 0] = "none";
        GroupingType[GroupingType["bin"] = 1] = "bin";
        GroupingType[GroupingType["multiBin"] = 2] = "multiBin";
    })(beachParty.GroupingType || (beachParty.GroupingType = {}));
    var GroupingType = beachParty.GroupingType;
    (function (AggregateType) {
        AggregateType[AggregateType["none"] = 0] = "none";
        AggregateType[AggregateType["count"] = 1] = "count";
        AggregateType[AggregateType["sum"] = 2] = "sum";
    })(beachParty.AggregateType || (beachParty.AggregateType = {}));
    var AggregateType = beachParty.AggregateType;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    frameOrArray.ts - encapsulates an array of dataFrameClass or a single instance.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var frameOrArrayClass = (function () {
        function frameOrArrayClass(data, name) {
            if (vp.utils.isArray(data)) {
                this.array = data;
                this.length = data.length;
            }
            else if (data.getVector) {
                this.single = data;
                this.length = this.single.getRecordCount();
            }
            else {
                throw "Error: not a dataFrame or an Array";
            }
            this.name = name;
        }
        frameOrArrayClass.prototype.slice = function (from, to) {
            var value = null;
            if (this.array) {
                value = this.array.slice(from, to);
            }
            else {
                value = this.single.copyData(vp.data.range(from, to));
            }
            var foa = new frameOrArrayClass(value, this.name);
            return foa;
        };
        frameOrArrayClass.prototype.getItem = function (index) {
            var item = null;
            if (this.array) {
                item = this.array[index];
            }
            else if (this.single) {
                item = this.single.getRecordByVectorIndex(index);
            }
            return item;
        };
        frameOrArrayClass.prototype.getVector = function (colName, countIfArray) {
            var vector = null;
            if (this.single) {
                vector = this.single.getVector(colName, false);
            }
            else {
                //---- array of dataFrames ----
                if (this.array.length) {
                    //---- ensure colName exists on first dataFrame ----
                    var firstDf = this.array[0];
                    if (firstDf._groupColName == colName) {
                        vector = this.array.map(function (df) {
                            return df._groupName;
                        });
                    }
                    else if (countIfArray) {
                        if (firstDf.getVector(colName, false)) {
                            vector = this.array.map(function (df) {
                                return df.getRecordCount();
                            });
                        }
                    }
                }
            }
            return vector;
        };
        frameOrArrayClass.prototype.getNumericVectorFromStat = function (statInfo, countIfArray) {
            var numVector = null;
            var colName = statInfo.colName;
            if (colName || statInfo.statType == beachParty.StatType.count) {
                var aggColName = statInfo.getAggColName();
                if (this.single) {
                    if (this.single.isColumnName(aggColName)) {
                        colName = aggColName;
                    }
                    if (statInfo.statType == beachParty.StatType.count) {
                        var vector = vp.data.dataRepeat(1, this.single.getRecordCount());
                        numVector = new beachParty.NumericVector(vector, "Count@", "number", null);
                    }
                    else {
                        numVector = this.single.getNumericVector(colName);
                    }
                }
                else {
                    vector = [];
                    for (var i = 0; i < this.array.length; i++) {
                        var df = this.array[i];
                        var value = df.aggData(statInfo);
                        vector.push(value);
                    }
                    numVector = new beachParty.NumericVector(vector, "aggColName", "number", null);
                }
            }
            return numVector;
        };
        frameOrArrayClass.prototype.map = function (callback) {
            var value = null;
            if (this.array) {
                value = this.array.map(callback);
            }
            else {
                var firstName = this.single.getColumnNames()[0];
                var firstVector = this.single.getVector(firstName, false);
                value = firstVector.map(callback);
            }
            return value;
        };
        return frameOrArrayClass;
    }());
    beachParty.frameOrArrayClass = frameOrArrayClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    shapeMaker.ts - generates shapes for containers.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var ShapeMaker = (function () {
        function ShapeMaker(svg, shapeType, shapeSize, shapeFill, shapeStroke, strokeSize) {
            if (shapeType === void 0) { shapeType = ShapeType.rectangle; }
            if (shapeSize === void 0) { shapeSize = 10; }
            if (shapeFill === void 0) { shapeFill = "none"; }
            if (shapeStroke === void 0) { shapeStroke = "#333"; }
            if (strokeSize === void 0) { strokeSize = 1; }
            this.textSize = 16;
            this.fillColorStat = beachParty.StatType.none;
            this.strokeColorStat = beachParty.StatType.none;
            this.svg = svg;
            this.shapeType = shapeType;
            this.shapeFill = shapeFill;
            this.shapeStroke = shapeStroke;
            this.shapeSize = shapeSize;
            this.strokeSize = strokeSize;
            this.opacity = 1;
            this.textCol = "";
            this.fillColorMapping = new beachParty.ColorMappingData("", "", false, 12);
            this.strokeColorMapping = new beachParty.ColorMappingData("", "", false, 12);
        }
        ShapeMaker.prototype.generate = function (cellArray, data, allData) {
            this.fillScale = null;
            this.strokeScale = null;
            if (this.svg) {
                var svgParentW = vp.select(this.svg);
                var rcAll = svgParentW.getBounds(false);
                rcAll = vp.geom.createRect(0, 0, rcAll.width, rcAll.height);
                //---- build color scales, if needed ----
                if (this.fillColorMapping.colName) {
                    this.buildColorPaletteFromSettings(this.fillColorMapping, allData);
                    //---- use allData to build color scale (for consistency and full color range across containers) ----
                    var result = this.buildShapeColorScale(this.fillColorMapping, this.fillColorStat, allData);
                    this.fillScale = result.scale;
                    this.fillVector = null;
                    if (this.fillScale) {
                        //---- use data to build fillVector (for color values for this container) ----
                        this.fillVector = data.getNumericVector(result.colName, false, result.keys, false).values.toArray();
                    }
                }
                if (this.strokeColorMapping.colName) {
                    this.buildColorPaletteFromSettings(this.strokeColorMapping, data);
                    //---- use allData to build color scale (for consistency and full color range across containers) ----
                    var result = this.buildShapeColorScale(this.strokeColorMapping, this.fillColorStat, data);
                    this.strokeScale = result.scale;
                    this.strokeVector = null;
                    if (this.strokeScale) {
                        //---- use data to build strokeVector (for color values for this container) ----
                        this.strokeVector = data.getNumericVector(result.colName, false, result.keys).values.toArray();
                    }
                }
                if (this.shapeType == ShapeType.line) {
                    this.genLine(cellArray, data);
                }
                else if (this.shapeType != ShapeType.none) {
                    for (var i = 0; i < cellArray.length; i++) {
                        var cellData = cellArray[i];
                        //var rcAny = <any>cellData.rect;
                        var dataItem = data.getRecordByVectorIndex(i);
                        if (cellData.cellShape == beachParty.CellShape.path) {
                            this.genSinglePath(cellData, dataItem, i, data);
                        }
                        else {
                            this.genSingle(cellData, dataItem, i, data);
                        }
                    }
                }
            }
        };
        ShapeMaker.prototype.genLine = function (cellData, data) {
            var svgW = vp.select(this.svg);
            var points = "M ";
            var fill = this.getFillColor(0);
            var stroke = this.getStrokeColor(0);
            for (var i = 0; i < cellData.length; i++) {
                var rc = cellData[i].rect;
                var x = rc.left + rc.width / 2;
                var y = rc.top + rc.height / 2;
                if (i == 1) {
                    points += "L ";
                }
                points += x + "," + y + " ";
            }
            svgW.append("path")
                .colors(fill, stroke, this.strokeSize)
                .attr("opacity", this.opacity)
                .attr("d", points);
        };
        ShapeMaker.prototype.makeTooltip = function (record, dataFrame) {
            var ttMsg = "";
            if (this.toolTipFields) {
                var keys = this.toolTipFields;
            }
            else {
                var keys = vp.utils.keys(record);
                keys.sort();
            }
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = record[key];
                var colType = dataFrame.getColType(key);
                if (colType == "number") {
                    value = vp.formatters.comma(value, 2, false, true);
                }
                else if (colType == "date") {
                    value = vp.formatters.formatDateTime(value, " m/dd/yyyy");
                }
                if (!key.startsWith("_")) {
                    if (i > 0) {
                        //---- NOTE: linebreaks on SVG tooltips are not supported by IE. ----
                        ttMsg += "\n";
                    }
                    ttMsg += key + ": " + value;
                }
            }
            return ttMsg;
        };
        ShapeMaker.prototype.getFillColor = function (index) {
            var fill = this.shapeFill;
            if (this.fillScale) {
                var value = this.fillVector[index];
                var paletteIndex = this.fillScale.scale(value);
                if (paletteIndex != undefined) {
                    fill = vp.color.colorFromPalette(this.fillColorMapping.colorPalette, paletteIndex);
                }
            }
            return fill;
        };
        ShapeMaker.prototype.getStrokeColor = function (index) {
            var stroke = this.shapeStroke;
            if (this.strokeScale) {
                var value = this.strokeVector[index];
                var paletteIndex = this.strokeScale.scale(value);
                if (paletteIndex != undefined) {
                    stroke = vp.color.colorFromPalette(this.strokeColorMapping.colorPalette, paletteIndex);
                }
            }
            return stroke;
        };
        //genPath(cellArray: CellData[], data: dataFrameClass)
        //{
        //    var svgW = vp.select(this.svg);
        //    for (var i = 0; i < cellArray.length; i++)
        //    {
        //        var cellData = cellArray[i];
        //        var path = cellData.path;
        //        if (path)
        //        {
        //            var fill = this.getFillColor(i);
        //            var stroke = this.getStrokeColor(i);
        //            var dataRecord = data.getRecord(i);
        //            var tipText = (this.showTooltips) ? this.makeTooltip(dataRecord, data) : null;
        //            svgW.append("path")
        //                .colors(fill, stroke, this.strokeSize)
        //                .attr("d", path)
        //                .attr("tooltip", tipText);
        //        }
        //    }
        //}
        ShapeMaker.prototype.genSinglePath = function (cellData, dataRecord, index, dataFrame) {
            var tipText = (this.showTooltips) ? this.makeTooltip(dataRecord, dataFrame) : null;
            var fill = this.getFillColor(index);
            var stroke = this.getStrokeColor(index);
            var svgW = vp.select(this.svg);
            var path = cellData.path;
            if (this.shapeType == ShapeType.path) {
                svgW.append("path")
                    .colors(fill, stroke, this.strokeSize)
                    .attr("d", path)
                    .attr("tooltip", tipText);
            }
            else if (this.shapeType == ShapeType.circle) {
            }
        };
        ShapeMaker.prototype.genSingle = function (cellData, dataRecord, index, dataFrame) {
            var rc = cellData.rect;
            var left = rc.left;
            var top = rc.top;
            var cx = left + rc.width / 2;
            var cy = top + rc.height / 2;
            var svgW = vp.select(this.svg);
            var halfSize = this.shapeSize / 2;
            var tipText = (this.showTooltips) ? this.makeTooltip(dataRecord, dataFrame) : null;
            var fill = this.getFillColor(index);
            var stroke = this.getStrokeColor(index);
            if (this.shapeType == ShapeType.circle) {
                var elemW = svgW.append("circle")
                    .attr("r", halfSize)
                    .colors(fill, stroke, this.strokeSize)
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("opacity", this.opacity);
            }
            else if (this.shapeType == ShapeType.circleFill) {
                var radius = Math.min(rc.width, rc.height) / 2;
                var elemW = svgW.append("circle")
                    .attr("r", radius)
                    .colors(fill, stroke, this.strokeSize)
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("opacity", this.opacity);
            }
            else if (this.shapeType == ShapeType.square) {
                var x = cx - halfSize;
                var y = cy - halfSize;
                var elemW = svgW.append("rect")
                    .colors(fill, stroke, this.strokeSize)
                    .bounds(x, y, this.shapeSize, this.shapeSize)
                    .attr("opacity", this.opacity);
            }
            else if (this.shapeType == ShapeType.rectangle) {
                var left = rc.left;
                var top = rc.top;
                var width = rc.width;
                var height = rc.height;
                if (cellData.cellShape == beachParty.CellShape.circle) {
                    var r = Math.min(width, height) / 2;
                    var half = r / Math.sqrt(2);
                    var width = 2 * half;
                    height = width;
                    left = cellData.circle.cx - half;
                    top = cellData.circle.cy - half;
                }
                var elemW = svgW.append("rect")
                    .colors(fill, stroke, this.strokeSize)
                    .bounds(left, top, width, height)
                    .attr("opacity", this.opacity);
            }
            else if (this.shapeType == ShapeType.text) {
                var text = dataRecord[this.textCol];
                var elemW = svgW.append("text")
                    .colors(fill, stroke, this.strokeSize)
                    .attr("x", cx)
                    .attr("y", cy)
                    .attr("text-anchor", "middle")
                    .attr("opacity", this.opacity)
                    .text(text);
                if (this.textSize) {
                    elemW.css("font-size", this.textSize + "px");
                }
                //---- vertical align text in middle of cell ----
                var delta = vp.dom.computeTextBaselineDelta(elemW[0], "middle");
                elemW.attr("dy", delta);
            }
            else {
                throw "Error: shapeType not yet supported: " + this.shapeType;
            }
            if (elemW && tipText) {
                elemW.attr("tooltip", tipText);
            }
        };
        ShapeMaker.prototype.buildShapeColorScale = function (cm, statType, allData) {
            var colName = cm.colName;
            var scale = null;
            var keys = null;
            //---- do we want the aggregated column, or the regular?  which is present? ----
            var statInfo = new beachParty.StatInfo(colName, statType);
            var aggColName = statInfo.getAggColName();
            if (allData.isColumnName(aggColName)) {
                colName = aggColName;
            }
            var nvColorIndex = allData.getNumericVector(colName, false);
            if (nvColorIndex) {
                var isContinuous = cm.isContinuous;
                var colorCount = cm.colorPalette.length;
                //---- palette index=0 is reserved for the selection color, so we use index=1 to index=N for our colors ----
                var maxIndex = colorCount;
                var maxColors = colorCount;
                keys = (nvColorIndex.keyInfo) ? nvColorIndex.keyInfo.sortedKeys : null;
                if (!isContinuous) {
                    //---- if keyCount is smaller than color palette, only map to keyCount entries ----
                    if (nvColorIndex && nvColorIndex.keyInfo && nvColorIndex.keyInfo.keyCount) {
                        var keyCount = nvColorIndex.keyInfo.keyCount;
                        if (keyCount < colorCount) {
                            maxIndex = keyCount;
                            maxColors = keyCount;
                        }
                        else if (keyCount > colorCount) {
                            //---- scale for # of keys & then truncate to maxColors (in vertex shader) ----
                            maxIndex = keyCount;
                        }
                    }
                    //---- add this so that when we take floor(scaledValue), we correctly map to stepped palette entries ----
                    maxIndex += .999999; // adding another "9" here breaks scaling on WebGL (gets interpreted as a "1")
                }
                if (cm.customScalingCallback) {
                    if (vp.utils.isString(cm.customScalingCallback)) {
                        //----  convert from string to func ----
                        var foo = null;
                        //eval("foo = " + cm.customScalingCallback);
                        throw "custom scaling callbacks not currently supported";
                    }
                    colorIndexScale = cm.customScalingCallback;
                }
                else {
                    var result = beachParty.cbUtils.getMinMax(nvColorIndex, null, cm); //  nv.layoutFilter);
                    if (cm.spread == beachParty.MappingSpread.low) {
                        var colorIndexScale = vp.scales.createLowBias()
                            .domainMin(result.min)
                            .domainMax(result.max)
                            .range(1, maxIndex);
                    }
                    else if (cm.spread == beachParty.MappingSpread.high) {
                        var colorIndexScale = vp.scales.createHighBias()
                            .domainMin(result.min)
                            .domainMax(result.max)
                            .range(1, maxIndex);
                    }
                    else {
                        var colorIndexScale = vp.scales.createLinear()
                            .domainMin(result.min)
                            .domainMax(result.max)
                            .range(1, maxIndex);
                    }
                }
            }
            return { scale: colorIndexScale, keys: keys, colName: colName };
        };
        ShapeMaker.prototype.buildColorPaletteFromSettings = function (cm, dataFrame) {
            if (cm) {
                var colName = cm.colName;
                if (colName) {
                    var numVector = dataFrame.getNumericVector(colName);
                    var colType = numVector.colType;
                    var isCategory = (cm.forceCategory || colType == "string");
                    var paletteName = cm.paletteName;
                    if (!paletteName) {
                        paletteName = (isCategory) ? "Paired" : "Blues";
                    }
                    var palette = beachParty.colorPalettesClass.getPaletteFromSettings(paletteName, cm.binCount, // stepsRequested,
                    cm.isReversed, cm.isInverted);
                    var breaks = null;
                    if (isCategory) {
                        var keys = numVector.keyInfo.sortedKeys;
                        var keyCount = keys.length;
                        if (keyCount < palette.length) {
                            palette = palette.slice(0, keyCount);
                        }
                        breaks = [];
                        for (var i = 0; i < palette.length; i++) {
                            if (i == palette.length - 1 && keyCount > palette.length) {
                                breaks.push("Other");
                            }
                            else {
                                breaks.push(keys[i]);
                            }
                        }
                    }
                    //---- add a selected color at palette[0] so that our color scaling works correctly ----
                    palette.insert(0, "pink");
                    cm.colorPalette = palette;
                    cm.breaks = breaks;
                }
            }
        };
        return ShapeMaker;
    }());
    beachParty.ShapeMaker = ShapeMaker;
    (function (ShapeType) {
        ShapeType[ShapeType["none"] = 0] = "none";
        ShapeType[ShapeType["circle"] = 1] = "circle";
        ShapeType[ShapeType["circleFill"] = 2] = "circleFill";
        ShapeType[ShapeType["line"] = 3] = "line";
        ShapeType[ShapeType["path"] = 4] = "path";
        ShapeType[ShapeType["square"] = 5] = "square";
        ShapeType[ShapeType["rectangle"] = 6] = "rectangle";
        ShapeType[ShapeType["text"] = 7] = "text";
    })(beachParty.ShapeType || (beachParty.ShapeType = {}));
    var ShapeType = beachParty.ShapeType;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    spaceDivider.ts - algorithm(s) for dividing up a container into sub-containers.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// Data Aggregation and Scaling for layouts:
    ///
    ///   There are several types of layouts supported by this class:
    ///
    ///     1. PLOT layouts (e.g., plotXY, polarXY)
    ///     2. PROPORTIONAL CELL SIZE layouts (e.g., fillX, fillY, squarify)
    ///     3. DATA INSENSITIVE layouts (e.g., packXY, poisson)
    ///
    ///   Types 1 & 2 need different X and/or Y values for each cell layed out (specified in the X and Y column mappings for
    ///   the associated spaceDivider).  For leaf nodes, these values are obtained directly from the leaf node record values.
    ///   For higher level ("inner") nodes, the column values at the leaf node are aggregated using a "leafStat" and then propagated up to the 
    ///   associated spaceDivider/container using a "innerStat".  
    ///
    ///   For example, you could have a #2 spaceDivider that uses "squarify" layout with "X" (the spacing column) mapped to the "Sales" column, 
    ///   with leafStat set to "Sum()" and innerStat set to "Sum"()".  This would compute the sum(Sales) for each group of level 3 and then
    ///   sum those for each group of level 2, and then layout each cell of level 2 like the outer containers in a Treemap.
    ///
    ///   All 3 of the above types may need to use a common scale (in X and/or Y), to facilitate comparison among containers
    ///   at various levels.  To accomplish that, they need to calculate the min/max (count or state) of X/Y at the leaf levels and 
    ///   then propagate  this to the root, so it can be passed to each of the relevant containers at layout() time.
    ///
    var SpaceDivider = (function () {
        function SpaceDivider(spaceType, margin) {
            if (spaceType === void 0) { spaceType = SpaceType.none; }
            if (margin === void 0) { margin = 2; }
            this.showContainers = false;
            this.showCounts = false;
            //---- labels ----
            this.showLabels = false;
            this.labelColName = "CabinClass";
            this.labelAddColon = false;
            this.labelPosition = LabelPositon.top;
            this.labelHalfCell = false;
            this.labelSize = 16;
            this.labelFill = "black";
            this.labelOpacity = 1;
            //---- stats for leaf and inner containers (must be set explictly by presets/UI)----
            this.xStat = new StatInfo();
            this.yStat = new StatInfo();
            //---- for drawing containers ----
            this.containerFill = "#ccc";
            this.containerStroke = "none";
            this.containerStrokeSize = 1;
            //---- X and Y mappings ----
            this.hAlign = HAlign.left; // how to align cells that are not full width
            this.vAlign = VAlign.bottom; // how to align cells that are not full height
            this.xMaxPeer = false; // for fillX/FillY: scale X values relative to max(peer values)
            this.yMaxPeer = false; // for fillX/fillY: scale Y values relative to max(peer values)
            //---- pre-computed random data (for reproducible drawing when attribute changes) ----
            this.xRandom = null;
            this.yRandom = null;
            //---- choropleth support ----
            this.choroData = null; // geoJSON shapes for ShapeType.choropleth
            this.choroMapType = ChoroMapType.none;
            this.choroColName = ""; // name of column that matches NAME in choroData
            this.spaceType = spaceType;
            this.margin = margin;
            this.cellMargin = margin;
            this.reverse = false;
            this.cellShape = CellShape.rectangle;
        }
        SpaceDivider.prototype.drawLabelsOnTop = function (cellData, svg, name) {
            var textHeight = 18;
            var rc = cellData.rect;
            var yText = rc.top + textHeight - 3;
            //labelPosition = LabelPositon.top;
            //labelHalfCell = false;
            var text = (this.labelAddColon) ? (name + ":") : name;
            var textW = vp.select(svg).append("text")
                .text(text)
                .attr("x", rc.left + rc.width / 2)
                .attr("y", yText)
                .attr("text-anchor", "middle")
                .colors(this.labelFill, "none", 0);
            if (this.labelSize) {
                textW.css("font-size", this.labelSize + "px");
            }
            if (this.labelOpacity != undefined) {
                textW.css("opacity", this.labelOpacity + "");
            }
            rc = vp.geom.createRect(rc.left, rc.top + textHeight, rc.width, rc.height - textHeight);
            var cd = CellData.fromRect(rc, this.cellShape);
            return cd;
        };
        /** data can be either a dataFrameClass or an array of DataFrameClass objects. */
        SpaceDivider.prototype.divide = function (cellData, name, data, shapeSize, scaleData, svg) {
            var _this = this;
            var cellArray = [];
            var margin = this.margin;
            var cellMargin = this.cellMargin;
            //---- get X and Y STAT data, if requested ----
            var xnv = data.getNumericVectorFromStat(this.xStat);
            this.xVector = (xnv) ? xnv.values.toArray() : null;
            var ynv = data.getNumericVectorFromStat(this.yStat);
            this.yVector = (ynv) ? ynv.values.toArray() : null;
            this.scaleData = scaleData;
            //---- apply margins ----
            var rcFull = cellData.rect;
            var rcMarg = vp.geom.createRect(rcFull.left + margin, rcFull.top + margin, rcFull.width - 2 * margin, rcFull.height - 2 * margin);
            var count = data.length;
            //vp.utils.debug("spaceDivider.divide: rcMarg.left=" + rcMarg.left + ", rcMarg.top=" + rcMarg.top);
            if (count) {
                //---- limit data ----
                var maxItems = beachParty.maxContainers;
                if (maxItems && count > maxItems) {
                    //var nd = <INumericRecords>data;
                    data = data.slice(0, maxItems - 1);
                    count = maxItems;
                }
                if (this.spaceType == SpaceType.overlay) {
                    cellArray = data.map(function (pt) {
                        return vp.geom.createRect(rcMarg.left, rcMarg.top, rcMarg.width, rcMarg.height);
                    });
                }
                else if (this.spaceType == SpaceType.poisson) {
                    var best = new beachParty.bestPoisson();
                    var pts = best.layout(rcMarg, count);
                    cellArray = pts.map(function (pt) {
                        //---- upper left corner ----
                        var x = pt[0] - .5;
                        var y = pt[1] - .5;
                        return CellData.fromRect(vp.geom.createRect(x, y, 1, 1), _this.cellShape);
                    });
                }
                else if (this.spaceType == SpaceType.random) {
                    var rIndex = 0;
                    cellArray = data.map(function (d) {
                        if (_this.xRandom) {
                            var xr = _this.xRandom[rIndex];
                            var yr = _this.yRandom[rIndex];
                            rIndex++;
                        }
                        else {
                            var xr = Math.random();
                            var yr = Math.random();
                        }
                        var cx = rcMarg.left + rcMarg.width * xr;
                        var cy = rcMarg.top + rcMarg.height * yr;
                        //---- upper left corner ----
                        var x = cx - .5;
                        var y = cy - .5;
                        return CellData.fromRect(vp.geom.createRect(x, y, 1, 1), _this.cellShape);
                    });
                }
                else if (this.spaceType == SpaceType.fillXY) {
                    cellArray = this.fillXY(rcMarg, data);
                }
                else if (this.spaceType == SpaceType.packXY) {
                    cellArray = this.packXY(rcMarg, data);
                }
                else if (this.spaceType == SpaceType.packYX) {
                    cellArray = this.packYX(rcMarg, data);
                }
                else if (this.spaceType == SpaceType.fillOut) {
                    cellArray = this.fillOut(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.packOut) {
                    cellArray = this.packOut(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.plotXY) {
                    cellArray = this.plotXY(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.polarXY) {
                    cellArray = this.polarXY(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.fillX) {
                    cellArray = this.fillXWithProp(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.fillY) {
                    cellArray = this.fillYWithProp(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.record) {
                    cellArray = this.record(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.squarify) {
                    cellArray = this.squarify(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.choropleth) {
                    cellArray = this.choroLayout(rcMarg, data);
                }
                //---- debug -----
                if (this.spaceType != SpaceType.none && this.spaceType != SpaceType.choropleth) {
                    if (cellArray.length != data.length) {
                        throw "Layout error - size(cellArray) is different from data.length";
                    }
                }
                //---- draw containers ----
                if (svg && (this.showContainers || this.showCounts || this.showLabels)) {
                    this.drawContainerOutlines(svg, cellArray, data);
                }
            }
            return cellArray;
        };
        SpaceDivider.prototype.choroLayout = function (rcMarg, data) {
            var cellArray = [];
            if (this.choroData && this.choroColName) {
                var ranges = { xMin: Number.MAX_VALUE, xMax: -Number.MAX_VALUE, yMin: Number.MAX_VALUE, yMax: -Number.MAX_VALUE };
                var coordsMap = {};
                var shapeNames = data.getVector(this.choroColName, false);
                if (shapeNames) {
                    //---- first pass: find shapes and compute min/max of X/Y ----
                    for (var i = 0; i < shapeNames.length; i++) {
                        var shapeName = shapeNames[i];
                        var coords = beachParty.choroplethHelper.getShapeCoords(this.choroData, shapeName);
                        if (coords) {
                            beachParty.choroplethHelper.computeXYRange(ranges, coords);
                            coordsMap[shapeName] = coords;
                        }
                    }
                    //---- second pass: build path strings ----
                    for (var i = 0; i < shapeNames.length; i++) {
                        var shapeName = shapeNames[i];
                        var coords = coordsMap[shapeName];
                        if (coords) {
                            var path = beachParty.choroplethHelper.buildPath(rcMarg, ranges, coords);
                            var cellData = new CellData();
                            cellData.cellShape = CellShape.path;
                            cellData.path = path;
                            cellArray.push(cellData);
                        }
                    }
                }
            }
            return cellArray;
        };
        SpaceDivider.prototype.makeScaleForCol = function (vector, colType, minRange, maxRange, maxPeer, zeroBased) {
            var scale = null;
            if (vector && vector.length) {
                var min = vector.min();
                var max = (maxPeer) ? maxPeer : vector.max();
                if (zeroBased) {
                    if (max < 0) {
                        max = 0;
                    }
                    else if (min > 0) {
                        min = 0;
                    }
                }
                if (colType == "date") {
                    scale = vp.scales.createDate();
                }
                else if (colType == "number") {
                    scale = vp.scales.createLinear();
                }
                else {
                    //---- not sure - should this be createCategoryKey()? ----
                    scale = vp.scales.createCategoryIndex();
                }
                scale
                    .domain(min, max)
                    .range(minRange, maxRange);
            }
            return scale;
        };
        /** lays out containers, one per     */
        SpaceDivider.prototype.record = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            //---- for legends, we don't call measure, so no childStats exists ----
            var xVector = this.xVector;
            if (xVector && xVector.length) {
                var squarifyLayout = new beachParty.squarifyLayoutClass();
                cellArray = squarifyLayout.layout(xVector, rcMarg, this.cellMargin);
            }
            return cellArray;
        };
        /** lays out containers in a single-level squarified treemap.  Here, the "color" of a squarify cell
        will be determined by the shapes that populate it.  The size of each cell at the leaf nodes can be based
        on a column or just "1".  The size of intermediate container cells is based on the child data groups: count of    */
        SpaceDivider.prototype.squarify = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            //---- for legends, we don't call measure, so no childStats exists ----
            var xVector = this.xVector;
            if (xVector && xVector.length) {
                var squarifyLayout = new beachParty.squarifyLayoutClass();
                cellArray = squarifyLayout.layout(xVector, rcMarg, this.cellMargin);
            }
            return cellArray;
        };
        /** maps X, Y values to polar coordinates to plot shapes.  */
        SpaceDivider.prototype.polarXY = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            var xCol = this.xStat.colName;
            var yCol = this.yStat.colName;
            var xnv = data.getNumericVectorFromStat(this.xStat);
            var xVector = (xnv) ? xnv.values.toArray() : null;
            var ynv = data.getNumericVectorFromStat(this.yStat);
            var yVector = (ynv) ? ynv.values.toArray() : null;
            var maxRadius = Math.min(rcMarg.width / 2, rcMarg.height / 2);
            var anyData = data;
            var xColType = (anyData.colTypes) ? anyData.colTypes[xCol] : "number";
            var yColType = (anyData.colTypes) ? anyData.colTypes[yCol] : "number";
            //---- X range: 0-2*PI ----
            var xScale = this.makeScaleForCol(xVector, xColType, 0, 2 * Math.PI);
            //---- Y range: 0-maxRadius ----
            var yScale = this.makeScaleForCol(yVector, yColType, 0, maxRadius);
            var cx = rcMarg.left + rcMarg.width / 2;
            var cy = rcMarg.top + rcMarg.height / 2;
            var xScaled = 0;
            var yScaled = 0;
            for (var i = 0; i < data.length; i++) {
                if (xVector) {
                    var xValue = xVector[i];
                    xScaled = xScale.scale(xValue);
                }
                if (yVector) {
                    var yValue = yVector[i];
                    yScaled = yScale.scale(yValue);
                }
                var theta = -(Math.PI / 2 + xScaled);
                var radius = yScaled;
                var cxx = cx + radius * Math.cos(theta);
                var cyy = cy + radius * Math.sin(theta);
                //---- upper left corner ----
                var x = cxx - .5;
                var y = cyy - .5;
                var rcChild = vp.geom.createRect(x, y, 1, 1);
                cellArray.push(CellData.fromRect(rcChild, this.cellShape));
            }
            return cellArray;
        };
        /** maps shapes along the X/Y axis using the xCol and yCol values.  */
        SpaceDivider.prototype.plotXY = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            var xCol = this.xStat.colName;
            var yCol = this.yStat.colName;
            var xVector = data.getVector(xCol);
            var yVector = data.getVector(yCol);
            var anyData = data;
            var xColType = (anyData.colTypes) ? anyData.colTypes[xCol] : "number";
            var yColType = (anyData.colTypes) ? anyData.colTypes[yCol] : "number";
            var xScale = this.makeScaleForCol(xVector, xColType, rcMarg.left, rcMarg.right);
            var yScale = this.makeScaleForCol(yVector, yColType, rcMarg.top, rcMarg.bottom);
            var cx = 0;
            var cy = 0;
            for (var i = 0; i < data.length; i++) {
                if (xVector) {
                    var xValue = xVector[i];
                    cx = xScale.scale(xValue);
                }
                if (yVector) {
                    var yValue = yVector[i];
                    cy = yScale.scale(yValue);
                }
                //---- upper left corner ----
                var x = cx - .5;
                var y = cy - .5;
                var rcChild = vp.geom.createRect(x, y, 1, 1);
                cellArray.push(CellData.fromRect(rcChild, this.cellShape));
            }
            return cellArray;
        };
        /** does a FILL along the X axis, where the width and height of each cell is proportional to xCol/yCol. */
        SpaceDivider.prototype.fillXWithProp = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            var xVector = this.xVector;
            var yVector = this.yVector;
            var cellMargin = this.cellMargin;
            var halfMargin = cellMargin / 2;
            var count = data.length;
            var uniformHeight = rcMarg.height;
            var uniformWidth = Math.max(0, rcMarg.width / count - cellMargin);
            var xFactor = 0;
            var yScale = null;
            if (xVector && xVector.length) {
                var xSum = xVector.sum(function (v) { return Math.abs(v); });
                xFactor = Math.max(0, (rcMarg.width - count * cellMargin) / xSum);
            }
            if (yVector && yVector.length) {
                yScale = this.makeScaleForCol(yVector, "number", 0, rcMarg.height, null, true);
            }
            var left = rcMarg.left + halfMargin;
            var valign = this.vAlign;
            var yCenter = rcMarg.top + rcMarg.height / 2;
            for (var i = 0; i < data.length; i++) {
                var width = (xVector) ? (Math.abs(xVector[i]) * xFactor) : uniformWidth;
                var height = (yVector) ? yScale.scale(yVector[i]) : uniformHeight;
                //---- make sure we can see all cells ----
                //width = Math.max(1, width);
                //height = Math.max(1, height);
                var top = rcMarg.bottom - height;
                if (valign == VAlign.middle) {
                    top = yCenter - height / 2;
                }
                else if (valign == VAlign.top) {
                    top = rcMarg.top;
                }
                var rcChild = vp.geom.createRect(left, top, width, height);
                cellArray.push(CellData.fromRect(rcChild, this.cellShape));
                left += (width + cellMargin);
            }
            return cellArray;
        };
        /** does a FILL along the Y axis, where the width and height of each cell is proportional to xCol/yCol. */
        SpaceDivider.prototype.fillYWithProp = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            var xCol = this.xStat.colName;
            var yCol = this.yStat.colName;
            var xVector = data.getVector(xCol, true);
            var yVector = data.getVector(yCol, true);
            var cellMargin = this.cellMargin;
            var halfMargin = cellMargin / 2;
            var count = data.length;
            var uniformHeight = Math.max(0, (rcMarg.height / count - cellMargin));
            var uniformWidth = rcMarg.width;
            var xScale = null;
            var yFactor = 0;
            var xCol = this.xStat.colName;
            var yCol = this.yStat.colName;
            if (xVector) {
                var maxPeer = (this.xMaxPeer) ? this.scaleData.xMax : undefined;
                xScale = this.makeScaleForCol(xVector, "number", 0, rcMarg.width, maxPeer);
            }
            if (yVector) {
                var ySum = (this.yMaxPeer) ? this.scaleData.yMax : yVector.sum(function (v) { return Math.abs(v); });
                yFactor = Math.max(0, (rcMarg.height - count * cellMargin) / ySum);
            }
            var hAlign = this.hAlign;
            var xCenter = rcMarg.left + rcMarg.width / 2;
            var yOffset = (this.reverse) ? (rcMarg.bottom - halfMargin) : (rcMarg.top + halfMargin);
            var yDir = (this.reverse) ? -1 : 1;
            for (var i = 0; i < data.length; i++) {
                var width = (xVector) ? xScale.scale(xVector[i]) : uniformWidth;
                var height = (yVector) ? (Math.abs(yVector[i]) * yFactor) : uniformHeight;
                ////---- make sure we can see all cells ----
                //width = Math.max(1, width);
                //height = Math.max(1, height);
                var left = rcMarg.left;
                if (xVector) {
                    if (hAlign == HAlign.center) {
                        left = xCenter - width / 2;
                    }
                    else if (hAlign == HAlign.right) {
                        left = rcMarg.right - width;
                    }
                }
                if (yDir == -1) {
                    var rcChild = vp.geom.createRect(left, yOffset - height, width, height);
                }
                else {
                    var rcChild = vp.geom.createRect(left, yOffset, width, height);
                }
                cellArray.push(CellData.fromRect(rcChild, this.cellShape));
                yOffset += yDir * (height + cellMargin);
            }
            return cellArray;
        };
        /** puts first shape at center, then packs other shapes around the first, starting at upper left corner of first shape. repeats
        until all shapes have been placed around the prior shapes.  */
        SpaceDivider.prototype.packOut = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            var halfSize = shapeSize / 2;
            var cx = rcMarg.left + rcMarg.width / 2 - halfSize;
            var cy = rcMarg.top + rcMarg.height / 2 - halfSize;
            var count = data.length;
            var cellMargin = this.cellMargin;
            //---- start algotirhm at dir=center ----
            var x = cx;
            var y = cy;
            var fillDir = FillDir.center;
            var dirMax = 1;
            var dirCount = 0;
            while (count--) {
                var rcChild = vp.geom.createRect(x, y, shapeSize, shapeSize);
                cellArray.push(CellData.fromRect(rcChild, this.cellShape));
                dirCount++;
                if (dirCount == dirMax) {
                    //---- change direction ----
                    if (fillDir == FillDir.down) {
                        fillDir = FillDir.right;
                    }
                    else if (fillDir == FillDir.right) {
                        fillDir = FillDir.up;
                    }
                    else if (fillDir == FillDir.up) {
                        fillDir = FillDir.left;
                    }
                    else if (fillDir == FillDir.left) {
                        fillDir = FillDir.down;
                        //---- start a new layer ----
                        dirMax += 2;
                        x -= (shapeSize + cellMargin);
                        y -= (shapeSize + cellMargin); // comphensate for upcoming y adjustment
                    }
                    dirCount = 0;
                }
                //---- move to next location ----
                if (fillDir == FillDir.center) {
                    //---- special handling for first shape ----
                    fillDir = FillDir.down;
                    dirMax = 2;
                    dirCount = 0;
                    x -= (shapeSize + cellMargin);
                }
                else if (fillDir == FillDir.down) {
                    y += (shapeSize + cellMargin);
                }
                else if (fillDir == FillDir.right) {
                    x += (shapeSize + cellMargin);
                }
                else if (fillDir == FillDir.up) {
                    y -= (shapeSize + cellMargin);
                }
                else if (fillDir == FillDir.left) {
                    x -= (shapeSize + cellMargin);
                }
            }
            return cellArray;
        };
        /** uses sunFlower drawing algorithm (aka fermat's apiral and disc phyllotaxis) to layout shapes in a spiral pattern that
        fills the specified space. */
        SpaceDivider.prototype.fillOut = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            var phyloSeed = 137.508; // "golden angle"
            var count = data.length;
            var xSize = rcMarg.width;
            var ySize = rcMarg.height;
            var radius = Math.min(xSize, ySize);
            var spacing = .5 * radius / Math.sqrt(count);
            var nextIndex = 0;
            var cx = rcMarg.left + rcMarg.width / 2;
            var cy = rcMarg.top + rcMarg.height / 2;
            for (var i = 0; i < count; i++) {
                //---- filtered code can calc stuff here, but it will not be used ----
                var r = spacing * Math.sqrt(i);
                var theta = Math.PI / 180 * (i * phyloSeed);
                var cxx = cx + r * Math.sin(theta);
                var cyy = cy + r * Math.cos(theta);
                var x = cxx - shapeSize / 2;
                var y = cyy - shapeSize / 2;
                var rcChild = vp.geom.createRect(x, y, shapeSize, shapeSize);
                cellArray.push(CellData.fromRect(rcChild, this.cellShape));
            }
            return cellArray;
        };
        SpaceDivider.prototype.fillXY = function (rcMarg, data) {
            var cellArray = [];
            var width = rcMarg.width;
            var height = rcMarg.height;
            var aspect = width / height;
            //---- space between facets ----
            var xMargin = this.cellMargin;
            var yMargin = this.cellMargin;
            var cellsPerRowByCount = {
                0: 0, 1: 1, 2: 2, 3: 3, 4: 2, 5: 3, 6: 3, 7: 4, 8: 4, 9: 3, 10: 5,
                11: 4, 12: 4, 13: 4, 14: 4, 15: 4, 16: 4
            };
            var count = data.length;
            //---- hard code layout for 0-16 cells ----
            var cellsPerRow = cellsPerRowByCount[count];
            if (cellsPerRow === undefined) {
                cellsPerRow = Math.ceil(Math.sqrt(aspect * count));
            }
            var rowCount = Math.ceil(count / cellsPerRow);
            //---- use whole numbers for sizes, for crisp drawing of frames ----
            var cellWidth = (width - xMargin * (cellsPerRow - 1)) / cellsPerRow;
            var cellHeight = (height - yMargin * (rowCount - 1)) / rowCount;
            var facetBounds = [];
            var margin2 = 2 * xMargin;
            for (var i = 0; i < count; i++) {
                var colIndex = Math.floor(i % cellsPerRow);
                var rowIndex = Math.floor(i / cellsPerRow);
                //---- use whole numbers for offsets ----
                //---- must align left cells to left edge of container (so labels outside are right next to them) ----
                var x = rcMarg.left + colIndex * (cellWidth + xMargin);
                var y = rcMarg.top + rowIndex * (cellHeight + yMargin);
                //---- make sure all facets are the SAME width and height (critical for shape drawing algorithm and visual comparisons) ----
                var rc = vp.geom.createRect(x, y, cellWidth, cellHeight);
                var cellData = CellData.fromRect(rc, this.cellShape);
                cellArray.push(cellData);
            }
            return cellArray;
        };
        SpaceDivider.prototype.packXY = function (rcMarg, data) {
            var _this = this;
            var cellMargin = this.cellMargin;
            var halfMargin = cellMargin / 2;
            var maxCount = (this.scaleData && this.scaleData.maxCount) ? this.scaleData.maxCount : this.getMaxCountInGroups(data);
            var aspect = rcMarg.width / rcMarg.height;
            var colCount = Math.ceil(Math.sqrt(aspect * maxCount));
            var rowCount = Math.ceil(maxCount / colCount);
            var boxWidth = rcMarg.width / colCount;
            var boxHeight = rcMarg.height / rowCount;
            var cellWidth = Math.max(0, boxWidth - cellMargin);
            var cellHeight = Math.max(0, boxHeight - cellMargin);
            var i = 0;
            var yStart = (this.reverse) ? (rcMarg.top + halfMargin) : (rcMarg.bottom - cellHeight - halfMargin);
            var yDir = (this.reverse) ? 1 : -1;
            var cellArray = data.map(function (d) {
                var colNum = i % colCount;
                var rowNum = Math.floor(i / colCount);
                var x = rcMarg.left + halfMargin + colNum * boxWidth;
                var y = yStart + yDir * rowNum * boxHeight;
                i++;
                return CellData.fromRect(vp.geom.createRect(x, y, cellWidth, cellHeight), _this.cellShape);
            });
            return cellArray;
        };
        SpaceDivider.prototype.packYX = function (rcMarg, data) {
            var _this = this;
            var cellMargin = this.cellMargin;
            var halfMargin = cellMargin / 2;
            var maxCount = (this.scaleData && this.scaleData.maxCount) ? this.scaleData.maxCount : this.getMaxCountInGroups(data);
            var aspect = rcMarg.width / rcMarg.height;
            var rowCount = Math.ceil(Math.sqrt(maxCount / aspect));
            var colCount = Math.ceil(maxCount / rowCount);
            var boxWidth = rcMarg.width / colCount;
            var boxHeight = rcMarg.height / rowCount;
            var cellWidth = Math.max(0, boxWidth - cellMargin);
            var cellHeight = Math.max(0, boxHeight - cellMargin);
            var i = 0;
            var yStart = (this.reverse) ? (rcMarg.top + halfMargin) : (rcMarg.bottom - cellHeight - halfMargin);
            var yDir = (this.reverse) ? 1 : -1;
            var cellArray = data.map(function (d) {
                var rowNum = i % rowCount;
                var colNum = Math.floor(i / rowCount);
                var x = rcMarg.left + halfMargin + colNum * boxWidth;
                var y = yStart + yDir * rowNum * boxHeight;
                i++;
                return CellData.fromRect(vp.geom.createRect(x, y, cellWidth, cellHeight), _this.cellShape);
            });
            return cellArray;
        };
        SpaceDivider.prototype.getMaxCountInGroups = function (frameOrArray) {
            var maxCount = 0;
            if (frameOrArray.array) {
                var firstGroup = frameOrArray.array[0];
                var isArray = (vp.utils.isArray(firstGroup));
                if (isArray) {
                    for (var i = 0; i < frameOrArray.length; i++) {
                        var group = frameOrArray[i];
                        var count = group.length;
                        maxCount = Math.max(maxCount, count);
                    }
                }
                else {
                    //----- just a set of records ----
                    maxCount = frameOrArray.length;
                }
            }
            else {
                //----- just a set of records ----
                maxCount = frameOrArray.length;
            }
            //---- don't exceed our demo-tool max ----
            if (beachParty.maxContainers) {
                maxCount = Math.min(maxCount, beachParty.maxContainers);
            }
            return maxCount;
        };
        SpaceDivider.prototype.drawContainerOutlines = function (svg, cellArray, data) {
            //---- draw containers in red ----
            for (var i = 0; i < cellArray.length; i++) {
                var cellData = cellArray[i];
                var rcx = cellData.rect;
                var dataGroup = data.getItem(i);
                var name = null;
                if (dataGroup.ctr == "dataFrameClass") {
                    name = (dataGroup._groupName) ? dataGroup._groupName : data.name;
                }
                else if (this.labelColName) {
                    name = dataGroup[this.labelColName];
                }
                if (this.showContainers) {
                    //---- make sure container is visible ----
                    var width = Math.max(2, rcx.width);
                    var height = Math.max(2, rcx.height);
                    if (this.cellShape == CellShape.rectangle) {
                        vp.select(svg).append("rect")
                            .bounds(rcx.left, rcx.top, width, height)
                            .colors(this.containerFill, this.containerStroke, this.containerStrokeSize);
                    }
                    else {
                        var radius = Math.min(width, height) / 2;
                        var cx = rcx.left + rcx.width / 2;
                        var cy = rcx.top + rcx.height / 2;
                        vp.select(svg).append("circle")
                            .attr("cx", cx)
                            .attr("cy", cy)
                            .attr("r", radius)
                            .colors(this.containerFill, this.containerStroke, this.containerStrokeSize);
                    }
                }
                if (this.showCounts) {
                    var groupCount = dataGroup.length;
                    var yText = rcx.top + 20;
                    if (this.spaceType == SpaceType.fillX) {
                        //groupCount = Math.min(maxContainers, groupCount);
                        yText = rcx.bottom;
                    }
                    vp.select(svg).append("text")
                        .text(data + "")
                        .attr("x", rcx.left + rcx.width / 2)
                        .attr("y", yText)
                        .attr("text-anchor", "middle")
                        .colors("black", "none", 0);
                }
                //---- draw label ----
                var minWidth = 10;
                var minHeight = 10;
                if (this.showLabels && name && rcx.width >= minWidth && rcx.height >= minHeight) {
                    var cdAdj = this.drawLabelsOnTop(cellData, svg, name);
                    cellArray[i] = cdAdj;
                }
            }
        };
        SpaceDivider.prototype.showStuff = function (showContainers, showCounts) {
            this.showContainers = showContainers;
            this.showCounts = showCounts;
        };
        return SpaceDivider;
    }());
    beachParty.SpaceDivider = SpaceDivider;
    var FillDir;
    (function (FillDir) {
        FillDir[FillDir["center"] = 0] = "center";
        FillDir[FillDir["down"] = 1] = "down";
        FillDir[FillDir["right"] = 2] = "right";
        FillDir[FillDir["up"] = 3] = "up";
        FillDir[FillDir["left"] = 4] = "left";
    })(FillDir || (FillDir = {}));
    (function (SpaceType) {
        SpaceType[SpaceType["none"] = 0] = "none";
        SpaceType[SpaceType["choropleth"] = 1] = "choropleth";
        SpaceType[SpaceType["fillX"] = 2] = "fillX";
        SpaceType[SpaceType["fillY"] = 3] = "fillY";
        SpaceType[SpaceType["fillXY"] = 4] = "fillXY";
        SpaceType[SpaceType["fillOut"] = 5] = "fillOut";
        SpaceType[SpaceType["packXY"] = 6] = "packXY";
        SpaceType[SpaceType["packYX"] = 7] = "packYX";
        SpaceType[SpaceType["packOut"] = 8] = "packOut";
        SpaceType[SpaceType["plotXY"] = 9] = "plotXY";
        SpaceType[SpaceType["polarXY"] = 10] = "polarXY";
        SpaceType[SpaceType["overlay"] = 11] = "overlay";
        SpaceType[SpaceType["poisson"] = 12] = "poisson";
        SpaceType[SpaceType["random"] = 13] = "random";
        SpaceType[SpaceType["record"] = 14] = "record";
        SpaceType[SpaceType["squarify"] = 15] = "squarify";
    })(beachParty.SpaceType || (beachParty.SpaceType = {}));
    var SpaceType = beachParty.SpaceType;
    (function (CellShape) {
        CellShape[CellShape["circle"] = 0] = "circle";
        CellShape[CellShape["path"] = 1] = "path";
        CellShape[CellShape["pieSlice"] = 2] = "pieSlice";
        CellShape[CellShape["rectangle"] = 3] = "rectangle";
    })(beachParty.CellShape || (beachParty.CellShape = {}));
    var CellShape = beachParty.CellShape;
    (function (HAlign) {
        HAlign[HAlign["left"] = 0] = "left";
        HAlign[HAlign["center"] = 1] = "center";
        HAlign[HAlign["right"] = 2] = "right";
    })(beachParty.HAlign || (beachParty.HAlign = {}));
    var HAlign = beachParty.HAlign;
    (function (VAlign) {
        VAlign[VAlign["top"] = 0] = "top";
        VAlign[VAlign["middle"] = 1] = "middle";
        VAlign[VAlign["bottom"] = 2] = "bottom";
    })(beachParty.VAlign || (beachParty.VAlign = {}));
    var VAlign = beachParty.VAlign;
    /** Type of statistic to gather about children of current container. Some stats use "statCol". */
    (function (StatType) {
        StatType[StatType["none"] = 0] = "none";
        StatType[StatType["count"] = 1] = "count";
        StatType[StatType["min"] = 2] = "min";
        StatType[StatType["max"] = 3] = "max";
        StatType[StatType["sum"] = 4] = "sum";
        StatType[StatType["avg"] = 5] = "avg";
        StatType[StatType["median"] = 6] = "median";
        StatType[StatType["mode"] = 7] = "mode";
        StatType[StatType["std"] = 8] = "std";
        StatType[StatType["variance"] = 9] = "variance";
    })(beachParty.StatType || (beachParty.StatType = {}));
    var StatType = beachParty.StatType;
    var StatInfo = (function () {
        function StatInfo(colName, statType) {
            if (colName === void 0) { colName = ""; }
            if (statType === void 0) { statType = StatType.none; }
            this.colValueTransform = null; // a callback to transform col value before building stat (e.g., Math.abs)
            this.statType = statType;
            this.colName = colName;
            this.peerScale = false;
            this.colValueTransform = null;
        }
        StatInfo.prototype.getAggColName = function () {
            var name = this.colName;
            if (this.statType == StatType.count) {
                name = "Count@";
            }
            else {
                var statType = (this.statType == StatType.none) ? "sum" : StatType[this.statType];
                name = statType.capitalize() + "@" + name;
            }
            return name;
        };
        return StatInfo;
    }());
    beachParty.StatInfo = StatInfo;
    var CircleData = (function () {
        function CircleData(cx, cy, radius) {
            this.cx = cx;
            this.cy = cy;
            this.radius = radius;
        }
        return CircleData;
    }());
    beachParty.CircleData = CircleData;
    var PieSliceData = (function (_super) {
        __extends(PieSliceData, _super);
        function PieSliceData() {
            _super.apply(this, arguments);
        }
        return PieSliceData;
    }(CircleData));
    beachParty.PieSliceData = PieSliceData;
    var CellData = (function () {
        function CellData() {
        }
        CellData.fromRect = function (rect, cellShape) {
            var cd = new CellData();
            cd.cellShape = cellShape;
            cd.rect = rect;
            if (cellShape == CellShape.circle) {
                var radius = Math.min(rect.width, rect.height) / 2;
                cd.circle = new CircleData(rect.left + rect.width / 2, rect.top + rect.height / 2, radius);
            }
            return cd;
        };
        return CellData;
    }());
    beachParty.CellData = CellData;
    (function (ChoroMapType) {
        ChoroMapType[ChoroMapType["none"] = 0] = "none";
        ChoroMapType[ChoroMapType["usStates"] = 1] = "usStates";
        ChoroMapType[ChoroMapType["usCounties"] = 2] = "usCounties";
    })(beachParty.ChoroMapType || (beachParty.ChoroMapType = {}));
    var ChoroMapType = beachParty.ChoroMapType;
    (function (LabelPositon) {
        LabelPositon[LabelPositon["left"] = 0] = "left";
        LabelPositon[LabelPositon["top"] = 1] = "top";
        LabelPositon[LabelPositon["right"] = 2] = "right";
        LabelPositon[LabelPositon["bottom"] = 3] = "bottom";
    })(beachParty.LabelPositon || (beachParty.LabelPositon = {}));
    var LabelPositon = beachParty.LabelPositon;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    squarifyLayout.ts - lays out items in a single-level squarified treemap.
//    adapted from: "Squarified Treemaps" paper by Mark Bruls, et al.  
//    http://www.win.tue.nl/~vanwijk/stm.pdf
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var squarifyLayoutClass = (function () {
        function squarifyLayoutClass() {
            this._isRowVertical = false;
            this._cellArray = [];
            this._cellMargin = 0;
            this._sortedPairs = [];
        }
        squarifyLayoutClass.prototype.layout = function (origValues, rc, cellMargin) {
            //---- use TEST DATA ----
            //values = [6, 6, 4, 3, 2, 2, 1];
            //rc = vp.geom.createRect(0, 0, 600, 400);
            var valuePairs = [];
            var now = vp.utils.now();
            //---- ensure all values are not too small, and pair them with a record index ----
            for (var i = 0; i < origValues.length; i++) {
                var value = Math.max(.00001, origValues[i]);
                valuePairs[i] = { value: value, index: i };
            }
            //---- sort the values ----
            var sortedPairs = valuePairs.orderByNum(function (v) { return v.value; });
            sortedPairs = sortedPairs.reverse();
            this._sortedPairs = sortedPairs;
            //---- extract just the values ----
            var values = sortedPairs.map(function (v) { return v.value; });
            //---- normalize the data to the size of the rc ----
            var area = rc.width * rc.height;
            var totalSum = values.sum();
            for (var i = 0; i < values.length; i++) {
                values[i] = values[i] / totalSum * area;
            }
            this._values = values;
            this._rc = rc;
            this._cellMargin = cellMargin;
            //---- report time taken to prep the data ----
            var elapsed = vp.utils.now() - now;
            var msg = "data prep of SQUARIFY took: " + elapsed + " ms";
            vp.utils.debug(msg);
            //vp.select("#consoleDiv").text(msg);
            var now = vp.utils.now();
            this.squarify();
            //---- report time taken to layout the cells ----
            var elapsed = vp.utils.now() - now;
            var msg = "cell layout of SQUARIFY took: " + elapsed + " ms";
            vp.utils.debug(msg);
            //vp.select("#consoleDiv").text(msg);
            return this._cellArray;
        };
        /** Returns the highest aspect ratio of the list of rectangles represented by "row". */
        squarifyLayoutClass.prototype.worst = function (row, w) {
            var wSquare = w * w;
            var sum = row.sum();
            var sSquare = sum * sum;
            var rMax = row.max();
            var rMin = row.min();
            var maxRatio = Math.max(wSquare * rMax / sSquare, sSquare / (wSquare * rMin));
            return maxRatio;
        };
        /** layout out the relative area sizes in "row", as a vertical or horizontal row in "rc". */
        squarifyLayoutClass.prototype.layoutRow = function (row, rowIndexes, remainingChildren) {
            var rowSum = row.sum();
            var totalSum = (remainingChildren.length) ? (rowSum + remainingChildren.sum()) : rowSum;
            var rc = this._rc;
            var left = rc.left;
            var cm = this._cellMargin;
            var cm2 = 2 * cm;
            if (this._isRowVertical) {
                //---- layout VERTICAL ROW (divisions in Y) ----
                var heightFactor = rc.height / rowSum;
                var width = rc.width * rowSum / totalSum;
                var adjWidth = Math.max(0, width - cm2);
                var bottom = rc.bottom;
                for (var i = 0; i < row.length; i++) {
                    var height = row[i] * heightFactor;
                    var adjHeight = Math.max(0, height - cm2);
                    var rcChild = vp.geom.createRect(left + cm, bottom - height + cm, adjWidth, adjHeight);
                    var cdChild = beachParty.CellData.fromRect(rcChild, beachParty.CellShape.rectangle);
                    //---- add index back to original data record ----
                    var index = rowIndexes[i];
                    this._cellArray[index] = cdChild;
                    bottom -= height;
                }
                //---- subtract used space from "rc" ----
                this._rc = vp.geom.createRect(rc.left + width, rc.top, rc.width - width, rc.height);
            }
            else {
                //---- layout HORIZONTAL ROW (divisions in X) ----
                var widthFactor = rc.width / rowSum;
                var height = rc.height * rowSum / totalSum;
                var adjHeight = Math.max(0, height - cm2);
                var top = rc.bottom - height;
                for (var i = 0; i < row.length; i++) {
                    var width = row[i] * widthFactor;
                    var adjWidth = Math.max(0, width - cm2);
                    var rcChild = vp.geom.createRect(left + cm, top + cm, adjWidth, adjHeight);
                    var cdChild = beachParty.CellData.fromRect(rcChild, beachParty.CellShape.rectangle);
                    //---- add index back to original data record ----
                    var index = rowIndexes[i];
                    this._cellArray[index] = cdChild;
                    left += width;
                }
                //---- subtract used space from "rc" ----
                this._rc = vp.geom.createRect(rc.left, rc.top, rc.width, rc.height - height);
            }
        };
        /** returns the length of the shortest side of remaining subrect in which current row is placed (this._rc). */
        squarifyLayoutClass.prototype.width = function () {
            var rc = this._rc;
            this._isRowVertical = (rc.width > rc.height);
            return Math.min(rc.width, rc.height);
        };
        squarifyLayoutClass.prototype.squarify = function () {
            var row = [];
            var rowIndexes = [];
            var nextRowIndex = 0;
            var children = this._values;
            var w = this.width();
            while (children.length) {
                var c = children[0];
                var wCurrent = this.worst(row, w);
                var wNext = this.worst(row.concat(c), w);
                //vp.utils.debug("squarify: c=" + c + ", wCurrent=" + wCurrent + ", wNext=" + wNext);
                //if (this.worst(row, w) <= this.worst(row.concat(c), w))
                if (row.length == 0 || (wNext <= wCurrent)) {
                    children.removeAt(0);
                    row.push(c);
                    var origRowIndex = this._sortedPairs[nextRowIndex++].index;
                    rowIndexes.push(origRowIndex);
                }
                else {
                    this.layoutRow(row, rowIndexes, children);
                    row = [];
                    rowIndexes = [];
                    w = this.width();
                }
            }
            this.layoutRow(row, rowIndexes, children);
        };
        return squarifyLayoutClass;
    }());
    beachParty.squarifyLayoutClass = squarifyLayoutClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    dampener.ts - class for smoothing out drag/pinch motion, as applied to world matrix.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var dampenerClass = (function () {
        function dampenerClass(applyCallback) {
            this._applyCallback = null;
            this._dampenFactor = .1; //   .3;     // .7;
            this._keepMoving = true;
            this._isOperationActive = false;
            this._firstTargetFrame = true;
            this._applyCallback = applyCallback;
            this._slidingWindow = new beachParty.slidingWindowClass(dampenerClass.windowDuration);
            this.startUiOperation();
        }
        dampenerClass.prototype.inertia = function (value) {
            if (arguments.length == 0) {
                return (this._isOperationActive) ? 0 : this._firstActual;
            }
            this._firstActual = value;
        };
        dampenerClass.prototype.hasInertia = function () {
            var has = (!this._isOperationActive) && (this._firstActual != 0);
            return has;
        };
        dampenerClass.prototype.startUiOperation = function () {
            this._target = 0;
            this._accum = 0;
            this._firstActual = 0;
            this._isOperationActive = true;
            //vp.utils.debug("startUiOperation called");
        };
        dampenerClass.prototype.stopUIOperation = function () {
            this._isOperationActive = false;
            //vp.utils.debug("stopUIOperation called");
            //---- if we didn't move the requd distance in last "windowDuration" ms, clear the inertia ----
            var samples = this._slidingWindow.getSamples();
            var count = samples.length;
            var dist = Math.abs(samples.sum(function (samp) { return +samp.value; }));
            //vp.utils.debug("--> length=" + count + ", dist=" + dist);
            if (count < 7) {
                this._firstActual = 0;
            }
        };
        dampenerClass.prototype.setTarget = function (value) {
            this._target += value;
            this._firstTargetFrame = true;
            this._slidingWindow.addSample(value);
            //vp.utils.debug("dampener.setTarget: value=" + value);
        };
        dampenerClass.prototype.apply = function (value) {
            if (Math.abs(value) > .0001) {
                if (this._applyCallback) {
                    this._applyCallback(value);
                }
            }
        };
        /**
         *  this must be called on each frame move.
         */
        dampenerClass.prototype.onFrameApply = function () {
            var hasInertia = false;
            if (this._isOperationActive) {
                if (this._accum != this._target) {
                    var frameTarget = vp.data.lerp(this._dampenFactor, this._accum, this._target);
                    var actual = frameTarget - this._accum;
                    //vp.utils.debug("dampener.onFrameApply: accum=" + this._accum + ", target=" + this._target +
                    //    ", frameTarget=" + frameTarget + ", actual=" + actual);
                    this.apply(actual);
                    if (this._firstTargetFrame) {
                        this._firstActual = actual;
                        this._firstTargetFrame = false;
                    }
                    this._accum = frameTarget;
                }
            }
            else if (this._keepMoving) {
                this.apply(this._firstActual);
                var epsilon = .001;
                hasInertia = (Math.abs(this._firstActual) > epsilon);
            }
            return hasInertia;
        };
        dampenerClass.createCycle = function (group, data) {
            var count = data.length;
            //---- draw circles ----
            for (var i = 0; i < count; i++) {
            }
            //---- draw arrows ----
            for (var i = 0; i < count; i++) {
            }
        };
        dampenerClass.windowDuration = 500; // ms
        return dampenerClass;
    }());
    beachParty.dampenerClass = dampenerClass;
})(beachParty || (beachParty = {}));
﻿/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
!function (a, b, c, d) { "use strict"; function e(a, b, c) { return setTimeout(k(a, c), b) } function f(a, b, c) { return Array.isArray(a) ? (g(a, c[b], c), !0) : !1 } function g(a, b, c) { var e; if (a) if (a.forEach) a.forEach(b, c); else if (a.length !== d) for (e = 0; e < a.length;) b.call(c, a[e], e, a), e++; else for (e in a) a.hasOwnProperty(e) && b.call(c, a[e], e, a) } function h(a, b, c) { for (var e = Object.keys(b), f = 0; f < e.length;) (!c || c && a[e[f]] === d) && (a[e[f]] = b[e[f]]), f++; return a } function i(a, b) { return h(a, b, !0) } function j(a, b, c) { var d, e = b.prototype; d = a.prototype = Object.create(e), d.constructor = a, d._super = e, c && h(d, c) } function k(a, b) { return function () { return a.apply(b, arguments) } } function l(a, b) { return typeof a == kb ? a.apply(b ? b[0] || d : d, b) : a } function m(a, b) { return a === d ? b : a } function n(a, b, c) { g(r(b), function (b) { a.addEventListener(b, c, !1) }) } function o(a, b, c) { g(r(b), function (b) { a.removeEventListener(b, c, !1) }) } function p(a, b) { for (; a;) { if (a == b) return !0; a = a.parentNode } return !1 } function q(a, b) { return a.indexOf(b) > -1 } function r(a) { return a.trim().split(/\s+/g) } function s(a, b, c) { if (a.indexOf && !c) return a.indexOf(b); for (var d = 0; d < a.length;) { if (c && a[d][c] == b || !c && a[d] === b) return d; d++ } return -1 } function t(a) { return Array.prototype.slice.call(a, 0) } function u(a, b, c) { for (var d = [], e = [], f = 0; f < a.length;) { var g = b ? a[f][b] : a[f]; s(e, g) < 0 && d.push(a[f]), e[f] = g, f++ } return c && (d = b ? d.sort(function (a, c) { return a[b] > c[b] }) : d.sort()), d } function v(a, b) { for (var c, e, f = b[0].toUpperCase() + b.slice(1), g = 0; g < ib.length;) { if (c = ib[g], e = c ? c + f : b, e in a) return e; g++ } return d } function w() { return ob++ } function x(a) { var b = a.ownerDocument; return b.defaultView || b.parentWindow } function y(a, b) { var c = this; this.manager = a, this.callback = b, this.element = a.element, this.target = a.options.inputTarget, this.domHandler = function (b) { l(a.options.enable, [a]) && c.handler(b) }, this.init() } function z(a) { var b, c = a.options.inputClass; return new (b = c ? c : rb ? N : sb ? Q : qb ? S : M)(a, A) } function A(a, b, c) { var d = c.pointers.length, e = c.changedPointers.length, f = b & yb && d - e === 0, g = b & (Ab | Bb) && d - e === 0; c.isFirst = !!f, c.isFinal = !!g, f && (a.session = {}), c.eventType = b, B(a, c), a.emit("hammer.input", c), a.recognize(c), a.session.prevInput = c } function B(a, b) { var c = a.session, d = b.pointers, e = d.length; c.firstInput || (c.firstInput = E(b)), e > 1 && !c.firstMultiple ? c.firstMultiple = E(b) : 1 === e && (c.firstMultiple = !1); var f = c.firstInput, g = c.firstMultiple, h = g ? g.center : f.center, i = b.center = F(d); b.timeStamp = nb(), b.deltaTime = b.timeStamp - f.timeStamp, b.angle = J(h, i), b.distance = I(h, i), C(c, b), b.offsetDirection = H(b.deltaX, b.deltaY), b.scale = g ? L(g.pointers, d) : 1, b.rotation = g ? K(g.pointers, d) : 0, D(c, b); var j = a.element; p(b.srcEvent.target, j) && (j = b.srcEvent.target), b.target = j } function C(a, b) { var c = b.center, d = a.offsetDelta || {}, e = a.prevDelta || {}, f = a.prevInput || {}; (b.eventType === yb || f.eventType === Ab) && (e = a.prevDelta = { x: f.deltaX || 0, y: f.deltaY || 0 }, d = a.offsetDelta = { x: c.x, y: c.y }), b.deltaX = e.x + (c.x - d.x), b.deltaY = e.y + (c.y - d.y) } function D(a, b) { var c, e, f, g, h = a.lastInterval || b, i = b.timeStamp - h.timeStamp; if (b.eventType != Bb && (i > xb || h.velocity === d)) { var j = h.deltaX - b.deltaX, k = h.deltaY - b.deltaY, l = G(i, j, k); e = l.x, f = l.y, c = mb(l.x) > mb(l.y) ? l.x : l.y, g = H(j, k), a.lastInterval = b } else c = h.velocity, e = h.velocityX, f = h.velocityY, g = h.direction; b.velocity = c, b.velocityX = e, b.velocityY = f, b.direction = g } function E(a) { for (var b = [], c = 0; c < a.pointers.length;) b[c] = { clientX: lb(a.pointers[c].clientX), clientY: lb(a.pointers[c].clientY) }, c++; return { timeStamp: nb(), pointers: b, center: F(b), deltaX: a.deltaX, deltaY: a.deltaY } } function F(a) { var b = a.length; if (1 === b) return { x: lb(a[0].clientX), y: lb(a[0].clientY) }; for (var c = 0, d = 0, e = 0; b > e;) c += a[e].clientX, d += a[e].clientY, e++; return { x: lb(c / b), y: lb(d / b) } } function G(a, b, c) { return { x: b / a || 0, y: c / a || 0 } } function H(a, b) { return a === b ? Cb : mb(a) >= mb(b) ? a > 0 ? Db : Eb : b > 0 ? Fb : Gb } function I(a, b, c) { c || (c = Kb); var d = b[c[0]] - a[c[0]], e = b[c[1]] - a[c[1]]; return Math.sqrt(d * d + e * e) } function J(a, b, c) { c || (c = Kb); var d = b[c[0]] - a[c[0]], e = b[c[1]] - a[c[1]]; return 180 * Math.atan2(e, d) / Math.PI } function K(a, b) { return J(b[1], b[0], Lb) - J(a[1], a[0], Lb) } function L(a, b) { return I(b[0], b[1], Lb) / I(a[0], a[1], Lb) } function M() { this.evEl = Nb, this.evWin = Ob, this.allow = !0, this.pressed = !1, y.apply(this, arguments) } function N() { this.evEl = Rb, this.evWin = Sb, y.apply(this, arguments), this.store = this.manager.session.pointerEvents = [] } function O() { this.evTarget = Ub, this.evWin = Vb, this.started = !1, y.apply(this, arguments) } function P(a, b) { var c = t(a.touches), d = t(a.changedTouches); return b & (Ab | Bb) && (c = u(c.concat(d), "identifier", !0)), [c, d] } function Q() { this.evTarget = Xb, this.targetIds = {}, y.apply(this, arguments) } function R(a, b) { var c = t(a.touches), d = this.targetIds; if (b & (yb | zb) && 1 === c.length) return d[c[0].identifier] = !0, [c, c]; var e, f, g = t(a.changedTouches), h = [], i = this.target; if (f = c.filter(function (a) { return p(a.target, i) }), b === yb) for (e = 0; e < f.length;) d[f[e].identifier] = !0, e++; for (e = 0; e < g.length;) d[g[e].identifier] && h.push(g[e]), b & (Ab | Bb) && delete d[g[e].identifier], e++; return h.length ? [u(f.concat(h), "identifier", !0), h] : void 0 } function S() { y.apply(this, arguments); var a = k(this.handler, this); this.touch = new Q(this.manager, a), this.mouse = new M(this.manager, a) } function T(a, b) { this.manager = a, this.set(b) } function U(a) { if (q(a, bc)) return bc; var b = q(a, cc), c = q(a, dc); return b && c ? cc + " " + dc : b || c ? b ? cc : dc : q(a, ac) ? ac : _b } function V(a) { this.id = w(), this.manager = null, this.options = i(a || {}, this.defaults), this.options.enable = m(this.options.enable, !0), this.state = ec, this.simultaneous = {}, this.requireFail = [] } function W(a) { return a & jc ? "cancel" : a & hc ? "end" : a & gc ? "move" : a & fc ? "start" : "" } function X(a) { return a == Gb ? "down" : a == Fb ? "up" : a == Db ? "left" : a == Eb ? "right" : "" } function Y(a, b) { var c = b.manager; return c ? c.get(a) : a } function Z() { V.apply(this, arguments) } function $() { Z.apply(this, arguments), this.pX = null, this.pY = null } function _() { Z.apply(this, arguments) } function ab() { V.apply(this, arguments), this._timer = null, this._input = null } function bb() { Z.apply(this, arguments) } function cb() { Z.apply(this, arguments) } function db() { V.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0 } function eb(a, b) { return b = b || {}, b.recognizers = m(b.recognizers, eb.defaults.preset), new fb(a, b) } function fb(a, b) { b = b || {}, this.options = i(b, eb.defaults), this.options.inputTarget = this.options.inputTarget || a, this.handlers = {}, this.session = {}, this.recognizers = [], this.element = a, this.input = z(this), this.touchAction = new T(this, this.options.touchAction), gb(this, !0), g(b.recognizers, function (a) { var b = this.add(new a[0](a[1])); a[2] && b.recognizeWith(a[2]), a[3] && b.requireFailure(a[3]) }, this) } function gb(a, b) { var c = a.element; g(a.options.cssProps, function (a, d) { c.style[v(c.style, d)] = b ? a : "" }) } function hb(a, c) { var d = b.createEvent("Event"); d.initEvent(a, !0, !0), d.gesture = c, c.target.dispatchEvent(d) } var ib = ["", "webkit", "moz", "MS", "ms", "o"], jb = b.createElement("div"), kb = "function", lb = Math.round, mb = Math.abs, nb = Date.now, ob = 1, pb = /mobile|tablet|ip(ad|hone|od)|android/i, qb = "ontouchstart" in a, rb = v(a, "PointerEvent") !== d, sb = qb && pb.test(navigator.userAgent), tb = "touch", ub = "pen", vb = "mouse", wb = "kinect", xb = 25, yb = 1, zb = 2, Ab = 4, Bb = 8, Cb = 1, Db = 2, Eb = 4, Fb = 8, Gb = 16, Hb = Db | Eb, Ib = Fb | Gb, Jb = Hb | Ib, Kb = ["x", "y"], Lb = ["clientX", "clientY"]; y.prototype = { handler: function () { }, init: function () { this.evEl && n(this.element, this.evEl, this.domHandler), this.evTarget && n(this.target, this.evTarget, this.domHandler), this.evWin && n(x(this.element), this.evWin, this.domHandler) }, destroy: function () { this.evEl && o(this.element, this.evEl, this.domHandler), this.evTarget && o(this.target, this.evTarget, this.domHandler), this.evWin && o(x(this.element), this.evWin, this.domHandler) } }; var Mb = { mousedown: yb, mousemove: zb, mouseup: Ab }, Nb = "mousedown", Ob = "mousemove mouseup"; j(M, y, { handler: function (a) { var b = Mb[a.type]; b & yb && 0 === a.button && (this.pressed = !0), b & zb && 1 !== a.which && (b = Ab), this.pressed && this.allow && (b & Ab && (this.pressed = !1), this.callback(this.manager, b, { pointers: [a], changedPointers: [a], pointerType: vb, srcEvent: a })) } }); var Pb = { pointerdown: yb, pointermove: zb, pointerup: Ab, pointercancel: Bb, pointerout: Bb }, Qb = { 2: tb, 3: ub, 4: vb, 5: wb }, Rb = "pointerdown", Sb = "pointermove pointerup pointercancel"; a.MSPointerEvent && (Rb = "MSPointerDown", Sb = "MSPointerMove MSPointerUp MSPointerCancel"), j(N, y, { handler: function (a) { var b = this.store, c = !1, d = a.type.toLowerCase().replace("ms", ""), e = Pb[d], f = Qb[a.pointerType] || a.pointerType, g = f == tb, h = s(b, a.pointerId, "pointerId"); e & yb && (0 === a.button || g) ? 0 > h && (b.push(a), h = b.length - 1) : e & (Ab | Bb) && (c = !0), 0 > h || (b[h] = a, this.callback(this.manager, e, { pointers: b, changedPointers: [a], pointerType: f, srcEvent: a }), c && b.splice(h, 1)) } }); var Tb = { touchstart: yb, touchmove: zb, touchend: Ab, touchcancel: Bb }, Ub = "touchstart", Vb = "touchstart touchmove touchend touchcancel"; j(O, y, { handler: function (a) { var b = Tb[a.type]; if (b === yb && (this.started = !0), this.started) { var c = P.call(this, a, b); b & (Ab | Bb) && c[0].length - c[1].length === 0 && (this.started = !1), this.callback(this.manager, b, { pointers: c[0], changedPointers: c[1], pointerType: tb, srcEvent: a }) } } }); var Wb = { touchstart: yb, touchmove: zb, touchend: Ab, touchcancel: Bb }, Xb = "touchstart touchmove touchend touchcancel"; j(Q, y, { handler: function (a) { var b = Wb[a.type], c = R.call(this, a, b); c && this.callback(this.manager, b, { pointers: c[0], changedPointers: c[1], pointerType: tb, srcEvent: a }) } }), j(S, y, { handler: function (a, b, c) { var d = c.pointerType == tb, e = c.pointerType == vb; if (d) this.mouse.allow = !1; else if (e && !this.mouse.allow) return; b & (Ab | Bb) && (this.mouse.allow = !0), this.callback(a, b, c) }, destroy: function () { this.touch.destroy(), this.mouse.destroy() } }); var Yb = v(jb.style, "touchAction"), Zb = Yb !== d, $b = "compute", _b = "auto", ac = "manipulation", bc = "none", cc = "pan-x", dc = "pan-y"; T.prototype = { set: function (a) { a == $b && (a = this.compute()), Zb && (this.manager.element.style[Yb] = a), this.actions = a.toLowerCase().trim() }, update: function () { this.set(this.manager.options.touchAction) }, compute: function () { var a = []; return g(this.manager.recognizers, function (b) { l(b.options.enable, [b]) && (a = a.concat(b.getTouchAction())) }), U(a.join(" ")) }, preventDefaults: function (a) { if (!Zb) { var b = a.srcEvent, c = a.offsetDirection; if (this.manager.session.prevented) return void b.preventDefault(); var d = this.actions, e = q(d, bc), f = q(d, dc), g = q(d, cc); return e || f && c & Hb || g && c & Ib ? this.preventSrc(b) : void 0 } }, preventSrc: function (a) { this.manager.session.prevented = !0, a.preventDefault() } }; var ec = 1, fc = 2, gc = 4, hc = 8, ic = hc, jc = 16, kc = 32; V.prototype = { defaults: {}, set: function (a) { return h(this.options, a), this.manager && this.manager.touchAction.update(), this }, recognizeWith: function (a) { if (f(a, "recognizeWith", this)) return this; var b = this.simultaneous; return a = Y(a, this), b[a.id] || (b[a.id] = a, a.recognizeWith(this)), this }, dropRecognizeWith: function (a) { return f(a, "dropRecognizeWith", this) ? this : (a = Y(a, this), delete this.simultaneous[a.id], this) }, requireFailure: function (a) { if (f(a, "requireFailure", this)) return this; var b = this.requireFail; return a = Y(a, this), -1 === s(b, a) && (b.push(a), a.requireFailure(this)), this }, dropRequireFailure: function (a) { if (f(a, "dropRequireFailure", this)) return this; a = Y(a, this); var b = s(this.requireFail, a); return b > -1 && this.requireFail.splice(b, 1), this }, hasRequireFailures: function () { return this.requireFail.length > 0 }, canRecognizeWith: function (a) { return !!this.simultaneous[a.id] }, emit: function (a) { function b(b) { c.manager.emit(c.options.event + (b ? W(d) : ""), a) } var c = this, d = this.state; hc > d && b(!0), b(), d >= hc && b(!0) }, tryEmit: function (a) { return this.canEmit() ? this.emit(a) : void (this.state = kc) }, canEmit: function () { for (var a = 0; a < this.requireFail.length;) { if (!(this.requireFail[a].state & (kc | ec))) return !1; a++ } return !0 }, recognize: function (a) { var b = h({}, a); return l(this.options.enable, [this, b]) ? (this.state & (ic | jc | kc) && (this.state = ec), this.state = this.process(b), void (this.state & (fc | gc | hc | jc) && this.tryEmit(b))) : (this.reset(), void (this.state = kc)) }, process: function () { }, getTouchAction: function () { }, reset: function () { } }, j(Z, V, { defaults: { pointers: 1 }, attrTest: function (a) { var b = this.options.pointers; return 0 === b || a.pointers.length === b }, process: function (a) { var b = this.state, c = a.eventType, d = b & (fc | gc), e = this.attrTest(a); return d && (c & Bb || !e) ? b | jc : d || e ? c & Ab ? b | hc : b & fc ? b | gc : fc : kc } }), j($, Z, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: Jb }, getTouchAction: function () { var a = this.options.direction, b = []; return a & Hb && b.push(dc), a & Ib && b.push(cc), b }, directionTest: function (a) { var b = this.options, c = !0, d = a.distance, e = a.direction, f = a.deltaX, g = a.deltaY; return e & b.direction || (b.direction & Hb ? (e = 0 === f ? Cb : 0 > f ? Db : Eb, c = f != this.pX, d = Math.abs(a.deltaX)) : (e = 0 === g ? Cb : 0 > g ? Fb : Gb, c = g != this.pY, d = Math.abs(a.deltaY))), a.direction = e, c && d > b.threshold && e & b.direction }, attrTest: function (a) { return Z.prototype.attrTest.call(this, a) && (this.state & fc || !(this.state & fc) && this.directionTest(a)) }, emit: function (a) { this.pX = a.deltaX, this.pY = a.deltaY; var b = X(a.direction); b && this.manager.emit(this.options.event + b, a), this._super.emit.call(this, a) } }), j(_, Z, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function () { return [bc] }, attrTest: function (a) { return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold || this.state & fc) }, emit: function (a) { if (this._super.emit.call(this, a), 1 !== a.scale) { var b = a.scale < 1 ? "in" : "out"; this.manager.emit(this.options.event + b, a) } } }), j(ab, V, { defaults: { event: "press", pointers: 1, time: 500, threshold: 5 }, getTouchAction: function () { return [_b] }, process: function (a) { var b = this.options, c = a.pointers.length === b.pointers, d = a.distance < b.threshold, f = a.deltaTime > b.time; if (this._input = a, !d || !c || a.eventType & (Ab | Bb) && !f) this.reset(); else if (a.eventType & yb) this.reset(), this._timer = e(function () { this.state = ic, this.tryEmit() }, b.time, this); else if (a.eventType & Ab) return ic; return kc }, reset: function () { clearTimeout(this._timer) }, emit: function (a) { this.state === ic && (a && a.eventType & Ab ? this.manager.emit(this.options.event + "up", a) : (this._input.timeStamp = nb(), this.manager.emit(this.options.event, this._input))) } }), j(bb, Z, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function () { return [bc] }, attrTest: function (a) { return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & fc) } }), j(cb, Z, { defaults: { event: "swipe", threshold: 10, velocity: .65, direction: Hb | Ib, pointers: 1 }, getTouchAction: function () { return $.prototype.getTouchAction.call(this) }, attrTest: function (a) { var b, c = this.options.direction; return c & (Hb | Ib) ? b = a.velocity : c & Hb ? b = a.velocityX : c & Ib && (b = a.velocityY), this._super.attrTest.call(this, a) && c & a.direction && a.distance > this.options.threshold && mb(b) > this.options.velocity && a.eventType & Ab }, emit: function (a) { var b = X(a.direction); b && this.manager.emit(this.options.event + b, a), this.manager.emit(this.options.event, a) } }), j(db, V, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 2, posThreshold: 10 }, getTouchAction: function () { return [ac] }, process: function (a) { var b = this.options, c = a.pointers.length === b.pointers, d = a.distance < b.threshold, f = a.deltaTime < b.time; if (this.reset(), a.eventType & yb && 0 === this.count) return this.failTimeout(); if (d && f && c) { if (a.eventType != Ab) return this.failTimeout(); var g = this.pTime ? a.timeStamp - this.pTime < b.interval : !0, h = !this.pCenter || I(this.pCenter, a.center) < b.posThreshold; this.pTime = a.timeStamp, this.pCenter = a.center, h && g ? this.count += 1 : this.count = 1, this._input = a; var i = this.count % b.taps; if (0 === i) return this.hasRequireFailures() ? (this._timer = e(function () { this.state = ic, this.tryEmit() }, b.interval, this), fc) : ic } return kc }, failTimeout: function () { return this._timer = e(function () { this.state = kc }, this.options.interval, this), kc }, reset: function () { clearTimeout(this._timer) }, emit: function () { this.state == ic && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input)) } }), eb.VERSION = "2.0.4", eb.defaults = { domEvents: !1, touchAction: $b, enable: !0, inputTarget: null, inputClass: null, preset: [[bb, { enable: !1 }], [_, { enable: !1 }, ["rotate"]], [cb, { direction: Hb }], [$, { direction: Hb }, ["swipe"]], [db], [db, { event: "doubletap", taps: 2 }, ["tap"]], [ab]], cssProps: { userSelect: "none", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } }; var lc = 1, mc = 2; fb.prototype = { set: function (a) { return h(this.options, a), a.touchAction && this.touchAction.update(), a.inputTarget && (this.input.destroy(), this.input.target = a.inputTarget, this.input.init()), this }, stop: function (a) { this.session.stopped = a ? mc : lc }, recognize: function (a) { var b = this.session; if (!b.stopped) { this.touchAction.preventDefaults(a); var c, d = this.recognizers, e = b.curRecognizer; (!e || e && e.state & ic) && (e = b.curRecognizer = null); for (var f = 0; f < d.length;) c = d[f], b.stopped === mc || e && c != e && !c.canRecognizeWith(e) ? c.reset() : c.recognize(a), !e && c.state & (fc | gc | hc) && (e = b.curRecognizer = c), f++ } }, get: function (a) { if (a instanceof V) return a; for (var b = this.recognizers, c = 0; c < b.length; c++) if (b[c].options.event == a) return b[c]; return null }, add: function (a) { if (f(a, "add", this)) return this; var b = this.get(a.options.event); return b && this.remove(b), this.recognizers.push(a), a.manager = this, this.touchAction.update(), a }, remove: function (a) { if (f(a, "remove", this)) return this; var b = this.recognizers; return a = this.get(a), b.splice(s(b, a), 1), this.touchAction.update(), this }, on: function (a, b) { var c = this.handlers; return g(r(a), function (a) { c[a] = c[a] || [], c[a].push(b) }), this }, off: function (a, b) { var c = this.handlers; return g(r(a), function (a) { b ? c[a].splice(s(c[a], b), 1) : delete c[a] }), this }, emit: function (a, b) { this.options.domEvents && hb(a, b); var c = this.handlers[a] && this.handlers[a].slice(); if (c && c.length) { b.type = a, b.preventDefault = function () { b.srcEvent.preventDefault() }; for (var d = 0; d < c.length;) c[d](b), d++ } }, destroy: function () { this.element && gb(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null } }, h(eb, { INPUT_START: yb, INPUT_MOVE: zb, INPUT_END: Ab, INPUT_CANCEL: Bb, STATE_POSSIBLE: ec, STATE_BEGAN: fc, STATE_CHANGED: gc, STATE_ENDED: hc, STATE_RECOGNIZED: ic, STATE_CANCELLED: jc, STATE_FAILED: kc, DIRECTION_NONE: Cb, DIRECTION_LEFT: Db, DIRECTION_RIGHT: Eb, DIRECTION_UP: Fb, DIRECTION_DOWN: Gb, DIRECTION_HORIZONTAL: Hb, DIRECTION_VERTICAL: Ib, DIRECTION_ALL: Jb, Manager: fb, Input: y, TouchAction: T, TouchInput: Q, MouseInput: M, PointerEventInput: N, TouchMouseInput: S, SingleTouchInput: O, Recognizer: V, AttrRecognizer: Z, Tap: db, Pan: $, Swipe: cb, Pinch: _, Rotate: bb, Press: ab, on: n, off: o, each: g, merge: i, extend: h, inherit: j, bindFn: k, prefixed: v }), typeof define == kb && define.amd ? define(function () { return eb }) : "undefined" != typeof module && module.exports ? module.exports = eb : a[c] = eb }(window, document, "Hammer");
//## sourceMappingURL=hammer.min.map