var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
///-----------------------------------------------------------------------------------------------------------------
/// structures.ts.  Copyright (c) 2016 Microsoft Corporation.
///    Structure classes for beachPartyChart.
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    (function (MappingSpread) {
        MappingSpread[MappingSpread["normal"] = 0] = "normal";
        MappingSpread[MappingSpread["low"] = 1] = "low";
        MappingSpread[MappingSpread["high"] = 2] = "high";
    })(beachParty.MappingSpread || (beachParty.MappingSpread = {}));
    var MappingSpread = beachParty.MappingSpread;
    (function (BinSorting) {
        BinSorting[BinSorting["none"] = 0] = "none";
        BinSorting[BinSorting["ascending"] = 1] = "ascending";
        BinSorting[BinSorting["descending"] = 2] = "descending";
        BinSorting[BinSorting["nameAscending"] = 3] = "nameAscending";
        BinSorting[BinSorting["nameDescending"] = 4] = "nameDescending";
    })(beachParty.BinSorting || (beachParty.BinSorting = {}));
    var BinSorting = beachParty.BinSorting;
    /** the delimiters that separate tags in a column value. */
    (function (TagDelimiter) {
        TagDelimiter[TagDelimiter["none"] = 0] = "none";
        TagDelimiter[TagDelimiter["semi"] = 1] = "semi";
        TagDelimiter[TagDelimiter["comma"] = 2] = "comma";
        TagDelimiter[TagDelimiter["space"] = 3] = "space";
    })(beachParty.TagDelimiter || (beachParty.TagDelimiter = {}));
    var TagDelimiter = beachParty.TagDelimiter;
    beachParty.TagDelimiters = [null, ";", ",", " "];
    /** parameters for mapping column data to attributes, facets, and axes. */
    var MappingData = (function () {
        function MappingData(attrName, colName, binCount) {
            if (colName === void 0) { colName = ""; }
            if (binCount === void 0) { binCount = 9; }
            this.isLegendBottomUp = false; // entries are added from the bottom to the top
            this.attrName = attrName;
            this.colName = colName;
            this.binCount = binCount;
            //this.maxCategoryBins = 32;
            this.binSorting = BinSorting.none;
            this.forceCategory = false;
            this.spread = MappingSpread.normal;
            this.customScalingCallback = null;
            this.breaks = null;
            this.customScalingCallback = null;
            this.useNiceNumbers = false;
            this.boundColInfo = null;
        }
        return MappingData;
    }());
    beachParty.MappingData = MappingData;
    var SizeMappingData = (function (_super) {
        __extends(SizeMappingData, _super);
        function SizeMappingData(binCount) {
            if (binCount === void 0) { binCount = 4; }
            _super.call(this, "size", "", binCount);
            this.sizePalette = [.25, .5, .75, 1];
            this.isContinuous = false;
        }
        return SizeMappingData;
    }(MappingData));
    beachParty.SizeMappingData = SizeMappingData;
    var LineMappingData = (function (_super) {
        __extends(LineMappingData, _super);
        function LineMappingData(binCount) {
            if (binCount === void 0) { binCount = 9; }
            _super.call(this, "line", "", binCount);
            this.color = "white";
            this.opacity = 1;
            this.size = 1;
            this.lineStyle = "solid";
            this.maxShapes = 9999;
        }
        return LineMappingData;
    }(MappingData));
    beachParty.LineMappingData = LineMappingData;
    var TextMappingData = (function (_super) {
        __extends(TextMappingData, _super);
        function TextMappingData(binCount) {
            if (binCount === void 0) { binCount = 9; }
            _super.call(this, "text", "", binCount);
            this.fontDesc = "12px Tahoma";
            this.color = "white";
            this.opacity = .5;
            this.maxTextLength = 100;
            this.maxShapes = 100;
        }
        return TextMappingData;
    }(MappingData));
    beachParty.TextMappingData = TextMappingData;
    var ShapeMappingData = (function (_super) {
        __extends(ShapeMappingData, _super);
        function ShapeMappingData(binCount) {
            if (binCount === void 0) { binCount = 6; }
            _super.call(this, "shape", "", binCount);
            this.shapePalette = ["filled circle", "filled square", "filled triangle", "circle", "square", "triangle"];
            var usePhotos = false;
            var palette = [];
            if (usePhotos) {
                //---- local photo-based images (test) ----
                for (var i = 1; i < 18; i++) {
                    palette.push("http://localhost/beachPartyApp/photos/p" + i + ".jpg");
                }
            }
            else {
                palette.push("http://localhost/beachPartyApp/photos/LogoOne.jpg");
                palette.push("http://localhost/beachPartyApp/photos/LogoTwo.jpg");
                palette.push("http://localhost/beachPartyApp/photos/LogoThree.jpg");
                palette.push("http://localhost/beachPartyApp/photos/LogoFour.jpg");
                palette.push("http://localhost/beachPartyApp/photos/LogoFive.jpg");
            }
            this.experimentalPalette = palette;
        }
        ShapeMappingData.prototype.getImagePalette = function (useExperimental) {
            var imgPalette = (useExperimental) ? this.experimentalPalette : this.shapePalette;
            return imgPalette;
        };
        return ShapeMappingData;
    }(MappingData));
    beachParty.ShapeMappingData = ShapeMappingData;
    var ImageMappingData = (function (_super) {
        __extends(ImageMappingData, _super);
        function ImageMappingData(binCount) {
            if (binCount === void 0) { binCount = 6; }
            _super.call(this, "image", "", binCount);
        }
        return ImageMappingData;
    }(MappingData));
    beachParty.ImageMappingData = ImageMappingData;
    var ChannelMappingData = (function () {
        function ChannelMappingData() {
        }
        return ChannelMappingData;
    }());
    beachParty.ChannelMappingData = ChannelMappingData;
    var ColorMappingData = (function (_super) {
        __extends(ColorMappingData, _super);
        function ColorMappingData(psName, paletteName, isContinuous, colorSteps, isReversed, isInverted, isCycling) {
            if (psName === void 0) { psName = "Diverging"; }
            if (paletteName === void 0) { paletteName = "RdBu"; }
            if (isContinuous === void 0) { isContinuous = false; }
            if (colorSteps === void 0) { colorSteps = 9; }
            _super.call(this, "color");
            this.paletteSetName = psName;
            this.paletteName = paletteName;
            this.isContinuous = isContinuous;
            //this.colorSteps = colorSteps;           // this will be used to set the inital value of the color steps slider in color panel
            this.binCount = colorSteps; // this will eventually be set to the length of the palette built for this attribute
            this.isReversed = isReversed;
            this.isInverted = isInverted;
            this.isCycling = isCycling;
            this.binCount = colorSteps;
            this.colorPalette = null;
        }
        return ColorMappingData;
    }(MappingData));
    beachParty.ColorMappingData = ColorMappingData;
    var SearchParams = (function () {
        function SearchParams() {
        }
        return SearchParams;
    }());
    beachParty.SearchParams = SearchParams;
    var FacetLayoutInfo = (function () {
        function FacetLayoutInfo() {
        }
        return FacetLayoutInfo;
    }());
    beachParty.FacetLayoutInfo = FacetLayoutInfo;
    var FacetMappingData = (function (_super) {
        __extends(FacetMappingData, _super);
        function FacetMappingData(binCount) {
            if (binCount === void 0) { binCount = 9; }
            _super.call(this, "facet", "", binCount);
            this.facetBounds = null; // if null, system will layout bounds
        }
        return FacetMappingData;
    }(MappingData));
    beachParty.FacetMappingData = FacetMappingData;
    var AxisData = (function () {
        function AxisData() {
            this.isAxisVisible = true;
            this.drawTicks = true;
            this.drawLabels = true;
            this.drawGridLines = false;
        }
        return AxisData;
    }());
    beachParty.AxisData = AxisData;
    var ChartFrameData = (function () {
        function ChartFrameData(isVisible) {
            if (isVisible === void 0) { isVisible = true; }
            this.isVisible = isVisible;
            this.opacity = 1;
            this.labelColor = "white";
            this.tickColor = "white";
            this.padding = null;
            this.xAxis = new AxisData();
            this.yAxis = new AxisData();
            this.zAxis = new AxisData();
        }
        return ChartFrameData;
    }());
    beachParty.ChartFrameData = ChartFrameData;
    (function (TextSearchType) {
        TextSearchType[TextSearchType["exactMatch"] = 0] = "exactMatch";
        TextSearchType[TextSearchType["startsWith"] = 1] = "startsWith";
        TextSearchType[TextSearchType["contains"] = 2] = "contains";
        TextSearchType[TextSearchType["lessThan"] = 3] = "lessThan";
        TextSearchType[TextSearchType["lessThanEqual"] = 4] = "lessThanEqual";
        TextSearchType[TextSearchType["greaterThan"] = 5] = "greaterThan";
        TextSearchType[TextSearchType["greaterThanEqual"] = 6] = "greaterThanEqual";
        TextSearchType[TextSearchType["betweenInclusive"] = 7] = "betweenInclusive";
        TextSearchType[TextSearchType["gtrValueAndLeqValue2"] = 8] = "gtrValueAndLeqValue2";
        TextSearchType[TextSearchType["geqValueAndLessValue2"] = 9] = "geqValueAndLessValue2";
        TextSearchType[TextSearchType["notEqual"] = 10] = "notEqual";
    })(beachParty.TextSearchType || (beachParty.TextSearchType = {}));
    var TextSearchType = beachParty.TextSearchType;
    (function (SearchAction) {
        SearchAction[SearchAction["selectMatches"] = 0] = "selectMatches";
        SearchAction[SearchAction["isolateMatches"] = 1] = "isolateMatches";
        SearchAction[SearchAction["excludeMatches"] = 2] = "excludeMatches";
        SearchAction[SearchAction["returnMatches"] = 3] = "returnMatches";
    })(beachParty.SearchAction || (beachParty.SearchAction = {}));
    var SearchAction = beachParty.SearchAction;
    /// LEGACY - remove ASAP.
    var ColMappings = (function () {
        function ColMappings(x, y, color) {
            this.x = new MappingData(x);
            this.y = new MappingData(y);
            this.color = new ColorMappingData("Sequential", color, false, 5, false);
        }
        return ColMappings;
    }());
    beachParty.ColMappings = ColMappings;
    var PreloadField = (function () {
        function PreloadField(name, desc, calcFieldExp, fieldType, sortedValues, formatting) {
            this.name = name;
            this.description = desc;
            this.calcFieldExp = calcFieldExp;
            this.fieldType = fieldType;
            this.sortedValues = sortedValues;
            this.formatting = formatting;
            this.valueMap = null;
        }
        return PreloadField;
    }());
    beachParty.PreloadField = PreloadField;
    (function (FileType) {
        FileType[FileType["delimited"] = 0] = "delimited";
        FileType[FileType["json"] = 1] = "json";
        FileType[FileType["sql"] = 2] = "sql";
    })(beachParty.FileType || (beachParty.FileType = {}));
    var FileType = beachParty.FileType;
    /** parameters that specify the working data: which data to load and how it should be transformed. */
    var WorkingDataParams = (function () {
        function WorkingDataParams(dataName, path, fileSource) {
            this.dataName = dataName;
            this.filePath = path;
            this.fileSource = fileSource;
            this.primaryKeyCol = null;
            this.hasHeader = true;
            this.fileType = FileType.delimited;
            this.fieldList = [];
        }
        WorkingDataParams.prototype.addField = function (name, desc, calcFieldExp, fieldType, sortedValues) {
            var pf = new PreloadField(name, desc, calcFieldExp, fieldType, sortedValues);
            this.fieldList.push(pf);
        };
        WorkingDataParams.prototype.getField = function (name) {
            var fix = null;
            for (var i = 0; i < this.fieldList.length; i++) {
                var fi = this.fieldList[i];
                if (fi.name == name) {
                    fix = fi;
                    break;
                }
            }
            return fix;
        };
        return WorkingDataParams;
    }());
    beachParty.WorkingDataParams = WorkingDataParams;
    /** Preloaded settings for data files. Users should also be able to create these by saving their current view.
    This also is how we represent the full state of an insight, to be persisted between sessions. */
    var Preload = (function (_super) {
        __extends(Preload, _super);
        function Preload(name, path, description, x, y, color, chart, subLayout) {
            _super.call(this, name, path);
            //this.name = name;
            this.description = description;
            this.tooltipFieldList = null;
            this.showInFileOpen = true;
            //this.addedBy = "rfernand";
            this.hasTimeData = false;
            this.dateAdded = new Date();
            this.colMappings = new ColMappings(x, y, color);
            this.chartName = chart;
            this.subLayout = subLayout;
        }
        return Preload;
    }(WorkingDataParams));
    beachParty.Preload = Preload;
    /** This is the subset of InsightData that is managed by the chart engine. */
    var SystemViewData = (function () {
        function SystemViewData() {
        }
        return SystemViewData;
    }());
    beachParty.SystemViewData = SystemViewData;
    (function (LoadAction) {
        LoadAction[LoadAction["all"] = 0] = "all";
        LoadAction[LoadAction["selection"] = 1] = "selection";
        LoadAction[LoadAction["filter"] = 2] = "filter";
        LoadAction[LoadAction["view"] = 3] = "view";
        LoadAction[LoadAction["data"] = 4] = "data";
    })(beachParty.LoadAction || (beachParty.LoadAction = {}));
    var LoadAction = beachParty.LoadAction;
    (function (NotesSource) {
        NotesSource[NotesSource["none"] = 0] = "none";
        NotesSource[NotesSource["name"] = 1] = "name";
        NotesSource[NotesSource["notes"] = 2] = "notes";
        NotesSource[NotesSource["both"] = 3] = "both";
    })(beachParty.NotesSource || (beachParty.NotesSource = {}));
    var NotesSource = beachParty.NotesSource;
    var InsightData = (function () {
        function InsightData(insightName, notes) {
            if (insightName === void 0) { insightName = ""; }
            if (notes === void 0) { notes = ""; }
            this.preload = new Preload("", null, "");
            this.name = insightName;
            this.notes = notes;
            this.loadAction = LoadAction.all;
            this.notesSource = NotesSource.none;
        }
        return InsightData;
    }());
    beachParty.InsightData = InsightData;
    (function (MarkerType) {
        MarkerType[MarkerType["circleFill"] = 0] = "circleFill";
        MarkerType[MarkerType["rectFill"] = 1] = "rectFill";
        MarkerType[MarkerType["triangleFill"] = 2] = "triangleFill";
        MarkerType[MarkerType["separator"] = 3] = "separator";
        MarkerType[MarkerType["circleOutline"] = 4] = "circleOutline";
        MarkerType[MarkerType["rectOutline"] = 5] = "rectOutline";
        MarkerType[MarkerType["triangleOutline"] = 6] = "triangleOutline";
    })(beachParty.MarkerType || (beachParty.MarkerType = {}));
    var MarkerType = beachParty.MarkerType;
    /**
     * For callers, if you don't know the information for a field, leave it as "undefined" and the dataFrame class
     * will try to calculate it.
     */
    var ColStats = (function () {
        function ColStats(min, max, nanCount, keyCount, sortedKeys) {
            this.min = min;
            this.max = max;
            this.nanCount = nanCount;
            this.keyCount = keyCount;
            this.sortedKeys = sortedKeys;
        }
        return ColStats;
    }());
    beachParty.ColStats = ColStats;
    /**
     * This is information about the specified column, relative to its SandDance-filtered-in values.
      * For callers, if you don't know the information for a field, leave it as "undefined" and the dataFrame class
      * will try to calculate it.
     */
    var ColInfo = (function () {
        function ColInfo(name, desc, colType, calcFieldExp, stats, infoIsComplete) {
            this.name = name;
            this.desc = desc;
            this.colType = colType;
            this.calcFieldExp = calcFieldExp;
            this.stats = stats;
            //---- default is to let system try to fill in missing informaton ----
            this.infoIsComplete = infoIsComplete;
        }
        return ColInfo;
    }());
    beachParty.ColInfo = ColInfo;
    /**
     * This structure extends ColInfo by adding a data vector.
     */
    var DataColumn = (function (_super) {
        __extends(DataColumn, _super);
        function DataColumn(name, desc, colType, calcFieldExp, stats, dataVector) {
            _super.call(this, name, desc, colType, calcFieldExp, stats);
            this.ctr = "DataColumn"; // class marker
        }
        return DataColumn;
    }(ColInfo));
    beachParty.DataColumn = DataColumn;
    /**
     * This specifies a substitution to be made for a specific value of a column.
     */
    var ValueMapEntry = (function () {
        function ValueMapEntry() {
        }
        return ValueMapEntry;
    }());
    beachParty.ValueMapEntry = ValueMapEntry;
    /** Information to rebuild chart as SVG, etc. */
    var ChartRepro = (function () {
        function ChartRepro() {
        }
        return ChartRepro;
    }());
    beachParty.ChartRepro = ChartRepro;
    (function (ChartType) {
        //AggColumn,
        ChartType[ChartType["Bar"] = 0] = "Bar";
        ChartType[ChartType["Column"] = 1] = "Column";
        ChartType[ChartType["Custom"] = 2] = "Custom";
        ChartType[ChartType["Density"] = 3] = "Density";
        ChartType[ChartType["Grid"] = 4] = "Grid";
        ChartType[ChartType["Line"] = 5] = "Line";
        ChartType[ChartType["Links"] = 6] = "Links";
        ChartType[ChartType["Poisson"] = 7] = "Poisson";
        ChartType[ChartType["Radial"] = 8] = "Radial";
        ChartType[ChartType["Random"] = 9] = "Random";
        ChartType[ChartType["Scatter"] = 10] = "Scatter";
        ChartType[ChartType["Scatter3D"] = 11] = "Scatter3D";
        //Squarify,
        ChartType[ChartType["Spiral"] = 12] = "Spiral";
        ChartType[ChartType["Stacks"] = 13] = "Stacks";
        ChartType[ChartType["Violin"] = 14] = "Violin";
        ChartType[ChartType["Xband"] = 15] = "Xband";
        ChartType[ChartType["Yband"] = 16] = "Yband";
    })(beachParty.ChartType || (beachParty.ChartType = {}));
    var ChartType = beachParty.ChartType;
    (function (LayoutType) {
        LayoutType[LayoutType["Default"] = 0] = "Default";
        LayoutType[LayoutType["Grid"] = 1] = "Grid";
        LayoutType[LayoutType["Percent"] = 2] = "Percent";
        LayoutType[LayoutType["Squarify"] = 3] = "Squarify";
        LayoutType[LayoutType["Strips"] = 4] = "Strips";
        //---- for stacks ----
        LayoutType[LayoutType["Cubes"] = 5] = "Cubes";
        LayoutType[LayoutType["ScaleToFit"] = 6] = "ScaleToFit";
        //---- not currently used ----
        LayoutType[LayoutType["Circle"] = 7] = "Circle";
        LayoutType[LayoutType["Poisson"] = 8] = "Poisson";
        LayoutType[LayoutType["Random"] = 9] = "Random";
    })(beachParty.LayoutType || (beachParty.LayoutType = {}));
    var LayoutType = beachParty.LayoutType;
    function getUiName(ct) {
        var uiName = null;
        if (ct == ChartType.Scatter3D) {
            uiName = "Scatter-3D";
        }
        else {
            uiName = ChartType[ct];
        }
        return uiName;
    }
    beachParty.getUiName = getUiName;
    (function (VectorType) {
        VectorType[VectorType["sortOrder"] = 0] = "sortOrder";
        VectorType[VectorType["naturalOrder"] = 1] = "naturalOrder";
        VectorType[VectorType["primaryKeyList"] = 2] = "primaryKeyList";
    })(beachParty.VectorType || (beachParty.VectorType = {}));
    var VectorType = beachParty.VectorType;
    var DataTipData = (function () {
        function DataTipData() {
        }
        return DataTipData;
    }());
    beachParty.DataTipData = DataTipData;
    (function (SelectMode) {
        SelectMode[SelectMode["normal"] = 0] = "normal";
        SelectMode[SelectMode["smartToggle"] = 1] = "smartToggle";
        SelectMode[SelectMode["toggleClear"] = 2] = "toggleClear";
        SelectMode[SelectMode["additive"] = 3] = "additive";
        SelectMode[SelectMode["subtractive"] = 4] = "subtractive";
        SelectMode[SelectMode["intersection"] = 5] = "intersection";
        SelectMode[SelectMode["nonIntersection"] = 6] = "nonIntersection";
    })(beachParty.SelectMode || (beachParty.SelectMode = {}));
    var SelectMode = beachParty.SelectMode;
    (function (SnapshotType) {
        SnapshotType[SnapshotType["none"] = 0] = "none";
        SnapshotType[SnapshotType["plot"] = 1] = "plot";
        SnapshotType[SnapshotType["chart"] = 2] = "chart";
    })(beachParty.SnapshotType || (beachParty.SnapshotType = {}));
    var SnapshotType = beachParty.SnapshotType;
    var ClusteringParams = (function () {
        function ClusteringParams() {
            this.numClusters = 3;
        }
        return ClusteringParams;
    }());
    beachParty.ClusteringParams = ClusteringParams;
    (function (ClusterResultMapping) {
        ClusterResultMapping[ClusterResultMapping["none"] = 0] = "none";
        ClusterResultMapping[ClusterResultMapping["color"] = 1] = "color";
        ClusterResultMapping[ClusterResultMapping["size"] = 2] = "size";
        ClusterResultMapping[ClusterResultMapping["shape"] = 3] = "shape";
    })(beachParty.ClusterResultMapping || (beachParty.ClusterResultMapping = {}));
    var ClusterResultMapping = beachParty.ClusterResultMapping;
    (function (PredefinedCustomChart) {
        //---- flat ----
        PredefinedCustomChart[PredefinedCustomChart["grid"] = 0] = "grid";
        PredefinedCustomChart[PredefinedCustomChart["random"] = 1] = "random";
        PredefinedCustomChart[PredefinedCustomChart["poisson"] = 2] = "poisson";
        PredefinedCustomChart[PredefinedCustomChart["spiral"] = 3] = "spiral";
        PredefinedCustomChart[PredefinedCustomChart["squarify"] = 4] = "squarify";
        //---- mapping ----
        PredefinedCustomChart[PredefinedCustomChart["line"] = 5] = "line";
        PredefinedCustomChart[PredefinedCustomChart["radial"] = 6] = "radial";
        PredefinedCustomChart[PredefinedCustomChart["scatter"] = 7] = "scatter";
        PredefinedCustomChart[PredefinedCustomChart["xband"] = 8] = "xband";
        PredefinedCustomChart[PredefinedCustomChart["yband"] = 9] = "yband";
        PredefinedCustomChart[PredefinedCustomChart["scatter3D"] = 10] = "scatter3D";
        //---- bins ----
        PredefinedCustomChart[PredefinedCustomChart["bar"] = 11] = "bar";
        PredefinedCustomChart[PredefinedCustomChart["column"] = 12] = "column";
        PredefinedCustomChart[PredefinedCustomChart["density"] = 13] = "density";
        PredefinedCustomChart[PredefinedCustomChart["violin"] = 14] = "violin";
        PredefinedCustomChart[PredefinedCustomChart["stacks"] = 15] = "stacks";
        PredefinedCustomChart[PredefinedCustomChart["custom"] = 16] = "custom";
    })(beachParty.PredefinedCustomChart || (beachParty.PredefinedCustomChart = {}));
    var PredefinedCustomChart = beachParty.PredefinedCustomChart;
    (function (CustomColUsage) {
        CustomColUsage[CustomColUsage["none"] = 0] = "none";
        CustomColUsage[CustomColUsage["map"] = 1] = "map";
        CustomColUsage[CustomColUsage["bin"] = 2] = "bin";
    })(beachParty.CustomColUsage || (beachParty.CustomColUsage = {}));
    var CustomColUsage = beachParty.CustomColUsage;
    (function (CustomLayout) {
        CustomLayout[CustomLayout["grid"] = 0] = "grid";
        CustomLayout[CustomLayout["map"] = 1] = "map";
        CustomLayout[CustomLayout["radial"] = 2] = "radial";
        CustomLayout[CustomLayout["random"] = 3] = "random";
        CustomLayout[CustomLayout["poisson"] = 4] = "poisson";
        CustomLayout[CustomLayout["squarify"] = 5] = "squarify";
        CustomLayout[CustomLayout["spiral"] = 6] = "spiral";
        CustomLayout[CustomLayout["stackX"] = 7] = "stackX";
        CustomLayout[CustomLayout["stackY"] = 8] = "stackY";
        CustomLayout[CustomLayout["stackZ"] = 9] = "stackZ";
    })(beachParty.CustomLayout || (beachParty.CustomLayout = {}));
    var CustomLayout = beachParty.CustomLayout;
    (function (LayoutDirection) {
        LayoutDirection[LayoutDirection["fromBottom"] = 0] = "fromBottom";
        LayoutDirection[LayoutDirection["fromLeft"] = 1] = "fromLeft";
        LayoutDirection[LayoutDirection["fromCenter"] = 2] = "fromCenter";
    })(beachParty.LayoutDirection || (beachParty.LayoutDirection = {}));
    var LayoutDirection = beachParty.LayoutDirection;
    (function (TextAlign) {
        TextAlign[TextAlign["left"] = 0] = "left";
        TextAlign[TextAlign["center"] = 1] = "center";
        TextAlign[TextAlign["right"] = 2] = "right";
    })(beachParty.TextAlign || (beachParty.TextAlign = {}));
    var TextAlign = beachParty.TextAlign;
    var CustomParams = (function () {
        function CustomParams() {
            this.xUsage = CustomColUsage.none;
            this.yUsage = CustomColUsage.none;
            this.zUsage = CustomColUsage.none;
            this.layout = CustomLayout.random;
        }
        return CustomParams;
    }());
    beachParty.CustomParams = CustomParams;
    var DataCacheParams = (function () {
        function DataCacheParams() {
            this.cacheLocalFiles = true;
            this.cacheWebFiles = true;
        }
        return DataCacheParams;
    }());
    beachParty.DataCacheParams = DataCacheParams;
    /** on client side. */
    (function (DragAction) {
        DragAction[DragAction["select"] = 0] = "select";
        DragAction[DragAction["zoomIn"] = 1] = "zoomIn";
        DragAction[DragAction["rotate"] = 2] = "rotate";
        DragAction[DragAction["move"] = 3] = "move";
        DragAction[DragAction["wheel"] = 4] = "wheel";
    })(beachParty.DragAction || (beachParty.DragAction = {}));
    var DragAction = beachParty.DragAction;
    (function (ClientTransformMode) {
        ClientTransformMode[ClientTransformMode["none"] = 0] = "none";
        ClientTransformMode[ClientTransformMode["auto"] = 1] = "auto";
        ClientTransformMode[ClientTransformMode["rotate"] = 2] = "rotate";
        ClientTransformMode[ClientTransformMode["pan"] = 3] = "pan";
        ClientTransformMode[ClientTransformMode["wheel"] = 4] = "wheel";
    })(beachParty.ClientTransformMode || (beachParty.ClientTransformMode = {}));
    var ClientTransformMode = beachParty.ClientTransformMode;
    /** effect of dragging mouse/touch on plot, on engine side of things. */
    (function (TransformMode) {
        TransformMode[TransformMode["none"] = 0] = "none";
        TransformMode[TransformMode["move"] = 1] = "move";
        TransformMode[TransformMode["spin"] = 2] = "spin";
        TransformMode[TransformMode["turn"] = 3] = "turn";
        TransformMode[TransformMode["flip"] = 4] = "flip";
        TransformMode[TransformMode["zoom"] = 5] = "zoom";
    })(beachParty.TransformMode || (beachParty.TransformMode = {}));
    var TransformMode = beachParty.TransformMode;
    (function (PanelLocation) {
        PanelLocation[PanelLocation["top"] = 0] = "top";
        PanelLocation[PanelLocation["right"] = 1] = "right";
        PanelLocation[PanelLocation["bottom"] = 2] = "bottom";
        PanelLocation[PanelLocation["left"] = 3] = "left";
    })(beachParty.PanelLocation || (beachParty.PanelLocation = {}));
    var PanelLocation = beachParty.PanelLocation;
    (function (ThemeName) {
        ThemeName[ThemeName["white"] = 0] = "white";
        ThemeName[ThemeName["black"] = 1] = "black";
    })(beachParty.ThemeName || (beachParty.ThemeName = {}));
    var ThemeName = beachParty.ThemeName;
    (function (SampleType) {
        SampleType[SampleType["first"] = 0] = "first";
        SampleType[SampleType["last"] = 1] = "last";
        SampleType[SampleType["random"] = 2] = "random";
    })(beachParty.SampleType || (beachParty.SampleType = {}));
    var SampleType = beachParty.SampleType;
    var DataSampling = (function () {
        function DataSampling(isEnabled, sampleType, sampleCount, sampleThreshold) {
            if (isEnabled === void 0) { isEnabled = true; }
            if (sampleType === void 0) { sampleType = SampleType.first; }
            if (sampleCount === void 0) { sampleCount = 1000; }
            if (sampleThreshold === void 0) { sampleThreshold = 100 * 1000; }
            this.isEnabled = isEnabled;
            this.sampleType = sampleType;
            this.sampleCount = sampleCount;
            this.samplingThreshold = sampleThreshold;
        }
        return DataSampling;
    }());
    beachParty.DataSampling = DataSampling;
    (function (AggType) {
        AggType[AggType["count"] = 0] = "count";
        AggType[AggType["sum"] = 1] = "sum";
        AggType[AggType["median"] = 2] = "median";
        AggType[AggType["average"] = 3] = "average";
        AggType[AggType["min"] = 4] = "min";
        AggType[AggType["max"] = 5] = "max";
        AggType[AggType["stdDev"] = 6] = "stdDev";
        AggType[AggType["variance"] = 7] = "variance";
    })(beachParty.AggType || (beachParty.AggType = {}));
    var AggType = beachParty.AggType;
    (function (DataChangeType) {
        DataChangeType[DataChangeType["datasetChange"] = 0] = "datasetChange";
        DataChangeType[DataChangeType["queryResults"] = 1] = "queryResults";
        DataChangeType[DataChangeType["sampleResults"] = 2] = "sampleResults";
    })(beachParty.DataChangeType || (beachParty.DataChangeType = {}));
    var DataChangeType = beachParty.DataChangeType;
    var AggRange = (function () {
        function AggRange() {
        }
        return AggRange;
    }());
    beachParty.AggRange = AggRange;
    var AggFilter = (function () {
        function AggFilter(colName, isMember, values) {
            this.colName = colName;
            this.isMember = isMember;
            this.values = values;
        }
        return AggFilter;
    }());
    beachParty.AggFilter = AggFilter;
    var DataAggregation = (function () {
        function DataAggregation(aggType, targetCol, groupCols) {
            this.aggType = aggType;
            this.targetCol = targetCol;
            this.groupCols = groupCols;
            this.aggFilters = [];
        }
        return DataAggregation;
    }());
    beachParty.DataAggregation = DataAggregation;
    var AggResult = (function () {
        function AggResult() {
        }
        return AggResult;
    }());
    beachParty.AggResult = AggResult;
    //---- this is specified per column (in pre-query) ----
    (function (nanAction) {
        /** leave NAN values in place */
        nanAction[nanAction["none"] = 0] = "none";
        /** omit records where NAN values are found for this column */
        nanAction[nanAction["omitRecord"] = 1] = "omitRecord";
        /** replace NAN with value linearly interpolated between last/next records with true value */
        nanAction[nanAction["interpolate"] = 2] = "interpolate";
        /** replace NAN with 0 */
        nanAction[nanAction["setToZero"] = 3] = "setToZero";
        /** replace NAN with the user-specified "NAN replacement" value */
        nanAction[nanAction["setToFixedValue"] = 4] = "setToFixedValue";
        /** replace NAN with the MINIMUM value of this column */
        nanAction[nanAction["setToMin"] = 5] = "setToMin";
        /** replace NAN with the MAXIMUM value of this column */
        nanAction[nanAction["setToMax"] = 6] = "setToMax";
        /** replace NAN with the MEAN (average) value of this column */
        nanAction[nanAction["setToMean"] = 7] = "setToMean";
        /** replace NAN with the MEDIAN (middle) value of this column */
        nanAction[nanAction["setToMediam"] = 8] = "setToMediam";
        /** replace NAN with the MODE (most occuring) value of this column */
        nanAction[nanAction["setToMode"] = 9] = "setToMode";
    })(beachParty.nanAction || (beachParty.nanAction = {}));
    var nanAction = beachParty.nanAction;
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    baseLayout.ts - base class for layouts.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** information needed to draw a facet/chart. */
    var baseLayoutClass = (function () {
        function baseLayoutClass(chart, layoutName, chartOptions) {
            if (chartOptions === void 0) { chartOptions = {}; }
            this._is3dChart = false;
            this._visibleColPickers = "";
            this._visibleBinAdjusters = "";
            this._chart = chart;
            this._layoutName = layoutName;
            this._animationData = chart.animationData();
            this._chartBuilder = chart.getChartBuilder();
            this._chartOptions = chartOptions;
            //---- default to showing axes ----
            this._chartBuilder.hideAxes(false);
            this._chartBuilder.isXAxisClickable(true);
            this._chartBuilder.isYAxisClickable(true);
            //---- reset to default transform ----
            var transformMgr = this._chartBuilder.getTransformMgr();
            transformMgr.resetTransform();
        }
        baseLayoutClass.prototype.getIs3dChart = function () {
            return this._is3dChart;
        };
        baseLayoutClass.prototype.getVisibleColPickers = function () {
            return this._visibleColPickers;
        };
        baseLayoutClass.prototype.getVisibleBinAdjusters = function () {
            return this._visibleBinAdjusters;
        };
        baseLayoutClass.prototype.buildScales = function (nv, rcxWorld, filteredRecordCount, facetCount) {
            return this._chartBuilder.buildDefaultScales(nv, rcxWorld, filteredRecordCount, facetCount);
        };
        baseLayoutClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var maxItems = beachParty.cbUtils.getDataLength(dc.nvData, true);
            return maxItems;
        };
        baseLayoutClass.prototype.preLayoutLoop = function (dc) {
        };
        /** to be overwritten by subclass, where appropriated. */
        baseLayoutClass.prototype.adjustScales = function (dc) {
        };
        baseLayoutClass.prototype.layoutDataForRecord = function (i, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            dr.x = beachParty.chartUtils.scaleColData(nv.x, i, scales.x);
            dr.y = beachParty.chartUtils.scaleColData(nv.y, i, scales.y);
            dr.z = beachParty.chartUtils.scaleColData(nv.z, i, scales.z);
            dr.width = beachParty.chartUtils.scaleColData(nv.size, i, scales.size, 1);
            dr.height = dr.width;
            dr.depth = dr.width;
            dr.colorIndex = beachParty.chartUtils.scaleColData(nv.colorIndex, i, scales.colorIndex);
            //colorIndex = Math.floor(colorIndex);
            dr.imageIndex = beachParty.chartUtils.scaleColData(nv.imageIndex, i, scales.imageIndex);
        };
        baseLayoutClass.prototype.scaleColData = function (vector, index, scale, defaultValue) {
            if (defaultValue === void 0) { defaultValue = 0; }
            return beachParty.chartUtils.scaleColData(vector, index, scale, defaultValue);
        };
        return baseLayoutClass;
    }());
    beachParty.baseLayoutClass = baseLayoutClass;
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chart.ts - defines a SandDance chart (axes, plot, and other layers) and the user
//               interaction (tooltips, datatips, drag selection, drag transformations)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var chartClass = (function (_super) {
        __extends(chartClass, _super);
        /// allow for app==null, for custom builds of SandDance.
        function chartClass(app, dataMgr, divElem, isVisible) {
            var _this = this;
            if (isVisible === void 0) { isVisible = true; }
            _super.call(this);
            this._selectMode = beachParty.SelectMode.smartToggle;
            this._cmdId = "";
            //---- DATA properties ----
            this._origColInfos = []; // full set of original columns from table
            this._colInfos = []; // set of FILTERED or SCRUBBED columns (as per preLoad)
            this._recordCount = 0;
            this._filename = "";
            this._selectedCount = 0;
            this._filteredInCount = 0;
            this._selection = [];
            //private _selectedRecords: any[] = [];
            this._isSelectionLocked = false;
            //---- sorting ----
            this._sortItemCol = null;
            this._isItemSortAscending = true;
            this._lastScatterXCol = null;
            this._lastScatterYCol = null;
            this._isChartCustom = false;
            this._customParams = new beachParty.CustomParams();
            this._customSpec = "mx";
            //---- this controls spacing between shapes in layout-type views (work in progress) ----
            this._sizeFactor = .98; // change also in: ViewSettings
            this._separationFactor = .5;
            this._isOrthoCamera = false;
            this._useFacets = false;
            this._lastHoverPos = null;
            this._isVisible = false;
            this._layoutsByChart = {};
            this._toPercentOverride = undefined;
            this._isAnimOverride = false;
            this._isTransformMode = false;
            this._isDataZoomMode = false;
            this._wheelDownTime = 0;
            this._dtMouseDown = 0;
            this._spiralParams = new beachParty.SpiralParams();
            this._prevChartType = null;
            this._autoRebuild = true;
            this._rcPlot = vp.geom.createRect(0, 0, 100, 100);
            this._chartSettings = {};
            this._isEngineDrawing = false;
            this._textOpacity = .5;
            this._maxToolTipColumns = 18; // at 20, we seem to run into a browser limit on total tooltip size
            this._topOfChartUx = 0; // used for EXTENDING the top of chartUX to allow dragging from empty area
            this._deltaOfChartUx = 0; // how much it was extended
            this._showItemCounts = false;
            this._showTitleText = false;
            this._titleText = "";
            this._dragAction = beachParty.DragAction.select;
            this._shapeOpacity = chartClass.defaultOpacity;
            this._canvasColor = "none";
            this._chartColor = "none";
            this._drawingPrimitive = beachParty.DrawPrimitive.cube;
            this._isContinuousDrawing = false;
            this._isTooltipsEnabled = false;
            this._is3dGridAlwaysOn = false;
            this._isWheelInertia = true;
            this._showWheelDuringTransformMode = false;
            this._isLightingAlwaysOn = false;
            this._lightingParams = new beachParty.Lighting();
            this._useNiceNumbers = false;
            this._maxItemCount = 100 * 1000;
            this._isMaxItemCountEnabled = false;
            this._defaultShapeSize = undefined; // when defined, this overrides system's calc for best shape size
            //---- events ----
            this.onActionDectected = new beachParty.bpEvent();
            this.onAttrColNameChange = new beachParty.bpEvent();
            this.onSearchStarted = new beachParty.bpEvent();
            this.onCycleStart = new beachParty.bpEvent();
            this.onCycleEnd = new beachParty.bpEvent();
            this._app = app;
            this._dataMgr = dataMgr;
            this._isVisible = isVisible;
            this._chartSpecs = new beachParty.ChartSpecs(beachParty.ChartType.Random);
            var appSettingsMgr = this._app.getAppSettingsMgr();
            //---- first chart to be created should add the beachParty.css text as a style sheet ----
            if (!chartClass.addedBeachPartyCss) {
                this.addBeachPartyCss();
                chartClass.addedBeachPartyCss = true;
            }
            this._scatterParams = new beachParty.ScatterParams();
            this._flatParams = new beachParty.FlatParams();
            //---- this needs more work (when app in ready) ----
            //dataMgr.onDataChange.attach(this, (e) =>
            //{
            //    this.processDataChange(e.changeFlags);
            //    this.markBuildNeeded("dataChanged");
            //});
            dataMgr.registerForChange("dataFrame", function (e) {
                //this.processDataChange(e.changeFlags);
                //this.markBuildNeeded("dataChanged");
                _this.onDataLoaded();
            });
            dataMgr.registerForChange("selection", function (e) {
                _this.onSelectionChanged();
            });
            dataMgr.registerForChange("filtered", function (e) {
                _this.onFilteredChanged();
            });
            this._lastScatterXCol = null;
            this._lastScatterYCol = null;
            if (appSettingsMgr) {
                //---- use PERSISTED values for properties ----
                this._animationData = appSettingsMgr.animationData();
                this._chartFrameData = appSettingsMgr.getChartFrameData();
                this._hoverParams = appSettingsMgr.getHoverParams();
                this._selectionParams = appSettingsMgr.getSelectionParams();
                this._shapeOpacity = appSettingsMgr.shapeOpacity();
                this._instancingParams = appSettingsMgr.getInstancingParams();
            }
            else {
                //---- use DEFAULT values for properties ----
                this._animationData = new beachParty.AnimationData();
                this._chartFrameData = new beachParty.ChartFrameData();
                this._hoverParams = new beachParty.HoverParams();
                this._selectionParams = new beachParty.SelectionParams();
                this._shapeOpacity = chartClass.defaultOpacity;
                this._instancingParams = new beachParty.InstancingParams();
            }
            this._vsCurrent = this.createViewSettings();
            this.buildAttributes();
            this.buildChartHtml(divElem, isVisible);
            //this._rotateRing = new rotateRingClass(this);
            this._chartBuilder = new beachParty.chartBuilderClass(this._clientElem, this);
            this._facetMgr = new beachParty.facetLabelMgrClass(this, this._facetLabelHolderElem);
            this._chartBuilder.registerForChange("facetLayoutChanged", function (e) {
                var facetLayouts = _this._chartBuilder.getFacetLayoutsInPixels();
                _this._facetMgr.buildLabels(facetLayouts);
            });
            this._chartBuilder.onCycleStart.attach(this, function (cd) {
                _this._isEngineDrawing = true;
                _this.onCycleStart.trigger(cd);
            });
            this._chartBuilder.onCycleEnd.attach(this, function (cs) {
                _this._isEngineDrawing = false;
                cs.cmdId = _this._cmdId;
                cs.cmdTime = 0;
                _this.onCycleEnd.trigger(cs);
            });
            var transformMgr = this._chartBuilder.getTransformMgr();
            this._chartUx.postInit(transformMgr);
            this._chartEng = new beachParty.chartEngClass(this, this._chartBuilder, dataMgr);
            this._chartBuilder.registerForChange("plotBounds", function (e) {
                var rcPlot = _this._chartBuilder.getPlotBounds(true);
                var rcRotateRing = null; // todo: supply this from wheel mgr
                _this.onPlotMoved(rcPlot, rcRotateRing);
            });
            //---- this will processs the initial data ----
            if (this.hasData()) {
                this.processDataChange(beachParty.DataChangeFlags.dataSetChange);
            }
        }
        chartClass.prototype.createViewSettings = function () {
            var settings = this._app.getAppSettingsMgr();
            if (settings) {
                var vs = new ViewSettings(settings.shapeColor(), settings.shapeOpacity());
            }
            else {
                var vs = new ViewSettings();
            }
            return vs;
        };
        chartClass.prototype.getChartUx = function () {
            return this._chartUx;
        };
        chartClass.prototype.hoverPrimaryKey = function (value) {
            if (arguments.length == 0) {
                return this._hoverPrimaryKey;
            }
            if (value != this._hoverPrimaryKey) {
                this._hoverPrimaryKey = value;
                this.onDataChanged("hoverPrimaryKey");
                this.markDrawNeeded("setHoverItem");
            }
        };
        chartClass.prototype.getHoverParams = function () {
            return this._hoverParams;
        };
        chartClass.prototype.autoLoadFile = function (wdp, callback) {
            return this._chartEng.autoLoadFile(wdp, callback);
        };
        chartClass.prototype.applyHover = function (x, y, returnRecord, columnList, showHover, callback) {
            return this._chartEng.applyHover(x, y, returnRecord, columnList, showHover, callback);
        };
        chartClass.prototype.getBinData = function (md, callback) {
            return this._chartEng.getBinData(md, callback);
        };
        chartClass.prototype.testApis = function () {
            //---- test chart API's here ----
            //this.showAxes(false);
            //this.showXGridLines(true);
            //this.showYGridLines(true);
            //this.showAxisTickLabels(false);
            this.enableTwoFingerSwipe(true);
            setTimeout(function (e) {
                //this.axisLabelStyle("fill: red; font-size: 35px");
                //this.showTitleText(false);
                //this.showItemCounts(false);
            }, 1000);
        };
        chartClass.prototype.selectFacetBox = function (index) {
            this._facetMgr.selectFacetLabel(index);
        };
        chartClass.prototype.getIndexOfFacetLabel = function (label) {
            return this._facetMgr.getIndexOfLabel(label);
        };
        chartClass.prototype.animationData = function (value) {
            if (arguments.length == 0) {
                return this._animationData;
            }
            this._animationData = value;
            this.onDataChanged("animationData");
            //---- don't need to trigger a build if this changed ----
            //this.markBuildNeeded("animationData");
        };
        chartClass.prototype.getVisibleColPickers = function () {
            var layout = this._chartBuilder.getLayout();
            var vis = (layout) ? layout.getVisibleColPickers() : "";
            return vis;
        };
        chartClass.prototype.getVisibleBinAdjusters = function () {
            var layout = this._chartBuilder.getLayout();
            var vis = (layout) ? layout.getVisibleBinAdjusters() : "";
            return vis;
        };
        chartClass.prototype.getChartBuilder = function () {
            return this._chartBuilder;
        };
        /**
         * Request a new chart drawing/animation cycle.
         * @param reason
         */
        chartClass.prototype.markBuildNeeded = function (reason) {
            if (this._isVisible) {
                this._chartBuilder.markBuildNeeded(reason);
            }
        };
        /**
         * Request a chart single frame draw (usually for operations like changing hover or size factor).
         * @param reason
         */
        chartClass.prototype.markDrawNeeded = function (reason) {
            if (this._isVisible) {
                this._chartBuilder.redrawLastFrame(reason);
            }
        };
        chartClass.prototype.getRotateRingBounds = function () {
            return this._rcRotateRing;
        };
        chartClass.prototype.getUseNiceNumbers = function () {
            return this._useNiceNumbers;
        };
        chartClass.prototype.getIsDataZoomMode = function () {
            return this._isDataZoomMode;
        };
        chartClass.prototype.enableSelectionSharing = function (value) {
            //this._bpsHelper.enableSelectionSharing(value);
        };
        chartClass.prototype.setPresentationMode = function (value) {
            if (value) {
                var regOptions = { showItemCounts: this._showItemCounts, showTitleText: this.showTitleText };
                this.regOptions(regOptions);
                //---- hide ITEM COUNTS ----
                this.showItemCounts(false);
                //---- show TITLE TEXT ----
                this.showTitleText(true);
                //---- CENTER and adjust-up the titlePanel ----
                vp.select("#titlePanel")
                    .css("text-align", "center")
                    .css("margin-top", "-15px")
                    .css("margin-bottom", "18px");
            }
            else {
                var regOptions = this.regOptions();
                //---- show ITEM COUNTS ----
                this.showItemCounts(regOptions.showItemCounts);
                //---- center TITLE ----
                this.showTitleText(regOptions.showTitleText);
                //---- LEFT-ALIGN and adjust-down the titlePanel ----
                vp.select("#titlePanel")
                    .css("text-align", "left")
                    .css("margin-top", "0")
                    .css("margin-bottom", "0");
            }
        };
        chartClass.prototype.getViewName = function () {
            return this._chartSpecs.getChartName();
        };
        //getSelectedRecords()
        //{
        //    return this._selectedRecords;
        //}
        //getSelectedKeys()
        //{
        //    var keys = this._selectedRecords.map((record) => record["_primaryKey"]);
        //    return keys;
        //}
        //setSelectedRecords(records: any[])
        //{
        //    this._selectedRecords = records;
        //}
        chartClass.prototype.getSelectedCount = function () {
            return this._selectedCount;
        };
        chartClass.prototype.setSelectedCount = function (value) {
            this._selectedCount = value;
        };
        chartClass.prototype.openKnownFile = function (fileName) {
            this._dataMgr.openKnownFile(fileName, false);
        };
        chartClass.prototype.isMaxItemCountEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isMaxItemCountEnabled;
            }
            this._isMaxItemCountEnabled = value;
            this.onDataChanged("isMaxItemCountEnabled");
        };
        chartClass.prototype.staggerForward = function (value) {
            if (arguments.length == 0) {
                return this._animationData.isStaggerForward;
            }
            this._animationData.isStaggerForward = value;
            this.onAnimationDataChanged();
            this.onDataChanged("staggerForward");
        };
        chartClass.prototype.scatterParams = function (value) {
            if (arguments.length == 0) {
                return this._scatterParams;
            }
            this._scatterParams = value;
            this.onDataChanged("scatterParams");
        };
        chartClass.prototype.defaultShapeSize = function (value) {
            if (arguments.length == 0) {
                return this._defaultShapeSize;
            }
            this._defaultShapeSize = value;
            this.onDataChanged("defaultShapeSize");
        };
        chartClass.prototype.getTransformer = function () {
            return this._chartBuilder.getTransformer();
        };
        chartClass.prototype.xAttr = function () {
            return this._xAttr;
        };
        chartClass.prototype.yAttr = function () {
            return this._yAttr;
        };
        chartClass.prototype.zAttr = function () {
            return this._zAttr;
        };
        chartClass.prototype.auxAttr = function () {
            return this._auxAttr;
        };
        chartClass.prototype.colorAttr = function () {
            return this._colorAttr;
        };
        chartClass.prototype.sizeAttr = function () {
            return this._sizeAttr;
        };
        chartClass.prototype.shapeAttr = function () {
            return this._shapeAttr;
        };
        chartClass.prototype.textAttr = function () {
            return this._textAttr;
        };
        chartClass.prototype.facetAttr = function () {
            return this._facetAttr;
        };
        chartClass.prototype.xMapping = function () {
            return this._xAttr.mappingData.apply(this._xAttr, arguments);
        };
        chartClass.prototype.yMapping = function () {
            return this._yAttr.mappingData.apply(this._yAttr, arguments);
        };
        chartClass.prototype.zMapping = function () {
            return this._zAttr.mappingData.apply(this._zAttr, arguments);
        };
        chartClass.prototype.auxMapping = function () {
            return this._auxAttr.mappingData.apply(this._auxAttr, arguments);
        };
        chartClass.prototype.colorMapping = function () {
            return this._colorAttr.mappingData.apply(this._colorAttr, arguments);
        };
        chartClass.prototype.sizeMapping = function () {
            return this._sizeAttr.mappingData.apply(this._sizeAttr, arguments);
        };
        chartClass.prototype.shapeMapping = function () {
            return this._shapeAttr.mappingData.apply(this._shapeAttr, arguments);
        };
        chartClass.prototype.facetMapping = function () {
            return this._facetAttr.mappingData.apply(this._facetAttr, arguments);
        };
        chartClass.prototype.textMapping = function () {
            return this._textAttr.mappingData.apply(this._textAttr, arguments);
        };
        chartClass.prototype.maxItemCount = function (value) {
            if (arguments.length == 0) {
                return this._maxItemCount;
            }
            this._maxItemCount = value;
            this.onDataChanged("maxItemCount");
        };
        chartClass.prototype.isSelectionLocked = function (value) {
            if (arguments.length == 0) {
                return this._isSelectionLocked;
            }
            this._isSelectionLocked = value;
            this.onDataChanged("isSelectionLocked");
        };
        chartClass.prototype.getColInfos = function () {
            return this._colInfos;
        };
        chartClass.prototype.setColInfos = function (value) {
            this._colInfos = value;
        };
        chartClass.prototype.getOrigColInfos = function () {
            return this._origColInfos;
        };
        chartClass.prototype.getPreload = function () {
            return this._preload;
        };
        chartClass.prototype.onDataLoaded = function () {
            var dataMgr = this._dataMgr;
            var dataFrame = dataMgr.getDataFrame();
            var preload = dataMgr.getPreload();
            var dataChangeType = (preload) ? preload.dataChangeType
                : beachParty.DataChangeType.datasetChange;
            //---- tell current chart to change its data ----
            //this._chartRouter.setData(dataFrame, preload);
            var fn = preload.dataName;
            var recordCount = dataFrame.getRecordCount();
            var colInfos = dataMgr.getColInfos(true);
            var origColInfos = dataMgr.getOrigColInfos();
            this._filename = fn;
            this._recordCount = recordCount;
            this._colInfos = colInfos;
            this._origColInfos = origColInfos;
            this._preload = preload;
            //vp.utils.debug("DATAFRAME msg received: recordCount=" + this._recordCount + ", filename=" + this._filename);
            this._selectedCount = 0;
            this._filteredInCount = this._recordCount;
            this.titleText(fn); // title defaults to name of file
            //---- this will tell the app data has changes which will eventually call chart.resetMappingsForNewFile() ----
            this.onDataChanged("dataFrame");
            //---- not needed - this get triggered many times in course of calling chart.resetMappingsForNewFile()  ----
            //this.markBuildNeeded("dataChanged");
        };
        chartClass.prototype.getRecordCount = function () {
            return this._recordCount;
        };
        chartClass.prototype.getFilteredInCount = function () {
            return this._filteredInCount;
        };
        chartClass.prototype.getFileName = function () {
            return this._filename;
        };
        chartClass.prototype.getAppMin = function () {
            return this._app;
        };
        chartClass.prototype.enableTickBoxUI = function (value) {
            vp.utils.debug("enableTickBoxUI: " + value);
            var pe = (value) ? "auto" : "none";
            this.addStyleSheet(".vpxAxisTickBox {pointer-events: " + pe + ";}");
        };
        chartClass.prototype.processDataChange = function (changeFlags) {
            vp.utils.debug("chart.setData called");
            if (changeFlags & beachParty.DataChangeFlags.dataSetChange) {
                var dataFrame = this._dataMgr.getDataFrame();
                var wdParams = new beachParty.WorkingDataParams(dataFrame.getFileName());
                wdParams.forceDataLoad = ((changeFlags & beachParty.DataChangeFlags.dataSetChange) != 0);
                this.onDataLoaded();
            }
            this.markBuildNeeded("dataChanged");
        };
        chartClass.prototype.setChartDebugInfo = function (value) {
        };
        chartClass.prototype.enableTwoFingerSwipe = function (value) {
            this._chartUx.uxMode((value) ? beachParty.UxMode.touch : beachParty.UxMode.rubberBand);
        };
        chartClass.prototype.isEngineDrawing = function () {
            return this._isEngineDrawing;
        };
        chartClass.prototype.selectMode = function (value) {
            if (arguments.length === 0) {
                return this._selectMode;
            }
            this._selectMode = value;
            this.onDataChanged("selectMode");
        };
        chartClass.prototype.textOpacity = function (value) {
            if (arguments.length === 0) {
                return this._textOpacity;
            }
            this._textOpacity = value;
            this.markBuildNeeded("textOpacityChanged");
            this.onDataChanged("textOpacity");
        };
        chartClass.prototype.toPercentOverride = function (value) {
            if (arguments.length === 0) {
                return this._toPercentOverride;
            }
            if (value != this._toPercentOverride) {
                this._toPercentOverride = value;
                this.markBuildNeeded("toPercentOverrideChanged");
                this.onDataChanged("toPercentOverride");
            }
        };
        chartClass.prototype.clearAxisBoxStuff = function () {
            this._axisBoxAttribute = null;
            this._axisBoxKeys = null;
        };
        chartClass.prototype.setDataAndSystemView = function (data, preload, svd, callback) {
            return this._chartEng.setDataAndSystemView(data, preload, svd, callback);
        };
        chartClass.prototype.search = function (colName, value, maxValue, searchType, searchAction, searchRawValues, caseSensitive, selectMode, callback, selectKey) {
            if (searchType === void 0) { searchType = beachParty.TextSearchType.contains; }
            if (searchAction === void 0) { searchAction = beachParty.SearchAction.selectMatches; }
            if (selectMode == undefined) {
                selectMode = this._selectMode;
            }
            return this._chartEng.search(colName, value, maxValue, searchType, searchAction, searchRawValues, caseSensitive, selectMode, callback, selectKey);
        };
        chartClass.prototype.searchEx = function (spList, selectKey, callback) {
            return this._chartEng.searchEx(spList, selectKey, callback);
        };
        chartClass.prototype.processSelectKey = function (selectMode, selectKey) {
            if (selectMode != beachParty.SelectMode.smartToggle) {
                this.clearAxisBoxStuff();
            }
            else {
                selectMode = beachParty.SelectMode.additive; // the default
                if (!selectKey) {
                    this._axisBoxAttribute = null;
                    this._axisBoxKeys = null;
                }
                else {
                    var parts = selectKey.split(".");
                    var attr = parts[0];
                    var key = parts[1];
                    if (attr != this._axisBoxAttribute) {
                        //---- start a new session with this as the first click ----
                        this._axisBoxAttribute = attr;
                        this._axisBoxKeys = {};
                        this._axisBoxKeys[key] = 1;
                    }
                    else {
                        //---- we are within a session of clicks for axis ATTR ----
                        if (this._axisBoxKeys[key] === undefined) {
                            //--- FIRST time clicking on this key within this session ----
                            this._axisBoxKeys[key] = 1;
                        }
                        else {
                            //--- SECOND time clicking on this key within this session ----
                            selectMode = beachParty.SelectMode.subtractive;
                            delete this._axisBoxKeys[key];
                        }
                    }
                }
            }
            return selectMode;
        };
        chartClass.prototype.doSearch = function (legendSource, colName, minValue, maxValue, searchType, selectMode, selectKey) {
            if (selectMode === undefined) {
                selectMode = this._selectMode;
            }
            //---- tell app we are doing a search ----
            var sd = new beachParty.SelectionDesc();
            sd.searchParams = sp;
            sd.legendSource = legendSource;
            sd.selectMode = selectMode;
            var selectionDesc = sd;
            this.onSearchStarted.trigger({ sender: this, selectionDesc: sd });
            var sp = new beachParty.SearchParams();
            sp.colName = colName;
            sp.minValue = minValue;
            sp.maxValue = maxValue;
            sp.selectMode = selectMode;
            sp.searchType = searchType;
            this.searchEx([sp], selectKey);
        };
        chartClass.prototype.isolateSelection = function (callback) {
            this._dataMgr.isolateSelection();
            this.markBuildNeeded("isolate");
        };
        chartClass.prototype.excludeSelection = function (callback) {
            this._dataMgr.excludeSelection();
            this.markBuildNeeded("exclude");
        };
        chartClass.prototype.resetFilter = function (callback) {
            this._dataMgr.resetFilter();
            this.markBuildNeeded("resetFilter");
            //---- callback should be called after data has been changed ----
            if (callback) {
                callback({ sender: this });
            }
        };
        chartClass.prototype.cursorHitTestLoc = function (value) {
            if (arguments.length == 0) {
                var cht = this._cursorHitTestLoc;
                var str = (cht) ? ("{x: " + Math.round(cht.x) + ", y: " + Math.round(cht.y) + "}") : "";
                return str;
            }
            this._cursorHitTestLoc = value;
            this.onDataChanged("cursorHitTestLoc");
        };
        chartClass.prototype.getSelectionParams = function () {
            return this._selectionParams;
        };
        chartClass.prototype.cursorHitTestShape = function (value) {
            if (arguments.length == 0) {
                var str = (this._cursorHitTestShape) ? this._cursorHitTestShape : "";
                return str;
            }
            this._cursorHitTestShape = value;
            this.onDataChanged("cursorHitTestShape");
        };
        chartClass.prototype.showClientFrame = function (value) {
            if (arguments.length == 0) {
                return this._showClientFrame;
            }
            this._showClientFrame = value;
            vp.select(this._clientElem).css("border", (value) ? "1px solid yellow" : "0");
            this.onDataChanged("showClientFrame");
        };
        chartClass.prototype.showGlCanvasFrame = function (value) {
            if (arguments.length == 0) {
                return this._showGlCanvasFrame;
            }
            this._showGlCanvasFrame = value;
            var glCanvasElem = this._chartBuilder.getGlCanvasElem();
            vp.select(glCanvasElem).css("border", (value) ? "1px solid green" : "0");
            this.onDataChanged("showGlCanvasFrame");
        };
        chartClass.prototype.showChartUxFrame = function (value) {
            if (arguments.length == 0) {
                return this._showChartUxFrame;
            }
            this._showChartUxFrame = value;
            vp.select(this._uxElem).css("border", (value) ? "1px solid red" : "0");
            this.onDataChanged("showChartUxFrame");
        };
        chartClass.prototype.showRing = function () {
            //this._currentChart.getPlotBounds((msgBlock) =>
            //{
            //    this._rotateRing.setRotationBounds(msgBlock.rcRotateRing);
            //});
            this._rotateRing.enter();
        };
        chartClass.prototype.getActualToolTipColumns = function () {
            var colNames = this.tooltipColumns();
            //---- if not columns explictly set, use columns in-use by chart ----
            if (colNames == null || colNames.length == 0) {
                colNames = this.getMappedColumns();
            }
            //---- if chart not using any columns, use all columns ----
            if (colNames == null || colNames.length == 0) {
                colNames = this._dataMgr.getDataFrame().getColumnNames();
                //---- filter out system columns ----
                colNames = colNames.filter(function (colName) { return !colName.startsWith("_"); });
            }
            return colNames;
        };
        chartClass.prototype.tooltipColumns = function (value) {
            if (arguments.length == 0) {
                return this._tooltipColumns;
            }
            this._tooltipColumns = value;
            this.onDataChanged("tooltipColumns");
        };
        chartClass.prototype.isItemSortAscending = function (value, tellEngine) {
            if (tellEngine === void 0) { tellEngine = true; }
            if (arguments.length === 0) {
                return this._isItemSortAscending;
            }
            if (value != this._isItemSortAscending) {
                this._isItemSortAscending = value;
                if (tellEngine) {
                    this.onSortParmsChanged(true);
                }
                this.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.sortParams, true, { ascending: value });
                this.onDataChanged("isItemSortAscending");
            }
        };
        chartClass.prototype.setSelectionWithKeys = function (keys) {
            var dataFrame = this._dataMgr.getDataFrame();
            var primaryKeys = dataFrame.getPrimaryKeys(keys, beachParty.VectorType.primaryKeyList);
            this._dataMgr.setSelectionDirect(primaryKeys, null);
        };
        chartClass.prototype.sortItemColumn = function (value, tellEngine) {
            if (tellEngine === void 0) { tellEngine = true; }
            if (arguments.length === 0) {
                return this._sortItemCol;
            }
            if (value != this._sortItemCol) {
                this._sortItemCol = value;
                this.onSortParmsChanged(tellEngine);
                this.onDataChanged("sortItemColumn");
                this.logAction(beachParty.Gesture.select, "sortItemColumn", beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.sortItemColumn, true, null, false, { value: value });
            }
        };
        chartClass.prototype.onSortParmsChanged = function (tellEngine) {
            var _this = this;
            if (tellEngine) {
                //---- put on a timer so we can combine multiple changes to sort params ----
                setTimeout(function (e) {
                    _this._dataMgr.sortData(_this._sortItemCol, _this._isItemSortAscending);
                    _this.markBuildNeeded("sortParamsChanged");
                }, 1);
            }
            this.onDataChanged("sortParams");
        };
        chartClass.prototype.sortIfNeeded = function (colName, isDescending) {
            this.sortItemColumn(colName);
            this.isItemSortAscending(!isDescending);
        };
        chartClass.prototype.isItemSortByColor = function (value) {
            var colName = this._colorAttr.colName();
            if (arguments.length === 0) {
                return (colName == this._sortItemCol);
            }
            if (value) {
                this._sortItemCol = colName;
            }
            else {
                this._sortItemCol = this._lastScatterYCol;
            }
            this.onSortParmsChanged(true);
            this.onDataChanged("isItemSortByColor");
        };
        chartClass.prototype.toggleWheel = function () {
            if (this._dragAction == beachParty.DragAction.select) {
                this.dragAction("wheel");
                vp.select("#wheelButton").attr("data-selected", "true");
            }
            else {
                this.dragAction("select");
                vp.select("#wheelButton").attr("data-selected", "false");
            }
        };
        chartClass.prototype.dragAction = function (value) {
            if (arguments.length == 0) {
                return beachParty.DragAction[this._dragAction];
            }
            this._dragAction = beachParty.DragAction[value];
            var useWheel = (value == "rotate" || value == "move" || value == "wheel");
            //this._chartUx.uxMode((useWheel) ? UxMode.wheel : UxMode.touch);
            var tm = beachParty.ClientTransformMode.none;
            if (value == "rotate") {
                tm = beachParty.ClientTransformMode.rotate;
            }
            else if (value == "move") {
                tm = beachParty.ClientTransformMode.pan;
            }
            else if (value == "wheel") {
                tm = beachParty.ClientTransformMode.wheel;
            }
            this.markBuildNeeded("setTransformMode");
            this.onDataChanged("dragAction");
            this._chartUx.getTouchMgr().isShowingWheel(value == "wheel");
        };
        chartClass.prototype.numColumns = function (value) {
            if (arguments.length == 0) {
                return this._flatParams.numColumns;
            }
            this._flatParams.numColumns = value;
            this.onFlatParamsChanged();
            this.onDataChanged("numColumns");
            this.logAction(beachParty.Gesture.select, "numColumns", beachParty.ElementType.numAdjuster, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { numColumns: value });
        };
        chartClass.prototype.useNiceNumbers = function (value) {
            if (arguments.length == 0) {
                return this._useNiceNumbers;
            }
            this._useNiceNumbers = value;
            this.onDataChanged("useNiceNumbers");
        };
        chartClass.prototype.pulse3DCircleIfAppropriate = function () {
            var settings = this._app.getAppSettingsMgr();
            //---- if in transform mode, but not showing wheel, pulse the ring to remind user where it is ----
            if (this._isTransformMode && !settings._showWheelDuringTransformMode) {
                this._rotateRing.pulse();
            }
        };
        chartClass.prototype.isTransformMode = function () {
            return this._isTransformMode;
        };
        chartClass.prototype.mapByColorChannels = function (value) {
            if (arguments.length == 0) {
                return this._mapByColorChannels;
            }
            this._mapByColorChannels = value;
            this.onDataChanged("mapByColorChannels");
        };
        chartClass.prototype.shapeColor = function (value, omitProcessing) {
            if (arguments.length === 0) {
                return this._shapeColor;
            }
            this._shapeColor = value;
            this._vsCurrent.shapeColor = value;
            if (!omitProcessing) {
                this.logAction(beachParty.Gesture.select, "shapeColor", beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { shapeColor: value });
                this.onShapeColorChanged();
            }
        };
        chartClass.prototype.onShapeColorChanged = function () {
            var cr = beachParty.cbUtils.getBeachPartyColor(this._shapeColor);
            this.markBuildNeeded("setShapeColor");
            var colorAttr = this._colorAttr;
            if (colorAttr) {
                colorAttr.colName(null);
                colorAttr.onMappingChanged(false);
            }
            this.onDataChanged("shapeColor");
        };
        chartClass.prototype.hasData = function () {
            var dataFrame = this.getDataFrame();
            return (this._dataMgr != null && dataFrame.getRecordCount() > 0);
        };
        chartClass.prototype.shapeImage = function (value, omitProcessing) {
            if (arguments.length === 0) {
                return this._shapeImage;
            }
            if (value != this._shapeImage) {
                this._shapeImage = value;
                this._vsCurrent.shapeName = value;
                if (!omitProcessing) {
                    this.onShapeImageChanged();
                    this.logAction(beachParty.Gesture.select, "shapeImage", beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { shapeImage: value });
                }
            }
        };
        chartClass.prototype.getLayoutName = function () {
            return this._chartSpecs.getLayoutName();
        };
        chartClass.prototype.layoutType = function () {
            return this._chartSpecs.layoutType();
        };
        chartClass.prototype.onShapeImageChanged = function () {
            this.markBuildNeeded("setShapeImage");
            this.onDataChanged("shapeImage");
        };
        chartClass.prototype.chartColor = function (value) {
            if (arguments.length === 0) {
                return this._chartColor;
            }
            this._chartColor = value;
            this.onChartColorChanged();
        };
        chartClass.prototype.onChartColorChanged = function () {
            var value = beachParty.cbUtils.getBeachPartyColor(this._chartColor);
            vp.select(this._root)
                .css("background", value);
            this.markBuildNeeded("setChartBackground");
            this.onDataChanged("chartColor");
        };
        chartClass.prototype.canvasColor = function (value) {
            if (arguments.length === 0) {
                return this._canvasColor;
            }
            this._canvasColor = value;
            this.onCanvasColorChanged();
        };
        chartClass.prototype.onCanvasColorChanged = function () {
            var cr = beachParty.cbUtils.getBeachPartyColor(this._canvasColor);
            this.markBuildNeeded("setPlotBackground");
            this.onDataChanged("canvasColor");
        };
        chartClass.prototype.getSpiralSeed = function () {
            return this._spiralParams.seed;
        };
        chartClass.prototype.setSpiralSeed = function (seed) {
            if (seed === undefined) {
                seed = 180 * Math.random();
            }
            this._spiralParams.seed = seed;
            this.markBuildNeeded("setSpiralParams");
            this.logAction(beachParty.Gesture.click, "nextSpiral", beachParty.ElementType.button, beachParty.Action.select, beachParty.Target.chartOptions, true, { nextSpiral: this._spiralParams.seed });
            return seed;
        };
        chartClass.prototype.buildFromTop = function (value) {
            if (arguments.length == 0) {
                return this._flatParams.buildFromTop;
            }
            this._flatParams.buildFromTop = value;
            this.onFlatParamsChanged();
            this.onDataChanged("startFromTop");
            this.logAction(beachParty.Gesture.select, "shapeSeparation", beachParty.ElementType.numAdjuster, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { shapeSeparation: value });
        };
        chartClass.prototype.onFlatParamsChanged = function () {
            this.onDataChanged("flatParams");
            this.markBuildNeeded("flatParamsChanged");
            this.markBuildNeeded("setFlatParams");
        };
        chartClass.prototype.flatParams = function (value) {
            if (arguments.length == 0) {
                return this._flatParams;
            }
            this._flatParams = value;
            this.onFlatParamsChanged();
        };
        chartClass.prototype.spiralParams = function (value) {
            if (arguments.length == 0) {
                return this._spiralParams;
            }
            this._spiralParams = value;
            this.onDataChanged("spiralParams");
        };
        chartClass.prototype.shapeOpacity = function (value, omitProcessing) {
            if (arguments.length === 0) {
                return this._shapeOpacity;
            }
            if (value != this._shapeOpacity) {
                this._shapeOpacity = value;
                this._vsCurrent.shapeOpacity = value;
            }
            if (!omitProcessing) {
                this.markDrawNeeded("setShapeOpacity");
                this.onDataChanged("shapeOpacity");
            }
        };
        chartClass.prototype.shapeOpacityCompleted = function (value) {
            this.logAction(beachParty.Gesture.select, "shapeOpacity", beachParty.ElementType.numAdjuster, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { shapeOpacity: value });
        };
        chartClass.prototype.isDataZoomMode = function (value) {
            if (arguments.length == 0) {
                return this._isDataZoomMode;
            }
            this._isDataZoomMode = value;
            //---- reflect in UI ----
            vp.select("#dataZoomButton")
                .attr("data-selected", value + "");
            if (!value) {
                this.resetTransform();
            }
            this.onDataChanged("isDataZoomMode");
        };
        chartClass.prototype.toggleDataZoom = function (e) {
            //---- toggle mode ----
            this.isDataZoomMode(!this._isDataZoomMode);
            //---- log it ----
            var action = (this._isDataZoomMode) ? beachParty.Action.hide : beachParty.Action.show;
            var targetId = (e) ? e.target.id : "";
            this.logAction(beachParty.Gesture.click, targetId, beachParty.ElementType.button, action, beachParty.Target.dataZoom, true);
        };
        chartClass.prototype.resetDataZoomMode = function () {
            if (this._isDataZoomMode) {
                this.toggleDataZoom(null);
            }
        };
        chartClass.prototype.isCountOrSumOrGrid = function (attrName, layoutType) {
            var chartType = this._chartSpecs.getChartType();
            layoutType = (layoutType === undefined) ? this._chartSpecs.layoutType() : layoutType;
            //---- TODO: clean up this messy chartName/layoutName design ----
            var isGrid = (chartType == beachParty.ChartType.Grid && attrName == "y");
            //var isSquarify = (layoutType == LayoutType.Squarify);
            var isColBar = (chartType == beachParty.ChartType.Column && attrName == "y") || (chartType == beachParty.ChartType.Bar && attrName == "x");
            var isCountSum = (isColBar || isGrid);
            return isCountSum;
        };
        chartClass.prototype.getAttribute = function (name) {
            return this._attributes[name];
        };
        chartClass.prototype.sizeFactor = function (value, animate, omitProcessing) {
            if (arguments.length === 0) {
                return this._sizeFactor;
            }
            if (value != this._sizeFactor) {
                this._sizeFactor = value;
                this._vsCurrent.sizeFactor = value;
                if (!omitProcessing) {
                    this.setSizeFactor(value, animate);
                    this.onDataChanged("sizeFactor");
                }
            }
        };
        chartClass.prototype.setSizeFactor = function (value, animate) {
            this.markDrawNeeded("setSizeFactor");
        };
        chartClass.prototype.sizeFactorCompleted = function (value) {
            this.logAction(beachParty.Gesture.select, "shapeSize", beachParty.ElementType.numAdjuster, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { sizeFactor: value });
        };
        chartClass.prototype.separationFactor = function (value, omitProcessing) {
            if (arguments.length === 0) {
                return this._separationFactor;
            }
            this._separationFactor = value;
            this._vsCurrent.separation = value;
            if (!omitProcessing) {
                //---- record changed size for this chart ----
                this.markBuildNeeded("setSeparationFactor");
                this.onDataChanged("separationFactor");
                this.logAction(beachParty.Gesture.select, "shapeSeparation", beachParty.ElementType.numAdjuster, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { shapeSeparation: value });
            }
        };
        chartClass.prototype.onChartOrLayoutChanged = function () {
            //---- apply user-preferences for this view ----
            this.applyViewSettings();
            //---- notify app ----
            this.onDataChanged("chartOrLayout");
            //---- notify chartBuilder ----
            this.markBuildNeeded("chartOrLayoutChanged");
        };
        chartClass.prototype.isLoggingEnabled = function (value) {
            return this._app.isLoggingEnabled.apply(this._app, arguments);
        };
        chartClass.prototype.applyViewSettings = function () {
            //---- turn off logging while we set various properties as side effect of main property change ----
            this.isLoggingEnabled(false);
            try {
                //---- apply view settings ----
                var dataFrame = this.getDataFrame();
                var cs = this._chartSpecs;
                var key = cs.getChartName() + "^" + cs.getLayoutName() + "^" + dataFrame.getFileName();
                var vs = this._chartSettings[key];
                if (!vs) {
                    vs = this.createViewSettings();
                    this._chartSettings[key] = vs;
                }
                this._vsCurrent = vs;
                if (vs.sizeFactor) {
                    this.sizeFactor(vs.sizeFactor, undefined, true);
                }
                if (vs.shapeOpacity) {
                    this.shapeOpacity(vs.shapeOpacity, true);
                }
                if (vs.shapeColor) {
                    this.shapeColor(vs.shapeColor, true);
                }
                if (vs.separation) {
                    this.separationFactor(vs.separation, true);
                }
                if (vs.shapeName) {
                    this.shapeImage(vs.shapeName, true);
                }
                if (vs.zBinCount) {
                    this._zAttr.binCount(vs.zBinCount, true);
                }
            }
            finally {
                this.isLoggingEnabled(true);
            }
        };
        chartClass.prototype.getLayoutsForCurrentChart = function () {
            var layouts = null;
            var chartName = this._chartSpecs.getChartName();
            /// chartnames: 
            ///     flat, column, density, line, scatter, pie
            ///     violin, graph, cluster, parallel, xxxx, xxxx
            if (chartName == "Flat") {
                layouts = [beachParty.LayoutType.Grid, beachParty.LayoutType.Circle, beachParty.LayoutType.Poisson, beachParty.LayoutType.Random];
            }
            else if (chartName == "Column" || chartName == "Bar") {
                layouts = [beachParty.LayoutType.Grid, beachParty.LayoutType.Squarify, beachParty.LayoutType.Strips, beachParty.LayoutType.Percent, beachParty.LayoutType.Random];
            }
            else if (chartName == "Density") {
                layouts = [beachParty.LayoutType.Grid, beachParty.LayoutType.Circle, beachParty.LayoutType.Poisson, beachParty.LayoutType.Random];
            }
            else if (chartName == "Stacks") {
                layouts = [beachParty.LayoutType.ScaleToFit, beachParty.LayoutType.Cubes];
            }
            return layouts;
        };
        chartClass.prototype.onChartChanged = function (layoutType) {
            var chartType = this._chartSpecs.getChartType();
            if (layoutType !== undefined) {
                //---- remember last used layout for this chart type ----
                this._layoutsByChart[chartType] = layoutType;
            }
            else {
                //---- get user-specified layout for this chart type ----
                layoutType = this._layoutsByChart[chartType];
            }
            if (layoutType === undefined) {
                var layouts = this.getLayoutsForCurrentChart();
                if (layouts && layouts.length) {
                    //---- use first choice for now ----
                    layoutType = layouts[0];
                }
                else {
                    layoutType = beachParty.LayoutType.Default; // no layouts for this chart
                }
            }
            var uiName = this._chartSpecs.getUiChartName();
            if (uiName == "Bar" || uiName == "Column" || uiName == "Grid") {
                layoutType = this.onSizePackingRelatedChanged(true, layoutType); //false);
            }
            //---- make sure count/sum/x/y is updated ----
            this.onDataChanged("xMapping");
            this.onDataChanged("yMapping");
            this._zAttr.limitBinsForStrings(this._chartSpecs.getChartType() != beachParty.ChartType.Stacks);
            this.changeToLayout(layoutType, false);
        };
        chartClass.prototype.customParams = function () {
            return this._customParams;
        };
        /**
         *  called when we change the view (chart type).
         * @param name
         * @param isFromUi
         */
        chartClass.prototype.changeToLayout = function (layoutType, isFromUi) {
            //---- store the new layout value ----
            this._chartSpecs.layoutType(layoutType);
            //---- don't bother updating UI until first data frame is loaded ----
            //this._app.updateUiForLayoutChange();
            if (isFromUi) {
                this.logAction(beachParty.Gesture.select, null, beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.layout, true, { name: name });
            }
            this.onChartOrLayoutChanged();
        };
        chartClass.prototype.logAction = function (gesture, elementId, elementType, action, target, isUndoable, options, forceLog, nonLogOptions) {
            if (this._app) {
                //---- call into our instance ----
                this._app.logAction(gesture, elementId, elementType, action, target, isUndoable, options, forceLog, nonLogOptions);
            }
        };
        chartClass.prototype.clearSelection = function () {
            this._dataMgr.clearSelection();
        };
        chartClass.prototype.isWheelInertia = function (value) {
            if (arguments.length === 0) {
                return this._isWheelInertia;
            }
            this._isWheelInertia = value;
            this.markBuildNeeded("setWheelInertia");
            this.onDataChanged("isWheelInertia");
        };
        chartClass.prototype.showWheelDuringTransformMode = function (value) {
            if (arguments.length == 0) {
                return this._showWheelDuringTransformMode;
            }
            this._showWheelDuringTransformMode = value;
            this.markBuildNeeded("showWheelDuringTransformMode");
            this.onDataChanged("showWheelDuringTransformMode");
        };
        chartClass.prototype.is3dGridAlwaysOn = function (value) {
            if (arguments.length === 0) {
                return this._is3dGridAlwaysOn;
            }
            this._is3dGridAlwaysOn = value;
            this.onDataChanged("is3dGridAlwaysOn");
            this.on3dViewChanged();
        };
        chartClass.prototype.ambientLightLevel = function (value) {
            if (arguments.length === 0) {
                return this._lightingParams.ambientLight.lightFactor;
            }
            this._lightingParams.ambientLight.lightFactor = value;
            this.onDataChanged("ambientLightLevel");
            this.onLightingParamsChanged();
        };
        chartClass.prototype.customSpec = function (value) {
            if (arguments.length == 0) {
                return this._customSpec;
            }
            this._customSpec = value;
            this.onCustomParamChanged();
            this.onDataChanged("customSpec");
        };
        chartClass.prototype.customX = function (value) {
            if (arguments.length == 0) {
                return beachParty.CustomColUsage[this._customParams.xUsage];
            }
            this._customParams.xUsage = beachParty.CustomColUsage[value];
            this.onCustomParamChanged();
            this.onDataChanged("customX");
        };
        chartClass.prototype.customY = function (value) {
            if (arguments.length == 0) {
                return beachParty.CustomColUsage[this._customParams.yUsage];
            }
            this._customParams.yUsage = beachParty.CustomColUsage[value];
            this.onCustomParamChanged();
            this.onDataChanged("customY");
        };
        chartClass.prototype.customZ = function (value) {
            if (arguments.length == 0) {
                return beachParty.CustomColUsage[this._customParams.zUsage];
            }
            this._customParams.zUsage = beachParty.CustomColUsage[value];
            this.onCustomParamChanged();
            this.onDataChanged("customZ");
        };
        chartClass.prototype.customLayout = function (value) {
            if (arguments.length == 0) {
                return beachParty.CustomLayout[this._customParams.layout];
            }
            this._customParams.layout = beachParty.CustomLayout[value];
            this.onCustomParamChanged();
            this.onDataChanged("customLayout");
        };
        chartClass.prototype.applyCustomParams = function () {
            this.onCustomParamChanged();
        };
        chartClass.prototype.takeSnapshot = function (chartBgColor, plotOnly) {
            var url;
            null;
            if (true) {
                var plotCanvas = this._chartBuilder.getGlCanvasElem();
                if (plotOnly) {
                    //---- PNG is messed up for IE/Chrome/Firefox; JPEG seems to work correctly ----
                    url = plotCanvas.toDataURL("image/jpeg", 1);
                }
                else {
                    var rcCanvas = this._chartBuilder.getChartBounds();
                    //---- build canvas the same size as our engine document (to hold plot + axes) ----
                    //---- other parts of snapshot (legends, etc.) will be drawn by the calling client app ----
                    var chartCanvas = document.createElement("canvas");
                    chartCanvas.width = rcCanvas.width;
                    chartCanvas.height = rcCanvas.height;
                    var ctx = chartCanvas.getContext("2d");
                    //---- draw body background ----
                    ctx.fillStyle = chartBgColor;
                    ctx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);
                    //---- get plot bounds ----
                    var rcPlot = this._chartBuilder.getPlotBounds(false);
                    var facetHelper = this._chartBuilder.getFacetHelper();
                    //---- avoid system error when drawing 0-size image ----
                    if (rcPlot.width > 0 && rcPlot.height > 0) {
                        //---- draw plot BACKGROUND ----
                        var cs = getComputedStyle(plotCanvas);
                        if (cs.backgroundColor) {
                            ctx.fillStyle = cs.backgroundColor;
                            ctx.fillRect(rcPlot.left, rcPlot.top, rcPlot.width, rcPlot.height);
                        }
                        //---- draw PLOT ----
                        ctx.drawImage(plotCanvas, rcPlot.left, rcPlot.top);
                    }
                    //---- draw axes ----
                    var svgElem = this._chartBuilder.getSvgDoc();
                    beachParty.drawSvgChildren(ctx, svgElem, rcCanvas, 0, 0, true);
                    //---- draw top/right borders ----
                    //drawHtmlChildren(ctx, this._appMgr.getElement("canvas3d"), null, true);
                    //drawHtmlChildren(ctx, this._root, null, true);
                    //---- PNG is messed up for IE/Chrome/Firefox; JPEG seems to work correctly ----
                    url = chartCanvas.toDataURL("image/jpeg", 1);
                }
            }
            return url;
        };
        chartClass.prototype.captureInsightProperties = function (preload) {
            //---- save VIEW properties ----
            preload.chartName = this._chartSpecs.getChartName();
            preload.subLayout = this._chartSpecs.getLayoutName();
            preload.sizeFactor = this._sizeFactor;
            preload.separationFactor = this._separationFactor;
            preload.shapeOpacity = this._shapeOpacity;
            preload.shapeColor = this._shapeColor;
            preload.shapeImage = this._shapeImage;
            //---- save FLAT PARAMS ----
            var fp = new beachParty.FlatParams();
            fp.buildFromTop = this.buildFromTop();
            fp.numColumns = this.numColumns();
            preload.flatParams = fp;
            //---- sorting stuff ----
            preload.sortCol = this._sortItemCol;
            preload.isSortAscending = this._isItemSortAscending;
            var xm = vp.utils.copyMap(this._xAttr.mappingData(), true);
            var ym = vp.utils.copyMap(this._yAttr.mappingData(), true);
            var zm = vp.utils.copyMap(this._zAttr.mappingData(), true);
            var am = vp.utils.copyMap(this._auxAttr.mappingData(), true);
            var cm = vp.utils.copyMap(this._colorAttr.mappingData(), true);
            var sm = vp.utils.copyMap(this._sizeAttr.mappingData(), true);
            var im = vp.utils.copyMap(this._shapeAttr.mappingData(), true);
            var fm = vp.utils.copyMap(this._facetAttr.mappingData(), true);
            var colMappings = new beachParty.ColMappings(null, null);
            preload.colMappings = colMappings;
            colMappings.x = xm;
            colMappings.y = ym;
            colMappings.z = zm;
            colMappings.aux = am;
            colMappings.color = cm;
            colMappings.size = sm;
            colMappings.shape = im;
            colMappings.facet = fm;
        };
        chartClass.prototype.onCustomParamChanged = function () {
            if (this._chartSpecs.getChartName() != "Custom") {
                this.changeToChart(beachParty.ChartType.Custom);
            }
            this.markBuildNeeded("setCustomParams");
            this.onDataChanged("customParams");
        };
        chartClass.prototype.on3dViewChanged = function () {
            var chartName = this._chartSpecs.getChartName();
            var isLightingChart = (chartName == "Stacks" || chartName == "Scatter-3D");
            var use3DGrid = (chartName == "Stacks" || chartName == "Scatter-3D");
            this._lightingParams.isLightingEnabled = (this._isLightingAlwaysOn || isLightingChart);
            this.onLightingParamsChanged();
            var use3dGrid = (this._is3dGridAlwaysOn || use3DGrid);
            this.markBuildNeeded("set3dGridVisible");
        };
        chartClass.prototype.isLightingAlwaysOn = function (value) {
            if (arguments.length === 0) {
                return this._isLightingAlwaysOn;
            }
            this._isLightingAlwaysOn = value;
            this.onDataChanged("isLightingAlwaysOn");
            this.on3dViewChanged();
        };
        chartClass.prototype.onLightingParamsChanged = function () {
            this.markBuildNeeded("setLightingParams");
        };
        chartClass.prototype.getLightingParanms = function () {
            return this._lightingParams;
        };
        chartClass.prototype.selectedColorEffect = function (value) {
            if (arguments.length == 0) {
                return beachParty.ColorEffect[this._selectionParams.selectedParams.colorEffect];
            }
            this._selectionParams.selectedParams.colorEffect = beachParty.ColorEffect[value];
            this.onDataChanged("selectedColorEffect");
            this.onSelectionParamsChanged();
        };
        chartClass.prototype.unselectedColorEffect = function (value) {
            if (arguments.length == 0) {
                return beachParty.ColorEffect[this._selectionParams.unselectedParams.colorEffect];
            }
            this._selectionParams.unselectedParams.colorEffect = beachParty.ColorEffect[value];
            this.onDataChanged("unselectedColorEffect");
            this.onSelectionParamsChanged();
        };
        chartClass.prototype.selectedColor = function (value) {
            if (arguments.length == 0) {
                return this._selectionParams.selectedParams.color;
            }
            this._selectionParams.selectedParams.color = value;
            this.onDataChanged("selectedColor");
            this.onSelectionParamsChanged();
        };
        chartClass.prototype.unselectedColor = function (value) {
            if (arguments.length == 0) {
                return this._selectionParams.unselectedParams.color;
            }
            this._selectionParams.unselectedParams.color = value;
            this.onDataChanged("unselectedColor");
            this.onSelectionParamsChanged();
        };
        chartClass.prototype.selectedColorFactor = function (value) {
            if (arguments.length == 0) {
                return this._selectionParams.selectedParams.colorFactor;
            }
            this._selectionParams.selectedParams.colorFactor = value;
            this.onDataChanged("selectedColorFactor");
            this.onSelectionParamsChanged();
        };
        chartClass.prototype.unselectedColorFactor = function (value) {
            if (arguments.length == 0) {
                return this._selectionParams.unselectedParams.colorFactor;
            }
            this._selectionParams.unselectedParams.colorFactor = value;
            this.onDataChanged("unselectedColorFactor");
            this.onSelectionParamsChanged();
        };
        chartClass.prototype.onSelectionParamsChanged = function () {
            this.markBuildNeeded("onSelectionParamsChanged");
        };
        chartClass.prototype.hoverOnDetailView = function (value) {
            if (arguments.length == 0) {
                return this._hoverOnDetailView;
            }
            this._hoverOnDetailView = value;
            this.onDataChanged("hoverOnDetailView");
        };
        chartClass.prototype.hoverOnMouseMove = function (value) {
            if (arguments.length == 0) {
                return this._hoverOnMouseMove;
            }
            this._hoverOnMouseMove = value;
            this.onDataChanged("hoverOnMouseMove");
        };
        chartClass.prototype.toolTipElem = function (value) {
            if (arguments.length == 0) {
                return this._toolTipElem;
            }
            this._toolTipElem = value;
            this.onDataChanged("toolTipElem");
        };
        chartClass.prototype.isTooltipsEnabled = function (value) {
            if (arguments.length == 0) {
                var enabled = (this._isTooltipsEnabled && !this._isEngineDrawing);
                return enabled;
            }
            this._isTooltipsEnabled = value;
            this.onDataChanged("isTooltipsEnabled");
        };
        chartClass.prototype.includeNamesInTooltip = function (value) {
            if (arguments.length == 0) {
                return this._includeNamesInTooltip;
            }
            this._includeNamesInTooltip = value;
            this.onDataChanged("includeNamesInTooltip");
        };
        chartClass.prototype.applyHoverCore = function (mousePos, showHover) {
            var hp = this._hoverParams;
            //var primaryKey = null;
            this._lastHoverPos = mousePos;
            var hpk = null;
            var shapeEng = this.getShapeEngine();
            if (hp.hoverMatch == beachParty.HoverMatch.point) {
                var transformMgr = this._chartBuilder.getTransformMgr();
                var ray = transformMgr.getRayFromScreenPos(mousePos.x, mousePos.y);
                var items = shapeEng.hitTestRay(ray, mousePos);
                if (items && items.length) {
                    hpk = items[0].primaryKey;
                }
            }
            else if (hp.hoverMatch == beachParty.HoverMatch.square) {
                var sz = hp.squareSize;
                if (sz >= 1) {
                    var rcScreen = vp.geom.createRect(mousePos.x - sz / 2, mousePos.y - sz / 2, sz, sz);
                    var boxes = shapeEng.hitTestFromRect(rcScreen, false, true);
                    if (boxes && boxes.length) {
                        var box = boxes[0];
                        hpk = box.primaryKey;
                    }
                }
            }
            if (showHover) {
                var pkShow = (showHover) ? hpk : -1;
            }
            //---- return actual primary key to client ----
            return hpk;
        };
        chartClass.prototype.hoverMatch = function (value) {
            if (arguments.length == 0) {
                return beachParty.HoverMatch[this._hoverParams.hoverMatch];
            }
            this._hoverParams.hoverMatch = beachParty.HoverMatch[value];
            this.onDataChanged("hoverMatch");
            this.onHoverParamsChanged();
        };
        chartClass.prototype.hoverEffect = function (value) {
            if (arguments.length == 0) {
                return beachParty.HoverEffect[this._hoverParams.hoverEffect];
            }
            this._hoverParams.hoverEffect = beachParty.HoverEffect[value];
            this.onDataChanged("hoverEffect");
            this.onHoverParamsChanged();
        };
        chartClass.prototype.hoverColor = function (value) {
            if (arguments.length == 0) {
                return this._hoverParams.hoverColor;
            }
            this._hoverParams.hoverColor = value;
            this.onDataChanged("hoverColor");
            this.onHoverParamsChanged();
        };
        chartClass.prototype.hoverSize = function (value) {
            if (arguments.length == 0) {
                return this._hoverParams.squareSize;
            }
            this._hoverParams.squareSize = value;
            this.onDataChanged("hoverSize");
            this.onHoverParamsChanged();
        };
        chartClass.prototype.onHoverParamsChanged = function () {
            this.markBuildNeeded("setHoverParams");
        };
        chartClass.prototype.isAnimationEnabled = function (value) {
            if (arguments.length === 0) {
                return this._animationData.isAnimationEnabled;
            }
            this._animationData.isAnimationEnabled = value;
            this.onAnimationDataChanged();
            this.onDataChanged("isAnimationEnabled");
        };
        chartClass.prototype.isStaggeringEnabled = function (value) {
            if (arguments.length === 0) {
                return this._animationData.isStaggeringEnabled;
            }
            this._animationData.isStaggeringEnabled = value;
            this.onAnimationDataChanged();
            this.onDataChanged("isStaggeringEnabled");
        };
        chartClass.prototype.easeFunction = function (value) {
            if (arguments.length == 0) {
                return beachParty.EaseFunction[this._animationData.easeFunction];
            }
            this._animationData.easeFunction = beachParty.EaseFunction[value];
            this.onAnimationDataChanged();
            this.onDataChanged("easeFunction");
        };
        chartClass.prototype.easeType = function (value) {
            if (arguments.length == 0) {
                return beachParty.EaseType[this._animationData.easeType];
            }
            this._animationData.easeType = beachParty.EaseType[value];
            this.onAnimationDataChanged();
            this.onDataChanged("easeType");
        };
        chartClass.prototype.animationDuration = function (value) {
            if (arguments.length === 0) {
                return this._animationData.animationDuration;
            }
            this._animationData.animationDuration = value;
            this.onAnimationDataChanged();
            this.onDataChanged("animationDuration");
        };
        chartClass.prototype.maxStaggerTime = function (value) {
            if (arguments.length === 0) {
                return this._animationData.maxStaggerTime;
            }
            this._animationData.maxStaggerTime = value;
            this.onAnimationDataChanged();
            this.onDataChanged("maxStaggerTime");
        };
        chartClass.prototype.onAnimationDataChanged = function () {
            this.markBuildNeeded("setAnimationData");
        };
        chartClass.prototype.chartFrameOpacity = function (value) {
            if (arguments.length === 0) {
                return this._chartFrameData.opacity;
            }
            this._chartFrameData.opacity = value;
            this.onDataChanged("chartFrameOpacity");
            this.onChartFrameDataChanged();
        };
        chartClass.prototype.chartFrameData = function () {
            return this._chartFrameData;
        };
        chartClass.prototype.blankValueStr = function () {
            return this._app.getBlankValueStr();
        };
        chartClass.prototype.showXGridLines = function (value) {
            if (arguments.length === 0) {
                return this._chartFrameData.xAxis.drawGridLines;
            }
            this._chartFrameData.xAxis.drawGridLines = value;
            this.onDataChanged("showXGridLines");
            this.onChartFrameDataChanged();
            this.logAction(beachParty.Gesture.click, "xGridLines", beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { xGridLines: value });
        };
        chartClass.prototype.showYGridLines = function (value) {
            if (arguments.length === 0) {
                return this._chartFrameData.yAxis.drawGridLines;
            }
            this._chartFrameData.yAxis.drawGridLines = value;
            this.onDataChanged("showYGridLines");
            this.onChartFrameDataChanged();
            this.logAction(beachParty.Gesture.click, "yGridLines", beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { yGridLines: value });
        };
        chartClass.prototype.onChartFrameDataChanged = function () {
            this.markBuildNeeded("chartFrameChanged");
        };
        chartClass.prototype.isContinuousDrawing = function (value) {
            if (arguments.length == 0) {
                return this._isContinuousDrawing;
            }
            this._isContinuousDrawing = value;
            this.markBuildNeeded("setContinuousDrawing");
            this.onDataChanged("isContinuousDrawing");
        };
        chartClass.prototype.isInstancingEnabled = function (value) {
            if (arguments.length == 0) {
                return this._instancingParams.isInstancingEnabled;
            }
            this._instancingParams.isInstancingEnabled = value;
            this.markBuildNeeded("setInstancingParams");
            this.onDataChanged("isInstancingEnabled");
        };
        chartClass.prototype.drawingPrimitive = function (value) {
            if (arguments.length === 0) {
                return beachParty.DrawPrimitive[this._drawingPrimitive];
            }
            var dpValue = beachParty.DrawPrimitive[value];
            if (dpValue != this._drawingPrimitive) {
                this._drawingPrimitive = dpValue;
                this.setActualDrawingPrimitive();
                this.onDataChanged("drawingPrimitive");
            }
        };
        chartClass.prototype.getActualDrawingPrimitive = function () {
            return this._actualDrawingPrimitive;
        };
        chartClass.prototype.sortItemsByColor = function () {
            var colName = this._colorAttr.colName();
            this.logAction(beachParty.Gesture.click, "sortByColor", beachParty.ElementType.button, beachParty.Action.adjust, beachParty.Target.sortParams, true);
            this.sortItemColumn(colName);
            this.isItemSortAscending(true);
        };
        chartClass.prototype.resetMappingsForNewFile = function (isLoadingInsight, defaultCols) {
            var prevSumByColumn = this._sizeAttr.colName();
            var prevYColumn = this._yAttr.colName();
            var prevChartType = this._chartSpecs.getUiChartName();
            //---- reset all attribute mapping ----
            this._xAttr.clearForDataChanged();
            this._yAttr.clearForDataChanged();
            this._zAttr.clearForDataChanged();
            this._auxAttr.clearForDataChanged();
            this._imageAttr.clearForDataChanged();
            this._facetAttr.clearForDataChanged();
            this._lineAttr.clearForDataChanged();
            this._textAttr.clearForDataChanged();
            this._sizeAttr.clearForDataChanged();
            this._shapeAttr.clearForDataChanged();
            this._colorAttr.clearForDataChanged();
            this._tooltipColumns = null;
            //---- reset these too ----
            this._sortItemCol = null;
            this._isItemSortAscending = true;
            this._lastScatterXCol = null;
            this._lastScatterYCol = null;
            if (!isLoadingInsight) {
                //---- reset all sorting (caution: don't sort multiple times here) ----
                this.sortItemColumn(null, false);
                this.isItemSortAscending(true, false);
                //this.xBinSorting(BinSorting.none, true);
                this._xAttr.binSorting("none", true);
                this._yAttr.binSorting("none", true);
                this._imageAttr.binSorting("none", true);
                this._facetAttr.binSorting("none", true);
                //---- ensure sort UI gets updated ----
                this.onSortParmsChanged(false);
                this._xAttr.colName(defaultCols.x);
                this._yAttr.colName(defaultCols.y);
                this._zAttr.colName(defaultCols.z);
                //this._auxAttr.colName(defaultCols.x);
                this._xAttr.setMappingDataFormatting();
                this._yAttr.setMappingDataFormatting();
                this._zAttr.setMappingDataFormatting();
                this._colorAttr.onMappingChanged(true);
                this._xAttr.onMappingChanged();
                this._yAttr.onMappingChanged();
                this._zAttr.onMappingChanged();
                this._auxAttr.onMappingChanged();
                this._imageAttr.onMappingChanged();
                this._sizeAttr.onMappingChanged();
                this._shapeAttr.onMappingChanged();
                this._facetAttr.onMappingChanged();
                this._lineAttr.onMappingChanged();
                this._textAttr.onMappingChanged();
                //this._currentChart.resetFilter();
                this.resetTransform();
            }
            this.onFilteredChanged();
            this.onSelectionChanged();
        };
        chartClass.prototype.setActualDrawingPrimitive = function () {
            //if (false)      // this._chartName == "Line")
            //{
            //    var value = DrawPrimitive.linePairs;
            //}
            //else
            var value = null;
            if (this._drawingPrimitive == beachParty.DrawPrimitive.auto) {
                //---- for now, ignore user-specified drawPrimitive ----
                if (this.is3DChart(this._prevChartType) || this.is3DChart(this._chartSpecs.getChartType())) {
                    value = beachParty.DrawPrimitive.cube;
                }
                else {
                    value = beachParty.DrawPrimitive.quad;
                }
            }
            else {
                value = this._drawingPrimitive;
            }
            if (value != this._actualDrawingPrimitive) {
                this._actualDrawingPrimitive = value;
                this.markBuildNeeded("setDrawingPrimitive");
            }
        };
        chartClass.prototype.is3DChart = function (chartType) {
            return (chartType == beachParty.ChartType.Scatter3D || chartType == beachParty.ChartType.Stacks);
        };
        chartClass.prototype.chartName = function () {
            return this._chartSpecs.getChartName();
        };
        chartClass.prototype.getDataMgr = function () {
            return this._dataMgr;
        };
        chartClass.prototype.getDataFrame = function () {
            var dataFrame = null;
            if (this._dataMgr) {
                dataFrame = this._dataMgr.getDataFrame();
            }
            return dataFrame;
        };
        chartClass.prototype.onSizePackingRelatedChanged = function (triggerLayoutChange, layoutType) {
            var chartName = this._chartSpecs.getChartName();
            var newLayout = beachParty.LayoutType.Default;
            //---- if SIZE BY is set and chart is column/bar, choose the correct layout ----
            if (this.isCountOrSumOrGrid("x", layoutType) || this.isCountOrSumOrGrid("y", layoutType)) {
                if (chartName == "Flat") {
                    newLayout = beachParty.LayoutType.Grid;
                }
                if (this._auxAttr.isSet()) {
                    //layout = this._appSettingsMgr.sizePacking();
                    newLayout = beachParty.LayoutType.Squarify;
                    if (this._auxAttr.sumLayout() == "strip") {
                        newLayout = beachParty.LayoutType.Strips;
                    }
                }
                else {
                    if (this._auxAttr.countLayout() == "percent") {
                        newLayout = beachParty.LayoutType.Percent;
                    }
                }
                this.changeToLayout(newLayout, false);
            }
            return newLayout;
        };
        chartClass.prototype.isChartUsingBins = function (attrName) {
            var chartName = this._chartSpecs.getChartName();
            var usingBins = false;
            if (chartName == "Bar") {
                usingBins = (attrName == "y");
            }
            else if (chartName == "Column") {
                usingBins = (attrName == "x");
            }
            else if (chartName == "Density") {
                usingBins = (attrName == "x" || attrName == "y");
            }
            else if (chartName == "Violin") {
                usingBins = (attrName == "x" || attrName == "y");
            }
            else if (chartName == "Stacks") {
                usingBins = (attrName == "x" || attrName == "y" || attrName == "z");
            }
            return usingBins;
        };
        chartClass.prototype.getSystemViewData = function (snapShotType, getReproData, chartBgColor, callback) {
            return this._chartEng.getSystemViewData(snapShotType, getReproData, chartBgColor, callback);
        };
        /**
         * return the bounds (ClientRect) of the shape associated with the specified primary key.  The returned bounds
         * are relative to the plot bounds.
         * @param primaryKey
         */
        chartClass.prototype.getShapeBounds = function (primaryKey) {
            var rcShape = null;
            var shapeEng = this.getShapeEngine();
            var bb = shapeEng.getShapeBoundingBox(primaryKey);
            if (bb) {
                var bounds = new beachParty.Bounds();
                bounds.x = bb.xMin;
                bounds.y = bb.yMin;
                bounds.width = bb.xMax - bb.xMin;
                bounds.height = bb.yMax - bb.yMin;
                var transform = this.getTransformer();
                var rc = transform.worldBoundsToScreen(bounds);
                //---- round to nearest pixel ----
                rcShape = vp.geom.createRect(Math.round(rc.left), Math.round(rc.top), Math.round(rc.width), Math.round(rc.height));
            }
            return rcShape;
        };
        chartClass.prototype.getColumnValues = function (columnList, primaryKey) {
            var valueList = [];
            if (primaryKey) {
                var record = this._dataMgr.getDataFrame().getRecordByPrimaryKey(primaryKey);
                for (var i = 0; i < columnList.length; i++) {
                    var colName = columnList[i];
                    var value = record[colName];
                    valueList.push(value);
                }
            }
            return valueList;
        };
        chartClass.prototype.getMemoryUse = function (callback) {
            return this._chartEng.getMemoryUse(callback);
        };
        chartClass.prototype.getEngineEvents = function (callback) {
            return this._chartEng.getEngineEvents(callback);
        };
        /**
         * Find the shape within rcArea that is closest to its center.  Return the values of the specified colNames for the
         * data record associated with the located shape.
         * @param rcArea    - ClientRect of area to search, relative to the plot area of the chart.
         * @param colNames  - Names of columns whose values should be returned.
         * @param callback  - the callback function used to return the results when the operation is complete.
         */
        chartClass.prototype.getMostCentralRecord = function (rcArea, colNames, callback) {
            return this._chartEng.getMostCentralRecord(rcArea, colNames, callback);
        };
        chartClass.prototype.getShapeBoundsAndRecord = function (primaryKey, colNames, callback) {
            return this._chartEng.getShapeBoundsAndRecord(primaryKey, colNames, callback);
        };
        chartClass.prototype.getShapeEngine = function () {
            return this._chartBuilder.getShapeEngine();
        };
        chartClass.prototype.buildAttributes = function () {
            var _this = this;
            var defaultBinCount = chartClass.defaultNumericBins;
            var autoBins = chartClass.autoBins;
            var xMapping = new beachParty.MappingData("x", "", autoBins);
            var yMapping = new beachParty.MappingData("y", "", autoBins);
            var zMapping = new beachParty.MappingData("z", "", 3);
            var auxMapping = new beachParty.MappingData("aux", "", autoBins);
            var imageMapping = new beachParty.ImageMappingData();
            var facetMapping = new beachParty.MappingData("facet", "", defaultBinCount);
            var sizeMapping = new beachParty.SizeMappingData(defaultBinCount);
            var shapeMapping = new beachParty.ShapeMappingData(6); // our only palette right now has 6 shapes
            var lineMapping = new beachParty.LineMappingData(defaultBinCount);
            var textMapping = new beachParty.TextMappingData(defaultBinCount);
            var colorMapping = new beachParty.ColorMappingData();
            var attributes = {};
            this._attributes = attributes;
            var dataFrame = this.getDataFrame();
            //---- build our 11 attributes ----
            attributes.x = new beachParty.attrClass(this, xMapping, beachParty.Target.xMapping);
            attributes.y = new beachParty.attrClass(this, yMapping, beachParty.Target.yMapping);
            attributes.z = new beachParty.attrClass(this, zMapping, beachParty.Target.zMapping);
            attributes.aux = new beachParty.auxAttrClass(this, auxMapping, beachParty.Target.auxMapping);
            attributes.color = new beachParty.colorAttrClass(this._app, this, colorMapping, beachParty.Target.colorMapping, defaultBinCount);
            attributes.size = new beachParty.sizeAttrClass(this, sizeMapping, beachParty.Target.sizeMapping);
            attributes.shape = new beachParty.shapeAttrClass(this, shapeMapping, beachParty.Target.shapeMapping);
            attributes.line = new beachParty.lineAttrClass(this, imageMapping, beachParty.Target.lineMapping);
            attributes.text = new beachParty.textAttrClass(this, imageMapping, beachParty.Target.textMapping);
            attributes.facet = new beachParty.attrClass(this, facetMapping, beachParty.Target.facetMapping, defaultBinCount);
            attributes.image = new beachParty.attrClass(this, imageMapping, beachParty.Target.imageMapping);
            this._xAttr = attributes.x;
            this._yAttr = attributes.y;
            this._zAttr = attributes.z;
            this._auxAttr = attributes.aux;
            this._colorAttr = attributes.color;
            this._facetAttr = attributes.facet;
            this._sizeAttr = attributes.size;
            this._shapeAttr = attributes.shape;
            this._imageAttr = attributes.image;
            this._lineAttr = attributes.line;
            this._textAttr = attributes.text;
            //---- hook "colName" changes from each attribute ----
            var keys = vp.utils.keys(attributes);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var attr = attributes[key];
                //---- hook COL NAME changed ----
                attr.onColNameChange.attach(this, function (e) {
                    _this.onAttrColNameChange.trigger(e);
                    var methodName = "on" + beachParty.chartUtils.capitalizeFirstLetter(e.attrName) + "Changed";
                    var method = _this._chartBuilder[methodName];
                    if (method) {
                        _this._chartBuilder[methodName](); // call with this ptr set correctly
                    }
                    _this.markBuildNeeded(methodName);
                });
                //---- hook MAPPING DATA changed ----
                attr.onMappingDataChange.attach(this, function (e) {
                    _this.markBuildNeeded(e.attrName + "MappingDataChanged");
                    //---- signal events to allow UI to update as needed ----
                    //this.onDataChanged(e.attrName + "Mapping");
                });
                //---- hook MAPPING DATA changed ----
                attr.registerForChange("trueBinCount", function (e) {
                    _this.markBuildNeeded(e.attrName + ": trueBinCountChanged");
                    //---- signal events to allow UI to update as needed ----
                    //this.onDataChanged(e.attrName + "Mapping");
                });
            }
            //this._lineMgr = new lineMgrClass(this, lineMapping, Target.lineMapping);
            //this._textMgr = new textMgrClass(this, textMapping, Target.textMapping);
            this._auxAttr.registerForChange("colName", function (e) {
                _this.onSizePackingRelatedChanged(true);
            });
            this._auxAttr.registerForChange("useStripSum", function (e) {
                _this.onSizePackingRelatedChanged(true);
            });
            this._auxAttr.registerForChange("usePercentMode", function (e) {
                _this.onSizePackingRelatedChanged(true);
            });
            this._zAttr.registerForChange("binCount", function (e) {
                _this._vsCurrent.zBinCount = _this._zAttr.binCount();
            });
        };
        chartClass.prototype.resetTransform = function () {
            var transform = this.getTransformer();
            transform.resetMatrices();
            this.markBuildNeeded("resetTransform");
        };
        chartClass.prototype.getUiChartName = function (value) {
            return this._chartSpecs.getUiChartName();
        };
        chartClass.prototype.rootElement = function () {
            return this._root;
        };
        chartClass.prototype.chartUxElement = function () {
            return this._uxElem;
        };
        chartClass.prototype.clientElement = function () {
            return this._clientElem;
        };
        chartClass.prototype.isVisible = function (value, fadeTime) {
            if (fadeTime === void 0) { fadeTime = 0; }
            if (arguments.length == 0) {
                return this._isVisible;
            }
            this._isVisible = value;
            if (value) {
                //vp.select(this._root).css(value ? "" : "none");
                beachParty.chartUtils.fadeIn(this._root, fadeTime);
                this.markBuildNeeded("isVisible");
            }
            else {
                vp.select(this._root).css(value ? "" : "none");
            }
        };
        chartClass.prototype.showAxes = function (value) {
            var opacity = (value) ? "1" : "0";
            this.addStyleSheet(".vpxAxisLabel,.vpxAxisTick,.vpxAxisTickBox {opacity: " + opacity + "}");
        };
        chartClass.prototype.showAxisTickLabels = function (value) {
            var opacity = (value) ? "1" : "0";
            this.addStyleSheet(".vpxAxisLabel {opacity: " + opacity + "}");
        };
        chartClass.prototype.enableTitlePanel = function (value) {
        };
        chartClass.prototype.showTitlePanel = function (value) {
            vp.select(this._root, "#titlePanel").css("display", (value) ? "" : "none");
        };
        chartClass.prototype.showTitleText = function (value) {
            if (arguments.length === 0) {
                return this._showTitleText;
            }
            this._showTitleText = value;
            this.onDataChanged("showTitleText");
            vp.select("#titleText").css("display", (value) ? "" : "none");
            this.logAction(beachParty.Gesture.click, "showTitle", beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.chartTitle, true, { showTitleText: value });
            this.layoutChart();
            //this._app.layoutScreen();
        };
        chartClass.prototype.showItemCounts = function (value) {
            if (arguments.length === 0) {
                return this._showItemCounts;
            }
            this._showItemCounts = value;
            this.onDataChanged("showItemCounts");
            vp.select("#titleItemCounts").css("display", (value) ? "" : "none");
            this.logAction(beachParty.Gesture.click, "showItemCounts", beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.chartTitle, true, { showItemCounts: value });
            this.layoutChart();
            //this._app.layoutScreen();
        };
        chartClass.prototype.xBins = function (value) {
            return this._xAttr.binCount.apply(this._xAttr, arguments);
        };
        chartClass.prototype.yBins = function (value) {
            return this._yAttr.binCount.apply(this._yAttr, arguments);
        };
        chartClass.prototype.zBins = function (value) {
            return this._zAttr.binCount.apply(this._zAttr, arguments);
        };
        chartClass.prototype.buildChartHtml = function (divElem, isVisible) {
            var _this = this;
            //---- ROOT ----
            var rootW = vp.select(divElem)
                .css("padding", "2px")
                .css("display", (isVisible) ? "" : "none");
            //.css("border", "1px solid white")
            this._root = rootW[0];
            this.buildTitleStuff(rootW);
            //---- CLIENT HOLDER ----
            var clientW = rootW.append("div")
                .id("clientHolder")
                .addClass("flexGrow")
                .css("position", "relative")
                .css("height", "80%");
            //---- CHART UX (positioned later to cover plot area within XY axes) ----
            var chartUxW = clientW.append("div")
                .css("position", "absolute")
                .id("chartUx")
                .css("width", "100%")
                .css("height", "100%")
                .css("z-index", "1002")
                .tabIndex("0");
            //.css("border", "1px solid red")
            //.css("background", "red")
            //.css("opacity", ".3")
            //---- FACET LABEL HOLDER ----
            var flhW = clientW.append("div")
                .id("facetLabelHolder")
                .css("position", "absolute")
                .css("pointer-events", "none")
                .css("width", "100%")
                .css("height", "100%")
                .css("z-index", "1002"); // one higher than svg so they can be clicked
            this._clientElem = clientW[0];
            this._uxElem = chartUxW[0];
            this._facetLabelHolderElem = flhW[0];
            this._chartUx = new beachParty.chartUxClass(this._app, this._dataMgr, this, this._maxToolTipColumns);
            this._chartUx.onActionDectected.attach(this, function (e) {
                if (e.action == "percent" && e.subAction) {
                    _this.toPercentOverride(e.subAction.value);
                }
                else if (e.action == null) {
                    _this.toPercentOverride(undefined);
                }
                _this.onActionDectected.trigger(e);
            });
            this._chartUx.onCursorHitTest.attach(this, function (e) {
                _this.cursorHitTestLoc({ x: e.x, y: e.y });
                _this.cursorHitTestShape(e.primaryKey);
            });
        };
        chartClass.prototype.onBoundsChanged = function () {
            this.layoutChart();
            this._chartBuilder.refreshClientSize();
            this.markBuildNeeded("onBoundsChanged");
        };
        //axisLabelStyle(value?: string)
        //{
        //    if (arguments.length == 0)
        //    {
        //        return this._axisLabelStyle;
        //    }
        //    this._axisLabelStyle = value;
        //    //---- send this rule to engine so it can apply it to axis labels ----
        //    var rule = ".vpxAxisLabel { " + value + "}";
        //    this.addStyleSheet(rule);
        //    this.onDataChanged("axisLabelStyle");
        //}
        //axisLabelSize(value?: number)
        //{
        //    if (arguments.length == 0)
        //    {
        //        return this._axisLabelSize;
        //    }
        //    this._axisLabelSize = value;
        //    this.onDataChanged("axisLabelSize");
        //}
        //axisLabelColor(value?: string)
        //{
        //    if (arguments.length == 0)
        //    {
        //        return this._axisLabelColor;
        //    }
        //    this._axisLabelColor = value;
        //    //---- send this rule to engine so it can apply it to axis labels ----
        //    var rule = ".vpxAxisLabel { fill: " + value + "; }";
        //    this.addStyleSheet(rule);
        //    this.onDataChanged("axisLabelColor");
        //}
        chartClass.prototype.tickBoxStyle = function (value) {
            if (arguments.length == 0) {
                return this._tickBoxStyle;
            }
            this._tickBoxStyle = value;
            //---- send this rule to engine so it can apply it to axis labels ----
            var rule = ".vpxAxisTickBox { " + value + "}";
            this.addStyleSheet(rule);
            this.onDataChanged("tickBoxStyle");
        };
        chartClass.prototype.getIFrameElem = function () {
            return this._iframeElem;
        };
        chartClass.prototype.layoutChart = function () {
            ////---- size clientW according to size of ROOT and TITLE PANEL ----
            //var rootW = vp.select(this._root);
            //var chartHeight = rootW.height();
            //var panelW = vp.select(this._root, "#titlePanel");
            //var titleHeight = panelW.height();
            ////---- set height of CLIENT HOLDER ----
            //var height = Math.max(0, chartHeight - titleHeight);
            //vp.select(this._root, "#clientHolder").height(height);
        };
        chartClass.prototype.onPlotMoved = function (rcPlot, rcRotateRing) {
            //---- screen relative ----
            this._rcPlot = rcPlot;
            //---- update chartUx ----
            vp.select(this._uxElem)
                .css("left", rcPlot.left + "px")
                .css("top", rcPlot.top + "px")
                .css("width", rcPlot.width + "px")
                .css("height", rcPlot.height + "px");
            var touchMgr = this._chartUx.getTouchMgr();
            if (touchMgr) {
                touchMgr.setBounds(rcPlot.left, rcPlot.top, rcPlot.width, rcPlot.height);
            }
            //this.layoutChart();
            //vp.utils.debug("---> onPlotMoved");
        };
        chartClass.prototype.getChartSpecs = function () {
            return this._chartSpecs;
        };
        chartClass.prototype.isShowing3DWheel = function (value) {
            if (arguments.length == 0) {
                return this._isTransformMode;
            }
            this._isTransformMode = value;
            //---- reflect in UI ----
            vp.select("#wheelButton")
                .attr("data-selected", value + "");
            this.onDataChanged("isShowing3DWheel");
        };
        chartClass.prototype.getAxisColumnsInCurrentChart = function () {
            var layout = this._chartBuilder.getLayout();
            var axisMask = layout.getVisibleColPickers();
            var columns = [];
            if (axisMask.contains("x")) {
                columns.push(this._xAttr.colName());
            }
            if (axisMask.contains("y")) {
                columns.push(this._yAttr.colName());
            }
            if (axisMask.contains("a")) {
                var colName = this._auxAttr.colName();
                if (colName) {
                    columns.push(colName);
                }
            }
            if (axisMask.contains("z")) {
                columns.push(this._zAttr.colName());
            }
            return columns;
        };
        chartClass.prototype.getMappedColumns = function () {
            //---- X, Y, Z, AUX ----
            var mappedCols = this.getAxisColumnsInCurrentChart();
            var col;
            //---- FACET ----
            if (col = this._facetAttr.colName()) {
                mappedCols.push(col);
            }
            //---- COLOR ----
            var colorMgr = this._colorAttr;
            if (col = colorMgr.colName()) {
                mappedCols.push(col);
            }
            //---- COLOR CHANNELS ----
            if (col = colorMgr.redColumn()) {
                mappedCols.push(col);
            }
            if (col = colorMgr.greenColumn()) {
                mappedCols.push(col);
            }
            if (col = colorMgr.blueColumn()) {
                mappedCols.push(col);
            }
            if (col = colorMgr.rgbColumn()) {
                mappedCols.push(col);
            }
            //---- SIZE ----
            if (col = this._sizeAttr.colName()) {
                mappedCols.push(col);
            }
            //---- SHAPE ----
            if (col = this._shapeAttr.colName()) {
                mappedCols.push(col);
            }
            //---- IMAGE ----
            if (col = this._imageAttr.colName()) {
                mappedCols.push(col);
            }
            //---- TEXT ----
            if (col = this._textAttr.colName()) {
                mappedCols.push(col);
            }
            //---- LINE ----
            if (col = this._lineAttr.colName()) {
                mappedCols.push(col);
            }
            //---- remove any duplicates ----
            mappedCols = mappedCols.distinct();
            return mappedCols;
        };
        chartClass.prototype.isMappedToXYZ = function (colName) {
            var xm = (this._xAttr.colName() == colName);
            var ym = (this._yAttr.colName() == colName);
            var zm = (this._zAttr.colName() == colName);
            return (xm || ym || zm);
        };
        chartClass.prototype.dataZoom = function (rcZoon, zoomOut) {
            // TODO 
        };
        chartClass.prototype.rectSelect = function (rcBand, selectMode) {
            this.hitTestRectWithSelect(rcBand, selectMode);
            this.logAction(beachParty.Gesture.drag, "canvas", beachParty.ElementType.canvas, beachParty.Action.adjust, beachParty.Target.selection, true, { left: rcBand.left, top: rcBand.top, width: rcBand.width, height: rcBand.height });
        };
        chartClass.prototype.hitTestRectWithSelect = function (rcScreen, selectMode) {
            var pointSelect = (rcScreen.width < 3 && rcScreen.height < 3);
            var hp = this._hoverParams;
            var isChartRelative = true;
            var shapeEng = this.getShapeEngine();
            vp.utils.debug("hitTestRectWithSelect: left=" + rcScreen.left + ", top=" + rcScreen.top +
                ", width=" + rcScreen.width + ", height = " + rcScreen.height);
            if (pointSelect && hp.hoverMatch == beachParty.HoverMatch.square) {
                //---- use center of rcScreen, and size of hoverSquare ----
                var sz = hp.squareSize;
                var cx = rcScreen.left + rcScreen.width / 2;
                var cy = rcScreen.top + rcScreen.height / 2;
                rcScreen = vp.geom.createRect(cx - sz / 2, cy - sz / 2, sz, sz);
                var boxes = shapeEng.hitTestFromRect(rcScreen, isChartRelative, true);
            }
            else {
                var boxes = shapeEng.hitTestFromRect(rcScreen, isChartRelative, false);
            }
            this._dataMgr.updateSelectionFromBoxes(boxes, selectMode);
            this.markBuildNeeded("selectionChanged");
        };
        chartClass.prototype.showChartUx = function (value) {
            vp.select(this._uxElem)
                .css("display", value ? "" : "none");
        };
        chartClass.prototype.buildTitleStuff = function (rootW) {
            var _this = this;
            //---- TITLE PANEL ----
            var titlePanelW = rootW.append("div")
                .id("titlePanel")
                .addClass("flexAuto flexRows titlePanel")
                .css("margin", "20px 10px 10px 80px");
            //---- CHART TITLE ----
            var titleTextW = titlePanelW.append("span")
                .id("titleText")
                .addClass("chartTitleText textPanelItem")
                .css("display", "none")
                .title("Open Data panel to select a new dataset")
                .attach("click", function (e) {
                beachParty.chartUtils.callPanelOpen(e, function (e) {
                    _this.onDataChanged("onTitleTextClicked");
                });
            });
            //---- COUNTS HOLDER ----
            var countsHolderW = titlePanelW.append("div")
                .id("titleItemCounts")
                .addClass("flexColumns countsHolder")
                .css("display", "none");
            //---- ITEM COUNT ----
            countsHolderW.append("span")
                .id("titleItemCount")
                .addClass("chartTitleItems");
            //.attach("click", (e) => this.onDataChanged("onTitleItemsClicked"));    
            //---- FILTERED COUNT ----
            countsHolderW.append("span")
                .id("titleFilteredCount")
                .addClass("chartTitleStats textPanelItem")
                .title("Reset the filter")
                .attach("click", function (e) { return _this.onDataChanged("onTitleStatsClicked"); });
            //---- SELECTED COUNT ----
            countsHolderW.append("span")
                .id("titleSelectedCount")
                .addClass("chartTitleStats textPanelItem")
                .title("Reset the selection")
                .attach("click", function (e) { return _this.onDataChanged("onTitleSelectedClicked"); });
        };
        chartClass.prototype.onSelectionChanged = function () {
            this._selectedCount = this._dataMgr.getSelectedCount();
            if (this._selectedCount == 0) {
                //---- some action cleared the selection - clear all of our selectKey stuff ----
                this.clearAxisBoxStuff();
            }
            //---- update our STATS label ----
            var reason = (this._selectedCount == 0) ? null : (this._selectedCount + "");
            var msg = (reason === null) ? "" : reason + " SELECTED";
            vp.select("#titleSelectedCount")
                .text(msg)
                .css("display", (reason) ? "" : "none");
            this.markBuildNeeded("selectionChanged");
            this.onDataChanged("selectedCount");
        };
        chartClass.prototype.onFilteredChanged = function () {
            vp.utils.debug("filteredChanged received from dataMgr");
            var dataMgr = this._dataMgr;
            this._filteredInCount = dataMgr.getFilteredInCount();
            var isFiltered = (this._filteredInCount != this._recordCount);
            this._colInfos = dataMgr.getColInfos(isFiltered);
            this._chartBuilder.onFilteredChanged(isFiltered);
            //---- update our STATS label ----
            var reason = (this._filteredInCount == this._recordCount) ? null : (this._filteredInCount + "");
            var msg = (reason === null) ? "" : reason + " FILTERED";
            vp.select("#titleFilteredCount")
                .text(msg)
                .css("display", (reason) ? "" : "none");
            this.onDataChanged("filteredInCount");
            this.markBuildNeeded("filterChanged");
        };
        chartClass.prototype.addStyleSheet = function (rule) {
            vp.dom.createStyleSheet(rule);
        };
        chartClass.prototype.setCmdId = function (value) {
            this._cmdId = value;
        };
        chartClass.prototype.onLocalStorageChange = function () {
            //---- nothing currently needed for this now that engine runs out of its iframe ----
        };
        /**
         *  Shutdown the chart & release as much memory as possible.
        */
        chartClass.prototype.shutDown = function () {
            var shapeEngine = this._chartBuilder.getShapeEngine();
            shapeEngine.shutDown();
            this._chartUx.shutDownUI();
        };
        chartClass.prototype.getBounds = function () {
            var rc = vp.select(this._root).getBounds();
            return rc;
        };
        chartClass.prototype.getPlotBounds = function () {
            return this._rcPlot;
        };
        chartClass.prototype.titleText = function (value) {
            if (arguments.length === 0) {
                return this._titleText;
            }
            this._titleText = value;
            vp.select("#titleText").text(value);
            var valueLen = (value) ? value.length : 0;
            this.logAction(beachParty.Gesture.editText, "title", beachParty.ElementType.textBox, beachParty.Action.adjust, beachParty.Target.chartTitle, true, { titleLen: valueLen }, false, { value: value });
            this.onDataChanged("titleText");
        };
        chartClass.prototype.selectXTickBox = function (index) {
            this._chartBuilder.getChartFrameHelper().selectXBoxByIndex(index);
        };
        chartClass.prototype.selectYTickBox = function (index) {
            this._chartBuilder.getChartFrameHelper().selectYBoxByIndex(index);
        };
        /**
         * Used to convert chart name and layout from insight file, UI controls, etc. into chartType.
         * @param chartName
         * @param layoutName
         */
        chartClass.getChartTypeFromName = function (chartName, layoutType) {
            var chartType = null;
            chartName = chartName.toLowerCase();
            //layoutType = layoutType.toLowerCase();
            if (chartName == "flat" || (chartName == "grid" && layoutType != null && layoutType != beachParty.LayoutType.Default)) {
                chartName = beachParty.LayoutType[layoutType];
            }
            if (chartName == "scatter-3d" || chartName == "scatter3d" || chartName == "scatter 3d") {
                chartType = beachParty.ChartType.Scatter3D;
            }
            else {
                var capChartName = beachParty.chartUtils.capitalizeFirstLetter(chartName);
                chartType = beachParty.ChartType[capChartName];
                if (chartType === undefined) {
                    chartType = beachParty.ChartType.Column; // fail soft
                }
            }
            return chartType;
        };
        chartClass.prototype.applyInsightToChart = function (insight) {
            var preload = insight.preload;
            //---- sorting stuff ----
            if (preload.sortCol) {
                this._isItemSortAscending = preload.isSortAscending;
                this.sortItemColumn(preload.sortCol);
            }
            //---- load CLIENT VIEW properties ----
            if (preload.chartName != this._chartSpecs.getChartName() || preload.subLayout != this._chartSpecs.getLayoutName()) {
                var layoutType = beachParty.LayoutType[preload.subLayout];
                var chartType = chartClass.getChartTypeFromName(preload.chartName, layoutType);
                this.changeToChart(chartType, layoutType, beachParty.Gesture.system);
            }
            //---- SIZE FACTOR ----
            if (preload.sizeFactor != this._sizeFactor) {
                this.sizeFactor(preload.sizeFactor);
            }
            //---- SEPARATION FACTOR ----
            if (preload.separationFactor != this._separationFactor) {
                this.separationFactor(preload.separationFactor);
            }
            //---- OPACITY ----
            if (preload.shapeOpacity != this._shapeOpacity) {
                this.shapeOpacity(preload.shapeOpacity);
            }
            //---- IMAGE ----
            if (preload.shapeImage != this._shapeImage) {
                this.shapeImage(preload.shapeImage);
            }
            //---- COLOR ----
            if (preload.shapeColor != this._shapeColor) {
                this.shapeColor(preload.shapeColor);
            }
            //---- FLAT PARAMS ----
            if (preload.flatParams) {
                this.buildFromTop(preload.flatParams.buildFromTop);
                this.numColumns(preload.flatParams.numColumns);
            }
            //---- CHART TITLE ----
            this.titleText(insight.name);
            //---- ATTRIBUTE mappings ----
            var icm = preload.colMappings;
            this.setAttrMapping(this._xAttr, this.copyMapping(icm.x));
            this.setAttrMapping(this._yAttr, this.copyMapping(icm.y));
            this.setAttrMapping(this._zAttr, this.copyMapping(icm.z));
            this.setAttrMapping(this._auxAttr, this.copyMapping(icm.aux));
            this.setAttrMapping(this._facetAttr, this.copyMapping(icm.facet));
            this.setAttrMapping(this._colorAttr, this.copyMapping(icm.color));
            this.setAttrMapping(this._sizeAttr, this.copyMapping(icm.size));
            this.setAttrMapping(this._shapeAttr, this.copyMapping(icm.shape));
            this.setAttrMapping(this._imageAttr, this.copyMapping(icm.image));
            this.setAttrMapping(this._lineAttr, this.copyMapping(icm.line));
            this.setAttrMapping(this._textAttr, this.copyMapping(icm.text));
        };
        chartClass.prototype.setAttrMapping = function (attr, md) {
            var colNameChanged = (attr.colName() != md.colName);
            //---- store the mapping data in the attribute ----
            attr.mappingData(md);
            if (colNameChanged) {
                this.onAttrColNameChange.trigger({ sender: this, attrName: md.attrName, colName: md.colName });
            }
        };
        chartClass.prototype.regOptions = function (value) {
            if (arguments.length == 0) {
                return this._regOptions;
            }
            this._regOptions = value;
            this.onDataChanged("regOptions");
        };
        chartClass.prototype.changeToChart = function (newChartType, layoutType, gesture, uiName, isChartCustom) {
            if (gesture === void 0) { gesture = beachParty.Gesture.click; }
            if (!uiName) {
                uiName = beachParty.getUiName(newChartType);
            }
            var oldChartType = this._chartSpecs.getChartType();
            if (newChartType == beachParty.ChartType.Spiral) {
                this.setSpiralSeed(137.508);
            }
            this._prevChartType = oldChartType;
            var cs = new beachParty.ChartSpecs(newChartType, layoutType); // create a new object (that can be compared to previous settings)
            this._chartSpecs = cs;
            this._isChartCustom = isChartCustom;
            this.setActualDrawingPrimitive();
            //---- set SORT ORDER such that transitions between SCATTER and BAR/COLUMN look their best ----
            if (oldChartType == beachParty.ChartType.Scatter) {
                this._lastScatterYCol = this._yAttr.colName();
                this._lastScatterXCol = this._xAttr.colName();
                if (newChartType == beachParty.ChartType.Column) {
                    this.sortIfNeeded(this._lastScatterYCol);
                    this.staggerForward(true);
                }
                else if (newChartType == beachParty.ChartType.Bar) {
                    this.sortIfNeeded(this._lastScatterXCol);
                    this.staggerForward(true);
                }
            }
            else if (newChartType == beachParty.ChartType.Scatter) {
                if (oldChartType == beachParty.ChartType.Column) {
                    this.sortIfNeeded(this._lastScatterYCol);
                    this.staggerForward(false);
                }
                else if (oldChartType == beachParty.ChartType.Bar) {
                    this.sortIfNeeded(this._lastScatterXCol);
                    this.staggerForward(false);
                }
            }
            if (newChartType == beachParty.ChartType.Line) {
                this.sortItemColumn(this._xAttr.colName());
            }
            this.onChartChanged(layoutType);
            this.onDataChanged("chartName");
        };
        chartClass.prototype.isChartCustom = function () {
            return this._isChartCustom;
        };
        chartClass.prototype.copyMapping = function (md) {
            var newMd = vp.utils.copyMap(md, true);
            if (newMd.colName) {
                //---- validate this column with this data (e.g., is ClusterId col missing?) ----
                var dataFrame = this.getDataFrame();
                if (!dataFrame.getColInfo(newMd.colName)) {
                    newMd.colName = null;
                }
            }
            return newMd;
        };
        chartClass.prototype.getChart = function () {
            return this;
        };
        chartClass.prototype.setAppAutoRebuild = function (autoRebuild, rebuildNow, ignoreFilterStage) {
            if (this._autoRebuild != autoRebuild) {
                this._autoRebuild = autoRebuild;
                this.onDataChanged("autoRebuild");
                vp.utils.debug("setAppAutoRebuild: value=" + autoRebuild + ", rebuildNow=" + rebuildNow);
                if (rebuildNow) {
                    this._chartBuilder.markBuildNeeded("buildNow", ignoreFilterStage);
                }
            }
        };
        chartClass.prototype.isAutoRebuild = function () {
            return this._autoRebuild;
        };
        chartClass.prototype.addBeachPartyCss = function () {
            var str = "\n            /*---- beachParty.css ----*/\n            .vpPlotBody, .directDiv { background: none; font-family: Verdana; font-size: 12px;\n                   touch-action: none; stroke-width: 1; \n                   color: #fff; stroke: #fff; fill: #fff; overflow: hidden; }\n\n             /* support for NEWLINE in tooltip strings */\n            .tooltip-inner { white-space: pre-wrap;  }\n            .canvasElem:focus { outline: 0; }\n\n            .transformWheel {stroke-width: 40px; stroke: gray; fill: none; opacity: 1;\n                             transition: opacity .5s ease-in-out;    }\n\n            .transformWheelCircle {opacity: .3; }\n            .transformWheelVBar { opacity: .3; }\n            .transformWheelHBar { opacity: .3; }\n            .groupMenuBg { fill: black; opacity: .7; stroke: none; }\n            .facetBorder { fill: none; stroke: #777; stroke-width: 1px;  }\n\n            .facetLabel { fill: white; stroke-width: 0; cursor: pointer; }\n                .facetLabel:hover { opacity: .7;  }\n                .facetLabel:active { opacity: .5;  }\n\n            .clickableAxisLabel { color: white;  }\n            .clickableAxisLabel:hover { opacity: .8; }\n\n            .toolTipText {max-width: 400px; white-space: pre-wrap; border: 1px solid gray; background: white; color: blue; \n                          padding-left: 2px; padding-right: 2px; cursor: pointer; max-height: 600px; overflow-y: auto; line-height: 14px;}\n            .toolTipTable { }\n            .toolTipName { font-weight: bold; margin-right: 16px; }\n            .toolTipValue { }\n\n            /* VuePlotPlus.css - contains default styles for vuePlot mark-based controls. */\n            /* reminder: z-index is ignored by SVG shapes, text, and images. */\n\n            /* NOTE: stroke-linecap set to value other than \"butt\" causes line to be drawn with a anti-aliased ending */\n\n            .vpxAxis { stroke: #555; fill: #555; font-family: Tahoma; font-size: 13.33px;  text-anchor:  middle; \n                       text-rendering: optimizeLegibility; shape-rendering: crispEdges; stroke-linecap: butt; stroke-width: 1px;\n            }\n\n            .vpxAxisLine { stroke-width: 1px }\n            .vpxGridLines { stroke: #888; shape-rendering: crispEdges; stroke-linecap: butt; stroke-width: 1px; }\n            .vpxAxisBox { stroke-width: 1px; stroke: #555; fill: none }\n            .vpxAxisTick { stroke-width: 1px }\n            .vpxAxisTickBox { fill: none; stroke: #888; padding-left: 6px; padding-right: 6px; cursor: pointer; stroke-width: 1px;  }\n            .vpxAxisTickBox:hover { fill: #555;  stroke: #555; }\n            .vpxAxisTickBox:active { fill: #888;  }\n            .vpxAxisLabel { stroke: none;  cursor: default;  }\n            .vpxAxisName {font-size: 16px; stroke: none; cursor: default }\n            .vpxXGridLine { stroke-width: 1px; }\n            .vpxYGridLine { stroke-width: 1px;  }\n            .vpxMinorXGridLine { stroke-width: 1px; }\n            .vpxMinorYGridLine { stroke-width: 1px; }\n            ";
            var ss = document.createElement("style");
            document.body.appendChild(ss);
            ss.innerHTML = str;
        };
        chartClass.maxCategoryBins = 999;
        chartClass.maxNumericBins = 999;
        chartClass.maxFacetCategoryBins = 255;
        chartClass.maxFacetNumericBins = 255;
        chartClass.defaultOpacity = .8;
        chartClass.defaultNumericBins = 9;
        chartClass.autoBins = 0;
        chartClass.addedBeachPartyCss = false;
        return chartClass;
    }(beachParty.dataChangerClass));
    beachParty.chartClass = chartClass;
    /** chart settings that are saved with each chartType (current session only). */
    var ViewSettings = (function () {
        function ViewSettings(shapeColor, shapeOpacity, separation, shapeName, sizeFactor, zBinCount) {
            if (shapeColor === void 0) { shapeColor = "blue"; }
            if (shapeOpacity === void 0) { shapeOpacity = 1; }
            if (separation === void 0) { separation = .5; }
            if (shapeName === void 0) { shapeName = "none"; }
            if (sizeFactor === void 0) { sizeFactor = .98; }
            if (zBinCount === void 0) { zBinCount = 3; }
            this.shapeColor = shapeColor;
            this.shapeOpacity = shapeOpacity;
            this.separation = separation;
            this.shapeName = shapeName;
            this.sizeFactor = sizeFactor;
            this.zBinCount = zBinCount;
        }
        return ViewSettings;
    }());
    beachParty.ViewSettings = ViewSettings;
})(beachParty || (beachParty = {}));
//---- NOTE: this file should be directly in the project folder (NOT under "scripts") ----
//---- NOTE: this file does NOT need to be referenced by each *.ts file; it will be implicitly referenced by VS/TSC. ----
//---- NOTE: this file does NOT need to include every *.ts file - just the ones whose order needs to be controlled (for references as *.js is loaded) ----
/// <reference path="scripts/vuePlotCore.d.ts" /> 
/// <reference path="scripts/thirdParty/gl-matrix.d.ts" /> 
/// <reference path="scripts/thirdParty/hammer.d.ts" />  
/// <reference path="scripts/beachPartyShape.d.ts" />  
//---- this list of TS files is needed to control the order the files in which the files and processed and loaded ----
/// <reference path="classes/structures.ts" />  
/// <reference path="layouts/baseLayout.ts" />  
/// <reference path="classes/chart.ts" />
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    drawHtml - draws the specified element and all of its children  of an HTML or SVG parent onto the specified canvas.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /**
     * Try the parent element and its children onto the canvas associated with "ctx".
     * @param ctx
     * @param parent
     * @param drawInfo - an object {tx: number, ty: number} - offset info
     * @param omitParentDraw
     */
    function drawHtmlChildren(ctx, parent, drawInfo, omitParentDraw, idToSkip) {
        if (parent && parent.tagName != "svg") {
            var className = parent.getAttribute("class");
            if (className != "numAdjuster" && parent.id != idToSkip) {
                if (!omitParentDraw) {
                    drawHtmlElement(ctx, parent, drawInfo);
                }
                for (var i = 0; i < parent.childElementCount; i++) {
                    var child = parent.children[i];
                    drawHtmlChildren(ctx, child, drawInfo, false, idToSkip);
                }
            }
        }
    }
    beachParty.drawHtmlChildren = drawHtmlChildren;
    function drawLine(ctx, x1, y1, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
    function isSizeSet(str) {
        return (str != null && str != "" && str != "0" && str != "0px");
    }
    function toNum(str) {
        if (str.endsWith("px")) {
            str = str.substr(0, str.length - 2);
        }
        var value = +str;
        return value;
    }
    function drawHtmlElement(ctx, elem, drawInfo) {
        var rc = elem.getBoundingClientRect();
        var style = getComputedStyle(elem);
        ctx.lineWidth = +style.strokeWidth;
        ctx.globalAlpha = +style.opacity;
        //vp.utils.debug("tag: " + elem.tagName);
        if (elem.id == "yButtonHolder") {
            var a = 9;
        }
        if (style.backgroundColor != null && style.backgroundColor != "") {
            //---- bg color ----
            ctx.fillStyle = style.backgroundColor;
            ctx.fillRect(rc.left, rc.top, rc.width, rc.height);
        }
        if (isSizeSet(style.borderLeftWidth)) {
            //---- border LEFT ----
            ctx.strokeStyle = style.borderLeftColor;
            ctx.lineWidth = +style.borderLeftWidth;
            drawLine(ctx, rc.left, rc.top, rc.left, rc.bottom);
        }
        if (isSizeSet(style.borderTopWidth)) {
            //---- border TOP ----
            ctx.strokeStyle = style.borderTopColor;
            ctx.lineWidth = +style.borderTopWidth;
            drawLine(ctx, rc.left, rc.top, rc.right, rc.top);
        }
        if (isSizeSet(style.borderRightWidth)) {
            //---- border RIGHT ----
            ctx.strokeStyle = style.borderRightColor;
            ctx.lineWidth = +style.borderRightWidth;
            drawLine(ctx, rc.right, rc.top, rc.right, rc.bottom);
        }
        if (isSizeSet(style.borderBottomWidth)) {
            //---- border BOTTOM ----
            ctx.strokeStyle = style.borderBottomColor;
            ctx.lineWidth = +style.borderBottomWidth;
            drawLine(ctx, rc.left, rc.bottom, rc.right, rc.bottom);
        }
        ctx.strokeStyle = style.stroke;
        ctx.fillStyle = style.color;
        if (elem.tagName == "IMG" && rc.width > 0 && rc.height > 0) {
            var src = elem.getAttribute("src");
            var imgElm = elem;
            var imgLeft = rc.left + toNum(elem.style.paddingLeft);
            var imgTop = rc.top + toNum(elem.style.paddingTop);
            ctx.drawImage(imgElm, imgLeft, imgTop, imgElm.width, imgElm.height);
        }
        var transform = style.transform;
        var isRotated = (transform.startsWith("matrix"));
        if (elem.textContent && elem.childElementCount == 0) {
            var padLeft = toNum(style.paddingLeft);
            var padTop = toNum(style.paddingTop);
            var padRight = toNum(style.paddingRight);
            var padBot = toNum(style.paddingBottom);
            //---- adjust rc by padding ----
            rc = vp.geom.createRect(rc.left + padLeft, rc.top + padTop, Math.max(0, rc.width - padLeft - padRight), Math.max(0, rc.height - padTop - padBot));
            //vp.utils.debug("  text=" + elem.textContent);
            var left = rc.left;
            var top = rc.top;
            if (style.verticalAlign == "baseline") {
                var topOffset = .70 * ((isRotated) ? rc.width : rc.height);
                top += topOffset;
            }
            var textAlign = style.textAlign;
            ctx.textAlign = "left";
            if (textAlign && textAlign != "left") {
                ctx.textAlign = textAlign;
                if (textAlign == "center") {
                    left += rc.width / 2;
                }
                else if (textAlign == "right") {
                    left = rc.right;
                }
            }
            ctx.font = style.fontSize + " " + style.fontFamily;
            if (isRotated) {
                ctx.save();
                //---- decode transform (this is not currently working) ----
                //var matStr = transform.substr(7, transform.length - 8);
                //var mm = matStr.split(",");
                //for (var i = 0; i < 6; i++)
                //{
                //    mm[i] = mm[i].trim();
                //}
                //ctx.translate(left, top);
                //ctx.setTransform(+mm[0], +mm[1], +mm[2], +mm[3], +mm[4], +mm[5]);
                //---- hardcode: -90 degree rotation ----
                //ctx.setTransform(1, 0, 0, 1, 0, 0);
                var myLeft = (drawInfo) ? (drawInfo.tx + left) : left;
                var myTop = (drawInfo) ? (drawInfo.ty + top) : top;
                //---- fudge factors ----
                myLeft += 5;
                myTop += 25;
                ctx.translate(myLeft, myTop); // - 20);      // -20 is fudge factor
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = "center";
                left = 0;
                top = 0;
                ctx.fillText(elem.textContent, left, top);
                ctx.restore();
            }
            else {
                ctx.fillText(elem.textContent, left, top);
            }
        }
    }
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    drawSvg - draws child elements of an SVG parent onto the specified canvas.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    function drawSvgChildren(ctx, parent, rcCanvas, xOffset, yOffset, flipY) {
        if (xOffset === void 0) { xOffset = 0; }
        if (yOffset === void 0) { yOffset = 0; }
        if (flipY === void 0) { flipY = true; }
        //---- turns out we should always ignore this ----
        flipY = false;
        //---- offset all children by the location of the group ----
        if (parent.tagName == "g") {
            var transform = parent.getAttribute("transform");
            if (transform && transform.startsWith("translate(")) {
                var str = transform.substr(10, transform.length - 11);
                if (str && str != "" && str != "0") {
                    var parts = str.split(" ");
                    var xt = (parts.length > 0) ? +parts[0] : 0;
                    var yt = (parts.length > 1) ? +parts[1] : 0;
                    xOffset += xt;
                    yOffset += yt;
                }
            }
        }
        for (var i = 0; i < parent.childElementCount; i++) {
            var child = parent.childNodes[i];
            var isHidden = false;
            if (child.getAttribute) {
                isHidden = (child.getAttribute("visibility") == "hidden");
            }
            if (!isHidden && child.style) {
                isHidden = (child.style.visibility == "hidden");
            }
            if (!isHidden) {
                drawSvgElement(ctx, child, rcCanvas, xOffset, yOffset, flipY);
                if (child.childElementCount > 0) {
                    if (child.style.opacity != "0") {
                        drawSvgChildren(ctx, child, rcCanvas, xOffset, yOffset, flipY);
                    }
                }
            }
        }
    }
    beachParty.drawSvgChildren = drawSvgChildren;
    function applyTransform(ctx, transform, xOffset, yOffset) {
        var transformed = false;
        if (transform.startsWith("rotate(")) {
            var str = transform.substr(7, transform.length - 8);
            if (str && str != "" && str != "0") {
                var parts = str.split(" ");
                var angle = (parts.length > 0) ? +parts[0] : 0;
                var x = (parts.length > 1) ? +parts[1] : 0;
                var y = (parts.length > 2) ? +parts[2] : 0;
                ctx.save();
                ctx.translate(x + xOffset, y + yOffset);
                ctx.rotate(angle * Math.PI / 180);
                transformed = true;
            }
        }
        return transformed;
    }
    /**
     * Draw the SVG element into ctx, adding xOffset/yOffset to its calculated location.  If flipY, then assume y value of elelment needs to be drawn
     * at its y-flipped location.
     * @param ctx
     * @param elem
     * @param xOffset
     * @param yOffset
     * @param flipY
     */
    function drawSvgElement(ctx, elem, rcCanvas, xOffset, yOffset, flipY) {
        var tagName = elem.tagName;
        var transformed = false;
        if (tagName != "g" && tagName !== undefined) {
            //vp.utils.debug("drawSvgElement: elem.tagName=" + tagName);
            var transform = elem.getAttribute("transform");
            if (transform) {
                yOffset += +elem.getAttribute("dy");
                transformed = applyTransform(ctx, transform, xOffset, yOffset);
            }
            if (elem.getBBox || elem.getBoundingClientRect) {
                var elemW = vp.select(elem);
                //---- get bounds relative to ctx ----
                var rc = elemW.getBounds(false);
                if (rc.width || rc.height) {
                    if (tagName == "text" && elem.textContent) {
                        var style = getComputedStyle(elem);
                        var text = elem.firstChild.textContent; // otherwise we get doubled text
                        var left = 0;
                        var top = 0;
                        if (transformed) {
                            //---- fudge factor for transformation case ----
                            top += 2;
                            left += 6;
                        }
                        else {
                            left = +elem.getAttribute("x") + xOffset;
                            top = +elem.getAttribute("y") + yOffset;
                            top += +elem.getAttribute("dy");
                        }
                        if (flipY) {
                            top = rcCanvas.height - top;
                        }
                        //vp.utils.debug("   text=" + text);
                        var ta = elem.getAttribute("text-anchor");
                        ctx.textAlign = (ta == "middle") ? "center" : (ta ? ta : "start");
                        ctx.font = style.fontSize + " " + style.fontFamily;
                        ctx.fillStyle = style.fill;
                        ctx.strokeStyle = style.stroke;
                        ctx.globalAlpha = +style.opacity;
                        ctx.fillText(text, left, top);
                    }
                    else if (tagName == "line") {
                        var style = getComputedStyle(elem);
                        var x1 = +elem.getAttribute("x1");
                        var x2 = +elem.getAttribute("x2");
                        //----- on lines, the Y values are flipped ----
                        var y1 = +elem.getAttribute("y1");
                        var y2 = +elem.getAttribute("y2");
                        x1 += xOffset;
                        x2 += xOffset;
                        y1 += yOffset;
                        y2 += yOffset;
                        if (flipY) {
                            y1 = rcCanvas.height - y1;
                            y2 = rcCanvas.height - y2;
                        }
                        if (elem.className.baseVal == "vpxAxisLine") {
                            //---- vertical line ----
                            vp.utils.debug("drawSvgElement: line - x1=" + x1 + ", x2=" + x2 + ", y1=" + y1 + ", y2=" + y2);
                        }
                        ctx.fillStyle = style.fill;
                        ctx.strokeStyle = style.stroke;
                        ctx.lineWidth = +style.strokeWidth;
                        ctx.globalAlpha = +style.opacity;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                    else if (tagName == "rect") {
                        var style = getComputedStyle(elem);
                        var x = +elem.getAttribute("x");
                        var y = +elem.getAttribute("y");
                        var width = +elem.getAttribute("width");
                        var height = +elem.getAttribute("height");
                        x += xOffset;
                        y += yOffset;
                        if (flipY) {
                            y = rcCanvas.height - y;
                        }
                        //vp.utils.debug("drawSvgElement: rect - x=" + x + ", y=" + y + ", width=" + width + ", height=" + height);
                        ctx.fillStyle = style.fill;
                        ctx.strokeStyle = style.stroke;
                        ctx.lineWidth = +style.strokeWidth;
                        ctx.globalAlpha = +style.opacity;
                        if (style.fill != "none") {
                            ctx.fillRect(x, y, width, height);
                        }
                        if (style.stroke != "none") {
                            ctx.strokeRect(x, y, width, height);
                        }
                    }
                }
            }
        }
        if (transformed) {
            ctx.restore();
        }
    }
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    boxPlot - the BoxPlot overlay for an X-Band or Y-Band chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var boxPlotClass = (function () {
        function boxPlotClass() {
        }
        boxPlotClass.run = function (data, xCol, yCol, whiskerType) {
            var totalCount = data.length;
            var groups = data.groupBy(xCol);
            var boxData = groups.map(function (group, index) {
                var ydata = group.values.map(function (data, index) { return data[yCol]; });
                var sdata = ydata.orderByNum();
                var median = 0;
                var q1 = 0;
                var q3 = 0;
                var count = sdata.length;
                var index = Math.floor(count / 2);
                if (count > 1) {
                    //---- we are using "method 2" from this Quartile definition: http://en.wikipedia.org/wiki/Quartile ----
                    if (count % 2) {
                        //---- count is ODD - use middle value ----
                        median = sdata[index];
                        var lowIndex = Math.floor(index / 2);
                        q1 = (sdata[lowIndex] + sdata[lowIndex + 1]) / 2;
                        var highIndex = index + lowIndex;
                        q3 = (sdata[highIndex] + sdata[highIndex + 1]) / 2;
                    }
                    else {
                        //---- count is EVEN - must average 2 middle values ----
                        var before = sdata[index - 1];
                        var after = sdata[index];
                        median = (before + after) / 2;
                        var lowIndex = Math.floor(index / 2);
                        q1 = sdata[lowIndex];
                        q3 = sdata[index + lowIndex + 1];
                    }
                }
                else {
                    median = sdata[0];
                    q1 = median;
                    q3 = median;
                }
                var yMin = sdata[0];
                var yMax = sdata[count - 1];
                var iqr = q3 - q1;
                var lowFence, highFence;
                if (whiskerType == WhiskerType.minMax) {
                    //---- minMax ----
                    lowFence = yMin;
                    highFence = yMax;
                }
                else if (whiskerType == WhiskerType.tukey) {
                    //---- tukey ----
                    lowFence = Math.max(yMin, q1 - 1.5 * iqr);
                    highFence = Math.min(yMax, q3 + 1.5 * iqr);
                }
                else if (whiskerType == WhiskerType.percentiles9to91) {
                    //---- percentiles9to91 ----
                    lowFence = this.getPercentile(sdata, 9);
                    highFence = this.getPercentile(sdata, 91);
                }
                else if (whiskerType == WhiskerType.percentile2to98) {
                    //---- percentile2to98 ----
                    lowFence = this.getPercentile(sdata, 2);
                    highFence = this.getPercentile(sdata, 98);
                }
                else {
                    //---- stdDev ----
                    var stdDev = this.getStdDev(sdata);
                    var mean = sdata.sum() / sdata.length;
                    lowFence = mean - stdDev;
                    highFence = mean + stdDev;
                }
                var outliers = [];
                vp.utils.debug("vp.createBoxPlotData: sdata.length=" + sdata.length);
                //---- build list of outliers ----
                for (var s = 0; s < sdata.length; s++) {
                    //if (s % 300 === 0)
                    //{
                    //    vp.utils.debug("vp.createBoxPlotData: in loop with s=" + s);
                    //}
                    var value = sdata[s];
                    if (value < lowFence) {
                        outliers.push(value);
                    }
                    else if (value > highFence) {
                        outliers.push(value);
                    }
                }
                var result = {
                    name: group.values[0][xCol], lower: q1, middle: median, upper: q3, yMin: yMin, yMax: yMax,
                    lowFence: lowFence, highFence: highFence, outliers: outliers
                };
                vp.utils.debug("vp.createBoxPlotData: result.lower=" + result.lower);
                return result;
            });
            return boxData;
        };
        boxPlotClass.getPercentile = function (sdata, percentile) {
            var index = Math.round(percentile / 100 * (sdata.length - 1));
            var value = sdata[index];
            return value;
        };
        boxPlotClass.getStdDev = function (sdata) {
            var mean = sdata.sum() / sdata.length;
            var diffs = sdata.map(function (value, index) {
                var diffSq = (value - mean) * (value - mean);
                return diffSq;
            });
            var meanDiff = diffs.sum() / sdata.length;
            var stdDev = Math.sqrt(meanDiff);
            return stdDev;
        };
        return boxPlotClass;
    }());
    beachParty.boxPlotClass = boxPlotClass;
    (function (WhiskerType) {
        WhiskerType[WhiskerType["minMax"] = 0] = "minMax";
        WhiskerType[WhiskerType["tukey"] = 1] = "tukey";
        WhiskerType[WhiskerType["percentiles9to91"] = 2] = "percentiles9to91";
        WhiskerType[WhiskerType["percentile2to98"] = 3] = "percentile2to98";
        WhiskerType[WhiskerType["stdDev"] = 4] = "stdDev";
    })(beachParty.WhiskerType || (beachParty.WhiskerType = {}));
    var WhiskerType = beachParty.WhiskerType;
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chartEng.ts - helper routines for code that used to be in the separate chart engine library.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var chartEngClass = (function (_super) {
        __extends(chartEngClass, _super);
        function chartEngClass(chart, chartBuilder, dataMgr) {
            _super.call(this);
            this._chart = chart;
            this._chartBuilder = chartBuilder;
            this._dataMgr = dataMgr;
        }
        chartEngClass.prototype.makeMatrix = function (fakeArray) {
            var mat = new Float32Array(16);
            for (var i = 0; i < 16; i++) {
                mat[i] = fakeArray[i];
            }
            return mat;
        };
        chartEngClass.prototype.buildDataFrameLoadedMsgBlock = function (dataMgr) {
            var key = "dataFrameLoaded";
            var returnData = true;
            var fn = dataMgr.getFilename();
            var recordCount = dataMgr.getDataFrame().getRecordCount();
            var colInfos = (returnData) ? dataMgr.getColInfos(true) : null;
            var origColInfos = (returnData) ? dataMgr.getOrigColInfos() : null;
            var preload = (returnData) ? dataMgr.getPreload() : null;
            var msgBlock = {
                msg: key, fn: fn, recordCount: recordCount, colInfos: colInfos,
                origColInfos: origColInfos, preload: preload
            };
            return msgBlock;
        };
        chartEngClass.prototype.loadDataFromServer = function (wdParams, requestId, callback) {
            var _this = this;
            var dataMgr = this._dataMgr;
            if (!wdParams || dataMgr.isFileLoaded(wdParams)) {
                //---- file is already loaded; process the properties sync ----
                if (callback) {
                    callback();
                }
            }
            else {
                //---- load file and then process the properties ----
                dataMgr.openPreloadAsync(wdParams, function (df) {
                    //---- don't draw twice; let client request the only draw in this sequence ----
                    _this._chartBuilder.cancelRequestedDraw();
                    if (callback) {
                        callback();
                    }
                });
            }
        };
        chartEngClass.prototype.setDataAndSystemView = function (data, preload, svd, callback) {
            var _this = this;
            var dataFrameLoadedMsgBlock = null;
            var selectedChangedMsgBlock = null;
            var filterChangedMsgBlock = null;
            var wdParams = preload;
            var dataMgr = this._dataMgr;
            var cmd = "setDataAndSystemView";
            var transformMgr = this._chartBuilder.getTransformMgr();
            if (data) {
                //---- SET DATA (from local cache) ----
                if (!wdParams) {
                    wdParams = new beachParty.WorkingDataParams();
                }
                dataMgr.setDataDirect(data, wdParams);
                //---- build msg block to describe data change ----
                dataFrameLoadedMsgBlock = this.buildDataFrameLoadedMsgBlock(dataMgr);
                var result = this.setDataAndSystemViewPost(svd, dataFrameLoadedMsgBlock, selectedChangedMsgBlock, filterChangedMsgBlock, transformMgr, dataMgr, cmd);
                if (callback) {
                    callback(result);
                }
            }
            else if (wdParams) {
                //---- we will tell client, so supress normal notification mechanism to ----
                //---- prevent duplicate msg (and subsequent mistakes) ----
                wdParams.supressDataFrameLoadedMsgToClient = true;
                //---- LOAD DATA (known or URL) ----
                this.loadDataFromServer(wdParams, null, function (e) {
                    //---- build msg block to describe data change ----
                    dataFrameLoadedMsgBlock = _this.buildDataFrameLoadedMsgBlock(dataMgr);
                    var result = _this.setDataAndSystemViewPost(svd, dataFrameLoadedMsgBlock, selectedChangedMsgBlock, filterChangedMsgBlock, transformMgr, dataMgr, cmd);
                    if (callback) {
                        callback(result);
                    }
                });
            }
            else {
                var result = this.setDataAndSystemViewPost(svd, dataFrameLoadedMsgBlock, selectedChangedMsgBlock, filterChangedMsgBlock, transformMgr, dataMgr, cmd);
                if (callback) {
                    callback(result);
                }
            }
        };
        chartEngClass.prototype.buildSelectionChangedMsgBlock = function (dataMgr) {
            var key = "selectionChanged";
            var options = { returnData: true };
            //---- return the "filtered selection" (only selected records that are in the FILTERED-IN records) ----
            var selectedCount = dataMgr.getSelectedCount(true);
            var recordCount = dataMgr.getDataFrame().getRecordCount();
            var selectedRecords = null;
            if (options.returnData) {
                selectedRecords = dataMgr.getSelectedRecords(true);
            }
            var msgBlock = { msg: key, selectedCount: selectedCount, recordCount: recordCount, selectedRecords: selectedRecords };
            return msgBlock;
        };
        chartEngClass.prototype.setDataAndSystemViewPost = function (svd, dataFrameLoadedMsgBlock, selectedChangedMsgBlock, filterChangedMsgBlock, transformMgr, dataMgr, cmd) {
            if (svd) {
                //---- set SYSTEM VIEW data ----
                var result2 = this.setSystemView(svd);
                if (result2.selectionChanged) {
                    //---- build msg block to describe selection change ----
                    selectedChangedMsgBlock = this.buildSelectionChangedMsgBlock(dataMgr);
                }
                if (result2.filterChanged) {
                    //---- build msg block to describe filter change ----
                    filterChangedMsgBlock = this.buildFilterChangedMsgBlock(dataMgr);
                }
            }
            var multiMsgBlock = {
                msg: cmd, responseId: 0,
                dataFrameLoadedMsgBlock: dataFrameLoadedMsgBlock,
                selectedChangedMsgBlock: selectedChangedMsgBlock,
                filterChangedMsgBlock: filterChangedMsgBlock
            };
            return multiMsgBlock;
        };
        chartEngClass.prototype.buildFilterChangedMsgBlock = function (dataMgr) {
            var key = "filteredChanged";
            var options = { returnData: true };
            var selectedCount = dataMgr.getSelectedCount(true);
            var filteredInCount = dataMgr.getFilteredInCount();
            var recordCount = dataMgr.getDataFrame().getRecordCount();
            var filteredRecords = null;
            var colInfos = dataMgr.getColInfos(true);
            if (options.returnData) {
                filteredRecords = dataMgr.getSelectedRecords();
            }
            var msgBlock = {
                msg: key, colInfos: colInfos, filteredInCount: filteredInCount, recordCount: recordCount, selectedCount: selectedCount,
                filteredRecords: filteredRecords
            };
            return msgBlock;
        };
        chartEngClass.prototype.setSystemView = function (svd, callback) {
            var filterChanged = false;
            var selectionChanged = false;
            var dataMgr = this._dataMgr;
            var transformMgr = this._chartBuilder.getTransformMgr();
            if (svd.filteredOutKeys) {
                filterChanged = dataMgr.setFilter(svd.filteredOutKeys);
            }
            if (svd.selectedKeys) {
                selectionChanged = dataMgr.setSelectionDirect(svd.selectedKeys, "insight");
            }
            if (svd.worldTransform) {
                var matWorld = this.makeMatrix(svd.worldTransform);
                transformMgr.getTransformer().world(matWorld);
            }
            if (svd.rotationInertia) {
                transformMgr.inertia(svd.rotationInertia);
            }
            var result = { selectionChanged: selectionChanged, filterChanged: filterChanged };
            if (callback) {
                callback(result);
            }
            return result;
        };
        chartEngClass.prototype.search = function (colName, value, maxValue, searchType, searchAction, searchRawValues, caseSensitive, selectMode, callback, selectKey) {
            if (searchType === void 0) { searchType = beachParty.TextSearchType.contains; }
            if (searchAction === void 0) { searchAction = beachParty.SearchAction.selectMatches; }
            var sp = new beachParty.SearchParams();
            sp.caseSensitiveSearch = caseSensitive;
            sp.colName = colName;
            sp.maxValue = maxValue;
            sp.minValue = value;
            sp.searchAction = searchAction;
            sp.searchRawValues = searchRawValues;
            sp.searchType = searchType;
            sp.selectMode = selectMode;
            this.searchEx([sp], selectKey, callback);
        };
        chartEngClass.prototype.searchEx = function (spList, selectKey, callback) {
            var sp = spList[0];
            var selectMode = this._chart.processSelectKey(sp.selectMode, selectKey);
            if (selectMode != sp.selectMode) {
                //---- update the selectMode in each sp ----
                for (var i = 0; i < spList.length; i++) {
                    var sp = spList[i];
                    sp.selectMode = selectMode;
                }
            }
            var results = this._dataMgr.runSearchQuery(spList);
            if (sp.searchAction == beachParty.SearchAction.returnMatches) {
                var rcPlot = this._chartBuilder.getPlotBounds(true);
                callback({ sender: this, rcPlot: rcPlot, results: results });
            }
        };
        chartEngClass.prototype.getSystemViewData = function (snapShotType, getReproData, chartBgColor, callback) {
            var svd = new beachParty.SystemViewData();
            var dataMgr = this._dataMgr;
            var transformMgr = this._chartBuilder.getTransformMgr();
            if (dataMgr.getDataFrame().getRecordCount() > 0) {
                var selectVector = dataMgr.getSelectedVector(false);
                svd.selectedKeys = dataMgr.getDataFrame().vectorToPrimaryKeys(selectVector);
                var filterVector = dataMgr.getFilteredVector(false);
                svd.filteredOutKeys = dataMgr.getDataFrame().vectorToPrimaryKeys(filterVector);
            }
            else {
                svd.selectedKeys = [];
                svd.filteredOutKeys = [];
            }
            svd.worldTransform = transformMgr.getTransformer().world();
            svd.rotationInertia = transformMgr.inertia();
            if (getReproData) {
                svd.chartRepro = this._chartBuilder.getChartRepro();
            }
            //---- did client request a copy of the plot image? ----
            if (snapShotType != beachParty.SnapshotType.none) {
                svd.imageAsUrl = this._chart.takeSnapshot(chartBgColor, snapShotType == beachParty.SnapshotType.plot);
            }
            //---- return result IMMEDIATELY back to caller ----
            callback(svd);
        };
        chartEngClass.prototype.getShapeBoundsAndRecord = function (primaryKey, colNames, callback) {
            var colValues = this._chart.getColumnValues(colNames, primaryKey);
            var rcShape = this._chart.getShapeBounds(primaryKey);
            var rcPlot = this._chartBuilder.getPlotBounds(false, true);
            var msgBlock = {
                msg: "recordAndBounds", colValues: colValues, primaryKey: primaryKey,
                rcShape: rcShape, rcPlot: rcPlot
            };
            callback(msgBlock);
        };
        chartEngClass.prototype.getMostCentralRecord = function (rcArea, colNames, callback) {
            var result = this._chartBuilder.getMostCentralRecord(rcArea, colNames);
            callback(result);
        };
        chartEngClass.prototype.applyHover = function (x, y, returnRecord, columnList, showHover, callback) {
            var primaryKey = this._chart.applyHoverCore({ x: x, y: y }, showHover);
            if (returnRecord) {
                var dataFrame = this._dataMgr.getDataFrame();
                var record = dataFrame.getRecordByPrimaryKey(primaryKey, columnList);
            }
            if (callback) {
                callback(primaryKey, record);
            }
        };
        chartEngClass.prototype.autoLoadFile = function (wdp, callback) {
            var dataMgr = this._dataMgr;
            dataMgr.autoloadFile(wdp, function (dataFrame, dataMgr, wdParams) {
                if (callback) {
                    callback(dataFrame, dataMgr, wdParams);
                }
            });
        };
        chartEngClass.prototype.getBinData = function (md, callback) {
            this._dataMgr.requestBinData(md, function (binResult) {
                var msgBlock = { msg: "binData", param: binResult };
                callback(msgBlock);
            });
        };
        chartEngClass.prototype.getMemoryUse = function (callback) {
            //---- TODO ----
            //var memObjs = <any>{};
            ////---- first build a map of major objects in engine ----
            //var chart = view.getChart();
            //memObjs.bufferMgr = (chart) ? chart.getBufferMgr() : null;
            //memObjs.dataMgr = dataMgr;
            //memObjs.dataFrame = dataFrame;
            //memObjs.chart = chart;
            //memObjs.view = view;
            //memObjs.appMgr = this._appMgr;
            //memObjs.cmdMgr = this;
            //memObjs.windowMgr = this._windowMgr;
            //memObjs.traceMgr = traceMgrClass.instance;
            //memObjs.transformer = view.getTransformer();
            //memObjs.transformMgr = view.getTransformMgr();
            //memObjs.shareMgr = dataMgr.getShareMgr();
            //memObjs.chartFrameHelper = (chart) ? chart._chartFrameHelper : null;
            //memObjs.boundingBoxMgr = (chart) ? chart.getBoundingBoxMgr() : null;
            //var memUse = utils.getMemoryUse(memObjs);
            //var requestId = msgBlock.requestId;
            //this._appMgr.postMessageToParent({ msg: "getMemoryUseResponse", responseId: requestId, memUse: memUse });
        };
        chartEngClass.prototype.getEngineEvents = function (callback) {
            var engineEvents = beachParty.traceMgrClass.instance.getCmds();
            callback({ msg: "getEngineEventsResponse", engineEvents: engineEvents });
        };
        return chartEngClass;
    }(beachParty.dataChangerClass));
    beachParty.chartEngClass = chartEngClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    localStorageMgr - manages local storage (data cachine, data preloads, add-in templates)
//-------------------------------------------------------------------------------------
/// SandDance add-in ideas:
///    - (DONE) custom color palettes, replace std color palettes
///    - (DONE) custom themes (canvas color, shape color, shape image)
///    - (DONE) custom tours 
///    - (DONE) custom scripts  (review and automate actions) 
///    - size palettes
///    - shape palettes (and images)
///    - custom images to use with static shape image
///    - custom facet layouts
///    - custom over/under lays (images) for plots (along with bounds information)
///    - custom CSS for app UI
///    - custom CSS for engine
///    - new "known" files (from WEB URL)
///    - custom 3D mesh shape to draw with (new drawing primitive)
///-----------------------------------------------------------------------------------------
///     Keys of items kept in localStorage (as of Feb-21-2016): refer to beachParty.StorageType
///-----------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var localStorageMgr = (function () {
        function localStorageMgr() {
        }
        localStorageMgr.makeKey = function (storageType, subType, fn, tableName) {
            var key = StorageType[storageType];
            if (subType != StorageSubType.none) {
                key += "^" + StorageSubType[subType];
            }
            if (fn) {
                key += "^" + fn;
            }
            if (tableName) {
                key += "^" + tableName;
            }
            return key;
        };
        localStorageMgr.getLastPartOfKey = function (key) {
            var fn = key;
            var index = key.lastIndexOf("^");
            if (index > -1) {
                fn = fn.substr(index + 1);
            }
            return fn;
        };
        localStorageMgr.dumpKeyValue = function (name, key, value) {
            var preview = (value) ? value.substr(0, 20) : "";
            var length = (value) ? value.length : 0;
            //vp.utils.debug(name + ": key: " + key + ", length: " +
            //    length + ", startsWith: " + preview);
        };
        localStorageMgr.save = function (storageType, subType, fn, value, tableName) {
            var key = this.makeKey(storageType, subType, fn, tableName);
            if (localStorage) {
                try {
                    localStorage[key] = value;
                    this.dumpKeyValue("save", key, value);
                }
                catch (ex) {
                    //---- log but ignore errors ----
                    var msg = "localStorageMgr.save: error=" + ex;
                    vp.utils.debug(msg);
                }
            }
            else if (window.external) {
                var host = window.external;
                host.saveToHostStorage(key, value);
            }
        };
        localStorageMgr.rename = function (storageType, subType, oldFn, newFn) {
            var oldKey = this.makeKey(storageType, subType, oldFn, null);
            var newKey = this.makeKey(storageType, subType, newFn, null);
            if (localStorage) {
                var value = localStorage[oldKey];
                localStorage.removeItem(oldKey);
                localStorage[newKey] = value;
            }
            else if (window.external) {
                var host = window.external;
                host.renameHostStorage(oldKey, newKey);
            }
        };
        localStorageMgr.delete = function (storageType, subType, fn, tableName) {
            var key = this.makeKey(storageType, subType, fn, tableName);
            if (localStorage) {
                localStorage.removeItem(key);
                this.dumpKeyValue("delete", key, null);
            }
            else if (window.external) {
                var host = window.external;
                var value = host.deleteFromHostStorage(key);
            }
        };
        localStorageMgr.get = function (storageType, subType, fn, tableName) {
            var key = this.makeKey(storageType, subType, fn, tableName);
            if (localStorage) {
                var value = localStorage[key];
                this.dumpKeyValue("get", key, value);
            }
            else if (window.external) {
                var host = window.external;
                var value = host.getFromHostStorage(key);
            }
            return value;
        };
        localStorageMgr.isPresent = function (storageType, subType, fn, tableName) {
            var key = this.makeKey(storageType, subType, fn, tableName);
            if (localStorage) {
                var value = localStorage[key];
                var isPresent = (value !== undefined);
                this.dumpKeyValue("isPresent", key, value);
            }
            else if (window.external) {
                var host = window.external;
                var isPresent = (host.isPresentInHostStorage(key) == "true");
            }
            return isPresent;
        };
        localStorageMgr.enumerate = function (storageType, subType, onlyLastPart) {
            var foundItems = [];
            var target = this.makeKey(storageType, subType, null, null);
            if (localStorage) {
                for (var i = 0; i < localStorage.length; i++) {
                    var key = localStorage.key(i);
                    if (key.startsWith(target)) {
                        if (onlyLastPart) {
                            key = this.getLastPartOfKey(key);
                        }
                        foundItems.push(key);
                    }
                }
            }
            else if (window.external) {
                var host = window.external;
                var matches = host.enumerateHostStorage(target);
                foundItems = matches.split(",");
                if (onlyLastPart) {
                    for (var i = 0; i < foundItems.length; i++) {
                        foundItems[i] = this.getLastPartOfKey(foundItems[i]);
                    }
                }
            }
            return foundItems;
        };
        localStorageMgr.hookChanges = function (callback) {
            //vp.utils.debug("hookChanges");
            //vp.events.attach(window, "storage", (e) =>
            //{
            //    callback(e);
            //});
        };
        localStorageMgr.clearAll = function () {
            //---- delete localStorage for all of our settings ----
            if (localStorage) {
                //---- if we do this, let it trigger event to engine ----
                localStorage.clear();
            }
            else if (window.external) {
                var host = window.external;
                var value = host.clearHostStorage();
            }
        };
        return localStorageMgr;
    }());
    beachParty.localStorageMgr = localStorageMgr;
    var CacheEntry = (function () {
        function CacheEntry() {
        }
        return CacheEntry;
    }());
    beachParty.CacheEntry = CacheEntry;
    (function (StorageType) {
        StorageType[StorageType["appSettings"] = 0] = "appSettings";
        StorageType[StorageType["currentTheme"] = 1] = "currentTheme";
        StorageType[StorageType["logTokens"] = 2] = "logTokens";
        StorageType[StorageType["dataFile"] = 3] = "dataFile";
        StorageType[StorageType["insights"] = 4] = "insights";
        StorageType[StorageType["locale"] = 5] = "locale";
        StorageType[StorageType["palette"] = 6] = "palette";
        StorageType[StorageType["preload"] = 7] = "preload";
        StorageType[StorageType["script"] = 8] = "script";
        StorageType[StorageType["sessionShare"] = 9] = "sessionShare";
        StorageType[StorageType["theme"] = 10] = "theme";
        StorageType[StorageType["tour"] = 11] = "tour";
    })(beachParty.StorageType || (beachParty.StorageType = {}));
    var StorageType = beachParty.StorageType;
    (function (StorageSubType) {
        StorageSubType[StorageSubType["none"] = 0] = "none";
        //---- sessionShare ----
        StorageSubType[StorageSubType["selectionChange"] = 1] = "selectionChange";
        StorageSubType[StorageSubType["triggerEngineRead"] = 2] = "triggerEngineRead";
        StorageSubType[StorageSubType["lastSessionState"] = 3] = "lastSessionState";
        StorageSubType[StorageSubType["testResults"] = 4] = "testResults";
        //---- logTokens ----
        StorageSubType[StorageSubType["machineId"] = 5] = "machineId";
        StorageSubType[StorageSubType["sessionId"] = 6] = "sessionId";
        StorageSubType[StorageSubType["sessionToken"] = 7] = "sessionToken";
        //---- files ----
        StorageSubType[StorageSubType["local"] = 8] = "local";
        StorageSubType[StorageSubType["web"] = 9] = "web";
        StorageSubType[StorageSubType["sql"] = 10] = "sql";
    })(beachParty.StorageSubType || (beachParty.StorageSubType = {}));
    var StorageSubType = beachParty.StorageSubType;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    searchUtils.ts - some functions to help search calls when clicking on axes or legends.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var searchUtils = (function () {
        function searchUtils() {
        }
        searchUtils.getValueOfBin = function (binResults, index) {
            var value = null;
            var useMax = false;
            //---- the last tick has an index that is one too large ----
            if (index >= binResults.bins.length) {
                index = binResults.bins.length - 1;
                useMax = true;
            }
            var bin = binResults.bins[index];
            if (bin.otherKeys) {
                value = bin.otherKeys;
            }
            else if (bin instanceof beachParty.BinInfoNum) {
                var numBin = bin;
                //---- to support sorted numeric bins, we need to keep both min/max (ascending min values are insufficient) ----
                //value = (useMax) ? numBin.max : numBin.min;
                value = { min: numBin.min, max: numBin.max };
            }
            else {
                value = bin.name;
            }
            //vp.utils.debug("getValueOfBin: index=" + index + ", value=" + value);
            return value;
        };
        searchUtils.buildSearchInfoOnElem = function (element, labelList, record, binResults, index, colName, isCategory, axisName, buttonType, isLast) {
            var isBar = (buttonType == "bar");
            var value = null;
            if (index >= 0) {
                var valueIndex = (buttonType == "bar") ? index - 1 : index;
                if (binResults) {
                    value = this.getValueOfBin(binResults, index);
                }
                else {
                    value = record.breakValue;
                }
            }
            //---- bar[0] is a dummy, so use prev label on Click ----
            if (isBar) {
                index--;
            }
            //---- bar[0] is a dummy, so don't add last label (will be a duplicate) ----
            if (true) {
                labelList.push(value);
            }
            var infoObj = {};
            element._infoObj = infoObj;
            infoObj.labelList = labelList;
            infoObj.labelIndex = index;
            infoObj.colName = colName;
            infoObj.axisName = axisName;
            infoObj.buttonType = buttonType;
            infoObj.isCategory = isCategory;
            infoObj.isLast = isLast;
            infoObj.useCategoryForBins = (binResults) ? binResults.useCategoryForBins : false;
        };
        searchUtils.searchOnTickOrBarClick = function (e, selectMode) {
            var elem = e.target;
            var infoObj = elem._infoObj;
            //---- extract info stuff into element when we built in ----
            var labels = infoObj.labelList;
            var index = infoObj.labelIndex;
            var colName = infoObj.colName;
            var axisName = infoObj.axisName;
            var buttonType = infoObj.buttonType;
            var isCategory = infoObj.isCategory;
            var isLast = infoObj.isLast;
            var useCategoryForBins = infoObj.useCategoryForBins;
            var sp = new beachParty.SearchParamsEx();
            sp.buttonType = buttonType;
            sp.buttonIndex = index;
            sp.axisName = axisName;
            sp.colName = colName;
            sp.caseSensitiveSearch = false;
            sp.searchAction = beachParty.SearchAction.selectMatches;
            sp.selectMode = selectMode;
            var isBar = (buttonType == "bar");
            //---- there are 8 cases to handle (3 variables: isCategory, bin/value, bar/tick) ----
            searchUtils.searchOnBarClick(elem, sp, isLast, labels, index, isCategory, isBar, useCategoryForBins);
            return sp;
        };
        searchUtils.searchOnBarClick = function (elem, sp, isLast, labels, index, isCategory, isBar, useCategoryForBins) {
            if (isCategory) {
                //---- CATEGORY ----
                sp.minValue = labels[index]; // could be string or string[]
                sp.maxValue = null;
                sp.searchType = beachParty.TextSearchType.exactMatch;
            }
            else {
                //---- NUMBER (or date) ----
                var labelCount = labels.length;
                sp.searchType = beachParty.TextSearchType.geqValueAndLessValue2;
                var value = labels[index];
                if (value.min !== undefined) {
                    //---- BIN: use min/max pair from a COLUMN type plt ----
                    var diff = (useCategoryForBins) ? 1 : 2;
                    if (isLast || (!isBar && index >= labels.length - diff)) {
                        index = labels.length - 1;
                        sp.searchType = beachParty.TextSearchType.betweenInclusive;
                        value = labels[index];
                    }
                    sp.minValue = value.min;
                    sp.maxValue = value.max;
                }
                else {
                    //---- BREAK VALUE: use list of break values from SCATTER type plot ----
                    if (isLast || (!isBar && index >= labels.length - 2)) {
                        index = labels.length - 2;
                        sp.searchType = beachParty.TextSearchType.betweenInclusive;
                    }
                    sp.minValue = labels[index];
                    sp.maxValue = labels[index + 1];
                }
            }
        };
        return searchUtils;
    }());
    beachParty.searchUtils = searchUtils;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    shareMgr - manages sharing of selection and other information among multiple BeachParty sessions.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var shareMgrClass = (function (_super) {
        __extends(shareMgrClass, _super);
        //---- events are async, so we cannot set a flag to know if it is us writing to LS ----
        //_isMySetting = false;
        //---- ISSUES DISCOVERED: ----
        // - For IFRAMES, IE needs to use parent window to hook storage event
        // - Each browser (IE, Chrome, Firefox) has their own localstorage - they can NOT talk to each other using LOCALSTORAGE
        // - Some browsers do NOT support "window.onstorage" form of event hooking
        function shareMgrClass(callback) {
            var _this = this;
            _super.call(this);
            this._callback = null;
            this._isSharingEnabled = true;
            this._changeNumber = 1;
            this._callback = callback;
            //---- our unique session id ----
            this._sessionId = Date.now() + "";
            var win = window;
            beachParty.localStorageMgr.hookChanges(function (e) {
                //vp.utils.debug("******* shareMgr.changeFunc: e.key=" + e.key);
                if (_this._isSharingEnabled) {
                    beachParty.addTrace("localStorage", e.key, beachParty.TraceEventType.point);
                    var myKey = beachParty.localStorageMgr.makeKey(beachParty.StorageType.sessionShare, beachParty.StorageSubType.selectionChange, _this._fn, null);
                    if (e.key == myKey) {
                        _this.processStorageChangedRecord(e.newValue);
                    }
                }
            });
        }
        shareMgrClass.prototype.setFilename = function (fn) {
            this._fn = fn;
            //this._itemId = "session-" + fn;
            //vp.utils.debug("shareName set to: " + this._itemId);
            //---- get current selection ----
            this.onLocalStorageChange();
        };
        shareMgrClass.prototype.processStorageChangedRecord = function (sdStr) {
            if (this._isSharingEnabled) {
                var sdx = JSON.parse(sdStr);
                if (sdx && sdx.changedById != this._sessionId) {
                    //---- watch out for illegal times ----
                    var timeDiff = Math.abs(Date.now() - sdx.changeTime);
                    if (timeDiff < 30 * 1000) {
                        //vp.utils.debug("====> onStorageChanged: myId=" + this._sessionId + ", sdx.filename=" + sdx.filename + ", sdx.changedById=" + sdx.changedById +
                        //    ", sdx.changeNumber=" + sdx.changeNumber);
                        this._callback(sdx);
                    }
                }
            }
        };
        /** this simulates a local storage change. */
        shareMgrClass.prototype.onLocalStorageChange = function () {
            if (this._isSharingEnabled) {
                var strJson = beachParty.localStorageMgr.get(beachParty.StorageType.sessionShare, beachParty.StorageSubType.selectionChange, this._fn);
                if (strJson) {
                    this.processStorageChangedRecord(strJson);
                }
            }
        };
        shareMgrClass.prototype.isSharingEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isSharingEnabled;
            }
            this._isSharingEnabled = value;
            this.onDataChanged("isSharingEnabled");
        };
        shareMgrClass.prototype.setSelection = function (selectedPrimaryKeys) {
            if (this._isSharingEnabled) {
                var sd = new ShareStateData(this._sessionId, this._changeNumber++, this._fn, selectedPrimaryKeys);
                var jsonStr = JSON.stringify(sd);
                beachParty.localStorageMgr.save(beachParty.StorageType.sessionShare, beachParty.StorageSubType.selectionChange, this._fn, jsonStr);
                vp.utils.debug("shareMgr.setSelection: fn=" + this._fn);
            }
        };
        return shareMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.shareMgrClass = shareMgrClass;
    var ShareStateData = (function () {
        function ShareStateData(changedById, changeNumber, fn, selectedPrimaryKeys) {
            this.changedById = changedById;
            this.changeNumber = changeNumber;
            this.changeTime = Date.now();
            this.filename = fn;
            this.selectedPrimaryKeys = selectedPrimaryKeys;
        }
        return ShareStateData;
    }());
    beachParty.ShareStateData = ShareStateData;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    traceMgr.ts - manages trace records.  These can be used to log structured information
//      and then plot the resulting records.  Can be used to diagnose complex, temporal issues with the engine.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var traceMgrClass = (function () {
        function traceMgrClass() {
            this._maxCmds = 5000;
            this._nextIndex = 0;
            traceMgrClass.instance = this;
            this._cmds = [];
        }
        traceMgrClass.prototype.addTrace = function (eventName, name, eventType, durationId) {
            if (durationId === void 0) { durationId = ""; }
            //---- since we cannot currently control the shape palette, simplfy the event types ----
            if (eventType == TraceEventType.point) {
                var et = "point";
            }
            else {
                et = "duration";
            }
            var obj = { time: new Date(), eventName: eventName, name: name, eventType: et, durationId: durationId };
            this._cmds[this._nextIndex] = obj;
            this._nextIndex++;
            //---- we keep cmds in a circular list ----
            if (this._nextIndex >= this._maxCmds) {
                this._nextIndex = 0;
            }
        };
        traceMgrClass.prototype.getCmds = function () {
            var cmds = this._cmds;
            var index = this._nextIndex;
            var forwardCmds = cmds.slice(0, index);
            var backwardCmds = cmds.slice(index, cmds.length);
            var allCmds = backwardCmds.concat(forwardCmds);
            return allCmds;
        };
        return traceMgrClass;
    }());
    beachParty.traceMgrClass = traceMgrClass;
    (function (TraceEventType) {
        TraceEventType[TraceEventType["point"] = 0] = "point";
        TraceEventType[TraceEventType["start"] = 1] = "start";
        TraceEventType[TraceEventType["end"] = 2] = "end";
    })(beachParty.TraceEventType || (beachParty.TraceEventType = {}));
    var TraceEventType = beachParty.TraceEventType;
    function addTrace(traceName, reason, eventType, durationId) {
        if (traceMgrClass.instance) {
            traceMgrClass.instance.addTrace(traceName, reason, eventType, durationId);
        }
    }
    beachParty.addTrace = addTrace;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    barSquarify.ts - builds a Column chart (with inner layout = squrify)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var barSquarifyClass = (function (_super) {
        __extends(barSquarifyClass, _super);
        function barSquarifyClass(chart) {
            _super.call(this, chart, "barSum");
            this._maxPosSumAllFacets = 0;
            this._maxNegSumAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._itemBounds = {}; // map from itemIndex to absolute rectangle bounds of each shape
            this._widthFactor = 0; // adjust each item's bottom/height to fit the tallest bin
            this._inverseSizeFactor = 0; // used to reverse effect of shader sizing
            this._yMargin = 0;
            this._yBetween = 0;
            this._xMin = 0;
            this._xMax = 0;
            this._visibleColPickers = "ya";
            this._visibleBinAdjusters = "y";
            this._chartBuilder.isXAxisClickable(false);
        }
        /** Two responsiblities: 1. compute max count for any bin, over all facets.  2. adjust scales as needed for our chart. */
        barSquarifyClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var ym = this._chart.yMapping();
            var maxPosSum = 0;
            var maxNegSum = 0;
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for consistent facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(ym, dc.layoutFilterVector, dc.nvData.y);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var results = beachParty.chartUtils.computeSumForFacet(dc, data, ym, "y", "size");
                    this._facetBinResults.push(results.binResults);
                    maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                    maxNegSum = Math.max(maxNegSum, results.maxNegSum);
                }
            }
            else {
                var results = beachParty.chartUtils.computeSumForFacet(dc, dc.nvData, ym, "y", "size");
                this._facetBinResults.push(results.binResults);
                maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                maxNegSum = Math.max(maxNegSum, results.maxNegSum);
            }
            this._maxPosSumAllFacets = maxPosSum;
            this._maxNegSumAllFacets = maxNegSum;
            vp.utils.debug("computeFacetStats: maxPosSum=" + maxPosSum + ", maxNegSum=" + maxNegSum);
            //---- return the sum of both as the "max item count" ----
            return maxPosSum + maxNegSum;
        };
        /** Responsiblities:
         1. adjust Y scale to reflect maxCount (across all facets).
         2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
        */
        barSquarifyClass.prototype.adjustScales = function (dc) {
            //---- adjust Y scale to reflect BINS ----
            var results = this._facetBinResults; //[0];
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, results);
            //---- adjust X scale to reflect MAX SUM ----
            var oldScale = dc.scales.x;
            //---- use nice numbers for domain min/max ----
            var nn = vp.scales.niceNumbersAlt.calculate(-this._maxNegSumAllFacets, this._maxPosSumAllFacets);
            dc.scales.x = vp.scales.createLinear()
                .rangeMin(oldScale.rangeMin())
                .rangeMax(oldScale.rangeMax())
                .domainMin(nn.min)
                .domainMax(nn.max);
            //---- mark scale as having pre-computed tickCount ----
            var anyScale = dc.scales.x;
            anyScale._tickCount = nn.steps + 1;
        };
        barSquarifyClass.prototype.assignRecordsToBins = function (nv, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var binAssignments = resultY.assignments;
            var itemBounds = {};
            var itemWidths = []; // the width of each item (per its X column value)
            var itemLefts = []; // the left value of each item within its bin 
            var binPosOffsets = []; // next position for an item in positive part of each bin
            var binNegOffsets = []; // next position for an item in negative part of each bin
            //---- process each (sorted) record ----
            for (var vectorIndex = 0; vectorIndex < filter.length; vectorIndex++) {
                if (!filter[vectorIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binAssign = binAssignments[vectorIndex];
                    if (binPosOffsets[binAssign] === undefined) {
                        binPosOffsets[binAssign] = 0;
                        binNegOffsets[binAssign] = 0;
                    }
                    //---- calculate the relative width of this item ----
                    var itemWidth = nv.size.values[vectorIndex];
                    itemWidths[vectorIndex] = itemWidth;
                    if (itemWidth >= 0) {
                        itemLefts[vectorIndex] = binPosOffsets[binAssign];
                        binPosOffsets[binAssign] += itemWidth;
                    }
                    else {
                        binNegOffsets[binAssign] += itemWidth;
                        itemLefts[vectorIndex] = binNegOffsets[binAssign];
                    }
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    itemWidths[vectorIndex] = 0;
                    itemLefts[vectorIndex] = 0;
                }
            }
            this._itemWidths = itemWidths;
            this._itemLefts = itemLefts;
            var facetWidth = dc.width;
            var facetHeight = dc.height;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the yScale labels ----
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            var xMin = dc.scales.x.scale(-this._maxNegSumAllFacets);
            var xMax = dc.scales.x.scale(this._maxPosSumAllFacets);
            var availWidth = xMax - xMin;
            //// prevent size adjustments in shader by setting our scale factor here to reverse shader shading.
            this._widthFactor = availWidth / (this._maxPosSumAllFacets + this._maxNegSumAllFacets);
            //---- create bounds ----
            var binLefts = [];
            var binBottoms = [];
            var bottom = dc.y + this._yMargin;
            var spacing = dc.spacingFactor; //   this.getSpacingFactor(dc);
            //---- layout each bin ----
            for (var i = 0; i < binsY.length; i++) {
                binBottoms[i] = bottom;
                bottom += (this._binHeight + this._yBetween);
                //---- offset all bins by the same amount to enable comparisons ----
                var xOffset = this._widthFactor * this._maxNegSumAllFacets;
                binLefts[i] = dc.x + xOffset;
                var binSizes = binsY[i].rowIndexes.map(function (itemNum) {
                    if (!filter[itemNum]) {
                        var size = nv.aux.values[itemNum];
                    }
                    else {
                        //---- if it is FILTERED OUT, don't include it in the layout ----
                        var size = 0;
                    }
                    //---- relative size of item ----
                    return size;
                });
                //---- layout records within the bin ----
                var binSum = binSizes.sum();
                var binHeightFactor = binSum / this._maxPosSumAllFacets;
                var binHeight = binHeightFactor * this._binHeight;
                var rc = vp.geom.createRect(binLefts[i], binBottoms[i], this._binWidth, binHeight);
                this.layoutBin(rc, binsY[i].rowIndexes, binSizes, itemBounds, spacing);
            }
            //---- not quite right...----
            this._itemBounds = itemBounds;
            this._binLefts = binLefts;
            this._binBottoms = binBottoms;
            this._itemAssignments = binAssignments;
            //---- setting this to "1" allow us to apply the sizeFactor correctly ----
            this._inverseSizeFactor = 1; // 1 / dc.userSizeFactor;            //  dc.combinedSizeFactor;
        };
        barSquarifyClass.prototype.layoutBin = function (rc, itemIndexes, binSizes, itemBounds, spacing) {
            //---- do a squarify layout for the items in this bin ----
            var squarify = new beachParty.squarifyLayoutClass();
            var cellMargin = spacing; // 0.00001;
            var cells = squarify.layout(binSizes, rc, cellMargin);
            //---- update itemBounds with results----
            for (var b = 0; b < cells.length; b++) {
                var rcItem = cells[b].rect;
                var itemIndex = itemIndexes[b];
                itemBounds[itemIndex] = rcItem;
            }
        };
        barSquarifyClass.prototype.preLayoutLoop = function (dc) {
            //var options = <sandDensityOptions>this._chartOptions;
            //var nv = dc.nvData;
            //var binResults = this._facetBinResults;
            //if (binResults && binResults.length)
            //{
            //    var yResult = binResults[dc.facetIndex];
            //    var binCount = yResult.bins.length;
            //    var width = dc.width;
            //    var height = dc.height;
            //    var approxItemHeight = height / binCount;
            //    var yMargin = .1 * approxItemHeight;
            //    var yBetween = .1 * approxItemHeight;
            //    this._yMargin = yMargin;
            //    this._yBetween = yBetween;
            //    //---- compute itemWidth and itemHeight ----
            //    var itemHeight = (height - 2 * yMargin - (binCount - 1) * yBetween) / binCount;
            //    var itemWidth = width;
            //    this._binWidth = itemWidth;
            //    this._binHeight = itemHeight;
            //    this.assignRecordsToBins(nv, yResult, dc);
            //}
            //---- compute usable part of X axis ----
            var xMin = dc.scales.x.scale(this._maxNegSumAllFacets);
            var xMax = dc.scales.x.scale(this._maxPosSumAllFacets);
            this._xMin = xMin;
            this._xMax = xMax;
            if (this._facetBinResults && dc.facetIndex < this._facetBinResults.length) {
                var facetResult = this._facetBinResults[dc.facetIndex];
                var availWidth = xMax - xMin;
                var result = beachParty.chartUtils.computeBarBinSize(facetResult, availWidth, dc.height);
                this._binWidth = result.binWidth;
                this._binHeight = result.binHeight;
                this._yMargin = result.yMargin;
                this._yBetween = result.yBetween;
                this.assignRecordsToBins(dc.nvData, facetResult, dc);
            }
        };
        barSquarifyClass.prototype.layoutDataForRecord = function (itemIndex, dc, dr) {
            var nv = dc.nvData;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[itemIndex]);
            var visibleIndex = 0;
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var binAssign = this._itemAssignments[itemIndex];
            var left = this._binLefts[binAssign];
            var bottom = this._binBottoms[binAssign];
            var widthFactor = this._widthFactor;
            var inverseSizeFactor = this._inverseSizeFactor;
            var trueWidth = Math.abs(widthFactor * this._itemWidths[itemIndex]);
            //---- layout as STACKED rectangles ----
            dr.x = left + (widthFactor * this._itemLefts[itemIndex]);
            dr.y = bottom + this._binHeight / 2; // place at horizontal center of shape
            dr.x += trueWidth / 2; // place at horizontal center of shape
            dr.z = 0;
            dr.width = inverseSizeFactor * trueWidth;
            dr.height = inverseSizeFactor * this._binHeight;
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, itemIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, itemIndex, dc.scales.imageIndex);
        };
        return barSquarifyClass;
    }(beachParty.baseLayoutClass));
    beachParty.barSquarifyClass = barSquarifyClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    fullCustom.ts - does layout based on custom unit shape grammar.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    ///-------------------------------------------------------------------------------------------------------------------------------------
    var fullCustomClass = (function (_super) {
        __extends(fullCustomClass, _super);
        function fullCustomClass(chart) {
            _super.call(this, chart, "fullCustom");
            this._maxShapeSize = 0;
            this._halfSizeSize = 0;
            this._z = 0;
            //---- for now, show everything ----
            this._visibleColPickers = "xyz";
            this._visibleBinAdjusters = "xyz";
        }
        fullCustomClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            //---- this call modifies the PREPASS scales (for use by the chart frame) ----
            this.modifyXYScales(dc);
            return dc.filteredRecordCount;
        };
        fullCustomClass.prototype.modifyXYScales = function (dc, halfShapeSize) {
            //---- add spacing on both sides of X and Y scales to keep shapes within the borders ----
            if (halfShapeSize != undefined) {
                var xExpand = halfShapeSize;
                var yExpand = halfShapeSize;
            }
            else {
                var sp = this._chart.scatterParams();
                var shapeSize = dc.maxShapeSize;
                if (sp) {
                    var xExpand = sp.percentExpandX * shapeSize;
                    var yExpand = sp.percentExpandY * shapeSize;
                }
                else {
                    var xExpand = .5 * shapeSize;
                    var yExpand = .5 * shapeSize;
                }
            }
            //---- note: expandSpace() for scale in specifed in range units (world units, in this case) ----
            dc.scales.x
                .expandSpace(xExpand);
            dc.scales.y
                .expandSpace(yExpand);
            this._halfSizeSize = xExpand;
        };
        fullCustomClass.prototype.preLayoutLoop = function (dc) {
            //---- this call modifies the FINAL scales (for use by our X/Y mapping) ----
            this.modifyXYScales(dc, this._halfSizeSize);
            this._maxShapeSize = dc.maxShapeSize;
            //---- place our 2D place in middle of Z space ----
            this._z = dc.z + dc.depth / 2;
            this.fullLayout(dc);
        };
        fullCustomClass.prototype.binFixedRange = function (bp) {
        };
        fullCustomClass.prototype.binNearBy = function (bp) {
        };
        fullCustomClass.prototype.parseBinType = function (node, binSpec) {
            var _this = this;
            var binStr = binSpec[1];
            if (binStr == "r") {
                node.binFunc = function (bp) { return _this.binFixedRange(bp); };
            }
            else if (binStr == "n") {
                node.binFunc = function (bp) { return _this.binNearBy(bp); };
            }
            else {
                vp.utils.error("Unrecognized binType: " + binSpec);
            }
        };
        fullCustomClass.prototype.parseLayout = function (node, layoutSpec) {
            var _this = this;
            var ls = layoutSpec;
            if (ls.startsWith("m")) {
                //---- MAP layout ----
                var axis = ls.substr(1);
                node.layoutsByAxis[axis] = function (lp) { return _this.layoutMap(lp); };
            }
            else if (ls.startsWith("r")) {
                //---- RANDOM layout ----
                var axis = ls.substr(1);
                node.layoutsByAxis[axis] = function (lp) { return _this.layoutRandom(lp); };
            }
            else if (ls.startsWith("b")) {
                //---- BAR layout ----
                var axis = ls.substr(1);
                node.layoutsByAxis[axis] = function (lp) { return _this.layoutBar(lp); };
            }
            else if (ls.startsWith("g")) {
                //---- BAR layout ----
                var axis = ls.substr(1);
                node.layoutsByAxis[axis] = function (lp) { return _this.layoutGrid(lp); };
            }
            else if (ls.startsWith("s")) {
                //---- BAR layout ----
                var axis = ls.substr(1);
                node.layoutsByAxis[axis] = function (lp) { return _this.layoutSpine(lp); };
            }
            else {
                vp.utils.error("Unrecognized layoutType: " + layoutSpec);
            }
        };
        fullCustomClass.prototype.getAxisBounds = function (axis, bounds) {
            var rangeMin = bounds[axis];
            var rangeMax = rangeMin + bounds[axis + "Range"];
            return { rangeMin: rangeMin, rangeMax: rangeMax };
        };
        fullCustomClass.prototype.makeScale = function (axis, bounds, colData) {
            var dataMin = colData.values.min();
            var dataMax = colData.values.max();
            var result = this.getAxisBounds(axis, bounds);
            var scale = vp.scales.createLinear();
            scale.domain(dataMin, dataMax);
            scale.range(result.rangeMin, result.rangeMax);
            return scale;
        };
        fullCustomClass.prototype.layoutMap = function (lp) {
            var dc = lp.dc;
            var axis = lp.axis;
            var results = lp.results;
            var bounds = lp.bounds;
            var colData = dc.nvData[axis];
            var scale = this.makeScale(axis, bounds, colData);
            for (var i = 0; i < colData.values.length; i++) {
                var result = this.scaleColData(colData, i, scale);
                results[i].bounds[axis] = result;
            }
        };
        fullCustomClass.prototype.layoutRandom = function (lp) {
            var dc = lp.dc;
            var axis = lp.axis;
            var results = lp.results;
            var bounds = lp.bounds;
            var colData = dc.nvData["random" + axis.toUpperCase()];
            var scale = this.makeScale(axis, bounds, colData);
            for (var i = 0; i < colData.values.length; i++) {
                var result = this.scaleColData(colData, i, scale);
                results[i].bounds[axis] = result;
            }
        };
        fullCustomClass.prototype.getMarginValue = function (dc, spec, axis) {
            var factor = spec - Math.floor(spec);
            if (axis == "x") {
                var maxSize = dc.transformer.screenSizeXToWorld(Math.floor(spec));
            }
            else if (axis == "y") {
                var maxSize = dc.transformer.screenSizeYToWorld(Math.floor(spec));
            }
            else {
                var maxSize = dc.transformer.screenSizeZToWorld(Math.floor(spec));
            }
            var value = dc.maxShapeSize * factor;
            value = Math.min(value, maxSize);
            return value;
        };
        fullCustomClass.prototype.layoutBar = function (lp) {
        };
        fullCustomClass.prototype.layoutSpine = function (lp) {
        };
        fullCustomClass.prototype.layoutGrid = function (lp) {
            var dc = lp.dc;
            var axis = lp.axis;
            var results = lp.results;
            var bounds = lp.bounds;
            var result = this.getAxisBounds(axis, bounds);
            var range = result.rangeMax - result.rangeMin;
            var margin = this.getMarginValue(dc, lp.marginSpec, axis);
            var gap = this.getMarginValue(dc, lp.gapSpec, axis);
            var count = dc.filteredRecordCount;
            var shapeStep = (range - (count - 1) * gap + 2 * margin) / count;
            var offset = result.rangeMin + margin + shapeStep / 2;
            var otherAxis = (axis == "x") ? "y" : ((axis == "z") ? "y" : "x");
            var otherAxisValue = bounds[otherAxis] + (bounds[otherAxis + "Range"] / 2);
            var otherAxisRange = bounds[otherAxis + "Range"] - 2 * dc.itemHalf;
            for (var i = 0; i < count; i++) {
                var bounds = results[i].bounds;
                bounds[axis] = offset;
                bounds[axis + "Range"] = shapeStep;
                //---- fill other axis fully ----
                bounds[otherAxis] = otherAxisValue;
                bounds[otherAxis + "Range"] = otherAxisRange;
                offset += (shapeStep + gap);
            }
        };
        fullCustomClass.prototype.parseSpec = function () {
            var root = null;
            var lastNode = null;
            var spec = this._chart.customSpec();
            var levels = spec.split(">");
            for (var i = 0; i < levels.length; i++) {
                var parts = levels[i].split(".");
                var node = new CustomLayoutNode();
                if (i == 0) {
                    root = node;
                }
                for (var p = 0; p < parts.length; p++) {
                    var part = parts[p];
                    if (part.startsWith("#")) {
                        this.parseBinType(node, part);
                    }
                    else {
                        this.parseLayout(node, part);
                    }
                }
                if (lastNode) {
                    lastNode.childLayout = node;
                }
                lastNode = node;
            }
            return root;
        };
        fullCustomClass.prototype.fullLayout = function (dc) {
            var cl = this.parseSpec();
            var data = this._chart.getDataFrame();
            var bounds = new Bounds3d(dc.x, dc.y, dc.z, dc.width, dc.height, dc.depth);
            this.layoutNextLevel(bounds, data, cl, dc);
        };
        fullCustomClass.prototype.layoutNextLevel = function (bounds, data, cl, dc) {
            if (cl.binFunc) {
                data = cl.binFunc(data);
            }
            //--- need to build scales & extra data on demand (can't rely on NV and SCALES) ----
            //---- build results ----
            var results = [];
            var recordCount = data.getRecordCount();
            for (var i = 0; i < recordCount; i++) {
                var result = new FullLayoutResult();
                var dr = new Bounds3d();
                result.bounds = dr;
                //---- defaults bounds ----
                dr.x = 0;
                dr.y = 0;
                dr.z = 0;
                dr.xRange = this._maxShapeSize;
                dr.yRange = dr.xRange;
                dr.zRange = dc.defaultDepth2d;
                result.data = data.getRecordByVectorIndex(i); // this should get the bin results
                results.push(result);
            }
            var keys = vp.utils.keys(cl.layoutsByAxis);
            var lp = new LayoutParams();
            lp.dc = dc;
            lp.results = results;
            lp.bounds = new Bounds3d(dc.x, dc.y, dc.z, dc.width, dc.height, dc.depth);
            //---- layout each axis spec for this level ----
            for (var k = 0; k < keys.length; k++) {
                var axis = keys[k];
                var layoutFunc = cl.layoutsByAxis[axis];
                lp.axis = axis;
                layoutFunc(lp);
            }
            if (false) {
            }
            else {
                this._results = results;
            }
        };
        /** "bufferIndex" in the 0-based indexed into the sorted data buffers. */
        fullCustomClass.prototype.layoutDataForRecord = function (bufferIndex, dc, dr) {
            //---- apply pre-computed bounds to specified record ----
            var rc = this._results[bufferIndex].bounds;
            dr.x = rc.x;
            dr.y = rc.y;
            dr.z = rc.z;
            dr.width = rc.xRange;
            dr.height = rc.yRange;
            dr.depth = rc.zRange;
            //---- apply default settings to color/image ----
            var nv = dc.nvData;
            var scales = dc.scales;
            dr.colorIndex = this.scaleColData(nv.colorIndex, bufferIndex, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, bufferIndex, dc.scales.imageIndex);
        };
        return fullCustomClass;
    }(beachParty.baseLayoutClass));
    beachParty.fullCustomClass = fullCustomClass;
    var Bounds3d = (function () {
        function Bounds3d(x, y, z, width, height, depth) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (width === void 0) { width = 1; }
            if (height === void 0) { height = 1; }
            if (depth === void 0) { depth = .15; }
            this.x = x;
            this.y = y;
            this.z = z;
            this.xRange = width;
            this.yRange = height;
            this.zRange = depth;
        }
        return Bounds3d;
    }());
    beachParty.Bounds3d = Bounds3d;
    var CustomLayoutNode = (function () {
        function CustomLayoutNode() {
            this.layoutsByAxis = {};
        }
        return CustomLayoutNode;
    }());
    beachParty.CustomLayoutNode = CustomLayoutNode;
    var FullLayoutData = (function () {
        function FullLayoutData() {
        }
        return FullLayoutData;
    }());
    beachParty.FullLayoutData = FullLayoutData;
    var FullLayoutResult = (function () {
        function FullLayoutResult() {
        }
        return FullLayoutResult;
    }());
    beachParty.FullLayoutResult = FullLayoutResult;
    var BinParams = (function () {
        function BinParams() {
        }
        return BinParams;
    }());
    beachParty.BinParams = BinParams;
    var LayoutParams = (function () {
        function LayoutParams() {
            this.marginSpec = 20.15;
            this.gapSpec = 2 * this.marginSpec;
        }
        return LayoutParams;
    }());
    beachParty.LayoutParams = LayoutParams;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    slidingWindow.ts - a sliding window sampler for streaming data. 
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** A sliding window sampler for streaming data.  Keeps the samples received in the last windowLength milliseconds. */
    var slidingWindowClass = (function () {
        function slidingWindowClass(windowLength) {
            this._samples = [];
            this._windowLength = windowLength;
        }
        slidingWindowClass.prototype.addSample = function (value, clear) {
            var now = vp.utils.now();
            var ts = new TimeSample(value, now);
            if (clear) {
                this._samples = [];
            }
            this._samples.push(ts);
            this.removeExpiredEntires();
        };
        slidingWindowClass.prototype.removeExpiredEntires = function () {
            var now = vp.utils.now();
            //---- remove all exipired entires ----
            var expired = now - this._windowLength;
            for (var i = this._samples.length - 1; i >= 0; i--) {
                var sample = this._samples[i];
                if (sample.timeStamp <= expired) {
                    this._samples = this._samples.slice(i + 1);
                    break;
                }
            }
        };
        slidingWindowClass.prototype.getSamples = function () {
            this.removeExpiredEntires();
            return this._samples;
        };
        return slidingWindowClass;
    }());
    beachParty.slidingWindowClass = slidingWindowClass;
    var TimeSample = (function () {
        function TimeSample(value, timeStamp) {
            this.value = value;
            this.timeStamp = timeStamp;
        }
        return TimeSample;
    }());
    beachParty.TimeSample = TimeSample;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    baseControl.ts - base class for menus and controls.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var transformWheelClass = (function (_super) {
        __extends(transformWheelClass, _super);
        function transformWheelClass(svgParent, wheelSize) {
            //super("transformerWheel", null);
            _super.call(this);
            this._partTouched = "";
            this._isActive = true;
            this._wheelSize = 0;
            //this._windowMgr = windowMgr;
            this._svgParent = svgParent;
            //---- create GROUP ----
            var groupW = vp.select(svgParent).append("g")
                .addClass("transformWheel");
            this._group = groupW[0];
            this.show(false); // initially hidden
            this.rebuild();
        }
        transformWheelClass.prototype.rebuild = function () {
            var _this = this;
            var wheelSize = this._wheelSize;
            var size2 = Math.max(0, wheelSize / 2 - 30);
            var groupW = vp.select(this._group)
                .clear();
            //---- CIRCLE ----
            var circle = groupW.append("circle")
                .addClass("transformWheelCircle")
                .attr("r", wheelSize / 2);
            this._circle = circle[0];
            circle[0]._partName = "circle";
            //---- VBAR ----
            var vBar = groupW.append("line")
                .addClass("transformWheelVBar")
                .from(0, -size2)
                .to(0, size2);
            this._vBar = vBar[0];
            vBar[0]._partName = "vBar";
            //---- HBAR ----
            var hBar = groupW.append("line")
                .addClass("transformWheelHBar")
                .from(-size2, 0)
                .to(size2, 0);
            this._hBar = hBar[0];
            hBar[0]._partName = "hBar";
            //---- hook events ----
            circle.attach("mousedown", function (e) { return _this.onPartMouseDown(e, "circle"); });
            hBar.attach("mousedown", function (e) { return _this.onPartMouseDown(e, "hBar"); });
            vBar.attach("mousedown", function (e) { return _this.onPartMouseDown(e, "vBar"); });
            //---- support 2nd finger down here, for temp. wheel operation (while first finger holds wheel down) ----
            circle.attach("pointerdown", function (e) { return _this.onPartMouseDown(e, "circle"); });
            hBar.attach("pointerdown", function (e) { return _this.onPartMouseDown(e, "hBar"); });
            vBar.attach("pointerdown", function (e) { return _this.onPartMouseDown(e, "vBar"); });
            circle.attach("mouseup", function (e) { return _this.onPartMouseUp(e, "circle"); });
            hBar.attach("mouseup", function (e) { return _this.onPartMouseUp(e, "hBar"); });
            vBar.attach("mouseup", function (e) { return _this.onPartMouseUp(e, "vBar"); });
            this.setTooltip(true);
        };
        transformWheelClass.prototype.simulateMouseDown = function (e, canvasElem) {
            var pt = vp.events.mousePosition(e);
            //---- turn off pointer-events on canvas, so that SVG can get our hit-test probe ----
            vp.select(canvasElem).css("pointer-events", "none");
            var elem = vp.events.elementFromPoint(pt.x, pt.y);
            vp.select(canvasElem).css("pointer-events", "");
            var partName = elem._partName;
            vp.utils.debug("simulateMouseDown: elem=" + partName);
            this.onPartMouseDown(e, partName);
        };
        transformWheelClass.prototype.wheelSize = function (value) {
            if (arguments.length == 0) {
                return value;
            }
            if (value < 0) {
                vp.utils.error("transformWheel: wheelSize cannot be negative: " + value);
            }
            this._wheelSize = value;
            this.rebuild();
            this.onDataChanged("wheelSize");
        };
        transformWheelClass.prototype.isActive = function (value) {
            if (arguments.length == 0) {
                return this._isActive;
            }
            this._isActive = value;
            this.show(value);
            this.onDataChanged("isActive");
        };
        transformWheelClass.prototype.setTooltip = function (value) {
            vp.select(this._group)
                .title((value) ? "Use the transform wheel to turn, flip, and spin the current chart in 3D space" : "");
        };
        transformWheelClass.prototype.onPartMouseUp = function (e, part) {
            /// TURN THIS OFF - it is too easy to trigger accidently.
            //if (this._partTouched == "middle")
            //{
            //    //---- touching middle resets TRANSFORMS ----
            //    this._windowMgr.resetStuff();
            //}
            this.partTouched("");
            this.setTooltip(true);
        };
        transformWheelClass.prototype.onPartMouseDown = function (e, part) {
            //vp.select("#consoleDiv").text("onParseMouseDown: part=" + part);
            if (this._isActive) {
                if (part == "vBar" || part == "hBar") {
                    var pt = vp.events.mousePosition(e, this._group);
                    if (this.isPtInMiddle(pt, true)) {
                        part = "middle";
                    }
                }
                this.partTouched(part);
                this.setTooltip(false);
            }
        };
        transformWheelClass.prototype.isPtInMiddle = function (pt, isRelativeToGroup) {
            if (!isRelativeToGroup) {
                //var rcx = vp.select(this._group).getBounds(false);
                var rcx = this._group.getBoundingClientRect();
                pt.x -= rcx.left;
                pt.y -= rcx.top;
            }
            var barSize = 40; // matches .transformWheel stroke-width in .css
            var halfBar = barSize / 2;
            var halfSize = this._wheelSize / 2;
            var middleStart = halfSize - halfBar + halfBar; // +halfBar = fudge factor
            var rc = vp.geom.createRect(middleStart, middleStart, barSize, barSize);
            var inMiddle = (vp.geom.rectContainsPoint(rc, pt));
            return inMiddle;
        };
        transformWheelClass.prototype.partTouched = function (value) {
            if (this._isActive) {
                if (value === undefined) {
                    return this._partTouched;
                }
                this._partTouched = value;
                vp.utils.debug("partToched=" + value);
                this.onDataChanged("partTouched");
            }
        };
        transformWheelClass.prototype.show = function (value) {
            vp.utils.debug("transformWheel: show=" + value);
            //var vis = (value) ? "visible" : "hidden";
            //vp.select(this._group)
            //    .css("visibility", vis);
            var opacity = (value) ? 1 : 0;
            vp.select(this._group)
                .css("opacity", opacity + "")
                .css("pointer-events", (value) ? "" : "none");
        };
        return transformWheelClass;
    }(beachParty.dataChangerClass));
    beachParty.transformWheelClass = transformWheelClass;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// binHelper.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - divides data into either numeric or categorical bins.
///----------------------------------------------------------------------------------------------------------------- 
var beachParty;
(function (beachParty) {
    var binHelper = (function () {
        function binHelper() {
        }
        binHelper.createBins = function (nv, colName, numericBinCount, maxCategoryBins, forceCategory, addIndexes, buildAssignments, binSortOptions, formatter, useNiceNumbers, md) {
            var result = null;
            var colData = nv[colName];
            if (md && !forceCategory) {
                forceCategory = md.forceCategory;
            }
            if (colData) {
                var typeName = colData.colType;
                if ((forceCategory) || (typeName == "string")) {
                    var requestCount = numericBinCount; //    Math.max(numericBinCount, maxCategoryBins);
                    //---- BIN the CATEGORY data ----
                    result = beachParty.binHelperCat.createCatBins(nv, colName, requestCount, addIndexes, buildAssignments, binSortOptions, md);
                }
                else {
                    if (typeName == "date") {
                        //---- BIN the DATE data ----
                        result = beachParty.binHelperDate.createDateBins(nv, colName, numericBinCount, addIndexes, buildAssignments, formatter, useNiceNumbers, md, binSortOptions);
                    }
                    else {
                        //---- BIN the NUMERIC data ----
                        result = beachParty.binHelperNum.createNumBins(nv, colName, numericBinCount, addIndexes, buildAssignments, formatter, useNiceNumbers, md, binSortOptions);
                    }
                    if (binSortOptions && binSortOptions.sortDirection != beachParty.BinSorting.none) {
                        this.sortBins(result, binSortOptions, nv);
                    }
                }
            }
            return result;
        };
        binHelper.splitBinsIntoNamedVectors = function (binResult, nv) {
            var bins = binResult.bins;
            var count = bins.length;
            var buckets = [];
            for (var i = 0; i < count; i++) {
                var bin = bins[i];
                var bucket = this.buildBinBucket(bin, nv);
                buckets.push(bucket);
            }
            return buckets;
        };
        /** for facets: split data from nv into groups, as defined by the bin result "bin". */
        binHelper.buildBinBucket = function (bin, nv) {
            var indexes = bin.rowIndexes; // the indexes in this facet bucket
            var keys = vp.utils.keys(nv);
            var bucket = {};
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var fromNV = nv[key]; // this is a NumericVector or an array of "raw" values (mapping to text attribute)
                var toNV = null;
                if (key != "length" && fromNV) {
                    var fromVector = (fromNV.values) ? fromNV.values : fromNV;
                    var toVector = new Float32Array(indexes.length);
                    var colInfo = (fromNV.colInfo) ? fromNV.colInfo : new beachParty.ColInfo("text", null, "string");
                    toNV = new beachParty.NumericVector(toVector, key, colInfo.colType, colInfo);
                    //---- transfer data for this key (named vector) ----
                    for (var i = 0; i < indexes.length; i++) {
                        var index = indexes[i];
                        var value = fromVector[index];
                        toVector[i] = value;
                    }
                    //---- if STRING, we need to recompute TEXT vector properties: rowsByKey and KeysByRow ---- 
                    if (toNV.colType == "string") {
                        beachParty.cbUtils.rebuildStringKeyIndexes(toNV, indexes, fromNV);
                    }
                    bucket[key] = toNV;
                    bucket.length = toVector.length; // fromVector.length;
                }
            }
            return bucket;
        };
        binHelper.sortBins = function (binningResults, binSortOptions, nv) {
            if (((binSortOptions.sortByAggregateType != "count") && (binSortOptions.sortByAggregateType != "sum")) ||
                (binSortOptions.sortDirection == beachParty.BinSorting.none)) {
                throw "One or more of the supplied binSortOptions values is invalid";
            }
            var result = binningResults;
            var preSortBinIDs = [];
            var postSortBinIDs = []; // Used to update result.assignments
            // Populate preSortBinIDs [needed to later populate postSortBinIDs]
            for (var i = 0; i < result.bins.length; i++) {
                var bin = result.bins[i];
                preSortBinIDs[bin.name] = i;
            }
            if (binSortOptions.sortByAggregateType == "count") {
                //---- Sort the bins by COUNT ----
                if (binSortOptions.sortDirection == beachParty.BinSorting.ascending) {
                    result.bins.sort(function (x, y) {
                        if (x.count > y.count) {
                            return (1);
                        }
                        if (x.count < y.count) {
                            return (-1);
                        }
                        return (0);
                    });
                }
                if (binSortOptions.sortDirection == beachParty.BinSorting.descending) {
                    result.bins.sort(function (x, y) {
                        if (x.count > y.count) {
                            return (-1);
                        }
                        if (x.count < y.count) {
                            return (1);
                        }
                        return (0);
                    });
                }
            }
            else if (binSortOptions.sortByAggregateType == "sum") {
                //---- Sort the bins by COUNT ----
                if (binSortOptions.sortDirection == beachParty.BinSorting.ascending) {
                    result.bins.sort(function (x, y) {
                        if (x.sum > y.sum) {
                            return (1);
                        }
                        if (x.sum < y.sum) {
                            return (-1);
                        }
                        return (0);
                    });
                }
                if (binSortOptions.sortDirection == beachParty.BinSorting.descending) {
                    result.bins.sort(function (x, y) {
                        if (x.sum > y.sum) {
                            return (-1);
                        }
                        if (x.sum < y.sum) {
                            return (1);
                        }
                        return (0);
                    });
                }
            }
            // Compute old-to-new bin ID mappings
            for (var i = 0; i < result.bins.length; i++) {
                var bin = result.bins[i];
                var oldBinID = preSortBinIDs[bin.name];
                postSortBinIDs[oldBinID] = i;
            }
            // Update bin assignments to match the new bin sorting
            if (result.assignments) {
                for (var i = 0; i < result.assignments.length; i++) {
                    var oldBinID = result.assignments[i];
                    var newBinID = postSortBinIDs[oldBinID];
                    result.assignments[i] = newBinID;
                }
            }
        };
        return binHelper;
    }());
    beachParty.binHelper = binHelper;
    var binSortOptionsClass = (function () {
        function binSortOptionsClass() {
        }
        return binSortOptionsClass;
    }());
    beachParty.binSortOptionsClass = binSortOptionsClass;
    var BinInfo = (function () {
        function BinInfo(name, isOther, otherKeys) {
            this.name = name;
            this.count = 0;
            this.rowIndexes = [];
            this.isLast = false;
            this.isOther = isOther;
            this.otherKeys = otherKeys;
            this.sum = 0;
            this.isTagBin = false;
        }
        return BinInfo;
    }());
    beachParty.BinInfo = BinInfo;
    var BinInfoNum = (function (_super) {
        __extends(BinInfoNum, _super);
        function BinInfoNum(name, min, max, actualMin, actualMax, density, ncount, ndensity) {
            _super.call(this, name);
            this.min = min;
            this.max = max;
            this.minLabel = null;
            this.maxLabel = null;
            this.actualMin = actualMin;
            this.actualMax = actualMax;
            this.density = density;
            this.ncount = ncount;
            this.ndensity = ndensity;
        }
        return BinInfoNum;
    }(BinInfo));
    beachParty.BinInfoNum = BinInfoNum;
    var BinResult = (function () {
        function BinResult() {
        }
        return BinResult;
    }());
    beachParty.BinResult = BinResult;
    var BinResultNum = (function (_super) {
        __extends(BinResultNum, _super);
        function BinResultNum() {
            _super.apply(this, arguments);
        }
        return BinResultNum;
    }(BinResult));
    beachParty.BinResultNum = BinResultNum;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// binHelperCat.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - divide the data into bins based on the specified categorical column.
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var binHelperCat = (function () {
        function binHelperCat() {
        }
        binHelperCat.createCatBins = function (nv, colName, maxCategoryBins, addIndexes, buildAssignments, binSortOptions, md) {
            var colDataInfo = nv[colName];
            var typeName = colDataInfo.colType;
            //---- we need the true filter, so we use enterExitFilter (vs. layoutFilter) ----
            var filterVector = nv.enterExitFilter;
            var filter = (filterVector) ? filterVector.values : null;
            var isUsingTags = (md && md.tagDelimiter != undefined && md.tagDelimiter != beachParty.TagDelimiter.none);
            var isUsingFacets = (nv.facet && nv.facet.colName);
            var facetKeys = (isUsingFacets) ? md.allFacetsKeys : null;
            var result0 = binHelperCat.getSortedKeyList(isUsingTags, nv, colName, filter, md, binSortOptions, assignments, buildAssignments, colDataInfo, maxCategoryBins, facetKeys);
            var keyList = result0.keyList;
            var otherKey = result0.otherKey;
            var useOtherBin = result0.useOtherBin;
            var otherKeys = result0.otherKeys;
            var sumColData = result0.sumColData;
            var groups = result0.groups;
            var otherMap = result0.otherMap;
            var otherIndex = result0.otherIndex;
            var binCount = keyList.length;
            //vp.utils.debug("--> binHelperCat: colName=" + colName + ", origCol=" +
            //    colDataInfo.colName + ", keyCount=" + binCount);
            var keyIndexes = {};
            var pkVector = nv.primaryKey;
            var bins = [];
            var assignments = [];
            //---- initialize each bin ----
            for (var i = 0; i < binCount; i++) {
                var name = keyList[i];
                var isOther = false;
                if ((i == binCount - 1) && (useOtherBin)) {
                    //name = "Other";
                    isOther = true;
                }
                if (md && md.labels && md.labels.length) {
                    var displayName = md.labels[i];
                }
                else {
                    var displayName = name;
                    if (md.formatting) {
                        var fmtFunc = vp.formatters.createExcelFormatter(md.formatting, "string");
                        displayName = fmtFunc(displayName);
                    }
                }
                bins[i] = new beachParty.BinInfo(displayName, isOther, (isOther) ? otherKeys : null);
                keyIndexes[name] = i;
                if (isUsingTags) {
                    //---- finish the bin now ----
                    var bin = bins[i];
                    bin.isTagBin = true;
                    var binRecords = groups[name];
                    bin.count = binRecords.length;
                    bin.rowIndexes = binRecords;
                    bin.isOther = true;
                    //---- build otherKeys ----
                    otherKeys = [];
                    for (var b = 0; b < binRecords.length; b++) {
                        var ri = binRecords[b];
                        var primaryKey = pkVector.getRawData(ri) + "";
                        otherKeys.push(primaryKey);
                    }
                    bin.otherKeys = otherKeys;
                }
            }
            if (!isUsingTags) {
                var colData = colDataInfo.values;
                var byVector = colData;
                var filter = (nv.layoutFilter) ? nv.layoutFilter.values : null;
                //---- ASSIGN each record to a BIN ----
                for (var i = 0; i < byVector.length; i++) {
                    var binIndex = 0;
                    var bin = bins[binIndex];
                    if (!filter || !filter[i]) {
                        if (colDataInfo.keyInfo) {
                            var key = "" + colDataInfo.keyInfo.keysByRow[i]; // force to a string, so that IndexOf works
                        }
                        else {
                            var key = "" + colData[i];
                        }
                        var binIndex = keyIndexes[key];
                        if (binIndex === undefined) {
                            if (otherMap && otherMap[key]) {
                                binIndex = otherIndex;
                            }
                            else {
                                //---- this key was not in breaks or sortedKeys; what to do? ----
                                binIndex = bins.length - 1; // for now, put it in the last bin
                            }
                        }
                        //var binIndex = (keyIndexes[key] == undefined) ? -1 : <number>keyIndexes[key]; //var binIndex = keys.indexOf(key);
                        if (binIndex >= binCount || binIndex == -1) {
                            //---- put in last (OTHER) bin ----
                            binIndex = binCount - 1;
                        }
                        if (binIndex == -1) {
                            // If the items have been filtered, then keysByRow will not contain an entry for the filtered-out items.
                            // As a result, 'key' will be undefined and indexOf(key) will return -1.  Since there is no bin for this
                            // item, there is nothing left to do. 
                            // See bug #9792.
                            if (byVector[i] == -1) {
                                continue;
                            }
                        }
                        var bin = bins[binIndex];
                        bin.count++; // count # of key values in this bin
                        if (sumColData) {
                            //---- sum data from NUMERIC sum column ----
                            var sumValue = sumColData[i];
                            bin.sum += sumValue;
                        }
                    }
                    //---- we build these lists for both IN and OUT records ----
                    if (addIndexes) {
                        bin.rowIndexes.push(i);
                    }
                    //----  let FILTERED OUT items fall into bin 0 (but they will not be drawn there) ----
                    if (buildAssignments) {
                        assignments.push(binIndex); // binIndex may be -1 (see comment below)
                    }
                }
            }
            var result = new beachParty.BinResult();
            result.bins = bins;
            result.assignments = assignments;
            result.colName = colName;
            result.isTagBinning = isUsingTags;
            return result;
        };
        binHelperCat.getSortedKeyList = function (isUsingTags, nv, colName, filter, md, binSortOptions, assignments, buildAssignments, colDataInfo, maxCategoryBins, keyList) {
            var keysSorted = false; // even if we get sortedKeys from colInfo, that is the "natural order".  user can override.
            if (isUsingTags) {
                keyList = [];
                var groups = this.groupTags(nv, colName, filter, md, binSortOptions, keyList, assignments, buildAssignments);
            }
            else {
                //---- first, just group the records by their keys ----
                var groups = this.groupRecordsByKey(nv, colName, filter, binSortOptions);
            }
            var sumColData = null;
            if (binSortOptions && binSortOptions.sumByColumn) {
                sumColData = nv[binSortOptions.sumByColumn].values;
            }
            if (!keyList) {
                //---- get preferred list of keys ----
                if (md && md.breaks) {
                    keyList = md.breaks.map(function (value) { return value + ""; });
                }
                else {
                    keyList = beachParty.cbUtils.getFilteredSortedKeys(colDataInfo, nv.layoutFilter);
                    if (!keyList) {
                        keyList = vp.utils.keys(groups);
                        keysSorted = false;
                    }
                }
            }
            //---- now sort keys as needed ----
            var sortDir = binSortOptions.sortDirection;
            var sortByKeyNames = (binSortOptions == undefined ||
                (sortDir == beachParty.BinSorting.nameAscending || sortDir == beachParty.BinSorting.nameDescending));
            if (sortByKeyNames) {
                if (!keysSorted) {
                    //---- sort the keys, if not too many ----
                    var sortMax = 50000;
                    if (keyList.length <= sortMax) {
                        keyList.sort();
                        if (sortDir == beachParty.BinSorting.nameDescending) {
                            keyList.reverse();
                        }
                    }
                }
            }
            else {
                keyList = this.sortByContent(keyList, groups, binSortOptions);
            }
            //---- now it is safe to compute the OTHER column (as per keyList sorted keys) ----
            var useOtherBin = (keyList.length > maxCategoryBins);
            if (useOtherBin) {
                var otherKeys = keyList.slice(maxCategoryBins - 1);
                keyList = keyList.slice(0, maxCategoryBins - 1);
                var otherMap = {};
                //--- build otherList ----
                var otherList = [];
                for (var i = 0; i < otherKeys.length; i++) {
                    var otherKey = otherKeys[i];
                    otherMap[otherKey] = true;
                    var list = groups[otherKey];
                    otherList = otherList.concat(list);
                }
                //---- for now, always put the "other" column at the end of the sorted keys ----
                keyList.push("Other");
                var otherIndex = keyList.length - 1;
                groups["Other"] = otherList;
            }
            return {
                keyList: keyList, otherKey: otherKey, useOtherBin: useOtherBin,
                otherKeys: otherKeys, sumColData: sumColData, groups: groups, otherMap: otherMap,
                otherIndex: otherIndex,
            };
        };
        binHelperCat.groupTags = function (nv, colName, filter, md, binSortOptions, keys, assignments, buildAssignments) {
            var groups = {};
            var colDataInfo = nv[colName];
            //---- ASSIGN each record to 0-N tags ----
            var count = colDataInfo.values.length;
            var delimiter = beachParty.TagDelimiters[md.tagDelimiter];
            for (var i = 0; i < count; i++) {
                //---- only include filtered IN records ----
                if (!filter || !filter[i]) {
                    var tagList = colDataInfo.getRawData(i);
                    var tags = tagList.split(delimiter);
                    if (buildAssignments) {
                        assignments[i] = [];
                    }
                    for (var t = 0; t < tags.length; t++) {
                        var tag = tags[t].trim();
                        //---- add record i to group tag ----
                        var tagArray = groups[tag];
                        if (tagArray === undefined) {
                            //---- new tag/key ----
                            keys.push(tag);
                            tagArray = [];
                            tagArray.keyIndex = keys.length;
                            groups[tag] = tagArray;
                        }
                        tagArray.push(i);
                        if (buildAssignments) {
                            assignments[i].push(tagArray.keyIndex);
                        }
                    }
                }
            }
            return groups;
        };
        binHelperCat.groupRecordsByKey = function (nv, colName, filter, binSortOptions) {
            var groups = {};
            var colDataInfo = nv[colName];
            var numVector = colDataInfo.values;
            var typeName = colDataInfo.colType;
            var isString = (typeName == "string");
            var keysByRow = (colDataInfo.keyInfo) ? colDataInfo.keyInfo.keysByRow : null;
            var aggColName = (binSortOptions) ? (binSortOptions.sumByColumn) : null;
            if (aggColName) {
                var aggColDataInfo = nv[aggColName];
                var aggNumVector = aggColDataInfo.values;
                var aggTypeName = aggColDataInfo.colType;
                var aggIsString = (aggTypeName == "string");
                var aggKeysByRow = (aggColDataInfo.keyInfo) ? aggColDataInfo.keyInfo.keysByRow : null;
            }
            //---- ASSIGN each record to a BIN ----
            for (var i = 0; i < numVector.length; i++) {
                //---- only include filtered IN records ----
                if (!filter || !filter[i]) {
                    var groupValue = (isString) ? keysByRow[i] : (numVector[i] + "");
                    if (aggColName) {
                        var aggValue = (aggIsString) ? +aggKeysByRow[i] : aggNumVector[i];
                    }
                    else {
                        aggValue = +groupValue;
                    }
                    var list = groups[groupValue];
                    if (list == undefined) {
                        list = [];
                        groups[groupValue] = list;
                    }
                    list.push(aggValue);
                }
            }
            return groups;
        };
        binHelperCat.sortByContent = function (keyList, groups, binSortOptions) {
            var count = (binSortOptions.sortByAggregateType == "count");
            var sum = (binSortOptions.sortByAggregateType == "sum");
            //---- compute agg value for each list in group, as indexed by keyList ----
            for (var i = 0; i < keyList.length; i++) {
                var key = keyList[i];
                var list = groups[key];
                if (list) {
                    //---- TODO: replace this calculation of "aggValue" with precomputed bin.sum ----
                    var anyList = list;
                    if (count) {
                        anyList.aggValue = list.length;
                    }
                    else if (sum) {
                        anyList.aggValue = list.sum();
                    }
                }
            }
            //---- sort the keyList by "aggValue" ----
            var newKeyList = keyList.slice(0); // copy before sorting (protect original sources)
            if (binSortOptions.sortDirection == beachParty.BinSorting.ascending) {
                newKeyList.sort(function (xx, yy) {
                    var x = groups[xx];
                    var y = groups[yy];
                    if (x.aggValue > y.aggValue) {
                        return (1);
                    }
                    if (x.aggValue < y.aggValue) {
                        return (-1);
                    }
                    return (0);
                });
            }
            else if (binSortOptions.sortDirection == beachParty.BinSorting.descending) {
                newKeyList.sort(function (xx, yy) {
                    var x = groups[xx];
                    var y = groups[yy];
                    if (x.aggValue > y.aggValue) {
                        return (-1);
                    }
                    if (x.aggValue < y.aggValue) {
                        return (1);
                    }
                    return (0);
                });
            }
            return newKeyList;
        };
        return binHelperCat;
    }());
    beachParty.binHelperCat = binHelperCat;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    binHelperDate.ts - divides up DATE data into bins.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var binHelperDate = (function () {
        function binHelperDate() {
        }
        /// returns an array of {min, max, count, density} bin objects for the specified data and binsize.
        binHelperDate.createDateBins = function (nv, colName, binSize, addIndexes, returnBinAssignments, formatter, useNiceNumbers, md, binSortOptions) {
            var bins = [];
            var assignments = [];
            var usingLocalFormatter = false;
            var recommendedDateFormatString = undefined;
            var numColData = nv[colName];
            var colData = numColData.values;
            var colInfo = numColData.colInfo;
            var breaks = null;
            var customBreaks = false;
            if (md && md.breaks && md.breaks.length) {
                breaks = md.breaks;
                customBreaks = true;
            }
            else {
                breaks = binHelperDate.computeDateBreaks(md, colInfo);
            }
            //---- for numeric bins, binCount is 1 less than break count ----
            var binCount = breaks.length - 1;
            var sumColData = null;
            if (binSortOptions && binSortOptions.sumByColumn) {
                sumColData = nv[binSortOptions.sumByColumn].values;
            }
            var filteredData = colData;
            var typeName = numColData.colType;
            var fixedSizedBuckets = true;
            //---- we need the true filter, so we use enterExitFilter (vs. layoutFilter) ----
            var filterVector = nv.enterExitFilter;
            if (filterVector) {
                //---- use "colData" for building assignments, but "filteredData" for bin boundaries ----
                filteredData = [];
                var filterValues = filterVector.values;
                for (var i = 0; i < colData.length; i++) {
                    if (!filterValues[i]) {
                        filteredData.push(colData[i]);
                    }
                }
            }
            if (binCount > 0) {
                if (md.formatting) {
                    formatter = vp.formatters.createExcelFormatter(md.formatting, typeName);
                }
                var colInfo = numColData.colInfo;
                //---- step 1: build empty bins ----
                var dataMin = breaks[0];
                var dataMax = breaks[binCount]; // for num/date, use [binCount]
                var binStart = dataMin;
                var isDescending = (dataMin > dataMax);
                var numDecimals = vp.data.calcNumDecimals(dataMax, dataMin, binCount);
                var firstNumIndex = 0;
                if (!formatter) {
                    usingLocalFormatter = true;
                }
                var firstNumIndex = 0;
                var nanCount = colInfo.stats.nanCount;
                var nanBinIndex = undefined;
                if (nanCount > 0) {
                    var bin = new beachParty.BinInfoNum("", NaN, NaN);
                    bins.push(bin);
                    binCount++;
                    firstNumIndex++;
                    nanBinIndex = 0;
                }
                if (customBreaks) {
                    var bin = new beachParty.BinInfoNum("", minValue, maxValue);
                    if (!formatter) {
                        var result = vp.dateHelper.getDateScaleValues(dataMin, dataMax, 7);
                        recommendedDateFormatString = result.formatString;
                        formatter = vp.formatters.createExcelFormatter(recommendedDateFormatString, "date");
                    }
                }
                else {
                    //---- TODO: figure out best units to use here ----
                    //---- for now, we use HOURS or multiples thereof ----
                    var result = vp.dateHelper.getDateScaleValues(dataMin, dataMax, 7);
                    var steps = result.steps;
                    recommendedDateFormatString = result.formatString;
                    if (!formatter) {
                        formatter = vp.formatters.createExcelFormatter(recommendedDateFormatString, "date");
                    }
                }
                var binSize = undefined;
                //---- BUILD BINS ----
                for (var i = 0; i < breaks.length - 1; i++) {
                    var minValue = breaks[i];
                    var maxValue = breaks[i + 1];
                    var thisSize = maxValue - minValue;
                    if (binSize === undefined) {
                        binSize = thisSize;
                    }
                    else if (thisSize != binSize) {
                        fixedSizedBuckets = false;
                    }
                    if (customBreaks) {
                        var bin = new beachParty.BinInfoNum("", minValue, maxValue);
                    }
                    else {
                        //var bin = new BinInfoNum("", minValue, maxValue);
                        var iNum = (nanCount > 0) ? i - 1 : i;
                        var binStart = dataMin + (iNum * binSize);
                        if (isDescending) {
                            var binEnd = Math.max(dataMax, binStart + binSize);
                        }
                        else {
                            var binEnd = Math.min(dataMax, binStart + binSize);
                        }
                        var bin = new beachParty.BinInfoNum("", binStart, binEnd);
                    }
                    if (addIndexes) {
                        bin.rowIndexes = [];
                    }
                    bins.push(bin);
                }
                if (bin) {
                    bin.isLast = true;
                }
                //---- step 2: fill bins ----
                var firstBinMin = dataMin; //   bins[firstNumIndex].min;
                for (var i = 0; i < colData.length; i++) {
                    //---- filtered-out shapes will go into bin 0 ----
                    var binIndex = 0;
                    var bin = bins[binIndex];
                    if (!filterValues || !filterValues[i]) {
                        var value = colData[i];
                        if (isNaN(value)) {
                            binIndex = nanBinIndex;
                        }
                        else {
                            //---- find "fltIndex" ----
                            if (fixedSizedBuckets && binSize) {
                                var fltIndex = firstNumIndex + (value - firstBinMin) / binSize;
                            }
                            else {
                                for (var j = 0; j < bins.length; j++) {
                                    var bin = bins[j];
                                    if (value < bin.max || j == (bins.length - 1)) {
                                        fltIndex = j;
                                        break;
                                    }
                                }
                            }
                            binIndex = Math.min(Math.floor(fltIndex), binCount - 1);
                            //---- enforce bin min/max settings for edge cases ----
                            if ((binIndex > firstNumIndex) && (value < bins[binIndex].min)) {
                                binIndex--;
                            }
                            else if ((binIndex < bins.length - 1) && (value >= bins[binIndex].max)) {
                                binIndex++;
                            }
                        }
                        //---- update BIN STATS (only for filtered-IN shapes) ----
                        var bin = bins[binIndex];
                        bin.count = bin.count + 1;
                        if (sumColData) {
                            var sumValue = sumColData[i];
                            bin.sum += sumValue;
                        }
                        if (bin.actualMin === undefined || value < bin.actualMin) {
                            bin.actualMin = value;
                        }
                        if (bin.actualMax === undefined || value > bin.actualMax) {
                            bin.actualMax = value;
                        }
                    }
                    //---- we build these lists for both IN and OUT records ----
                    if (addIndexes) {
                        bin.rowIndexes.push(i);
                    }
                    if (returnBinAssignments) {
                        //---- just let FILTERED OUT items fall into bin 0 assignments (but they will not be put there during drawing) ----
                        assignments[i] = binIndex;
                    }
                }
                //---- add "density" field ----   
                var itemCount = filteredData.length;
                beachParty.binHelperNum.computeBinStats(bins, itemCount);
                //---- assign final labels ----
                for (var i = 0; i < bins.length; i++) {
                    var bin = bins[i];
                    if (md && md.labels && md.labels.length) {
                        var minLabel = md.labels[i];
                        var maxLabel = md.labels[i + 1];
                    }
                    else {
                        var minLabel = formatter(bin.min);
                        var maxLabel = formatter(bin.max);
                    }
                    //bin.name = ((i == 0) ? "" : "> ") + minLabel + " ... " + maxLabel;
                    bin.name = minLabel + " ... " + maxLabel;
                    bin.minLabel = minLabel;
                    bin.maxLabel = maxLabel;
                }
            }
            var retValue = new beachParty.BinResultNum();
            retValue.colName = colName;
            retValue.bins = bins;
            retValue.assignments = assignments;
            retValue.dateFormatString = recommendedDateFormatString;
            retValue.isTagBinning = false;
            return retValue;
        };
        /**
         * Common code for finding the axis/bin break values for date columns.
         * @param md
         * @param colInfo
         */
        binHelperDate.computeDateBreaks = function (md, colInfo) {
            //---- this takes priority ----
            var breaks = md.breaks;
            if (!breaks) {
                var binCount = (md.isBinCountSoft) ? undefined : md.binCount;
                var min = +colInfo.stats.min;
                var max = +colInfo.stats.max;
                //---- handle override of min/max ----
                if (md.minBreak !== undefined) {
                    min = md.minBreak;
                }
                else if (md.minBreakFacet !== undefined) {
                    min = md.minBreakFacet;
                }
                if (md.maxBreak !== undefined) {
                    max = md.maxBreak;
                }
                if (md.maxBreakFacet !== undefined) {
                    max = md.maxBreakFacet;
                }
                if (min == max) {
                    max = min + 1; // make 2 values so that we can have at least 1 bin
                }
                //---- does caller allow nicer (round) numbers? ----
                if (md.useNiceNumbers || binCount === undefined) {
                    if (binCount === undefined) {
                        var result = vp.scales.niceNumbersAlt.calculate(min, max, undefined);
                    }
                    else {
                        //---- uses binCount+1 ----
                        var result = vp.scales.niceNumbersAlt.calculate(min, max, binCount + 1);
                    }
                    min = result.min;
                    max = result.max;
                    if (!binCount) {
                        binCount = result.steps;
                    }
                }
                var stepAmt = (max - min) / binCount;
                breaks = vp.data.range(min, max, stepAmt);
                //---- do we need to add a break value for NAN's? ----
                if (colInfo.stats.nanCount) {
                    breaks.insert(0, Number.NaN);
                }
            }
            return breaks;
        };
        return binHelperDate;
    }());
    beachParty.binHelperDate = binHelperDate;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    binHelperNum.ts - divides up numeric data into bins.  Should only pay attention to the
//    data that is IN the current layout filter (! layoutFilter[index] ).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var binHelperNum = (function () {
        function binHelperNum() {
        }
        /// returns an array of {min, max, count, density} bin objects for the specified data and binsize.
        binHelperNum.createNumBins = function (nv, colName, binSize, addIndexes, returnBinAssignments, formatter, useNiceNumbers, md, binSortOptions) {
            var bins = [];
            var assignments = [];
            var usingLocalFormatter = false;
            nv.enterExitFilter;
            var numColData = nv[colName];
            var colData = numColData.values;
            var colInfo = numColData.colInfo;
            var breaks = null;
            var customBreaks = false;
            if (md && md.breaks && md.breaks.length) {
                breaks = md.breaks;
                customBreaks = true;
            }
            else {
                breaks = binHelperNum.computeNumBreaks(md, colInfo, false);
            }
            //---- for numeric bins, binCount is 1 less than break count ----
            var binCount = breaks.length - 1;
            var sumColData = null;
            if (binSortOptions && binSortOptions.sumByColumn) {
                sumColData = nv[binSortOptions.sumByColumn].values;
            }
            var filteredData = colData;
            var typeName = numColData.colType;
            var fixedSizedBuckets = true;
            //---- we should always use nv.layoutFilter for layouts and binning ----
            var filterVector = nv.layoutFilter;
            if (filterVector) {
                //---- use "colData" for building assignments, but "filteredData" for bin boundaries ----
                filteredData = [];
                var filterValues = filterVector.values;
                for (var i = 0; i < colData.length; i++) {
                    if (!filterValues[i]) {
                        filteredData.push(colData[i]);
                    }
                }
            }
            if (binCount > 0) {
                //---- support case where we are binning with numbers, but have a formatting string from Excel ----
                //---- in this case, ignore the Excel format, and do our own local bin formatting ----
                if (formatter && formatter._colType == "number") {
                    //var isAllIntegers = vp.data.isAllIntegers(filteredData);
                    if (true) {
                        //---- remove the "General" formatter and create a smarter local formatter below ----
                        formatter = null;
                    }
                }
                if (md.formatting) {
                    formatter = vp.formatters.createExcelFormatter(md.formatting, typeName);
                }
                //---- step 1: build empty bins ----
                var dataMin = breaks[0];
                var dataMax = breaks[binCount]; // for num/date, use [binCount]
                var binStart = dataMin;
                var isDescending = (dataMin > dataMax);
                var numDecimals = vp.data.calcNumDecimals(dataMax, dataMin, binCount);
                if (!formatter) {
                    formatter = vp.formatters.createCommaFormatter(numDecimals);
                    usingLocalFormatter = true;
                }
                var binSize = undefined;
                //---- don't rely on stats while filter may be changing (it may be ahead of our view of the data) ----
                //var nanCount = colInfo.stats.nanCount;
                var nanCount = filteredData.count(isNaN);
                var firstNumIndex = 0;
                var nanBinIndex = undefined;
                vp.utils.debug("binHelperNum: colData.length=" + colData.length + ", filteredData.length=" + filteredData.length + ", nanCount=" + nanCount);
                if (nanCount > 0) {
                    var bin = new beachParty.BinInfoNum("", NaN, NaN);
                    bins.push(bin);
                    binCount++;
                    firstNumIndex++;
                    nanBinIndex = 0;
                }
                //---- BUILD BINS ----
                for (var i = 0; i < breaks.length - 1; i++) {
                    var minValue = breaks[i];
                    var maxValue = breaks[i + 1];
                    var thisSize = maxValue - minValue;
                    if (binSize === undefined) {
                        binSize = thisSize;
                    }
                    else if (thisSize != binSize) {
                        fixedSizedBuckets = false;
                    }
                    if (customBreaks) {
                        var bin = new beachParty.BinInfoNum("", minValue, maxValue);
                    }
                    else {
                        var iNum = (nanCount > 0) ? i - 1 : i;
                        var binStart = dataMin + (iNum * binSize);
                        if (isDescending) {
                            var binEnd = Math.max(dataMax, binStart + binSize);
                        }
                        else {
                            var binEnd = Math.min(dataMax, binStart + binSize);
                        }
                        var bin = new beachParty.BinInfoNum("", binStart, binEnd);
                    }
                    if (addIndexes) {
                        bin.rowIndexes = [];
                    }
                    bins.push(bin);
                }
                if (bin) {
                    bin.isLast = true;
                }
                // Make sure that the maximum value is always included as the last bin boundary [because
                // of the inherent float imprecision issues that arise from the way binStart is computed
                // (see the comment below regarding the "BEFORE bin case")]
                bins[binCount - 1].max = isDescending ? dataMin : dataMax;
                //---- step 2: fill bins ----
                var firstBinMin = dataMin; //   bins[firstNumIndex].min;
                //---- NOTE: we use "colData" here (rather than "filteredData") so that we get "binAssignments" for the full set of records ----
                for (var i = 0; i < colData.length; i++) {
                    //---- filtered-out shapes will go into bin 0 ----
                    var binIndex = 0;
                    var bin = bins[binIndex];
                    if (!filterValues || !filterValues[i]) {
                        var value = colData[i];
                        if (isNaN(value)) {
                            binIndex = nanBinIndex;
                        }
                        else {
                            //---- find "fltIndex" ----
                            if (fixedSizedBuckets && binSize) {
                                var fltIndex = firstNumIndex + (value - firstBinMin) / binSize;
                            }
                            else {
                                for (var j = 0; j < bins.length; j++) {
                                    var bin = bins[j];
                                    if (value < bin.max || j == (bins.length - 1)) {
                                        fltIndex = j;
                                        break;
                                    }
                                }
                            }
                            //var binIndex = Math.max(0, Math.floor(fltIndex - hostServices.epsilon));
                            /*
                            // Commented out 2/4/2014: With this code in place, the bin index will sometimes disagree with the bin.min/max values
                            // [eg. in DemoVote, a MedianHomeValue of 200,000 (with 15 columns) will be placed into bin index 3 (200,000.2 to 266,666.93) instead of bin index 2].
                            var binIndex = Math.max(0, Math.floor(fltIndex + hostServices.epsilon));
                            binIndex = Math.min(binIndex, binCount - 1);
                            */
                            binIndex = Math.min(Math.floor(fltIndex), binCount - 1);
                            // If we have, for example, 3 columns: "0 .. 10", "> 10 .. 20", "> 20 .. 30" then we need to
                            // ensure that the value 10 falls into bin[0] (not bin 1) and 20 falls into bin[1] (not bin 2).
                            // Note that we need to do 2 checks for the BEFORE bin case:
                            // Is the value <= the max of the bin before, or is the value equal to the min of the current bin?
                            // We need both since 'max of the bin before' and 'min of the current bin' may NOT be the same value
                            // due to float imprecision. See this in action with the titanic dataset and 15 columns on 'Age':
                            // bins[5].max = 31.999999999999996 yet bins[6].min = 32. 
                            // This happens because:
                            // (5 * binSize) + binSize = 31.999999999999996, but 6 * binSize = 32.
                            //---- enforce bin min/max settings for edge cases ----
                            if ((binIndex > firstNumIndex) && (value < bins[binIndex].min)) {
                                binIndex--;
                            }
                            else if ((binIndex < bins.length - 1) && (value >= bins[binIndex].max)) {
                                binIndex++;
                            }
                        }
                        //---- update BIN STATS (only for filtered-IN shapes) ----
                        var bin = bins[binIndex];
                        bin.count = bin.count + 1;
                        if (sumColData) {
                            var sumValue = sumColData[i];
                            bin.sum += sumValue;
                        }
                        if (bin.actualMin === undefined || value < bin.actualMin) {
                            bin.actualMin = value;
                        }
                        if (bin.actualMax === undefined || value > bin.actualMax) {
                            bin.actualMax = value;
                        }
                    }
                    //---- we build these lists for both IN and OUT records ----
                    if (addIndexes) {
                        bin.rowIndexes.push(i);
                    }
                    if (returnBinAssignments) {
                        //---- just let FILTERED OUT items fall into bin 0 assignments (but they will not be put there during drawing) ----
                        assignments[i] = binIndex;
                    }
                }
                //---- add "density" field ----   
                var itemCount = filteredData.length;
                this.computeBinStats(bins, itemCount);
                if (usingLocalFormatter && typeName == "number") {
                    //---- ensure that label decimal precision is true to the bin's content ----
                    for (var i = 0; i < 5; i++) {
                        if (!this.labelsNeedMoreDecimals(bins, formatter)) {
                            break;
                        }
                        //---- add 1 more decimal to formatter and rebuild labels ----
                        numDecimals++;
                        formatter = vp.formatters.createCommaFormatter(numDecimals);
                    }
                }
                //---- assign final labels ----
                for (var i = 0; i < bins.length; i++) {
                    var bin = bins[i];
                    if (md && md.labels && md.labels.length) {
                        var minLabel = md.labels[i];
                        var maxLabel = md.labels[i + 1];
                    }
                    else {
                        var minLabel = formatter(bin.min);
                        var maxLabel = formatter(bin.max);
                    }
                    //bin.name = ((i == 0) ? "" : "> ") + minLabel + " ... " + maxLabel;
                    bin.name = minLabel + " ... " + maxLabel;
                    bin.minLabel = minLabel;
                    bin.maxLabel = maxLabel;
                }
            }
            var retValue = new beachParty.BinResultNum();
            retValue.colName = colName;
            retValue.bins = bins;
            retValue.assignments = assignments;
            retValue.dateFormatString = null;
            retValue.isTagBinning = false;
            return retValue;
        };
        /**
         * Common code for finding the axis/bin break values for numeric columns.
         * @param md
         * @param colInfo
         */
        binHelperNum.computeNumBreaks = function (md, colInfo, addNanBreakIfNeeded) {
            //---- this takes priority ----
            var breaks = md.breaks;
            if (!breaks) {
                var binCount = (md.isBinCountSoft) ? undefined : md.binCount;
                var min = +colInfo.stats.min;
                var max = +colInfo.stats.max;
                //---- handle override of min/max ----
                if (md.minBreak !== undefined) {
                    min = md.minBreak;
                }
                else if (md.minBreakFacet !== undefined) {
                    min = md.minBreakFacet;
                }
                if (md.maxBreak !== undefined) {
                    max = md.maxBreak;
                }
                if (md.maxBreakFacet !== undefined) {
                    max = md.maxBreakFacet;
                }
                if (min == max) {
                    max = min + 1; // make 2 values so that we can have at least 1 bin
                }
                //---- does caller allow nicer (round) numbers? ----
                if (md.useNiceNumbers || binCount === undefined) {
                    if (binCount === undefined) {
                        var result = vp.scales.niceNumbersAlt.calculate(min, max, undefined);
                    }
                    else {
                        //---- uses binCount+1 ----
                        var result = vp.scales.niceNumbersAlt.calculate(min, max, binCount + 1);
                    }
                    min = result.min;
                    max = result.max;
                    if (!binCount) {
                        binCount = result.steps;
                    }
                }
                var stepAmt = (max - min) / binCount;
                breaks = vp.data.range(min, max, stepAmt);
                //---- do we need to add a break value for NAN's? ----
                if (colInfo.stats.nanCount && addNanBreakIfNeeded) {
                    breaks.insert(0, Number.NaN);
                }
            }
            return breaks;
        };
        binHelperNum.computeBinStats = function (bins, dataItemCount) {
            for (var i = 0; i < bins.length; i++) {
                var bin = bins[i];
                bin.density = bin.count / dataItemCount;
            }
            var maxCount = bins.max(function (data) { return data.count; });
            var maxDensity = bins.max(function (data) { return data.density; });
            for (var i = 0; i < bins.length; i++) {
                var bin = bins[i];
                //---- add "ncount" field (count scaled to maximum of 1) ----
                bin.ncount = bin.count / maxCount;
                //---- add "ndensity" field (density scaled to maximum of 1) ----
                bin.ndensity = bin.density / maxDensity;
            }
        };
        binHelperNum.labelsNeedMoreDecimals = function (bins, formatter) {
            var needMoreDecimals = false;
            for (var i = 0; i < bins.length; i++) {
                var bin = bins[i];
                var displayMin = +formatter(bin.min);
                var displayMax = +formatter(bin.max);
                if (i == 0) {
                    if (bin.actualMin !== undefined) {
                        if (bin.actualMin < displayMin || bin.actualMax > displayMax) {
                            needMoreDecimals = true;
                            break;
                        }
                    }
                }
                else {
                    //---- should be > min and <= max ----
                    if (bin.actualMin !== undefined) {
                        if (bin.actualMin <= displayMin || bin.actualMax > displayMax) {
                            needMoreDecimals = true;
                            break;
                        }
                    }
                }
            }
            return needMoreDecimals;
        };
        return binHelperNum;
    }());
    beachParty.binHelperNum = binHelperNum;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// csv.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - part of the beachParty library
///     - converts a CSV (comma seperated file) into an array of json objects
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// converts a csv string (read from a csv file) into a json object.
    function csvToJson(csv, hasHeader, sepChar, findTypes) {
        var loader = createCsvLoader(hasHeader, sepChar, findTypes);
        return loader.loadFromText(csv);
    }
    beachParty.csvToJson = csvToJson;
    var csvLoaderClass = (function () {
        function csvLoaderClass(hasHeader, sepChar, findTypes, fixupValues) {
            //---- private state ----
            this._colNames = [];
            this._processedHdr = false;
            this._lastLoadRemainder = "";
            this._colCount = 0;
            this._hasHeader = null;
            this._sepChar = "";
            this._quoteChar = "\"";
            this._findTypes = false;
            this._fixupValues = true;
            this._shortRowsCount = 0;
            this._hasHeader = (hasHeader === null) ? false : hasHeader;
            this._findTypes = findTypes;
            this._sepChar = (sepChar === null) ? "\t" : sepChar;
            this._fixupValues = fixupValues;
        }
        /// public: load(csv)
        csvLoaderClass.prototype.loadFromText = function (csv) {
            var startTimeInMs = vp.utils.now();
            var rows = [];
            var scanner = new beachParty.csvScannerClass(csv, this._sepChar, "\"");
            if (!this._processedHdr) {
                if (this._hasHeader) {
                    //---- read first line containing column headers ----
                    var colNum = 0;
                    //---- process first line ----
                    while (true) {
                        var colName = scanner.scan();
                        if (colName === beachParty.csvScannerClass.endOfLine || colName === beachParty.csvScannerClass.endOfFile) {
                            break;
                        }
                        colName = colName.trim();
                        // Check that the column name doesn't contain any invalid chars [that JavaSctipt - or we - may choke on]
                        //if (colName.startsWith("@") || (colName.indexOf("&") != -1))
                        //{
                        //    throw ("Column name '" + colName + "' is invalid: column names cannot contain '&' or start with '@'");
                        //}
                        this._colNames.push(colName);
                    }
                    this._colCount = this._colNames.length;
                }
                this._processedHdr = true;
            }
            var lastRowOffset = 0;
            var malformedRowErrorCount = 0;
            var reportMalformedRowErrors = true;
            while (true) {
                var row = this.collectRowValues(scanner, this._colNames);
                var colsFound = vp.utils.keys(row).length;
                if (colsFound == 0 && scanner.endOfFile()) {
                    break;
                }
                //---- if no header present, take first line of values as the "soft" column count ----
                if (this._colCount == 0) {
                    this._colCount = colsFound;
                }
                if (colsFound < this._colCount) {
                    this._shortRowsCount++;
                    if (this._shortRowsCount < 5) {
                        //---- this is not an error, but we flag it for debugging purposes ----
                        vp.utils.debug("csv short row: rowIndex=" + rows.length + ", expected=" + this._colCount + ", found=" + colsFound);
                    }
                    //---- ensure first row has all names ----
                    if (rows.length == 0) {
                        for (var i = colsFound; i < this._colCount; i++) {
                            var name = this._colNames[i];
                            row[name] = "";
                        }
                    }
                }
                rows.push(row);
                lastRowOffset = i;
            }
            if (this._shortRowsCount) {
                vp.utils.debug("csv total SHORT ROWS=" + this._shortRowsCount);
            }
            //---- test each column to see if all numeric; if so, convert to numbers ----
            if ((this._findTypes) && (rows.length > 0)) {
                var firstRow = rows[0];
                var keys = vp.utils.keys(firstRow);
                //---- test each column ----
                for (var i = 0; i < keys.length; i++) {
                    this.tryToConvertColToNativeType(rows, keys[i]);
                }
            }
            var elapsedMs = new Date().getTime() - startTimeInMs;
            // alert("load() elapsed ms = " + elapsedMs.toString());
            return rows;
        };
        csvLoaderClass.prototype.collectRowValues = function (scanner, colNames) {
            //---- process next line (row) of data ----
            var colNum = 0;
            var row = {};
            while (true) {
                var colValue = scanner.scan();
                if (colValue === beachParty.csvScannerClass.endOfLine || colValue === beachParty.csvScannerClass.endOfFile) {
                    break;
                }
                var colName = (colNum < colNames.length) ? colNames[colNum] : "col" + colNum;
                row[colName] = colValue;
                colNum++;
            }
            return row;
        };
        csvLoaderClass.prototype.tryToConvertColToNativeType = function (rows, colName) {
            if (!this.tryToConvertColToBool(rows, colName)) {
                /// since JavaScript cannot tell the difference between a DATE and a number reliably, don't auto convert to date.
                if (true) {
                    this.tryToConvertColToNumeric(rows, colName);
                }
            }
        };
        csvLoaderClass.prototype.tryToConvertColToNumeric = function (rows, colName) {
            var isNumeric = true;
            var values = [];
            for (var i = 0; i < rows.length; i++) {
                var row = rows[i];
                var str = row[colName];
                if (str) {
                    //---- TODO: add support for various standard number formats (e.g., 35,032.33) ----
                    //---- for now, just remove commas (works for US but not other locales) ----
                    str = str.replace(/,/g, "");
                }
                else {
                    str = "";
                }
                if (!this._fixupValues && str.trim() == "") {
                    //---- convert missing number to null ----
                    values.push(null);
                }
                else {
                    var value = Number(str);
                    if (isNaN(value)) {
                        str = str.toLowerCase();
                        if (str == "null" || str == "na" || str == "") {
                            value = 0;
                        }
                        else {
                            isNumeric = false;
                            break;
                        }
                    }
                    values.push(value);
                }
            }
            if (isNumeric) {
                for (var i = 0; i < rows.length; i++) {
                    var row = rows[i];
                    row[colName] = values[i];
                }
            }
            return isNumeric;
        };
        csvLoaderClass.prototype.tryToConvertColToBool = function (rows, colName) {
            var isBool = true;
            var values = [];
            for (var i = 0; i < rows.length; i++) {
                var row = rows[i];
                var str = row[colName].toLowerCase();
                if (str == "true") {
                    values.push(true);
                }
                else if (str == "false") {
                    values.push(false);
                }
                else {
                    isBool = false;
                    break;
                }
            }
            if (isBool) {
                for (var i = 0; i < rows.length; i++) {
                    var row = rows[i];
                    row[colName] = values[i];
                }
            }
            return isBool;
        };
        csvLoaderClass.prototype.tryToConvertColToDate = function (rows, colName) {
            var isDate = true;
            var values = [];
            for (var i = 0; i < rows.length; i++) {
                var row = rows[i];
                var str = row[colName];
                //---- TODO: add support for various standard date formats (e.g., yyyy-mm-dd) ----
                var value = Date.parse(str);
                if (isNaN(value)) {
                    isDate = false;
                    break;
                }
                values.push(value);
            }
            if (isDate) {
                for (var i = 0; i < rows.length; i++) {
                    var row = rows[i];
                    row[colName] = values[i];
                }
            }
            return isDate;
        };
        return csvLoaderClass;
    }());
    beachParty.csvLoaderClass = csvLoaderClass;
    function createCsvLoader(hasHeader, sepChar, findTypes, fixupValues) {
        if (fixupValues === void 0) { fixupValues = true; }
        return new csvLoaderClass(hasHeader, sepChar, findTypes, fixupValues);
    }
    beachParty.createCsvLoader = createCsvLoader;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// csvColLoader.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - part of the beachParty library
///     - loads columns on demand from a raw block of CSV text.
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var csvColLoaderClass = (function () {
        function csvColLoaderClass(text, hasHeader, sepChar, findTypes, fixupValues) {
            //---- private state ----
            this._colNames = [];
            this._processedHdr = false;
            this._lastLoadRemainder = "";
            this._colCount = 0;
            this._rowCount = 0;
            this._hasHeader = null;
            this._sepChar = "";
            this._quoteChar = "\"";
            this._findTypes = false;
            this._fixupValues = true;
            this._shortRowsCount = 0;
            this._text = text;
            this._hasHeader = (hasHeader === null) ? false : hasHeader;
            this._findTypes = findTypes;
            this._sepChar = (sepChar === null) ? "\t" : sepChar;
            this._fixupValues = fixupValues;
        }
        /** load header and determine col types thru record sampling. */
        csvColLoaderClass.prototype.buildDataFrameWithEmptyVectors = function () {
            var scanner = new beachParty.csvScannerClass(this._text, this._sepChar, "\"");
            this._scanner = scanner;
            //---- read first line containing column headers ----
            this.readHeaderRow(scanner);
            //---- read entire text to build rowIndexes[] ----
            this.buildColRowIndexes(scanner);
            //---- sample records to determine colTypes ----
            var colTypes = this.sampleForColTypes(scanner);
            //---- build DataColum array ----
            var dataColumns = [];
            for (var i = 0; i < colTypes.length; i++) {
                var colName = this._colNames[i];
                var dataCol = new beachParty.DataColumn(colName, null, colTypes[i], null);
                dataCol.data = null;
                dataColumns[i] = dataCol;
            }
            var dataFrame = new beachParty.dataFrameClass(dataColumns);
            return dataFrame;
        };
        csvColLoaderClass.prototype.readRowsWithVectors = function (scanner, vectors, startRow, rowCount) {
            var startOffset = this._colRowIndexes[0][startRow];
            scanner._offset = startOffset;
            for (var i = 0; i < rowCount; i++) {
                //---- process next row ----
                var valueCount = 0;
                for (var i = 0; i < this._colCount; i++) {
                    var vector = vectors[i];
                    var value = scanner.scan();
                    if (value === beachParty.csvScannerClass.endOfLine || value === beachParty.csvScannerClass.endOfFile) {
                        break;
                    }
                    vector.push(value);
                    valueCount++;
                }
                //---- fill missing values ----
                while (valueCount < this._colCount) {
                    //---- add empty values for rest of the row ----
                    var vector = vectors[valueCount++];
                    vector.push("");
                }
                //---- skip extra values ----
                while (value !== beachParty.csvScannerClass.endOfLine && value !== beachParty.csvScannerClass.endOfFile) {
                    value = scanner.scan();
                }
                if (value === beachParty.csvScannerClass.endOfFile) {
                    break;
                }
            }
        };
        csvColLoaderClass.prototype.fillSparseColVectors = function (vectorMap, scanner, colIndexes) {
            //---- process by vector (for now; todo: try processing by row later & compare timings) ----
            for (var i = 0; i < colIndexes.length; i++) {
                var colIndex = colIndexes[i];
                var colName = this._colNames[colIndex];
                var vector = [];
                vectorMap[colName] = vector;
                //---- fill colIndex ----
                for (var r = 0; r < this._rowCount; r++) {
                    var startIndex = this._colRowIndexes[colIndex][r];
                    var endIndex = this._colRowIndexes[colIndex + 1][r] - 1;
                    var value = this._text.substr(startIndex, endIndex - startIndex);
                    if (value.startsWith(this._quoteChar) && value.endsWith(this._quoteChar)) {
                        //---- remove surrounding quotes ----
                        value = value.substr(1, value.length - 2);
                    }
                    vector.push(value);
                }
            }
        };
        csvColLoaderClass.prototype.getRecord = function (rowIndex, colNames) {
            var startOffset = this._colRowIndexes[0][rowIndex];
            var scanner = this._scanner;
            scanner._offset = startOffset;
            var valueCount = 0;
            var record = {};
            for (var i = 0; i < this._colCount; i++) {
                var value = scanner.scan();
                if (value === beachParty.csvScannerClass.endOfLine || value === beachParty.csvScannerClass.endOfFile) {
                    break;
                }
                var name = this._colNames[i];
                record[name] = value;
                valueCount++;
            }
            return record;
        };
        csvColLoaderClass.prototype.loadColumns = function (vectorMap, colNames) {
            var colIndexes = [];
            for (var i = 0; i < colNames.length; i++) {
                var colName = colNames[i];
                var index = this._colNames.indexOf(colName);
                if (index == -1) {
                    throw "loadColumns(): unknown colName=" + colName;
                }
                colIndexes.push(index);
            }
            this.fillSparseColVectors(vectorMap, this._scanner, colIndexes);
        };
        csvColLoaderClass.prototype.sampleForColTypes = function (scanner) {
            //---- number of records to sample ----
            var topCount = 100;
            var middleCount = 100;
            var bottomCount = 100;
            var rowCount = this._rowCount;
            if (rowCount < 1000) {
                //---- just use all data ----
                topCount = rowCount;
                middleCount = 0;
                bottomCount = 0;
            }
            //---- build empty array of vectors ----
            var vectors = [];
            for (var i = 0; i < this._colCount; i++) {
                vectors[i] = [];
            }
            var topIndex = 0;
            var middleIndex = rowCount / 2 - middleCount / 2;
            var bottomIndex = rowCount - bottomCount;
            //---- pseudo random samples, in a way that is repeatable ----
            this.readRowsWithVectors(scanner, vectors, topIndex, topCount);
            this.readRowsWithVectors(scanner, vectors, middleIndex, middleCount);
            this.readRowsWithVectors(scanner, vectors, bottomIndex, bottomCount);
            //---- set colTypes from records[] ----
            var colTypes = [];
            for (var i = 0; i < this._colCount; i++) {
                var colName = this._colNames[i];
                //this.tryToConvertColToNativeType(records, colName);
                var vector = vectors[i];
                var colType = vp.data.getDataType(vector);
                colTypes.push(colType);
            }
            return colTypes;
        };
        csvColLoaderClass.prototype.buildColRowIndexes = function (scanner) {
            //---- build empty array of rowIndexes (one for each column) ----
            var colRowIndexes = [];
            this._colRowIndexes = colRowIndexes;
            //---- build 1 extra for finding end of last column on each row ----
            for (var i = 0; i <= this._colCount; i++) {
                var rowIndexes = [];
                colRowIndexes.push(rowIndexes);
            }
            while (true) {
                //---- record start of next row ----
                var valueCount = 0;
                //---- process next row ----
                while (true) {
                    var startOffset = scanner._offset;
                    var value = scanner.scan();
                    if (value === beachParty.csvScannerClass.endOfLine || value === beachParty.csvScannerClass.endOfFile) {
                        break;
                    }
                    var rowIndexes = colRowIndexes[valueCount];
                    rowIndexes.push(startOffset);
                    valueCount++;
                    if (valueCount == this._colCount) {
                        //---- add end of last column info ----
                        var rowIndexes = colRowIndexes[valueCount];
                        var offset = scanner._offset;
                        if (!scanner.justPassedDelimiter()) {
                            offset++;
                        }
                        rowIndexes.push(offset);
                    }
                }
                if (value === beachParty.csvScannerClass.endOfFile) {
                    break;
                }
            }
            this._rowCount = colRowIndexes[0].length;
        };
        csvColLoaderClass.prototype.readHeaderRow = function (scanner) {
            var colNum = 0;
            this._colNames = [];
            while (true) {
                var colName = scanner.scan();
                if (colName === beachParty.csvScannerClass.endOfLine || colName === beachParty.csvScannerClass.endOfFile) {
                    break;
                }
                if (this._hasHeader) {
                    // Check that the column name doesn't contain any invalid chars [that JavaSctipt - or we - may choke on]
                    //if (colName.startsWith("@") || (colName.indexOf("&") != -1))
                    //{
                    //    throw ("Column name '" + colName + "' is invalid: column names cannot contain '&' or start with '@'");
                    //}
                    colName = colName.trim();
                }
                else {
                    colName = "column" + (colNum + 1);
                }
                this._colNames.push(colName);
            }
            this._colCount = this._colNames.length;
            if (!this._hasHeader) {
                //---- reset scanner to first row ----
                scanner = new beachParty.csvScannerClass(this._text, this._sepChar, "\"");
            }
        };
        return csvColLoaderClass;
    }());
    beachParty.csvColLoaderClass = csvColLoaderClass;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// csvScanner.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - part of the beachParty library
///     - scans values in a CSV (text delimited) file
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var csvScannerClass = (function () {
        function csvScannerClass(text, delimiter, quoteChar) {
            //---- scanner state ----
            this._text = null;
            this._offset = 0;
            this._delimiter = delimiter;
            this._quoteChar = quoteChar;
            this._offset - 0;
            //---- make scanner simpler by collapsing multi char line endings ----
            text = text.replace(/\r\n/g, "\n");
            text = text.replace(/\r/g, "\n");
            this._text = text;
        }
        csvScannerClass.prototype.scan = function () {
            var value = csvScannerClass.endOfFile;
            var offset = this._offset;
            var start = offset;
            var text = this._text;
            if (offset < text.length) {
                var ch = text[offset++];
                if (ch == "\n") {
                    value = csvScannerClass.endOfLine;
                }
                else if (ch == this._delimiter) {
                    value = "";
                }
                else {
                    //---- scan NORMAL value which might contain a quoted subset ----
                    var inQuotedPhrase = false;
                    var foundAQuote = false;
                    value = "";
                    while (true) {
                        if (inQuotedPhrase) {
                            //---- QUOTE mode processing ----
                            if (ch == this._quoteChar) {
                                //---- EMBEDDED quote? ----
                                if (offset < text.length && text[offset] == this._quoteChar) {
                                    value += ch;
                                    offset++; // skip over 2nd quote char
                                }
                                else {
                                    //---- normal ENDING quote ----
                                    inQuotedPhrase = false;
                                    value += ch;
                                }
                            }
                            else {
                                //---- normal char in quote mode ----
                                value += ch;
                            }
                        }
                        else {
                            //---- NORMAL mode processing ----
                            if (ch == this._quoteChar) {
                                foundAQuote = true;
                                inQuotedPhrase = true;
                                value += ch;
                            }
                            else if (ch == this._delimiter) {
                                break;
                            }
                            else if (ch == "\n") {
                                //---- don't consume the newline until our next call ----
                                offset--;
                                break;
                            }
                            else {
                                //---- normal char in normal mode ----
                                value += ch;
                            }
                        }
                        if (offset >= text.length) {
                            break;
                        }
                        ch = text[offset++];
                    }
                    //---- debug ----
                    if (foundAQuote) {
                        //alert("quoted value: " + value);
                        var dummy = 9;
                    }
                    //---- if value is surrounded by quotes, remove them ----
                    if (value.startsWith(this._quoteChar) && value.endsWith(this._quoteChar)) {
                        value = value.substr(1, value.length - 2);
                    }
                }
                this._offset = offset;
            }
            return value;
        };
        csvScannerClass.prototype.justPassedDelimiter = function () {
            var lastOffset = this._offset - 1;
            var text = this._text;
            return (lastOffset >= 0 && lastOffset < text.length && text[lastOffset] === this._delimiter);
        };
        csvScannerClass.prototype.endOfFile = function () {
            return (this._offset >= this._text.length);
        };
        csvScannerClass.endOfLine = -1;
        csvScannerClass.endOfFile = null;
        return csvScannerClass;
    }());
    beachParty.csvScannerClass = csvScannerClass;
    function testCsvScanner() {
        var scanner = new csvScannerClass('abc;def;ghi\n1;2;3\naaa;"bbb";ccc\naaa;"bb""bb";ccc\n', ";", "\"");
        while (true) {
            var value = scanner.scan();
            vp.utils.debug("csvScan: value=" + value);
            if (value == csvScannerClass.endOfFile) {
                break;
            }
        }
    }
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// dataFrame.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - a class to represent a dataset as a set of named vectors.  This is a lightweight version of the NDV data format.
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// Note: dataFrame does NOT change the original data, but it cache numeric vectors on-demand for each column. 
    var dataFrameClass = (function (_super) {
        __extends(dataFrameClass, _super);
        function dataFrameClass(dataColumns) {
            _super.call(this);
            this.ctr = "dataFrameClass";
            this._sortKey = "none"; // colName + "up" or "down"
            this._pkToVectorIndex = {};
            this._recordCount = 0;
            this._getColInfoWorkCount = 0;
            this._isFilterActive = false; // must be pushed to us by dataMgr 
            //this._appMgr = appMgr;
            this._columns = dataColumns;
            this._wdParams = new beachParty.WorkingDataParams("");
            var colMap = {};
            this._colMap = colMap;
            for (var i = 0; i < dataColumns.length; i++) {
                var col = dataColumns[i];
                colMap[col.name] = col;
            }
            this._numericVectorsCache = {};
            //---- code for running in engine or on client ----
            //if (this._appMgr && this._appMgr._dataView)
            //{
            //    var view = this._appMgr._dataView;
            //    var blankValueStr = view.blankValueStr();
            //}
            //else
            {
                var blankValueStr = "<blank>";
            }
            this._recordCount = this.computeRecordCount();
        }
        dataFrameClass.prototype.computeRecordCount = function () {
            var recordCount = 0;
            var cols = this._columns;
            if (cols && cols.length) {
                recordCount = cols[0].data.length;
            }
            return recordCount;
        };
        dataFrameClass.prototype.isFilterActive = function (value) {
            if (arguments.length == 0) {
                return this._isFilterActive;
            }
            this._isFilterActive = value;
            this.onDataChanged("isFilterActive");
        };
        dataFrameClass.prototype.setWdParams = function (wdParams) {
            this._wdParams = wdParams;
        };
        dataFrameClass.prototype.getColTypes = function () {
            var colTypes = this._columns.map(function (col) { return col.colType; });
            return colTypes;
        };
        dataFrameClass.prototype.getColInfos = function () {
            var colInfos = [];
            var columns = this._columns;
            for (var i = 0; i < columns.length; i++) {
                var col = columns[i];
                var colInfo = this.getColInfo(col.name);
                colInfos.push(colInfo);
            }
            return colInfos;
        };
        dataFrameClass.prototype.getColInfo = function (name) {
            var numVector = this.getNumericVector(name);
            var colInfo = numVector.colInfo;
            return colInfo;
        };
        /** returns the type of column (date, number, string).  This value is calculated on demand, and then cached. */
        dataFrameClass.prototype.getColType = function (name) {
            var colType = null;
            var col = this._colMap[name];
            if (col) {
                colType = col.colType;
            }
            return colType;
        };
        /** ensure the specified columns are loaded and the other columns are closed (to minimize memory use). */
        dataFrameClass.prototype.loadColumns = function (colList) {
            //if (this._loader)
            //{
            //    //---- close unneeded columns ----
            //    for (var i = 0; i < this._names.length; i++)
            //    {
            //        var name = this._names[i];
            //        if (systemColNames.indexOf(name) == -1)
            //        {
            //            if (colList.indexOf(name) == -1)
            //            {
            //                this._vectorsByName[name] = null;
            //                this._numericVectorsCache[name] = null;
            //            }
            //        }
            //    }
            //    //---- gather list of columns that we need to load ----
            //    var loadList = [];
            //    for (var i = 0; i < colList.length; i++)
            //    {
            //        var name = colList[i];
            //        if (this._vectorsByName[name] == null)
            //        {
            //            loadList.push(name);
            //        }
            //    }
            //    if (loadList.length)
            //    {
            //        this._loader.loadColumns(this._vectorsByName, loadList);
            //    }
            //}
        };
        dataFrameClass.prototype.rebuildPrimaryKeyIndex = function () {
            var pkMap = {};
            var pkVector = this.getVector(beachParty.primaryKeyName, false);
            for (var i = 0; i < pkVector.length; i++) {
                var pk = pkVector[i];
                pkMap[pk] = i;
            }
            this._pkToVectorIndex = pkMap;
        };
        dataFrameClass.prototype.getColumnNames = function () {
            return this._columns.map(function (col) { return col.name; });
        };
        dataFrameClass.prototype.getPkToVectorIndex = function () {
            return this._pkToVectorIndex;
        };
        dataFrameClass.prototype.getVectorIndexByKey = function (key) {
            var index = this._pkToVectorIndex[key];
            return index;
        };
        dataFrameClass.prototype.vectorToPrimaryKeys = function (vector) {
            var keys = [];
            var pkVector = this.getVector(beachParty.primaryKeyName, false);
            if (vector) {
                for (var i = 0; i < vector.length; i++) {
                    if (vector[i]) {
                        var key = pkVector[i];
                        keys.push(key);
                    }
                }
            }
            return keys;
        };
        dataFrameClass.prototype.getValueMap = function (colName, maxRows, callback) {
            var vm = null;
            var pf = this.getFieldData(colName);
            if (pf && pf.valueMap) {
                vm = pf.valueMap;
            }
            else {
                //---- must build one from values in column ----
                var vector = this.getVector(colName, false);
                var groups = vector.groupBy();
                vm = [];
                for (var i = 0; i < groups.length; i++) {
                    var group = groups[i];
                    var vme = new beachParty.ValueMapEntry();
                    vme.originalValue = group.key;
                    vme.valueCount = group.values.length;
                    vm.push(vme);
                }
            }
            //---- valueMap: sort in descending order of value count (high counts first) ----
            vm = vm.orderByNum(function (e) { return e.valueCount; });
            vm.reverse();
            if (maxRows != undefined) {
                vm = vm.slice(0, maxRows);
            }
            if (callback) {
                callback(vm);
            }
            return vm;
        };
        dataFrameClass.prototype.isColumnName = function (colName) {
            var isCol = (this._colMap[colName] != null);
            return isCol;
        };
        dataFrameClass.prototype.append = function (df) {
            var fromCols = df._columns;
            var toCols = this._columns;
            for (var i = 0; i < fromCols.length; i++) {
                var fromCol = fromCols[i];
                var colName = fromCol.name;
                //---- append "colName" to this dataFrame ----
                var toVector = this.getVector(colName, true);
                if (!toVector) {
                    var newCol = new beachParty.DataColumn(fromCol.name, fromCol.desc, fromCol.colType, fromCol.calcFieldExp, fromCol.stats, fromCol.data.slice(0));
                    toCols.push(newCol);
                    this._colMap[colName] = newCol;
                }
                else {
                    var fromVector = df.getVector(colName, false);
                    for (var v = 0; v < fromVector.length; v++) {
                        var value = fromVector[v];
                        toVector.push(value);
                    }
                }
            }
        };
        dataFrameClass.prototype.isValidFieldName = function (str) {
            var isValid = (str.length > 0);
            for (var i = 0; i < str.length; i++) {
                var ch = str[i];
                if (ch == "_" || (ch >= "0" && ch <= "9") || (ch.toLocaleLowerCase() != ch.toLocaleUpperCase())) {
                }
                else {
                    isValid = false;
                    break;
                }
            }
            return isValid;
        };
        /** replaces column names with "record." in front of them.  Also correct the case-ing of the column names. */
        dataFrameClass.prototype.addRecordKeywordToColumnNames = function (exp) {
            var newExp = "";
            var lastToken = null;
            var TokenType = vp.utils.TokenType;
            //---- build lowerColNames ----
            var lowerColNames = [];
            var cols = this._columns;
            for (var i = 0; i < cols.length; i++) {
                var name = cols[i].name.toLowerCase();
                lowerColNames.push(name);
            }
            //---- get column names ----
            var scanner = new vp.utils.scannerClass(exp);
            scanner.scan(); // get the first token
            var tokenType = scanner.tokenType();
            var token = scanner.token();
            while (tokenType != TokenType.eof) {
                /// TODO: how can we support odd column name chars like "#"?
                if (tokenType == TokenType.id) {
                    if (lastToken != ".") {
                        var lowtok = token.toLowerCase();
                        var index = lowerColNames.indexOf(lowtok);
                        if (index > -1) {
                            //---- add column name ----
                            token = "record." + cols[index].name;
                        }
                        else {
                            if (lowtok == "math") {
                                token = "Math"; // correct case if needed
                            }
                            else if (lowtok == "_primaryKey") {
                                token = "_primaryKey";
                            }
                        }
                    }
                }
                else if (token == "=") {
                    //---- common mistake - fix for user ----
                    token = "==";
                }
                newExp += token;
                lastToken = token;
                scanner.scan();
                tokenType = scanner.tokenType();
                token = scanner.token();
            }
            return newExp;
        };
        dataFrameClass.prototype.isColLoaded = function (colName) {
            return (this._colMap[colName].data != null);
        };
        /** uses "exp" as a JavaScript expression to build a new vector of values. */
        dataFrameClass.prototype.buildCalcVector = function (exp) {
            var newVector = [];
            var recordCount = this._recordCount;
            //----  convert exp from string to func ----
            var expAdj = this.addRecordKeywordToColumnNames(exp);
            var expFunc = null;
            var strMakeFunc = "expFunc = function(record) { return " + expAdj + ";}";
            /// TOD: write a function validator that ensures only columns, standard function, and constants are
            /// used in an expression to create a safeEval().
            //eval(strMakeFunc);      // create function from user expression
            throw "calc fields not currenly supported";
            //for (var i = 0; i < recordCount; i++)
            //{
            //    var record = this.getRecordByVectorIndex(i);
            //    //var _primaryKey = i;
            //    var value = expFunc(record);
            //    newVector.push(value);
            //}
            //return newVector;
        };
        /** applies a filter and produces a new dataFrame object. */
        dataFrameClass.prototype.applyPrefilter = function (exp) {
            var recordCount = this._recordCount;
            var indexes = []; // the records to keep
            //----  convert exp from string to func ----
            var expAdj = this.addRecordKeywordToColumnNames(exp);
            var expFunc = null;
            //eval("expFunc = function(record) { return " + expAdj + ";}");   // create function from exp
            throw "preload filter not currently supported";
            //for (var i = 0; i < recordCount; i++)
            //{
            //    var record = this.getRecordByVectorIndex(i);
            //    var _primaryKey = i;
            //    var value = expFunc(record);
            //    if (value != true)
            //    {
            //        indexes.push(i);
            //    }
            //}
            //var df = this.copyData(indexes);
            //return df;
        };
        /** create a new dataFrame, using the specified fieldList. */
        dataFrameClass.prototype.makeFields = function (fieldList, mergeFields) {
            var newMap = {};
            if (mergeFields) {
                this._columns.forEach(function (col) { return newMap[col.name] = col; });
            }
            for (var i = 0; i < fieldList.length; i++) {
                var fld = fieldList[i];
                var newName = fld.name;
                var exp = fld.calcFieldExp;
                var typeName = fld.fieldType;
                if (exp) {
                    if (this.isValidFieldName(exp)) {
                        //---- just a field rename ("exp" is the name of the source field) ----
                        var fromCol = this._colMap[exp];
                        var newCol = vp.utils.copyMap(fromCol, true);
                        //var vector = <any[]> null;
                        //if (this.isColLoaded(exp))
                        //{
                        //    vector = this.getVector(exp, false);
                        //    vector = vector.slice(0);  // copy vector
                        //}
                        newMap[newName] = newCol;
                    }
                    else {
                    }
                }
                else {
                    //---- use original field name ----
                    if (!newMap[newName]) {
                        var fromCol = this._colMap[newName];
                        var newCol = vp.utils.copyMap(fromCol, true);
                        newMap[newName] = newCol;
                    }
                }
                if (newCol && newCol.data && fld.valueMap && fld.valueMap.length) {
                    this.applyValueMap(fld, newCol.data);
                }
            }
            //---- convert map to array ----
            var newColumns = [];
            for (var k in newMap) {
                var nc = newMap[k];
                newColumns.push(nc);
            }
            var df = new dataFrameClass(newColumns);
            return df;
        };
        dataFrameClass.prototype.loader = function (value) {
            if (arguments.length == 0) {
                return this._loader;
            }
            this._loader = value;
        };
        /**
         *  Make the value substitutions specified by the fld's valueMap (array of valueMapEntry objects).
         * @param fld
         * @param vector
         */
        dataFrameClass.prototype.applyValueMap = function (fld, vector) {
            var valueMap = fld.valueMap;
            for (var i = 0; i < valueMap.length; i++) {
                var entry = valueMap[i];
                if (entry.newValue) {
                    this.applyValueMapEntry(entry, vector);
                }
            }
        };
        dataFrameClass.prototype.applyValueMapEntry = function (entry, vector) {
            var origValue = entry.originalValue;
            var newValue = entry.newValue;
            for (var i = 0; i < vector.length; i++) {
                if (vector[i] == origValue) {
                    vector[i] = newValue;
                }
            }
        };
        dataFrameClass.prototype.sortVectors = function (colName, ascending, colType) {
            /// HISTORICAL NOTE: using JavaScript array sort() for STRINGS on large data tables used to take a long time, so
            /// for a while we were sorting on the server.  Turns out the problem was that we were returning "1" for equal
            /// values, which GREATLY slowed down sorting in many cases.
            //---- NOTE: we can move this onto a background worker thread if/when needed----
            var sortAsNumbers = (colType != "string");
            if (!colName) {
                colName = "_primaryKey";
                ascending = true;
                sortAsNumbers = true;
            }
            //---- extract keys to sort ----
            var keys = [];
            if (colType == "string") {
                var vector = this.getVector(colName, false);
            }
            else {
                var vector = this.getNumericVector(colName, false).values;
            }
            if (!vector) {
                throw "Internal error - sort() called on non-existent colName=" + colName;
            }
            if (sortAsNumbers) {
                for (var i = 0; i < vector.length; i++) {
                    var key = vector[i];
                    keys[i] = { key: +key, index: i };
                }
                vp.utils.debug("calling NUMERIC sort: colName=" + colName + ", ascending=" + ascending + ", length=" + keys.length);
                if (ascending) {
                    keys.sort(function (a, b) { return a.key - b.key; });
                }
                else {
                    keys.sort(function (b, a) { return a.key - b.key; });
                }
            }
            else {
                for (var i = 0; i < vector.length; i++) {
                    var key = vector[i];
                    keys[i] = { key: key + "", index: i };
                }
                vp.utils.debug("calling STRING sort: colName=" + colName + ", ascending=" + ascending + ", length=" + keys.length);
                if (ascending) {
                    keys.sort(function (a, b) { return (a.key < b.key) ? -1 : ((a.key == b.key) ? 0 : 1); });
                }
                else {
                    keys.sort(function (b, a) { return (a.key < b.key) ? -1 : ((a.key == b.key) ? 0 : 1); });
                }
            }
            //vp.utils.debug("sort returned");
            //---- recorder each named vector, in place ----
            //---- this means that all layout routines directly use the sorted data, so they don't have to worry about a "sorted index" ----
            for (var i = 0; i < this._columns.length; i++) {
                var col = this._columns[i];
                var name = col.name;
                var vector = col.data;
                if (vector) {
                    this.reorderVectorInPlace(vector, keys);
                }
            }
            //---- save sort keys for colsOnDemand ----
            this._currentSortKeys = keys;
            this.rebuildPrimaryKeyIndex();
            this._sortKey = colName + (ascending ? "-up" : "-down");
            //---- invalidate our cache of numeric vectors ----
            this._numericVectorsCache = {};
            //---- debug - show first record index of newly sorted records ----
            //var last = riVector.length - 1;
            //vp.utils.debug("after sort, first record index=" + riVector[0] + ", last record index =" + riVector[last]);
        };
        dataFrameClass.prototype.getSortKey = function () {
            return this._sortKey;
        };
        dataFrameClass.prototype.reorderVectorInPlace = function (vector, keys) {
            var prevVector = vp.utils.copyArray(vector);
            for (var i = 0; i < keys.length; i++) {
                var keyEntry = keys[i];
                var index = keyEntry.index;
                var value = prevVector[index];
                vector[i] = value;
            }
        };
        dataFrameClass.prototype.getPreloadField = function (colName) {
            var pf = null;
            var preload = this.getPreload();
            if (preload && preload.fieldList) {
                var fieldList = preload.fieldList;
                for (var i = 0; i < fieldList.length; i++) {
                    if (fieldList[i].name == colName) {
                        pf = fieldList[i];
                        break;
                    }
                }
            }
            return pf;
        };
        dataFrameClass.prototype.addColsToData = function (newInfos, newVectors, callback) {
            for (var i = 0; i < newInfos.length; i++) {
                var ci = newInfos[i];
                var vector = newVectors[i];
                this.addColumn(ci, vector, false);
            }
            this.onDataChanged("colInfos");
            if (callback) {
                var colInfos = this.getColInfos();
                callback(colInfos);
            }
        };
        dataFrameClass.prototype.addColumn = function (ci, vector, notify) {
            if (notify === void 0) { notify = true; }
            var name = ci.name;
            var col = this._colMap[name];
            if (col === undefined) {
                //---- a new column ----
                col = new beachParty.DataColumn(ci.name, ci.desc, ci.colType, ci.calcFieldExp, ci.stats, vector);
                this._columns.push(col);
                this._colMap[name] = col;
            }
            else {
                //---- update an existing column ----
                col.desc = ci.desc;
                col.colType = ci.colType;
                col.calcFieldExp = ci.calcFieldExp;
                col.stats = ci.stats;
                //---- invalidate cache for this column, since we are adding new data ----
                this._numericVectorsCache[name] = null;
            }
            if (!vector) {
                //---- supply default vector of all zeros ----
                var count = this._recordCount;
                vector = [];
                for (var i = 0; i < count; i++) {
                    vector[i] = 0;
                }
            }
            //---- add the data to the newly created column ----
            col.data = vector;
            if (notify) {
                this.onDataChanged("colInfos");
            }
        };
        /* return an object serialized to JSON string */
        dataFrameClass.prototype.toJsonString = function () {
            var str = JSON.stringify(this);
            return str;
        };
        dataFrameClass.jsonToDataFrame = function (jsonData) {
            var newCols = [];
            if (jsonData.length > 0) {
                var record0 = jsonData[0];
                var names = vp.utils.keys(record0);
                for (var c = 0; c < names.length; c++) {
                    var colName = names[c];
                    var newCol = new beachParty.DataColumn(colName);
                    newCol.data = [];
                    newCols.push(newCol);
                }
                for (var r = 0; r < jsonData.length; r++) {
                    var record = jsonData[r];
                    for (var c = 0; c < names.length; c++) {
                        colName = names[c];
                        var col = newCols[c];
                        var value = record[colName];
                        col.data.push(value);
                    }
                }
                //---- postprocessing on each col ----
                for (var c = 0; c < names.length; c++) {
                    var col = newCols[c];
                    //---- compute colType, now that we have all our data ----
                    col.colType = vp.data.getDataType(col.data);
                }
            }
            var df = new dataFrameClass(newCols);
            return df;
        };
        dataFrameClass.prototype.getRecordCount = function () {
            return this._recordCount;
        };
        dataFrameClass.prototype.getPreload = function () {
            return this._wdParams;
        };
        dataFrameClass.prototype.getRecordByPrimaryKey = function (primaryKey, colNames) {
            var vi = this._pkToVectorIndex[primaryKey];
            return this.getRecordByVectorIndex(vi, colNames);
        };
        dataFrameClass.prototype.getRecordByVectorIndex = function (recordIndex, colNames) {
            var record = null;
            if (this._loader) {
                record = this._loader.getRecord(recordIndex, colNames);
            }
            else {
                if (recordIndex >= 0 && recordIndex <= this._recordCount) {
                    record = {};
                    if (!colNames) {
                        colNames = this.getColumnNames();
                    }
                    for (var c = 0; c < colNames.length; c++) {
                        var colName = colNames[c];
                        var vector = this._colMap[colName].data;
                        var value = vector[recordIndex];
                        record[colName] = value;
                    }
                }
            }
            return record;
        };
        dataFrameClass.prototype.toJson = function (maxRecords, indexes) {
            var newData = [];
            if (this._columns && this._columns.length) {
                var names = this.getColumnNames();
                var count = this._recordCount;
                if (maxRecords) {
                    count = Math.min(maxRecords, count);
                }
                if (indexes) {
                    count = Math.min(indexes.length, count);
                }
                for (var r = 0; r < count; r++) {
                    var record = {};
                    var index = (indexes) ? indexes[r] : r;
                    for (var c = 0; c < names.length; c++) {
                        var colName = names[c];
                        var vector = this._colMap[colName].data;
                        record[colName] = vector[index];
                    }
                    newData.push(record);
                }
            }
            return newData;
        };
        /** gets the named vector in its ORIGINAL form (string, date, number). */
        dataFrameClass.prototype.getVector = function (name, invalidateNumericCache) {
            //---- if we are changing the original vector, we need to invalidate the cached version of the numeric vector ----
            if (invalidateNumericCache) {
                this._numericVectorsCache[name] = null;
            }
            var colEntry = this._colMap[name];
            var vector = (colEntry) ? colEntry.data : null;
            if (!vector && this._loader) {
                //---- get column on demand ----
                var myMap = {};
                this._loader.loadColumns(myMap, [name]);
                vector = myMap[name];
                this._colMap[name].data = vector;
                //---- apply value map if present ----
                var fld = this.getFieldData(name);
                if (fld && fld.valueMap && fld.valueMap.length) {
                    this.applyValueMap(fld, vector);
                }
                //---- sort if sortKeys active ----
                if (this._currentSortKeys) {
                    this.reorderVectorInPlace(vector, this._currentSortKeys);
                }
            }
            return vector;
        };
        dataFrameClass.prototype.getFieldData = function (colName) {
            var pf = null;
            if (this._wdParams) {
                var fields = this._wdParams.fieldList;
                if (fields) {
                    for (var i = 0; i < fields.length; i++) {
                        var field = fields[i];
                        if (field.name == colName) {
                            pf = field;
                            break;
                        }
                    }
                }
            }
            return pf;
        };
        dataFrameClass.prototype.invalidateCache = function (colName) {
            this._numericVectorsCache[colName] = null;
        };
        /** gets the named vector in its NUMERIC form. */
        dataFrameClass.prototype.getNumericVector = function (name, forceCategory, allKeys, useCache) {
            if (useCache === void 0) { useCache = true; }
            var numVector = null;
            if (forceCategory) {
                numVector = this.buildNumericCol(name, true, true, allKeys);
            }
            else {
                if (useCache) {
                    //---- use cache for normal requests ----
                    numVector = this._numericVectorsCache[name];
                }
                if (!numVector) {
                    numVector = this.buildNumericCol(name, true, false, allKeys);
                    if (useCache) {
                        this._numericVectorsCache[name] = numVector;
                    }
                }
            }
            //---- now, build and set colInfo ----
            var colInfo = this.buildColumnInfo(name, numVector);
            numVector.colInfo = colInfo;
            return numVector;
        };
        dataFrameClass.prototype.copyData = function (recordIndexes) {
            //---- make a cop of all columns but without data ----
            var newCols = vp.utils.copyArray(this._columns);
            //---- go thru each colum and copy specified rows ----
            for (var i = 0; i < newCols.length; i++) {
                var newCol = newCols[i];
                var name = newCol.name;
                var vector = newCol.data;
                if (recordIndexes) {
                    var newVector = recordIndexes.map(function (recordIndex) {
                        return vector[recordIndex];
                    });
                }
                else {
                    var newVector = vp.utils.copyArray(vector);
                }
                newCol.data = newVector;
            }
            var df = new dataFrameClass(newCols);
            return df;
        };
        dataFrameClass.getSortedKeys = function (name, wdParams) {
            var sortedKeys = null;
            if (wdParams) {
                var colInfo = wdParams.getField(name);
                if (colInfo) {
                    sortedKeys = colInfo.sortedValues;
                }
            }
            return sortedKeys;
        };
        dataFrameClass.prototype.getPrimaryKeys = function (vector, vectorType) {
            var keys = [];
            var pkVector = this.getVector(beachParty.primaryKeyName, false);
            if (vectorType == beachParty.VectorType.sortOrder) {
                for (var ri = 0; ri < vector.length; ri++) {
                    var value = vector[ri];
                    if (value) {
                        var key = pkVector[ri];
                        keys.push(value);
                    }
                }
            }
            else if (vectorType == beachParty.VectorType.primaryKeyList) {
                keys = vector;
            }
            else {
                beachParty.cbUtils.error("getSortOrderKeys: unknown vectorType=" + vectorType);
            }
            return keys;
        };
        dataFrameClass.prototype.buildNumericCol = function (name, forceNumeric, forceCategory, allKeys) {
            //---- first, try dataFrame (map of data vectors) ----
            var colData = this.getVector(name, false);
            var colType = this.getColType(name);
            if (forceCategory) {
                colType = "string";
            }
            var fieldInfo = (this._wdParams) ? this._wdParams.getField(name) : null;
            var desc = (fieldInfo) ? fieldInfo.description : "";
            //---- buildColInfo relies on numericVector, so build it first ----
            var numericVector = dataFrameClass.buildNumericColFromVector(name, colData, colType, forceNumeric, forceCategory, allKeys, this._wdParams);
            //---- now, build and set colInfo ----
            //var colInfo = this.buildColInfo(name, numericVector);
            //numericVector.colInfo = colInfo;
            return numericVector;
        };
        /**
         * Fill in missing information in col, using wdParams and numeric vector.
         * @param col
         * @param numericVector
         */
        dataFrameClass.prototype.completeColInfo = function (col, numericVector) {
            //---- numericVector has already calculated the underlying colType for us ----
            col.colType = numericVector.colType;
            var fieldInfo = (this._wdParams) ? this._wdParams.getField(col.name) : null;
            if (fieldInfo) {
                if (!col.desc) {
                    col.desc = fieldInfo.description;
                }
                if (!col.calcFieldExp) {
                    col.calcFieldExp = fieldInfo.calcFieldExp;
                }
            }
            var mm = this.getFilteredKeysMinMax(numericVector, col.name, col.colType);
            var stats = col.stats;
            if (!stats) {
                var keyLength = (mm.keys) ? mm.keys.length : 0;
                col.stats = new beachParty.ColStats(mm.min, mm.max, mm.nanCount, keyLength, mm.keys);
            }
            else {
                //if (stats.min === undefined)
                //{
                //    stats.min = mm.min;
                //}
                //if (stats.max === undefined)
                //{
                //    stats.max = mm.max;
                //}
                //if (stats.nanCount === undefined)
                //{
                //    stats.nanCount = mm.nanCount;
                //}
                //if (stats.sortedKeys === undefined)
                //{
                //    stats.sortedKeys = mm.keys;
                //}
                //if (stats.keyCount === undefined)
                //{
                //    stats.keyCount = stats.sortedKeys.length;
                //}
                //---- always update stats so they reflect the current filter setting ----
                stats.min = mm.min;
                stats.max = mm.max;
                stats.nanCount = mm.nanCount;
                stats.sortedKeys = mm.keys;
                stats.keyCount = (stats.sortedKeys) ? stats.sortedKeys.length : 0;
            }
            col.infoIsComplete = true;
        };
        dataFrameClass.prototype.getFileName = function () {
            return this._wdParams.dataName;
        };
        dataFrameClass.prototype.clearFilteredColInfosCache = function () {
            //---- cache for filtered colInfos not currently implemented ----
        };
        dataFrameClass.prototype.getIndexOfCol = function (name) {
            var index = -1;
            for (var i = 0; i < this._columns.length; i++) {
                var col = this._columns[i];
                if (col.name == name) {
                    index = i;
                    break;
                }
            }
            return index;
        };
        /**
         * Get a copy of the colInfo for the specified column name.
         * @param colName
         */
        dataFrameClass.prototype.buildColumnInfo = function (colName, numVector) {
            var value = null;
            var col = this._colMap[colName];
            if (numVector && col) {
                var useFilter = this._isFilterActive;
                if (!col.infoIsComplete || useFilter) {
                    this._getColInfoWorkCount++;
                    this.completeColInfo(col, numVector);
                }
            }
            if (col) {
                //---- make a copy of DataColumn and return it as ColInfo ----
                var value = vp.utils.copyMap(col, false);
                value.data = null;
            }
            return value;
        };
        dataFrameClass.prototype.getFilteredKeysMinMax = function (numericVector, colName, colType) {
            var keys = null;
            var min = null;
            var max = null;
            var nanCount = 0;
            //---- must specify TRUE here to get numeric/date values in their correct form ----
            var getNumeric = (colType != "string");
            var vector = this.getFilteredInVector(colName, getNumeric, numericVector);
            if (colType == "string") {
                keys = vector.distinct(); // honor current filter
                min = 0;
                max = keys.length - 1;
                nanCount = 0; // in the future, we might want to count empty strings as NAN's
            }
            else {
                keys = null;
                min = vector.min();
                max = vector.max();
                nanCount = vector.count(isNaN);
                vp.utils.debug("colName=" + colName + ", vector.length=" + vector.length + ", nanCount=" + nanCount);
            }
            return { keys: keys, min: min, max: max, nanCount: nanCount };
        };
        /**
         * Caution - this returns a vector of column values where the FILTERED OUT values have been removed.  This will break code that is expecting
         * a FULL vector (indexes will be wrong).
         * @param colName
         * @param asNumeric
         * @param numericVector
         */
        dataFrameClass.prototype.getFilteredInVector = function (colName, asNumeric, numericVector) {
            if (asNumeric) {
                if (!numericVector) {
                    numericVector = this.getNumericVector(colName);
                }
                var rawVector = numericVector.values;
            }
            else {
                var rawVector = this.getVector(colName, false);
            }
            var filter = this.getFilteredVector(false);
            var newVector = [];
            for (var i = 0; i < rawVector.length; i++) {
                if (!filter || !filter[i]) {
                    newVector.push(rawVector[i]);
                }
            }
            return newVector;
        };
        dataFrameClass.prototype.getFilteredVector = function (invalidateNumericCache) {
            var vector = this.getVector(beachParty.filteredName, invalidateNumericCache);
            return vector;
        };
        dataFrameClass.buildNumericColFromVector = function (name, colData, colType, forceNumeric, forceCategory, allKeys, wdParams) {
            var count = (colData) ? colData.length : 0;
            var newData = new Float32Array(count);
            var numericVector = new beachParty.NumericVector(newData, name, colType);
            if (colData && colData.length) {
                if (colType == "number") {
                    //---- transfer NUMBER values, converting strings to parsed numbers ----
                    for (var i = 0; i < colData.length; i++) {
                        /// number represenations:
                        ///     valid number string --> normal numbers
                        ///     blanks  --> NaN 
                        ///     invalid number string --> NaN
                        //var value: any = +colData[i];
                        var strValue = colData[i];
                        if (strValue === "") {
                            //---- NA (missing) value ----
                            var numValue = NaN;
                        }
                        else {
                            //---- NUMBER or STRING value ----
                            var numValue = +strValue;
                        }
                        newData[i] = numValue;
                    }
                }
                else if (colType == "date") {
                    //---- transfer DATE values, converting strings to parsed date numbers and date objects to date numbers ----
                    for (var i = 0; i < colData.length; i++) {
                        var value = colData[i];
                        //---- BLANK and NON-DATE strings are converted here to NaN's ----
                        if (typeof value == "string") {
                            value = Date.parse(value);
                        }
                        else {
                            value = +value;
                        }
                        newData[i] = value;
                    }
                }
                else {
                    //---- string values ----
                    if (forceNumeric) {
                        var sortedKeys = dataFrameClass.getSortedKeys(name, wdParams);
                        if (sortedKeys) {
                            //---- overrides allKeys ----
                            allKeys = sortedKeys;
                        }
                        //---- convert string to numeric, using dictionary keys & their indexes ----
                        var keyIndexs = dataFrameClass.getStringKeyIndexes(colData, numericVector, allKeys);
                        if (keyIndexs && keyIndexs.length) {
                            newData = keyIndexs;
                        }
                    }
                    else {
                        throw "Error: cannot put string values into a NumericVector";
                    }
                }
            }
            return numericVector;
        };
        dataFrameClass.getStringKeyIndexes = function (data, numericVector, allKeys) {
            var indexesByKey = {};
            var keysByIndex = {};
            var keyIndexes = [];
            var rowsByKey = {};
            var keysByRow = [];
            var sortedKeys = []; // a list of keys in their desired sort order
            var nextKeyId = 0;
            if (data && data.length) {
                if (!allKeys) {
                    //---- pull and sort keys up front to ensure sorted key indexes match indexes used in data ----
                    allKeys = data.groupBy().map(function (g) { return g.key; });
                    sortedKeys = allKeys.sort();
                }
                else {
                    sortedKeys = allKeys.slice(0); // make copy of allKeys
                }
                //---- pre-assign a full set of keys ----
                for (var i = 0; i < sortedKeys.length; i++) {
                    var ak = sortedKeys[i];
                    indexesByKey[ak] = nextKeyId;
                    keysByIndex[nextKeyId] = ak;
                    nextKeyId++;
                }
                //---- convert values from string to number (key index) ----
                for (var i = 0; i < data.length; i++) {
                    var key = data[i] + "";
                    var keyValue = indexesByKey[key];
                    if (keyValue === undefined) {
                        keyValue = nextKeyId++;
                        indexesByKey[key] = keyValue;
                        keysByIndex[keyValue] = key;
                        sortedKeys.push(key);
                    }
                    var rows = rowsByKey[key];
                    if (rows === undefined || !vp.utils.isArray(rows)) {
                        rows = [];
                        rowsByKey[key] = rows;
                    }
                    rows.push(i);
                    keysByRow[i] = key;
                    keyIndexes.push(keyValue);
                }
            }
            numericVector.values = keyIndexes;
            numericVector.keyInfo = new beachParty.KeyInfo(sortedKeys.length, indexesByKey, keysByIndex, rowsByKey, keysByRow, sortedKeys);
            return keyIndexes;
        };
        dataFrameClass.prototype.aggData = function (statInfo) {
            var result = null;
            var statType = statInfo.statType;
            if (statType == beachParty.StatType.count) {
                result = this._recordCount;
            }
            else {
                var colName = statInfo.colName;
                var statTransform = statInfo.colValueTransform;
                var statName = (statType != beachParty.StatType.none) ? beachParty.StatType[statType] : "sum";
                var aggregator = vp.data.createAggregator(statName);
                aggregator.init();
                var vector = this.getVector(colName, false);
                for (var i = 0; i < vector.length; i++) {
                    var value = vector[i];
                    if (statTransform) {
                        value = statTransform(value);
                    }
                    aggregator.process(value);
                }
                result = aggregator.getResult();
            }
            return result;
        };
        dataFrameClass.prototype.getDataColumns = function () {
            return this._columns;
        };
        return dataFrameClass;
    }(beachParty.dataChangerClass));
    beachParty.dataFrameClass = dataFrameClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    dataLoader.ts - loads data (from server if needed) and return a dataFrame.  Applies wdParams as specified.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var dataLoaderClass = (function () {
        function dataLoaderClass(preloadMgr, colsOnDemand, isCachingWebFiles) {
            this._preloadMgr = preloadMgr;
            this._colsOnDemand = colsOnDemand;
            this._isCachingWebFiles = isCachingWebFiles;
        }
        dataLoaderClass.prototype.expandRecordsByKeywordColumn = function (data, colName) {
            if (!vp.utils.isArray(data)) {
                //---- convert DataFrame to JSON, for easier expansion ----
                var df = new beachParty.dataFrameClass(data);
                data = df.toJson();
            }
            var newData = [];
            var colNames = null;
            for (var i = 0; i < data.length; i++) {
                var record = data[i];
                if (colNames == null) {
                    colNames = vp.utils.keys(record);
                }
                var kwValue = record[colName];
                var keyWords = this.getKeywordsFromCommaString(kwValue);
                //---- generate a record for each keyword ----
                for (var k = 0; k < keyWords.length; k++) {
                    var kw = keyWords[k];
                    if (!isNaN(+kw)) {
                        //---- special treatment for keywords that are numbers so that JavaScript doesn't mess things up ----
                        kw += " "; //= "__" + kw;
                    }
                    var newRecord = {};
                    newRecord._origRecordIndex = i;
                    newRecord._copyIndex = k;
                    newRecord.origKeywordValues = kwValue;
                    //---- transfer all fields from record ----
                    for (var c = 0; c < colNames.length; c++) {
                        var cn = colNames[c];
                        if (cn != "") {
                            newRecord[cn] = record[cn];
                        }
                    }
                    //---- update the keyword column ----
                    newRecord[colName] = kw;
                    newData.push(newRecord);
                }
            }
            return newData;
        };
        dataLoaderClass.prototype.loadColumns = function (colMap, loadList) {
            this._csvColLoader.loadColumns(colMap, loadList);
        };
        dataLoaderClass.prototype.getRecord = function (recordIndex, colNames) {
            return this._csvColLoader.getRecord(recordIndex, colNames);
        };
        dataLoaderClass.prototype.getKeywordsFromCommaString = function (str) {
            var parts = str.split(',');
            var keyWords = [];
            for (var p = 0; p < parts.length; p++) {
                var part = parts[p].trim(); //.toLowerCase();
                if (part != "") {
                    keyWords.push(part);
                }
            }
            return keyWords;
        };
        dataLoaderClass.prototype.loadDataFrameFromText = function (text, wdParams) {
            var anyData = null;
            if (text.startsWith("[") || text.startsWith("}")) {
                anyData = JSON.parse(text);
            }
            else {
                var separator = wdParams.separator;
                var hasHeader = wdParams.hasHeader;
                if (this._colsOnDemand) {
                    var csvColLoader = new beachParty.csvColLoaderClass(text, hasHeader, separator, true, true);
                    this._csvColLoader = csvColLoader;
                    anyData = csvColLoader.buildDataFrameWithEmptyVectors();
                }
                else {
                    anyData = beachParty.csvToJson(text, hasHeader, separator, true);
                }
            }
            return anyData;
        };
        dataLoaderClass.prototype.addSysCol = function (dataFrame, name, colType, desc, vector) {
            var colInfo = new beachParty.ColInfo(name, desc, colType, null);
            dataFrame.addColumn(colInfo, vector);
        };
        dataLoaderClass.prototype.addSystemColumns = function (dataFrame, wdParams) {
            this.addSysCol(dataFrame, beachParty.selectedName, "number", "System column where value=1 means the record is selected");
            this.addSysCol(dataFrame, beachParty.filteredName, "number", "System column where value=1 means the record is filtered OUT");
            this.addSysCol(dataFrame, beachParty.randomXName, "number", "System column to provide a random X value for layout");
            this.addSysCol(dataFrame, beachParty.randomYName, "number", "System column to provide a random Y value for layout");
            //---- does table have a pre-defined primary key? ----
            if (wdParams.primaryKeyCol) {
                var pkName = wdParams.primaryKeyCol;
                var pkVector = dataFrame.getVector(pkName, false);
                //---- create an alias column named "primaryKeyName" that points to the same vector as pkName ----
                this.addSysCol(dataFrame, beachParty.primaryKeyName, "number", "System column that uniquely defines each record", pkVector);
            }
            else {
                //---- if no primary key specified, use record index ----
                this.addSysCol(dataFrame, beachParty.primaryKeyName, "number");
                var primaryKeys = dataFrame.getVector(beachParty.primaryKeyName, false);
                for (var i = 0; i < primaryKeys.length; i++) {
                    primaryKeys[i] = i;
                }
            }
            //---- build randomX, randomY ----
            var randomX = dataFrame.getVector(beachParty.randomXName, false);
            var randomY = dataFrame.getVector(beachParty.randomYName, false);
            for (var i = 0; i < primaryKeys.length; i++) {
                randomX[i] = Math.random();
                randomY[i] = Math.random();
            }
            dataFrame.rebuildPrimaryKeyIndex();
        };
        /** open the specified known data file, async.  if "multiValueCol" is true, replicate records
            so that we have 1 record for each value in the specified column of each original record. */
        dataLoaderClass.prototype.loadKnownAsyncCore = function (name, multiValueCol, callback) {
            //vp.utils.debug("loadKnownAsync: name=" + name);
            var lowName = name.toLowerCase(); // support user typing of name with wrong case
            var preload = this._preloadMgr.getFilePreload(lowName);
            if (!preload) {
                throw "Error: unknown known file: " + lowName;
            }
            //---- ensure this has a dataName set ----
            //if (!preload.dataName)
            //{
            //    preload.dataName = preload.name;
            //}
            var anyWindow = window;
            if (lowName == "knowndata") {
                var jsonData = this._preloadMgr.getPreloads();
                var df = beachParty.dataFrameClass.jsonToDataFrame(jsonData);
                var pdResult = this.processData(df.getDataColumns(), preload, multiValueCol);
                if (callback) {
                    callback(pdResult.origDf, pdResult.postDf, pdResult.wdParams);
                }
            }
            else {
                this.openPreloadAsyncCore(preload, multiValueCol, callback);
            }
        };
        /** convert "anyData" into a dataFrame, and then apply wdParams. */
        dataLoaderClass.prototype.processData = function (anyData, wdParams, multiValueCol) {
            ////---- did caller request record duplication to expand each keyword to its own record? ----
            //if (multiValueCol || wdParams.multiValueCol)
            //{
            //    anyData = this.expandRecordsByKeywordColumn(anyData, multiValueCol);
            //}
            //---- convert data (in 1 of N formats) to a dataFrame object ----
            if (vp.utils.isString(anyData)) {
                //---- STRING ----
                anyData = this.loadDataFrameFromText(anyData, wdParams);
            }
            if (vp.utils.isArray(anyData)) {
                var firstItem = (anyData.length > 0) ? anyData[0] : null;
                if (firstItem && firstItem.ctr == "DataColumn") {
                    //---- DATA COLUMN [] ----
                    var df = new beachParty.dataFrameClass(anyData);
                }
                else {
                    //---- JSON [] ----
                    df = beachParty.dataFrameClass.jsonToDataFrame(anyData);
                }
            }
            else if (anyData instanceof beachParty.dataFrameClass) {
                df = anyData;
            }
            else if (anyData.ctr == "dataFrameClass") {
                df = anyData;
            }
            else {
                //---- VECTOR MAP ----
                var keys = vp.utils.keys(anyData);
                var columns = [];
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var data = anyData[key];
                    var colType = vp.data.getDataType(data);
                    var sortedKeys = null;
                    if (colType == "string") {
                        sortedKeys = data.distinct();
                    }
                    var col = new beachParty.DataColumn(key, null, colType, sortedKeys);
                    col.data = anyData[key];
                    columns.push(col);
                }
                var df = new beachParty.dataFrameClass(columns);
            }
            //---- apply WORKING DATA PARAMS ----
            var origDf = df;
            if (wdParams.fieldList && wdParams.fieldList.length) {
                df = df.makeFields(wdParams.fieldList, wdParams.mergeFieldList);
            }
            if (wdParams.prefilter) {
                df = null; //  df.applyPrefilter(wdParams.prefilter);
            }
            if (wdParams.dataAggregation) {
                var jsonRecords = this.runLocalAgg(wdParams);
            }
            df.setWdParams(wdParams);
            this.addSystemColumns(df, wdParams);
            return { origDf: origDf, postDf: df, wdParams: wdParams };
        };
        dataLoaderClass.prototype.runLocalAgg = function (wdParams) {
            var jsonRecords = null;
            //if (this._appMgr)
            //{
            //    var localAgg = this._appMgr._localAgg;
            //    var aggResult = localAgg.runQuery(wdParams.dataAggregation);
            //    var jsonRecords = aggResult.data;
            //}
            return jsonRecords;
        };
        dataLoaderClass.prototype.setWdpResult = function (wdp, aggResult) {
            var aggResult = new beachParty.AggResult();
            //---- transfer all properties but the data ----
            aggResult.wasSampled = aggResult.wasSampled;
            aggResult.wasAggregated = aggResult.wasAggregated;
            aggResult.trueRecordCount = aggResult.trueRecordCount;
            aggResult.aggFilteredRecordCount = aggResult.aggFilteredRecordCount;
            aggResult.data = null;
            wdp.aggResult = aggResult;
        };
        dataLoaderClass.prototype.openPreloadAsyncCore = function (wdParams, multiValueCol, callback) {
            var _this = this;
            var path = wdParams.filePath;
            var fileName = (wdParams.dataName) ? wdParams.dataName : path;
            if (wdParams.fileType == beachParty.FileType.sql) {
                if (wdParams.dataAggregation) {
                    beachParty.fileAccess.readSqlTableAgg(path, wdParams.tableName, wdParams.queryString, wdParams.dataAggregation, function (sqlResult) {
                        var dataFrame = sqlResult.data;
                        var keys = vp.utils.keys(dataFrame);
                        var firstKey = keys[0];
                        var recordCount = dataFrame[firstKey].length;
                        vp.utils.debug("openKnownAsync SUCCEEDED: columns=" + keys.length + ", records=" + recordCount);
                        var pdResult = _this.processData(dataFrame, wdParams, multiValueCol);
                        var wdp = pdResult.wdParams;
                        _this.setWdpResult(wdp, sqlResult);
                        if (callback) {
                            callback(pdResult.origDf, pdResult.postDf, pdResult.wdParams);
                        }
                    }, function (e) {
                        beachParty.cbUtils.onFileOpenError(fileName, e.response);
                    });
                }
                else {
                    beachParty.fileAccess.readSqlTable(path, wdParams.tableName, wdParams.queryString, wdParams.dataSampling, function (sqlResult) {
                        var dataFrame = sqlResult.data;
                        var keys = vp.utils.keys(dataFrame);
                        var firstKey = keys[0];
                        var recordCount = dataFrame[firstKey].length;
                        vp.utils.debug("openKnownAsync SUCCEEDED: columns=" + keys.length + ", records=" + recordCount);
                        var pdResult = _this.processData(dataFrame, wdParams, multiValueCol);
                        var wdp = pdResult.wdParams;
                        _this.setWdpResult(wdp, sqlResult);
                        if (callback) {
                            callback(pdResult.origDf, pdResult.postDf, pdResult.wdParams);
                        }
                    }, function (e) {
                        beachParty.cbUtils.onFileOpenError(fileName, e.response);
                    });
                }
            }
            else {
                this.loadDataFromService(path, fileName, wdParams, multiValueCol, callback);
            }
        };
        dataLoaderClass.prototype.loadDataFromService = function (path, fileName, wdParams, multiValueCol, callback) {
            var _this = this;
            var separator = wdParams.separator;
            if (!separator) {
                separator = (path.endsWith(".csv")) ? "," : "\t";
                wdParams.separator = separator;
            }
            if (this._colsOnDemand) {
                //---- for consistency (and colsOnDemand feature), just read the plain text and parse the text on the client ----
                var format = null;
                separator = null;
            }
            else {
                var format = (wdParams && wdParams.fileType == beachParty.FileType.json) ? beachParty.fileFormat.json : beachParty.fileFormat.csv;
            }
            var csvOptions = { hasHeader: wdParams.hasHeader, sepChar: separator, findTypes: true };
            var convertToDataFrameClass = false; // just return as map of named vectors 
            if (path.startsWith("http://") || path.startsWith("https://")) {
                fn = path;
            }
            else {
                var fn = beachParty.bpDataPath() + "/DataFiles/" + path;
            }
            //---- prevent caching on server ----
            //fn += "?" + Date.now();       
            var localAgg = false; // (this._appMgr) ? this._appMgr._localAgg : null;
            var tryCache = (!wdParams || wdParams.canLoadFromCache);
            if (tryCache) {
                var strCacheEntry = beachParty.localStorageMgr.get(beachParty.StorageType.dataFile, beachParty.StorageSubType.web, path);
                if (strCacheEntry) {
                    var cacheEntry = JSON.parse(strCacheEntry);
                    var dataFrameOrText = cacheEntry.data;
                    //---- always give full data to localAgg ----
                    //if (this._appMgr)
                    //{
                    //    this._appMgr._localAgg.onLocalDataLoaded(dataFrameOrText);
                    //}
                    var pdResult = this.processData(dataFrameOrText, wdParams, multiValueCol);
                    if (callback) {
                        callback(pdResult.origDf, pdResult.postDf, pdResult.wdParams);
                    }
                }
            }
            if (!dataFrameOrText) {
                //---- not found in cache ----
                beachParty.addTrace("serverRequest", path, beachParty.TraceEventType.start);
                beachParty.fileAccess.readFile(fn, format, csvOptions, function (dataFrameOrText) {
                    beachParty.addTrace("serverResponse", path, beachParty.TraceEventType.end);
                    //---- STORE new data in LS CACHE ----
                    if (wdParams.canLoadFromCache && wdParams.fileSource == "url" && _this._isCachingWebFiles) {
                        var obj = { data: dataFrameOrText, wdParams: wdParams };
                        var value = JSON.stringify(obj);
                        beachParty.localStorageMgr.save(beachParty.StorageType.dataFile, beachParty.StorageSubType.web, path, value);
                    }
                    var pdResult = _this.processData(dataFrameOrText, wdParams, multiValueCol);
                    if (callback) {
                        callback(pdResult.origDf, pdResult.postDf, pdResult.wdParams);
                    }
                }, function (e) {
                    beachParty.cbUtils.onFileOpenError(fileName, e.response);
                }, false, convertToDataFrameClass);
            }
        };
        return dataLoaderClass;
    }());
    beachParty.dataLoaderClass = dataLoaderClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    dataMgr.ts - loads and manages data streams used by BeachParty.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    //---- keep in sync with same names in dataServerApp/DataTransformer.cs ----
    beachParty.selectedName = "_selected";
    beachParty.filteredName = "_filtered";
    beachParty.primaryKeyName = "_primaryKey";
    beachParty.randomXName = "_randomX";
    beachParty.randomYName = "_randomY";
    beachParty.systemColNames = [beachParty.selectedName, beachParty.filteredName, beachParty.primaryKeyName, beachParty.randomXName, beachParty.randomYName];
    /** manages:
        - server data requests
        - client-side data requests
        - selection
        - filtering
    */
    var dataMgrClass = (function (_super) {
        __extends(dataMgrClass, _super);
        function dataMgrClass(preloadMgr, isClientEdition, isCachingWebFiles) {
            var _this = this;
            _super.call(this);
            this._fn = null;
            //private _colMappings: any = {};
            this._recordCount = 0;
            this._selectedCount = 0;
            this._filteredInCount = 0;
            this._wdParams = null;
            this._colsOnDemand = false;
            /// selectMode logically belongs on the client, but since the engine processes events from the chart exes, 
            /// we keep it here.  this may change in the future.
            //private _selectMode = SelectMode.toggle;
            //---- events ----
            this.onDataLoadStart = new beachParty.bpEvent();
            this.onDataLoadComplete = new beachParty.bpEvent();
            this.onDataChange = new beachParty.bpEvent();
            this._preloadMgr = preloadMgr;
            this._isClientEdition = isClientEdition;
            this._isCachingWebFiles = isCachingWebFiles;
            //---- don't trip over NULL dataFrame ----
            this._dataFrame = new beachParty.dataFrameClass([]);
            this._shareMgr = new beachParty.shareMgrClass(function (sd) {
                if (_this.hasSelectionChanged(sd.selectedPrimaryKeys)) {
                    _this.setSelectionDirect(sd.selectedPrimaryKeys, "localstorage");
                }
            });
        }
        dataMgrClass.prototype.colsOnDemand = function () {
            return this._colsOnDemand;
        };
        dataMgrClass.prototype.getPrimaryKeys = function (applySelection, applyFilter) {
            var rawVector = this._dataFrame.getVector(beachParty.primaryKeyName, false);
            var selected = (applySelection) ? this.getSelectedVector(false) : null;
            var filter = (applyFilter) ? this.getFilteredVector(false) : null;
            var newVector = [];
            if (rawVector) {
                for (var i = 0; i < rawVector.length; i++) {
                    if ((!selected || selected[i]) && (!filter || !filter[i])) {
                        newVector.push(rawVector[i]);
                    }
                }
            }
            return newVector;
        };
        dataMgrClass.prototype.hasSelectionChanged = function (keyList) {
            var hasChanged = true;
            var selVector = this.getSelectedVector(false);
            var vCount = vector.countOn(selVector);
            //---- quickest check - make sure # of 1's in vector matches length of keyList ----
            if (vCount == keyList.length) {
                var pktoIndex = this._dataFrame.getPkToVectorIndex();
                var hasChanged = false;
                for (var i = 0; i < keyList.length; i++) {
                    var key = keyList[i];
                    var index = pktoIndex[key];
                    if (!selVector[index]) {
                        hasChanged = true;
                        break;
                    }
                }
            }
            return hasChanged;
        };
        dataMgrClass.prototype.setDataDirect = function (dataColumns, wdParams) {
            vp.utils.debug("setDataDirect: calling loader");
            var loader = new beachParty.dataLoaderClass(this._preloadMgr, this._colsOnDemand, this._isCachingWebFiles);
            var result = loader.processData(dataColumns, wdParams);
            vp.utils.debug("setDataDirect: calling setDataAndInfo");
            this.setDataAndInfo(result.origDf, result.postDf, result.wdParams, loader);
            vp.utils.debug("setDataDirect ending");
        };
        dataMgrClass.prototype.loadKnownAsync = function (name, wdParams, callback) {
            var _this = this;
            var loader = new beachParty.dataLoaderClass(this._preloadMgr, this._colsOnDemand, this._isCachingWebFiles);
            loader.loadKnownAsyncCore(name, null, function (origDf, postDf, wdParams) {
                _this.setDataAndInfo(origDf, postDf, wdParams, loader);
                if (callback) {
                    callback(postDf, wdParams);
                }
            });
        };
        //---- subclass should supply this ----
        dataMgrClass.prototype.openKnownFile = function (name, fromUI, callback) {
        };
        //---- subclass should supply this ----
        dataMgrClass.prototype.autoloadFile = function (wdParams, callback) {
        };
        dataMgrClass.prototype.openPreloadAsync = function (wdParams, callback) {
            var _this = this;
            var loader = new beachParty.dataLoaderClass(this._preloadMgr, this._colsOnDemand, this._isCachingWebFiles);
            loader.openPreloadAsyncCore(wdParams, null, function (origDf, postDf, wdParams) {
                _this.setDataAndInfo(origDf, postDf, wdParams, loader);
                if (callback) {
                    callback(postDf);
                }
            });
        };
        /**
         *  returns column values for all selected rows, ignoring the filter.
         * @param names
         * @param asNumeric
         * @param callback
         */
        dataMgrClass.prototype.getSelectedRowsMultiCol = function (names, asNumeric, callback) {
            var nv = {};
            for (var i = 0; i < names.length; i++) {
                var name = names[i];
                nv[name] = this.getSelectedRowsSingleCol(name, asNumeric);
            }
            callback(nv);
        };
        /**
         * returns values of a single column for all selected rows, optionally applying a filter.

         * @param colName
         * @param asNumeric
         */
        dataMgrClass.prototype.getSelectedRowsSingleCol = function (colName, asNumeric, applyFilter) {
            if (asNumeric) {
                var rawVector = this._dataFrame.getNumericVector(colName).values;
            }
            else {
                var rawVector = this._dataFrame.getVector(colName, false);
            }
            var selected = this.getSelectedVector(false);
            var newVector = [];
            var filter = (applyFilter) ? this.getFilteredVector(false) : null;
            for (var i = 0; i < rawVector.length; i++) {
                if (selected[i] && (!filter || filter[i])) {
                    newVector.push(rawVector[i]);
                }
            }
            return newVector;
        };
        dataMgrClass.prototype.getOrigColInfos = function () {
            return this._origColInfos;
        };
        dataMgrClass.prototype.getColKeyCounts = function (colName, sortByCount, isDescendingSort, maxKeys, callback) {
            var rawVector = this._dataFrame.getVector(colName, false);
            var keyCountList = rawVector.groupBy().map(function (g) { return { key: g.key, count: g.values.length }; });
            if (sortByCount) {
                var sortedList = keyCountList.orderByNum(function (g) { return g.count; });
            }
            else {
                var sortedList = keyCountList.orderByStr(function (g) { return g.key; });
            }
            if (isDescendingSort) {
                sortedList = sortedList.reverse();
            }
            if (sortedList.length > maxKeys) {
                sortedList = sortedList.slice(0, maxKeys - 1);
            }
            if (callback) {
                callback(sortedList);
            }
            return sortedList;
        };
        dataMgrClass.prototype.getDataVectors = function (names, asNumeric, callback) {
            var nv = {};
            for (var i = 0; i < names.length; i++) {
                var name = names[i];
                nv[name] = this.getFilteredInVector(name, asNumeric);
            }
            callback(nv);
        };
        dataMgrClass.prototype.getFilteredInVector = function (colName, asNumeric) {
            return this._dataFrame.getFilteredInVector(colName, asNumeric);
        };
        dataMgrClass.prototype.getColInfos = function (applyFilter) {
            var colInfos = this._dataFrame.getColInfos();
            return colInfos;
        };
        dataMgrClass.prototype.isFilterInIuse = function () {
            var inUse = (this._filteredInCount != this._recordCount);
            return inUse;
        };
        dataMgrClass.prototype.buildColInfos = function (df) {
            df.clearFilteredColInfosCache();
            var colInfos = df.getColInfos();
            return colInfos;
        };
        dataMgrClass.prototype.isFileLoaded = function (wdp) {
            var isLoaded = false;
            var wdpCurrent = this._wdParams;
            if (wdpCurrent) {
                isLoaded = (wdpCurrent.filePath == wdp.filePath);
                if (isLoaded) {
                    //---- check to see if field list matches ----
                    if (!beachParty.wdCompare.fieldListsMatch(wdpCurrent.fieldList, wdp.fieldList)) {
                        isLoaded = false;
                    }
                }
                if (isLoaded) {
                    if (wdp.dataAggregation != wdpCurrent.dataAggregation) {
                        isLoaded = false;
                    }
                }
                if (isLoaded) {
                    if (wdp.dataSampling != wdpCurrent.dataSampling) {
                        isLoaded = false;
                    }
                }
            }
            return isLoaded;
        };
        dataMgrClass.prototype.onLocalStorageChange = function () {
            this._shareMgr.onLocalStorageChange();
        };
        dataMgrClass.prototype.getShareMgr = function () {
            return this._shareMgr;
        };
        dataMgrClass.prototype.getDataFrame = function () {
            return this._dataFrame;
        };
        dataMgrClass.prototype.getFilename = function () {
            return this._fn;
        };
        dataMgrClass.prototype.searchExactMatchNumber = function (selection, data, value, maxValue) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (isNaN(+itemValue)) {
                    //---- must do an isNan() test on itemValue ----
                    selection[i] = isNaN(+value) ? 1 : 0;
                }
                else if (itemValue == value) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchExactMatchString = function (selection, data, value, maxValue) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (itemValue == value) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchNotEqual = function (selection, data, value, maxValue) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (isNaN(+itemValue)) {
                    //---- must do an isNan() test on itemValue ----
                    selection[i] = isNaN(+value) ? 0 : 1;
                }
                else if (itemValue != value) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchContains = function (selection, data, value, maxValue) {
            value = value + ""; // force to a string
            for (var i = 0; i < data.length; i++) {
                var str = data[i] + "";
                if (str.contains(value)) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchStartsWith = function (selection, data, value, maxValue) {
            value = value + ""; // force to a string
            for (var i = 0; i < data.length; i++) {
                var str = data[i] + "";
                if (str.startsWith(value)) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchGreaterThan = function (selection, data, value, maxValue, isString) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (itemValue > value) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchGreaterThanEqual = function (selection, data, value, maxValue, isString) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (itemValue >= value) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchLessThan = function (selection, data, value, maxValue, isString) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (itemValue < value) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchLessThanEqual = function (selection, data, value, maxValue, isString) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (itemValue <= value) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchBetweenInclusive = function (selection, data, value, maxValue, isString) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (isNaN(+itemValue)) {
                    //---- must do an isNan() test on itemValue ----
                    selection[i] = isNaN(+value) ? 1 : 0;
                }
                else if (itemValue >= value && itemValue <= maxValue) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchGtrValueAndLeqValue2 = function (selection, data, value, maxValue, isString) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (isNaN(+itemValue)) {
                    //---- must do an isNan() test on itemValue ----
                    selection[i] = isNaN(+value) ? 1 : 0;
                }
                else if (itemValue > value && itemValue <= maxValue) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchGeqValueAndLessValue2 = function (selection, data, value, maxValue, isString) {
            for (var i = 0; i < data.length; i++) {
                var itemValue = data[i];
                if (isNaN(+itemValue)) {
                    //---- must do an isNan() test on itemValue ----
                    selection[i] = isNaN(+value) ? 1 : 0;
                }
                else if (itemValue >= value && itemValue < maxValue) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.searchColValueByKeys = function (selection, data, otherKeys) {
            for (var i = 0; i < data.length; i++) {
                var strKey = data[i] + "";
                if (otherKeys.indexOf(strKey) > -1) {
                    selection[i] = 1;
                }
            }
        };
        dataMgrClass.prototype.dateToNumber = function (value) {
            var numValue;
            if (vp.utils.isString(value)) {
                var dt = new Date(value);
                numValue = +dt;
            }
            else {
                numValue = +value;
            }
            return numValue;
        };
        dataMgrClass.prototype.runSearchQuery = function (spList) {
            var matchVector = null;
            for (var i = 0; i < spList.length; i++) {
                var sp = spList[i];
                var mvSingle = this.runSearchNode(sp);
                if (i == 0) {
                    matchVector = mvSingle;
                }
                else {
                    //---- AND them together ----
                    for (var i = 0; i < matchVector.length; i++) {
                        matchVector[i] = (matchVector[i] && mvSingle[i]);
                    }
                }
            }
            var sp = spList[0];
            var searchAction = (sp.searchAction === undefined) ? beachParty.SearchAction.selectMatches : sp.searchAction;
            var selectMode = sp.selectMode;
            //if (selectMode === undefined)
            //{
            //    selectMode = this._selectMode;
            //}
            var matches = this.applyMatchVector(matchVector, searchAction, selectMode);
            return matches;
        };
        dataMgrClass.prototype.runSearchNode = function (sp) {
            var matches = null;
            var colName = sp.colName;
            if (colName) {
                matches = this.searchSingleColumn(sp);
            }
            else {
                var colInfos = this._dataFrame.getColInfos();
                //---- OR-together search from each string column ----
                for (var i = 0; i < colInfos.length; i++) {
                    var ci = colInfos[i];
                    //---- why did we used to limit this to strings? ----
                    //if (ci.colType == "string")
                    {
                        sp.colName = ci.name;
                        var oneMatch = this.searchSingleColumn(sp);
                        if (!matches) {
                            matches = oneMatch;
                        }
                        else {
                            //---- OR them together ----
                            for (var j = 0; j < matches.length; j++) {
                                matches[j] = (matches[j] || oneMatch[j]);
                            }
                        }
                    }
                }
            }
            return matches;
        };
        dataMgrClass.prototype.searchSingleColumn = function (sp) {
            var colName = sp.colName;
            var value = sp.minValue;
            var maxValue = sp.maxValue;
            var searchType = sp.searchType;
            var searchAction = (sp.searchAction === undefined) ? beachParty.SearchAction.selectMatches : sp.searchAction;
            if (value === "") {
                searchType = beachParty.TextSearchType.exactMatch;
            }
            var st = beachParty.TextSearchType[searchType];
            vp.utils.debug("search: colName=" + colName + ", value=" + value + ", maxValue=" + maxValue +
                ", searchType=" + st);
            var matchVector = vp.data.dataRepeat(0, this._recordCount);
            var colType = this._dataFrame.getColType(colName);
            if (sp.searchRawValues) {
                colType = "string";
            }
            //---- EXACT search uses original string values ----
            var isString = (colType == "string" || searchType == beachParty.TextSearchType.exactMatch || searchType == beachParty.TextSearchType.startsWith);
            if (isString) {
                //---- get original data vector ----
                var data = this._dataFrame.getVector(colName, false);
                if (!sp.caseSensitiveSearch && colType == "string") {
                    if (vp.utils.isArray(value)) {
                        for (var i = 0; i < value.length; i++) {
                            var val = value[i];
                            value[i] = val.toLowerCase();
                        }
                    }
                    else if (vp.utils.isString(value)) {
                        value = value.toLowerCase();
                    }
                    //---- make lowercase copy of data ----
                    var lowData = data.map(function (d) { return d.toLowerCase(); });
                    data = lowData;
                }
            }
            else {
                //---- get numeric form of vector ----
                var data = this._dataFrame.getNumericVector(colName, false).values.toArray();
            }
            if (colType == "number") {
                value = +value;
                maxValue = (maxValue !== null && maxValue !== undefined) ? +maxValue : value;
            }
            else if (colType == "date") {
                value = this.dateToNumber(value);
                maxValue = (maxValue !== null && maxValue !== undefined) ? this.dateToNumber(maxValue) : value;
            }
            if (vp.utils.isArray(value)) {
                this.searchColValueByKeys(matchVector, data, value);
            }
            else if (searchType == beachParty.TextSearchType.exactMatch) {
                if (colType == "string") {
                    this.searchExactMatchString(matchVector, data, value, maxValue);
                }
                else {
                    this.searchExactMatchNumber(matchVector, data, value, maxValue);
                }
            }
            else if (searchType == beachParty.TextSearchType.notEqual) {
                this.searchNotEqual(matchVector, data, value, maxValue);
            }
            else if (searchType == beachParty.TextSearchType.contains) {
                this.searchContains(matchVector, data, value, maxValue);
            }
            else if (searchType == beachParty.TextSearchType.startsWith) {
                this.searchStartsWith(matchVector, data, value, maxValue);
            }
            else if (searchType == beachParty.TextSearchType.greaterThan) {
                this.searchGreaterThan(matchVector, data, value, maxValue, isString);
            }
            else if (searchType == beachParty.TextSearchType.greaterThanEqual) {
                this.searchGreaterThanEqual(matchVector, data, value, maxValue, isString);
            }
            else if (searchType == beachParty.TextSearchType.lessThan) {
                this.searchLessThan(matchVector, data, value, maxValue, isString);
            }
            else if (searchType == beachParty.TextSearchType.lessThanEqual) {
                this.searchLessThanEqual(matchVector, data, value, maxValue, isString);
            }
            else if (searchType == beachParty.TextSearchType.betweenInclusive) {
                this.searchBetweenInclusive(matchVector, data, value, maxValue, isString);
            }
            else if (searchType == beachParty.TextSearchType.gtrValueAndLeqValue2) {
                this.searchGtrValueAndLeqValue2(matchVector, data, value, maxValue, isString);
            }
            else if (searchType == beachParty.TextSearchType.geqValueAndLessValue2) {
                this.searchGeqValueAndLessValue2(matchVector, data, value, maxValue, isString);
            }
            return matchVector;
        };
        dataMgrClass.prototype.applyMatchVector = function (matchVector, searchAction, selectMode) {
            var matches = null;
            if (searchAction == beachParty.SearchAction.returnMatches) {
                //---- return matches ----
                matches = [];
                //var dataView = this._appMgr.getDataView();
                var pkVector = this._dataFrame.getVector(beachParty.primaryKeyName, false);
                if (matchVector) {
                    for (var i = 0; i < matchVector.length; i++) {
                        if (matchVector[i]) {
                            var key = pkVector[i];
                            //---- TODO ----
                            var rc = null; // dataView.getShapeScreenRect(key);
                            var match = { primaryKey: key, rcBounds: rc };
                            matches.push(match);
                        }
                    }
                }
            }
            else {
                //---- update the selection from the matches ----
                //---- convert from list of 0/1 values to a list of "value=1" record indexes ----
                var selectedIndexes = [];
                if (matchVector) {
                    for (var i = 0; i < matchVector.length; i++) {
                        if (matchVector[i]) {
                            selectedIndexes.push(i);
                        }
                    }
                }
                this.updateSelectionFromVectorIndexes(selectedIndexes, selectMode);
                if (searchAction == beachParty.SearchAction.isolateMatches) {
                    this.isolateSelection();
                }
                else if (searchAction == beachParty.SearchAction.excludeMatches) {
                    this.excludeSelection();
                }
            }
            return matches;
        };
        //getColMappings()
        //{
        //    return this._colMappings;
        //}
        dataMgrClass.prototype.getPreload = function () {
            return this._wdParams;
        };
        /** data can be either JSON array, map of named vectors, or text string. */
        dataMgrClass.prototype.setDataAndInfo = function (origDf, postDf, wdParams, loader) {
            this._dataFrame = postDf;
            this._wdParams = wdParams;
            this._fn = wdParams.dataName;
            if (this._colsOnDemand) {
                postDf.loader(loader);
            }
            this._recordCount = postDf.getRecordCount();
            this.computeSelectedCount();
            this.computeFilteredCount();
            //---- build ORIG colInfos, based on full set of (unchanged) columns in table ----
            this._origColInfos = this.buildColInfos(origDf);
            ////---- build colInfos, based on SCRUBBED set of columns ----
            //this._colInfos = this.buildColInfos(postDf);
            this.onDataChanged("dataFrame");
            //this.onDataChanged("filtered");
            this.onDataChanged("colMappings");
            this.onDataChanged("fn");
            this._shareMgr.setFilename(wdParams.dataName);
        };
        dataMgrClass.prototype.requestBinData = function (md, callback) {
            var sortOptions = new beachParty.binSortOptionsClass();
            sortOptions.sortDirection = md.binSorting;
            sortOptions.sortByAggregateType = "count";
            var maxCount = 0;
            //---- create a NamedVector object for binHelper ----
            var nv = new beachParty.NamedVectors(this._recordCount);
            var dataFrame = this.getDataFrame();
            nv.x = dataFrame.getNumericVector(md.colName);
            nv.primaryKey = dataFrame.getNumericVector(beachParty.primaryKeyName);
            var binResult = beachParty.binHelper.createBins(nv, "x", md.binCount, md.binCount, md.forceCategory, true, true, sortOptions, null, md.useNiceNumbers, md);
            callback(binResult);
        };
        dataMgrClass.prototype.computeSelectedCount = function () {
            var select = this.getSelectedVector(false);
            this._selectedCount = vector.countOn(select);
        };
        dataMgrClass.prototype.computeFilteredCount = function () {
            var filter = this.getFilteredVector(false);
            this._filteredInCount = vector.countOff(filter);
        };
        dataMgrClass.prototype.getFilteredVector = function (invalidateNumericCache) {
            return this._dataFrame.getFilteredVector(invalidateNumericCache);
        };
        dataMgrClass.prototype.getSelectedVector = function (invalidateNumericCache) {
            var vector = this._dataFrame.getVector(beachParty.selectedName, invalidateNumericCache);
            return vector;
        };
        //getRecordIndexVector()
        //{
        //    var vector = this._dataFrame.getVector(primaryKeyName, false);
        //    return vector;
        //}
        dataMgrClass.prototype.updateSelectionFromBoxes = function (origBoxes, selectMode) {
            //---- map origBoxes[] shapeIndex to sorted-data-relative boxIndexes[] ----
            if (origBoxes) {
                var vectorIndexes = [];
                var pkToVectorIndex = this._dataFrame.getPkToVectorIndex();
                for (var i = 0; i < origBoxes.length; i++) {
                    var key = origBoxes[i].primaryKey;
                    var vectorIndex = pkToVectorIndex[key];
                    vectorIndexes.push(vectorIndex);
                }
                this.updateSelectionFromVectorIndexes(vectorIndexes, selectMode);
            }
        };
        /**
         *  Remove any indexes that are not in the current FILTERED IN records.
         * @param indexes
         */
        dataMgrClass.prototype.removeFilteredOutIndexes = function (indexes) {
            var filteredOut = this.getFilteredVector(false);
            var newIndexes = [];
            for (var i = 0; i < indexes.length; i++) {
                var index = indexes[i];
                if (!filteredOut[index]) {
                    newIndexes.push(index);
                }
            }
            return newIndexes;
        };
        dataMgrClass.prototype.updateSelectionFromVectorIndexes = function (indexes, selectMode) {
            //if (selectMode === undefined)
            //{
            //    selectMode = this._selectMode;
            //}
            indexes = this.removeFilteredOutIndexes(indexes);
            var select = this.getSelectedVector(true);
            //---- smart toggle is just treated as "normal" in the plot engine ----
            if (selectMode == beachParty.SelectMode.smartToggle) {
                selectMode = beachParty.SelectMode.normal;
            }
            if (selectMode == beachParty.SelectMode.normal) {
                //---- clear previous selection ----
                vector.clear(select);
            }
            if (selectMode == beachParty.SelectMode.subtractive) {
                for (var i = 0; i < indexes.length; i++) {
                    var recordIndex = indexes[i];
                    select[recordIndex] = 0;
                }
            }
            else if (selectMode == beachParty.SelectMode.intersection) {
                var temp = vp.utils.copyArray(select);
                for (var i = 0; i < indexes.length; i++) {
                    var recordIndex = indexes[i];
                    if (temp[recordIndex] == 1) {
                        temp[recordIndex] = 2;
                    }
                }
                //---- tranfer to select ----
                for (var i = 0; i < temp.length; i++) {
                    select[i] = (temp[i] == 2) ? 1 : 0;
                }
            }
            else if (selectMode == beachParty.SelectMode.nonIntersection) {
                var temp = vp.utils.copyArray(select);
                for (var i = 0; i < indexes.length; i++) {
                    var recordIndex = indexes[i];
                    if (temp[recordIndex] == 1) {
                        temp[recordIndex] = 2;
                    }
                    else {
                        temp[recordIndex] = 1;
                    }
                }
                //---- tranfer to select ----
                for (var i = 0; i < temp.length; i++) {
                    select[i] = (temp[i] == 1) ? 1 : 0;
                }
            }
            else if (selectMode == beachParty.SelectMode.normal || selectMode == beachParty.SelectMode.additive) {
                for (var i = 0; i < indexes.length; i++) {
                    var recordIndex = indexes[i];
                    select[recordIndex] = 1;
                }
            }
            else if (selectMode == beachParty.SelectMode.toggleClear) {
                if (indexes.length == 0) {
                    if (selectMode == beachParty.SelectMode.toggleClear) {
                        //---- clear previous selection ----
                        vector.clear(select);
                    }
                }
                else {
                    for (var i = 0; i < indexes.length; i++) {
                        var recordIndex = indexes[i];
                        //---- toggle each record specified ----
                        select[recordIndex] = (1 - select[recordIndex]);
                    }
                }
            }
            this.onSelectionChanged();
        };
        dataMgrClass.prototype.getVectorFromKeys = function (keys) {
            var vector = vp.data.dataRepeat(0, this._recordCount);
            var pkToVectorIndex = this._dataFrame.getPkToVectorIndex();
            for (var i = 0; i < keys.length; i++) {
                var pk = keys[i];
                var vi = pkToVectorIndex[pk];
                vector[vi] = 1;
            }
            return vector;
        };
        //---- set FILTERED-OUT records to the specified list of primary keys ----
        dataMgrClass.prototype.setFilter = function (filteredOutKeys) {
            //---- optimized for speed, so slightly complex ----
            var isDifferent = false;
            var newVector = null;
            var filter = null;
            var noFilter = (!filteredOutKeys || filteredOutKeys.length == 0);
            if (noFilter) {
                isDifferent = this.isFilterInIuse();
            }
            else {
                //---- must convert keys to vector, and compare vectors ----
                newVector = this.getVectorFromKeys(filteredOutKeys);
                filter = this.getFilteredVector(false);
                isDifferent = vector.compare(filter, newVector);
            }
            if (isDifferent) {
                if (!newVector) {
                    filter = this.getFilteredVector(false);
                    newVector = this.getVectorFromKeys(filteredOutKeys);
                }
                vector.copy(filter, newVector);
                this.computeFilteredCount();
                this.onDataChanged("filtered");
                //---- rebuild colInfos so they reflect new filter setting ----
                this.buildColInfos(this._dataFrame);
                //---- since the filter has been changed, invalidate filter column numeric data cache ----
                this._dataFrame.invalidateCache(beachParty.filteredName);
            }
            return isDifferent;
        };
        dataMgrClass.prototype.forceFilterChangedEvent = function () {
            this.onDataChanged("filtered");
        };
        /** sets the selection vector to the records described by "selectedPrimaryKeys", without applying any boolean operations. */
        dataMgrClass.prototype.setSelectionDirect = function (selectedPrimaryKeys, changeSource) {
            var isDifferent = false;
            var selectVector = null;
            var newVector = null;
            var noSelect = (!selectedPrimaryKeys || selectedPrimaryKeys.length == 0);
            if (noSelect) {
                isDifferent = (this._selectedCount > 0);
            }
            else {
                //---- must convert keys to vector, and compare vectors ----
                newVector = this.getVectorFromKeys(selectedPrimaryKeys);
                selectVector = this.getSelectedVector(false);
                isDifferent = vector.compare(selectVector, newVector);
            }
            if (isDifferent) {
                if (!newVector) {
                    selectVector = this.getSelectedVector(false);
                    newVector = this.getVectorFromKeys(selectedPrimaryKeys);
                }
                vector.copy(selectVector, newVector);
                //---- since the selection has been changed, invalidate its numeric data cache ----
                this._dataFrame.invalidateCache(beachParty.selectedName);
                this.onSelectionChanged(changeSource);
            }
            return isDifferent;
        };
        dataMgrClass.prototype.isolateSelection = function () {
            /// REMINDER: filtered[i] == true (or == 1) means record is filtered OUT of view  
            var select = this.getSelectedVector(false);
            var filter = this.getFilteredVector(true);
            for (var i = 0; i < select.length; i++) {
                //---- don't change filter of filtered-out records ----
                if (!filter[i]) {
                    filter[i] = (1 - select[i]);
                }
            }
            this.onFilterChanged();
            this.clearSelection();
        };
        dataMgrClass.prototype.onFilterChanged = function () {
            this.computeFilteredCount();
            this.onDataChanged("filtered");
            var filterInIuse = this.isFilterInIuse();
            this._dataFrame.isFilterActive(filterInIuse);
        };
        dataMgrClass.prototype.excludeSelection = function () {
            /// REMINDER: filtered[i] == true (or == 1) means record is filtered OUT of view  
            var select = this.getSelectedVector(false);
            var filter = this.getFilteredVector(true);
            for (var i = 0; i < select.length; i++) {
                //---- don't change filter of filtered-out records ----
                if (!filter[i]) {
                    //---- record is filtered out if it IS selected ----
                    filter[i] = select[i];
                }
            }
            this.onFilterChanged();
            this.clearSelection();
        };
        /**
         * returns full records for the selected rows, optionally applying the filter.
         * @param applyFilter
         */
        dataMgrClass.prototype.getSelectedRecords = function (applyFilter) {
            var select = this.getSelectedVector(false);
            var selectedRecords = [];
            var filter = null;
            if (applyFilter) {
                filter = this.getFilteredVector(true);
            }
            if (filter && filter.length) {
                for (var i = 0; i < select.length; i++) {
                    if ((select[i]) && (!filter[i])) {
                        var record = this._dataFrame.getRecordByVectorIndex(i);
                        selectedRecords.push(record);
                    }
                }
            }
            else {
                for (var i = 0; i < select.length; i++) {
                    if (select[i]) {
                        var record = this._dataFrame.getRecordByVectorIndex(i);
                        selectedRecords.push(record);
                    }
                }
            }
            return selectedRecords;
        };
        dataMgrClass.prototype.sortData = function (colName, ascending) {
            var colType = this._dataFrame.getColType(colName);
            this._dataFrame.sortVectors(colName, ascending, colType);
            this.onDataChanged("sortOrder");
        };
        dataMgrClass.prototype.resetFilter = function () {
            var filter = this.getFilteredVector(true);
            vector.clear(filter);
            this.onFilterChanged();
            this.onDataChanged("filterReset");
            //---- this is no longer done in resetFilter ----
            //this.clearSelection();
        };
        dataMgrClass.prototype.clearSelection = function (omitNotify) {
            var select = this.getSelectedVector(true);
            vector.clear(select);
            if (!omitNotify) {
                this.onSelectionChanged();
            }
        };
        dataMgrClass.prototype.onSelectionChanged = function (changeSource) {
            if (changeSource === void 0) { changeSource = "local"; }
            this.computeSelectedCount();
            this.onDataChanged("selection");
            if (changeSource == "local") {
                var select = this.getSelectedVector(false);
                var selectedPrimaryKeys = this._dataFrame.vectorToPrimaryKeys(select);
                this._shareMgr.setSelection(selectedPrimaryKeys);
            }
        };
        dataMgrClass.prototype.getSelectedCount = function (applyFilter) {
            var count = this._selectedCount;
            if (applyFilter && this._recordCount != this._filteredInCount) {
                var select = this.getFilteredInVector(beachParty.selectedName);
                count = vector.countOn(select);
            }
            return count;
        };
        dataMgrClass.prototype.getFilteredInCount = function () {
            return this._filteredInCount;
        };
        dataMgrClass.prototype.getKnownDataPreloads = function () {
            return this._preloadMgr.getPreloads();
        };
        dataMgrClass.prototype.getPreloadMgr = function () {
            return this._preloadMgr;
        };
        return dataMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.dataMgrClass = dataMgrClass;
    (function (DataChangeFlags) {
        DataChangeFlags[DataChangeFlags["dataSetChange"] = 1] = "dataSetChange";
        DataChangeFlags[DataChangeFlags["selectionChange"] = 2] = "selectionChange";
        DataChangeFlags[DataChangeFlags["filterChange"] = 4] = "filterChange";
        DataChangeFlags[DataChangeFlags["columnsChange"] = 8] = "columnsChange";
        DataChangeFlags[DataChangeFlags["dataUpdate"] = 16] = "dataUpdate";
        DataChangeFlags[DataChangeFlags["sortOrder"] = 32] = "sortOrder";
    })(beachParty.DataChangeFlags || (beachParty.DataChangeFlags = {}));
    var DataChangeFlags = beachParty.DataChangeFlags;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// fileAccess.ts.  Copyright (c) 2016 Microsoft Corporation.
///     Part of the beachParty library - functions to read and write files.
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    (function (fileFormat) {
        fileFormat[fileFormat["text"] = 0] = "text";
        fileFormat[fileFormat["json"] = 1] = "json";
        fileFormat[fileFormat["csv"] = 2] = "csv";
        fileFormat[fileFormat["odata"] = 3] = "odata";
        fileFormat[fileFormat["excelSheet"] = 4] = "excelSheet";
        fileFormat[fileFormat["excelAllSheets"] = 5] = "excelAllSheets";
    })(beachParty.fileFormat || (beachParty.fileFormat = {}));
    var fileFormat = beachParty.fileFormat;
    var fileAccess = (function () {
        function fileAccess() {
        }
        /** reads a local text file that is selected by the user. */
        fileAccess.readLocalTextFile = function (userPrompt, callback) {
            //---- add an file input elem so we can promp user for file ----
            var fileElem = document.createElement("input");
            fileElem.setAttribute("type", "file");
            fileElem.style.display = "none";
            document.body.appendChild(fileElem);
            //---- click on it to invoke the dialog ----
            fileElem.click();
            //---- remove the fileElem ----
            document.body.removeChild(fileElem);
            //---- now, initiate the async read ----
            var reader = new FileReader();
            reader.onload = function (f) {
                callback(reader.result);
            };
            var started = false;
            if (fileElem.files.length) {
                var file = fileElem.files[0];
                reader.readAsText(file);
                started = true;
            }
            return started;
        };
        fileAccess.mapToUrlParams = function (map) {
            var str = "";
            if (map) {
                for (var key in map) {
                    if (str == "") {
                        str = "?";
                    }
                    else {
                        str += "&";
                    }
                    str += key + "=" + map[key];
                }
            }
            return str;
        };
        fileAccess.writeFile64 = function (fn, content64) {
            var vp = bpServerPath();
            var serviceUrl = vp + "/putData.asmx/writeFile64";
            var fullUrl = serviceUrl;
            var finalUrl = encodeURI(fullUrl);
            //alert("posting to url: " + finalUrl);
            var body = "fn=" + fn + "&content=" + content64;
            fileAccess.httpPost(finalUrl, body, function (xmlhttp) {
                //alert("writeFile64 succeeded");
            }, function (e) {
                //alert("writeFile64 failed");
            }, false);
        };
        fileAccess.writeFileText = function (fn, text, successCallback, failureCallback) {
            var vp = bpServerPath();
            var serviceUrl = vp + "/putData.asmx/writeFileText";
            var fullUrl = serviceUrl;
            var finalUrl = encodeURI(fullUrl);
            //alert("posting to url: " + finalUrl);
            var body = "fn=" + fn + "&text=" + encodeURIComponent(text);
            var isAsync = (successCallback !== undefined);
            fileAccess.httpPost(finalUrl, body, function (xmlhttp) {
                if (successCallback) {
                    successCallback(xmlhttp);
                }
            }, function (e) {
                if (failureCallback) {
                    failureCallback(e);
                }
            }, isAsync);
        };
        fileAccess.removeDirectory = function (dir) {
            var vp = bpServerPath();
            var serviceUrl = vp + "/putData.asmx/removeDirectory";
            var fullUrl = serviceUrl;
            var finalUrl = encodeURI(fullUrl);
            //alert("posting to url: " + finalUrl);
            var body = "dir=" + dir;
            fileAccess.httpPost(finalUrl, body, function (xmlhttp) {
                //alert("writeFile64 succeeded");
            }, function (e) {
                //alert("writeFile64 failed");
            }, false);
        };
        /** replace every /Date/ value with a javaScript date object. */
        fileAccess.fixUpDatesFromDotNet = function (data) {
            var keys = null;
            if (data.length) {
                //---- JSON array of records ----
                for (var r = 0; r < data.length; r++) {
                    var record = data[r];
                    if (!keys) {
                        keys = vp.utils.keys(record);
                    }
                    for (var k = 0; k < keys.length; k++) {
                        var colName = keys[k];
                        var value = record[colName];
                        if (vp.utils.isString(value)) {
                            var str = value;
                            if (str.startsWith("/Date(")) {
                                str = "new " + str.substr(1, str.length - 2);
                                var date = new Date(str);
                                record[colName] = date;
                            }
                        }
                    }
                }
            }
            else if (data._vectorsByName) {
                //---- DATA FRAME class ----
                var df = data;
                //---- process by vector ----
                var names = df.getColumnNames();
                for (var v = 0; v < names.length; v++) {
                    var name = names[v];
                    var vector = df.getVector(name, true);
                    for (var r = 0; r < vector.length; r++) {
                        var value = vector[r];
                        if (vp.utils.isString(value)) {
                            var str = value;
                            if (str.startsWith("/Date(")) {
                                str = "new " + str.substr(1, str.length - 2);
                                var date = new Date(str);
                                vector[r] = date;
                            }
                        }
                    }
                }
            }
            else if (data) {
                //---- KEY/VECTOR dict ----
                var names = vp.utils.keys(data);
                for (var v = 0; v < names.length; v++) {
                    var name = names[v];
                    var vector = data[name];
                    for (var r = 0; r < vector.length; r++) {
                        var value = vector[r];
                        if (vp.utils.isString(value)) {
                            var str = value;
                            if (str.startsWith("/Date(")) {
                                str = "new " + str.substr(1, str.length - 2);
                                var date = new Date(str);
                                vector[r] = date;
                            }
                        }
                    }
                }
            }
            return data;
        };
        /** read TEXT file sync. from server relative path. */
        fileAccess.readServerTextFile = function (relPath) {
            //---- read file SYNC from my host (same directory) ----
            var request = new XMLHttpRequest();
            //---- try to disable caching here by using time as a unique URL argument ----
            //relPath += "?foo=" + Date.now();
            request.open("GET", relPath, false);
            request.send();
            var str = request.responseText;
            return str;
        };
        /** read binary file sync. from server relative path, into arrayBuff. */
        fileAccess.readServerFileIntoArrayBuff = function (relPath) {
            var request = new XMLHttpRequest();
            request.open("GET", relPath, false);
            request.responseType = 'arraybuffer';
            request.send();
            var uInt8Array = new Uint8Array(request.response);
            return uInt8Array;
        };
        fileAccess.readFile = function (fnOrUlr, format, formatOptions, asyncSuccessCallback, asyncFailCallback, noCache, asDataFrame, addDataPathIfNeeded) {
            //vp.utils.debug("readFile() called");
            if (addDataPathIfNeeded === void 0) { addDataPathIfNeeded = true; }
            format = format || fileFormat.text; // default to TEXT
            var isJson = ((format === fileFormat.json) || (format === fileFormat.odata));
            if (addDataPathIfNeeded && !fnOrUlr.contains(":")) {
                fnOrUlr = bpDataPath() + "/" + fnOrUlr;
            }
            var result = undefined;
            if (format == fileFormat.csv) {
                fileAccess.httpReadCsvViaService(fnOrUlr, formatOptions, function (data) {
                    //---- success ----
                    if (asyncSuccessCallback) {
                        var data = fileAccess.fixUpDatesFromDotNet(data);
                        asyncSuccessCallback(data);
                    }
                    else {
                        result = data;
                    }
                }, function (e) {
                    if (asyncFailCallback) {
                        asyncFailCallback(e);
                    }
                    else {
                        //---- FAILURE ----
                        fileFail("httpReadCsvViaService", fnOrUlr, e);
                    }
                }, (asyncSuccessCallback != null), asDataFrame);
            }
            else if (format == fileFormat.excelSheet || format == fileFormat.excelAllSheets) {
                fileAccess.httpReadExcelViaService(fnOrUlr, format, formatOptions, function (data) {
                    //---- success ----
                    if (asyncSuccessCallback) {
                        var data = fileAccess.fixUpDatesFromDotNet(data);
                        asyncSuccessCallback(data);
                    }
                    else {
                        result = data;
                    }
                }, function (e) {
                    //---- failure ----
                    if (asyncFailCallback) {
                        asyncFailCallback(e);
                    }
                    else {
                        //throw "Error during httpReadCsvViaService: url=" + fnOrUlr + ", error=" + e.response;
                        fileFail("httpReadCsvViaService", fnOrUlr, e);
                    }
                }, (asyncSuccessCallback != null));
            }
            else {
                fileAccess.httpReadViaService(fnOrUlr, isJson, function (data) {
                    //---- success ----
                    if (format === fileFormat.odata) {
                        data = data.results;
                    }
                    //---- sending from server encodes special characters, so we must decode them ----
                    data = fileAccess.removeHtmlEncoding(data);
                    //else if (format === fileFormat.csv)
                    //{
                    //    var start = vp.utils.now();
                    //    var csv = createCsvLoader(formatOptions.hasHeader, formatOptions.sepChar,
                    //        formatOptions.findTypes);
                    //    data = csv.load(data, false);
                    //    var data = fileAccess.fixUpDatesFromDotNet(data);
                    //    var elapsed = vp.utils.now() - start;
                    //    vp.utils.debug("csvLoader.load: " + elapsed + " ms");
                    //}
                    if (asDataFrame) {
                        data = beachParty.dataFrameClass.jsonToDataFrame(data);
                    }
                    if (asyncSuccessCallback) {
                        asyncSuccessCallback(data);
                    }
                    else {
                        result = data;
                    }
                }, function (e) {
                    if (asyncFailCallback) {
                        asyncFailCallback(e);
                    }
                    else {
                        //---- failure ----
                        //throw "Error during httpReadCsvViaService: url=" + fnOrUlr + ", error=" + e.response;
                        fileFail("httpReadCsvViaService", fnOrUlr, e);
                    }
                }, (asyncSuccessCallback != null), noCache);
            }
            return result;
        };
        //---- this seems to be the best way to remove HTML encodings from a string (might compress spaces though) ----
        fileAccess.removeHtmlEncoding = function (value) {
            var div = document.createElement("div");
            div.innerHTML = value;
            var str = div.textContent;
            return str;
        };
        fileAccess.readSqlTable = function (cs, tableName, query, dataSampling, asyncSuccessCallback, asyncFailCallback) {
            if (!query) {
                query = "";
            }
            //---- base URL: http://localhost/bpServerOther/getData.asmx/DownloadDataFromSql ----
            var bpServer = bpServerNextPath();
            //var serviceUrl = bpServer + "Other/getData.asmx/DownloadDataFromSql";
            var serviceUrl = bpServer + "/bpService.asmx/DownloadDataFromSql";
            var fullUrl = serviceUrl + "?cs=" + cs + "&tableName=" + tableName + "&query=" +
                query;
            if (dataSampling && dataSampling.isEnabled) {
                fullUrl += "&sampleThreshold=" + dataSampling.samplingThreshold;
                fullUrl += "&sampleType=" + beachParty.SampleType[dataSampling.sampleType];
                fullUrl += "&sampleCount=" + dataSampling.sampleCount;
            }
            else {
                fullUrl += "&sampleThreshold=-1";
                fullUrl += "&sampleType=none";
                fullUrl += "&sampleCount=-1";
            }
            var finalUrl = encodeURI(fullUrl);
            var isJson = true;
            httpRead(finalUrl, isJson, function (xmlhttp) {
                if (asyncSuccessCallback) {
                    var result = getDataFromResult(xmlhttp, isJson);
                    result.data = fileAccess.fixUpDatesFromDotNet(result.data);
                    asyncSuccessCallback(result);
                }
            }, asyncFailCallback, true);
        };
        fileAccess.readSqlTableAgg = function (cs, tableName, query, dataAgg, asyncSuccessCallback, asyncFailCallback) {
            if (!query) {
                query = "";
            }
            //---- base URL: http://localhost/bpServerOther/getData.asmx/DownloadAggDataFromSql ----
            var bpServer = bpServerPath();
            //var serviceUrl = bpServer + "Other/getData.asmx/DownloadDataFromSql";
            var serviceUrl = bpServer + "/bpService.asmx/DownloadAggDataFromSql";
            var fullUrl = serviceUrl + "?cs=" + cs + "&tableName=" + tableName + "&query=" +
                query;
            fullUrl += "&aggType=" + beachParty.AggType[dataAgg.aggType];
            fullUrl += "&aggColumn=" + dataAgg.targetCol;
            fullUrl += "&groupCols=" + dataAgg.groupCols;
            fullUrl += "&jsonAggFilters=" + JSON.stringify(dataAgg.aggFilters);
            var finalUrl = encodeURI(fullUrl);
            var isJson = true;
            httpRead(finalUrl, isJson, function (xmlhttp) {
                if (asyncSuccessCallback) {
                    var result = getDataFromResult(xmlhttp, isJson);
                    result.data = fileAccess.fixUpDatesFromDotNet(result.data);
                    asyncSuccessCallback(result);
                }
            }, asyncFailCallback, true);
        };
        fileAccess.httpReadIncremental = function (url, isJson, offset, maxSize, successFunc, failFunc, callAsync) {
            var pp = pagePath();
            if (url.startsWith("..")) {
                url = pp + url;
            }
            //var serviceUrl = "http://" + window.location.host + "/VuePlotWeb/Service/Service1.asmx/DownloadText";
            var serviceUrl = pp + "/Service/Service1.asmx/IncrementalDownload";
            var win = window;
            if (win.alertShown === undefined) {
                //alert("read via url: " + serviceUrl);
                win.alertShown = 1;
            }
            var fullUrl = serviceUrl + "?url=" + url + "&offset=" + offset + "&maxSize=" + maxSize;
            httpRead(fullUrl, false, function (xmlhttp) {
                if (successFunc) {
                    var data = getDataFromResult(xmlhttp, isJson);
                    successFunc(data);
                }
            }, failFunc);
        };
        /// starts a async (or calls sync) upload of text to the specified url.
        fileAccess.httpPost = function (url, stringToSend, successFunc, failFunc, isAsync, contentType) {
            var xmlhttp = createXMLHttpRequest();
            xmlhttp.open("POST", url, isAsync);
            if (!contentType) {
                contentType = "application/x-www-form-urlencoded";
            }
            xmlhttp.setRequestHeader("Content-Type", contentType);
            xmlhttp.onreadystatechange = function () {
                if ((xmlhttp.readyState == 4) && (xmlhttp.status != 0)) {
                    if (xmlhttp.status == 200) {
                        if (successFunc != null) {
                            successFunc(xmlhttp);
                        }
                    }
                    else {
                        if (failFunc != null) {
                            failFunc(xmlhttp);
                        }
                    }
                }
            };
            xmlhttp.send(stringToSend);
        };
        ///
        /// download text data from a URL, using a specific service that is expected to
        /// be on the same host as the current host:  http://samehostname/VuePlotWeb/Service/Service1.asmx/DownloadText
        ///
        /// This is to get around problem "cross origin resource sharing".
        ///
        fileAccess.httpReadViaService = function (url, isJson, successFunc, failFunc, isAsync, noCache) {
            isJson = isJson || false;
            noCache = noCache || false;
            var vp = bpServerPath();
            var serviceUrl = vp + "/getData.asmx/DownloadText";
            var win = window;
            if (win.alertShown === undefined) {
                //alert("read via url: " + serviceUrl);
                win.alertShown = 1;
            }
            var httpReadJson = false; // download to us as text
            var finalUrl = serviceUrl + "?url=" + url + "&isJson=" + httpReadJson + "&noCache=" + noCache;
            httpRead(finalUrl, httpReadJson, function (xmlhttp) {
                if (successFunc) {
                    var data = getDataFromResult(xmlhttp, isJson, true);
                    successFunc(data);
                }
            }, failFunc, isAsync, noCache);
        };
        ///
        /// download CSV data (as JSON data) from a URL, using a specific service that is expected to
        /// be on the same host as the current host:  http://samehostname/VuePlotWeb/Service/Service1.asmx/DownloadCsvAsJson
        ///
        /// This is to get around problem "cross origin resource sharing".
        ///
        fileAccess.httpReadCsvViaService = function (url, csvOpts, successFunc, failFunc, isAsync, asDataFrame) {
            if (asDataFrame === void 0) { asDataFrame = false; }
            var vp = bpServerPath();
            //var serviceUrl = vp + "/getData.asmx/DownloadCsvAsJsonVectors";
            var serviceUrl = vp + "/bpService.asmx/DownloadCsvAsJsonVectors";
            var win = window;
            if (win.alertShown === undefined) {
                //alert("read via url: " + serviceUrl);
                win.alertShown = 1;
            }
            var fullUrl = serviceUrl + "?url=" + url + "&delimeter=" + csvOpts.sepChar +
                "&hasHeader=" + csvOpts.hasHeader + "&inferTypes=" + csvOpts.findTypes;
            var finalUrl = encodeURI(fullUrl);
            var isJson = true;
            httpRead(finalUrl, isJson, function (xmlhttp) {
                if (successFunc) {
                    var data = getDataFromResult(xmlhttp, isJson);
                    if (asDataFrame) {
                        //---- convert into a real dataFrame object ----
                        var dataCols = [];
                        for (var i = 0; i < data.names.length; i++) {
                            var name = data.names[i];
                            var vector = data.vectors[i];
                            var dc = new beachParty.DataColumn(name, null, null, null, null, vector);
                            dataCols.push(dc);
                        }
                        var df = new beachParty.dataFrameClass(dataCols);
                        data = df;
                    }
                    data = fileAccess.fixUpDatesFromDotNet(data);
                    successFunc(data);
                }
            }, failFunc, isAsync);
        };
        ///
        /// download Excel data (as JSON data) from a URL, using a specific service that is expected to
        /// be on the same host as the current host:  http://samehostname/VuePlotWeb/Service/Service1.asmx/DownloadExcelAsJson
        ///
        /// This is to get around problem "cross origin resource sharing".
        ///
        fileAccess.httpReadExcelViaService = function (url, format, sheetName, successFunc, failFunc, isAsync) {
            var vp = bpServerPath();
            if (format == fileFormat.excelSheet) {
                var serviceUrl = vp + "/getData.asmx/DownloadExcelSheetAsJson";
                var fullUrl = serviceUrl + "?url=" + url + "&sheetName=" + sheetName;
            }
            else {
                var serviceUrl = vp + "/getData.asmx/DownloadAllExcelSheetsAsJson";
                var fullUrl = serviceUrl + "?url=" + url;
            }
            var win = window;
            if (win.alertShown === undefined) {
                //alert("read via url: " + serviceUrl);
                win.alertShown = 1;
            }
            var finalUrl = encodeURI(fullUrl);
            var isJson = true;
            httpRead(finalUrl, isJson, function (xmlhttp) {
                if (successFunc) {
                    var data = getDataFromResult(xmlhttp, isJson);
                    successFunc(data);
                }
            }, failFunc, isAsync);
        };
        /// reads OData data from the specified url.
        fileAccess.oDataRead = function (url, isJson, successFunc, failFunc) {
            fileAccess.httpReadViaService(url, isJson, function (data) {
                if (successFunc) {
                    if ((data) && (data.results)) {
                        data = data.results;
                    }
                    successFunc(data);
                }
            }, failFunc);
        };
        /// reads all of the OData data from the specified url (adding parameters to the URL to
        /// read each block of data).
        fileAccess.oDataReadAll = function (url, byCount, successFunc, failFunc) {
            if (byCount == null) {
                byCount = 1000;
            }
            var bag = fileAccess.oDataBag;
            bag.error = false;
            bag.data = [];
            bag.total = 0;
            bag.byCount = byCount;
            var self = this;
            var readMore = function () {
                fileAccess.oDataRead(url + "?$skip=" + bag.total + "&$top=" + bag.byCount, true, function (dataChunk) {
                    var chunkSize = dataChunk.length;
                    if (chunkSize > 0) {
                        bag.byCount = chunkSize;
                        //self.dataServices.concat(dataChunk);
                        //bag.data = dataServices.conconcat(bag.data, dataChunk);
                        bag.total = bag.data.length;
                        readMore();
                    }
                    else {
                        if (successFunc != null) {
                            successFunc(bag.data);
                        }
                    }
                }, function (xmlhttp) {
                    if (failFunc != null) {
                        failFunc(xmlhttp);
                    }
                    bag.error = true;
                });
            };
            readMore();
        };
        //---- we use this to store data for multiple calls to oDataReadAll ----
        fileAccess.oDataBag = {};
        return fileAccess;
    }());
    beachParty.fileAccess = fileAccess;
    var incrementalCsvLoader = (function () {
        function incrementalCsvLoader(url, hasHeader, sepChar, findTypes, recordsCallback) {
            this._csvLoader = null;
            this._offset = 0;
            this._recordsCallback = null;
            this._url = null;
            this._recordsCallback = recordsCallback;
            this._url = url;
            this._csvLoader = beachParty.createCsvLoader(hasHeader, sepChar, findTypes);
        }
        incrementalCsvLoader.prototype.readNextCheck = function (size) {
            fileAccess.httpReadIncremental(this._url, false, this._offset, size, function (jsonResult) {
                //---- success: got next chunk ----
                var chunk = jsonResult.data;
                var isMore = jsonResult.isMore;
                this._offset += chunk.length;
                var records = this._csvLoader.load(chunk, true);
                this._recordsCallback(records, isMore);
            }, function (xmlhttp) {
                //---- read failed ----
                throw "Error reading CSV file: " + this._url;
            });
        };
        return incrementalCsvLoader;
    }());
    beachParty.incrementalCsvLoader = incrementalCsvLoader;
    function pagePath() {
        var pp = window.location.href;
        //---- on IE10, running under "localhost", sometimes all the props of "window.location" are ----
        //---- undefined, so we ahndle that here ----
        if (pp === undefined) {
            pp = window.location.toString();
        }
        var index = pp.lastIndexOf("/");
        if (index > 0) {
            pp = pp.substr(0, index);
            index = pp.lastIndexOf("/");
            if (index > 0) {
                pp = pp.substr(0, index);
            }
        }
        return pp;
    }
    beachParty.pagePath = pagePath;
    /// starts a async download of text from the specified url.  if "isJson" is true,
    /// the data is requested in json format.  when the download is finished, either
    /// successFunc or failFunc is called, with the param "xmlhttp".
    ///
    /// if this is a file on a server, the true text is returned in xmlhttp.responseText.  if text is XML,
    /// the XML document object is available in xmlhttp.responseXML.
    function httpRead(url, isJson, successFunc, failFunc, callAsync, noCache) {
        callAsync = (callAsync === undefined) ? true : callAsync;
        var xmlhttp = vp.utils.createXMLHttpRequest();
        xmlhttp.open("GET", url, callAsync);
        if (isJson) {
            xmlhttp.setRequestHeader("accept", "application/json");
        }
        if (noCache) {
            //xmlhttp.setRequestHeader("If-Modified-Since", "Sat, 1 Jan 2015 00:00:00 GMT");
            //---- per http://stackoverflow.com/questions/49547/making-sure-a-web-page-is-not-cached-across-all-browsers ----
            xmlhttp.setRequestHeader("Cache-Control", "no-cache, no-store, must-revalidate"); // HTTP 1.1.
            xmlhttp.setRequestHeader("Pragma", "no-cache"); // HTTP 1.0.
            xmlhttp.setRequestHeader("Expires", "2"); // Proxies.
        }
        xmlhttp.onreadystatechange = function () {
            if ((xmlhttp.readyState == 4) && (xmlhttp.status != 0)) {
                if (xmlhttp.status == 200) {
                    if (successFunc != null) {
                        successFunc(xmlhttp);
                    }
                }
                else {
                    if (failFunc != null) {
                        failFunc(xmlhttp);
                    }
                    else {
                        throw "httpRead failed: url=" + url;
                    }
                }
            }
        };
        xmlhttp.send();
    }
    beachParty.httpRead = httpRead;
    function getMyPath() {
        if (this._appMgr && this._appMgr._beachPartyDir) {
            var path = this._appMgr._beachPartyDir + "/Apps";
        }
        else {
            var path = window.location.href;
            //---- remove any params ----
            var index = path.indexOf("?");
            if (index > -1) {
                path = path.substr(0, index);
            }
            //---- remove the last node ----
            var index = path.lastIndexOf("/");
            if (index > -1) {
                path = path.substr(0, index);
            }
        }
        return path;
    }
    beachParty.getMyPath = getMyPath;
    function pathHelper(nodeName) {
        var getServicePrefix = true;
        var serverPath = window.location.href;
        //---- try easy ones first ----
        if (serverPath.startsWith("http://localhost")) {
            serverPath = "http://localhost/" + nodeName;
        }
        else if (serverPath.contains("azurewebsites")) {
            serverPath = location.protocol + "//" + location.hostname + "/" + nodeName;
        }
        else {
            //---- vibe10 or a named dev machine ----
            if (serverPath.startsWith("http://vibe10") || serverPath.startsWith("https://vibe10")) {
                //---- first, remove any parameters ----
                var index = serverPath.indexOf("?");
                if (index > -1) {
                    serverPath = serverPath.substr(0, index);
                }
                //---- find node that begins with "/build" ----
                index = serverPath.indexOf("/build");
                if (index > 0) {
                    var index2 = serverPath.indexOf("/", index + 1);
                    if (index2 > -1) {
                        serverPath = serverPath.substr(0, index2);
                        serverPath += "/" + nodeName;
                    }
                }
            }
            else {
                serverPath = location.protocol + "//" + location.hostname + "/" + nodeName;
            }
        }
        return serverPath;
    }
    function bpServerPath() {
        ////---- on IE10, running under "localhost", sometimes all the props of "window.location" are ----
        ////---- undefined, so we handle that here ----
        //---- the GOAL of this function: to return the "bpServer" name that belongs to this code.  This is easy ----
        //---- for dev machine (http://localhost/bpServer) but gets somewhat tricky when we are deployed ----
        //---- and the bpServer we want is something like:  http://vibe10/SandCastle/build3/bpServer.  ----
        //var serverPath = window.location.href;
        if (location.href.contains("azurewebsites")) {
            if (location.href.contains("2.azure")) {
                var path = location.protocol + "//beachPartyServer2.azurewebsites.net";
            }
            else {
                var path = location.protocol + "//beachPartyServer.azurewebsites.net";
            }
        }
        else {
            var path = pathHelper("bpServer");
        }
        return path;
    }
    beachParty.bpServerPath = bpServerPath;
    function sandDancePageServer() {
        if (location.href.contains("azurewebsites")) {
            if (location.href.contains("2.azure")) {
                var path = location.protocol + "//beachPartyServer2.azurewebsites.net";
            }
            else {
                var path = location.protocol + "//beachPartyServer.azurewebsites.net";
            }
        }
        else {
            //---- DOM workaround - location.origin not always supported ----
            var path = location.protocol + "//" + location.host;
        }
        return path;
    }
    beachParty.sandDancePageServer = sandDancePageServer;
    function bpServerNextPath() {
        ////---- on IE10, running under "localhost", sometimes all the props of "window.location" are ----
        ////---- undefined, so we handle that here ----
        //---- the GOAL of this function: to return the "bpServer" name that belongs to this code.  This is easy ----
        //---- for dev machine (http://localhost/bpServer) but gets somewhat tricky when we are deployed ----
        //---- and the bpServer we want is something like:  http://vibe10/SandCastle/build3/bpServer.  ----
        //var serverPath = window.location.href;
        if (location.href.contains("azurewebsites")) {
            //var path = location.protocol + "//beachPartyServer.azurewebsites.net";
            throw "SQL not supported on this version of SandDance";
        }
        else {
            var path = pathHelper("bpServerNext");
        }
        return path;
    }
    beachParty.bpServerNextPath = bpServerNextPath;
    function appPath() {
        ////---- on IE10, running under "localhost", sometimes all the props of "window.location" are ----
        ////---- undefined, so we handle that here ----
        //---- the GOAL of this function: to return the "bpServer" name that belongs to this code.  This is easy ----
        //---- for dev machine (http://localhost/BeachPartyApp) but gets somewhat tricky when we are deployed ----
        //---- and the bpServer we want is something like:  http://vibe10/BeachParty/buildXXX/BeachPartyApp.  ----
        if (this._appMgr && this._appMgr._beachPartyDir) {
            var path = this._appMgr._beachPartyDir;
        }
        else {
            var path = pathHelper("beachPartyApp");
        }
        return path;
    }
    beachParty.appPath = appPath;
    function getMyProtocol() {
        var protocol = (location.protocol) ? location.protocol : "http:";
        return protocol;
    }
    function bpDataPath() {
        //return pathHelper("VueBigData");
        var hostName = (window.location.hostname) ? window.location.hostname : "localhost";
        if (hostName.contains("azurewebsites")) {
            //---- HTTP / HTTPS ----
            var dataPath = getMyProtocol();
            if (location.href.contains("2.azure")) {
                dataPath += "//beachpartyserver2.azurewebsites.net/VueBigData";
            }
            else {
                dataPath += "//beachpartyserver.azurewebsites.net/VueBigData";
            }
        }
        else {
            //---- for non-azure, we assume that VueBigData wants http: ----
            dataPath = "http://" + hostName + "/VueBigData";
        }
        return dataPath;
    }
    beachParty.bpDataPath = bpDataPath;
    /// create a instance of the XMLHttpRequest object.
    function createXMLHttpRequest() {
        var req = null;
        if (XMLHttpRequest != null) {
            req = new XMLHttpRequest();
        }
        else {
            req = new ActiveXObject("Microsoft.XMLHTTP");
        }
        return req;
    }
    beachParty.createXMLHttpRequest = createXMLHttpRequest;
    /// convert a XmlHttp response to a json object.
    function getDataFromResult(xmlRequest, isJson, decodeNeeded) {
        //---- try not to use the "responseXML" since it is heavy weight ----
        var data = xmlRequest.response; // on my server, value is here
        if (!data) {
            data = xmlRequest.responseText; // on vibe10, value is here.  why?
        }
        if (data) {
            if (data.startsWith("<?xml")) {
                var index = data.indexOf(">");
                if (index > -1) {
                    var index2 = data.indexOf(">", index + 1);
                    if (index2 > -1) {
                        //---- remove the XML header ----
                        data = data.substr(index2 + 1);
                        //---- remove the xml trailer ----
                        if (data.endsWith("</string>")) {
                            data = data.substr(0, data.length - 9);
                        }
                    }
                }
            }
        }
        ////---- TOGROK: what is this needed? ----
        //if (decodeNeeded)
        //{
        //    data = decodeURIComponent(data);
        //    data = decodeURIComponent(data);
        //}
        if ((data) && (isJson)) {
            //vp.utils.debug("getDataFromResult: json.length=" + vp.formatters.comma(data.length));
            var data = JSON.parse(data);
            if ((data) && (data.d)) {
                data = data.d; // for json data
            }
        }
        return data;
    }
    beachParty.getDataFromResult = getDataFromResult;
    function startServerSort(keys, sortAsNumbers, callback) {
        var jsonData = JSON.stringify(keys);
        var safeJsonData = encodeURIComponent(jsonData); // protect ourselves from "=" and "&" chars in keys
        var body = "sortAsNumbers=" + sortAsNumbers + "&keys=" + safeJsonData;
        var url = bpServerPath() + "/putData.asmx/sortKeys";
        var safeUrl = encodeURI(url);
        fileAccess.httpPost(safeUrl, body, function (xmlhttp) {
            //---- SUCCESS ----
            var data = getDataFromResult(xmlhttp, true);
            callback(data);
        }, function (e) {
            //alert("writeFile64 failed");
        }, false);
    }
    beachParty.startServerSort = startServerSort;
    function logActionToServer(sessionId, gesture, elementId, elementType, action, target, options) {
        var url = bpServerPath() + "/putData.asmx/logAction";
        url += "?sessionId=" + sessionId +
            "&gesture=" + gesture +
            "&elementId=" + elementId +
            "&elementType=" + elementType +
            "&action=" + action +
            "&target=" + target;
        if (options) {
            var keys = vp.utils.keys(options);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = options[key];
                url += "&" + key + "=" + value;
            }
        }
        //action + " & actionSource = " + actionSource + " & p1 = " + p1 + " & p2 = " + p2 + " & p3 = " + p3;
        var safeUrl = encodeURI(url);
        beachParty.httpRead(safeUrl, false, function (xmlhttp) {
            //---- SUCCESS ----
        }, function (e) {
            //---- FAILURE ----
            //fileFail("logActionToServer", "", e);
        }, true);
    }
    beachParty.logActionToServer = logActionToServer;
    //---- TODO: move this into app ----
    //export function logActionToAzureInsights(sessionId: string, gesture: string, elementId: string, elementType: string,
    //    action: string, target: string, options?: any)
    //{
    //    var anyWindow = <any>window;
    //    var appInsightsObj = <Microsoft.ApplicationInsights.AppInsights>anyWindow.appInsights;
    //    if (appInsightsObj)
    //    {
    //        var props = <any>{};
    //        props.sessionId = sessionId;
    //        props.gesture = gesture;
    //        props.elementId = elementId;
    //        props.target = target;
    //        props.timeStamp = +Date.now();
    //        if (options)
    //        {
    //            var keys = vp.utils.keys(options);
    //            for (var i = 0; i < keys.length; i++)
    //            {
    //                var key = keys[i];
    //                var value = options[key];
    //                props[key] = value;
    //            }
    //        }
    //        appInsightsObj.trackEvent(action, props);
    //    }
    //}
    //export function logFeedbackToServer(type: string, feedback: string)
    //{
    //    var url = bpServerPath() + "/putData.asmx/logFeedback";
    //    //---- use "encodeURI" for the overall URL, if needed ----
    //    //---- use "encodeURIComponent" for the values of parameters, if needed ---
    //    url += "?type=" + type + "&feedback=" + encodeURIComponent(feedback);
    //    //---- only log if we are running on Azure, for now ----
    //    var usingAzure = (url.contains("azurewebsites"));
    //    if (true)       // usingAzure)
    //    {
    //        var anyWindow = <any>window;
    //        var appInsightsObj = <Microsoft.ApplicationInsights.AppInsights>anyWindow.appInsights;
    //        var props = <any>{};
    //        props.type = type;
    //        props.feedback = feedback;
    //        if (appInsightsObj)
    //        {
    //            appInsightsObj.trackEvent("feedback", props);
    //        }
    //    }
    //    //else
    //    //{
    //    //    beachParty.httpRead(url, false,
    //    //        function (xmlhttp)
    //    //        {
    //    //            //---- SUCCESS ----
    //    //            var dummy = 1;
    //    //        },
    //    //        function (e)
    //    //        {
    //    //            //---- FAILURE ----
    //    //            var dummy = 0;
    //    //            this.fileFail("logFeedbackToServer", "", e);
    //    //        }, true);
    //    //}
    //}
    function fileFail(callerName, url, e) {
        var dummy = 0;
        throw "Error in " + callerName + ", status=" + e.statusText + "\r\nurl=" + url + "\r\n" + e.responseText;
    }
    function renderWebPageToPng(pageUrl, width, height, msTimeout, callback) {
        var url = bpServerPath() + "/putData.asmx/renderWebPageToPng";
        //---- use "encodeURI" for the overall URL, if needed ----
        //---- use "encodeURIComponent" for the values of parameters, if needed ---
        //---- todo: also pass preload ----
        url += "?pageUrl=" + encodeURIComponent(pageUrl) + "&width=" + width + "&height=" + height + "&msTimeout=" + msTimeout;
        beachParty.httpRead(url, false, function (xmlhttp) {
            //---- SUCCESS ----
            var data = getDataFromResult(xmlhttp, false);
            callback(data);
        }, function (e) {
            //---- FAILURE ----
            fileFail("renderWebPageToPng", pageUrl, e);
        }, true);
    }
    beachParty.renderWebPageToPng = renderWebPageToPng;
    function writeSessionFile(userName, fileName, contents, callback) {
        var body = "userName=" + userName + "&fileName=" + fileName + "&contents=" + contents;
        var safeBody = encodeURIComponent(body);
        //var url = bpServerPath() + "/putData.asmx/writeSessionFile";
        var url = bpServerPath() + "/bpService.asmx/writeSessionFile";
        var safeUrl = encodeURI(url);
        fileAccess.httpPost(safeUrl, safeBody, function (xmlhttp) {
            //---- SUCCESS ----
            var data = getDataFromResult(xmlhttp, false);
            callback(data);
        }, function (e) {
            //---- FAILURE ----
            fileFail("writeSessionFile", fileName, e);
        }, true);
    }
    beachParty.writeSessionFile = writeSessionFile;
    function publishSessionToWebPage(userName, fileName, contents, callback) {
        var bpUrl = location.href;
        var index = bpUrl.indexOf("?");
        if (index > -1) {
            bpUrl = bpUrl.substr(0, index);
        }
        var body = "userName=" + userName + "&fileName=" + fileName + "&contents=" + contents + "&bpUrl=" + bpUrl;
        var safeBody = encodeURIComponent(body);
        //var url = bpServerPath() + "/putData.asmx/writeSessionFile";
        var url = bpServerPath() + "/bpService.asmx/publishSessionToWebPage";
        var safeUrl = encodeURI(url);
        fileAccess.httpPost(safeUrl, safeBody, function (xmlhttp) {
            //---- SUCCESS ----
            var url = getDataFromResult(xmlhttp, false);
            //var myServer = bpServerPath();
            var fullUrl = sandDancePageServer() + "/" + url;
            callback(fullUrl);
        }, function (e) {
            //---- FAILURE ----
            fileFail("publishSessionToWebPage", fileName, e);
        }, true);
    }
    beachParty.publishSessionToWebPage = publishSessionToWebPage;
    function readSessionFile(sessionUrl, callback) {
        //var url = bpServerPath() + "/putData.asmx/readSessionFile?sessionUrl=" + sessionUrl;
        var url = bpServerPath() + "/bpService.asmx/readSessionFile?sessionUrl=" + sessionUrl;
        //var safeUrl = encodeURI(url);
        var httpReadJson = false; // download to us as text
        var async = true;
        httpRead(url, false, function (xmlhttp) {
            //---- SUCCESS (get as raw string, not JSON) ----
            var text = getDataFromResult(xmlhttp, false);
            if (callback) {
                callback(text);
            }
        }, function (e) {
            //---- FAILURE ----
            //throw "readSessionFile: error=" + e.response;
            fileFail("readSessionFile", sessionUrl, e);
        }, async);
    }
    beachParty.readSessionFile = readSessionFile;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// preloadMgr.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - manages the list of preload items (each describes how to load a known file).
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// Note: dataFrame does NOT change the original data, but it cache numeric vectors on-demand for each column. 
    var preloadMgrClass = (function () {
        function preloadMgrClass() {
            this.buildPreloads();
        }
        preloadMgrClass.prototype.getPreloads = function () {
            return this._preloads;
        };
        preloadMgrClass.prototype.getFilePreload = function (name) {
            name = name.toLowerCase();
            var preload = null;
            for (var i = 0; i < this._preloads.length; i++) {
                var pl = this._preloads[i];
                //if (pl.name.toLowerCase() == name)
                if (pl.dataName && pl.dataName.toLowerCase() == name) {
                    preload = pl;
                    break;
                }
            }
            return preload;
        };
        preloadMgrClass.prototype.buildPreloads = function () {
            var preloads = [];
            this._preloads = preloads;
            //var isNextEdition = (this._appMgr._edition != "client");
            //---- DEMOVOTE ORIG ----
            var demoVoteOrig = new beachParty.Preload("DemoVoteOrig", "demovote.txt", "Esri Census data for US merged with 2012 Election results", "Longitude", "Latitude", "Scatter");
            demoVoteOrig.addedBy = "sdrucker";
            demoVoteOrig.dateAdded = new Date("01/01/2014");
            demoVoteOrig.recordCount = 24669;
            demoVoteOrig.fieldList.push(new beachParty.PreloadField("Longitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVoteOrig.fieldList.push(new beachParty.PreloadField("Latitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVoteOrig.mergeFieldList = true;
            demoVoteOrig.showInFileOpen = false; // test mode
            preloads.push(demoVoteOrig);
            //---- DEMOVOTE CLEAN (OK for us to publish) ----
            var demoVoteClearn = new beachParty.Preload("DemoVote", "demovoteclean.txt", "2014 US Census data merged with 2012 Election results", "Longitude", "Latitude", "Scatter");
            demoVoteClearn.addedBy = "sdrucker";
            demoVoteClearn.dateAdded = new Date("03/18/2016");
            demoVoteClearn.recordCount = 24669;
            demoVoteClearn.fieldList.push(new beachParty.PreloadField("Longitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVoteClearn.fieldList.push(new beachParty.PreloadField("Latitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVoteClearn.mergeFieldList = true;
            demoVoteClearn.description = "In the 'DemoVote' dataset, each record represents a US polling place (roughly corresponds to a county)";
            preloads.push(demoVoteClearn);
            //---- DEMOVOTE 5 ----
            var demoVote5 = new beachParty.Preload("DemoVote5", "demovote5.txt", "2014 US Census data merged with 2012 Election results", "Longitude", "Latitude", "Scatter");
            demoVote5.addedBy = "rfernand";
            demoVote5.dateAdded = new Date("9/13/2016");
            demoVote5.recordCount = 5;
            demoVote5.fieldList.push(new beachParty.PreloadField("Longitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVote5.fieldList.push(new beachParty.PreloadField("Latitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVote5.mergeFieldList = true;
            demoVote5.description = "In the 'DemoVote' dataset, each record represents a US polling place (roughly corresponds to a county)";
            demoVote5.showInFileOpen = false;
            preloads.push(demoVote5);
            //---- DEMOVOTE 25 ----
            var demoVote25 = new beachParty.Preload("DemoVote25", "demovote25.txt", "2014 US Census data merged with 2012 Election results", "Longitude", "Latitude", "Scatter");
            demoVote25.addedBy = "rfernand";
            demoVote25.dateAdded = new Date("9/13/2016");
            demoVote25.recordCount = 25;
            demoVote25.fieldList.push(new beachParty.PreloadField("Longitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVote25.fieldList.push(new beachParty.PreloadField("Latitude", undefined, undefined, "number", undefined, "#0.00"));
            demoVote25.mergeFieldList = true;
            demoVote25.description = "In the 'DemoVote' dataset, each record represents a US polling place (roughly corresponds to a county)";
            demoVote25.showInFileOpen = false;
            preloads.push(demoVote25);
            if (true) {
                //---- TrainInst ----
                var trainInst = new beachParty.Preload("TrainInst", "MLVis\\Train.inst.txt", "ML training data");
                trainInst.addedBy = "rfernand (via t-bijia)";
                trainInst.dateAdded = new Date("07/20/2015");
                trainInst.recordCount = 100000;
                trainInst.showInFileOpen = false;
                preloads.push(trainInst);
                //---- Million Rows ----
                var millionRows = new beachParty.Preload("MillionRows", "millionRowsTwoCols.csv", "BeachParty test data");
                millionRows.addedBy = "rfernand (via t-bijia)";
                millionRows.dateAdded = new Date("11/02/2015");
                millionRows.recordCount = 1000000;
                millionRows.showInFileOpen = false;
                preloads.push(millionRows);
                //---- Half Million Rows ----
                var halfMillionRows = new beachParty.Preload("HalfMillionRows", "halfMillionRows.csv", "BeachParty test data");
                halfMillionRows.addedBy = "rfernand";
                halfMillionRows.dateAdded = new Date("1/15/2016");
                halfMillionRows.recordCount = 500000;
                halfMillionRows.showInFileOpen = false;
                preloads.push(halfMillionRows);
            }
            //---- COLLEGES ----
            var colleges = new beachParty.Preload("Colleges", "Colleges.txt", "Data about colleges");
            colleges.addedBy = "sdrucker";
            colleges.dateAdded = new Date("02/01/2016");
            colleges.recordCount = 7804;
            colleges.description = "In the 'Colleges' dataset, each record represents a college and includes attributes like SAT scores and tuition";
            preloads.push(colleges);
            //---- TITANIC ----
            var useNew = true;
            if (useNew) {
                var titanic = new beachParty.Preload("Titanic", "TitanicMaster.txt", "Titanic Passenger Data");
                titanic.colMappings.x.colName = "Age";
                titanic.colMappings.y.colName = "TicketCost";
            }
            else {
                var titanic = new beachParty.Preload("Titanic", "TitanicRevised.txt", "Titanic Passenger Data", "Fare", "Age", "Scatter");
                titanic.addField("CabinClass", "The class of the passenger's ticket", null, null, ["first", "second", "third"]);
                titanic.addField("Survived", "Whether or not the passenger survived", null, null, ["TRUE", "FALSE"]);
                titanic.addField("Name", "The name of the passenger");
                titanic.addField("Gender", "Whether the passenger was a male or a female", null, null, ["male", "female"]);
                titanic.addField("Age", "The age of the passenger at the time of the voyage");
                titanic.addField("TicketNumber", "The ticket number of the passenger");
                titanic.addField("Fare", "How much the passenger paid for his ticket (in US dollars)", null, "number");
                titanic.addField("Embarked", "The city in which the passenger boarded the Titanic");
            }
            titanic.addedBy = "sdrucker";
            titanic.dateAdded = new Date("10/15/2015");
            titanic.recordCount = 2207;
            titanic.description = "In the 'Titanic' dataset, each record represents a passenger on the Titanic's first (and only) voyage";
            preloads.push(titanic);
            //---- TITANIC 5 ----
            var titanic5 = new beachParty.Preload("Titanic5", "Titanic5.txt", "Titanic Passenger Data");
            titanic5.colMappings.x.colName = "Age";
            titanic5.colMappings.y.colName = "TicketCost";
            titanic5.addedBy = "rfernand";
            titanic5.dateAdded = new Date("9/13/2016");
            titanic5.recordCount = 5;
            titanic5.description = "In the 'Titanic' dataset, each record represents a passenger on the Titanic's first (and only) voyage";
            titanic5.showInFileOpen = false;
            preloads.push(titanic5);
            //---- TITANIC 25 ----
            var titanic25 = new beachParty.Preload("Titanic25", "Titanic25.txt", "Titanic Passenger Data");
            titanic25.colMappings.x.colName = "Age";
            titanic25.colMappings.y.colName = "TicketCost";
            titanic25.addedBy = "rfernand";
            titanic25.dateAdded = new Date("9/13/2016");
            titanic25.recordCount = 25;
            titanic25.description = "In the 'Titanic' dataset, each record represents a passenger on the Titanic's first (and only) voyage";
            titanic25.showInFileOpen = false;
            preloads.push(titanic25);
            //---- SALES ----
            var bigSales = new beachParty.Preload("Sales", "bigSalesData.csv", "Generated Sales Data", "Profit", "Sales", "Scatter");
            bigSales.hasTimeData = true;
            bigSales.recordCount = 8399;
            bigSales.description = "In the 'Sales' dataset, each record represents a sale, including customer, product, order, and shipping information";
            preloads.push(bigSales);
            //---- BABY NAMES ----
            var babyNames = new beachParty.Preload("BabyNames", "TopBabyNamesbyState.csv", "Top baby names, by state and year");
            babyNames.hasTimeData = true;
            babyNames.recordCount = 10506;
            babyNames.description = "In the 'BabyNames' dataset, each record represents the top name for each state in a given year";
            preloads.push(babyNames);
            //---- COFFEE SALES ----
            var coffeeSales = new beachParty.Preload("CoffeeSales", "CoffeeSales.txt", "Coffee sales data");
            coffeeSales.hasTimeData = true;
            coffeeSales.recordCount = 4248;
            coffeeSales.description = "In the 'CoffeeSales' dataset, each record represents sales aggregated by market, product type, and other attributes";
            preloads.push(coffeeSales);
            if (true) {
                //---- MGX SMALL ----
                var mgxSmall = new beachParty.Preload("MgxSmall", "mgxSmall.txt", "Microsoft Sales Data");
                mgxSmall.hasTimeData = true;
                mgxSmall.recordCount = 25634;
                mgxSmall.showInFileOpen = false;
                preloads.push(mgxSmall);
                //---- ATHENS CA ----
                var athensCa = new beachParty.Preload("AthensCa", "Athens\\ca_microsoft_analytic.3.txt", "Political Data for California");
                athensCa.hasTimeData = true;
                athensCa.recordCount = 4000000;
                athensCa.showInFileOpen = false;
                preloads.push(athensCa);
                ////---- STATES ----
                //var states = new Preload("States", "CensusData/StateSummary.csv", "US Census data on States (2012)");
                //states.addField("Name", "The state's name");
                //states.addField("Population", "The population of the state in 2012", "CENSUS2010POP");
                //states.addField("Change", "The change in population of the state, since the previous year", "NPOPCHG_2012");
                //states.addField("Births", "The number of births in the state for 2012", "BIRTHS2012");
                //states.addField("Deaths", "The number of deaths in the state for 2012", "DEATHS2012");
                //states.colMappings = new ColMappings("Population", "Longitude", null);
                //states.chartName = "Column";
                //states.prefilter = "Name == 'United States' || Name == 'Alaska' || Name == 'Puerto Rico' || Name == 'Hawaii' || " +
                //"Name.endsWith('Region')";
                //states.recordCount = 50;
                //preloads.push(states);
                ////---- FULLSTATES ----
                //var ttFields = ["Name", "CENSUS2010POP", "NPOPCHG_2012", "BIRTHS2012", "DEATHS2012"];
                //var fullStates = new Preload("FullStates", "CensusData/StateSummary.csv", "US Census data on States (2012)", null,
                //    "Population", "Longitude", null, "Column");
                //fullStates.tooltipFieldList = ttFields;
                //fullStates.recordCount = 57;
                //preloads.push(fullStates);
                //---- RAINFALL ----
                var rainFall = new beachParty.Preload("RainFall", "US-Rainfall.csv", "US Rainfall data");
                rainFall.hasTimeData = true;
                rainFall.addedBy = "dabrown";
                rainFall.dateAdded = new Date("04/02/2014");
                rainFall.recordCount = 240000; // FIX THIS
                rainFall.showInFileOpen = false;
                preloads.push(rainFall);
            }
            //---- MPG ----
            var mpg = new beachParty.Preload("MPG", "MPG.csv", "Car data, including miles/gallon", "cyl", "displ", "class", "Scatter");
            mpg.hasTimeData = true;
            mpg.recordCount = 234;
            mpg.description = "In the MPG dataset, each record represents miles/gallon data on a particular car type";
            preloads.push(mpg);
            if (true) {
                //---- McDonalds ----
                var macDs = new beachParty.Preload("McDonalds", "macD.csv", "Location of all US McDonald's restaurants");
                macDs.recordCount = 43166;
                macDs.showInFileOpen = false;
                preloads.push(macDs);
                //---- PITCHES ----
                var pitches = new beachParty.Preload("Pitches", "baseball-pitches.csv", "Data on baseball pitches", "x", "y", "Scatter");
                pitches.hasTimeData = true;
                pitches.addedBy = "sdrucker";
                pitches.dateAdded = new Date("12/10/2014");
                pitches.recordCount = 134588;
                pitches.showInFileOpen = false;
                preloads.push(pitches);
                //---- IBM ----
                var ibm = new beachParty.Preload("IBM", "stockQuotes/ibm.csv", "IBM Stock Quotes", "Date", "Close", "Scatter");
                ibm.hasTimeData = true;
                ibm.recordCount = 13194;
                ibm.showInFileOpen = false;
                preloads.push(ibm);
                //---- MSFT ----
                var msft = new beachParty.Preload("MSFT", "stockQuotes/msft.csv", "Microsoft Stock Quotes", "Date", "Close", "Scatter");
                msft.hasTimeData = true;
                msft.recordCount = 7115;
                msft.showInFileOpen = false;
                preloads.push(msft);
                //---- APPL ----
                var appl = new beachParty.Preload("APPL", "stockQuotes/appl.csv", "Apple Stock Quotes", "Date", "Close", "Scatter");
                appl.hasTimeData = true;
                appl.recordCount = 8440;
                appl.showInFileOpen = false;
                preloads.push(appl);
                //---- AMZN ----
                var amzn = new beachParty.Preload("AMZN", "stockQuotes/amzn.csv", "Amazon Stock Quotes", "Date", "Close", "Scatter");
                amzn.hasTimeData = true;
                amzn.recordCount = 4288;
                amzn.showInFileOpen = false;
                preloads.push(amzn);
                //---- FACEBOOK ----
                var facebook = new beachParty.Preload("FaceBook", "stockQuotes/fb.csv", "Facebook Stock Quotes", "Date", "Close", "Scatter");
                facebook.hasTimeData = true;
                facebook.recordCount = 511;
                facebook.showInFileOpen = false;
                preloads.push(facebook);
                //---- GOOGLE ----
                var google = new beachParty.Preload("Google", "stockQuotes/googl.csv", "Google Stock Quotes", "Date", "Close", "Scatter");
                google.hasTimeData = true;
                google.recordCount = 2463;
                google.showInFileOpen = false;
                preloads.push(google);
                //---- NETWORK (from Irina) ----
                var network = new beachParty.Preload("Network", "irina/network.csv", "Verizon Data");
                network.hasTimeData = true;
                network.recordCount = 3823;
                network.showInFileOpen = false;
                network.addedBy = "irinasp";
                preloads.push(network);
                //---- SALERIES (from Irina) ----
                var salaries = new beachParty.Preload("Salaries", "irina/salaries.csv", "Salary Data");
                salaries.hasTimeData = true;
                salaries.recordCount = 148654;
                salaries.showInFileOpen = false;
                salaries.addedBy = "irinasp";
                preloads.push(salaries);
                //---- SALERIES20 (from Irina) ----
                var salaries20 = new beachParty.Preload("Salaries20", "irina/salaries20.csv", "Salary Data");
                salaries20.hasTimeData = true;
                salaries20.recordCount = 20019;
                salaries20.showInFileOpen = false;
                salaries20.addedBy = "irinasp";
                preloads.push(salaries20);
                //---- SERVICE AREA (from Irina) ----
                var serviceArea = new beachParty.Preload("ServiceArea", "irina/serviceArea.csv", "Service Data");
                serviceArea.hasTimeData = true;
                serviceArea.recordCount = 42248;
                serviceArea.showInFileOpen = false;
                serviceArea.addedBy = "irinasp";
                preloads.push(serviceArea);
                //---- ADULT CENSUS ----
                var uciAdults = new beachParty.Preload("Adult Census", "http://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data", "Adult Census Data (from UCI repository)", "Col3", "Col4");
                uciAdults.addField("Age", "The age of the person", "Col1", "number");
                uciAdults.addField("WorkClass", "The type of employment that person has", "Col2");
                uciAdults.addField("Fnlwgt", "The census taker's estimate of household population", "Col3", "number");
                uciAdults.addField("Education", "The highest educational category acheived by the person", "Col4");
                uciAdults.addField("EdNum", "The numeric highest educational level acheived by the person", "Col5", "number");
                uciAdults.addField("Marital", "The marital status of the person", "Col6");
                uciAdults.addField("Occupation", "The occupation of the person", "Col7");
                uciAdults.addField("Relationship", "The primary family role of the person", "Col8");
                uciAdults.addField("Race", "The race of the person", "Col9");
                uciAdults.addField("Sex", "The biological sex of the person", "Col10");
                uciAdults.addField("CapitalGain", "Capital gains recorded", "Col11", "number");
                uciAdults.addField("CapitalLoss", "Capital losses recorded", "Col12", "number");
                uciAdults.addField("HoursPerWeek", "The number of hours worked per week by the person", "Col13", "number");
                uciAdults.addField("NativeCountry", "The country where the person was born", "Col14");
                uciAdults.addField("Income", "The income level for the person", "Col15");
                uciAdults.separator = ",";
                uciAdults.hasHeader = false;
                uciAdults.recordCount = 32562;
                uciAdults.showInFileOpen = false;
                preloads.push(uciAdults);
                //---- SQL server test ----
                var sqlServer = new beachParty.Preload("Headtrax (SQL 200K)", "Server=localhost;Database=Headtrax;User ID=vibedemo;Password=vibedemo;Trusted_Connection=False;", "Microsoft Headtrax employee/hire data");
                sqlServer.fileType = beachParty.FileType.sql;
                //sqlServer.tableName = "EmployeeData";
                sqlServer.queryString = "select * from EmployeeData where EmailName is not null";
                sqlServer.dataSampling = new beachParty.DataSampling(true, beachParty.SampleType.first, 25 * 1000, 25 * 1000);
                sqlServer.recordCount = 221353; // FIX THIS
                sqlServer.showInFileOpen = false;
                preloads.push(sqlServer);
                //---- KNOWN DATA (our "preloads" table)  ----
                var knownData = new beachParty.Preload("KnownData", "knownData.json", "The datasets that we know how to open");
                knownData.colMappings = new beachParty.ColMappings("dateAdded", "hasTimeData", null);
                knownData.hasTimeData = true;
                knownData.showInFileOpen = false;
                preloads.push(knownData);
            }
            //---- this must be last ----
            knownData.recordCount = preloads.length;
            //---- set file "fileSource" for all our preloads to "known" ----
            for (var i = 0; i < preloads.length; i++) {
                preloads[i].fileSource = "known";
            }
        };
        return preloadMgrClass;
    }());
    beachParty.preloadMgrClass = preloadMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    vector.ts - helper functions for working with vectors (of dataFrame).
//      - the vector can be a Float32Array or a number[].
//-------------------------------------------------------------------------------------
var vector;
(function (vector_1) {
    /** return the number of entries that are true (or == 1). */
    function countOn(vector) {
        var count = 0;
        if (vector) {
            for (var i = 0; i < vector.length; i++) {
                if (vector[i]) {
                    count++;
                }
            }
        }
        return count;
    }
    vector_1.countOn = countOn;
    /** return the number of entries that are false (or == 0). */
    function countOff(vector) {
        var count = 0;
        if (vector) {
            for (var i = 0; i < vector.length; i++) {
                if (!vector[i]) {
                    count++;
                }
            }
        }
        return count;
    }
    vector_1.countOff = countOff;
    /** set each entry to 0. */
    function clear(vector) {
        if (vector) {
            for (var i = 0; i < vector.length; i++) {
                vector[i] = 0;
            }
        }
    }
    vector_1.clear = clear;
    /** copy contents of source to dest. */
    function copy(dest, source) {
        for (var i = 0; i < dest.length; i++) {
            dest[i] = source[i];
        }
    }
    vector_1.copy = copy;
    /** compare contents of vector to vector2. */
    function compare(vector, vector2) {
        var isDiff = (vector.length != vector2.length);
        if (!isDiff) {
            for (var i = 0; i < vector.length; i++) {
                if (vector[i] != vector2[i]) {
                    isDiff = true;
                    break;
                }
            }
        }
        return isDiff;
    }
    vector_1.compare = compare;
})(vector || (vector = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    wdCompare.ts - compares 2 sets of wdParams.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var wdCompare = (function () {
        function wdCompare() {
        }
        wdCompare.valueEntriesMatch = function (entry1, entry2) {
            var match = true;
            if ((!entry1) || (!entry2)) {
                match = (entry1 == entry2);
            }
            else if (entry1.originalValue != entry2.originalValue) {
                match = false;
            }
            else if (entry1.newValue != entry2.newValue) {
                match = false;
            }
            return match;
        };
        wdCompare.valueMapsMatch = function (map1, map2) {
            var match = true;
            if ((!map1) || (!map2)) {
                match = (map1 == map2);
            }
            else {
                if (map1.length != map2.length) {
                    match = false;
                }
                else {
                    //---- check each entry ----
                    for (var i = 0; i < map1.length; i++) {
                        var f1 = map1[i];
                        var f2 = map2[i];
                        if (!this.valueEntriesMatch(f1, f2)) {
                            match = false;
                            break;
                        }
                    }
                }
            }
            return match;
        };
        wdCompare.fieldsMatch = function (f1, f2) {
            var match = true;
            if ((!f1) || (!f2)) {
                match = (f1 == f2);
            }
            else if (f1.name != f2.name) {
                match = false;
            }
            else if (f1.calcFieldExp != f2.calcFieldExp) {
                match = false;
            }
            else if (f1.description != f2.description) {
                match = false;
            }
            else if (f1.fieldType != f2.fieldType) {
                match = false;
            }
            else if (!vp.arrayEquals(f1.sortedValues, f2.sortedValues)) {
                match = false;
            }
            else if (!this.valueMapsMatch(f1.valueMap, f2.valueMap)) {
                match = false;
            }
            return match;
        };
        wdCompare.fieldListsMatch = function (list1, list2) {
            var match = true;
            if ((!list1) || (!list2)) {
                match = (list1 == list2);
            }
            else {
                if (list1.length != list2.length) {
                    match = false;
                }
                else {
                    //---- check each field ----
                    for (var i = 0; i < list1.length; i++) {
                        var f1 = list1[i];
                        var f2 = list2[i];
                        if (!this.fieldsMatch(f1, f2)) {
                            match = false;
                            break;
                        }
                    }
                }
            }
            return match;
        };
        return wdCompare;
    }());
    beachParty.wdCompare = wdCompare;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    baseLegend.ts - base class for BeachParty interactive legends.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var baseLegendClass = (function (_super) {
        __extends(baseLegendClass, _super);
        function baseLegendClass(chartRouter, legendName, rootName, titleElemName) {
            var _this = this;
            _super.call(this);
            //---- legend sizes ----
            this._maxPaletteHeight = 400;
            this._entryHeight = 0; // dynamically set to match font
            this._entryWidth = 20;
            this._labelVertOffset = 0;
            //---- hard events ----
            this.onSearchRequest = new beachParty.bpEvent();
            this.onPanelRequest = new beachParty.bpEvent();
            this._chartRouter = chartRouter;
            this._legendName = legendName;
            this._md = null;
            var root = vp.select("#" + rootName)
                .addClass("legend")
                .css("position", "relative")
                .css("left", "5px");
            //.css("border", "1px solid red")
            //---- add colName as TITLE ----
            var title = root.append("div")
                .addClass("textButton legendTitle")
                .id(titleElemName)
                .css("position", "relative")
                .css("top", "10px")
                .css("left", "-8px")
                .attach("click", function (e) {
                _this.onPanelRequest.trigger({ e: e });
            });
            //---- create a parent for the table, so we can position the continuous palette using it ----
            var holderParentW = root.append("div")
                .css("position", "relative")
                .css("overflow-y", "auto")
                .css("overflow-x", "hidden")
                .css("max-height", "400px")
                .css("padding-top", "10px"); // so that we don't cut off top label
            this._holderParent = holderParentW[0];
            var legendTableW = holderParentW.append("table")
                .addClass("legendHolder")
                .attr("cell-spacing", "0")
                .attr("cell-padding", "0");
            this._root = root[0];
            this._titleElem = title[0];
            this._legendTable = legendTableW[0];
        }
        baseLegendClass.prototype.doSearch = function (legendName, colName, fromValue, toValue, searchType, selectMode, selectKey) {
            this.onSearchRequest.trigger({
                legendName: legendName, colName: colName, fromValue: fromValue, toValue: toValue, searchType: searchType, selectMode: selectMode, selectKey: selectKey
            });
        };
        baseLegendClass.prototype.getColInfo = function (colName) {
            var chart = this._chartRouter.getChart();
            var dataFrame = chart.getDataFrame();
            var ci = dataFrame.getColInfo(colName);
            return ci;
        };
        baseLegendClass.prototype.show = function (value) {
            vp.select(this._root)
                .css("display", (value) ? "" : "none");
        };
        baseLegendClass.prototype.measureTextAndSetItemHeight = function () {
            //---- measure font & set _entryHeight accordingly ----
            var tempW = vp.select(document.body).append("div")
                .addClass("legendLabel")
                .css("position", "absolute")
                .css("opacity", "0")
                .text("wWgtyTZ"); // some text to measure with
            var rc = tempW.getBounds(null);
            tempW.remove();
            var entryHeight = Math.ceil(6 + rc.height);
            this._entryHeight = entryHeight;
        };
        baseLegendClass.prototype.buildLabelFormatter = function () {
            var md = this._md;
            var formatter = null;
            if (md && md.breaks) {
                var colInfo = this.getColInfo(md.colName);
                var colType = colInfo.colType;
                var minValue = md.breaks[0];
                var maxValue = md.breaks[md.breaks.length - 1];
                if (colType == "number") {
                    //TODO: write and use createNumFormatterFromrange() 
                    formatter = vp.formatters.createNumFormatterFromRange(minValue, maxValue, md.breaks.length);
                }
                else if (colType == "date") {
                    formatter = vp.formatters.createDateFormatterFromRange(minValue, maxValue, md.breaks.length);
                }
                else {
                    formatter = null;
                }
            }
            this._formatter = formatter;
        };
        baseLegendClass.prototype.formatLabel = function (value) {
            var text = value;
            if (this._formatter) {
                text = this._formatter(text);
            }
            if (text == "") {
                var chart = this._chartRouter.getChart();
                text = chart.blankValueStr();
            }
            return text;
        };
        baseLegendClass.prototype.rebuildLegendEx = function (md, breakCount, isNumeric) {
            if (md.isLegendBottomUp) {
                this.rebuildFromBottom(md, breakCount, isNumeric);
            }
            else {
                this.rebuildFromTop(md, breakCount, isNumeric);
            }
        };
        baseLegendClass.prototype.rebuildFromTop = function (md, breakCount, isNumeric) {
            this._md = md;
            //---- adjust bottom margin of title ----
            var entryHeight = this._entryHeight;
            var marg = .5 * entryHeight; // (isNumeric) ? (.35 * entryHeight) : (.3 * entryHeight);
            vp.select(this._titleElem).css("margin-bottom", marg + "px");
            var tableW = vp.select(this._legendTable)
                .clear();
            var lastIndex = (isNumeric) ? (breakCount - 1) : (breakCount - 1);
            this.buildLabelFormatter();
            //---- need to process in ascending value order so that each item can refer to its previous item ---
            //---- and build the click/selection information correctly.  We currently draw first label at top of legend ----
            for (var i = 0; i <= lastIndex; i++) {
                var rowW = tableW.append("tr");
                var isTop = (i == 0);
                var isBottom = (i == lastIndex - 1);
                var addPaletteTick = (i < lastIndex);
                var paletteIndex = i;
                //---- add the TD's ----
                var paletteW = rowW.append("td")
                    .css("padding", "0");
                var tickW = rowW.append("td").css("padding", "0");
                var labelW = rowW.append("td").css("padding", "0");
                if (isNumeric) {
                    //---- NUMERIC AXIS ----
                    if (addPaletteTick) {
                        this.fillPaletteEntry(paletteW, paletteIndex, isTop);
                        this.fillTickEntry(tickW, isBottom);
                    }
                    var yOffset = (isNumeric && i == 0) ? +1 : 0;
                    this.fillLabelEntry(labelW, i, yOffset);
                }
                else {
                    //---- CATEGORY AXIS ----
                    this.fillPaletteEntry(paletteW, i, isTop);
                    this.fillTickEntry(tickW, isBottom);
                    this.fillLabelEntry(labelW, i, 0);
                }
            }
        };
        baseLegendClass.prototype.rebuildFromBottom = function (md, breakCount, isNumeric) {
            this._md = md;
            //---- adjust bottom margin of title ----
            var entryHeight = this._entryHeight;
            var marg = .5 * entryHeight; // (isNumeric) ? (.35 * entryHeight) : (.3 * entryHeight);
            vp.select(this._titleElem).css("margin-bottom", marg + "px");
            var tableW = vp.select(this._legendTable)
                .clear();
            var lastIndex = (isNumeric) ? (breakCount - 1) : (breakCount - 1);
            this.buildLabelFormatter();
            //---- need to process in ascending value order so that each item can refer to its previous item ---
            //---- and build the click/selection information correctly.  We currently draw first label at top of legend ----
            for (var i = 0; i <= lastIndex; i++) {
                var rowW = tableW.prepend("tr");
                var isTop = (i == lastIndex);
                var isBottom = (i == 1);
                var addPaletteTick = (i > 0);
                var paletteIndex = i - 1;
                //---- add the TD's ----
                var paletteW = rowW.append("td")
                    .css("padding", "0");
                var tickW = rowW.append("td").css("padding", "0");
                var labelW = rowW.append("td").css("padding", "0");
                if (isNumeric) {
                    //---- NUMERIC AXIS ----
                    if (addPaletteTick) {
                        this.fillPaletteEntry(paletteW, paletteIndex, isTop);
                        this.fillTickEntry(tickW, isBottom);
                    }
                    var yOffset = (isNumeric && i == 0) ? +1 : 0;
                    this.fillLabelEntry(labelW, i, yOffset);
                }
                else {
                    //---- CATEGORY AXIS ----
                    this.fillPaletteEntry(paletteW, i, isTop);
                    this.fillTickEntry(tickW, isBottom);
                    this.fillLabelEntry(labelW, i, 0);
                }
            }
        };
        baseLegendClass.prototype.selectBox = function (index) {
            var elems = this._paletteElements;
            if (elems && elems.length) {
                if (index < 0) {
                    index += elems.length;
                }
                else {
                    //---- true elements start at index=1 ----
                    index++;
                }
                var elem = elems[index];
                var e = { target: elem };
                this.searchForEntryValues(e);
            }
        };
        baseLegendClass.prototype.search = function (colName, value) {
            var chart = this._chartRouter.getChart();
            chart.search(colName, value);
        };
        baseLegendClass.prototype.searchForEntryValues = function (e) {
            var elem = e.target;
            if (elem.colorIndex !== undefined) {
                //---- get text element from this PALETTE entry ----
                elem = this._textElems[elem.colorIndex];
            }
            var legendName = this._legendName;
            var key = legendName + "." + elem.axisKey; // "color." + elem.innerText;
            this.doSearch(legendName, elem.colName, elem.fromValue, elem.toValue, elem.searchType, undefined, key);
        };
        baseLegendClass.prototype.fillPaletteEntry = function (paletteW, i, isTop) {
        };
        baseLegendClass.prototype.fillTickEntry = function (parentW, addBottom) {
            var tickW = parentW.append("div")
                .addClass("legendTick")
                .css("height", (this._entryHeight - 2) + "px");
            if (addBottom) {
                tickW.css("border-bottom", "1px solid #777");
            }
        };
        baseLegendClass.prototype.fillLabelEntry = function (labelW, i, yOffset) {
        };
        return baseLegendClass;
    }(beachParty.dataChangerClass));
    beachParty.baseLegendClass = baseLegendClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    colorLegend.ts - draws an interactive, continuous/discreet color legend (color palette, ticks, labels).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var colorLegendClass = (function (_super) {
        __extends(colorLegendClass, _super);
        function colorLegendClass(chartRouter, rootName) {
            _super.call(this, chartRouter, "color", rootName, "colorLegendTitle");
            this._lastValue = null;
            this.rebuildLegend();
        }
        colorLegendClass.prototype.colorMapping = function (value) {
            if (arguments.length === 0) {
                return this._cm;
            }
            this._cm = value;
            this.onDataChanged("colorMapping");
            this.rebuildLegend();
        };
        colorLegendClass.prototype.rebuildLegend = function () {
            var cm = this._cm;
            var showLegend = (cm != null && cm.colorPalette != null && cm.colName != null && cm.colName != "");
            //---- show/hide legend ----
            this.show(showLegend);
            if (showLegend) {
                this.measureTextAndSetItemHeight();
                var name = cm.colName;
                vp.select(this._titleElem)
                    .text(name);
                if (this._continuousPalette) {
                    vp.select(this._continuousPalette).remove();
                    this._continuousPalette = null;
                }
                var colorPalette = cm.colorPalette;
                var breaks = cm.breaks;
                var count = colorPalette.length;
                if (breaks && breaks.length < count) {
                    count = breaks.length;
                }
                var colInfo = this.getColInfo(cm.colName);
                var colType = colInfo.colType;
                this._colType = colType;
                this._isNumeric = (colInfo.colType != "string"); // number or date
                this._lastValue = null;
                this._textElems = [];
                this._paletteElements = [];
                this.rebuildLegendEx(cm, breaks.length, this._isNumeric);
            }
        };
        colorLegendClass.prototype.buildContinuousPaletteDiv = function (tdW) {
            var cm = this._cm;
            var colorPalette = cm.colorPalette;
            var count = colorPalette.length;
            //---- as a workaround to appending it to the TD of first row (with rowSpan=999), which produces weird layout issues ----
            //---- we just plop it down as child of holderParent, using absolute positioning. ----
            var holderParentW = vp.select(this._holderParent);
            var paletteW = holderParentW.prepend("div")
                .addClass("continuousColorPalette")
                .css("position", "absolute")
                .css("left", "1px") // place within border
                .css("top", "10px"); // align with labels correctly
            var lg = "linear-gradient(";
            //---- go thru backwards, since we want the LIGHT colors at the top (and client palettes start with DARK) ----
            //for (var i = count - 1; i >= 0; i--)
            for (var i = 0; i < count; i++) {
                if (i != 0) {
                    lg += ",";
                }
                var cr = vp.color.colorFromPalette(colorPalette, i);
                lg += cr;
            }
            lg += ")";
            var paletteHeight = Math.min(this._maxPaletteHeight, this._entryHeight * count);
            //entryHeight = paletteHeight / count;
            //---- CONTINUOUS ----
            paletteW
                .css("background", lg)
                .css("height", paletteHeight + "px")
                .css("width", this._entryWidth + "px")
                .css("pointer-events", "none");
            //.addClass("colorPaletteEntry")
            return paletteW[0];
        };
        colorLegendClass.prototype.fillPaletteEntry = function (parentW, i, isTop) {
            var _this = this;
            var cm = this._cm;
            var colorPalette = cm.colorPalette;
            var breaks = cm.breaks;
            var cr = vp.color.colorFromPalette(colorPalette, i, 0, cm.isCycling);
            var text = (breaks) ? breaks[i] : "";
            if (cm.isContinuous) {
                //---- we will overlay this, so don't draw a color ----
                cr = "transparent";
            }
            //---- this will overlay the regular palette, but it will still be used for hit-testing ----
            if (isTop && cm.isContinuous) {
                this._continuousPalette = this.buildContinuousPaletteDiv(parentW);
                this._paletteElements[i] = this._continuousPalette;
            }
            var colorEntryW = parentW.append("div")
                .css("background-color", cr)
                .addClass("colorPaletteEntry")
                .css("width", this._entryWidth + "px")
                .css("height", (this._entryHeight - 2) + "px") // allow for mouseover, mousedown border without movement
                .customAttr("value", text)
                .attach("click", function (e) { return _this.searchForEntryValues(e); });
            colorEntryW[0].colorIndex = (this._isNumeric) ? (i + 1) : i;
            this._paletteElements[i] = colorEntryW[0];
        };
        colorLegendClass.prototype.fillLabelEntry = function (parentW, i, yOffset) {
            var _this = this;
            var cm = this._cm;
            var breaks = cm.breaks;
            var value = (breaks) ? breaks[i] : "";
            var text = this.formatLabel(value);
            var tooltip = (text == "Other") ? "All other values mapped here" : text;
            var labelW = parentW.append("div")
                .text(text)
                .addClass("clipText legendLabel")
                .title(tooltip)
                .attach("click", function (e) { return _this.searchForEntryValues(e); });
            if (this._isNumeric) {
                parentW
                    .css("position", "relative");
                //---- shift labels up and to the right ----
                labelW
                    .css("position", "relative")
                    .css("left", "8px")
                    .css("top", (yOffset - this._entryHeight / 2) + "px");
            }
            //---- add information to support click/select ----
            labelW[0].colName = cm.colName;
            labelW[0].axisKey = "box" + i;
            if (value == "Other") {
                labelW[0].fromValue = this._lastValue;
                labelW[0].toValue = this._lastValue;
                labelW[0].searchType = beachParty.TextSearchType.greaterThanEqual;
            }
            else if (this._isNumeric) {
                labelW[0].fromValue = (i == 0) ? value : this._lastValue;
                labelW[0].toValue = value;
                labelW[0].searchType = beachParty.TextSearchType.betweenInclusive;
            }
            else {
                labelW[0].fromValue = value;
                labelW[0].toValue = value;
                labelW[0].searchType = beachParty.TextSearchType.exactMatch;
            }
            var colorIndex = i; // (count - 1) - i;
            this._textElems[colorIndex] = labelW[0];
            this._lastValue = value;
        };
        return colorLegendClass;
    }(beachParty.baseLegendClass));
    beachParty.colorLegendClass = colorLegendClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    facetLegend.ts - draws an interactive, continuous/discreet color legend (color palette, ticks, labels).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var facetLegendClass = (function (_super) {
        __extends(facetLegendClass, _super);
        function facetLegendClass(rootName, cm) {
            var _this = this;
            _super.call(this);
            this._fm = cm;
            var root = vp.select("#" + rootName);
            //---- add colName as TITLE ----
            var title = root.append("span")
                .addClass("legendTitle textButton")
                .id("facetLegendTitle")
                .text(cm.colName)
                .attach("click", function (e) {
                _this.onDataChanged("facetColPickerRequest");
            });
            this._rootElem = root[0];
            this._titleElem = title[0];
            this.updateLegend();
        }
        facetLegendClass.prototype.facetMapping = function (value) {
            if (arguments.length === 0) {
                return this._fm;
            }
            this._fm = value;
            this.onDataChanged("facetMapping");
            this.updateLegend();
        };
        facetLegendClass.prototype.updateLegend = function () {
            var cm = this._fm;
            var name = cm.colName;
            vp.select(this._rootElem)
                .css("display", (name) ? "block" : "none");
            vp.select(this._titleElem)
                .text(name);
        };
        return facetLegendClass;
    }(beachParty.dataChangerClass));
    beachParty.facetLegendClass = facetLegendClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    facetLabelMgr.ts - manages the facet labels above each facet.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var facetLabelMgrClass = (function (_super) {
        __extends(facetLabelMgrClass, _super);
        function facetLabelMgrClass(chart, labelHolderElem) {
            _super.call(this);
            this._labelHolderElem = labelHolderElem;
            this._chart = chart;
        }
        facetLabelMgrClass.prototype.buildLabels = function (facetLayouts) {
            var _this = this;
            this._facetLayouts = facetLayouts;
            var rootW = vp.select(this._labelHolderElem);
            //---- clear previous labels ----
            rootW.clear();
            this._labelElements = [];
            if (facetLayouts && facetLayouts.length) {
                for (var i = 0; i < facetLayouts.length; i++) {
                    var fl = facetLayouts[i];
                    var rc = fl.labelBounds;
                    var text = fl.facelLabel;
                    if (!text) {
                        text = "<blank>";
                    }
                    //---- note that the text-align must be specified on the CONTAINTER ----
                    var divW = rootW.append("div")
                        .css("position", "absolute")
                        .css("text-align", "center")
                        .bounds(rc.left, rc.top + 0, rc.width, rc.height);
                    var labelW = divW.append("span")
                        .addClass("textButton facetLabel")
                        .css("pointer-events", "auto")
                        .css("position", "relative") // IE11 bug workaround
                        .text(text)
                        .attach("mousedown", function (e) {
                        //---- don't trigger a "tap" event in touchMgr ----
                        e.handled = true;
                        vp.events.cancelEventBubble(e);
                        vp.events.cancelEventDefault(e);
                        return false;
                    })
                        .attach("click", function (e) {
                        var elem = e.target;
                        var sp = elem.searchParams;
                        var boxKey = "facet." + elem.facetKey;
                        var selectMode = _this._chart.selectMode();
                        _this._chart.doSearch("Facet", sp.colName, sp.minValue, sp.maxValue, sp.searchType, selectMode, boxKey);
                        //---- don't trigger a "tap" event in touchMgr ----
                        vp.events.cancelEventBubble(e);
                        vp.events.cancelEventDefault(e);
                        return false;
                    });
                    labelW[0].searchParams = fl.searchParams;
                    labelW[0].facetKey = "box" + i;
                    this._labelElements.push(labelW[0]);
                }
            }
        };
        facetLabelMgrClass.prototype.getIndexOfLabel = function (label) {
            var index = -1;
            label = label.toLowerCase();
            for (var i = 0; i < this._labelElements.length; i++) {
                var elem = this._labelElements[i];
                if (elem.textContent.toLocaleLowerCase() == label) {
                    index = i;
                    break;
                }
            }
            return index;
        };
        /**
         * Used to select a facel label from the API.
         * @param index
         */
        facetLabelMgrClass.prototype.selectFacetLabel = function (index) {
            var elem = this._labelElements[index];
            var sp = elem.searchParams;
            this._chart.doSearch("Facet", sp.colName, sp.minValue, sp.maxValue, sp.searchType);
        };
        return facetLabelMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.facetLabelMgrClass = facetLabelMgrClass;
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    NumericVector.ts - defines a numeric version of a number, string, or data column.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** this represents a vector, usually extracted from a dataFrame, which has been converted to all numbers. */
    var NumericVector = (function () {
        function NumericVector(values, colName, colType, colInfo) {
            if (values instanceof Float32Array) {
                this.values = values;
            }
            else {
                this.values = new Float32Array(values);
            }
            this.colName = colName;
            this.colType = colType;
            this.colInfo = colInfo;
        }
        NumericVector.prototype.clone = function () {
            var newArray = new Float32Array(this.values);
            var nv = new NumericVector(newArray, this.colName, this.colType, this.colInfo);
            nv.keyInfo = this.keyInfo;
            return nv;
        };
        NumericVector.prototype.getRawData = function (index) {
            var value = (this.keyInfo) ? this.keyInfo.keysByRow[index] : this.values[index];
            return value;
        };
        NumericVector.prototype.count = function (value) {
            var count = 0;
            for (var i = 0; i < this.values.length; i++) {
                if (this.values[i] == value) {
                    count++;
                }
            }
            return count;
        };
        NumericVector.prototype.copy = function (indexes) {
            var newValues = new Float32Array(indexes.length);
            for (var i = 0; i < indexes.length; i++) {
                var index = indexes[i];
                var value = this.values[index];
                newValues[i] = value;
            }
            var nv = new NumericVector(newValues, this.colName, this.colType, this.colInfo);
            if (this.colType == "string") {
                beachParty.cbUtils.rebuildStringKeyIndexes(nv, indexes, this);
            }
            return nv;
        };
        return NumericVector;
    }());
    beachParty.NumericVector = NumericVector;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    namedVectors.ts - manages changes to 3D transform of chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var NamedVectors = (function () {
        function NamedVectors(length, x, y, z, colorIndex, imageIndex, staggerOffset, size, text, facet, selected, layoutFilter, enterExitFilter, primaryKey, randomX, randomY, red, green, blue, aux, rgb) {
            this.length = length;
            this.x = x;
            this.y = y;
            this.z = z;
            this.colorIndex = colorIndex;
            this.imageIndex = imageIndex;
            this.staggerOffset = staggerOffset;
            this.size = size;
            this.text = text;
            this.facet = facet;
            this.selected = selected;
            this.layoutFilter = layoutFilter;
            this.enterExitFilter = enterExitFilter;
            this.primaryKey = primaryKey;
            this.randomX = randomX;
            this.randomY = randomY;
            this.red = red;
            this.green = green;
            this.blue = blue;
            this.rgb = rgb;
            this.aux = aux;
        }
        NamedVectors.prototype.copy = function (indexes) {
            var nv = new NamedVectors(indexes.length);
            var keys = vp.utils.keys(this);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (key != "length" && this[key] != null) {
                    var numericVector = this[key];
                    var vector = numericVector.copy(indexes);
                    nv[key] = vector;
                }
            }
            return nv;
        };
        return NamedVectors;
    }());
    beachParty.NamedVectors = NamedVectors;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    cbUtils.ts - simple utils for this prototype.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var cbUtils = (function () {
        function cbUtils() {
        }
        cbUtils.buildColorsFromName = function () {
            cbUtils._colorFromName.aliceblue = [240, 248, 255];
            cbUtils._colorFromName.antiquewhite = [250, 235, 215];
            cbUtils._colorFromName.aqua = [0, 255, 255];
            cbUtils._colorFromName.aquamarine = [127, 255, 212];
            cbUtils._colorFromName.azure = [240, 255, 255];
            cbUtils._colorFromName.beige = [245, 245, 220];
            cbUtils._colorFromName.bisque = [255, 228, 196];
            cbUtils._colorFromName.black = [0, 0, 0];
            cbUtils._colorFromName.blanchedalmond = [255, 235, 205];
            cbUtils._colorFromName.blue = [0, 0, 255];
            cbUtils._colorFromName.blueviolet = [138, 43, 226];
            cbUtils._colorFromName.brown = [165, 42, 42];
            cbUtils._colorFromName.burlywood = [222, 184, 135];
            cbUtils._colorFromName.cadetblue = [95, 158, 160];
            cbUtils._colorFromName.chartreuse = [127, 255, 0];
            cbUtils._colorFromName.chocolate = [210, 105, 30];
            cbUtils._colorFromName.coral = [255, 127, 80];
            cbUtils._colorFromName.cornflowerblue = [100, 149, 237];
            cbUtils._colorFromName.cornsilk = [255, 248, 220];
            cbUtils._colorFromName.crimson = [220, 20, 60];
            cbUtils._colorFromName.cyan = [0, 255, 255];
            cbUtils._colorFromName.darkblue = [0, 0, 139];
            cbUtils._colorFromName.darkcyan = [0, 139, 139];
            cbUtils._colorFromName.darkgoldenrod = [184, 134, 11];
            cbUtils._colorFromName.darkgray = [169, 169, 169];
            cbUtils._colorFromName.darkgreen = [0, 100, 0];
            cbUtils._colorFromName.darkkhaki = [189, 183, 107];
            cbUtils._colorFromName.darkmagenta = [139, 0, 139];
            cbUtils._colorFromName.darkolivegreen = [85, 107, 47];
            cbUtils._colorFromName.darkorange = [255, 140, 0];
            cbUtils._colorFromName.darkorchid = [153, 50, 204];
            cbUtils._colorFromName.darkred = [139, 0, 0];
            cbUtils._colorFromName.darksalmon = [233, 150, 122];
            cbUtils._colorFromName.darkseagreen = [143, 188, 143];
            cbUtils._colorFromName.darkslateblue = [72, 61, 139];
            cbUtils._colorFromName.darkslategray = [47, 79, 79];
            cbUtils._colorFromName.darkturquoise = [0, 206, 209];
            cbUtils._colorFromName.darkviolet = [148, 0, 211];
            cbUtils._colorFromName.deeppink = [255, 20, 147];
            cbUtils._colorFromName.deepskyblue = [0, 191, 255];
            cbUtils._colorFromName.dimgray = [105, 105, 105];
            cbUtils._colorFromName.dodgerblue = [30, 144, 255];
            cbUtils._colorFromName.firebrick = [178, 34, 34];
            cbUtils._colorFromName.floralwhite = [255, 250, 240];
            cbUtils._colorFromName.forestgreen = [34, 139, 34];
            cbUtils._colorFromName.fuchsia = [255, 0, 255];
            cbUtils._colorFromName.gainsboro = [220, 220, 220];
            cbUtils._colorFromName.ghostwhite = [248, 248, 255];
            cbUtils._colorFromName.gold = [255, 215, 0];
            cbUtils._colorFromName.goldenrod = [218, 165, 32];
            cbUtils._colorFromName.gray = [128, 128, 128];
            cbUtils._colorFromName.green = [0, 128, 0];
            cbUtils._colorFromName.greenyellow = [173, 255, 47];
            cbUtils._colorFromName.honeydew = [240, 255, 240];
            cbUtils._colorFromName.hotpink = [255, 105, 180];
            cbUtils._colorFromName.indianred = [205, 92, 92];
            cbUtils._colorFromName.indigo = [75, 0, 130];
            cbUtils._colorFromName.ivory = [255, 255, 240];
            cbUtils._colorFromName.khaki = [240, 230, 140];
            cbUtils._colorFromName.lavender = [230, 230, 250];
            cbUtils._colorFromName.lavenderblush = [255, 240, 245];
            cbUtils._colorFromName.lawngreen = [124, 252, 0];
            cbUtils._colorFromName.lemonchiffon = [255, 250, 205];
            cbUtils._colorFromName.lightblue = [173, 216, 230];
            cbUtils._colorFromName.lightcoral = [240, 128, 128];
            cbUtils._colorFromName.lightcyan = [224, 255, 255];
            cbUtils._colorFromName.lightgoldenrodyellow = [250, 250, 210];
            cbUtils._colorFromName.lightgray = [211, 211, 211];
            cbUtils._colorFromName.lightgreen = [144, 238, 144];
            cbUtils._colorFromName.lightpink = [255, 182, 193];
            cbUtils._colorFromName.lightsalmon = [255, 160, 122];
            cbUtils._colorFromName.lightseagreen = [32, 178, 170];
            cbUtils._colorFromName.lightskyblue = [135, 206, 250];
            cbUtils._colorFromName.lightslategray = [119, 136, 153];
            cbUtils._colorFromName.lightsteelblue = [176, 196, 222];
            cbUtils._colorFromName.lightyellow = [255, 255, 224];
            cbUtils._colorFromName.lime = [0, 255, 0];
            cbUtils._colorFromName.limegreen = [50, 205, 50];
            cbUtils._colorFromName.linen = [250, 240, 230];
            cbUtils._colorFromName.magenta = [255, 0, 255];
            cbUtils._colorFromName.maroon = [128, 0, 0];
            cbUtils._colorFromName.mediumaquamarine = [102, 205, 170];
            cbUtils._colorFromName.mediumblue = [0, 0, 205];
            cbUtils._colorFromName.mediumorchid = [186, 85, 211];
            cbUtils._colorFromName.mediumpurple = [147, 112, 219];
            cbUtils._colorFromName.mediumseagreen = [60, 179, 113];
            cbUtils._colorFromName.mediumslateblue = [123, 104, 238];
            cbUtils._colorFromName.mediumspringgreen = [0, 250, 154];
            cbUtils._colorFromName.mediumturquoise = [72, 209, 204];
            cbUtils._colorFromName.mediumvioletred = [199, 21, 133];
            cbUtils._colorFromName.midnightblue = [25, 25, 112];
            cbUtils._colorFromName.mintcream = [245, 255, 250];
            cbUtils._colorFromName.mistyrose = [255, 228, 225];
            cbUtils._colorFromName.moccasin = [255, 228, 181];
            cbUtils._colorFromName.navajowhite = [255, 222, 173];
            cbUtils._colorFromName.navy = [0, 0, 128];
            cbUtils._colorFromName.oldlace = [253, 245, 230];
            cbUtils._colorFromName.olive = [128, 128, 0];
            cbUtils._colorFromName.olivedrab = [107, 142, 35];
            cbUtils._colorFromName.orange = [255, 165, 0];
            cbUtils._colorFromName.orangered = [255, 69, 0];
            cbUtils._colorFromName.orchid = [218, 112, 214];
            cbUtils._colorFromName.palegoldenrod = [238, 232, 170];
            cbUtils._colorFromName.palegreen = [152, 251, 152];
            cbUtils._colorFromName.paleturquoise = [175, 238, 238];
            cbUtils._colorFromName.palevioletred = [219, 112, 147];
            cbUtils._colorFromName.papayawhip = [255, 239, 213];
            cbUtils._colorFromName.peachpuff = [255, 218, 185];
            cbUtils._colorFromName.peru = [205, 133, 63];
            cbUtils._colorFromName.pink = [255, 192, 203];
            cbUtils._colorFromName.plum = [221, 160, 221];
            cbUtils._colorFromName.powderblue = [176, 224, 230];
            cbUtils._colorFromName.purple = [128, 0, 128];
            cbUtils._colorFromName.red = [255, 0, 0];
            cbUtils._colorFromName.rosybrown = [188, 143, 143];
            cbUtils._colorFromName.royalblue = [65, 105, 225];
            cbUtils._colorFromName.saddlebrown = [139, 69, 19];
            cbUtils._colorFromName.salmon = [250, 128, 114];
            cbUtils._colorFromName.sandybrown = [244, 164, 96];
            cbUtils._colorFromName.seagreen = [46, 139, 87];
            cbUtils._colorFromName.seashell = [255, 245, 238];
            cbUtils._colorFromName.sienna = [160, 82, 45];
            cbUtils._colorFromName.silver = [192, 192, 192];
            cbUtils._colorFromName.skyblue = [135, 206, 235];
            cbUtils._colorFromName.slateblue = [106, 90, 205];
            cbUtils._colorFromName.slategray = [112, 128, 144];
            cbUtils._colorFromName.snow = [255, 250, 250];
            cbUtils._colorFromName.springgreen = [0, 255, 127];
            cbUtils._colorFromName.steelblue = [70, 130, 180];
            cbUtils._colorFromName.tan = [210, 180, 140];
            cbUtils._colorFromName.teal = [0, 128, 128];
            cbUtils._colorFromName.thistle = [216, 191, 216];
            cbUtils._colorFromName.tomato = [255, 99, 71];
            cbUtils._colorFromName.transparent = [255, 255, 255];
            cbUtils._colorFromName.turquoise = [64, 224, 208];
            cbUtils._colorFromName.violet = [238, 130, 238];
            cbUtils._colorFromName.wheat = [245, 222, 179];
            cbUtils._colorFromName.white = [255, 255, 255];
            cbUtils._colorFromName.whitesmoke = [245, 245, 245];
            cbUtils._colorFromName.yellow = [255, 255, 0];
            cbUtils._colorFromName.yellowgreen = [154, 205, 50];
        };
        /** rebuild the 4 special properties for "toNV", based on info from the larger "fromNV" that toNV was built from. */
        cbUtils.rebuildStringKeyIndexes = function (toNV, indexes, fromNV) {
            var indexesByKey = {};
            var keysByIndex = {};
            var rowsByKey = {};
            var keysByRow = [];
            var nextKeyId = 0;
            var sortedKeys = fromNV.keyInfo.sortedKeys;
            var toVector = toNV.values;
            if (toVector && toVector.length) {
                //---- look like non-numbers; treat as string ----
                for (var i = 0; i < indexes.length; i++) {
                    var fromIndex = indexes[i];
                    var key = fromNV.keyInfo.keysByRow[fromIndex];
                    var keyValue = toVector[i];
                    indexesByKey[key] = keyValue;
                    keysByIndex[keyValue] = key;
                    var rows = rowsByKey[key];
                    if (rows === undefined) {
                        rows = [];
                        rowsByKey[key] = rows;
                        var si = sortedKeys.indexOf(key);
                        if (si == -1) {
                            sortedKeys.push(key);
                        }
                    }
                    rows.push(i);
                    keysByRow[i] = key;
                }
            }
            var keyInfo = new beachParty.KeyInfo(sortedKeys.length, indexesByKey, keysByIndex, rowsByKey, keysByRow, sortedKeys);
            toNV.keyInfo = keyInfo;
        };
        cbUtils.onFileOpenError = function (fileName, ex) {
            //---- separate error msg from stack trace ----
            var fullMsg = ex;
            ex = ex.replace(/&#39;/g, "'");
            var index = ex.indexOf("\r\n");
            if (index > -1) {
                ex = ex.substr(0, index);
            }
            //---- remove .NET error text ----
            index = ex.indexOf("returned an error: ");
            if (index > -1) {
                ex = ex.substr(index + 18);
            }
            var errorMsg = "Could not open '" + fileName + "' (error: " + ex + ").";
            vp.utils.debug(errorMsg);
            //---- this will be caught by the engine's window.onerror & sent back to the client ----
            throw errorMsg;
        };
        cbUtils.getDataLength = function (nv, applyFilter) {
            var length = (nv) ? nv.length : 0;
            if (applyFilter && nv && nv.layoutFilter) {
                var filter = nv.layoutFilter.values;
                length = vector.countOff(filter);
            }
            return length;
        };
        cbUtils.toBool = function (value) {
            var bValue = value;
            if (vp.utils.isString(value)) {
                var str = value.toLowerCase();
                bValue = (str == "true" || str == "1");
            }
            return bValue;
        };
        cbUtils.getMinMax = function (dataNumVector, filterNumVector, md) {
            var min = Number.MAX_VALUE;
            var max = -Number.MAX_VALUE;
            if (dataNumVector) {
                var dataVector = dataNumVector.values;
                var filterVector = (filterNumVector) ? filterNumVector.values : null;
                for (var i = 0; i < dataVector.length; i++) {
                    var value = dataVector[i];
                    if (!filterVector || !filterVector[i]) {
                        if (value < min) {
                            min = value;
                        }
                        if (value > max) {
                            max = value;
                        }
                    }
                }
            }
            else {
                min = 0;
                max = 1;
            }
            if (md.minBreak !== undefined) {
                min = md.minBreak;
            }
            else if (md.minBreakFacet !== undefined) {
                min = md.minBreakFacet;
            }
            if (md.maxBreak !== undefined) {
                max = md.maxBreak;
            }
            else if (md.maxBreakFacet !== undefined) {
                max = md.maxBreakFacet;
            }
            return { min: min, max: max };
        };
        cbUtils.makeRangeScale = function (dataVector, filterVector, rangeMin, rangeMax, constantDefault, md) {
            if (constantDefault === void 0) { constantDefault = 0; }
            var colType = (dataVector) ? dataVector.colType : null;
            var scale = null;
            if (colType == "string" || (md && md.forceCategory)) {
                //---- create CATEGORY scale ----
                /// NOTE: to ensure category scaling works when a filter is active, we need to use the true string key values for
                /// the catKeys, and when scaling, we will pass the true string key value.  This is necessary because when a 
                /// filter is active, the key numbers used in NumericVectors are not consecutive, like they are when the 
                /// filter is not active.
                var catKeys = cbUtils.getFilteredSortedKeys(dataVector, filterVector, md.forceCategory);
                scale = vp.scales.createCategoryKey()
                    .categoryKeys(catKeys)
                    .range(rangeMin, rangeMax);
            }
            else if (colType == "date") {
                var result = cbUtils.getMinMax(dataVector, filterVector, md);
                //---- create DATE scale ----
                var scale = vp.scales.createDate()
                    .domainMin(result.min)
                    .domainMax(result.max)
                    .rangeMin(rangeMin)
                    .rangeMax(rangeMax);
            }
            else {
                //---- create LINEAR scale ---
                var result = cbUtils.getMinMax(dataVector, filterVector, md);
                if (!dataVector) {
                    rangeMin = constantDefault;
                    rangeMax = constantDefault;
                }
                scale = vp.scales.createLinear()
                    .domainMin(result.min)
                    .domainMax(result.max)
                    .rangeMin(rangeMin)
                    .rangeMax(rangeMax);
            }
            this.buildFormatter(md, scale, colType);
            return scale;
        };
        cbUtils.buildFormatter = function (md, scale, colType) {
            if (md && md.formatting) {
                var anyScale = scale;
                anyScale._formatter = vp.formatters.createExcelFormatter(md.formatting, colType);
            }
        };
        /** this is used to scale palette-based attributes (like IMAGE and SHAPE), other than color. */
        cbUtils.makePaletteScale = function (dataVector, filterVector, palette, isContinuous, breaks, md) {
            /// Note: scale input/domain can be Continuous (number, date) or discrete (string).  scale out/range can be continuous or discrete.
            /// Scale construction needs to consider all 4 possible combinations.
            var colType = (dataVector) ? dataVector.colType : null;
            var scale = null;
            if (colType == "string") {
                //---- create CATEGORY scale ----
                //var catKeys = dataVector.keyInfo.sortedKeys;
                var catKeys = cbUtils.getFilteredSortedKeys(dataVector, filterVector);
                scale = vp.scales.createCategoryKey()
                    .categoryKeys(catKeys)
                    .palette(palette);
            }
            else {
                //---- create LINEAR scale ---
                if (breaks && breaks.length) {
                    //---- get min/max from breaks ----
                    var len = breaks.length;
                    var minVal = breaks[0];
                    var maxVal = breaks[len - 1];
                }
                else {
                    //---- get min/max from data ----
                    var result = cbUtils.getMinMax(dataVector, filterVector, md);
                    minVal = result.min;
                    maxVal = result.max;
                }
                scale = vp.scales.createLinear()
                    .domainMin(minVal)
                    .domainMax(maxVal)
                    .palette(palette)
                    .isPaletteDiscrete(!isContinuous);
            }
            this.buildFormatter(md, scale, colType);
            return scale;
        };
        cbUtils.makeLinearScale = function (min, max, rangeMin, rangeMax) {
            var linearScale = vp.scales.createLinear()
                .domainMin(min)
                .domainMax(max)
                .rangeMin(rangeMin)
                .rangeMax(rangeMax);
            return linearScale;
        };
        cbUtils.getCubeDefaultSize = function (shapeCount) {
            var logCount = Math.log10(shapeCount);
            var size = .1 / logCount;
            if (logCount < 3) {
                size *= 4;
            }
            else if (logCount < 3.5) {
                size *= 3;
            }
            else if (logCount < 4) {
                size *= 2;
            }
            //size /= 100;
            return size;
        };
        cbUtils.error = function (msg) {
            throw "Error: " + msg;
        };
        cbUtils.cloneMap = function (map) {
            var newMap = {};
            var keys = vp.utils.keys(map);
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var value = map[key];
                newMap[key] = value;
            }
            return newMap;
        };
        cbUtils.getFilteredSortedKeys = function (colDataInfo, filterVector, sortAsNumeric) {
            var keys = null;
            var hasKeyInfo = colDataInfo.keyInfo;
            var sortedKeys = (hasKeyInfo) ? colDataInfo.keyInfo.sortedKeys : null;
            if (!sortedKeys) {
                //---- force numeric values to strings and sort them ----
                var numKeys = colDataInfo.values.groupBy().map(function (pair) { return pair.key; });
                if (sortAsNumeric) {
                    sortedKeys = numKeys.orderByNum();
                }
                else {
                    sortedKeys = numKeys.orderByStr();
                }
            }
            if (sortedKeys) {
                keys = sortedKeys.slice(0); // duplicate array (since we will change it)
                var colData = colDataInfo.values;
                //---- must remove any key in KEYS that is completely filtered out ----
                if (filterVector) {
                    //---- use "colData" for building assignments, but "filteredData" for bin boundaries ----
                    var filteredData = [];
                    var filterValues = filterVector.values;
                    var inKeys = {};
                    for (var i = 0; i < colData.length; i++) {
                        if (!filterValues[i]) {
                            var key = (hasKeyInfo) ? colDataInfo.keyInfo.keysByRow[i] : (colData[i] + "");
                            inKeys[key] = true;
                        }
                    }
                    //---- test each key in KEYS - preserving the key order ----
                    for (var k = keys.length - 1; k >= 0; k--) {
                        var key = keys[k];
                        if (inKeys[key] === undefined) {
                            keys.removeAt(k);
                        }
                    }
                }
            }
            return keys;
        };
        cbUtils.isImageFile = function (fn) {
            var isImg = false;
            if (fn) {
                var ext = fn.substr(-4).toLowerCase(); // last 4 chars
                isImg = (ext == ".png" || ext == ".jpg" || ext == ".bmp");
            }
            return isImg;
        };
        cbUtils.getSizeOfMap = function (map, objList, forceCheck) {
            var total = 0;
            if (map) {
                if (forceCheck || !objList || objList.indexOf(map) == -1) {
                    if (!forceCheck && objList != null) {
                        //---- add this obj so that we never count it again ----
                        objList.push(map);
                    }
                    var keys = vp.utils.keys(map);
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        total += key.length;
                        var obj = map[key];
                        total += cbUtils.getSizeOfValue(obj, objList);
                    }
                    total += 8 * keys.length; // hashtable estimate
                }
            }
            return total;
        };
        cbUtils.getSizeOfValue = function (value, objList) {
            var total = 0;
            if (value) {
                total = 4; // estimated space for type info
                if (vp.utils.isNumber(value)) {
                    total += 8;
                }
                else if (vp.utils.isString(value)) {
                    total += value.length;
                }
                else if (vp.utils.isDate(value)) {
                    total += 8; // estimate
                }
                else if (value instanceof Float32Array) {
                    total += 4 * value.length;
                }
                else if (vp.utils.isArray(value)) {
                    var aray = value;
                    for (var i = 0; i < aray.length; i++) {
                        total += cbUtils.getSizeOfValue(aray[i], objList);
                    }
                    total += 8 * value.length; // ptrs to strings (estimated)
                }
                else {
                    //---- assume it is a map ----
                    total += cbUtils.getSizeOfMap(value, objList);
                }
            }
            return total;
        };
        /** get the approximate memory used exclusively by the specified objects (overlapping memory not counted).
         * Space used by functions and unusual memory types not counted.
         */
        cbUtils.getMemoryUse = function (memObjMap, memUseMap) {
            if (!memUseMap) {
                memUseMap = {};
            }
            var keys = vp.utils.keys(memObjMap);
            var objList = [];
            //---- build objList ----
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var obj = memObjMap[key];
                objList.push(obj);
            }
            //---- get size of each object ----
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var obj = memObjMap[key];
                var total = cbUtils.getSizeOfMap(obj, objList, true);
                memUseMap[key] = total;
            }
            return memUseMap;
        };
        cbUtils.arrayToString = function (aray, delim) {
            var str = "";
            for (var i = 0; i < aray.length; i++) {
                if (str != "") {
                    str += delim;
                }
                str += aray[i];
            }
            return str;
        };
        cbUtils.stringToArray = function (value, delim) {
            var parts = [];
            if (value) {
                parts = value.split(delim);
            }
            return parts;
        };
        /**
         *  The expression is parsed to ensure it only contains:
            - contant numbers and strings
            - standard JavaScript Math/Date/String functions
            - variables from "allowVariableList".
         * @param expression
         * @param allowedVariableList
         */
        cbUtils.isSafeExpression = function (expression, allowedVariableList) {
            //---- TODO: add parser code here to validate expression as safe ----
            return false;
        };
        /**
         *  Returns a function that be called to evaluate the specified expression.
         * @param expression
         */
        cbUtils.safeEval = function (expression, allowedVariableList) {
            var str = "return " + expression;
            if (!cbUtils.isSafeExpression(expression, allowedVariableList)) {
                throw "unsafe expression passed to safeEval()";
            }
            var func = new Function(str);
            return func;
        };
        /**
 *  Return a valid HTML color string for "cr".
 * @param cr
 */
        cbUtils.getBeachPartyColor = function (cr) {
            if (vp.utils.isString(cr)) {
                var crLow = cr.toLowerCase();
                if (crLow == "beach blue" || crLow == "beachblue") {
                    cr = "#0cf";
                }
                else if (crLow == "none" || crLow == "") {
                    cr = "transparent";
                }
            }
            return cr;
        };
        cbUtils.getBeachPartyName = function (cr) {
            var name = cr;
            if (vp.utils.isString(cr)) {
                var crLow = cr.toLowerCase();
                if (crLow == "transparent") {
                    name = "None";
                }
                else if (crLow == "#0cf" || crLow == "rgb(0, 204, 255)") {
                    name = "BeachBlue";
                }
            }
            return name;
        };
        cbUtils.colorFromName = function (cr) {
            var crLow = cbUtils.getBeachPartyColor(cr);
            cr = cbUtils._colorFromName[cr];
            return cr;
        };
        cbUtils._colorFromName = {};
        return cbUtils;
    }());
    beachParty.cbUtils = cbUtils;
    var SearchParamsEx = (function (_super) {
        __extends(SearchParamsEx, _super);
        function SearchParamsEx() {
            _super.apply(this, arguments);
        }
        return SearchParamsEx;
    }(beachParty.SearchParams));
    beachParty.SearchParamsEx = SearchParamsEx;
    cbUtils.buildColorsFromName();
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    touchMgr.ts - manages the chart touch events (using Hammer.js)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var touchMgrClass = (function (_super) {
        __extends(touchMgrClass, _super);
        function touchMgrClass(div, rubberBand, chart) {
            var _this = this;
            _super.call(this);
            this._inputAction = null; // "swipe", "percent", or "dragRect"
            this._insightIndex = 0;
            this._isHammerEnabled = false;
            this._maxTouchCount = 0; // within a "touch session" 
            this._ptDownInChartUx = false;
            this._lastSessionFinal = 0; // last mouse up time
            this._isPinching = false;
            this._isShowingWheel = false;
            this._transformMode = beachParty.ClientTransformMode.wheel;
            this._ptTouch = null;
            this._wheelTimer = null;
            this._isMouseDown = false;
            this._hasInertia = false;
            this._isCutomRecogEnabled = false;
            //---- removable callbacks for hammer event processing ----
            this._processInputCallback = null;
            this._doubleTabCallback = null;
            this._pinchStartCallback = null;
            this._doublePinchCallback = null;
            this._singlePanCallback = null;
            this._doublePanCallback = null;
            this._triplePanCallback = null;
            //---- prevent entering lower pointer modes as pointers are lifted ----
            this._tripleMode = null;
            this._doubleMode = null;
            //---- for throttling events ----
            this._delayTimer = null;
            this._isTouchEnabled = true;
            //---- events ----
            this.onActionDectected = new beachParty.bpEvent();
            this._div = div;
            this._rubberBandSelector = rubberBand;
            this._chart = chart;
            div.oncontextmenu = function () { return false; };
            //---- build removable callbacks ----
            this._processInputCallback = function (e) { return _this.processHammerInput(e); };
            this._doubleTabCallback = function (e) { return _this.processDoubleTap(e); };
            this._pinchStartCallback = function (e) { return _this.processPinchStart(e); };
            this._doublePinchCallback = function (e) { return _this.processDoublePinch(e); };
            this._singlePanCallback = function (e) { return _this.processSinglePan(e); };
            this._doublePanCallback = function (e) { return _this.processDoublePan(e); };
            this._triplePanCallback = function (e) { return _this.processTriplePan(e); };
        }
        touchMgrClass.prototype.isShowingWheel = function (value) {
            if (arguments.length == 0) {
                return this._isShowingWheel;
            }
            this._isShowingWheel = value;
            this._wheel.isActive(this._isShowingWheel);
            vp.utils.debug("toggleWheel: _isShowingWheel=" + this._isShowingWheel);
            this.onDataChanged("isShowingWheel");
        };
        touchMgrClass.prototype.shutDown = function () {
            this.isHammerEnabled(false);
        };
        touchMgrClass.prototype.setTransformMgr = function (transformMgr) {
            this._transformMgr = transformMgr;
            var wheelSize = 100; // gets resized later
            var svgElem = this._chart.getChartBuilder().getSvgDoc();
            this._svgDoc = svgElem;
            this._chartUxElem = this._chart.chartUxElement();
            this._wheel = new beachParty.transformWheelClass(svgElem, wheelSize);
            this._wheel.isActive(false);
        };
        touchMgrClass.prototype.isHammerEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isHammerEnabled;
            }
            this._isHammerEnabled = value;
            this.onHammerEnabledChanged();
        };
        touchMgrClass.prototype.processPinchStart = function (e) {
            this._doubleMode = "pinch";
            if (!this._tripleMode) {
                this._transformMgr.resetPanAndPinchDeltas();
            }
        };
        touchMgrClass.prototype.processDoublePinch = function (e) {
            if (!this._tripleMode) {
                if (this._isTouchEnabled) {
                    //---- ignore single finger when user is removing 1 finger at a time from pinch ----
                    var pointerCount = e.pointers.length;
                    if (pointerCount == 2) {
                        this._isPinching = true;
                        var touchPos = this.avgTouchPosition(e);
                        //vp.utils.debug("--> pinch event: x==" + touchPos.x + ", y=" + touchPos.y + ", scale=" + e.scale);
                        this._transformMgr.scaleCameraAbsolute(e.scale, touchPos);
                        this.drawSingleFrame("pinchZoom");
                        this.setNextMsgDelay();
                    }
                }
            }
        };
        touchMgrClass.prototype.drawSingleFrame = function (reason) {
            this._chart.getChartBuilder().redrawLastFrame(reason);
        };
        touchMgrClass.prototype.enablePinch = function (mc) {
            var anyHammer = Hammer;
            //---- threshold here is min. scale to recognize event; default=0 ----
            var pinch = mc.add(new anyHammer.Pinch({ pointers: 2, event: "doublePinch", direction: anyHammer.DIRECTION_ALL, time: 750, threshold: .15 }));
            mc.on('pinchstart', this._pinchStartCallback);
            mc.on('doublePinch', this._doublePinchCallback);
            return pinch;
        };
        touchMgrClass.prototype.processSinglePan = function (e) {
            if (!this._doubleMode && !this._tripleMode) {
                //vp.utils.debug("1 FINGER PAN detected");
                if (this._isShowingWheel) {
                    this.onPanEvent(e);
                }
            }
        };
        touchMgrClass.prototype.enablePan1 = function (mc) {
            //---- enable 1 finger PAN ----
            var anyHammer = Hammer;
            //---- threshold here is min. distance to recognize event; default=10 ----
            mc.add(new anyHammer.Pan({ pointers: 1, event: "singlePan", direction: anyHammer.DIRECTION_ALL, threshold: 10 }));
            mc.on("singlePan", this._singlePanCallback);
        };
        touchMgrClass.prototype.enableTap2 = function (mc) {
            //---- enable 2 finger TAP ----
            var anyHammer = Hammer;
            //---- threshold here is amount tab can move around; default=2 ----
            //---- time here is maximum pointer down time for recognition; default=250  ----
            mc.add(new anyHammer.Tap({ pointers: 2, event: "doubleTap", threshold: 9, time: 1000 }));
            mc.on("doubleTap", this._doubleTabCallback);
        };
        touchMgrClass.prototype.processDoubleTap = function (e) {
            if (!this._tripleMode) {
                this._doubleMode = "tap2";
                vp.utils.debug("2 FINGER --TAP-- detected");
                //---- call thru chart so that everything works correctly ----
                //this.toggleWheel();
                this._chart.toggleWheel();
            }
        };
        touchMgrClass.prototype.processDoublePan = function (e) {
            if (!this._tripleMode) {
                this._doubleMode = "pan2";
                vp.utils.debug("2 FINGER PAN detected");
                this.onPanEvent(e, false, true);
            }
        };
        touchMgrClass.prototype.enablePan2 = function (mc) {
            //---- enable 2 finger PAN ----
            var anyHammer = Hammer;
            //---- threshold here is min. distance to recognize event; default=10 ----
            var pan = mc.add(new anyHammer.Pan({ pointers: 2, event: "doublePan", direction: anyHammer.DIRECTION_ALL, threshold: 10 }));
            mc.on("doublePan", this._doublePanCallback);
            return pan;
        };
        touchMgrClass.prototype.enablePinchAndPan2 = function (mc) {
            var pinch = this.enablePinch(mc);
            var pan2 = this.enablePan2(mc);
            pinch.recognizeWith(pan2);
        };
        touchMgrClass.prototype.processTriplePan = function (e) {
            this._tripleMode = "pan3";
            vp.utils.debug("3 FINGER PAN detected");
            this.onPanEvent(e, true, false);
        };
        touchMgrClass.prototype.enablePan3 = function (mc) {
            //---- enable 3 finger PAN ----
            var anyHammer = Hammer;
            //---- threshold here is min. distance to recognize event; default=10 ----
            mc.add(new anyHammer.Pan({ pointers: 3, event: "triplePan", direction: anyHammer.DIRECTION_ALL, threshold: 3 }));
            mc.on("triplePan", this._triplePanCallback);
        };
        touchMgrClass.prototype.onHammerEnabledChanged = function () {
            var value = this._isHammerEnabled;
            if (value) {
                //this._rubberBandSelector.isEnabled(false);
                var myDiv = this._div;
                var anyHammer = window["Hammer"];
                if (anyHammer) {
                    var hammerOpts = { preventDefault: false };
                    //---- use the Hammer.Manager() form to start with no recognizers (so we control exactly what happens) ----
                    var mc = new anyHammer.Manager(myDiv, hammerOpts);
                    this._mc = mc;
                    mc.on("hammer.input", this._processInputCallback);
                    //this.enablePinch(mc);
                    //this.enablePan2(mc);      // this one does not work well with pinch
                    this.enablePinchAndPan2(mc);
                    this.enableTap2(mc);
                    this.enablePan3(mc);
                    this.enablePan1(mc); // use our custom recog for this
                    this.inputAction(null);
                }
            }
            else {
                //this._rubberBandSelector.isEnabled(true);
                if (this._mc) {
                    //---- an attemp to make Hammer release its event handlers, but not yet working ----
                    this._mc.off("hammer.input", this._processInputCallback);
                    this._mc.off("doubleTap", this._doubleTabCallback);
                    this._mc.off("pinchstart", this._pinchStartCallback);
                    this._mc.off("doublePinch", this._doublePinchCallback);
                    this._mc.off("singlePan", this._singlePanCallback);
                    this._mc.off("doublePan", this._doublePanCallback);
                    this._mc.off("triplePan", this._triplePanCallback);
                    //this._mc.remove(xx);
                    this._mc.enabled = false;
                    this._mc = null;
                }
            }
        };
        touchMgrClass.prototype.processHammerInput = function (e) {
            var _this = this;
            if (e.isFinal) {
                //---- when last pointer is lifted, reset our mode protector ----
                vp.utils.debug("input.isFinal=true");
                //---- put on small timer so we finish pending events before clearing this ----
                setTimeout(function (e) {
                    _this._doubleMode = null;
                    _this._tripleMode = null;
                    _this._wheel.partTouched("");
                }, 1);
            }
            this.onInput(e);
        };
        touchMgrClass.prototype.onPanEvent = function (e, forceRotate, forceMove) {
            var rotStep = Math.PI / 64;
            var view = this._chart;
            var lastTouch = this._ptTouch;
            var thisTouch = vp.events.mousePosition(e.srcEvent); //  this.avgTouchPosition(e);
            //vp.utils.debug("onPanEvent: lastTouch.x=" + lastTouch.x + ", .y=" + lastTouch.y);
            var deltaX = thisTouch.x - lastTouch.x;
            var deltaY = thisTouch.y - lastTouch.y;
            var partTouched = this._wheel.partTouched(); //  this.get3dWheelPartTouched(this._ptLastDown);
            this._ptTouch = thisTouch;
            var xDir = (deltaX >= 0) ? 1 : -1;
            var yDir = (deltaY >= 0) ? 1 : -1;
            var delta = (Math.abs(deltaX) > Math.abs(deltaY)) ? deltaX : deltaY;
            var speedFactor = 1 / 100;
            //vp.utils.debug("deltaX=" + deltaX + ", deltaY=" + deltaY);
            var drawReason = null;
            //---- make mouse event look like hammer event, if needed ----
            if (!e.srcEvent) {
                e.srcEvent = e;
            }
            if (!forceRotate) {
                forceRotate = (this._transformMode == beachParty.ClientTransformMode.rotate);
            }
            if (!forceMove) {
                forceMove = (this._transformMode == beachParty.ClientTransformMode.pan);
            }
            if (forceMove) {
                //---- MOVE ----
                this.moveCamera(e);
                drawReason = "moveCamera";
            }
            else {
                //---- ROTATE, AUTO, or WHEEL mode ----
                if (forceRotate) {
                    partTouched = "middle";
                }
                if ((e.srcEvent.ctrlKey && e.srcEvent.shiftKey) || (partTouched == "circle")) {
                    //---- CTRL + SHIFT + drag = SPIN ----
                    //vp.utils.debug("ROTATE-Z: value=" + delta);
                    this._transformMgr.rotateMatrixZ(delta * speedFactor);
                    drawReason = "rotateMatrixZ";
                }
                if ((e.srcEvent.ctrlKey) || (partTouched == "hBar") || (partTouched == "middle")) {
                    //---- CTRL + drag = TURN ----
                    //vp.utils.debug("ROTATE-Y: value=" + -deltaX);
                    //---- workaround until we figure out the right approach here ----
                    var usePostZ = (this._chart.chartName() == "Stacks");
                    this._transformMgr.rotateMatrixY(-deltaX * speedFactor, usePostZ);
                    drawReason = "rotateMatrixY";
                }
                if ((e.srcEvent.shiftKey) || (partTouched == "vBar") || (partTouched == "middle")) {
                    //---- SHIFT + drag = FLIP ----
                    //vp.utils.debug("ROTATE-X: value=" + -deltaY);
                    this._transformMgr.rotateMatrixX(-deltaY * speedFactor);
                    drawReason = "rotateMatrixX";
                }
                if ((!e.srcEvent.shiftKey) && (!e.srcEvent.ctrlKey) && (partTouched == "")) {
                    //---- MOVE ----
                    this.moveCamera(e);
                    drawReason = "moveCamera";
                }
                if (drawReason) {
                    this.drawSingleFrame(drawReason);
                }
            }
            this.setNextMsgDelay();
        };
        touchMgrClass.prototype.moveCamera = function (e) {
            vp.utils.debug("MOVE-X: x=" + e.deltaX + ", y=" + -e.deltaY);
            var mousePos = vp.events.mousePosition(e.srcEvent, this._chartUxElem);
            this._transformMgr.transformMode(beachParty.TransformMode.move);
            this._transformMgr.moveCamera(e.deltaX / 100, -e.deltaY / 100, mousePos);
        };
        touchMgrClass.prototype.setBounds = function (left, top, width, height) {
            //this._svgWidth = width;
            //this._svgHeight = height;
            //---- center the transformWheel ----
            var left = left + width / 2; // circle is drawn from center, so this works
            var top = top + height / 2; // - 10;      // fudge factor
            var wheelSize = Math.max(0, .8 * Math.min(width, height));
            this._wheel.wheelSize(wheelSize);
            vp.select(this._wheel._group)
                .translate(left, top);
        };
        touchMgrClass.prototype.setNextMsgDelay = function () {
            var _this = this;
            this._delayTimer = setTimeout(function (e) {
                _this._delayTimer = null;
                _this._isTouchEnabled = true;
            }, 15);
            this._isTouchEnabled = false;
        };
        touchMgrClass.prototype.inputAction = function (value, subAction, e) {
            if (arguments.length == 0) {
                return this._inputAction;
            }
            this._inputAction = value;
            //vp.utils.debug("touchMgr: inputAction set=" + value);
            if (this._isCutomRecogEnabled) {
                this.onActionDectected.trigger({ sender: this, action: value, subAction: subAction, evt: e });
            }
            if (e) {
                this.processOnAction(e);
            }
        };
        touchMgrClass.prototype.onMouseWheel = function (e) {
            var pt = vp.events.mousePosition(e);
            var factor = (e.wheelDelta > 0) ? 1.3 : (1 / 1.3);
            this._transformMgr.scaleCameraRelative(factor, pt);
            this.drawSingleFrame("mouseWheel");
        };
        /** Called from dataView, based on the chart's onFrame event. */
        touchMgrClass.prototype.onFrame = function () {
            this._hasInertia = this._transformMgr.onFrame();
            if (this._hasInertia) {
                this.drawSingleFrame("hasInertia");
            }
            if ((this._transformMode != beachParty.ClientTransformMode.none) && (!this._isMouseDown)) {
                var showIt = (!this._hasInertia); //  (this._showWheelDuringTransformMode && (!hasInertia));
            }
        };
        touchMgrClass.prototype.avgTouchPosition = function (e) {
            //vp.utils.debug("avgTouchPosition: e=" + e + ", e.pointers=" + e.pointers + ", avgTouchPosition.length=" + e.pointers.length);
            var pt = { x: 0, y: 0 };
            if (e.pointers) {
                //---- hammer.js event ----
                var count = e.pointers.length;
                for (var i = 0; i < count; i++) {
                    var pe = e.pointers[i];
                    var x = (pe.x === undefined) ? pe.clientX : pe.x;
                    var y = (pe.y === undefined) ? pe.clientY : pe.y;
                    //vp.utils.debug("avgTouchPosition: pe[" + i + "]: x=" + x + ", y=" + y);
                    pt.x += x;
                    pt.y += y;
                }
                if (count) {
                    pt.x /= count;
                    pt.y /= count;
                }
            }
            else {
                pt = vp.events.mousePosition(e);
            }
            //vp.utils.debug("avgTouchPosition: x=" + pt.x + ", y=" + pt.y);
            return pt;
        };
        touchMgrClass.prototype.processOnAction = function (e) {
            var action = this._inputAction;
            var origEvent = e.srcEvent;
            if (action == "dragRect") {
                if (!this._isShowingWheel) {
                    //---- route mouseDown to rubberBand ----
                    //vp.utils.debug("touchMgr: routing dragRect event to rubberBandSelector.onRubberDown");
                    this._rubberBandSelector.setMouseDown(this._ptMouseDown);
                    this._chart.enableTickBoxUI(false);
                }
            }
            else if (action == "tap") {
                if (!this._isShowingWheel) {
                    var pt = this._ptMouseDown;
                    if (this.isValidSelectionPos(pt)) {
                        //vp.utils.debug("touchMgr: routing tap event to rubberBandSelector.processExternalTap");
                        this._rubberBandSelector.setMouseDown(pt);
                        this._rubberBandSelector.processExternalUp(origEvent);
                    }
                }
            }
        };
        touchMgrClass.prototype.isValidSelectionPos = function (pt) {
            var isValid = true;
            var elem = vp.events.elementFromPoint(pt.x, pt.y);
            //---- is it a facet label? ----
            var elemW = vp.select(elem);
            if (elemW.hasClass("facetLabel")) {
                isValid = false;
            }
            else {
                //---- is point within the plot rectangle? ----
                var rc = vp.select(this._chartUxElem).getBounds();
                if (!vp.geom.rectContainsPoint(rc, pt)) {
                    isValid = false;
                }
            }
            return isValid;
        };
        touchMgrClass.prototype.detectInputAction = function (e) {
            var touchCount = e.pointers.length;
            //vp.utils.debug("==> touchCount=" + touchCount + ", velocityY=" + e.velocityY + ", deltaY=" + e.deltaY);
            if (touchCount == 1) {
                var isDragging = (Math.abs(e.deltaY) >= 3 || Math.abs(e.deltaX) >= 3);
                if (isDragging && e.deltaTime > 250) {
                    this.inputAction("dragRect", null, e);
                }
            }
            else if (touchCount == 2) {
                if (Math.abs(e.deltaY) > 10) {
                    var dir = (e.deltaY > 0) ? "down" : "up";
                    this._dir = dir;
                    if (Math.abs(e.deltaTime) < 500) {
                        this.inputAction("swipe", { dir: dir }, e);
                        this._insightIndex += (dir == "down") ? 1 : -1;
                    }
                    else {
                        this.inputAction("percent", { dir: dir }, e);
                    }
                }
            }
        };
        touchMgrClass.prototype.onMouseDown = function (e) {
            vp.utils.debug("onMouseDown called");
            var touchCount = e.pointers.length;
            this._transformMgr.onUiOpStart();
            this._isMouseDown = true;
            this._ptTouch = this.avgTouchPosition(e);
            var pt = vp.events.mousePosition(e, this._chartUxElem);
            //this._ptLastDown = pt;
            if (this._wheel.isActive()) {
                this.startWheelTimer();
            }
            //vp.utils.debug("---------------------------------------------------------------------");
            //vp.utils.debug("touchMgr: isFirst=true");
            this._ptMouseDown = vp.events.mousePosition(e.srcEvent);
            var rc = this._chart.getPlotBounds();
            this._ptDownInChartUx = (!e.srcEvent.handled || vp.geom.rectContainsPoint(rc, this._ptMouseDown));
            this.inputAction(null, null, e);
            if (this._isShowingWheel) {
                if (touchCount == 1) {
                    //---- trigger svg mousedown to get benefits of wheel hit testing ----
                    this._wheel.simulateMouseDown(e.srcEvent, this._chartUxElem);
                }
            }
            //---- ensure that mouse capture is OFF ----
            this._maxTouchCount = touchCount;
        };
        touchMgrClass.prototype.onMouseUp = function (e) {
            vp.utils.debug("onMouseUp called");
            //    if (this._inputAction == "dragRect")
            //    {
            //        //---- another UI control has stolen our mouseUp event; simulate our own now ----
            //        this._rubberBandSelector.cancelBanding(true, e);
            //        this._rubberBandSelector.processExternalUp(e);
            //        this.inputAction(null, e);
            //    }
            this._isMouseDown = false;
            this._isPinching = false;
            this._tripleMode = null;
            this._doubleMode = null;
            //vp.utils.debug("touchMgr: isFinal=" + e.isFinal);
            //---- require a min time between events to filter out finger noise ----
            var lastSessionTime = vp.utils.now() - this._lastSessionFinal;
            if (this._ptDownInChartUx) {
                if (this._maxTouchCount == 1 && this._inputAction == null && lastSessionTime > 500) {
                    this.inputAction("tap", null, e);
                }
            }
            this.inputAction(null, e);
            this._lastSessionFinal = vp.utils.now();
            this.stopWheelTimer();
            var hasInertia = this._transformMgr.onUiOpStop();
            if (this._transformMode != beachParty.ClientTransformMode.none) {
                //var showWheel = (this._transformMode == ClientTransformMode.wheel);
                if (this._wheel.isActive() && !hasInertia) {
                    this._wheel.show(true);
                }
            }
            //---- set focus to CANVAS so that we can hook KEYBOARD events ----
            this._chartUxElem.focus();
        };
        touchMgrClass.prototype.stopWheelTimer = function () {
            if (this._wheelTimer) {
                clearTimeout(this._wheelTimer);
                this._wheelTimer = null;
            }
        };
        touchMgrClass.prototype.startWheelTimer = function () {
            var _this = this;
            this.stopWheelTimer();
            if (this._transformMode != beachParty.ClientTransformMode.none) {
                this._wheelTimer = setTimeout(function (e) {
                    //---- after 500 ms of using wheel, hide it until mouse up ----
                    _this._wheel.show(false);
                }, 500);
            }
        };
        touchMgrClass.prototype.onInput = function (e) {
            var touchCount = e.pointers.length;
            if (e.isFirst) {
                this.onMouseDown(e);
            }
            else {
                if (touchCount > this._maxTouchCount) {
                    this._maxTouchCount = touchCount;
                }
            }
            if (!this._inputAction && this._ptDownInChartUx) {
                this.detectInputAction(e);
            }
            if (this._inputAction == "dragRect") {
                if (e.isFinal) {
                    if (!this._isShowingWheel) {
                        this._rubberBandSelector.processExternalUp(e.srcEvent);
                        this._chart.enableTickBoxUI(true);
                    }
                }
                else {
                    if (!this._isShowingWheel) {
                        this._rubberBandSelector.drawBand(e.srcEvent);
                        //---- workaround for IBeam (text) cursor showing up during drag in Chrome ----
                        vp.dom.css(this._chartUxElem, "cursor", "default");
                    }
                }
            }
            else if (this._inputAction == "percent") {
                var percent = Math.floor(.5 * e.deltaY) / 100;
                if (this._dir == "up") {
                    percent = 1 + percent;
                }
                if (percent < 0) {
                    percent = 0;
                }
                else if (percent > 1) {
                    percent = 1;
                }
                this.inputAction("percent", { value: percent }, e);
            }
            if (e.isFinal) {
                this.onMouseUp(e);
            }
        };
        return touchMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.touchMgrClass = touchMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    attr.ts - manages an attribute mapping for a chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var attrClass = (function (_super) {
        __extends(attrClass, _super);
        function attrClass(chart, md, target, userBinCount) {
            _super.call(this);
            this._mappingChangedCount = 0;
            this._isMappingEnabled = true;
            //---- events ----
            this.onColNameChange = new beachParty.bpEvent();
            this.onMappingDataChange = new beachParty.bpEvent();
            this._chart = chart;
            this._app = chart.getAppMin();
            this._md = md;
            this._target = target;
            if (userBinCount == undefined) {
                userBinCount = md.binCount;
            }
            this._customBreaks = "";
            this._customLabels = "";
            this._sliderBinCount = userBinCount;
            this._userNiceNumbers = false;
            this._limitBinsForStrings = true;
            //---- give each attribute a chance to remember info by column for its context ----
            this._colOptMgr = new beachParty.colOptionMgrClass();
        }
        /**
         *  don't store this since it changes whenever data is loaded (including the first load).
         */
        attrClass.prototype.getDataFrame = function () {
            return this._chart.getDataMgr().getDataFrame();
        };
        attrClass.prototype.isSet = function () {
            return (this._md.colName != null && this._md.colName != "");
        };
        attrClass.prototype.mappingData = function (value) {
            if (arguments.length == 0) {
                return this._md;
            }
            value.attrName = this._md.attrName;
            this._md = value;
            this._sliderBinCount = value.binCount;
            this.onDataChanged("sliderBinCount");
            this.onMappingChanged(true);
            //this.onDataChanged("mappingData");
        };
        attrClass.prototype.colName = function (value, omitLogging, rebindColInfo) {
            var md = this._md;
            if (arguments.length === 0) {
                return md.colName;
            }
            if (md.colName != value) {
                md.colName = value;
                vp.utils.debug("colName set to=" + value);
                //---- this is where all the work happens ----
                this.onColNameChanged();
                if (!omitLogging) {
                    this._app.logAction(beachParty.Gesture.select, null, beachParty.ElementType.picklist, beachParty.Action.adjust, this._target, true, { colName: value });
                }
            }
            if (rebindColInfo) {
                md.boundColInfo = null;
            }
        };
        attrClass.prototype.limitBinsForStrings = function (value) {
            if (arguments.length === 0) {
                return this._limitBinsForStrings;
            }
            this._limitBinsForStrings = value;
            this.onDataChanged("limitBinsForStrings");
        };
        attrClass.prototype.defaultBinCountForColumn = function (colName) {
            var ci = this.getDataFrame().getColInfo(colName);
            if (ci.colType == "string") {
                var maxCount = Math.min(beachParty.chartClass.maxCategoryBins, ci.stats.sortedKeys.length);
                var defaultCount = maxCount;
            }
            else {
                var maxCount = beachParty.chartClass.maxNumericBins;
                var defaultCount = beachParty.chartClass.defaultNumericBins;
            }
            var binCount = this._colOptMgr.getBinCount();
            if (binCount === undefined) {
                binCount = defaultCount;
            }
            return { binCount: binCount, maxCount: maxCount };
        };
        attrClass.prototype.getMaxKeysForColumn = function (colName) {
            var maxKeys = null;
            if (colName) {
                var ci = this.getDataFrame().getColInfo(colName);
                if (ci && ci.colType == "string") {
                    maxKeys = ci.stats.max + 1;
                }
            }
            return maxKeys;
        };
        attrClass.prototype.onColNameChanged = function (forceColRemap, omitOnMappingCall) {
            vp.utils.debug("onColNameChanged...");
            var md = this._md;
            if (this._colOptMgr && md.colName) {
                var opts = this._colOptMgr.getOrMakeOptions(md.colName);
                try {
                    //---- apply column-remembered options when we change our colName ----
                    this._isMappingEnabled = false; // prevent multiple calls during this sequence
                    this.forceCategory(opts.forceCategory, true);
                    this.customBreaks(opts.customBreaks, true);
                    this.useCustomBreaks(opts.useCustomBreaks, true);
                    this.customLabels(opts.customLabels, true);
                    this.useCustomLabels(opts.useCustomLabels, true);
                    this.useNiceNumbers(opts.useNiceNumbers, true);
                    if (opts.binCount !== undefined) {
                        this.binCount(opts.binCount, true);
                    }
                    var strBinSort = beachParty.BinSorting[opts.binSort];
                    this.binSorting(strBinSort, false, true);
                    var strSpread = beachParty.MappingSpread[opts.valueSpread];
                    this.valueSpread(strSpread, true);
                    this.setMappingDataFormatting();
                }
                finally {
                    this._isMappingEnabled = true;
                }
            }
            else {
                //---- reset selected properties when column mapping changed to null ----
                this.binSorting("none", false, false);
            }
            if (!omitOnMappingCall) {
                this.onMappingChanged(true);
            }
            //if (this._jsonPanel)
            //{
            //    this.updateAttrPanel(null);
            //}
            this.onDataChanged("colName");
            this.onColNameChange.trigger({ sender: this, attrName: this._md.attrName, colName: this._md.colName });
        };
        attrClass.prototype.calcCustomBreaks = function () {
            var md = this._md;
            //---- reset these by default ----
            md.breaks = null;
            md.minBreak = undefined;
            md.maxBreak = undefined;
            var cb = this._customBreaks;
            if (cb.contains(":")) {
                //---- min:max ----
                var mm = cb.split(":");
                if (mm.length == 2) {
                    md.minBreak = +mm[0];
                    md.maxBreak = +mm[1];
                }
            }
            else {
                var breaks = this.getCommaSeparatedValues(cb);
                md.breaks = breaks;
            }
        };
        attrClass.prototype.getCommaSeparatedValues = function (str) {
            var values = str.split(",");
            //---- trim each label ----
            for (var i = 0; i < values.length; i++) {
                var value = values[i];
                values[i] = value.trim();
            }
            return values;
        };
        attrClass.prototype.onCustomStuffChanged = function () {
            var md = this._md;
            var attrName = md.attrName;
            md.breaks = null;
            md.labels = null;
            if (this._useCustomBreaks && this._customBreaks) {
                this.calcCustomBreaks();
            }
            //---- see if CUSTOM LABELS have changed ----
            if (this._useCustomLabels && this._customLabels) {
                var labels = this.getCommaSeparatedValues(this._customLabels);
                md.labels = labels;
            }
            this.updateNiceNumbersInMapping(md);
            //---- send change to plot engine ----
            this.onMappingChanged();
        };
        attrClass.prototype.onMappingChanged = function (binCountChanged, omitDataChangedCall) {
            if (this._isMappingEnabled) {
                var md = this._md;
                var attrName = md.attrName;
                this._mappingChangedCount++;
                this.triggerColNameChanged();
                if (!binCountChanged) {
                    this.setBinCountFromDefault(omitDataChangedCall);
                }
                //if (this._chartName == "Line")
                //{
                //    this.sortItemColumn(md.colName);
                //}
                var app = this._chart.getAppMin();
                if (app.updateClusterPanel) {
                    app.updateClusterPanel();
                }
                //vp.utils.debug("attrMgr.onMappingChanged called (name=" + md.attrName + ", count=" + this._mappingChangedCount + ")");
                if (!omitDataChangedCall) {
                    this.triggerOnMappingDataChanged();
                }
            }
        };
        attrClass.prototype.triggerOnMappingDataChanged = function () {
            this.onDataChanged("mappingData");
            this.onMappingDataChange.trigger({ sender: this, attrName: this._md.attrName });
        };
        attrClass.prototype.triggerColNameChanged = function () {
            this.onDataChanged("colName");
        };
        attrClass.prototype.setBinCountFromDefault = function (omitNotify) {
            var md = this._md;
            var attrName = md.attrName;
            var chart = this._chart;
            var usingBins = (attrName == "color" || attrName == "size" || attrName == "shape");
            if (!usingBins) {
                usingBins = chart.isChartUsingBins(md.attrName);
            }
            if (md.colName && usingBins) {
                var result = this.defaultBinCountForColumn(md.colName);
                this.binCount(result.binCount, omitNotify);
            }
        };
        /**
         * The UI for bins is done thru "_sliderBinCount".  This is typically "0" for
         * AUTO or "9" (the default setting for non-AUTO capable attributes).  The actual
         * "binCount" in the _mappingData is the value used to the the mapping (which is never "0").
         * @param value
         * @param omitNotify
         */
        attrClass.prototype.sliderBinCount = function (value, omitNotify) {
            if (arguments.length === 0) {
                return this._sliderBinCount;
            }
            if (value != this._sliderBinCount) {
                this._sliderBinCount = value;
                this.onDataChanged("sliderBinCount");
                //---- remember the binCount the current column mapping ----
                var md = this._md;
                this._colOptMgr.setBinCount(md.colName, value);
                this.setTrueBinCount(value, omitNotify);
            }
        };
        attrClass.prototype.setTrueBinCount = function (value, omitNotify) {
            var md = this._md;
            var attrName = md.attrName;
            //---- set true binCount from value; don't exceed allowable maxKeys ----
            var trueBinCount = value;
            if (this._limitBinsForStrings) {
                var maxKeys = this.getMaxKeysForColumn(md.colName);
                if (maxKeys != null && maxKeys < trueBinCount) {
                    trueBinCount = maxKeys;
                }
            }
            vp.utils.debug(attrName + ": setTrueBinCount(): colName=" + md.colName + ", adjValue=" + trueBinCount);
            this.binCount(trueBinCount, omitNotify);
            //---- send change to plot engine ----
            this.onDataChanged("trueBinCount");
        };
        attrClass.prototype.binCount = function (value, omitNotify) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length === 0) {
                return md.binCount;
            }
            if (value != md.binCount) {
                md.binCount = value;
                this.updateNiceNumbersInMapping(md);
                if (!omitNotify) {
                    this.onMappingChanged(true);
                    this._app.logAction(beachParty.Gesture.dial, null, beachParty.ElementType.dial, beachParty.Action.adjust, this._target, true, { binCount: value });
                    this.onDataChanged("binCount");
                }
            }
        };
        attrClass.prototype.binSorting = function (value, disableNotify, skipOptionUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length === 0) {
                return beachParty.BinSorting[md.binSorting];
            }
            md.binSorting = beachParty.BinSorting[value];
            if (!disableNotify) {
                this.onMappingChanged();
                this.onDataChanged("binSorting");
                var logName = attrName + "BinSort";
                this._app.logAction(beachParty.Gesture.select, attrName + "Bins", beachParty.ElementType.radioButton, beachParty.Action.adjust, beachParty.Target.sortParams, true, { logName: beachParty.BinSorting[value] });
            }
            if (!skipOptionUpdate) {
                this._colOptMgr.setBinSort(md.binSorting);
            }
        };
        attrClass.prototype.setMappingDataFormatting = function () {
            var formatting = null;
            var md = this._md;
            if (md.colName) {
                var pf = this.getDataFrame().getPreloadField(md.colName);
                if (pf) {
                    formatting = pf.formatting;
                }
            }
            md.formatting = formatting;
        };
        attrClass.prototype.forceCategory = function (value, skipOptionUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length == 0) {
                return md.forceCategory;
            }
            md.forceCategory = value;
            this.onMappingChanged();
            this.onDataChanged("forceCategory");
            if (!skipOptionUpdate) {
                this._colOptMgr.setForceCategory(value);
            }
        };
        attrClass.prototype.useNiceNumbers = function (value, omitOptionUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length == 0) {
                //return md.useNiceNumbers;
                return this._userNiceNumbers;
            }
            //---- set these in sync ----
            this._userNiceNumbers = value;
            this.updateNiceNumbersInMapping(md);
            if (!omitOptionUpdate) {
                this._colOptMgr.setUseNiceNumbers(value);
            }
            this.onMappingChanged();
            this.onDataChanged("useNiceNumbers");
        };
        attrClass.prototype.updateNiceNumbersInMapping = function (md) {
            var userBinCount = this._sliderBinCount;
            md.useNiceNumbers = (this._userNiceNumbers || userBinCount == 0 ||
                ((md.minBreak !== undefined) && this._useCustomBreaks));
            md.isBinCountSoft = (userBinCount == 0);
            //---- keep md.binCount non-zero ----
            md.binCount = (userBinCount == 0) ? 9 : userBinCount;
        };
        attrClass.prototype.valueSpread = function (value, omitOptionUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length == 0) {
                return beachParty.MappingSpread[md.spread];
            }
            md.spread = beachParty.MappingSpread[value];
            if (!omitOptionUpdate) {
                this._colOptMgr.setValueSpread(md.spread);
            }
            this.onMappingChanged();
            this.onDataChanged("valueSpread");
        };
        attrClass.prototype.useCustomBreaks = function (value, skipOptUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length == 0) {
                return this._useCustomBreaks;
            }
            this._useCustomBreaks = value;
            if (!skipOptUpdate) {
                this._colOptMgr.setUseCustomBreaks(value);
            }
            this.onCustomStuffChanged();
            this.onDataChanged("useCustomBreaks");
        };
        attrClass.prototype.customBreaks = function (value, skipOptUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length == 0) {
                return this._customBreaks;
            }
            this._customBreaks = value;
            if (!skipOptUpdate) {
                this._colOptMgr.setCustomBreaks(value);
            }
            this.onCustomStuffChanged();
            this.onDataChanged("customBreaks");
        };
        attrClass.prototype.useCustomLabels = function (value, skipOptUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length == 0) {
                return this._useCustomLabels;
            }
            this._useCustomLabels = value;
            if (!skipOptUpdate) {
                this._colOptMgr.setUseCustomLabels(value);
            }
            this.onCustomStuffChanged();
            this.onDataChanged("useCustomLabels");
        };
        attrClass.prototype.customLabels = function (value, skipOptUpdate) {
            var md = this._md;
            var attrName = md.attrName;
            if (arguments.length == 0) {
                return this._customLabels;
            }
            this._customLabels = value;
            if (!skipOptUpdate) {
                this._colOptMgr.setCustomLabels(value);
            }
            this.onCustomStuffChanged();
            this.onDataChanged("customLabels");
        };
        attrClass.prototype.isLegendBottomUp = function (value, omitOptionUpdate) {
            var md = this._md;
            if (arguments.length == 0) {
                return md.isLegendBottomUp;
            }
            md.isLegendBottomUp = value;
            if (!omitOptionUpdate) {
                this._colOptMgr.setIsLegendBottomUp(value);
            }
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.isLegendBottomUp, true, { value: value });
            this.onDataChanged("isLegendBottomUp");
        };
        attrClass.prototype.clearForDataChanged = function () {
            var md = this._md;
            md.forceCategory = false;
            md.colName = null;
            var defaultBinCount = beachParty.chartClass.defaultNumericBins;
            md.binCount = defaultBinCount;
            this.triggerColNameChanged();
        };
        return attrClass;
    }(beachParty.dataChangerClass));
    beachParty.attrClass = attrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    auxAttr.ts - manages the AUX attribute (for the SIZE BY and LINE BY grouping).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var auxAttrClass = (function (_super) {
        __extends(auxAttrClass, _super);
        function auxAttrClass(chart, md, target) {
            _super.call(this, chart, md, target);
            this._countLayout = CountLayoutType.grid;
            this._sumLayout = SumLayoutType.squarify;
        }
        auxAttrClass.prototype.countLayout = function (value) {
            if (arguments.length == 0) {
                return CountLayoutType[this._countLayout];
            }
            this._countLayout = CountLayoutType[value];
            this.triggerColNameChanged();
            this.onDataChanged("countLayout");
        };
        auxAttrClass.prototype.sumLayout = function (value) {
            if (arguments.length == 0) {
                return SumLayoutType[this._sumLayout];
            }
            this._sumLayout = SumLayoutType[value];
            this.triggerColNameChanged();
            this.onDataChanged("sumLayout");
        };
        return auxAttrClass;
    }(beachParty.attrClass));
    beachParty.auxAttrClass = auxAttrClass;
    (function (CountLayoutType) {
        CountLayoutType[CountLayoutType["grid"] = 0] = "grid";
        CountLayoutType[CountLayoutType["percent"] = 1] = "percent";
    })(beachParty.CountLayoutType || (beachParty.CountLayoutType = {}));
    var CountLayoutType = beachParty.CountLayoutType;
    (function (SumLayoutType) {
        SumLayoutType[SumLayoutType["squarify"] = 0] = "squarify";
        SumLayoutType[SumLayoutType["strip"] = 1] = "strip";
    })(beachParty.SumLayoutType || (beachParty.SumLayoutType = {}));
    var SumLayoutType = beachParty.SumLayoutType;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chartRouter.ts - routes calls from UI to the currently active chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /**
     *  Would like to remove dynamic method routing to current chart and just use this as the
     *  holder of the current chart.  For now, we still need dynamic method routing for panels
     *  that dynamically connect with current chart.
     */
    var chartRouterClass = (function (_super) {
        __extends(chartRouterClass, _super);
        function chartRouterClass() {
            _super.call(this);
        }
        chartRouterClass.prototype.buildMethodRoutingTable = function (chart) {
            //---- build dynamic routine table ----
            var proto = Object.getPrototypeOf(chart);
            var keys = vp.utils.keys(proto);
            for (var i = 0; i < keys.length; i++) {
                var methodName = keys[i];
                if (methodName != "getChart" && methodName != "setChart") {
                    if (typeof chart[methodName] === "function") {
                        var currentChart = this._chart;
                        this[methodName] = this.makeMethod(methodName);
                    }
                }
            }
        };
        /**
         *  make a unique function that correctly captures the method name.
         * @param name
         */
        chartRouterClass.prototype.makeMethod = function (name) {
            var __this = this;
            return function () {
                var chart = __this.getChart();
                if (chart) {
                    return chart[name].apply(chart, arguments);
                }
            };
        };
        chartRouterClass.prototype.setChart = function (chart) {
            if (!this._chart) {
                //---- first chart ----
                this.buildMethodRoutingTable(chart);
            }
            this._chart = chart;
            this.onDataChanged("chart");
        };
        chartRouterClass.prototype.getChart = function () {
            return this._chart;
        };
        return chartRouterClass;
    }(beachParty.dataChangerClass));
    beachParty.chartRouterClass = chartRouterClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chartUx.ts - manages the user interaction with the chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// each chart gets one of these classes to handle UI events.
    var chartUxClass = (function (_super) {
        __extends(chartUxClass, _super);
        function chartUxClass(app, dataMgr, chart, maxToolTipColumns) {
            var _this = this;
            _super.call(this);
            //---- events ----
            this.onActionDectected = new beachParty.bpEvent();
            this.onCursorHitTest = new beachParty.bpEvent();
            this._app = app;
            this._chart = chart;
            this._toolTipMgr = new beachParty.toolTipMgrClass(app, dataMgr, chart, maxToolTipColumns);
            this.buildRubberBand();
            //---- use root of chart (vs uxElem) so Chrome works correctly ----
            var touchRootElem = chart.rootElement();
            this._touchMgr = new beachParty.touchMgrClass(touchRootElem, this._rubberBandSelector, chart);
            this._touchMgr.onActionDectected.attach(this, function (e) {
                _this.onActionDectected.trigger(e);
            });
            var chartUxElem = chart.chartUxElement();
            this._chartUxElem = chartUxElem;
            vp.select(document.body).attach("contextmenu", function (e) {
                vp.events.cancelEventDefault(e);
                vp.events.cancelEventBubble(e);
            });
            vp.select(document.body).attach("MSHoldVisual", function (e) {
                e.preventDefault;
                vp.events.cancelEventDefault(e);
                vp.events.cancelEventBubble(e);
                return false;
            });
            vp.select(window).attach("mouseup", function (e) { return _this.enableEngineUI(true); });
            var eventElemW = vp.select(this._chart.rootElement()); // chartElemUx
            //---- MOUSE MOVE for tooltips ----
            eventElemW.attach("mousemove", function (e) { return _this.onUxMouseMove(e); });
            //---- MOUSE OUT for turning off tooltips ----
            eventElemW.attach("mouseout", function (e) { return _this.onUxMouseOut(e); });
            //---- KEY DOWN for keyboard commands ----
            vp.select(window).attach("keydown", function (e) { return _this.onKeyDown(e); });
            //---- DBL CLICK for reset transform ----
            eventElemW.attach("dblclick", function (e) { return _this.onDblClick(e); });
            //---- MOUSE WHEEL ----
            eventElemW.attach("mousewheel", function (e) { return _this.onMouseWheel(e); });
            //---- MOUSE OVER for 3D circle ----
            //vp.select("#" + this._iframeId).attach("mouseover", (e) => this.onMouseOver(e));
            //---- CONTEXT MENU for toggling data tips on/off ----
            //vp.select(chartUxElem).attach("contextmenu", (e) => this.onPlotContextMenu(e));
        }
        chartUxClass.prototype.shutDownUI = function () {
            this._touchMgr.isHammerEnabled(false);
        };
        chartUxClass.prototype.postInit = function (transformMgr) {
            //---- delayed 2nd part of init ----
            this._touchMgr.setTransformMgr(transformMgr);
            this.uxMode(UxMode.touch);
        };
        chartUxClass.prototype.onDblClick = function (e) {
            //---- why does animatin get turned off here? ----
            this._chart.resetTransform();
        };
        chartUxClass.prototype.onKeyDown = function (e) {
            //---- TODO: add 3D nav keys here ----
            if (e.keyCode == vp.events.keyCodes.escape) {
                //---- why does animatin get turned off here? ----
                this._chart.resetTransform();
                this._chart.resetDataZoomMode();
            }
        };
        chartUxClass.prototype.enableRubberBand = function (value) {
            if (this._rubberBandSelector) {
                this._rubberBandSelector.isEnabled(value);
            }
        };
        //onPlotContextMenu(e)
        //{
        //    //---- TODO: with TOUCH interface, hover does not get set - fix this so that it works just based on current pt ----
        //    vp.utils.debug("chartUx: onPlotContextMenu called");
        //    this._rubberBandSelector.cancelPendingUpEvent();
        //    //---- force hover info to be updated (especially important for TOUCH interface) ----
        //    this.onUxMouseMove(e, (primaryKey, record) =>
        //    {
        //        var primaryKey = this._chart.hoverPrimaryKey();
        //        //vp.utils.debug("chartUx: onMouseMove callback: primaryKey=" + primaryKey);
        //        if (primaryKey)
        //        {
        //            var dataTipMgr = this._app.getDataTipMgr();
        //            var dataTip = dataTipMgr.getDataTip(primaryKey);
        //            //vp.utils.debug("chartUx: onMouseMove callback: dataTip=" + dataTip);
        //            if (dataTip)
        //            {
        //                //---- REMOVE dataTip ----
        //                dataTipMgr.closeDataTip(dataTip);
        //            }
        //            //else
        //            //{
        //            //    //---- ADD dataTip ----
        //            //    var colName = vp.select("#searchCol").text();
        //            //    var pt = vp.events.mousePosition(e);
        //            //    dataTipMgrClass.instance.addDataTip(colName, pt);
        //            //    vp.events.cancelEventBubble(e);
        //            //    vp.events.cancelEventDefault(e);
        //            //}
        //        }
        //    });
        //}
        chartUxClass.prototype.onMouseWheel = function (e) {
            this._touchMgr.onMouseWheel(e);
        };
        chartUxClass.prototype.onUxMouseOut = function (e, callback) {
            //vp.utils.debug("onUxMouseOut: turning tooltips OFF");
            this._mouseInCanvas = false;
            //this._toolTipMgr.hideToolTip();
            if (this._primaryKey != undefined) {
                this.processPrimaryKeyChanged({}, undefined, false, false, null, null);
            }
        };
        chartUxClass.prototype.screenToPlotCoordinates = function (x, y) {
            //---- make it relative to current PLOT ONLY area ----
            var rc = vp.select(this._chartUxElem).getBounds();
            x -= rc.left;
            y -= rc.top;
            return { x: x, y: y };
        };
        chartUxClass.prototype.onUxMouseMove = function (e, callback) {
            var _this = this;
            /// NOTE: hover information (the current hover shape) is used for both tooltips & the 
            /// hover rending effect (2 separate app options).
            var chart = this._chart;
            if (chart.hasData()) {
                //vp.utils.debug("onUxMouseMove: enabling tooltips");
                this._mouseInCanvas = true;
                var hoverEnabled = (chart.hoverEffect() != "none");
                var tooltipsEnabled = chart.isTooltipsEnabled();
                var hoverOnMoveEnabled = chart.hoverOnMouseMove();
                if (hoverEnabled && (tooltipsEnabled || hoverOnMoveEnabled) && e.buttons != 1) {
                    var screenPos = vp.events.mousePosition(e); //, this._chartUxElem);
                    var plotPos = this.screenToPlotCoordinates(screenPos.x, screenPos.y);
                    //vp.utils.debug("onUxMouseMove: mousePos=" + plotPos.x + ", " + plotPos.y);
                    //---- show tooltips if middle/right mouse button pressed, or if tooltips are enabled ----
                    var getRecord = (e.buttons != 0 || tooltipsEnabled);
                    var colList = this._chart.getActualToolTipColumns();
                    chart.applyHover(plotPos.x, plotPos.y, getRecord, colList, hoverOnMoveEnabled, function (primaryKey, record) {
                        if (_this._primaryKey != primaryKey && _this._mouseInCanvas) {
                            _this.processPrimaryKeyChanged(e, primaryKey, getRecord, tooltipsEnabled, record, colList);
                        }
                        _this.onCursorHitTest.trigger({ sender: _this, x: plotPos.x, y: plotPos.y, primaryKey: primaryKey });
                        if (callback) {
                            callback(primaryKey, record);
                        }
                    });
                }
            }
        };
        chartUxClass.prototype.processPrimaryKeyChanged = function (e, primaryKey, getRecord, tooltipsEnabled, record, colList) {
            var chart = this._chart;
            //vp.utils.debug("processPrimaryKeyChanged: old=" + this._primaryKey + ", new=" + primaryKey);
            this._primaryKey = primaryKey;
            if (chart.hoverOnMouseMove()) {
                chart.hoverPrimaryKey(primaryKey);
            }
            if (primaryKey && (getRecord || tooltipsEnabled)) {
                this._toolTipMgr.showToolTipForShape(e, primaryKey, record, colList);
            }
            else {
                //vp.select(this._chartUxElem).title("");
                this._toolTipMgr.hideToolTip();
            }
        };
        chartUxClass.prototype.enableEngineUI = function (value) {
            var charUxElem = this._chartUxElem;
            vp.select(charUxElem)
                .css("pointer-events", (value) ? "" : "none");
            if (!value) {
                //---- set focus so we can get keyboard events ----
                setTimeout(function (e) { return charUxElem; }, 10);
            }
        };
        chartUxClass.prototype.getTouchMgr = function () {
            return this._touchMgr;
        };
        chartUxClass.prototype.uxMode = function (value) {
            if (arguments.length == 0) {
                return this._uxMode;
            }
            this._uxMode = value;
            this.onUxModeChanged();
        };
        chartUxClass.prototype.onUxModeChanged = function () {
            var uxMode = this._uxMode;
            if (this._touchMgr) {
                this._touchMgr.isHammerEnabled(uxMode == UxMode.touch);
            }
            this.enableRubberBand(uxMode == UxMode.rubberBand);
            this.onDataChanged("uxMode");
        };
        chartUxClass.prototype.buildRubberBand = function () {
            var _this = this;
            var chartUxElem = this._chart.chartUxElement();
            this._rubberBandSelector = new beachParty.rubberBandSelectorClass(chartUxElem, true);
            //---- hook the RECT SELECT event ----
            this._rubberBandSelector.attachOnSelect(function (evt, rcScreen, toggle, mouseDownOrigin) {
                if (_this._chart.hasData() && !_this._chart.isSelectionLocked()) {
                    _this.onRubberBandSelect(evt, rcScreen, toggle, mouseDownOrigin);
                }
            });
            this._rubberBandSelector.registerForChange("mouseDown", function (e) {
                //---- mouse vs touch issue: turn off last tooltip info, or it shows wherever user touches screen (if cursor is over a shape) ----
                //this._chart.hideToolTip();
                _this._rubberBandSelector.forceToggle(_this._chart.isDataZoomMode());
                _this.enableEngineUI(false);
            });
            this._rubberBandSelector.isEnabled(true);
        };
        //getPlotBounds()
        //{
        //    var rc = this._chart.getBounds();
        //    return rc;
        //}
        /**
         * Process the window-relative rectangle coordinates from a drag-rectangle
         * mouse operation.
         * @param evt
         * @param rcBand
         * @param toggle
         * @param mouseDownOrigin
         */
        chartUxClass.prototype.onRubberBandSelect = function (evt, rcScreen, toggle, mouseDownOrigin) {
            //---- for now: "toggle" is set when we drag a rectangle with RIGHT mouse button down ----
            if (rcScreen) {
                //---- convert from screen-relative to plot-relative coordinates ----
                var plotPos = this.screenToPlotCoordinates(rcScreen.left, rcScreen.top);
                var rcPlot = vp.geom.createRect(plotPos.x, plotPos.y, rcScreen.width, rcScreen.height);
                vp.utils.debug("onRubberBandSelect: left=" + rcPlot.left + ", top=" + rcPlot.top +
                    ", width=" + rcPlot.width + ", height = " + rcPlot.height);
                if (this._chart.dragAction() == "zoomIn") {
                    toggle = true;
                }
                if (toggle || this._chart.getIsDataZoomMode()) {
                    var zoomIt = true;
                    if (!this._chart.getIsDataZoomMode()) {
                        //---- watch out for accidental use of right click vs. right drag ----
                        zoomIt = (Math.max(rcScreen.width, rcScreen.height) > 4);
                    }
                    if (zoomIt) {
                        this._chart.dataZoom(rcPlot, false);
                    }
                }
                else {
                    var sd = new beachParty.SelectionDesc();
                    sd.legendSource = "rect drag";
                    sd.rectSelect = rcPlot;
                    //---- todo: push event, not method call ----
                    this._app.setSelectionDesc(sd);
                    this._chart.rectSelect(rcPlot, this._chart.selectMode());
                }
            }
        };
        return chartUxClass;
    }(beachParty.dataChangerClass));
    beachParty.chartUxClass = chartUxClass;
    (function (UxMode) {
        UxMode[UxMode["touch"] = 0] = "touch";
        UxMode[UxMode["rubberBand"] = 1] = "rubberBand";
    })(beachParty.UxMode || (beachParty.UxMode = {}));
    var UxMode = beachParty.UxMode;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    colOptionMgr.ts - manages options for columns.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var colOptionMgrClass = (function (_super) {
        __extends(colOptionMgrClass, _super);
        function colOptionMgrClass() {
            _super.call(this);
            this._optionsByColumn = {};
        }
        colOptionMgrClass.prototype.clear = function () {
            this._optionsByColumn = {};
        };
        colOptionMgrClass.prototype.getOrMakeOptions = function (colName) {
            var opts = null;
            if (true) {
                this._colName = colName;
                opts = this._optionsByColumn[colName];
                if (!opts) {
                    opts = new ColumnOptions();
                    this._optionsByColumn[this._colName] = opts;
                }
            }
            return opts;
        };
        colOptionMgrClass.prototype.setForceCategory = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.forceCategory = value;
        };
        colOptionMgrClass.prototype.getForceCategory = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.forceCategory;
        };
        colOptionMgrClass.prototype.setBinSort = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.binSort = value;
        };
        colOptionMgrClass.prototype.getBinSort = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.binSort;
        };
        colOptionMgrClass.prototype.setBinCount = function (colName, count) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.binCount = count;
        };
        colOptionMgrClass.prototype.getBinCount = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.binCount;
        };
        colOptionMgrClass.prototype.setUseCustomBreaks = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.useCustomBreaks = value;
        };
        colOptionMgrClass.prototype.getUseCustomBreaks = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.useCustomBreaks;
        };
        colOptionMgrClass.prototype.setCustomBreaks = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.customBreaks = value;
        };
        colOptionMgrClass.prototype.getCustomBreaks = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.customBreaks;
        };
        colOptionMgrClass.prototype.setUseCustomLabels = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.useCustomLabels = value;
        };
        colOptionMgrClass.prototype.getUseCustomLabels = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.useCustomLabels;
        };
        colOptionMgrClass.prototype.setCustomLabels = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.customLabels = value;
        };
        colOptionMgrClass.prototype.getCustomLabels = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.customLabels;
        };
        colOptionMgrClass.prototype.setUseNiceNumbers = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.useNiceNumbers = value;
        };
        colOptionMgrClass.prototype.getUseNiceNumbers = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.useNiceNumbers;
        };
        colOptionMgrClass.prototype.setValueSpread = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.valueSpread = value;
        };
        colOptionMgrClass.prototype.getValueSpread = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.valueSpread;
        };
        colOptionMgrClass.prototype.setIsLegendBottomUp = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.isLegendBottomUp = value;
        };
        colOptionMgrClass.prototype.getIsLegendBottomUp = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.isLegendBottomUp;
        };
        return colOptionMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.colOptionMgrClass = colOptionMgrClass;
    //---- per column options for session (not persisted) ----
    var ColumnOptions = (function () {
        function ColumnOptions() {
            this.binCount = undefined;
            this.binSort = beachParty.BinSorting.none;
            this.valueSpread = beachParty.MappingSpread.normal;
            this.customBreaks = "";
            this.customLabels = "";
        }
        return ColumnOptions;
    }());
    beachParty.ColumnOptions = ColumnOptions;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    colorAttr.ts - manages a single copy of the COLOR attribute for a chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var colorAttrClass = (function (_super) {
        __extends(colorAttrClass, _super);
        function colorAttrClass(app, chart, md, target, userBinCount) {
            if (userBinCount === void 0) { userBinCount = 0; }
            _super.call(this, chart, md, target, userBinCount);
            this._app = app;
            this._colorColOptMgr = new beachParty.colorColOptionMgrClass(chart.getDataMgr());
            this._colOptMgr = this._colorColOptMgr; // copy for baseclass
            this._colOptMgr.getOrMakeOptions(null);
            this._paletteMgr = app.getPaletteMgr();
        }
        colorAttrClass.prototype.setCustomPalette = function (palette) {
            var md = this._md;
            md.paletteName = "custom";
            md.paletteSetName = null;
            md.colorPalette = palette;
            this.onMappingChanged(false, true);
        };
        /**
         * If stepsRequested==0, compute an automatic value that gives nice results for numeric and date values.  For
           category, use 999 to allow all numbers to show
         */
        colorAttrClass.prototype.stepsRequested = function () {
            var md = this._md;
            var sr = this._sliderBinCount; //  md.colorSteps;
            return sr;
        };
        colorAttrClass.prototype.onMappingChanged = function (rebuildPalette, rebindColInfo) {
            if (this._isMappingEnabled) {
                var cm = this._md;
                var app = this._app;
                _super.prototype.onMappingChanged.call(this, false, true);
                if (this.isSet()) {
                    if (this.isSet() && (!cm.colorPalette || !cm.breaks)) {
                        rebuildPalette = true;
                    }
                    if (rebuildPalette) {
                        cm.breaks = null;
                    }
                    if (rebuildPalette && cm.paletteSetName) {
                        var palette = this._paletteMgr.getPaletteFromSettings(cm.paletteSetName, cm.paletteName, this.stepsRequested(), cm.isReversed, cm.isInverted);
                        cm.colorPalette = palette.values;
                    }
                    //---- use the currently bound FILTERED-IN data set, if available ----
                    var colInfo = cm.boundColInfo;
                    if (rebindColInfo || !colInfo || colInfo.name != cm.colName) {
                        //---- REBIND colInfo to current filter setting ----
                        colInfo = this.getDataFrame().getColInfo(cm.colName);
                        cm.boundColInfo = colInfo;
                    }
                    if (rebuildPalette || rebindColInfo) {
                        beachParty.paletteHelper.buildColorBreaks(cm, colInfo, this._chart.getUseNiceNumbers());
                    }
                }
                //---- push change to UI ----
                vp.select("#colorText")
                    .css("font-style", (cm.colName) ? "italic" : "normal");
                this.triggerOnMappingDataChanged();
                this.onDataChanged("rebuildColorPaletteList");
            }
        };
        colorAttrClass.prototype.getNamedPaletteFromSet = function (setName, name) {
            var cm = this._md;
            var app = this._app;
            name = name.toLowerCase();
            var pa = this._paletteMgr.getPaletteArray(setName, this.stepsRequested(), cm.isReversed, cm.isInverted);
            var palettes = pa.palettes;
            var palette = null;
            for (var i = 0; i < palettes.length; i++) {
                var pal = palettes[i];
                if (pal.name.toLowerCase() == name) {
                    palette = pal;
                    break;
                }
            }
            return palette;
        };
        colorAttrClass.prototype.setPaletteFromName = function (name, omitOptionUpdate) {
            var cm = this._md;
            var app = this._app;
            var pm = this._paletteMgr;
            if (this.isSet()) {
                //---- first try current palette set ----
                var setName = cm.paletteSetName;
                var palette = this.getNamedPaletteFromSet(setName, name);
                if (!palette) {
                    //---- try the other palette sets ----
                    //var setNames = app.getPaletteItems();
                    var setNames = this._paletteMgr.getPaletteItems();
                    for (var i = 0; i < setNames.length; i++) {
                        var setName = setNames[i];
                        if (setName != cm.paletteSetName) {
                            palette = this.getNamedPaletteFromSet(setName, name);
                            if (palette) {
                                break;
                            }
                        }
                    }
                }
                if (!omitOptionUpdate) {
                    this._colorColOptMgr.setPaletteName(name);
                }
                if (palette) {
                    if (setName != cm.paletteSetName) {
                        this.paletteSetName(setName);
                    }
                    this.colorPalette(palette);
                }
            }
        };
        colorAttrClass.prototype.onColNameChanged = function () {
            //---- do normal work ----
            _super.prototype.onColNameChanged.call(this, false, true);
            //---- update COLOR settings per new column ----
            var md = this._md;
            var opts = this._colOptMgr.getOrMakeOptions(md.colName);
            try {
                //---- apply column-remembered options when we change our colName ----
                this._isMappingEnabled = false; // prevent multiple calls during this sequence
                this.paletteSetName(opts.paletteSetName, true);
                this.setPaletteFromName(opts.paletteName, true);
                this.reverseColorPalette(opts.reverseColorPalette, true);
                this.invertColorPalette(opts.invertColorPalette, true);
                this.colorIsContinuous(opts.colorIsContinuous, true);
                this.colorIsCycling(opts.colorIsCycling, true);
                this.redColumn(opts.redColumn, true);
                this.greenColumn(opts.greenColumn, true);
                this.blueColumn(opts.blueColumn, true);
                this.rgbColumn(opts.rgbColumn, true);
                this.zapColorChannels();
                this.onMappingChanged(true, true);
            }
            finally {
                this._isMappingEnabled = true;
                this.onMappingChanged(true);
            }
        };
        colorAttrClass.prototype.zapColorChannels = function () {
            var cm = this._md;
            cm.channelMapping = null;
            this.onDataChanged("redColumn");
            this.onDataChanged("greenColumn");
            this.onDataChanged("blueColumn");
            this.onDataChanged("rgbColumn");
        };
        colorAttrClass.prototype.colorPaletteIndex = function (index) {
            this._paletteMgr.colorPaletteIndex(this, index);
        };
        colorAttrClass.prototype.getColorPaletteEntry = function (index) {
            return this._paletteMgr.getColorPaletteEntry(this, index);
        };
        colorAttrClass.prototype.remapColorData = function () {
            this.onMappingChanged(true, true);
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.button, beachParty.Action.remap, beachParty.Target.colorMapping, true);
        };
        //onColorMappingChanged(rebuildPalette: boolean, rebindColInfo?: boolean)
        //{
        //    this.onMappingChanged(rebuildPalette, rebindColInfo);
        //}
        colorAttrClass.prototype.colorSpread = function (value) {
            var cm = this._md;
            if (arguments.length == 0) {
                return beachParty.MappingSpread[cm.spread];
            }
            cm.spread = beachParty.MappingSpread[value];
            this.onDataChanged("spread");
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.colorSpread, true, { value: value });
            //---- zap the color channel info ----
            this.zapColorChannels();
            this.onMappingChanged(false);
        };
        colorAttrClass.prototype.colorForceCategory = function (value) {
            var cm = this._md;
            if (arguments.length == 0) {
                return cm.forceCategory;
            }
            cm.forceCategory = value;
            this.onDataChanged("forceCategory");
            this.onMappingChanged(false);
        };
        colorAttrClass.prototype.reverseColorPalette = function (value, omitOptionUpdate) {
            var cm = this._md;
            if (arguments.length == 0) {
                return cm.isReversed;
            }
            cm.isReversed = value;
            this.onDataChanged("reverseColorPalette");
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.colorReverse, true, { value: value });
            if (!omitOptionUpdate) {
                this._colorColOptMgr.setReverseColorPalette(value);
            }
            //---- zap the color channel info ----
            this.zapColorChannels();
            this.onMappingChanged(true);
        };
        colorAttrClass.prototype.invertColorPalette = function (value, omitOptionUpdate) {
            var cm = this._md;
            if (arguments.length == 0) {
                return cm.isInverted;
            }
            cm.isInverted = value;
            this.onDataChanged("invertColorPalette");
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.colorInvert, true, { value: value });
            if (!omitOptionUpdate) {
                this._colorColOptMgr.setInvertColorPalette(value);
            }
            //---- zap the color channel info ----
            this.zapColorChannels();
            this.onMappingChanged(true);
        };
        colorAttrClass.prototype.colorIsContinuous = function (value, omitOptionUpdate) {
            var cm = this._md;
            if (arguments.length == 0) {
                return cm.isContinuous;
            }
            cm.isContinuous = value;
            this.onDataChanged("colorIsContinuous");
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.colorContinuous, true, { value: value });
            if (!omitOptionUpdate) {
                this._colorColOptMgr.setColorIsContinuous(value);
            }
            //---- zap the color channel info ----
            this.zapColorChannels();
            this.onMappingChanged(false);
        };
        colorAttrClass.prototype.colorIsCycling = function (value, omitOptionUpdate) {
            var cm = this._md;
            if (arguments.length == 0) {
                return cm.isCycling;
            }
            cm.isCycling = value;
            this.onDataChanged("colorIsCycling");
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.colorCycling, true, { value: value });
            if (!omitOptionUpdate) {
                this._colorColOptMgr.setColorIsCycling(value);
            }
            //---- zap the color channel info ----
            this.zapColorChannels();
            this.onMappingChanged(true);
        };
        colorAttrClass.prototype.redColumn = function (value, omitOptionUpdate) {
            var cm = this._md;
            var ch = cm.channelMapping;
            if (arguments.length == 0) {
                var col = (ch && ch.redColumn) ? ch.redColumn : "";
                return col;
            }
            if (!value && !ch) {
            }
            else {
                if (!omitOptionUpdate) {
                    this._colorColOptMgr.setRedColumn(value);
                }
                if (!ch) {
                    ch = new beachParty.ChannelMappingData;
                    cm.channelMapping = ch;
                }
                ch.redColumn = value;
                this.onDataChanged("redColumn");
                this._app.logAction(beachParty.Gesture.select, "redCol", beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.channelMapping, true, { red: value != null });
                this.onChannelColumnChanged();
            }
        };
        colorAttrClass.prototype.onChannelColumnChanged = function () {
            var cm = this._md;
            var channelIsActive = false;
            if (cm.channelMapping) {
                var cmx = cm.channelMapping;
                if (cmx.redColumn || cmx.greenColumn || cmx.blueColumn || cmx.rgbColumn) {
                    channelIsActive = true;
                }
            }
            if (channelIsActive) {
                //---- zap the colName ----
                cm.colName = null;
                //---- zap the paletteName ----
                //cm.paletteName = null;
                this.onDataChanged("colorPalette");
            }
            else {
                //---- zap the channel ----
                this.zapColorChannels();
            }
            this.onDataChanged("colorColumn");
            this.onMappingChanged(false);
        };
        colorAttrClass.prototype.greenColumn = function (value, omitOptionUpdate) {
            var cm = this._md;
            var ch = cm.channelMapping;
            if (arguments.length == 0) {
                var col = (ch && ch.greenColumn) ? ch.greenColumn : "";
                return col;
            }
            if (!value && !ch) {
            }
            else {
                if (!omitOptionUpdate) {
                    this._colorColOptMgr.setGreenColumn(value);
                }
                if (!ch) {
                    ch = new beachParty.ChannelMappingData;
                    cm.channelMapping = ch;
                }
                ch.greenColumn = value;
                this.onDataChanged("greenColumn");
                this._app.logAction(beachParty.Gesture.select, "greenCol", beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.channelMapping, true, { green: value != null });
                this.onChannelColumnChanged();
            }
        };
        colorAttrClass.prototype.blueColumn = function (value, omitOptionUpdate) {
            var cm = this._md;
            var ch = cm.channelMapping;
            if (arguments.length == 0) {
                var col = (ch && ch.blueColumn) ? ch.blueColumn : "";
                return col;
            }
            if (!value && !ch) {
            }
            else {
                if (!omitOptionUpdate) {
                    this._colorColOptMgr.setBlueColumn(value);
                }
                if (!ch) {
                    ch = new beachParty.ChannelMappingData;
                    cm.channelMapping = ch;
                }
                ch.blueColumn = value;
                this.onDataChanged("blueColumn");
                this._app.logAction(beachParty.Gesture.select, "blueCol", beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.channelMapping, true, { blue: value != null });
                this.onChannelColumnChanged();
            }
        };
        colorAttrClass.prototype.rgbColumn = function (value, omitOptionUpdate) {
            var cm = this._md;
            var ch = cm.channelMapping;
            if (arguments.length == 0) {
                var col = (ch && ch.rgbColumn) ? ch.rgbColumn : "";
                return col;
            }
            if (!value && !ch) {
            }
            else {
                if (!omitOptionUpdate) {
                    this._colorColOptMgr.setRgbColumn(value);
                }
                if (!ch) {
                    ch = new beachParty.ChannelMappingData;
                    cm.channelMapping = ch;
                }
                ch.rgbColumn = value;
                this.onDataChanged("rgbColumn");
                this._app.logAction(beachParty.Gesture.select, "rgbColumn", beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.channelMapping, true, { rgb: value != null });
                this.onChannelColumnChanged();
            }
        };
        //---- supports the palettePicker in the color panel ----
        colorAttrClass.prototype.paletteSetName = function (value, omitOptionUpdate) {
            var cm = this._md;
            if (arguments.length == 0) {
                var setName = (cm.paletteSetName) ? cm.paletteSetName : "Sequential";
                return setName;
            }
            cm.paletteSetName = value;
            if (!omitOptionUpdate) {
                this._colorColOptMgr.setPaletteSetName(value);
            }
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.picklist, beachParty.Action.select, beachParty.Target.paletteSetPickList, true);
            //---- tell the color panel that a user action just happened ----
            //var panel = this._panelMgr.getPanel("colorPanel");
            //panel.onUserAction(null, false);
            this.onDataChanged("rebuildColorPaletteList");
            this.onDataChanged("paletteSetName");
        };
        colorAttrClass.prototype.colorPalette = function (value, omitOptionUpdate) {
            var cm = this._md;
            if (arguments.length == 0) {
                //---- hide colorPalette name when channel mapping is active ----
                return (cm.channelMapping) ? "" : cm.colorPalette;
            }
            cm.colorPalette = value.values;
            cm.paletteName = value.name;
            if (!omitOptionUpdate) {
                this._colorColOptMgr.setPaletteName(value.name);
            }
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.colorPalette, true, { setName: cm.paletteSetName, paletteName: cm.paletteName });
            this.onDataChanged("colorPalette");
            //this.onDataChanged("paletteName");
            //---- zap the color channel info ----
            this.zapColorChannels();
            this.onMappingChanged(true); // false);
        };
        return colorAttrClass;
    }(beachParty.attrClass));
    beachParty.colorAttrClass = colorAttrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    colorColOptionMgr.ts - manages options for COLOR columns.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var colorColOptionMgrClass = (function (_super) {
        __extends(colorColOptionMgrClass, _super);
        function colorColOptionMgrClass(dataMgr) {
            _super.call(this);
            this._dataMgr = dataMgr;
        }
        colorColOptionMgrClass.prototype.setDefaultOptions = function (opts, psSetName, paletteName) {
            opts.paletteSetName = psSetName;
            opts.paletteName = paletteName;
            opts.paletteIndex = undefined; // not yet set
        };
        colorColOptionMgrClass.prototype.setDefaultOptionsByColType = function (colName, opts) {
            if (colName) {
                var dataFrame = this._dataMgr.getDataFrame();
                var colInfo = dataFrame.getColInfo(colName);
                var colType = (colInfo) ? colInfo.colType : "string";
                if (colType == "string") {
                    this.setDefaultOptions(opts, "Qualitative", "Paired");
                }
                else if (colType == "date") {
                    this.setDefaultOptions(opts, "Sequential", "Blues");
                }
                else {
                    this.setDefaultOptions(opts, "Diverging", "RdBu");
                }
            }
        };
        colorColOptionMgrClass.prototype.getOrMakeOptions = function (colName) {
            var opts = null;
            if (true) {
                this._colName = colName;
                opts = this._optionsByColumn[colName];
                if (!opts) {
                    opts = new ColorColumnOptions();
                    this._optionsByColumn[this._colName] = opts;
                    this.setDefaultOptionsByColType(this._colName, opts);
                }
            }
            return opts;
        };
        colorColOptionMgrClass.prototype.setPaletteSetName = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.paletteSetName = value;
        };
        colorColOptionMgrClass.prototype.getPaletteSetName = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.paletteSetName;
        };
        colorColOptionMgrClass.prototype.setPaletteName = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.paletteName = value;
        };
        colorColOptionMgrClass.prototype.getPaletteName = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.paletteName;
        };
        colorColOptionMgrClass.prototype.setPaletteIndex = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.paletteIndex = value;
        };
        colorColOptionMgrClass.prototype.getPaletteIndex = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.paletteIndex;
        };
        colorColOptionMgrClass.prototype.setReverseColorPalette = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.reverseColorPalette = value;
        };
        colorColOptionMgrClass.prototype.getReverseColorPalette = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.reverseColorPalette;
        };
        colorColOptionMgrClass.prototype.setInvertColorPalette = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.invertColorPalette = value;
        };
        colorColOptionMgrClass.prototype.getInvertColorPalette = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.invertColorPalette;
        };
        colorColOptionMgrClass.prototype.setColorIsContinuous = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.colorIsContinuous = value;
        };
        colorColOptionMgrClass.prototype.getColorIsContiuous = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.colorIsContinuous;
        };
        colorColOptionMgrClass.prototype.setColorIsCycling = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.colorIsCycling = value;
        };
        colorColOptionMgrClass.prototype.getColorIsCycling = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.colorIsCycling;
        };
        colorColOptionMgrClass.prototype.setRedColumn = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.redColumn = value;
        };
        colorColOptionMgrClass.prototype.getRedColumn = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.redColumn;
        };
        colorColOptionMgrClass.prototype.setGreenColumn = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.greenColumn = value;
        };
        colorColOptionMgrClass.prototype.getGreenColumn = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.greenColumn;
        };
        colorColOptionMgrClass.prototype.setBlueColumn = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.blueColumn = value;
        };
        colorColOptionMgrClass.prototype.getBlueColumn = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.blueColumn;
        };
        colorColOptionMgrClass.prototype.setRgbColumn = function (value) {
            var opts = this.getOrMakeOptions(this._colName);
            opts.rgbColumn = value;
        };
        colorColOptionMgrClass.prototype.getRgbColumn = function () {
            var opts = this.getOrMakeOptions(this._colName);
            return opts.rgbColumn;
        };
        return colorColOptionMgrClass;
    }(beachParty.colOptionMgrClass));
    beachParty.colorColOptionMgrClass = colorColOptionMgrClass;
    //---- per column options for session (not persisted) ----
    var ColorColumnOptions = (function (_super) {
        __extends(ColorColumnOptions, _super);
        function ColorColumnOptions() {
            _super.call(this);
        }
        return ColorColumnOptions;
    }(beachParty.ColumnOptions));
    beachParty.ColorColumnOptions = ColorColumnOptions;
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chartInterfaces.ts - interafaces and min classes for BeachParty chart class.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var KeyInfo = (function () {
        function KeyInfo(keyCount, indexesByKey, keysByIndex, rowsByKey, keysByRow, sortedKeys) {
            this.keyCount = keyCount;
            this.indexesByKey = indexesByKey;
            this.keysByIndex = keysByIndex;
            this.rowsByKey = rowsByKey;
            this.keysByRow = keysByRow;
            this.sortedKeys = sortedKeys;
        }
        return KeyInfo;
    }());
    beachParty.KeyInfo = KeyInfo;
    var NamedPalette = (function () {
        function NamedPalette(name, values) {
            this.name = name;
            this.values = values;
        }
        return NamedPalette;
    }());
    beachParty.NamedPalette = NamedPalette;
    var appMinClass = (function () {
        function appMinClass() {
        }
        appMinClass.prototype.logAction = function (gesture, elementId, elementType, action, target, isUndoable, options, forceLog, nonLogOptions) {
        };
        appMinClass.prototype.getBlankValueStr = function () {
            return "<blank>";
        };
        appMinClass.prototype.getPaletteMgr = function () {
            return null;
        };
        //layoutScreen();
        appMinClass.prototype.getDataTipMgr = function () {
            return null;
        };
        appMinClass.prototype.getAppSettingsMgr = function () {
            return null;
        };
        appMinClass.prototype.getPanelMaster = function () {
            return null;
        };
        appMinClass.prototype.setSelectionDesc = function (selectDesc) {
            return null;
        };
        appMinClass.prototype.isLoggingEnabled = function (value) {
            return false;
        };
        return appMinClass;
    }());
    beachParty.appMinClass = appMinClass;
    var SpiralParams = (function () {
        function SpiralParams() {
            this.seed = 137.508;
        }
        return SpiralParams;
    }());
    beachParty.SpiralParams = SpiralParams;
    var ScatterParams = (function () {
        function ScatterParams(percentExpandX, percentExpandY) {
            if (percentExpandX === void 0) { percentExpandX = .5; }
            if (percentExpandY === void 0) { percentExpandY = .5; }
            this.percentExpandX = percentExpandX;
            this.percentExpandY = percentExpandY;
        }
        return ScatterParams;
    }());
    beachParty.ScatterParams = ScatterParams;
    var FlatParams = (function () {
        function FlatParams() {
            this.numColumns = 0; // not yet specified
            this.buildFromTop = false;
        }
        return FlatParams;
    }());
    beachParty.FlatParams = FlatParams;
    var SelectionParams = (function () {
        function SelectionParams() {
            this.unselectedParams = new beachParty.ColorParams(beachParty.ColorEffect.adjustSaturation, "yellow", .20);
            this.selectedParams = new beachParty.ColorParams(beachParty.ColorEffect.setColor, "yellow", .20);
        }
        return SelectionParams;
    }());
    beachParty.SelectionParams = SelectionParams;
    /**
     *  Describe a draw/animation cycle that is beginning.
     */
    var CycleDesc = (function () {
        function CycleDesc() {
        }
        return CycleDesc;
    }());
    beachParty.CycleDesc = CycleDesc;
    /**
     *  Informaton about a draw/animation cycle that has just ended.
     */
    var CycleStats = (function (_super) {
        __extends(CycleStats, _super);
        function CycleStats() {
            _super.apply(this, arguments);
        }
        return CycleStats;
    }(beachParty.ShapeStats));
    beachParty.CycleStats = CycleStats;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    lineAttr.ts - manages the LINE attribute for a chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var lineAttrClass = (function (_super) {
        __extends(lineAttrClass, _super);
        function lineAttrClass(chart, md, target) {
            _super.call(this, chart, md, target);
        }
        lineAttrClass.prototype.maxLineShapes = function (value, omitLogging) {
            var lm = this._md;
            if (arguments.length == 0) {
                return lm.maxShapes;
            }
            lm.maxShapes = value;
            this.onMappingChanged();
            if (!omitLogging) {
                this._app.logAction(beachParty.Gesture.drag, null, beachParty.ElementType.slider, beachParty.Action.adjust, beachParty.Target.lineMapping, true, { maxShapes: value });
            }
            this.onDataChanged("maxLineShapes");
        };
        lineAttrClass.prototype.lineColor = function (value, omitLogging) {
            var lm = this._md;
            if (arguments.length == 0) {
                return lm.color;
            }
            lm.color = value;
            this.onMappingChanged();
            if (!omitLogging) {
                this._app.logAction(beachParty.Gesture.select, null, beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.lineMapping, true, { lineColor: value });
            }
            this.onDataChanged("lineColor");
        };
        return lineAttrClass;
    }(beachParty.attrClass));
    beachParty.lineAttrClass = lineAttrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    logging.ts - defines structures needed for logging.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    //---- event logging enums - for consistent names ----
    (function (Gesture) {
        Gesture[Gesture["chatBot"] = 0] = "chatBot";
        Gesture[Gesture["click"] = 1] = "click";
        Gesture[Gesture["dblClick"] = 2] = "dblClick";
        Gesture[Gesture["dial"] = 3] = "dial";
        Gesture[Gesture["drag"] = 4] = "drag";
        Gesture[Gesture["editText"] = 5] = "editText";
        Gesture[Gesture["keyDown"] = 6] = "keyDown";
        Gesture[Gesture["none"] = 7] = "none";
        Gesture[Gesture["select"] = 8] = "select";
        Gesture[Gesture["system"] = 9] = "system";
        Gesture[Gesture["automatedTest"] = 10] = "automatedTest";
        Gesture[Gesture["notAvailable"] = 11] = "notAvailable";
    })(beachParty.Gesture || (beachParty.Gesture = {}));
    var Gesture = beachParty.Gesture;
    (function (ElementType) {
        ElementType[ElementType["button"] = 0] = "button";
        ElementType[ElementType["checkbox"] = 1] = "checkbox";
        ElementType[ElementType["canvas"] = 2] = "canvas";
        ElementType[ElementType["none"] = 3] = "none";
        ElementType[ElementType["dial"] = 4] = "dial";
        ElementType[ElementType["insightEntry"] = 5] = "insightEntry";
        ElementType[ElementType["menuItem"] = 6] = "menuItem";
        ElementType[ElementType["numAdjuster"] = 7] = "numAdjuster";
        ElementType[ElementType["slider"] = 8] = "slider";
        ElementType[ElementType["textBox"] = 9] = "textBox";
        ElementType[ElementType["panelTitle"] = 10] = "panelTitle";
        ElementType[ElementType["picklist"] = 11] = "picklist";
        ElementType[ElementType["radioButton"] = 12] = "radioButton";
        ElementType[ElementType["resizer"] = 13] = "resizer";
        ElementType[ElementType["notAvailable"] = 14] = "notAvailable";
    })(beachParty.ElementType || (beachParty.ElementType = {}));
    var ElementType = beachParty.ElementType;
    (function (Action) {
        Action[Action["add"] = 0] = "add";
        Action[Action["adjust"] = 1] = "adjust";
        Action[Action["capture"] = 2] = "capture";
        Action[Action["clear"] = 3] = "clear";
        Action[Action["close"] = 4] = "close";
        Action[Action["create"] = 5] = "create";
        Action[Action["delete"] = 6] = "delete";
        Action[Action["edit"] = 7] = "edit";
        Action[Action["email"] = 8] = "email";
        Action[Action["export"] = 9] = "export";
        Action[Action["hide"] = 10] = "hide";
        Action[Action["import"] = 11] = "import";
        Action[Action["load"] = 12] = "load";
        Action[Action["open"] = 13] = "open";
        Action[Action["pause"] = 14] = "pause";
        Action[Action["play"] = 15] = "play";
        Action[Action["publish"] = 16] = "publish";
        Action[Action["remap"] = 17] = "remap";
        Action[Action["rename"] = 18] = "rename";
        Action[Action["report"] = 19] = "report";
        Action[Action["resume"] = 20] = "resume";
        Action[Action["select"] = 21] = "select";
        Action[Action["show"] = 22] = "show";
        Action[Action["start"] = 23] = "start";
        Action[Action["stop"] = 24] = "stop";
    })(beachParty.Action || (beachParty.Action = {}));
    var Action = beachParty.Action;
    (function (Target) {
        //---- panels ----
        Target[Target["aboutPanel"] = 0] = "aboutPanel";
        Target[Target["aggPanel"] = 1] = "aggPanel";
        Target[Target["appSettings"] = 2] = "appSettings";
        Target[Target["botPanel"] = 3] = "botPanel";
        Target[Target["browsePanel"] = 4] = "browsePanel";
        Target[Target["channelMapping"] = 5] = "channelMapping";
        Target[Target["chartOptions"] = 6] = "chartOptions";
        //chartOptionsPanel,
        Target[Target["chartTitle"] = 7] = "chartTitle";
        Target[Target["colorContinuous"] = 8] = "colorContinuous";
        Target[Target["colorCycling"] = 9] = "colorCycling";
        Target[Target["colorInvert"] = 10] = "colorInvert";
        Target[Target["colorPalette"] = 11] = "colorPalette";
        Target[Target["colorPanel"] = 12] = "colorPanel";
        Target[Target["colorReverse"] = 13] = "colorReverse";
        Target[Target["colorSpread"] = 14] = "colorSpread";
        Target[Target["clusterPanel"] = 15] = "clusterPanel";
        Target[Target["currentPanel"] = 16] = "currentPanel";
        Target[Target["datasetPanel"] = 17] = "datasetPanel";
        Target[Target["dataTip"] = 18] = "dataTip";
        Target[Target["detailsPanel"] = 19] = "detailsPanel";
        Target[Target["documentSize"] = 20] = "documentSize";
        Target[Target["facetPanel"] = 21] = "facetPanel";
        //feedback,
        //feedbackPanel,
        Target[Target["filterPanel"] = 22] = "filterPanel";
        Target[Target["frameStats"] = 23] = "frameStats";
        Target[Target["helpPanel"] = 24] = "helpPanel";
        Target[Target["imageMapping"] = 25] = "imageMapping";
        Target[Target["imagePanel"] = 26] = "imagePanel";
        Target[Target["insights"] = 27] = "insights";
        Target[Target["insightPanel"] = 28] = "insightPanel";
        Target[Target["itemsPanel"] = 29] = "itemsPanel";
        Target[Target["isLegendBottomUp"] = 30] = "isLegendBottomUp";
        Target[Target["layersPanel"] = 31] = "layersPanel";
        Target[Target["lineByPanel"] = 32] = "lineByPanel";
        Target[Target["navPanel"] = 33] = "navPanel";
        Target[Target["palettesPanel"] = 34] = "palettesPanel";
        Target[Target["paletteSetPickList"] = 35] = "paletteSetPickList";
        Target[Target["panelLocation"] = 36] = "panelLocation";
        Target[Target["panelSize"] = 37] = "panelSize";
        Target[Target["panelPin"] = 38] = "panelPin";
        Target[Target["panelTab"] = 39] = "panelTab";
        Target[Target["scriptsPanel"] = 40] = "scriptsPanel";
        Target[Target["searchPanel"] = 41] = "searchPanel";
        Target[Target["selectionPanel"] = 42] = "selectionPanel";
        Target[Target["settingsPanel"] = 43] = "settingsPanel";
        Target[Target["shapePanel"] = 44] = "shapePanel";
        Target[Target["sizePanel"] = 45] = "sizePanel";
        Target[Target["slicerPanel"] = 46] = "slicerPanel";
        Target[Target["snapshot"] = 47] = "snapshot";
        Target[Target["sortItemColumn"] = 48] = "sortItemColumn";
        Target[Target["sortParams"] = 49] = "sortParams";
        Target[Target["sortPanel"] = 50] = "sortPanel";
        Target[Target["sumPanel"] = 51] = "sumPanel";
        Target[Target["tasksPanel"] = 52] = "tasksPanel";
        Target[Target["textPanel"] = 53] = "textPanel";
        Target[Target["themesPanel"] = 54] = "themesPanel";
        Target[Target["timePanel"] = 55] = "timePanel";
        Target[Target["tipsPanel"] = 56] = "tipsPanel";
        Target[Target["tourLoaderPanel"] = 57] = "tourLoaderPanel";
        Target[Target["tourStep"] = 58] = "tourStep";
        Target[Target["unknownPanel"] = 59] = "unknownPanel";
        Target[Target["userResource"] = 60] = "userResource";
        Target[Target["xPanel"] = 61] = "xPanel";
        Target[Target["yPanel"] = 62] = "yPanel";
        Target[Target["zPanel"] = 63] = "zPanel";
        //---- menus ----
        Target[Target["insightMenu"] = 64] = "insightMenu";
        //---- dropdown picklists ----
        Target[Target["columnPicker"] = 65] = "columnPicker";
        Target[Target["chartPicker"] = 66] = "chartPicker";
        Target[Target["layoutPicker"] = 67] = "layoutPicker";
        //---- data ----
        Target[Target["data"] = 68] = "data";
        Target[Target["selection"] = 69] = "selection";
        Target[Target["filter"] = 70] = "filter";
        Target[Target["filterAndSelection"] = 71] = "filterAndSelection";
        //---- attributes ----
        Target[Target["xMapping"] = 72] = "xMapping";
        Target[Target["yMapping"] = 73] = "yMapping";
        Target[Target["zMapping"] = 74] = "zMapping";
        Target[Target["auxMapping"] = 75] = "auxMapping";
        Target[Target["colorMapping"] = 76] = "colorMapping";
        Target[Target["sizeMapping"] = 77] = "sizeMapping";
        Target[Target["shapeMapping"] = 78] = "shapeMapping";
        Target[Target["textMapping"] = 79] = "textMapping";
        Target[Target["lineMapping"] = 80] = "lineMapping";
        Target[Target["facetMapping"] = 81] = "facetMapping";
        Target[Target["sumByMapping"] = 82] = "sumByMapping";
        //---- properties ----
        Target[Target["chartType"] = 83] = "chartType";
        Target[Target["layout"] = 84] = "layout";
        Target[Target["shapeOpacity"] = 85] = "shapeOpacity";
        Target[Target["sizeFactor"] = 86] = "sizeFactor";
        Target[Target["separationFactor"] = 87] = "separationFactor";
        //---- other ----
        Target[Target["app"] = 88] = "app";
        Target[Target["newAppInstance"] = 89] = "newAppInstance";
        Target[Target["undoEntry"] = 90] = "undoEntry";
        Target[Target["redoEntry"] = 91] = "redoEntry";
        Target[Target["insight"] = 92] = "insight";
        Target[Target["searchCol"] = 93] = "searchCol";
        Target[Target["threeDimWheel"] = 94] = "threeDimWheel";
        Target[Target["dataZoom"] = 95] = "dataZoom";
    })(beachParty.Target || (beachParty.Target = {}));
    var Target = beachParty.Target;
    var SelectionDesc = (function () {
        function SelectionDesc() {
        }
        return SelectionDesc;
    }());
    beachParty.SelectionDesc = SelectionDesc;
    var ScriptCmd = (function () {
        //---- params ----
        function ScriptCmd(action, target) {
            this.action = Action[action];
            this.target = Target[target];
        }
        return ScriptCmd;
    }());
    beachParty.ScriptCmd = ScriptCmd;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    paletteHelper.ts - helps client apps build a color, size, and image palettes based on the associated MappingData.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var paletteHelper = (function () {
        function paletteHelper() {
        }
        paletteHelper.buildColorBreaks = function (cm, colInfo, useNiceNumbers) {
            if (cm) {
                var palette = cm.colorPalette;
                var breaks = null;
                var colName = cm.colName;
                if (colName) {
                    if (colInfo) {
                        //palette = colorPalettesClass.getPaletteFromSettings(cm.paletteName, cm.stepsRequested, cm.isReversed);
                        var isCategory = (cm.forceCategory || colInfo.colType == "string");
                        if (isCategory) {
                            var result = this.buildCategoryBreaks(colInfo, palette, cm.isCycling);
                            breaks = result.breaks;
                            palette = result.palette;
                        }
                        else {
                            //---- user-supplied palette overrides cm.binCount ----
                            //if (palette.length > cm.binCount)
                            //{
                            //    //---- shorten palette to # of color steps requested ----
                            //    palette = palette.slice(0, cm.binCount);
                            //}
                            cm.binCount = palette.length;
                            breaks = this.buildNumOrDateBreaks(cm, colInfo, palette, useNiceNumbers);
                        }
                    }
                }
                cm.colorPalette = palette;
                cm.breaks = breaks;
            }
        };
        paletteHelper.buildSizeBreaks = function (sm, colInfo, useNiceNumbers) {
            if (sm) {
                var palette = sm.sizePalette;
                var breaks = null;
                var colName = sm.colName;
                if (colName) {
                    if (colInfo) {
                        //---- the default size palette, for now ----
                        //palette = [.25, .5, .75, 1];
                        var isCategory = (sm.forceCategory || colInfo.colType == "string");
                        if (isCategory) {
                            var result = this.buildCategoryBreaks(colInfo, palette, false);
                            breaks = result.breaks;
                            palette = result.palette;
                        }
                        else {
                            breaks = this.buildNumOrDateBreaks(sm, colInfo, palette, useNiceNumbers);
                        }
                    }
                }
                sm.sizePalette = palette;
                sm.breaks = breaks;
            }
        };
        paletteHelper.buildShapeBreaks = function (im, colInfo, useNiceNumbers, useExperimental) {
            if (im) {
                var palette = im.getImagePalette(useExperimental);
                var breaks = null;
                var colName = im.colName;
                if (colName) {
                    if (colInfo) {
                        var isCategory = (im.forceCategory || colInfo.colType == "string");
                        if (isCategory) {
                            var result = this.buildCategoryBreaks(colInfo, palette, false);
                            breaks = result.breaks;
                            palette = result.palette;
                        }
                        else {
                            breaks = this.buildNumOrDateBreaks(im, colInfo, palette, useNiceNumbers);
                        }
                    }
                }
                im.imagePalette = palette;
                im.breaks = breaks;
            }
        };
        paletteHelper.buildCategoryBreaks = function (colInfo, palette, isCycling) {
            var keys = colInfo.stats.sortedKeys ? colInfo.stats.sortedKeys : colInfo.keys; // support older "keys" format in QuickTest insights
            var keyCount = keys.length;
            if (keyCount < palette.length) {
                palette = palette.slice(0, keyCount);
            }
            var breaks = [];
            if (isCycling) {
                //---- cap this at 250 until we add a virtual listbox to help perf ----
                var breakCount = Math.min(250, keyCount);
                for (var i = 0; i < breakCount; i++) {
                    breaks.push(keys[i]);
                }
            }
            else {
                for (var i = 0; i < palette.length; i++) {
                    if (i == palette.length - 1 && keyCount > palette.length) {
                        breaks.push("Other");
                    }
                    else {
                        breaks.push(keys[i]);
                    }
                }
            }
            return { breaks: breaks, palette: palette };
        };
        paletteHelper.buildNumOrDateBreaks = function (md, colInfo, palette, useNiceNumbers) {
            //var min = +colInfo.min;
            //var max = +colInfo.max;
            //var stepCount = (palette.length) ? palette.length : 1;
            //if (useNiceNumbers)
            //{
            //    var result = vp.scales.niceNumbersAlt.calculate(min, max, stepCount + 1);
            //    min = result.min;
            //    max = result.max;
            //}
            //var stepAmt = (max - min) / stepCount;
            //var breaks = vp.data.range(min, max, stepAmt);
            //return breaks;
            //---- call common code for consistent results ----
            if (colInfo.colType == "date") {
                var breaks = beachParty.binHelperDate.computeDateBreaks(md, colInfo);
            }
            else {
                var breaks = beachParty.binHelperNum.computeNumBreaks(md, colInfo, false);
            }
            return breaks;
        };
        return paletteHelper;
    }());
    beachParty.paletteHelper = paletteHelper;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    rotateRing.ts - displays a slowly pulsing ring in the 3D rotation area, in center of plot area. 
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var rotateRingClass = (function () {
        //_rcRotation = null;
        function rotateRingClass(chart) {
            this._fullOpacity = "1";
            //_radius = 0;               // size of 3D transform center
            this._pulseInterval = 5000;
            this._pulseTimer = null;
            this._pulseDuration = 0;
            this._chart = chart;
            var rootW = vp.select(document.body).append("div")
                .addClass("rotateRing")
                .css("position", "absolute")
                .css("opacity", "0");
            this._root = rootW[0];
        }
        //setRotationBounds(rc)
        //{
        //    this._rcRotation = rc;
        //}
        rotateRingClass.prototype.getRcPlot = function () {
            var rcPlot = this._chart.getBounds();
            return rcPlot;
        };
        rotateRingClass.prototype.getFinalRotationBounds = function () {
            var rcPlot = this.getRcPlot();
            var rcRot = this._chart.getRotateRingBounds();
            var rc = vp.geom.createRect(rcPlot.left + rcRot.left, rcPlot.top + rcRot.top, rcRot.width, rcRot.height);
            return rc;
        };
        rotateRingClass.prototype.enter = function () {
            var _this = this;
            var ring = this._root;
            var rcPlot = this.getRcPlot();
            var rcRing = this.getFinalRotationBounds();
            vp.utils.debug("ENTER");
            //---- FROM size ----
            vp.select(ring)
                .bounds(rcPlot.left, rcPlot.top, rcPlot.width, rcPlot.height)
                .css("border-radius", "0px")
                .css("opacity", "0");
            //---- ENDING bounds/radius ----
            setTimeout(function (e) {
                vp.select(ring)
                    .css("transition", "all .5s ease")
                    .bounds(rcRing.left, rcRing.top, rcRing.width, rcRing.height)
                    .css("border-radius", rcRing.width / 2 + "px")
                    .css("opacity", _this._fullOpacity);
            }, 250);
            //---- FADE OUT ----
            setTimeout(function (e) {
                vp.select(ring)
                    .css("transition", "all .5s ease")
                    .css("opacity", "0");
            }, 1500);
        };
        rotateRingClass.prototype.startPulsing = function () {
            var _this = this;
            this.stopPulsing();
            this._pulseTimer = setInterval(function (e) {
                _this.pulse();
            }, this._pulseInterval);
        };
        rotateRingClass.prototype.stopPulsing = function () {
            if (this._pulseTimer) {
                clearInterval(this._pulseTimer);
                this._pulseTimer = null;
            }
        };
        rotateRingClass.prototype.exit = function () {
            this.stopPulsing();
            var ring = this._root;
            var rcPlot = this.getRcPlot();
            var rcRing = this.getFinalRotationBounds();
            vp.utils.debug("EXIT");
            //---- STARTING bounds/radius ----
            vp.select(ring)
                .css("transition", "all .5 ease")
                .bounds(rcRing.left, rcRing.top, rcRing.width, rcRing.height)
                .css("border-radius", rcRing.width / 2 + "px")
                .css("opacity", this._fullOpacity);
            //---- TO size ----
            setTimeout(function (e) {
                vp.select(ring)
                    .css("transition", "all 3.5 ease")
                    .bounds(rcPlot.left, rcPlot.top, rcPlot.width, rcPlot.height)
                    .css("border-radius", "0px")
                    .css("opacity", "0");
            }, 500);
        };
        rotateRingClass.prototype.pulse = function () {
            //---- update its rcRing (plot may have moved since last enter/pulse) ----
            var ring = this._root;
            var rcRing = this.getFinalRotationBounds();
            vp.utils.debug("PULSE");
            //---- FADE IN ----
            vp.select(ring)
                .bounds(rcRing.left, rcRing.top, rcRing.width, rcRing.height)
                .css("border-radius", rcRing.width / 2 + "px")
                .css("transition", "all .5s ease")
                .css("opacity", this._fullOpacity);
            //---- FADE OUT ----
            setTimeout(function (e) {
                vp.select(ring)
                    .css("opacity", "0");
            }, 500 + this._pulseDuration);
        };
        return rotateRingClass;
    }());
    beachParty.rotateRingClass = rotateRingClass;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// rubberBandSelector.ts.  Copyright (c) 2016 Microsoft Corporation.
/// Part of the beachParty library
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var nextSelectorId = 1;
    var maxHoldDist = 5;
    var holdTime = 2000;
    /** Note: this class hooks mouseDOWN using the chart canvas, and mouseUP using "window",
    so that we can drag outside the chart.  We treat a mouseDOWN with isEnabled=false as a
    notification back to the client (so they can enable an inactive chart).
    
    Also, this control implements its own context menu (when the mouse is not moved for a certain time).  The goal
    is to eventually use the standard browser context menu event in its place. */
    var rubberBandSelectorClass = (function (_super) {
        __extends(rubberBandSelectorClass, _super);
        function rubberBandSelectorClass(dragSelectCanvas, isEnabled) {
            var _this = this;
            _super.call(this);
            //---- state ----
            this._id = nextSelectorId++;
            this._isEnabled = true;
            this._isBanding = false;
            this._ptMouseDown = null;
            this._ptMouseHold = null; // location where user is "holding" (not moving for holdTime ms)
            this._holdTimer = null;
            this._selectCallback = null;
            this._holdCallback = null;
            this._dragSelectCanvas = null;
            this._canvasChanged = false;
            this._mouseDownOrigin = "outsideChart"; // insideActiveChart, insideInactiveChart, outsideChart
            this._isLeftButtonDown = false;
            this._isRightButtonDown = false;
            this._pendingUpEvent = false;
            this._forceToggle = false;
            this._onMouseMoveFunc = null;
            this._onMouseUpFunc = null;
            this._isSetCaptureActive = false;
            //---- turn this off until we change this to look like a context menu on touch screen, with normal menu items ----
            this._isHoldEnabled = false;
            this._isEnabled = isEnabled;
            this._onMouseMoveFunc = function (e) { return _this.onRubberMove(e); };
            this._onMouseUpFunc = function (e) { return _this.onRubberUp(e); };
            this._dragSelectCanvas = dragSelectCanvas;
            var rubberBand = vp.select(document.createElement("span")) //   createTextBlock()
                .id("rubberBandSelector")
                .addClass("rubberBand")
                .css("z-index", "9999")
                .css("display", "none");
            this._rubberBand = rubberBand;
            /// try to prevent rubberBand from taking mouse events from the dragSelectCanvas
            /// but none of these really does the trick.
            rubberBand.css("pointer-events", "none");
            rubberBand[0].disabled = true;
            if (isEnabled) {
                this.hookEvents(false);
            }
        }
        rubberBandSelectorClass.prototype.forceToggle = function (value) {
            if (arguments.length == 0) {
                return this._forceToggle;
            }
            this._forceToggle = value;
            this.onDataChanged("forceToggle");
        };
        rubberBandSelectorClass.prototype.isDragging = function () {
            return this._isBanding;
        };
        rubberBandSelectorClass.prototype.isDraggingRect = function () {
            return (this._isBanding && this._isEnabled);
        };
        rubberBandSelectorClass.prototype.hookEvents = function (canvasChanged) {
            var _this = this;
            //---- always process mouse up, so we can track right mouse button up/down state ----
            vp.select(window).attach("mouseup", function (e) { return _this.onMouseUp(e); });
            this._canvasChanged = canvasChanged;
            var canvas = this._dragSelectCanvas;
            if (canvas) {
                //---- hook MOUSE DOWN ----
                canvas.onmousedown = function (e) { return _this.onRubberDown(e); };
                vp.select(canvas).attach("touchstart", function (e) { return _this.onRubberDown(e); });
                vp.select(canvas).attach("keydown", function (e) {
                    if (e.keyCode == vp.events.keyCodes.escape) {
                        _this.cancelBanding(true, e);
                    }
                });
                //canvas.appendChild(this._rubberBand.getNative());
                document.body.appendChild(this._rubberBand[0]);
            }
        };
        rubberBandSelectorClass.prototype.attachOnSelect = function (callback) {
            this._selectCallback = callback;
        };
        rubberBandSelectorClass.prototype.attachOnHold = function (callback) {
            this._holdCallback = callback;
        };
        rubberBandSelectorClass.prototype.setRubberBand = function (rc) {
            var left = rc.left;
            var top = rc.top;
            //vp.utils.debug("rubberBandSelector.setRubberBand: left=" + rc.left + ", top=" + rc.top + ", width=" + rc.width +
            //    ", height=" + rc.height);
            this._rubberBand
                .css("position", "absolute")
                .css("left", left + "px")
                .css("top", top + "px")
                .width(rc.width + "px")
                .height(rc.height + "px")
                .css("display", "block");
        };
        rubberBandSelectorClass.prototype.showRubberBand = function (value) {
            if (this._rubberBand) {
                this._rubberBand.css("display", (value) ? "block" : "none");
            }
        };
        rubberBandSelectorClass.prototype.cancelBanding = function (clearBanding, evt) {
            this.showRubberBand(false);
            this.clearCapture();
            //---- re-enable text selection by browser (for Chrome, FireFox) ----
            //hostControls.enableElementSelection(document.body, true);
            if (clearBanding) {
                this.clearBanding();
            }
            this.clearHoldTimer();
        };
        rubberBandSelectorClass.prototype.clearCapture = function () {
            if (this._isSetCaptureActive) {
                vp.events.releaseCaptureWindow();
                //vp.utils.debug("rubberBandSelection: RELEASE CAPTURE");
                this._isSetCaptureActive = false;
            }
        };
        rubberBandSelectorClass.prototype.clearBanding = function () {
            //vp.utils.debug("cancelBanding: id=" + this._id);
            this._isBanding = false;
        };
        rubberBandSelectorClass.prototype.isToggleKey = function (evt) {
            return (evt.shiftKey); // (evt.ctrlKey);
        };
        /// debug support: distingish between mouse and touch UP events.
        rubberBandSelectorClass.prototype.onTouchUp = function (evt) {
            //---- click on inactive window? ----
            if (!this._isEnabled) {
                if (this._mouseDownOrigin != "outsideChart") {
                    this.handleClickOnInactiveView(evt);
                }
            }
            else {
                this.onRubberUp(evt);
            }
        };
        rubberBandSelectorClass.prototype.handleClickOnInactiveView = function (evt) {
            var pt = vp.events.mousePosition(evt);
            var rc = this._dragSelectCanvas.getBoundingClientRect();
            if ((rc.width > 0) && (rc.height > 0)) {
                if (vp.geom.rectContainsPoint(rc, pt)) {
                    if (this._selectCallback) {
                        this._selectCallback(evt, null, false, "insideInactiveChart");
                    }
                }
            }
        };
        //---- touchMgr calls this ----
        rubberBandSelectorClass.prototype.setMouseDown = function (pt) {
            this._ptMouseDown = pt;
            this.cancelBanding(true);
        };
        //---- touchMgr calls this ----
        rubberBandSelectorClass.prototype.drawBand = function (evt) {
            var ptCurrent = vp.events.mousePosition(evt);
            var rc = vp.geom.rectFromPoints(ptCurrent, this._ptMouseDown);
            this.setRubberBand(rc);
        };
        //---- touchMgr calls this ----
        rubberBandSelectorClass.prototype.processExternalUp = function (evt) {
            var ptCurrent = vp.events.mousePosition(evt);
            this._mouseDownOrigin = "insideActiveChart";
            var rcBand = vp.geom.rectFromPoints(ptCurrent, this._ptMouseDown);
            var toggle = (this._forceToggle || evt.which == 3 || this.isToggleKey(evt));
            this.cancelBanding(true, evt);
            if (this._selectCallback) {
                //---- pass callback the window-relative rectangle coordinates ----
                this._selectCallback(evt, rcBand, toggle, this._mouseDownOrigin);
            }
        };
        /// debug support: distingish between mouse and touch UP events.
        rubberBandSelectorClass.prototype.onMouseUp = function (evt) {
            //vp.utils.debug("rubberBandSelector: onMouseUp");
            //---- in case things get out of sync, always treat UP event as clearing isRightButtonDown ----
            if (true) {
                this._isRightButtonDown = false;
            }
            //---- including this 2nd UP call on IE causes 2 "clear selection" cmds to be recorded, so we don't include it. ----
            //---- the TOUCH up seem to now be required by rubberBand code for proper operation (vs. MOUSE UP). ----
            //---- BUT, Chrome requires this call. ----
            if ((!vp.utils.isIE) || (window.external && window.external.isHostedInExcel)) {
                //---- click on inactive window? ----
                if (!this._isEnabled) {
                    this.handleClickOnInactiveView(evt);
                }
                else {
                    this.onRubberUp(evt);
                }
            }
        };
        rubberBandSelectorClass.prototype.cancelPendingUpEvent = function () {
            if (this._pendingUpEvent) {
                //vp.utils.debug("rubberbandSelection: cancelling pending UP event");
                this._pendingUpEvent = false;
                this.cancelBanding(true);
            }
        };
        rubberBandSelectorClass.prototype.onRubberUp = function (evt) {
            var _this = this;
            //---- to enable a TOUCH context menu to cancel this potential select event, we give it a chance to fire before we process the UP ----
            this._pendingUpEvent = true;
            setTimeout(function (e) {
                if (_this._pendingUpEvent) {
                    _this._pendingUpEvent = false;
                    _this.onRubberUpCore(evt);
                }
            }, 1);
        };
        rubberBandSelectorClass.prototype.onRubberUpCore = function (evt) {
            //vp.utils.debug("rubberBandSelector.onRubberUpCore: id=" + this._id + ", isBanding=" + this._isBanding);
            this.clearCapture();
            if (this._isEnabled) {
                if (evt.which == 1) {
                    this._isLeftButtonDown = false;
                }
                /// this is triggered for all window mouse move events, so its important to only look at them
                /// when we have started a banding operation.
                if (this._isBanding) {
                    //vp.utils.debug("rubberBandSelector.onUp: id=" + this._id + ", isEnabled=" + this._isEnabled);
                    var cancelEvent = false;
                    this.clearHoldTimer();
                    //try
                    {
                        //this.cancelBanding(false, evt);
                        this.showRubberBand(false);
                        var toggle = (this._forceToggle || evt.which == 3 || this.isToggleKey(evt));
                        if (evt.type == "touchend") {
                            var ptCurrent = this.changedTouchPosition(evt, null);
                        }
                        else {
                            var ptCurrent = vp.events.mousePosition(evt);
                        }
                        var rcBand = vp.geom.rectFromPoints(ptCurrent, this._ptMouseDown);
                        //---- adjust rcBand so it matches actual location ----
                        //var rect = this._dragSelectCanvas.getBoundingClientRect();
                        //vp.utils.debug("rcBand: left=" + rcBand.left + ", top=" + rcBand.top +
                        //    ", width=" + rcBand.width + ", height = " + rcBand.height + ", toggle = " + toggle);
                        //---- allow for a direct click (no movement) ----
                        if (true) {
                            //vp.utils.debug("calling selectCallback from RUBBER BAND...");
                            if (this._selectCallback) {
                                //---- pass callback the window-relative rectangle coordinates ----
                                this._selectCallback(evt, rcBand, toggle, this._mouseDownOrigin);
                            }
                            cancelEvent = true;
                            this.onDataChanged("mouseUp");
                        }
                        //---- if we re banding, do not pass event along ----
                        vp.events.cancelEventDefault(evt);
                        vp.events.cancelEventBubble(evt);
                    }
                    //catch (ex)
                    //{
                    //    vp.utils.debug("Exception in rubber banding: " + ex);
                    //    throw ex;
                    //}
                    //finally
                    //{
                    //    this.cancelBanding(true, evt);
                    //}
                    this.cancelBanding(true, evt);
                }
                else {
                }
            }
            else {
            }
            //---- reset for next mouse down/up ----
            this._mouseDownOrigin = "outsideChart";
        };
        rubberBandSelectorClass.prototype.changedTouchPosition = function (e, elem) {
            var x = e.changedTouches[0].pageX;
            var y = e.changedTouches[0].pageY;
            if (elem) {
                x -= elem.offsetLeft;
                y -= elem.offsetTop;
            }
            return { x: x, y: y };
        };
        rubberBandSelectorClass.prototype.touchPosition = function (e, elem) {
            var x = e.touches[0].pageX;
            var y = e.touches[0].pageY;
            if (elem) {
                x -= elem.offsetLeft;
                y -= elem.offsetTop;
            }
            return { x: x, y: y };
        };
        rubberBandSelectorClass.prototype.onRubberMove = function (evt) {
            //vp.utils.debug("raw rubberband mouseMove");
            try {
                /// this is triggered for all window mouse move events, so its important to only look at them
                /// when we have started a banding operation.
                if (this._isBanding && this._isEnabled) {
                    //vp.utils.debug("rubberBandSelector.onMove: id=" + this._id);
                    if ((this._isLeftButtonDown) && (this._isRightButtonDown)) {
                        //---- user started a 2-button drag (3D panning) - abandon this operation ----
                        this.cancelBanding(true, evt);
                    }
                    else {
                        if (evt.type == "touchmove") {
                            var ptCurrent = this.touchPosition(evt, null);
                        }
                        else {
                            var ptCurrent = vp.events.mousePosition(evt);
                        }
                        var rc = vp.geom.rectFromPoints(ptCurrent, this._ptMouseDown);
                        //vp.utils.debug("rubberBandSelector: onMove: pt="+  ptCurrent + ", rc=" + rc); 
                        this.setRubberBand(rc);
                        //---- if we're banding, do not pass event along ----
                        vp.events.cancelEventDefault(evt);
                        vp.events.cancelEventBubble(evt);
                        //---- HOLD detection ----
                        if (this._isHoldEnabled) {
                            var deltaX = Math.abs(ptCurrent.x - this._ptMouseHold.x);
                            var deltaY = Math.abs(ptCurrent.y - this._ptMouseHold.y);
                            if ((this._ptMouseHold == null) || (Math.max(deltaX, deltaY) > maxHoldDist)) {
                                //---- start a new hold location/time ----
                                this._ptMouseHold = ptCurrent;
                                this.restartHoldTimer();
                            }
                        }
                    }
                }
            }
            catch (ex) {
                vp.utils.debug("MouseMove Exception: " + ex);
            }
        };
        rubberBandSelectorClass.prototype.triggerHoldEvent = function () {
            var ptCurrent = this._ptMouseHold;
            this._ptMouseHold = null;
            this.clearHoldTimer();
            var rcBand = vp.geom.rectFromPoints(ptCurrent, this._ptMouseDown);
            ////---- adjust rcBand so it matches actual location ----
            //var rect = this._dragSelectCanvas.getBoundingClientRect();
            //var toggle = this.isToggleKey(evt);
            //vp.utils.debug("HOLD rcBand: width=" + rcBand.width + ", height=" + rcBand.height);
            if (this._holdCallback) {
                this.clearBanding();
                this._holdCallback(rcBand, this._mouseDownOrigin, ptCurrent);
            }
        };
        rubberBandSelectorClass.prototype.triggerOnDown = function (e) {
            if (this._isEnabled) {
                this.onRubberDown(e);
            }
        };
        rubberBandSelectorClass.prototype.onRubberDown = function (evt) {
            //vp.utils.debug("--> rubberBandSelector.onDown: id=" + this._id + ",isEnabled=" + this._isEnabled);
            if ((evt.which == 1) || (evt.type == "touchstart")) {
                if (!evt.ctrlKey) {
                    this._isLeftButtonDown = true;
                }
            }
            if (evt.which == 3) {
                this._isRightButtonDown = true;
            }
            //---- only process if LEFT DOWN and RIGHT UP (don't response to multi-button drags ----
            if (true) {
                if (this._isBanding) {
                    this.cancelBanding(true, evt);
                }
                else if (this._isEnabled) {
                    // var toggle = this.isToggleKey(evt);
                    //---- prevent text selection by browser during our drag operation (for Chrome, FireFox) ----
                    //enableElementSelection(document.body, false);
                    //---- use chart-relative point & then add chart-relative offset of each series ----
                    if (evt.type == "touchstart") {
                        this._ptMouseDown = this.touchPosition(evt, null);
                    }
                    else {
                        this._ptMouseDown = vp.events.mousePosition(evt);
                    }
                    if (this._isHoldEnabled) {
                        this._ptMouseHold = this._ptMouseDown;
                        this.restartHoldTimer();
                    }
                    this._isBanding = true;
                    //vp.utils.debug("rubberBandSelector: onDown");
                    //vp.utils.debug("rubberBandSelector.onDown: id=" + this._id + ", isBanding=" + this._isBanding);
                    /// when "vp.events.setCapture" tried by rfernand on Feb-27-2015, no mouse events were being sent to element 
                    /// betweeen call and next mouse click.  When "element.setCapture()" called directly, it returned "undefined"
                    /// and seemed to have no effect.  So, it was then turned off.  Normal mouse events work OK for rubberband
                    /// dragging, but behavior is awkward when mouse leaves document boundaries.
                    /// update:  as of Aug-27-2015, found that we were hooking mousedown twice (pointerdown and mousedown events).  As
                    /// a result, we would end up calling "cancelBanding()" on the 2nd time thru this function which would turn off
                    /// the CAPTURE of mouseMove/mouseUP events.  Fixed that, and now setCaptureWindow() is working correctly... almost - 
                    /// new problem: we are not getting events OUTSIDE of our window.
                    vp.events.setCaptureWindow(this._onMouseMoveFunc, this._onMouseUpFunc);
                    vp.utils.debug("rubberbandSelector: SET CAPTURE");
                    this._isSetCaptureActive = true;
                    //vp.select("#consoleDiv").text("rubberbandSelector: SET CAPTURE");
                    this._mouseDownOrigin = "insideActiveChart";
                }
                else {
                    this._mouseDownOrigin = "insideInactiveChart";
                }
            }
            else {
            }
            this.onDataChanged("mouseDown");
            //---- set line style according to which button is pressed ----
            var toggle = (this._forceToggle || evt.which == 3);
            var rbW = vp.select("#rubberBandSelector");
            if (toggle) {
                rbW.addClass("zoomRubberBand");
            }
            else {
                rbW.removeClass("zoomRubberBand");
            }
            //vp.select("#rubberBandSelector").css("border", (toggle) ? "3px double white" : "2px dashed yellow");
        };
        rubberBandSelectorClass.prototype.clearHoldTimer = function () {
            if (this._holdTimer) {
                clearInterval(this._holdTimer);
                this._holdTimer = null;
            }
        };
        /** we cannot just check the time in mousemove because the mouse might not be moving after reaching its destination. */
        rubberBandSelectorClass.prototype.restartHoldTimer = function () {
            var _this = this;
            this.clearHoldTimer();
            if (this._isEnabled) {
                this._holdTimer = setInterval(function () {
                    _this.triggerHoldEvent();
                }, holdTime);
            }
        };
        rubberBandSelectorClass.prototype.isEnabled = function (value) {
            var _this = this;
            if (arguments.length == 0) {
                return this._isEnabled;
            }
            //vp.utils.debug("rubberBandSelector: id=" + this._id + ", setting isEnabled=" + value + ", isBanding=" + this._isBanding);
            this._isEnabled = value;
            var canvas = this._dragSelectCanvas;
            if (!value) {
                this.cancelBanding(true);
                vp.select(canvas).detach("touchstart", function (e) { return _this.onRubberDown(e); });
                canvas.onmousedown = null;
            }
            else {
                vp.select(canvas).attach("touchstart", function (e) { return _this.onRubberDown(e); });
                canvas.onmousedown = function (e) { return _this.onRubberDown(e); };
            }
            vp.events.releaseCaptureWindow(); // a good time to ensure this is off
            return this;
        };
        rubberBandSelectorClass.prototype.dragSelectElement = function (value) {
            if (arguments.length == 0) {
                return this._dragSelectCanvas;
            }
            this._dragSelectCanvas = value;
            this.hookEvents(true);
        };
        return rubberBandSelectorClass;
    }(beachParty.dataChangerClass));
    beachParty.rubberBandSelectorClass = rubberBandSelectorClass;
    function createRubberBandSelector(canvas) {
        return new rubberBandSelectorClass(canvas, false);
    }
    beachParty.createRubberBandSelector = createRubberBandSelector;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    shapeAttr.ts - manages the SHAPE attribute for a chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var shapeAttrClass = (function (_super) {
        __extends(shapeAttrClass, _super);
        function shapeAttrClass(chart, md, target) {
            var _this = this;
            _super.call(this, chart, md, target);
            this._useExperimentalImages = false;
            chart.registerForChange("chart", function (e) {
                _this.onChartTypeChanged();
            });
            //this.registerForChange("binCount", (e) => this.onMappingChanged(true, false, true));
        }
        shapeAttrClass.prototype.onChartTypeChanged = function () {
        };
        shapeAttrClass.prototype.useExperimentalImages = function (value) {
            if (arguments.length == 0) {
                return this._useExperimentalImages;
            }
            this._useExperimentalImages = value;
            this.onDataChanged("useExperimentalImages");
            this.onMappingChanged(true, false, true);
        };
        shapeAttrClass.prototype.onMappingChanged = function (binCountChanged, omitDataChangedCall, rebindColInfo) {
            _super.prototype.onMappingChanged.call(this, binCountChanged, omitDataChangedCall);
            var md = this._md;
            if (md.colName) {
                var colInfo = md.boundColInfo;
                if (rebindColInfo || !colInfo || colInfo.name != md.colName) {
                    //---- REBIND colInfo to current filter setting ----
                    colInfo = this.getDataFrame().getColInfo(md.colName);
                    md.boundColInfo = colInfo;
                }
                if (colInfo && !md.breaks) {
                    beachParty.paletteHelper.buildShapeBreaks(md, colInfo, this._chart.useNiceNumbers(), this._useExperimentalImages);
                }
            }
        };
        return shapeAttrClass;
    }(beachParty.attrClass));
    beachParty.shapeAttrClass = shapeAttrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    sizeAttr.ts - manages the SIZE attribute for a chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var sizeAttrClass = (function (_super) {
        __extends(sizeAttrClass, _super);
        function sizeAttrClass(chart, md, target) {
            var _this = this;
            _super.call(this, chart, md, target);
            chart.registerForChange("chart", function (e) {
                _this.onChartTypeChanged();
            });
        }
        sizeAttrClass.prototype.onChartTypeChanged = function () {
        };
        sizeAttrClass.prototype.onMappingChanged = function (binCountChanged, omitDataChangedCall) {
            _super.prototype.onMappingChanged.call(this, binCountChanged, omitDataChangedCall);
            var md = this._md;
            var rebindColInfo = false;
            if (md.colName) {
                var colInfo = md.boundColInfo;
                if (rebindColInfo || !colInfo || colInfo.name != md.colName) {
                    //---- REBIND colInfo to current filter setting ----
                    colInfo = this.getDataFrame().getColInfo(md.colName);
                    md.boundColInfo = colInfo;
                }
                if (!md.breaks) {
                    beachParty.paletteHelper.buildSizeBreaks(md, colInfo, this._chart.useNiceNumbers());
                }
            }
        };
        return sizeAttrClass;
    }(beachParty.attrClass));
    beachParty.sizeAttrClass = sizeAttrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    textAttr.ts - manages the TEXT attribute for a chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var textAttrClass = (function (_super) {
        __extends(textAttrClass, _super);
        function textAttrClass(chart, md, target) {
            _super.call(this, chart, md, target);
        }
        textAttrClass.prototype.maxTextShapes = function (value, omitLogging) {
            var lm = this._md;
            if (arguments.length == 0) {
                return lm.maxShapes;
            }
            lm.maxShapes = value;
            this.onMappingChanged();
            if (!omitLogging) {
                this._app.logAction(beachParty.Gesture.drag, null, beachParty.ElementType.slider, beachParty.Action.adjust, beachParty.Target.textMapping, true, { maxShapes: value });
            }
            this.onDataChanged("maxTextShapes");
        };
        textAttrClass.prototype.textColor = function (value, omitLogging) {
            var lm = this._md;
            if (arguments.length == 0) {
                return lm.color;
            }
            lm.color = value;
            this.onMappingChanged();
            if (!omitLogging) {
                this._app.logAction(beachParty.Gesture.select, null, beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.textMapping, true, { textColor: value });
            }
            this.onDataChanged("textColor");
        };
        return textAttrClass;
    }(beachParty.attrClass));
    beachParty.textAttrClass = textAttrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    toolTipMgr.ts - manages the (custom drawn) tooltip for the shapes (on the client).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var toolTipMgrClass = (function (_super) {
        __extends(toolTipMgrClass, _super);
        function toolTipMgrClass(app, dataMgr, chart, maxToolTipColumns) {
            _super.call(this);
            this._areToolTipsEnabled = true;
            this._showDelay = 500;
            this._showTimeout = 30 * 1000; // 30 secs
            this._timer = null;
            this._app = app;
            this._dataMgr = dataMgr;
            this._chart = chart;
            this._maxToolTipColumns = maxToolTipColumns;
        }
        toolTipMgrClass.prototype.showToolTipForShape = function (e, primaryKey, record, colNames) {
            var html = "<table class='toolTipTable'>";
            //var keys = vp.utils.keys(record);
            //var includeSysCols = true;
            var colCount = colNames.length;
            if (colCount > 0) {
                var firstSystemName = true;
                var dataFrame = this._dataMgr.getDataFrame();
                for (var i = 0; i < colCount; i++) {
                    var colName = colNames[i];
                    //if (colName.startsWith("_") && !includeSysCols)
                    //{
                    //    continue;
                    //}
                    var colType = dataFrame.getColType(colName);
                    var value = record[colName];
                    var strValue = vp.formatters.formatByType(value, colType);
                    if (i > 0) {
                        if (colName.startsWith("_") && firstSystemName) {
                            //---- skip a row ----
                            firstSystemName = false;
                            html += "<tr><td>&nbsp;</td></tr>";
                        }
                    }
                    //html += "<tr style='white-space: nowrap'>";
                    html += "<tr >";
                    if (this._chart.includeNamesInTooltip()) {
                        html += "<td class='toolTipName'>" + colName + ":</td>";
                    }
                    html += "<td class='toolTipValue'>" + value + "</td></tr>";
                }
                html += "</table>";
            }
            //---- set text / HTML ----
            vp.select(this.getToolTipElem())
                .html(html);
            var pt = vp.events.mousePosition(e);
            this.positionToolTip(pt);
        };
        toolTipMgrClass.prototype.positionToolTip = function (pt) {
            //---- position tooltip so that its bottom is 20 pixels above the pt screen location ----
            //---- show with opacity=0 so we can measure it ----
            var toolTipW = vp.select(this.getToolTipElem());
            if (toolTipW.length) {
                toolTipW
                    .css("opacity", "0")
                    .css("display", "");
                var rc = toolTipW.getBounds(false);
                //---- hide it until timer fires ----
                toolTipW
                    .css("display", "none")
                    .css("opacity", "1");
                //---- move it ----
                var x = pt.x - (rc.width / 2);
                var y = pt.y - (rc.height + 20);
                if (y < 0) {
                    y = pt.y + 40;
                }
                toolTipW
                    .css("left", x + "px")
                    .css("top", y + "px");
                this.startShowTimer();
            }
        };
        toolTipMgrClass.prototype.startShowTimer = function () {
            var _this = this;
            this.clearTimer();
            //vp.utils.debug("startShowTimer");
            this._timer = setTimeout(function (e) { return _this.showToolTip(); }, this._showDelay);
        };
        toolTipMgrClass.prototype.startHideTimer = function () {
            var _this = this;
            this.clearTimer();
            this._timer = setTimeout(function (e) { return _this.hideToolTip(); }, this._showTimeout);
        };
        toolTipMgrClass.prototype.clearTimer = function () {
            if (this._timer) {
                //vp.utils.debug("clearTimer");
                clearTimeout(this._timer);
                this._timer = null;
            }
        };
        toolTipMgrClass.prototype.showToolTip = function () {
            //vp.utils.debug("showToolTip");
            this.clearTimer();
            vp.select(this.getToolTipElem())
                .css("display", "");
            this.startHideTimer();
        };
        toolTipMgrClass.prototype.areToolTipsEnabled = function (value) {
            if (value === undefined) {
                return this._areToolTipsEnabled;
            }
            this._areToolTipsEnabled = value;
            this.onDataChanged("areToolTipsEnabled");
        };
        toolTipMgrClass.prototype.getToolTipElem = function () {
            return this._chart.toolTipElem();
        };
        toolTipMgrClass.prototype.hideToolTip = function () {
            //vp.utils.debug("hideToolTip called");
            this.clearTimer();
            vp.select(this.getToolTipElem())
                .css("display", "none");
        };
        return toolTipMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.toolTipMgrClass = toolTipMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chartFrameHelper.ts - helps a chart to draw the (somewhat complex) chart frame.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var chartFrameHelperClass = (function (_super) {
        __extends(chartFrameHelperClass, _super);
        function chartFrameHelperClass(parent, chartBuilder, dataMgr, transformer, blankStrValue) {
            _super.call(this);
            this._tickLength = 12;
            this._clickTickLength = 12; // preserve space in facets
            this._isYAxisClickable = true;
            this._isXAxisClickable = true;
            this._leftWidth = 0;
            this._bottomHeight = 0;
            this._blankStrValue = "";
            //---- events ----
            this.onTickBoxClick = new beachParty.bpEvent();
            this._chartBuilder = chartBuilder;
            var rootW = vp.select(parent).append("g");
            this._root = rootW[0];
            this._blankStrValue = blankStrValue;
            this._dataMgr = dataMgr;
            this._transformer = transformer;
        }
        chartFrameHelperClass.prototype.getRoot = function () {
            return this._root;
        };
        chartFrameHelperClass.prototype.selectXBoxByIndex = function (index) {
            var xElems = this._xTickBoxElements;
            if (index < 0) {
                index += xElems.length;
            }
            else {
                //---- true elements start at index=1 ----
                index++;
            }
            var elem = xElems[index];
            var e = { target: elem };
            this.doNewSearch(e, "X", elem.innerText);
        };
        chartFrameHelperClass.prototype.selectYBoxByIndex = function (index) {
            var yElems = this._yTickBoxElements;
            if (index < 0) {
                index += yElems.length;
            }
            else {
                //---- true elements start at index=1 ----
                index++;
            }
            var elem = yElems[index];
            var e = { target: elem };
            this.doNewSearch(e, "Y", elem.innerText);
        };
        chartFrameHelperClass.prototype.chartFrameRoot = function () {
            return this._root;
        };
        /**
         * Create a single chartFrame - called multiple times for Facet views.
         */
        chartFrameHelperClass.prototype.createChartFrame = function () {
            var svgParent = this._root;
            //---- create placeholder scales to initialize with ----
            var xData = vp.chartFrame.createAxisData(vp.scales.createLinear());
            var yData = vp.chartFrame.createAxisData(vp.scales.createLinear());
            //var daFrame = plotServices.currentTheme().getDrawingAttributes("chartFrame");
            var daFrame = null;
            //---- create CHART FRAME control ----
            var chartFrame = vp.chartFrame.createChartFrameEx(svgParent, xData, yData)
                .translate(0, 0, true);
            var dp = chartFrame.leftAxis().drawingParams();
            dp.tickLength = (this._isYAxisClickable) ? this._clickTickLength : this._tickLength;
            var dp = chartFrame.bottomAxis().drawingParams();
            dp.tickLength = (this._isXAxisClickable) ? this._clickTickLength : this._tickLength;
            chartFrame.leftAxis().maxPerpendicularSize(this._leftWidth);
            chartFrame.bottomAxis().maxPerpendicularSize(this._bottomHeight);
            return chartFrame;
        };
        chartFrameHelperClass.prototype.getYAxisWidth = function () {
            var width = (this._isYAxisClickable) ? this._clickTickLength : this._tickLength;
            width += this._leftWidth;
            return width;
        };
        chartFrameHelperClass.prototype.getXAxisHeight = function () {
            var height = (this._isXAxisClickable) ? this._clickTickLength : this._tickLength;
            height += this._bottomHeight;
            return height;
        };
        chartFrameHelperClass.prototype.buildFacetFrames = function (width, height, cfd, dc, hideLabels, facetLayoutInPixels, isXAxisClickable, isYAxisClickable) {
            this._isXAxisClickable = isXAxisClickable;
            this._isYAxisClickable = isYAxisClickable;
            var rootW = vp.select(this._root)
                .clear();
            var scales = dc.scales;
            this._facetChartFrames = [];
            var xAttr = null; // attributes.x;
            var yAttr = null; // attributes.y;
            //---- use width/height of first facet (all facets are the same size) ----
            var bounds = facetLayoutInPixels[0].plotBounds;
            //var xAxisData = this.createAxisData(scales.x, xAttr, 0, bounds.width, "x");
            //var yAxisData = this.createAxisData(scales.y, yAttr, bounds.height, 0, "y");
            var xAxisData = this._bigChartFrame.bottomAxis().axisData();
            var yAxisData = this._bigChartFrame.leftAxis().axisData();
            //---- layout facets with latest WIDTH and HEIGHT ----
            //this.updateFacetLayout();
            //---- get THEME drawing attributes for facet labels ----
            //---- clear cached label measurements ----
            //this._xLabelMeasurements = null;
            //this._yLabelMeasurements = null;
            var xBinResults = (scales.x) ? scales.x._binResults : null;
            var yBinResults = (scales.y) ? scales.y._binResults : null;
            for (var i = 0; i < facetLayoutInPixels.length; i++) {
                var bounds = facetLayoutInPixels[i].plotBounds;
                //---- draw debug guidelines: GREEN BOX around INSIDE of facet cell drawing area ----
                //groupWrap.append("rect")
                //    .attr("stroke", "green")
                //    .attr("stroke-width", "1")
                //    .attr("fill", "none")
                //    .bounds(bounds.left, bounds.top, bounds.width, bounds.height, true)
                //    .id("facetGuideLines")
                //var areTitlesClickable = true;  
                var areLeftLabelsClickable = this._isYAxisClickable;
                var areBottomLabelsClickable = this._isXAxisClickable;
                var facetInfo = dc.facetHelper._layout;
                this.createFacetChartFrame(width, height, dc, xBinResults, yBinResults, cfd, xAxisData, yAxisData, i, facetInfo, rootW[0], bounds, areLeftLabelsClickable, areBottomLabelsClickable, hideLabels, scales);
            }
        };
        /**
         * Creates a facet chart frame for "facetIndex" and lays it out according to "bounds".  This is called
         for all facets, not just the left/bottom ones.  For inner facets, just a rectangle border is created.  For all
         facets, a facet label is also created (on top of the frame).
         * @param cfd
         * @param xAxisData
         * @param yAxisData
         * @param facetIndex
         * @param facetInfo
         * @param groupElem
         * @param bounds
         * @param areLeftLabelsClickable
         * @param areBottomLabelsClickable
         * @param hideAxes
         */
        chartFrameHelperClass.prototype.createFacetChartFrame = function (width, height, dc, xBinResults, yBinResults, cfd, xAxisData, yAxisData, facetIndex, facetInfo, groupElem, bounds, areLeftLabelsClickable, areBottomLabelsClickable, hideAxes, scales) {
            var isLeft = (facetIndex % facetInfo.columnCount == 0);
            var isBottom = Math.floor(facetIndex / facetInfo.columnCount) == facetInfo.rowCount - 1;
            var xoff = bounds.left - 1;
            var yoff = bounds.top - 1;
            //---- TODO: find underlying cause for this y-adjustment ----
            if (isBottom) {
                yoff += 0;
            }
            else {
                yoff += 0;
            }
            //---- create CHART FRAME control ----
            var chartFrame = this.createChartFrame();
            chartFrame
                .translate(xoff, yoff)
                .width(bounds.width)
                .height(bounds.height);
            //chartFrame.gridLines()
            //    .opacity(.4)
            this.setChartFrameProps(chartFrame, bounds.width, bounds.height, hideAxes, true, scales, cfd, dc, xAxisData, yAxisData, isLeft, isBottom, false);
            if (!hideAxes) {
                var tickSize = 16;
                var leftAxisWidth = this._bigChartFrame.leftAxis()._measuredSize;
                //---- set options on LEFT AXIS ----
                var leftAxis = chartFrame.leftAxis()
                    .isLabelsVisible(isLeft)
                    .hideInteriorLabels(false)
                    .labelOverflow(vp.chartFrame.LabelOverflow.ellipses);
                var bottomAxisHeight = this._bigChartFrame.bottomAxis()._measuredSize;
                //---- set options on BOTTOM AXIS ----
                var bottomAxis = chartFrame.bottomAxis()
                    .isLabelsVisible(isBottom)
                    .hideInteriorLabels(false)
                    .labelOverflow(vp.chartFrame.LabelOverflow.ellipses)
                    .labelRotation(vp.chartFrame.LabelRotation.auto)
                    .positiveAutoRotation(false);
            }
            chartFrame.build();
            this._facetChartFrames.push(chartFrame);
        };
        /** converts a WORLD space scale to a SCREEN space scale. */
        chartFrameHelperClass.prototype.cloneScale = function (oldScale, attr, rangeMin, rangeMax, axisName) {
            var myScale = null;
            var scaleType = beachParty.MappingSpread.normal;
            var oldScaleType = oldScale.scaleType();
            var anyOldScale = oldScale;
            var domainMin = oldScale.domainMin();
            var domainMax = oldScale.domainMax();
            //---- map domain boundaries using our transform matrix ----
            if (axisName == "x" || axisName == "y") {
                if (anyOldScale._binResults || oldScale.isCategory()) {
                    //---- use break indexes rather than true data ----
                    var count = 0;
                    if (anyOldScale._binResults) {
                        count = anyOldScale._binResults.bins.length;
                    }
                    else if (anyOldScale.getBreaks) {
                        count = anyOldScale.getBreaks();
                    }
                    else if (anyOldScale._categoryKeys) {
                        count = anyOldScale._categoryKeys.length;
                    }
                    if (anyOldScale._useCategoryForBins) {
                        count--;
                    }
                    var result = this.transformScaleDomain(oldScale, axisName, 0, count);
                }
                else {
                    var result = this.transformScaleDomain(oldScale, axisName, domainMin, domainMax);
                }
                domainMin = result.domainMin;
                domainMax = result.domainMax;
            }
            if (oldScaleType == vp.scales.ScaleType.linear) {
                if (scaleType == beachParty.MappingSpread.low) {
                    myScale = vp.scales.createLowBias();
                }
                else if (scaleType == beachParty.MappingSpread.high) {
                    myScale = vp.scales.createHighBias();
                }
                else {
                    myScale = vp.scales.createLinear();
                }
                //vp.utils.debug("cloneScale: axisName=" + axisName);
                myScale
                    .domainMin(domainMin)
                    .domainMax(domainMax)
                    .rangeMin(rangeMin)
                    .rangeMax(rangeMax);
                myScale.preserveBreakPoints = (anyOldScale._binResults != null);
            }
            else if (oldScaleType == vp.scales.ScaleType.dateTime) {
                myScale = vp.scales.createDate()
                    .domainMin(domainMin)
                    .domainMax(domainMax)
                    .rangeMin(rangeMin)
                    .rangeMax(rangeMax);
                //---- map domain boundaries using our transform matrix ----
                myScale.preserveBreakPoints = (anyOldScale._binResults != null);
                myScale._useCategoryForBins = anyOldScale._useCategoryForBins;
            }
            else {
                //var catKeys = vp.utils.keys(oldScale.categoryKeys());
                var catKeys = this.getCategoryKeysInOrder(oldScale);
                //if (false)      // oldScaleType == vp.scales.ScaleType.categoryIndex)
                //{
                //    myScale = vp.scales.createCategoryIndex()
                //        .categoryKeys(catKeys)
                //}
                //else
                if (oldScale.isCategory()) {
                    myScale = vp.scales.createCategoryKey()
                        .categoryKeys(catKeys);
                }
                else {
                    throw "Unsupported scaleType: " + oldScaleType;
                }
                myScale
                    .range(rangeMin, rangeMax);
                myScale.preserveBreakPoints = true;
            }
            //---- convert expandSpace from 3D units to pixels ----
            var expandSpace = oldScale.expandSpace();
            expandSpace = this._transformer.worldSizeToScreen(expandSpace);
            myScale
                .expandSpace(expandSpace);
            return myScale;
        };
        chartFrameHelperClass.prototype.transformScaleDomain = function (scale, axisName, dataMin, dataMax) {
            //var invWorld = this._transformer.getInvWorldpMatrix();
            var matWorld = this._transformer.getInvWorldpMatrix();
            var xxx = this._transformer.getWorldBounds();
            //---- map from NDC bounds to world bounds (for current transform) ---- 
            if (axisName == "x") {
                var ptTrans = this._transformer.transformPtWithMatrix(xxx.left, 0, 0, matWorld);
                var minWorld = ptTrans.x;
                var ptTrans = this._transformer.transformPtWithMatrix(xxx.right, 0, 0, matWorld);
                var maxWorld = ptTrans.x;
            }
            else if (axisName == "y") {
                var ptTrans = this._transformer.transformPtWithMatrix(0, xxx.bottom, 0, matWorld);
                var minWorld = ptTrans.y;
                var ptTrans = this._transformer.transformPtWithMatrix(0, xxx.top, 0, matWorld);
                var maxWorld = ptTrans.y;
            }
            //---- reverse scale the world bounds to get data bounds of current view ----
            var minNewData = vp.data.mapValue(minWorld, scale._palette[0], scale._palette[1], dataMin, dataMax);
            var maxNewData = vp.data.mapValue(maxWorld, scale._palette[0], scale._palette[1], dataMin, dataMax);
            return { domainMin: minNewData, domainMax: maxNewData };
        };
        chartFrameHelperClass.prototype.createAxisData = function (scale, attr, rangeMin, rangeMax, axisName) {
            /// CAUTION: "scale" was built in world space, but rangeMin/rangeMax are in screen pixels.
            //---- todo: put a real, user-controllable value here ----
            var tickCount = 9; // get adjusted below    // scale.getActualBreaks().length;
            if (scale.scaleType() == vp.scales.ScaleType.categoryIndex) {
                tickCount++;
            }
            //---- create special properties added by chartUtils.adjustScaleForBin() ----
            var anyScale = scale;
            var formatter = anyScale._formatter;
            var breaks = anyScale._breaks;
            var labels = anyScale._labels;
            var newScale = this.cloneScale(scale, attr, rangeMin, rangeMax, axisName);
            //---- support case where we are scaling with numbers, but have a formatting string from Excel ----
            //---- in this case, ignore the Excel format, and do our own local formatting because when user has filtered view, ----
            //---- we can provide a closer fit to the values shown.  We may revisit this in the future ----
            if (formatter && formatter._colType == "number") {
            }
            //---- adjust breaks (subbsetting or creating new break values) to match the updated domainMin/domainMax ----
            var preserveBreakPoints = newScale.preserveBreakPoints;
            var domainMin = newScale._domainMin;
            var domainMax = newScale._domainMax;
            var fullBreakCount = (breaks) ? breaks.length : 0;
            if (preserveBreakPoints) {
                //---- subset the full set of break points ----
                var firstIndex = Math.max(0, Math.ceil(domainMin));
                var lastIndex = Math.min(Math.floor(domainMax), fullBreakCount - 1);
                var diff = lastIndex - firstIndex;
                breaks = vp.data.range(firstIndex, lastIndex);
                labels = null;
            }
            else if (breaks && breaks.length > 1) {
                //---- replace breaks with domainMin, domainMax ticks to match current transform ----
                var diff = domainMax - domainMin;
                var steps = diff / (fullBreakCount - 1);
                breaks = vp.data.range(domainMin, domainMax, steps);
                vp.utils.assert(breaks.length == fullBreakCount);
                labels = null; // regen these to match new breaks
            }
            if (breaks && breaks.length) {
                var len = breaks.length;
                //---- for bin-related scales, since breaks could be non-linear, we need to ensure mapping is linear ----
                if (anyScale._binResults && !anyScale._useCategoryForBins) {
                    if (!labels) {
                        //---- create labels from original breaks ----
                        labels = breaks.map(function (data, index) {
                            var binResults = anyScale._binResults;
                            var useCategoryForBins = anyScale._useCategoryForBins;
                            if (binResults) {
                                if (useCategoryForBins) {
                                    var bin = binResults.bins[data];
                                    data = bin.name;
                                }
                                else if (index == breaks.length - 1) {
                                    var bin = binResults.bins[data - 1];
                                    data = bin.maxLabel;
                                }
                                else {
                                    var bin = binResults.bins[data];
                                    data = bin.minLabel;
                                }
                            }
                            else {
                                data = (formatter) ? formatter(data) : (data + "");
                            }
                            return data;
                        });
                    }
                    //---- replace nonlinear breaks with linear breaks ----
                    breaks = vp.data.range(0, len - 1);
                }
                //---- when breaks are specified, they override domainMin/domainMax specifications ----
                newScale
                    .domainMin(breaks[0])
                    .domainMax(breaks[len - 1]);
            }
            else if (anyScale._tickCount) {
                tickCount = anyScale._tickCount;
            }
            var isCategory = (scale.scaleType() == vp.scales.ScaleType.categoryIndex || scale.scaleType() == vp.scales.ScaleType.categoryKey);
            if (isCategory) {
                //var catKeys = scale.categoryKeys();
                var catKeys = this.getCategoryKeysInOrder(anyScale);
                breaks = (catKeys) ? catKeys : null;
            }
            var axisData = vp.chartFrame.createAxisData(newScale, null, tickCount, breaks, labels, formatter);
            return axisData;
        };
        chartFrameHelperClass.prototype.getCategoryKeysInOrder = function (scale) {
            var catKeysObj = scale.categoryKeys();
            var keysOnly = vp.utils.keys(catKeysObj);
            var catKeysInOrder = [];
            for (var k = 0; k < keysOnly.length; k++) {
                var theKey = keysOnly[k];
                var index = catKeysObj[theKey];
                if (theKey == "") {
                    theKey = this._blankStrValue;
                }
                catKeysInOrder[index] = theKey;
            }
            return catKeysInOrder;
        };
        chartFrameHelperClass.prototype.close = function () {
            vp.select(this._root)
                .clear();
            //this._chartFrame.close();       
        };
        chartFrameHelperClass.prototype.fadeInOut = function (show) {
            //var cfd = this._chartFrameData;
            //if (show)
            //{
            //    vp.select(this._chartFrameRoot)
            //        .css("transition", "opacity .25s ease-in-out")
            //        .css("opacity", cfd.opacity + "")
            //}
            //else
            //{
            //    vp.select(this._chartFrameRoot)
            //        .css("transition", "opacity 0s ease-in-out")
            //        .css("opacity", "0")
            //}
        };
        chartFrameHelperClass.prototype.show = function (value) {
            var cfd = this._chartFrameData;
            if (value) {
                vp.select(this._root)
                    .css("opacity", cfd.opacity + "");
            }
            else {
                vp.select(this._root)
                    .css("opacity", "0");
            }
        };
        chartFrameHelperClass.prototype.build = function (width, height, hideAxes, usingFacets, cfd, dc, facetLayoutInPixels, isXAxisClickable, isYAxisClickable) {
            vp.select(this._root)
                .clear();
            //---- axis sizes ----
            var leftWidth = Math.min(100, .25 * width);
            var bottomHeight = Math.min(75, .25 * height);
            if (hideAxes === true || hideAxes == "y" || !cfd.yAxis.isAxisVisible) {
                leftWidth = 0;
            }
            if (hideAxes === true || hideAxes == "x" || !cfd.xAxis.isAxisVisible) {
                bottomHeight = 0;
            }
            this._leftWidth = leftWidth;
            this._bottomHeight = bottomHeight;
            this._hideAxes = hideAxes;
            //---- for now, always build the big chartFrame to get layout info for overall chart ----
            this.buildBigChartFrame(width, height, hideAxes, usingFacets, dc.scales, cfd, dc, isXAxisClickable, isYAxisClickable);
            //if (usingFacets)
            //{
            //    this.buildFacetFrames(width, height, cfd, dc, this._root, scales, hideAxes, facetLayoutInPixels);
            //}
            var rcPlot = this.layoutChartFrames(width, height, dc, cfd);
            //---- ensure we didn't exceed our layout bounds ----
            //if (rcPlot.left < 0 || rcPlot.right > width || rcPlot.top < 0 || rcPlot.bottom > height)
            //{
            //    vp.utils.error("chartFrameHelper.build: bounds of plot exceed client area");
            //}
            return rcPlot;
        };
        chartFrameHelperClass.prototype.layoutChartFrames = function (width, height, dc, cfd) {
            var rcPlot = this._bigChartFrame.plotAreaBounds();
            //var rcPlot = vp.geom.createRect(this._leftWidth, 0, width - this._leftWidth, height - this._bottomHeight);
            var left = rcPlot.left;
            var top = rcPlot.top;
            var width = rcPlot.width;
            var height = rcPlot.height;
            var padding = cfd.padding;
            if (padding) {
                //---- width and height have already been adjusted for 2*padding ----
                left += padding.left;
                top += padding.top;
            }
            //---- workaround for slight errors in chartFrame calculations (positioning of glCanvas must be pixel perfect) ----
            //---- in parallel, we also need to adjust the facet layout to match ----
            if (dc.facetHelper) {
                if (this._hideAxes !== true && this._hideAxes != "x") {
                    left += 10;
                }
                if (this._hideAxes !== true && this._hideAxes != "y") {
                    height -= 20;
                }
            }
            rcPlot = vp.geom.createRect(left, top, width, height);
            return rcPlot;
        };
        chartFrameHelperClass.prototype.buildBigChartFrame = function (width, height, hideAxes, usingFacets, scales, cfd, dc, isXAxisClickable, isYAxisClickable) {
            this._isXAxisClickable = isXAxisClickable;
            this._isYAxisClickable = isYAxisClickable;
            var chartFrame = this.createChartFrame();
            this._bigChartFrame = chartFrame;
            this._chartFrameData = cfd;
            //---- adjust width/height for padding ----
            var padding = cfd.padding;
            if (padding) {
                vp.select(this._root)
                    .translate(padding.left, padding.top);
                width -= (padding.left + padding.right);
                height -= (padding.top + padding.bottom);
            }
            var xAttr = null; // attributes.x;
            var yAttr = null; // attributes.y;
            var xAxisData = this.createAxisData(scales.x, xAttr, 0, width, "x");
            var yAxisData = this.createAxisData(scales.y, yAttr, height, 0, "y");
            this.setChartFrameProps(chartFrame, width, height, hideAxes, usingFacets, scales, cfd, dc, xAxisData, yAxisData, true, true, true);
            chartFrame.build();
        };
        chartFrameHelperClass.prototype.setChartFrameProps = function (chartFrame, width, height, hideAxes, usingFacets, scales, cfd, dc, xAxisData, yAxisData, isLeft, isBottom, isBigChartFrame) {
            vp.select(this._root)
                .css("opacity", cfd.opacity + "");
            chartFrame
                .xAxisData(xAxisData)
                .yAxisData(yAxisData);
            var isGridVisible = (cfd.xAxis.drawGridLines || cfd.yAxis.drawGridLines);
            var showXAxis = (hideAxes !== true && hideAxes != "x" && cfd.xAxis.isAxisVisible);
            var showYAxis = (hideAxes !== true && hideAxes != "y" && cfd.yAxis.isAxisVisible);
            if (hideAxes === true) {
                isGridVisible = false;
            }
            chartFrame
                .width(width)
                .height(height)
                .isLeftAxisVisible(showYAxis)
                .isBottomAxisVisible(showXAxis)
                .isTopAxisVisible(false)
                .isRightAxisVisible(false)
                .isGridLinesVisible(isGridVisible)
                .axesOnOutside(usingFacets && !isBigChartFrame)
                .isBoxVisible(false);
            if (isGridVisible) {
                chartFrame.gridLines()
                    .isXVisible(cfd.xAxis.drawGridLines)
                    .isYVisible(cfd.yAxis.drawGridLines);
            }
            var chartType = dc.toChartType;
            if (hideAxes !== true) {
                var tickSize = 16;
                if (dc.nvData.y) {
                    var areLeftLabelsClickable = this._isYAxisClickable;
                    //---- set options on LEFT AXIS ----
                    var leftAxis = chartFrame.leftAxis()
                        .labelOverflow(vp.chartFrame.LabelOverflow.ellipses);
                    var yBinResults = (scales.y) ? scales.y._binResults : null;
                    var showYTickBoxes = (this._isYAxisClickable && isLeft);
                    this.shadeYAxis(dc, yAxisData, yBinResults, chartType, showYTickBoxes, leftAxis, areLeftLabelsClickable, usingFacets);
                }
                if (dc.nvData.x) {
                    var areBottomLabelsClickable = this._isXAxisClickable;
                    var xBinResults = (scales.x) ? scales.x._binResults : null;
                    //---- set options on BOTTOM AXIS ----
                    var bottomAxis = chartFrame.bottomAxis()
                        .labelOverflow(vp.chartFrame.LabelOverflow.ellipses)
                        .labelRotation(vp.chartFrame.LabelRotation.auto)
                        .positiveAutoRotation(false);
                    var showXTickBoxes = (this._isXAxisClickable && isBottom);
                    this.shadeXAxis(dc, xAxisData, xBinResults, chartType, showXTickBoxes, bottomAxis, areBottomLabelsClickable);
                }
            }
        };
        chartFrameHelperClass.prototype.shadeXAxis = function (dc, xAxisData, xBinResults, chartType, showTickBoxes, bottomAxis, areBottomLabelsClickable) {
            var _this = this;
            var xCol = (dc.xCalcName) ? dc.xCalcName : dc.nvData.x.colName;
            var xIsCat = (dc.nvData.x.colType == "string"); // || (<any>dc.scales.x)._useCategoryForBins);
            var xLast = null;
            var xLastIndex = xAxisData.tickCount() - 1;
            this._xTickBoxElements = [];
            var labelList = [];
            bottomAxis
                .isTickBoxesVisible(showTickBoxes)
                .onShade(function (element, record, index, isNew, isLastNew) {
                if (index == 0) {
                    xLast = null;
                    labelList = [];
                }
                if (areBottomLabelsClickable && isNew) {
                    if (vp.dom.hasClass(element, "vpxAxisLabel")) {
                        element._boxName = "index=" + index; // for event handling
                        vp.select(element)
                            .attach("click", function (e) { return _this.doNewSearch(e, "X", e.target._boxName); })
                            .css("cursor", "pointer")
                            .attr("simpleHighlight", "true")
                            .addClass("clickableAxisLabel");
                        //---- build info needed by CLICK to do search ----
                        beachParty.searchUtils.buildSearchInfoOnElem(element, labelList, record, xBinResults, index, xCol, xIsCat, "x", "tick", isLastNew);
                    }
                    else if (vp.dom.hasClass(element, "vpxAxisTickBox")) {
                        var tickBarTooltip = null;
                        if (xBinResults && index > 0) {
                            var bin = xBinResults.bins[index - 1];
                            var itemCount = bin.count;
                            tickBarTooltip = "Count: " + vp.formatters.formatNumber(itemCount, "0,##0");
                            if (chartType == "columnSumClass") {
                                var itemSum = bin.sum; //  this.computeBinSum(dc, "x", bin.rowIndexes);
                                tickBarTooltip = "Sum: " + vp.formatters.formatNumber(itemSum, "0,##0") + ", " +
                                    tickBarTooltip;
                            }
                        }
                        element._boxName = "index=" + index; // for event handling
                        vp.select(element)
                            .attach("click", function (e) { return _this.doNewSearch(e, "X", e.target._boxName); })
                            .title(tickBarTooltip);
                        //---- build info needed by CLICK to do search ----
                        beachParty.searchUtils.buildSearchInfoOnElem(element, labelList, record, xBinResults, index, xCol, xIsCat, "x", "bar", isLastNew);
                        _this._xTickBoxElements[index] = element;
                    }
                }
            });
        };
        chartFrameHelperClass.prototype.shadeYAxis = function (dc, yAxisData, yBinResults, chartType, showTickBoxes, leftAxis, areLeftLabelsClickable, isFacet) {
            var _this = this;
            var yCol = (dc.yCalcName) ? dc.yCalcName : dc.nvData.y.colName;
            var yIsCat = (dc.nvData.y.colType == "string"); // || (<any>dc.scales.y)._useCategoryForBins);
            var yLast = null;
            //var yLastIndex = yAxisData.tickCount() - 1;
            this._yTickBoxElements = [];
            //--- lock down the width of the Y axis ---
            if (!isFacet) {
                leftAxis.minWidth(this._leftWidth);
            }
            var labelList = [];
            //---- hook the "shaded" event so that we can apply our custom settings on axis labels ----
            leftAxis
                .isTickBoxesVisible(showTickBoxes)
                .onShade(function (element, record, index, isNew, isLastNew) {
                if (index == 0) {
                    yLast = null;
                    labelList = [];
                }
                //---- isNew is set to true if we haven't seen this element before ----
                if (areLeftLabelsClickable && isNew) {
                    if (vp.dom.hasClass(element, "vpxAxisLabel")) {
                        element._boxName = "index=" + index; // for event handling
                        vp.select(element)
                            .attach("click", function (e) { return _this.doNewSearch(e, "Y", e.target._boxName); })
                            .css("cursor", "pointer")
                            .attr("simpleHighlight", "true")
                            .addClass("clickableAxisLabel");
                        //---- build info needed by CLICK to do search ----
                        beachParty.searchUtils.buildSearchInfoOnElem(element, labelList, record, yBinResults, index, yCol, yIsCat, "y", "tick", isLastNew);
                    }
                    else if (vp.dom.hasClass(element, "vpxAxisTickBox")) {
                        var tickBarTooltip = null;
                        if (yBinResults && index > 0) {
                            var bin = yBinResults.bins[index - 1];
                            var itemCount = bin.count;
                            tickBarTooltip = "Count: " + vp.formatters.formatNumber(itemCount, "0,##0");
                            if (chartType == "barSumClass") {
                                var itemSum = bin.sum; //  this.computeBinSum(dc, "y", bin.rowIndexes);
                                tickBarTooltip = "Sum: " + vp.formatters.formatNumber(itemSum, "0,##0") + ", " +
                                    tickBarTooltip;
                            }
                        }
                        element._boxName = "index=" + index; // for event handling
                        vp.select(element)
                            .attach("click", function (e) { return _this.doNewSearch(e, "Y", e.target._boxName); })
                            .title(tickBarTooltip);
                        //---- build info needed by CLICK to do search ----
                        beachParty.searchUtils.buildSearchInfoOnElem(element, labelList, record, yBinResults, index, yCol, yIsCat, "y", "bar", isLastNew);
                        _this._yTickBoxElements[index] = element;
                    }
                }
            });
        };
        chartFrameHelperClass.prototype.doNewSearch = function (e, axisName, boxLabel) {
            //---- tick box click handling has been moved to the chart class ----
            var selectMode = this._chartBuilder.getChart().selectMode();
            var sp = beachParty.searchUtils.searchOnTickOrBarClick(e, selectMode);
            this.onTickBoxClick.trigger({ sender: this, buttonType: sp.buttonType, axisName: sp.axisName, boxLabel: boxLabel, searchParams: sp });
        };
        return chartFrameHelperClass;
    }(beachParty.dataChangerClass));
    beachParty.chartFrameHelperClass = chartFrameHelperClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chartUtils.ts - common functions used by some of the chart classes
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var chartUtils = (function () {
        function chartUtils() {
        }
        chartUtils.fadeIn = function (elem, msDuration) {
            if (msDuration === void 0) { msDuration = 35; }
            var boxW = vp.select(elem);
            //---- workaround bug in Edge where animated fade results in unstable visibility ----
            if (vp.utils.isEdge) {
                msDuration = 0;
            }
            if (msDuration === 0) {
                //---- make visible NOW---
                boxW
                    .css("opacity", "1")
                    .css("display", "")
                    .css("visibility", "")
                    .css("animation", "")
                    .css("animation-fill-mode", "");
            }
            else {
                //---- animate opacity ---
                var anim = "fadeIn " + msDuration + "ms forwards";
                vp.utils.debug("fadeIn: anim=" + anim);
                boxW
                    .css("display", "")
                    .css("visibility", "")
                    .css("animation", anim);
            }
        };
        chartUtils.fadeOut = function (elem, msDuration) {
            if (msDuration === void 0) { msDuration = 35; }
            var boxW = vp.select(elem);
            if (msDuration === 0) {
                //---- make hidden NOW---
                boxW
                    .css("opacity", "0")
                    .css("display", "none")
                    .css("visibility", "")
                    .css("animation", "")
                    .css("animation-fill-mode", "");
            }
            else {
                //---- animate opacity to hide ---
                var anim = "fadeOut " + msDuration + "ms";
                boxW
                    .css("animation", anim)
                    .css("animation-fill-mode", "forwards");
                var anim = "fadeOut " + msDuration + "ms";
                setTimeout(function (e) { return boxW.css("display", "none"); }, msDuration);
            }
        };
        chartUtils.isVisible = function (name) {
            var disp = vp.select("#" + name).css("display");
            return (disp != "none");
        };
        chartUtils.findIgnoreClickElem = function (elem) {
            while (elem) {
                if (elem.ignoreNextClick) {
                    break;
                }
                elem = elem.parentNode;
            }
            return elem;
        };
        chartUtils.callPanelOpen = function (e, callback) {
            if (e) {
                var elem = chartUtils.findIgnoreClickElem(e.target);
                if (elem) {
                    vp.utils.debug("callPanelOpen: elem.id=" + elem.id + " , ignoreClick=found");
                    elem.ignoreNextClick = false;
                }
                else {
                    vp.utils.debug("callPanelOpen: e.target.id=" + e.target.id + ", ignoreClick=NOT found");
                    callback(e);
                }
            }
            else {
                vp.utils.debug("callPanelOpen: e=null");
                callback(e);
            }
        };
        chartUtils.scaleColData = function (vector, index, scale, defaultValue) {
            if (defaultValue === void 0) { defaultValue = 0; }
            var result = defaultValue;
            if (vector) {
                var colValue = vector.values[index];
                var needKey = scale.scaleType() == vp.scales.ScaleType.categoryKey;
                if (needKey) {
                    colValue = (vector.keyInfo) ? vector.keyInfo.keysByIndex[colValue] : (colValue + "");
                }
                //---- handle NAN's by treating them as "0" for now ----
                if (!needKey && isNaN(colValue)) {
                    colValue = 0;
                }
                result = scale.scale(colValue);
            }
            return result;
        };
        chartUtils.setFilteredMinMaxBreak = function (md, layoutFilterVector, nv) {
            //---- filter data using layoutFilterVector ----
            var newVector = [];
            var values = nv.values;
            var keys = null;
            var min = null;
            var max = null;
            if (nv.colType == "string") {
                var nvFilter = new beachParty.NumericVector(layoutFilterVector, "filter", "number");
                keys = beachParty.cbUtils.getFilteredSortedKeys(nv, nvFilter);
                min = 0;
                max = keys.length - 1;
                md.allFacetsKeys = keys;
            }
            else {
                //---- filter the "all facets" data per current filter setting ----
                for (var i = 0; i < values.length; i++) {
                    if (!layoutFilterVector[i]) {
                        newVector.push(values[i]);
                    }
                }
                keys = null;
                min = newVector.min();
                max = newVector.max();
            }
            md.minBreakFacet = min;
            md.maxBreakFacet = max;
            return keys;
        };
        chartUtils.computeBestCountFactor = function (maxCount, shapesPerRow) {
            var breakCount = null;
            if (maxCount <= 1) {
                breakCount = 1;
            }
            else {
                var rowCount = Math.ceil(maxCount / shapesPerRow);
                maxCount = rowCount * shapesPerRow;
                var maxOver = 0;
                var bestFactor = null;
                //---- try various factors, in priority order ----
                var factors = [7, 8, 6, 5, 9, 4, 10, 3, 11, 12, 2];
                for (var i = 0; i < factors.length; i++) {
                    var f = factors[i];
                    var over = rowCount % f;
                    if (over === 0) {
                        breakCount = f;
                        break;
                    }
                    if (i == 0 || over > maxOver) {
                        maxOver = over;
                        bestFactor = f;
                    }
                }
                if (!breakCount) {
                    //---- take next highest factor of 7 ----
                    breakCount = bestFactor;
                    var rowsPerBreak = Math.ceil(rowCount / breakCount);
                    maxCount = rowsPerBreak * breakCount * shapesPerRow;
                }
            }
            return { maxCount: maxCount, tickCount: 1 + breakCount };
        };
        chartUtils.computeMaxBinCountForData = function (dc, nv, cm, binCol) {
            //---- compute single bin (for this facet) ----
            var requestedBins = cm.binCount;
            var sortOptions = new beachParty.binSortOptionsClass();
            sortOptions.sortDirection = cm.binSorting;
            sortOptions.sortByAggregateType = "count";
            var maxCount = 0;
            var binResults = beachParty.binHelper.createBins(nv, binCol, requestedBins, cm.binCount, false, true, true, sortOptions, null, cm.useNiceNumbers, cm);
            if (binResults) {
                var binCount = binResults.bins.length;
                //---- compute maxCount ----
                var maxCount = 0;
                for (var i = 0; i < binCount; i++) {
                    var count = binResults.bins[i].count;
                    maxCount = Math.max(maxCount, count);
                }
            }
            return { maxCount: maxCount, binResults: binResults };
        };
        chartUtils.binTheDataForCount = function (dc, data, cm, binCol) {
            var requestedBins = cm.binCount;
            var sortOptions = new beachParty.binSortOptionsClass();
            sortOptions.sortDirection = cm.binSorting;
            sortOptions.sortByAggregateType = "count";
            var maxCount = 0;
            var binResults = beachParty.binHelper.createBins(data, binCol, requestedBins, cm.binCount, false, true, true, sortOptions, null, cm.useNiceNumbers, cm);
            return binResults;
        };
        chartUtils.computeSumForFacet = function (dc, data, cm, binColumn, sumByColumn) {
            var sortOptions = new beachParty.binSortOptionsClass();
            sortOptions.sortDirection = cm.binSorting;
            sortOptions.sortByAggregateType = "sum";
            sortOptions.sumByColumn = sumByColumn;
            var maxCount = 0;
            var requestedBins = cm.binCount;
            var binResults = beachParty.binHelper.createBins(data, binColumn, requestedBins, requestedBins, false, true, true, sortOptions, null, cm.useNiceNumbers, cm);
            if (binResults) {
                var binCount = binResults.bins.length;
                //cpp.binResults.push(xResult);
                //---- find tallest bin for the current facet ----
                var maxPosSum = 0;
                var maxNegSum = 0;
                for (var i = 0; i < binCount; i++) {
                    var result = this.computeBinNegPosSums(dc, binResults.bins[i], sumByColumn);
                    maxPosSum = Math.max(maxPosSum, result.posSum);
                    maxNegSum = Math.max(maxNegSum, result.negSum);
                }
            }
            return { maxPosSum: maxPosSum, maxNegSum: maxNegSum, binResults: binResults };
        };
        chartUtils.computeBinNegPosSums = function (dc, binResult, sumColumn) {
            var rowIndexes = binResult.rowIndexes;
            var posHeight = 0;
            var negHeight = 0;
            var nv = dc.nvData;
            var values = nv[sumColumn].values;
            for (var i = 0; i < rowIndexes.length; i++) {
                var vectorIndex = rowIndexes[i];
                //---- only process FILTERED-IN records ----
                if (!dc.layoutFilterVector[vectorIndex]) {
                    var height = values[vectorIndex];
                    if (height >= 0) {
                        posHeight += height;
                    }
                    else {
                        negHeight += height;
                    }
                }
            }
            return { posSum: posHeight, negSum: Math.abs(negHeight) };
        };
        chartUtils.getOrderOfBins = function (bins) {
            var isAscend = true;
            var isDescend = true;
            var lastValue = null;
            for (var i = 0; i < bins.length; i++) {
                var value = bins[i].min;
                if (i > 0) {
                    if (value < lastValue) {
                        isAscend = false;
                    }
                    else if (value > lastValue) {
                        isDescend = false;
                    }
                }
                lastValue = value;
            }
            var order = (isAscend) ? +1 : ((isDescend) ? -1 : 0);
            return order;
        };
        //static getUnionOfKeys(appMgr: appMgrClass, axisName: string)
        //{
        //    var colInfos = appMgr.getDataMgr().getColInfos(true);
        //    var colName = appMgr.getDataView().xMapping().colName;
        //    var keys = null;
        //    for (var i = 0; i < colInfos.length; i++)
        //    {
        //        var colInfo = colInfos[i];
        //        if (colInfo.name == colName)
        //        {
        //            keys = colInfo.sortedKeys;
        //            break;
        //        }
        //    }
        //    return keys;
        //}
        chartUtils.adjustScaleForBin = function (scale, binResulsArray, axisName) {
            var scaleType = scale.scaleType();
            var binResults = binResulsArray[0];
            var bins = binResults.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNames = [];
            for (var i = 0; i < bins.length; i++) {
                binNames[i] = bins[i].name;
            }
            if (scaleType == vp.scales.ScaleType.categoryIndex || scaleType == vp.scales.ScaleType.categoryKey) {
                //if (appMgr && axisName)
                //{
                //    binNames = this.getUnionOfKeys(appMgr, axisName);
                //}
                scale.categoryKeys(binNames);
            }
            else {
                //---- looks at each bin value and determines the current sort order ----
                var order = this.getOrderOfBins(bins);
                //---- order = 1 means ascending order ----
                //---- order = 0 means bins are in random order, according to their conseq. min/max values ----
                //---- order = -1 means descending order ----
                var useCategoryForBins = (order != 1);
                if (useCategoryForBins) {
                    var oldScale = scale;
                    scale = vp.scales.createCategoryIndex()
                        .categoryKeys(binNames)
                        .range(oldScale.rangeMin(), oldScale.rangeMax());
                    binResults.useCategoryForBins = true;
                }
                else {
                    var breakValues = [];
                    var labels = [];
                    var numBins = binResults.bins;
                    var anyScale = scale;
                    for (var b = 0; b < numBins.length; b++) {
                        var numBin = numBins[b];
                        breakValues.push(numBin.min);
                        labels.push(numBin.minLabel);
                        if (b == bins.length - 1) {
                            breakValues.push(numBin.max);
                            labels.push(numBin.maxLabel);
                        }
                    }
                    anyScale._breaks = breakValues;
                    anyScale._labels = labels;
                    if (scaleType == vp.scales.ScaleType.dateTime && !anyScale._formatter) {
                        //---- use the formatString returned by the binning function ----
                        var formatString = binResults.dateFormatString;
                        var formatter = vp.formatters.createExcelFormatter(formatString, "date");
                        anyScale._formatter = formatter;
                    }
                }
            }
            var anyScale = scale;
            anyScale._binResults = binResults;
            anyScale._useCategoryForBins = useCategoryForBins;
            return scale;
        };
        chartUtils.getScatterShapeSize = function (dc, recordCount, chart) {
            var maxShapeSize = (chart) ? chart.defaultShapeSize() : null;
            if (maxShapeSize) {
                //---- convert from pixels to world units ----
                maxShapeSize = chart.getTransformer().screenSizeXToWorld(maxShapeSize);
            }
            else {
                var facetCount = (dc.facetHelper) ? dc.facetHelper.facetCount() : 0;
                if (recordCount === undefined || recordCount === null) {
                    recordCount = dc.filteredRecordCount;
                }
                maxShapeSize = this.getScatterShapeSizeEx(recordCount, dc.width, dc.height, facetCount);
            }
            return maxShapeSize;
        };
        /** returns the best shape size (in world units) for a scatter-like chart. */
        chartUtils.getScatterShapeSizeEx = function (filteredRecordCount, width, height, facetCount) {
            var count = filteredRecordCount;
            //---- density-based shape size ----
            var maxShapeSize = Math.sqrt((width * height) / count);
            //---- adjust for spacing ----
            if (facetCount > 1) {
                maxShapeSize *= 1.25;
            }
            else {
                maxShapeSize *= .375; // .25;
            }
            return maxShapeSize;
        };
        chartUtils.computeMaxCountOverFacets = function (dc, nvFacetBuckets) {
            var maxCount = 0;
            if (nvFacetBuckets) {
                for (var i = 0; i < nvFacetBuckets.length; i++) {
                    var nv = nvFacetBuckets[i];
                    var count = nv.layoutFilter.count(0);
                    maxCount = Math.max(maxCount, count);
                }
            }
            else {
                maxCount = dc.filteredRecordCount;
            }
            return maxCount;
        };
        /** Compute the fixed-width and max-height of bins for a Column Chart. This code is shared to encourage consistent layout results for
         * Column Grid, Column Sum.
         */
        chartUtils.computeColumnBinSize = function (facetResult, availWidth, availHeight) {
            var binCount = facetResult.bins.length;
            var approxItemWidth = availWidth / binCount;
            var xMargin = .05 * approxItemWidth;
            var xBetween = .10 * approxItemWidth;
            var binWidth = (availWidth - (2 * xMargin) - (binCount - 1) * xBetween) / binCount;
            var binHeight = availHeight;
            return { binWidth: binWidth, binHeight: binHeight, xMargin: xMargin, xBetween: xBetween };
        };
        /** Compute the max-width and fixed-height of bins for a Bar chart. This code is shared to encourage consistent layout results for
         * Bar Grid, Bar Sum.
         */
        chartUtils.computeBarBinSize = function (facetResult, availWidth, availHeight) {
            var binCount = facetResult.bins.length;
            var approxItemHeight = availHeight / binCount;
            var yMargin = .05 * approxItemHeight;
            var yBetween = .15 * approxItemHeight;
            //---- compute itemWidth and itemHeight ----
            var itemHeight = (availHeight - (2 * yMargin) - (binCount - 1) * yBetween) / binCount;
            var itemWidth = availWidth;
            return { binWidth: itemWidth, binHeight: itemHeight, yMargin: yMargin, yBetween: yBetween };
        };
        chartUtils.capitalizeFirstLetter = function (value) {
            if (value.length) {
                value = value[0].toUpperCase() + value.substr(1);
            }
            return value;
        };
        return chartUtils;
    }());
    beachParty.chartUtils = chartUtils;
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    drawContext.ts - information for layout classes about the drawing/chart context.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** information needed to draw a facet/chart. */
    var DrawContext = (function () {
        function DrawContext(rcxWorld, facetHelper, nvData, scales, recordCount, filteredRecordCount, /*attrInfos: any,*/ userSizeFactor, fromChartType, toChartType, itemSize, transformer, chart) {
            /** used by baseGlVis code the scale size to GL sizes after user layout (transformSizeFactor * userSizeFactor. */
            //combinedSizeFactor: number;
            /* the recommend shape size for equal density layout of shapes.  some charts may use other sizes. */
            this.maxShapeSize = 0;
            /* how does this compare to maxShapeSize? */
            this.itemSize = 0;
            /* this is 1/2 of itemSize. */
            this.itemHalf = 0;
            //---- minimums ----
            this.x = rcxWorld.left;
            this.y = rcxWorld.bottom; // top
            this.z = rcxWorld.back;
            //---- positive sizes ----
            this.width = rcxWorld.right - rcxWorld.left;
            this.height = rcxWorld.top - rcxWorld.bottom;
            this.depth = rcxWorld.front - rcxWorld.back;
            this.facetHelper = facetHelper;
            this.nvData = nvData;
            this.scales = scales;
            this.recordCount = recordCount;
            this.filteredRecordCount = filteredRecordCount;
            //this.attrInfos = attrInfos;
            this.fromChartType = fromChartType;
            this.toChartType = toChartType;
            this.facetIndex = 0;
            //---- sizes ----
            //this.transformSizeFactor = transformSizeFactor;
            this.userSizeFactor = userSizeFactor;
            //this.combinedSizeFactor = combinedSizeFactor;
            //---- is there a difference between itemSize and maxShapeSize? ----
            this.maxShapeSize = beachParty.chartUtils.getScatterShapeSize(this, null, chart);
            this.itemSize = this.maxShapeSize; //   itemSize;
            this.itemHalf = this.itemSize / 2;
            var zSpace = 4;
            this.defaultDepth2d = Math.min(this.itemSize * .05, zSpace * .25);
            this.layoutFilterVector = (nvData.layoutFilter && nvData.layoutFilter.values != null) ? nvData.layoutFilter.values : null;
            if (!this.layoutFilterVector) {
            }
            //---- compute SPACING FACTOR ----
            var marginBase = this.width / 5000;
            if (facetHelper) {
                marginBase *= 5;
            }
            this.spacingFactor = 4 * chart.separationFactor() * marginBase;
            if (recordCount > 10000) {
                this.spacingFactor *= .1; //.2;
            }
            this.transformer = transformer;
            //cellMargin *= 2;             
        }
        return DrawContext;
    }());
    beachParty.DrawContext = DrawContext;
})(beachParty || (beachParty = {}));
//------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chartBuilder.ts - does sizing of axes and plot area, followed by layout of specific view/chart type.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var chartBuilderClass = (function (_super) {
        __extends(chartBuilderClass, _super);
        function chartBuilderClass(parentElem, chart) {
            var _this = this;
            _super.call(this);
            this._buildTimer = null;
            this._buildNeededReason = null;
            this._drawNeededReason = "";
            this._isAggChart = false;
            this._isXAxisClickable = true;
            this._isYAxisClickable = true;
            this._shapes = []; // for building chart repro data (stored in Insights)
            this._selectionExists = false;
            this._primaryColorCount = 0;
            this._maxColors = 0; // mapped colors and selection color(s)
            this._prevDrawBounds = null;
            //---- FILTERING ----
            this._isFirstFilteredStage = false; // true if this is first of 2-stage filter cycles (shape engine animation cycles)
            this._isForwardFilter = true;
            //---- FACETS ----
            this._facetHelper = null;
            //---- the part of the client that contains just the plot ----
            this._rcPlotEst = vp.geom.createRect(0, 0, 1, 1); // estimate without axes
            this._rcPlotFinal = vp.geom.createRect(0, 0, 1, 1); // with axes taken into account (this is where plot in drawn within our webGL canvas)
            //---- size of the client area (containing the axes and the plot) ----
            this._clientWidth = 0;
            this._clientHeight = 0;
            this._maxItems = 0; // max items we are drawing?
            this._isSelectionChangeOnly = false;
            //---- PERF STATS ----
            this._buildPerf = {};
            this._drawCount = 0;
            this._buildChartElapsed = 0;
            this._layoutTime = 0;
            //---- events ----
            this.onCycleStart = new beachParty.bpEvent();
            this.onCycleEnd = new beachParty.bpEvent();
            //---- create CANVAS under parent ----
            var parentW = vp.select(parentElem);
            //.css("position", "relative")
            //---- make this exactly size of parent, so we don't have to resize and move it ----
            var canvasElemW = parentW.append("canvas")
                .id("glCanvas")
                .css("left", "0")
                .css("top", "0")
                .css("position", "absolute")
                .css("z-index", "999");
            var svgW = parentW.append("svg")
                .id("svgCanvas")
                .css("left", "0")
                .css("top", "0")
                .css("width", "100%")
                .css("height", "100%")
                .css("position", "absolute")
                .css("z-index", "1001");
            this._parentElem = parentW[0];
            this._glCanvasElem = canvasElemW[0];
            this._svgDoc = svgW[0];
            this.createSvgGroup();
            this._chart = chart;
            this._dataMgr = chart.getDataMgr();
            this._dataMgr.registerForChange("dataFrame", function (e) {
                //---- reset facet settings ----
                _this.onFacetChanged();
                //---- when data changes, reset the gl buffers ----
                _this._shapeEng.clearFromBuffers();
            });
            this._shapeEng = new beachParty.ShapeEngClass(canvasElemW[0]);
            var gl = this._shapeEng.getGlContext();
            this._shapeEng.onDrawFrame.attach(this, function (e) {
                _this._drawNeededReason = null;
                var touchMgr = _this._chart.getChartUx().getTouchMgr();
                touchMgr.onFrame();
            });
            this._shapeEng.onCycleEnd.attach(this, function (ss) {
                //---- trigger our own ON CYCLE END event ----
                var cs = ss;
                cs.buildChartElapsed = _this._buildChartElapsed;
                cs.layoutTime = _this._layoutTime;
                cs.isFirstFilterStage = _this._isFirstFilteredStage;
                cs.isSelectionChangeOnly = _this._isSelectionChangeOnly;
                _this.onCycleEnd.trigger(cs);
                _this._chartFrameHelper.fadeInOut(true);
                //---- 2-stage filter support ----
                var wasFirstFilteredStage = _this._isFirstFilteredStage;
                _this._prevFilter = (_this._nv.enterExitFilter) ? _this._nv.enterExitFilter.clone() : null;
                if (_this._isFirstFilteredStage) {
                    _this._isFirstFilteredStage = false;
                    //---- start new cycle ----
                    _this.markBuildNeeded("isFirstFilteredStage");
                }
                _this._isSelectionChangeOnly = false;
            });
            var transformer = new beachParty.transformerClass(gl); //   this._shapeEng.getTransformer();
            this._transformerMgr = new beachParty.transformMgrClass(gl, transformer);
            this._transformer = this._transformerMgr.getTransformer();
            this.buildChartFrameHelper();
            this._animationData = chart.animationData();
            this.refreshClientSize();
        }
        chartBuilderClass.prototype.getChartBounds = function () {
            var rc = vp.select(this._parentElem).getBounds();
            return rc;
        };
        chartBuilderClass.prototype.onFilteredChanged = function (isForward) {
            //---- this may cause "onEndOfCycle()" to be called, which resets "this._isFirstFilteredStage", so call this first ----
            this.markBuildNeeded("onFilteredChanged");
            this._isFirstFilteredStage = true;
            this._isForwardFilter = isForward;
        };
        chartBuilderClass.prototype.getGlCanvasElem = function () {
            return this._glCanvasElem;
        };
        chartBuilderClass.prototype.getSvgDoc = function () {
            return this._svgDoc;
        };
        chartBuilderClass.prototype.rectsDiffer = function (rc, rc2) {
            var isDiff = (rc.left != rc2.left || rc.top != rc2.top || rc.width != rc2.width || rc.height != rc2.height);
            return isDiff;
        };
        chartBuilderClass.prototype.rebuildCameraIfNeeded = function () {
            var rcFrame = this._rcPlotFinal;
            var rcPrev = this._prevDrawBounds;
            if (!rcPrev || !rcFrame || this.rectsDiffer(rcPrev, rcFrame)) {
                //---- REBUILD CAMERA immediately, so user can call getWorldBounds() ----
                this._transformer.updateCamera(this._transformer._isOrthoCamera, rcFrame.width, rcFrame.height);
                this._prevDrawBounds = rcFrame;
            }
            return rcFrame;
        };
        chartBuilderClass.prototype.getTransformer = function () {
            return this._transformer;
        };
        chartBuilderClass.prototype.getWorldBounds = function () {
            return this._transformer.getWorldBounds();
        };
        chartBuilderClass.prototype.setUpShapeEngParams = function () {
            var dp = this._shapeEng.getParams(); // start with default values
            var chart = this._chart;
            var rcBounds = this.rebuildCameraIfNeeded();
            //---- required parameters ----
            dp.canvasWidth = rcBounds.width;
            dp.canvasHeight = rcBounds.height;
            //---- animation, staggering ----
            this._animationData = this._chart.animationData();
            dp.animationParams = this._animationData;
            //---- drawing params ----
            dp.cameraParams = this._transformer.cameraParams();
            dp.sizeFactor = chart.sizeFactor();
            dp.drawPrimitive = beachParty.DrawPrimitive[chart.drawingPrimitive()];
            dp.useInstancing = this._chart.isInstancingEnabled();
            dp.drawOrderKey = this.getDrawOrderKey();
            dp.facetBins = this.getFacetBins();
            //dp.maxGlBufferLength = 16000;           // keep GL buffers relatively small
            //---- color params ----
            var colorPalette = this._finalColorPalette.slice(0, this._maxColors);
            dp.colorPalette = colorPalette; // contains shapeColor as the first entry
            dp.clearColor = chart.canvasColor();
            //---- selection, hover params ----
            dp.hoverParams = this._chart.getHoverParams();
            dp.hoverPrimaryKey = this._chart.hoverPrimaryKey();
            //---- lighting, opacity, blending ----
            var lightingParamns = this._chart.getLightingParanms();
            dp.lightParams = lightingParamns;
            dp.shapeOpacity = chart.shapeOpacity();
            dp.isBlendingEnabled = (!this._layout.getIs3dChart());
            //---- textures ----
            dp.shapeImage = this._chart.shapeImage();
            dp.useTextures = true;
            this._shapeEng.setParams(dp);
        };
        chartBuilderClass.prototype.getColorPalette = function () {
            var palette = null;
            var cm = this._chart.colorMapping();
            if (cm && cm.colName) {
                palette = cm.colorPalette;
            }
            return palette;
        };
        chartBuilderClass.prototype.getDrawOrderKey = function () {
            var drawOrderKey = null;
            if (this._dataFrame) {
                drawOrderKey = this._dataFrame.getSortKey();
                if (this._facetHelper) {
                    var facetHelper = this._facetHelper;
                    drawOrderKey = facetHelper._colName + "-" + facetHelper._facetCount + "-" + drawOrderKey;
                }
            }
            return drawOrderKey;
        };
        chartBuilderClass.prototype.getFacetBins = function () {
            var facetBins = null;
            if (this._facetHelper) {
                var facetHelper = this._facetHelper;
                var bins = facetHelper.binResult().bins;
                var layout = facetHelper.layout();
                facetBins = [];
                for (var i = 0; i < bins.length; i++) {
                    var fb = new beachParty.FacetBin();
                    fb.rowIndexes = bins[i].rowIndexes;
                    fb.drawOffset = { x: layout.facetBounds[i].x, y: layout.facetBounds[i].y };
                    facetBins.push(fb);
                }
            }
            return facetBins;
        };
        chartBuilderClass.prototype.getShapeEngine = function () {
            return this._shapeEng;
        };
        chartBuilderClass.prototype.createSvgGroup = function () {
            //---- create an svg GROUP element for chart to use for all of its SVG shapes ----
            var svgChartGroup = vp.select(this._svgDoc).append("g");
            //.translate(10, 10)          // account for margin bet. svgdoc & canvas 
            this._svgChartGroup = svgChartGroup[0];
            //---- create an svg GROUP element for the chart frame ----
            var svgChartFrameGroup = vp.select(this._svgDoc).append("g")
                .addClass("chartFrameGroup");
            this._svgChartFrameGroup = svgChartFrameGroup[0];
        };
        /**
         * A chart single frame draw has been requested.
         * @param reason
         */
        chartBuilderClass.prototype.redrawLastFrame = function (reason) {
            //---- ensure there is a last frame to draw ----
            if (this._finalColorPalette) {
                if (!this._drawNeededReason) {
                    this._drawNeededReason = reason;
                }
                this.setUpShapeEngParams();
                this._shapeEng.redrawLastFrame();
            }
        };
        /**
         * A new animation cycle has been requested.
         * @param reason
         */
        chartBuilderClass.prototype.markBuildNeeded = function (reason, ignoreFilterStage) {
            var _this = this;
            if (!this._buildTimer && this._chart.isVisible() && this._chart.isAutoRebuild()) {
                this._buildTimer = setTimeout(function (e) {
                    if (ignoreFilterStage) {
                        _this._isFirstFilteredStage = false;
                    }
                    _this.buildChart();
                }, 100);
                this._buildNeededReason = reason;
                this._isSelectionChangeOnly = (reason == "selectionChanged");
            }
        };
        chartBuilderClass.prototype.cancelBuildTimer = function () {
            if (this._buildTimer) {
                clearTimeout(this._buildTimer);
                this._buildTimer = null;
            }
        };
        chartBuilderClass.prototype.getCol = function (dataFrame, attrName, getOrigData) {
            var vector = null;
            if (attrName) {
                if (getOrigData) {
                    vector = dataFrame.getVector(attrName, false);
                }
                else {
                    vector = dataFrame.getNumericVector(attrName);
                }
            }
            return vector;
        };
        chartBuilderClass.prototype.buildNamedVectors = function (dataFrame) {
            //var attrInfos = this._attrInfos;
            var length = dataFrame.getRecordCount();
            //var bindings = this._chart.getBindings();
            var chart = this._chart;
            //---- get attribute/column mappings ----
            var xMap = chart.xMapping();
            var yMap = chart.yMapping();
            var zMap = chart.zMapping();
            var auxMap = chart.auxMapping();
            var crMap = chart.colorMapping();
            var szMap = chart.sizeMapping();
            var txMap = chart.textMapping();
            var imMap = chart.shapeMapping();
            var faMap = chart.facetMapping();
            var xData = this.getCol(dataFrame, xMap.colName);
            if (this._isAggChart) {
                var dataAgg = this._dataMgr.getPreload().dataAggregation;
                var strAggType = beachParty.AggType[dataAgg.aggType];
                var yData = this.getCol(dataFrame, strAggType);
            }
            else {
                var yData = this.getCol(dataFrame, yMap.colName);
            }
            var zData = this.getCol(dataFrame, zMap.colName);
            var auxData = this.getCol(dataFrame, auxMap.colName);
            var ch = crMap.channelMapping;
            if (ch) {
                var redData = this.getCol(dataFrame, ch.redColumn);
                var greenData = this.getCol(dataFrame, ch.greenColumn);
                var blueData = this.getCol(dataFrame, ch.blueColumn);
                var rgbData = this.getCol(dataFrame, ch.rgbColumn, true);
                this._selectionColor = vp.color.getColorFromName("yellow");
            }
            var sizeData = this.getCol(dataFrame, szMap.colName);
            var colorData = this.getCol(dataFrame, crMap.colName);
            var imageIndexData = this.getCol(dataFrame, imMap.colName);
            var textData = this.getCol(dataFrame, txMap.colName, true);
            var facetData = this.getCol(dataFrame, faMap.colName);
            //---- todo: remove this ----
            var staggerOffsetData = null; // this.getCol(dataFrame, "staggerOffset");
            var selectData = this.getCol(dataFrame, beachParty.selectedName);
            var filterData = this.getCol(dataFrame, beachParty.filteredName);
            var randomXData = this.getCol(dataFrame, beachParty.randomXName);
            var randomYData = this.getCol(dataFrame, beachParty.randomYName);
            //---- try treating primary key vector just like the numeric mapping data ----
            var primaryKeyData = this.getCol(dataFrame, beachParty.primaryKeyName);
            /// support for 2-stage filter/layout:
            ///     layoutFilter - when entry is true, the record should NOT be included in the chart layout
            ///     enterExitFilter - when entry is true, the record WILL be included in the ENTER/EXIT effect
            var nv = new beachParty.NamedVectors(length, xData, yData, zData, colorData, imageIndexData, staggerOffsetData, sizeData, textData, facetData, selectData, filterData, filterData, primaryKeyData, randomXData, randomYData, redData, greenData, blueData, auxData, rgbData);
            if (this._isFirstFilteredStage && this._isForwardFilter) {
                nv.layoutFilter = this._prevFilter;
            }
            return nv;
        };
        chartBuilderClass.prototype.hideAxes = function (value) {
            if (arguments.length == 0) {
                return this._hideAxes;
            }
            this._hideAxes = value;
            this.onDataChanged("hideAxes");
        };
        chartBuilderClass.prototype.isAggChart = function (value) {
            if (arguments.length == 0) {
                return this._isAggChart;
            }
            this._isAggChart = value;
            this.onDataChanged("isAggChart");
        };
        chartBuilderClass.prototype.isXAxisClickable = function (value) {
            if (arguments.length == 0) {
                return this._isXAxisClickable;
            }
            this._isXAxisClickable = value;
            this.onDataChanged("isXAxisClickable");
        };
        chartBuilderClass.prototype.getFacetHelper = function () {
            return this._facetHelper;
        };
        chartBuilderClass.prototype.getTransformMgr = function () {
            return this._transformerMgr;
        };
        chartBuilderClass.prototype.isYAxisClickable = function (value) {
            if (arguments.length == 0) {
                return this._isYAxisClickable;
            }
            this._isYAxisClickable = value;
            this.onDataChanged("isYAxisClickable");
        };
        chartBuilderClass.prototype.updatePlotBounds = function (left, top, width, height, usingFacets, resizeElements) {
            var canvas3dElem = this._glCanvasElem;
            //var canvas2dElem = this._chart.getCanvas2d();
            //---- adjust so we don't overwrite the axes/box of chart ----
            //left++;
            //top++;
            //width = Math.ceil(Math.max(0, width - 2));
            //height = Math.ceil(Math.max(0, height - 3));
            left = Math.round(left);
            top = Math.round(top);
            width = Math.ceil(Math.max(0, width));
            height = Math.ceil(Math.max(0, height));
            if (resizeElements) {
                //---- try to avoid changing size of canvas since it clears the canvas and causes a blinking effect ----
                //---- move the actual resizing to just before we draw to see if that helps to hide the blinking ----
                var rcCurrent = this._rcPlotFinal;
                var canvasW = vp.select(canvas3dElem);
                //var rc = canvasW.getBounds();
                if (rcCurrent.left != left || rcCurrent.top != top) {
                    //---- moving the canvas does not blank it ----
                    canvasW
                        .css("left", left + "px")
                        .css("top", top + "px");
                }
                if (rcCurrent.width != width || rcCurrent.height != height) {
                    vp.utils.debug("SETTING pending size: width=" + width + ", height=" + height);
                    this._pendingCanvasResize = { width: width, height: height };
                }
                this._rcPlotFinal = vp.geom.createRect(left, top, width, height);
            }
            this._rcPlotEst = vp.geom.createRect(left, top, width, height);
            this.onDataChanged("plotBounds");
            this.updateTransformerCamera();
        };
        chartBuilderClass.prototype.getMaxItemsInView = function (nv) {
            var maxItems = 0;
            //---- does client want to override max count? ----
            if (this._chart.isMaxItemCountEnabled()) {
                maxItems = this._chart.maxItemCount();
            }
            else {
                maxItems = beachParty.cbUtils.getDataLength(nv, true);
            }
            return maxItems;
        };
        chartBuilderClass.prototype.clearMinMaxBreaks = function (md) {
            md.minBreakFacet = undefined;
            md.maxBreakFacet = undefined;
        };
        chartBuilderClass.prototype.buildColorScale = function (nv, md) {
            var scale = null;
            //---- default (non mapped) ----
            this._maxColors = (this._selectionExists) ? 2 : 1;
            if (nv && nv.colorIndex) {
                var chart = this._chart;
                var cm = chart.colorMapping();
                var colType = nv.colorIndex.colType;
                var colorCount = this._primaryColorCount;
                //---- unselected colors start at index=0 ----
                //---- selected colors have been moved to offset 14+ in the palette ----
                var maxIndex = colorCount - 1;
                var catKeys = null;
                if (colType == "string" || cm.forceCategory) {
                    //---- create CATEGORY scale ----
                    //---- use currently bound values (based on current/previous filter settings) ----
                    catKeys = cm.boundColInfo.stats.sortedKeys;
                    if (!catKeys) {
                        //---- fallback to current filter settings ----
                        catKeys = beachParty.cbUtils.getFilteredSortedKeys(nv.colorIndex, nv.layoutFilter);
                    }
                }
                if (!cm.isContinuous) {
                    //---- range mapping will be DISCRETE ----
                    if (catKeys) {
                        //---- if keyCount is smaller than color palette, only map to keyCount entries ----
                        var keyCount = catKeys.length;
                        if (keyCount < colorCount) {
                            colorCount = keyCount;
                        }
                        else if (keyCount > colorCount) {
                        }
                    }
                    maxIndex = colorCount - 1;
                    //---- add this so that when we take floor(scaledValue), we correctly map to stepped palette entries ----
                    maxIndex += .999999; // adding another "9" here breaks scaling on WebGL (gets interpreted as a "1")
                }
                this._maxColors = (this._selectionExists) ? (2 * colorCount) : colorCount;
                if (catKeys) {
                    var palette = (cm.isContinuous) ? [0, colorCount - 1] : vp.data.range(0, colorCount - 1);
                    var palette = (false) ? [0, colorCount - 1] : vp.data.range(0, colorCount - 1);
                    //---- CATEGORY scale ----
                    scale = vp.scales.createCategoryKey()
                        .categoryKeys(catKeys)
                        .isPaletteDiscrete(!cm.isContinuous)
                        .palette(palette);
                    if (cm.isCycling) {
                        scale.isRangeClipping(false); // allow values to cycle thru available colors
                    }
                }
                else {
                    var minVal = 0;
                    var maxVal = 0;
                    if (cm.breaks && cm.breaks.length && nv.colorIndex.colType != "string") {
                        //---- get min/max from breaks ----
                        var len = cm.breaks.length;
                        minVal = cm.breaks[0];
                        maxVal = cm.breaks[len - 1];
                    }
                    else {
                        //---- get min/max from data ----
                        var result = beachParty.cbUtils.getMinMax(nv.colorIndex, nv.layoutFilter, md);
                        minVal = result.min;
                        maxVal = result.max;
                    }
                    if (cm.spread == beachParty.MappingSpread.low) {
                        //---- SPREAD LOW scale  ----
                        scale = vp.scales.createLowBias()
                            .domainMin(minVal)
                            .domainMax(maxVal)
                            .range(0, maxIndex);
                    }
                    else if (cm.spread == beachParty.MappingSpread.high) {
                        //---- SPREAD HIGH scale ----
                        scale = vp.scales.createHighBias()
                            .domainMin(minVal)
                            .domainMax(maxVal)
                            .range(0, maxIndex);
                    }
                    else {
                        //---- normal LINEAR scale ----
                        scale = vp.scales.createLinear()
                            .domainMin(minVal)
                            .domainMax(maxVal)
                            .range(0, maxIndex);
                    }
                }
            }
            if (scale && colType) {
                beachParty.cbUtils.buildFormatter(md, scale, colType);
            }
            return scale;
        };
        chartBuilderClass.prototype.refreshClientSize = function () {
            var rc = vp.select(this._parentElem).getBounds();
            this._clientWidth = rc.width;
            this._clientHeight = rc.height;
        };
        chartBuilderClass.prototype.buildChartFrameHelper = function () {
            var _this = this;
            if (!this._chartFrameHelper) {
                var chartFrameGroup = this._svgChartFrameGroup;
                this._chartFrameHelper = new beachParty.chartFrameHelperClass(chartFrameGroup, this, this._dataMgr, this._transformer, this._chart.blankValueStr());
                this._chartFrameHelper.onTickBoxClick.attach(this, function (e) {
                    var selectKey = e.axisName + "." + e.boxLabel;
                    _this._chart.searchEx([e.searchParams], selectKey);
                });
            }
        };
        /// Called as dynamic method when the colName for "chart._attrFacet" has changed.
        chartBuilderClass.prototype.onFacetChanged = function () {
            var fm = this._chart.facetMapping();
            var colName = fm.colName;
            var facetCount = fm.binCount;
            var isUsingFacets = (colName && colName.length);
            if (isUsingFacets) {
                //var rcx = this._transformer._rcxWorld;
                this._facetHelper = new beachParty.facetHelperClass(colName, facetCount, fm.binCount, fm.facetBounds, this._transformer, fm);
            }
            else {
                this._facetHelper = null;
            }
        };
        chartBuilderClass.prototype.onLayoutNameChanged = function () {
            var cs = this._currentChartSpecs;
            var cs2 = this._chart.getChartSpecs();
            if (!cs || !cs2 || !cs.isEqual(cs2)) {
                this.applyNewChartSpecs(cs2);
                this._currentChartSpecs = new ChartSpecs(cs2.getChartType(), cs2.layoutType());
            }
        };
        chartBuilderClass.prototype.applyNewChartSpecs = function (cs) {
            var chartType = cs.getChartType();
            var layoutType = cs.layoutType();
            var usePartyGen = false;
            var layout;
            if (chartType == beachParty.ChartType.Spiral) {
                //---- SPIRAL ----
                if (usePartyGen) {
                    layout = new beachParty.partyGenPlotClass(this._chart, "FlatCircle");
                }
                else {
                    layout = new beachParty.flatCircle(this._chart);
                }
            }
            else if (chartType == beachParty.ChartType.Random) {
                //---- RANCOM ----
                if (usePartyGen) {
                    layout = new beachParty.partyGenPlotClass(this._chart, "FlatRandom");
                }
                else {
                    layout = new beachParty.flatRandom(this._chart);
                }
            }
            else if (chartType == beachParty.ChartType.Poisson) {
                //---- POISSON ----
                layout = new beachParty.partyGenPlotClass(this._chart, "FlatPoisson");
            }
            else if (chartType == beachParty.ChartType.Grid) {
                //---- GRID ----
                if (usePartyGen) {
                    layout = new beachParty.partyGenPlotClass(this._chart, "FlatGrid");
                }
                else {
                    if (layoutType == beachParty.LayoutType.Squarify) {
                        //---- SQUARIFY ----
                        layout = new beachParty.partyGenPlotClass(this._chart, "FlatSquarify");
                    }
                    else {
                        layout = new beachParty.flatGrid(this._chart);
                    }
                }
            }
            else if (chartType == beachParty.ChartType.Scatter) {
                //---- SCATTER ----
                layout = new beachParty.scatterPlotClass(this._chart);
            }
            else if (chartType == beachParty.ChartType.Column) {
                //---- COLUMN ----
                if (usePartyGen) {
                    layout = new beachParty.partyGenPlotClass(this._chart, "ColumnGrid");
                }
                else {
                    if (layoutType == beachParty.LayoutType.Strips) {
                        //---- COLUMN STRIP ----
                        layout = new beachParty.columnSumClass(this._chart);
                    }
                    else if (layoutType == beachParty.LayoutType.Squarify) {
                        //---- COLUMN SQUARIFY ----
                        layout = new beachParty.columnSquarifyClass(this._chart);
                    }
                    else if (layoutType == beachParty.LayoutType.Percent) {
                        //---- COLUMN PERCENT ----
                        layout = new beachParty.columnPercentClass(this._chart);
                    }
                    else {
                        //---- COLUMN ----
                        layout = new beachParty.columnCountClass(this._chart);
                    }
                }
            }
            else if (chartType == beachParty.ChartType.Density) {
                //---- DENSITY ----
                layout = new beachParty.densityGrid(this._chart);
            }
            else if (chartType == beachParty.ChartType.Stacks) {
                //---- STACKS ----
                layout = new beachParty.stacksBinClass(this._chart);
            }
            else if (chartType == beachParty.ChartType.Scatter3D) {
                //---- SCATTER 3D ----
                layout = new beachParty.scatterPlot3dClass(this._chart);
            }
            else if (chartType == beachParty.ChartType.Line) {
                //---- LINE ----
                layout = new beachParty.linePlotClass(this._chart, false, false);
            }
            else if (chartType == beachParty.ChartType.Links) {
                //---- LINKS ----
                layout = new beachParty.linePlotClass(this._chart, true, true);
            }
            else if (chartType == beachParty.ChartType.Radial) {
                //---- RADIAL ----
                layout = new beachParty.radialClass(this._chart);
            }
            else if (chartType == beachParty.ChartType.Xband) {
                //---- X BAND ----
                layout = new beachParty.xBandClass(this._chart);
            }
            else if (chartType == beachParty.ChartType.Yband) {
                //---- Y BAND ----
                layout = new beachParty.yBandClass(this._chart);
            }
            else if (chartType == beachParty.ChartType.Bar) {
                if (usePartyGen) {
                    layout = new beachParty.partyGenPlotClass(this._chart, "BarGrid");
                }
                else {
                    //---- these SUM options are not yet supported for the Bar chart ----
                    //if (layoutType == LayoutType.Strips)
                    //{
                    //    layout = new barSumClass(this._chart);
                    //}
                    //else if (layoutType == LayoutType.Squarify)
                    //{
                    //    layout = new barSquarifyClass(this._chart);
                    //}
                    //else if (layoutType == LayoutType.Percent)
                    //{
                    //    layout = new barPercentClass(this._chart);
                    //}
                    //else
                    {
                        layout = new beachParty.barCountClass(this._chart);
                    }
                }
            }
            else if (chartType == beachParty.ChartType.Violin) {
                //---- VIOLIN ----
                layout = new beachParty.violinClass(this._chart);
            }
            else if (chartType == beachParty.ChartType.Custom) {
                //---- CUSTOM ----
                layout = new beachParty.fullCustomClass(this._chart);
            }
            else {
                vp.utils.error("Unrecognized chart type=" + beachParty.ChartType[+chartType]);
            }
            this._layout = layout;
        };
        chartBuilderClass.prototype.getLayout = function () {
            return this._layout;
        };
        chartBuilderClass.prototype.getChart = function () {
            return this._chart;
        };
        chartBuilderClass.prototype.getClientWidth = function () {
            return this._clientWidth;
        };
        chartBuilderClass.prototype.getClientHeight = function () {
            return this._clientHeight;
        };
        chartBuilderClass.prototype.buildDefaultScales = function (nv, rcxWorld, filteredRecordCount, facetCount) {
            var chart = this._chart;
            //---- camera is positive Z, object are negative Z ----
            var xScale = beachParty.cbUtils.makeRangeScale(nv.x, nv.layoutFilter, rcxWorld.left, rcxWorld.right, undefined, chart.xMapping());
            var yScale = beachParty.cbUtils.makeRangeScale(nv.y, nv.layoutFilter, rcxWorld.bottom, rcxWorld.top, undefined, chart.yMapping());
            var zMin = -2;
            var zMax = zMin + 4;
            var zScale = beachParty.cbUtils.makeRangeScale(nv.z, nv.layoutFilter, zMin, zMax, undefined, chart.zMapping());
            //---- build SIZE scale ----
            var sm = chart.sizeMapping();
            var clientSizePalette = sm.sizePalette;
            var breaks = sm.breaks;
            var szPalette = vp.utils.copyArray(clientSizePalette);
            var sizeScale = beachParty.cbUtils.makePaletteScale(nv.size, nv.layoutFilter, szPalette, null, breaks, chart.sizeMapping());
            //---- build IMAGE INDEX scale ----
            var im = chart.shapeMapping();
            var imagePalette = im.imagePalette;
            var breaks = im.breaks;
            var imgIindexPalette = (imagePalette) ? vp.data.range(0, imagePalette.length - 1) : null;
            var imageScale = beachParty.cbUtils.makePaletteScale(nv.imageIndex, nv.layoutFilter, imgIindexPalette, null, breaks, chart.shapeMapping());
            imageScale.isPaletteDiscrete(true);
            //---- build COLOR scale ----
            var cm = chart.colorMapping();
            var colorIndexScale = this.buildColorScale(nv, cm);
            if (cm.channelMapping) {
                var redScale = beachParty.cbUtils.makeRangeScale(nv.red, nv.layoutFilter, 0, 255, 0, cm);
                var greenScale = beachParty.cbUtils.makeRangeScale(nv.green, nv.layoutFilter, 0, 255, 0, cm);
                var blueScale = beachParty.cbUtils.makeRangeScale(nv.blue, nv.layoutFilter, 0, 255, 0, cm);
            }
            return {
                x: xScale, y: yScale, z: zScale, size: sizeScale, colorIndex: colorIndexScale,
                imageIndex: imageScale, red: redScale, green: greenScale, blue: blueScale,
            };
        };
        chartBuilderClass.prototype.prepassAndFrameBuild = function () {
            this.onLayoutNameChanged();
            var userSizeFactor = this._chart.sizeFactor();
            var usingFacets = (this._facetHelper != null);
            var nv = this.buildNamedVectors(this._dataFrame);
            this._nv = nv;
            //---- for consistent results, always do PREPASS calculations with no chartFrame ----
            this.updatePlotBounds(0, 0, this._clientWidth, this._clientHeight, usingFacets, false);
            //---- build PREPASS scales ----
            var rcxWorld = this.calcRanges(nv, true); // false);
            var recordCount = this.getDataLength();
            var filteredRecordCount = this.getMaxItemsInView(nv);
            var nvBuckets = null;
            var facetCount = 0;
            var facetBinResults = null;
            var chart = this._chart;
            this._currentChartClass = chart.getUiChartName();
            //---- clear facet min/max breaks from last build ----
            var xm = chart.xMapping();
            this.clearMinMaxBreaks(xm);
            var ym = chart.yMapping();
            this.clearMinMaxBreaks(ym);
            var zm = chart.zMapping();
            this.clearMinMaxBreaks(zm);
            if (this._facetHelper) {
                var facetHelper = this._facetHelper;
                var requestedFacets = facetHelper._requestedFacets;
                var maxFacets = facetHelper._maxCategoryFacets;
                var sortOptions = new beachParty.binSortOptionsClass();
                var fm = chart.facetMapping();
                sortOptions.sortDirection = fm.binSorting;
                sortOptions.sortByAggregateType = "count";
                var useNiceNumbers = fm.useNiceNumbers;
                facetBinResults = beachParty.binHelper.createBins(nv, "facet", requestedFacets, maxFacets, fm.forceCategory, true, true, sortOptions, null, useNiceNumbers, fm);
                nvBuckets = beachParty.binHelper.splitBinsIntoNamedVectors(facetBinResults, nv);
                facetHelper.binResult(facetBinResults);
                facetCount = facetHelper.facetCount();
            }
            //---- build ESTIMATED scales, based on estimated rcxWorld (with no chart frame) ----
            var scales = this._layout.buildScales(nv, rcxWorld, filteredRecordCount, facetCount);
            //---- build PREPASS drawContext ----
            var dc = new beachParty.DrawContext(rcxWorld, this._facetHelper, nv, scales, recordCount, filteredRecordCount, /*this._attrInfos,*/ userSizeFactor, this._prevChartClass, this._currentChartClass, userSizeFactor, this._transformer, this._chart);
            this._prepassDc = dc;
            //---- let layout do pre-pass over all facets ----
            var maxItems = this._layout.computeFacetStats(dc, nvBuckets);
            this._maxItems = maxItems;
            //---- let chart make PREPASS scale adjustments ----
            this._layout.adjustScales(dc);
            //---- relay maxItems to appMgr, so he can send to client, if subscribed & changed ----
            //this._chart.getAppMgr().setMaxItemCount(maxItems);
            this.onDataChanged("maxItems");
            //---- build the chart frame & axes ----
            var rcPlot = this.buildChartFrame();
            //---- change bounds of gl canvas to "rcPlot" (these bounds used in calcRanges()) ----
            this.updatePlotBounds(rcPlot.left, rcPlot.top, rcPlot.width, rcPlot.height, usingFacets, true);
            //---- build FINAL scales ----
            var rcxWorld = this.calcRanges(nv, true);
            var scales = this._layout.buildScales(nv, rcxWorld, filteredRecordCount, facetCount);
            //---- build FINAL drawContext ----
            var dc = new beachParty.DrawContext(rcxWorld, this._facetHelper, nv, scales, recordCount, filteredRecordCount, /*this._attrInfos,*/ userSizeFactor, this._prevChartClass, this._currentChartClass, userSizeFactor, this._transformer, this._chart);
            //---- let chart make FINAL scale adjustments ----
            this._layout.adjustScales(dc);
            if (usingFacets) {
                this.buildFacetChartFrames(dc);
            }
            return { dc: dc, facetCount: facetCount, nvBuckets: nvBuckets, facetBinResults: facetBinResults };
        };
        chartBuilderClass.prototype.calcRanges = function (nv, facetAdjust) {
            var rcxWorld = beachParty.cbUtils.cloneMap(this._transformer.getWorldBounds());
            if (facetAdjust && this._facetHelper) {
                var fm = this._chart.facetMapping();
                this._facetHelper.setBinCountFromData(this._dataFrame, nv, nv.facet, fm);
                ////---- adjust for yAxis/xAxis ----
                //var yAxisWidthPx = this._chartFrameHelper.getYAxisWidth();
                //var xAxisHeightPx = this._chartFrameHelper.getXAxisHeight();
                //var yAxisWidth = this._transformer.screenSizeXToWorld(yAxisWidthPx);
                //var xAxisHeight = this._transformer.screenSizeYToWorld(xAxisHeightPx);
                var left = rcxWorld.left; // + yAxisWidth;
                var bottom = rcxWorld.bottom; // + xAxisHeight;
                var facetLayout = this._facetHelper.buildFacetLayout(left, bottom, rcxWorld.right, rcxWorld.top);
                //---- adjust rcxWorld so that we scale to fit into a single facet ----
                var rc0 = facetLayout.facetBounds[0];
                rcxWorld.left = rc0.x;
                rcxWorld.right = rc0.x + rc0.width;
                rcxWorld.top = rc0.y + rc0.height;
                rcxWorld.bottom = rc0.y; // - rc0.height;           // flipped axis
            }
            //---- add width, height, depth ----
            rcxWorld.width = rcxWorld.right - rcxWorld.left;
            rcxWorld.height = rcxWorld.top - rcxWorld.bottom;
            rcxWorld.depth = rcxWorld.front - rcxWorld.back;
            return rcxWorld;
        };
        chartBuilderClass.prototype.buildChartFrame = function () {
            var cfd = this._chart.chartFrameData();
            var usingFacets = (this._facetHelper != null);
            var hideAxes = (this._hideAxes || !cfd.isVisible);
            var dc = this._prepassDc;
            var facetLayoutInPixels = this.getFacetLayoutsInPixels();
            var rcPlot = this._chartFrameHelper.build(this._clientWidth, this._clientHeight, hideAxes, usingFacets, cfd, dc, facetLayoutInPixels, this._isXAxisClickable, this._isYAxisClickable);
            return rcPlot;
        };
        chartBuilderClass.prototype.worldBoundsToSvg = function (bounds) {
            //---- translate to 3D canvas coordiates ----
            var rc = this._transformer.worldBoundsToScreen(bounds);
            //---- offset rc so that it is relative to the SVG doc ----
            var rcp = this._rcPlotFinal; // Est;
            rc = vp.geom.createRect(rcp.left + rc.left, rcp.top + rc.top, rc.width, rc.height);
            return rc;
        };
        chartBuilderClass.prototype.getFacetLayoutsInPixels = function () {
            var fl = null;
            var facetHelper = this._facetHelper;
            if (facetHelper && facetHelper._layout) {
                var bins = facetHelper._binResult.bins;
                fl = [];
                for (var b = 0; b < bins.length; b++) {
                    var bin = bins[b];
                    var isFirst = (b == 0);
                    var layout = new beachParty.FacetLayoutInfo();
                    layout.facelLabel = bin.name;
                    layout.facetIndex = b;
                    layout.plotBounds = this.worldBoundsToSvg(facetHelper._layout.facetBounds[b]);
                    layout.labelBounds = this.worldBoundsToSvg(facetHelper._layout.labelBounds[b]);
                    var sp = new beachParty.SearchParams();
                    sp.colName = facetHelper._colName;
                    if (bin instanceof beachParty.BinInfoNum) {
                        var numBin = bin;
                        sp.minValue = numBin.min;
                        sp.maxValue = numBin.max;
                        sp.searchType = (isFirst) ? beachParty.TextSearchType.betweenInclusive : beachParty.TextSearchType.gtrValueAndLeqValue2;
                    }
                    else {
                        var value = (bin.isOther) ? bin.otherKeys : bin.name;
                        sp.minValue = value;
                        sp.maxValue = value;
                        sp.searchType = beachParty.TextSearchType.exactMatch;
                    }
                    layout.searchParams = sp;
                    fl.push(layout);
                }
            }
            return fl;
        };
        chartBuilderClass.prototype.buildFacetChartFrames = function (dc) {
            var cfd = this._chart.chartFrameData();
            var hideAxes = (this._hideAxes || !cfd.isVisible);
            //var dc = this._prepassDc;
            var facetLayoutInPixels = this.getFacetLayoutsInPixels();
            this._chartFrameHelper.buildFacetFrames(this._clientWidth, this._clientHeight, cfd, dc, hideAxes, facetLayoutInPixels, this._isXAxisClickable, this._isYAxisClickable);
        };
        chartBuilderClass.prototype.getDataLength = function (applyFilter) {
            var length = 0;
            if (this._dataFrame) {
                if (applyFilter) {
                    length = this._dataMgr.getFilteredInCount();
                }
                else {
                    length = this._dataFrame.getRecordCount();
                }
            }
            return length;
        };
        chartBuilderClass.prototype.cancelRequestedDraw = function () {
            this.cancelBuildTimer();
        };
        //enableDrawOnTransform(value: boolean)
        //{
        //    var dp = this._shapeEng.getParams();
        //    dp.drawOnTransformChange = value;
        //    this._shapeEng.setParams(dp);
        //}
        chartBuilderClass.prototype.buildChart = function () {
            this.cancelBuildTimer();
            var startBuild = vp.utils.now();
            var cd = new beachParty.CycleDesc();
            cd.isSelectionChangeOnly = this._isSelectionChangeOnly;
            this.onCycleStart.trigger(cd);
            var chart = this._chart;
            this._dataFrame = chart.getDataFrame();
            if (chart.getRecordCount() > 0) {
                var shapeEng = this._shapeEng;
                //this.rebuildCamera();       // based on new area to draw into???
                //---- prevent accidental drawing before we are ready (as our layouts change the current transform) ----
                //this.enableDrawOnTransform(false);
                this._selectionExists = (this._dataMgr.getSelectedCount() > 0);
                //---- build color palette now, so we have _primaryColorCount for further operations ----
                var shapeColor = this._chart.shapeColor();
                var colorPalette = this.getColorPalette();
                this.buildShaderColorPalette(shapeColor, colorPalette);
                //this._primaryColorCount = this._finalColorPalette.length;
                this.buildChartCore();
                this.applyPendingResizeIfNeeded();
                this.setUpShapeEngParams();
                this._layoutTime = vp.utils.now() - startBuild;
                shapeEng.drawShapes(this._shapes);
                this._drawCount++;
                //this.enableDrawOnTransform(true);
                this._prevChartClass = this._currentChartClass;
                this._buildNeededReason = null;
            }
            else {
                //---- release memory when no file is open ----
                this._shapeEng.clearCanvas();
                this._shapeEng.resetBuffers();
                if (this._chartFrameHelper) {
                    //---- remove chartFrameHelper from parent and release ----
                    vp.select(this._chartFrameHelper.getRoot()).remove();
                    this._chartFrameHelper = null;
                    this.buildChartFrameHelper();
                }
                this._nv = null;
                this._prepassDc = null;
                this._shapes = [];
                this._prevFilter = null;
                var cs2 = this._chart.getChartSpecs();
                this.applyNewChartSpecs(cs2); // force old chart (and its memory) to be released 
                this._layoutTime = vp.utils.now() - startBuild;
            }
            this._buildChartElapsed = vp.utils.now() - startBuild;
        };
        chartBuilderClass.prototype.applyPendingResizeIfNeeded = function () {
            if (this._pendingCanvasResize) {
                vp.utils.debug("RESIZING glCanvas to pending size");
                vp.select(this._glCanvasElem)
                    .attr("width", this._pendingCanvasResize.width)
                    .attr("height", this._pendingCanvasResize.height);
                this._pendingCanvasResize = null;
            }
        };
        chartBuilderClass.prototype.updateTransformerCamera = function () {
            //var shapeEng = this._shapeEng;
            //if (updateParamSize)
            //{
            //    var dp = shapeEng.getParams();
            //    //dp.frameRect = vp.geom.createRect(0, 0, this._canvasWidth, this._canvasHeight);
            //    dp.frameRect = this._rcPlotFinal;
            //    shapeEng.setParams(dp);
            //}
            //shapeEng.rebuildCamera();
            var rcFrame = this._rcPlotEst;
            this._transformer.updateCamera(this._transformer._isOrthoCamera, rcFrame.width, rcFrame.height);
        };
        chartBuilderClass.prototype.buildShaderColorPalette = function (shapeColor, colorPalette) {
            var colorNames = (colorPalette) ? (colorPalette) : [shapeColor];
            this._finalColorPalette = this.adjustColorPaletteForSelection(colorNames);
        };
        chartBuilderClass.prototype.adjustColorPaletteForSelection = function (colorNames) {
            //var dp = this._drawParams;
            var selectionExists = this._selectionExists;
            var triplets = [];
            var count = colorNames.length;
            this._primaryColorCount = count;
            //---- convert color names to normalized triplets (RGB) ----
            for (var i = 0; i < count; i++) {
                var crName = beachParty.cbUtils.getBeachPartyColor(colorNames[i]);
                var rgb = vp.color.getColorFromString(crName);
                triplets.push(rgb);
            }
            //---- apply ColorParams to both unselected (first COUNT) color and selected (next COUNT) ----
            var newPalette = [];
            var sParams = this._chart.getSelectionParams();
            var up = sParams.unselectedParams;
            var sp = sParams.selectedParams;
            up.rgb = vp.color.getColorFromString(up.color);
            sp.rgb = vp.color.getColorFromString(sp.color);
            for (var i = 0; i < count; i++) {
                newPalette[i] = this.applyColorParams(triplets[i], up, selectionExists);
                if (selectionExists && i < 14) {
                    newPalette[i + count] = this.applyColorParams(triplets[i], sp, selectionExists);
                }
            }
            this._maxColors = newPalette.length;
            return newPalette;
        };
        chartBuilderClass.prototype.applyColorParams = function (rgb, cp, selectionExists) {
            var value = rgb;
            if (selectionExists) {
                if (cp.colorEffect == beachParty.ColorEffect.setColor) {
                    value = cp.rgb;
                }
                else if (cp.colorEffect == beachParty.ColorEffect.adjustHue) {
                    var hsl = vp.color.hslFromRgb(rgb);
                    hsl = hsl.adjustHue(cp.colorFactor);
                    value = hsl.toRgb();
                }
                else if (cp.colorEffect == beachParty.ColorEffect.adjustSaturation) {
                    var hsl = vp.color.hslFromRgb(rgb);
                    hsl = hsl.adjustSaturation(cp.colorFactor);
                    value = hsl.toRgb();
                }
                else if (cp.colorEffect == beachParty.ColorEffect.adjustValue) {
                    var hsl = vp.color.hslFromRgb(rgb);
                    hsl = hsl.adjustValue(cp.colorFactor);
                    value = hsl.toRgb();
                }
            }
            return value;
        };
        chartBuilderClass.prototype.getMostCentralRecord = function (rcArea, columnList) {
            var colValues = null;
            var primaryKey = null;
            ////---- try fastest point-test first ----
            //var cx = rcScreen.left + rcScreen.width / 2;
            //var cy = rcScreen.top + rcScreen.height;            //  / 2;
            //var mousePos = { x: cx, y: cy };
            //---- try the slower method ----
            var boxes = this._shapeEng.hitTestFromRect(rcArea, true, true);
            if (boxes && boxes.length) {
                var box = boxes[0];
                colValues = this._chart.getColumnValues(columnList, box.primaryKey);
                primaryKey = box.primaryKey;
            }
            return { primaryKey: primaryKey, colValues: colValues, };
        };
        chartBuilderClass.prototype.getChartFrameHelper = function () {
            return this._chartFrameHelper;
        };
        /**
         * Gets the location of the drawn shapes relative to the CHART'S #clientHolder element.
         * @param useDrawnHeight
         * @param screenRelative - if true, adjusts bounds to be screen relative.
         */
        chartBuilderClass.prototype.getPlotBounds = function (useDrawnHeight, screenRelative) {
            var rc = this._rcPlotFinal;
            if (useDrawnHeight) {
                if (this._facetHelper) {
                    rc = vp.geom.createRect(rc.left, rc.top, rc.width, rc.height - 14);
                }
                else {
                    rc = vp.geom.createRect(rc.left, rc.top, rc.width, rc.height - 1);
                }
            }
            if (screenRelative) {
                var rcGl = vp.select(this._parentElem).getBounds();
                rc = vp.geom.createRect(rc.left + rcGl.left, rc.top + rcGl.top, rc.width, rc.height);
            }
            return rc;
        };
        chartBuilderClass.prototype.buildChartCore = function () {
            var chart = this._chart;
            vp.utils.debug("--- buildChart (chartBuilder): firstReason=" + this._buildNeededReason + ", usingPrimaryBuffers=" + this._shapeEng.isUsingPrimaryBuffers() + " ----");
            var result = this.prepassAndFrameBuild();
            this.onDataChanged("facetLayoutChanged");
            var dc = result.dc;
            var nvBuckets = result.nvBuckets;
            var facetHelper = this._facetHelper;
            var facetCount = result.facetCount; //   (facetHelper) ? facetHelper.facetCount() : 1;
            var facetBinResults = result.facetBinResults;
            this._shapes = [];
            var layoutStart = vp.utils.now();
            var drawBufferIndex = 0;
            if (this._facetHelper) {
                var facetResult = facetHelper.layout();
                //---- now, do the REGULAR PASS on all facets ----
                for (var i = 0; i < facetCount; i++) {
                    var nvBucket = nvBuckets[i];
                    var facetBounds = facetResult.facetBounds[i];
                    var facetOffset = { x: facetBounds.x - dc.x, y: facetBounds.y - dc.y };
                    //if (!this._chart.is3dGridVisible())
                    //{
                    //    //---- add a 2D border around the bounds ----
                    //    var rc = this.worldBoundsToSvg(facetBounds);
                    //    vp.select(this._svgChartGroup).append("rect")
                    //        .addClass("facetBorder")
                    //        .bounds(rc.left, rc.top, rc.width, rc.height);
                    //}
                    //---- update drawing context for this facet ----
                    var facetRecordCount = beachParty.cbUtils.getDataLength(nvBucket);
                    var facetFilteredRecordCount = beachParty.cbUtils.getDataLength(nvBucket, true);
                    dc.facetIndex = i;
                    dc.nvData = nvBucket;
                    dc.recordCount = facetRecordCount;
                    dc.filteredRecordCount = facetFilteredRecordCount;
                    dc.layoutFilterVector = (nvBucket.layoutFilter && nvBucket.layoutFilter.values) ? nvBucket.layoutFilter.values : null;
                    /// NOTE: we do NOT update the scales or the dc bounds - chart draws into first facet bounds and then system offsets x/y as needed afterwards. 
                    /// calcRanges() uses the FIRST facet bounds to set: dc.x, dc.y, dc.width, dc.height also.  
                    this.layoutChartOrFacet(dc, facetOffset, drawBufferIndex);
                    drawBufferIndex += dc.recordCount;
                }
            }
            else {
                //---- REGULAR PASS (no facets) ----
                this.layoutChartOrFacet(dc, { x: 0, y: 0 }, drawBufferIndex);
                var recordCount = this._dataFrame.getRecordCount();
            }
        };
        chartBuilderClass.prototype.addToBuildPerf = function (name, start) {
            var now = vp.utils.now();
            var elapsed = now - start;
            this._buildPerf[name] += elapsed;
            return now;
        };
        chartBuilderClass.prototype.processRecord = function (fri, primaryKey, shape, facetOffset, nv, dc, drawBufferIndex) {
            if (isNaN(shape.x)) {
                shape.x = 0;
            }
            if (isNaN(shape.y)) {
                shape.y = 0;
            }
            if (isNaN(shape.z)) {
                shape.z = 0;
            }
            if (isNaN(shape.width)) {
                shape.width = 0;
            }
            if (isNaN(shape.height)) {
                shape.height = 0;
            }
            if (isNaN(shape.depth)) {
                shape.depth = 0;
            }
            shape.x += facetOffset.x;
            shape.y += facetOffset.y;
            //----  modify color of this shape for selection being active ----
            if (this._selectionExists && nv.selected) {
                if (this._chart.colorMapping().channelMapping != null) {
                    //---- coloring shapes using DIRECT CHANNELS ----
                    if (nv.selected.values[fri]) {
                        var cr = this._selectionColor;
                        shape.redChannel = cr[0];
                        shape.greenChannel = cr[1];
                        shape.blueChannel = cr[2];
                    }
                    else {
                        //---- unselected: use gray value ----
                        var cr = [100, 100, 100];
                        shape.redChannel = cr[0];
                        shape.greenChannel = cr[1];
                        shape.blueChannel = cr[2];
                    }
                }
                else {
                    //---- coloring shapes using COLOR PALETTE ----
                    if (nv.selected.values[fri]) {
                        shape.colorIndex += this._primaryColorCount; // color this with parallel selected color
                    }
                }
            }
            var yOffScreen = -10;
            if (this._isFirstFilteredStage && !this._isForwardFilter) {
                //---- process PREVIOUS filter mapping ----
                //---- WARNING: this "drawBufferIndex" index can cause problems if we change order at same time as filtering! ----
                if (this._prevFilter && this._prevFilter.values[drawBufferIndex]) {
                    //---- move to bottom of screen ----
                    shape.y = yOffScreen;
                    shape.opacity = 0;
                }
            }
            else {
                //---- process CURRENT filter mapping ----
                if (nv.enterExitFilter && nv.enterExitFilter.values[fri]) {
                    //---- move to bottom of screen ----
                    shape.y = yOffScreen;
                    shape.opacity = 0;
                }
                else {
                }
            }
        };
        chartBuilderClass.prototype.addDefaultLayoutResults = function (shape, fri, dc, nv, drawBufferIndex, primaryKey) {
            shape.primaryKey = primaryKey;
            //vp.utils.debug("addDefaultLayoutResults: shape[" + drawBufferIndex + "].primaryKey=" + primaryKey);
            shape.x = 0;
            shape.y = 0;
            shape.z = 0;
            shape.width = 1;
            shape.height = 1;
            shape.depth = 1 / 8;
            shape.colorIndex = 0;
            shape.imageIndex = 0;
            shape.opacity = 1;
            shape.staggerOffset = 0;
            shape.theta = 0;
            shape.redChannel = 0;
            shape.greenChannel = 0;
            shape.blueChannel = 0;
            this.setStaggerOffset(shape, fri, dc);
            if (this._chart.colorMapping().channelMapping != null) {
                var scales = dc.scales;
                if (nv.rgb) {
                    var colorStr = nv.rgb[drawBufferIndex];
                    var cr = vp.color.getColorFromString(colorStr);
                    if (!cr) {
                        //---- when color is missing, default to white ----
                        cr = [255, 255, 255];
                    }
                    shape.redChannel = cr[0];
                    shape.greenChannel = cr[1];
                    shape.blueChannel = cr[2];
                }
                else {
                    shape.redChannel = beachParty.chartUtils.scaleColData(nv.red, drawBufferIndex, scales.red);
                    shape.greenChannel = beachParty.chartUtils.scaleColData(nv.green, drawBufferIndex, scales.green);
                    shape.blueChannel = beachParty.chartUtils.scaleColData(nv.blue, drawBufferIndex, scales.blue);
                }
            }
        };
        chartBuilderClass.prototype.setStaggerOffset = function (shape, facetRelativeIndex, dc) {
            var ad = this._animationData;
            if (ad.isStaggeringEnabled && !this._isSelectionChangeOnly && !this._isFirstFilteredStage) {
                //---- stagger each shape a bit ----
                //---- to stagger shapes in the sorted order, we use "facetRelativeIndex" ----
                var staggerPercent = facetRelativeIndex / dc.recordCount;
                //---- this is now done thru a new "ad.isStaggerForward" boolean, set by the caller ----
                ////---- if we are moving from a COLUMN to a SCATTER, we want to process the HIGH Y values first (values are sorted by Y), so we flip the order ----
                ////---- likewise, if we moving from a BAR to a SCATTER, we want to process the HIGH X values first (values are sorted by X) ----
                //var fromCol = (dc.fromChartType == "columnCountClass" || dc.fromChartType == "columnSumClass");
                //var fromBar = (dc.fromChartType == "barCountClass" || dc.fromChartType == "barSumClass");
                //var flipOrder = (fromCol && dc.toChartType == "scatterPlot") || (fromBar && dc.toChartType == "scatterPlot");
                var flipOrder = (!ad.isStaggerForward);
                //---- we also change flipOrder when usingPrimaryBuffers=true, since the value of "toPercent" will be flipped in the shader ----
                if (this._shapeEng.isUsingPrimaryBuffers()) {
                    flipOrder = !flipOrder;
                }
                if (flipOrder) {
                    staggerPercent = 1 - staggerPercent;
                }
                //---- map all staggerOffset values to between 0 and stagger time as percent of animation time) ----
                shape.staggerOffset = -(staggerPercent * (ad.maxStaggerTime / ad.animationDuration)); // -(maxStaggerTime * staggerPercent);
            }
        };
        chartBuilderClass.prototype.getChartRepro = function () {
            var repro = new beachParty.ChartRepro();
            repro.xFactor = 1; // TODO
            repro.yFactor = 1; // TODO
            repro.zFactor = 1; // TODO
            repro.layoutResults = this._shapes;
            return repro;
        };
        chartBuilderClass.prototype.layoutChartOrFacet = function (dc, facetOffset, drawBufferIndex) {
            //vp.utils.debug("layoutChartOrFacet: facetOffset.x=" + facetOffset.x + ", facetOffset.y=" + facetOffset.y);
            var start = vp.utils.now();
            this._layout.preLayoutLoop(dc);
            var nv = dc.nvData;
            start = this.addToBuildPerf("preLayout", start);
            var textDrawCount = 0;
            var layout = this._layout;
            /// NOTE: taking perf measurements each time thru the loop causes a HUGE slowdown in the layout process,
            /// so we now just take a sample at the end (without the layout, fill, process breakdown). 
            for (var fri = 0; fri < dc.recordCount; fri++) {
                //---- facet data indexes are relative to each facet, so use "fri" (not "bufferDrawIndex") ----
                var primaryKey = nv.primaryKey.getRawData(fri) + "";
                var shape = new beachParty.Shape();
                //---- add default values for this record's layout result ----
                this.addDefaultLayoutResults(shape, fri, dc, nv, drawBufferIndex, primaryKey);
                //---- call chart class to layout the shape for this record ----
                layout.layoutDataForRecord(fri, dc, shape);
                this._shapes.push(shape);
                //start = this.addToBuildPerf("layout", start);
                var rect = this.processRecord(fri, primaryKey, shape, facetOffset, nv, dc, drawBufferIndex);
                //start = this.addToBuildPerf("process", start);
                //if (this._tm.colName != null && textDrawCount < this._tm.maxShapes)
                //{
                //    //---- use "fri" (vs. "drawBufferIndex") so that we index nv.* correctly ----
                //    this.drawTextForItem(this._ctx, fri, rect, nv, dr, primaryKey);
                //    textDrawCount++;
                //}
                drawBufferIndex++;
            }
            //var debugMsg = "record drawn: " + i;
            //vp.select("#consoleDiv").text(debugMsg);
            //if (this._lm.colName)
            //{
            //    this.drawLinesBetweenShapes(dc, buffers, facetOffset);
            //}
            start = this.addToBuildPerf("layoutEx", start);
            //vp.utils.debug("finished layout of " + dc.recordCount + " shapes");
            //this.fillGridLinesBuffer(dc, facetOffset);
            this.addToBuildPerf("layoutPost", start);
        };
        return chartBuilderClass;
    }(beachParty.dataChangerClass));
    beachParty.chartBuilderClass = chartBuilderClass;
    var NamedScales = (function () {
        function NamedScales() {
        }
        return NamedScales;
    }());
    beachParty.NamedScales = NamedScales;
    var ChartSpecs = (function () {
        function ChartSpecs(chartType, layoutType) {
            this._chartType = chartType;
            this._layoutType = layoutType;
        }
        ChartSpecs.prototype.isEqual = function (cs) {
            var eq = (this._chartType == cs._chartType && this._layoutType == cs._layoutType);
            return eq;
        };
        ChartSpecs.prototype.getChartType = function () {
            return this._chartType;
        };
        ChartSpecs.prototype.layoutType = function (value) {
            if (arguments.length == 0) {
                return this._layoutType;
            }
            this._layoutType = value;
        };
        ChartSpecs.prototype.getChartName = function () {
            return beachParty.ChartType[this._chartType];
        };
        ChartSpecs.prototype.getLayoutName = function () {
            return beachParty.LayoutType[this._layoutType];
        };
        ChartSpecs.prototype.getUiChartName = function () {
            var uiName = beachParty.getUiName(this._chartType);
            return uiName;
        };
        return ChartSpecs;
    }());
    beachParty.ChartSpecs = ChartSpecs;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    facetHelper.ts - helps layout facets into a NxM grid.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var facetHelperClass = (function () {
        function facetHelperClass(colName, requestedFacets, maxCategoryFacets, customScreenBounds, transformer, fm) {
            this._colName = colName;
            this._requestedFacets = (requestedFacets > 0) ? requestedFacets : 99;
            this._maxCategoryFacets = (maxCategoryFacets > 0) ? maxCategoryFacets : 999;
            this._customScreenBounds = customScreenBounds;
            this._transformer = transformer;
            this._fm = fm;
        }
        facetHelperClass.prototype.setBinCountFromData = function (dataFrame, nv, dataVector, fm) {
            /// before we do the facet binning, we need to peek ahead and see the number of keys in all of the data ----
            var dataType = dataVector.colType;
            if (this._fm.breaks && this._fm.breaks.length) {
                facetCount = this._fm.breaks.length;
            }
            else if (dataType == "string") {
                var facetCount = Math.min(this._maxCategoryFacets, dataVector.keyInfo.keyCount);
                facetCount = Math.min(this._requestedFacets, facetCount);
            }
            else if (this._fm.forceCategory) {
                var forcedNumVector = dataFrame.getNumericVector(dataVector.colName, true);
                var facetCount = Math.min(this._maxCategoryFacets, forcedNumVector.keyInfo.keyCount);
                facetCount = Math.min(this._requestedFacets, facetCount);
            }
            else if (dataType == "date") {
                var results = beachParty.binHelperDate.createDateBins(nv, "facet", this._requestedFacets, null, null, null, null, fm);
                var facetCount = results.bins.length;
            }
            else {
                //---- number - cannot reply on this._requestedFacets - binHelperNum.createBins() might adjust (e.g., date) ----
                //var facetCount = this._requestedFacets;
                var results = beachParty.binHelperNum.createNumBins(nv, "facet", this._requestedFacets, null, null, null, null, fm);
                var facetCount = results.bins.length;
            }
            this._facetCount = facetCount;
        };
        facetHelperClass.prototype.facetCount = function () {
            return this._facetCount;
        };
        facetHelperClass.prototype.colName = function () {
            return this._colName;
        };
        facetHelperClass.prototype.layout = function () {
            return this._layout;
        };
        facetHelperClass.prototype.binResult = function (value) {
            if (arguments.length === 0) {
                return this._binResult;
            }
            this._binResult = value;
            this._facetCount = value.bins.length;
        };
        facetHelperClass.prototype.buildFacetLayout = function (xMin, yMin, xMax, yMax) {
            var customScreenBounds = this._customScreenBounds;
            var plotBounds = [];
            var labelBounds = [];
            var labelHeight = this._transformer.screenSizeYToWorld(16); // approx height of 16px font + padding
            if (customScreenBounds && customScreenBounds.length) {
                var rowCount = 1; // hard to say
                var colCount = 1; // hard to say
                for (var i = 0; i < customScreenBounds.length; i++) {
                    var rc = customScreenBounds[i];
                    var bounds = this._transformer.screenToWorldBounds(rc);
                    var cellWidth = bounds.width;
                    var cellHeight = bounds.height;
                    var x = bounds.left;
                    var y = bounds.bottom + .05; // why is this fudge needed?
                    //---- make sure all facets are the SAME width and height (critical for shape drawing algorithm and visual comparisons) ----
                    var plotY = y - labelHeight;
                    var plotHeight = Math.max(0, cellHeight - labelHeight);
                    var fb = { x: x, y: plotY, width: cellWidth, height: plotHeight };
                    var lb = { x: x, y: y, width: cellWidth, height: labelHeight };
                    plotBounds.push(fb);
                    labelBounds.push(lb);
                }
            }
            else {
                //---- 8px offsets ----
                var hm = this._transformer.screenSizeXToWorld(8);
                var vm = this._transformer.screenSizeYToWorld(8);
                //---- do NOT add these - they put axis borders in wrong positions relative to glCanvas & chartUX ----
                //---- add margins around overall space ----
                //yMax -= vm;    
                //yMin += vm;    
                //xMin += hm;
                //xMax -= hm;
                //---- adjust to align within client frame ----
                //yMin += vm;
                xMax -= 2 * hm;
                yMax -= 1 * vm;
                yMin += 1 * vm;
                var width = Math.max(0, xMax - xMin);
                var height = Math.max(0, Math.abs(yMax - yMin));
                var aspect = width / height;
                var count = this._facetCount;
                //---- hard code layout for 0-16 cells ----
                var cellsPerRowByCount = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 2, 5: 3, 6: 3, 7: 4, 8: 4, 9: 3, 10: 5, 11: 4, 12: 4, 13: 4, 14: 4, 15: 4, 16: 4 };
                var cellsPerRow = cellsPerRowByCount[count];
                if (cellsPerRow === undefined) {
                    cellsPerRow = Math.ceil(Math.sqrt(aspect * count));
                }
                var rowCount = Math.ceil(count / cellsPerRow);
                //---- space between facets ----
                var approxCellWidth = width / cellsPerRow;
                var xTick = this._transformer.screenSizeXToWorld(12);
                var yTick = this._transformer.screenSizeYToWorld(12);
                var hMargin = xTick + .075 * approxCellWidth;
                var vMargin = yTick + 1.5 * labelHeight;
                var cellWidth = (width - hMargin * (cellsPerRow - 1)) / cellsPerRow;
                var cellHeight = (height - vMargin * (rowCount - 1)) / rowCount;
                var margin2 = 2 * hMargin;
                var yStart = yMax + 2 * vMargin - labelHeight;
                for (var i = 0; i < count; i++) {
                    var colIndex = Math.floor(i % cellsPerRow);
                    var rowIndex = Math.floor(i / cellsPerRow);
                    //---- must align left cells to left edge of container (so labels outside are right next to them) ----
                    var x = xMin + colIndex * (cellWidth + hMargin);
                    //var y = yMin - rowIndex * (cellHeight + vMargin);         // flipped axis
                    var y = yStart - (1 + rowIndex) * (cellHeight + vMargin); // flipped axis
                    //---- make sure all facets are the SAME width and height (critical for shape drawing algorithm and visual comparisons) ----
                    var plotY = y - labelHeight;
                    var plotHeight = Math.max(0, cellHeight - labelHeight);
                    var fb = { x: x, y: plotY, width: cellWidth, height: plotHeight };
                    var lb = { x: x, y: y + plotHeight, width: cellWidth, height: labelHeight };
                    plotBounds.push(fb);
                    labelBounds.push(lb);
                }
            }
            var layout = { facetBounds: plotBounds, labelBounds: labelBounds, rowCount: rowCount, columnCount: cellsPerRow };
            this._layout = layout;
            return layout;
        };
        return facetHelperClass;
    }());
    beachParty.facetHelperClass = facetHelperClass;
    var FacetLayout = (function () {
        function FacetLayout() {
        }
        return FacetLayout;
    }());
    beachParty.FacetLayout = FacetLayout;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    transformMgr.ts - manages changes to 3D transform of chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** manages changes to 3D transform of chart, including relative changes,
      dampening, inerita, transformMode, and transformEnabled. */
    var transformMgrClass = (function (_super) {
        __extends(transformMgrClass, _super);
        function transformMgrClass(gl, transformer) {
            var _this = this;
            _super.call(this);
            this._isInertialEnabled = true;
            this._usePostZ = false;
            //---- this attempts to keep track of our current SCALE and OFFSET and we incrementally change them ----
            this._currentScale = 1;
            this._currentOffsetX = 0;
            this._currentOffsetY = 0;
            this._currentRotationZ = 0;
            this._gl = gl;
            if (!transformer) {
                transformer = new beachParty.transformerClass(gl);
            }
            this._transformer = transformer;
            this._transformMode = beachParty.TransformMode.none;
            //---- hook up dampening ----
            this._xRotDamp = new beachParty.dampenerClass(function (actual) {
                _this._transformer.rotateMatrixX(actual);
            });
            this._yRotDamp = new beachParty.dampenerClass(function (actual) {
                _this._transformer.rotateMatrixY(actual, false, _this._usePostZ);
            });
            this._zRotDamp = new beachParty.dampenerClass(function (actual) {
                _this._transformer.rotateMatrixZ(actual);
            });
            this.resetPanAndPinchDeltas();
        }
        //buildGettersAndSetters()
        //{
        //    this._getterSetters["xRotation"] = (value) => this.xRotation(value);
        //    this._getterSetters["yRotation"] = (value) => this.yRotation(value);
        //    this._getterSetters["zRotation"] = (value) => this.zRotation(value);
        //    this._getterSetters["transformMode"] = (value) => this.transformMode(value);
        //}
        transformMgrClass.prototype.getRayFromScreenPos = function (screenX, screenY) {
            return this._transformer.getRayFromScreenPos(screenX, screenY);
        };
        /** called by dataView when chart frame changes. */
        transformMgrClass.prototype.onFrame = function () {
            var xHas = this._xRotDamp.onFrameApply();
            var yHas = this._yRotDamp.onFrameApply();
            var zHas = this._zRotDamp.onFrameApply();
            this.onDataChanged("frame");
            return (xHas || yHas || zHas);
        };
        transformMgrClass.prototype.getTransformer = function () {
            return this._transformer;
        };
        transformMgrClass.prototype.inertia = function (value) {
            if (arguments.length == 0) {
                var x = this._xRotDamp.inertia();
                var y = this._yRotDamp.inertia();
                var z = this._zRotDamp.inertia();
                return [x, y, z];
            }
            if (value && value.length) {
                this._xRotDamp.inertia(value[0]);
                this._yRotDamp.inertia(value[1]);
                this._zRotDamp.inertia(value[2]);
            }
        };
        transformMgrClass.prototype.resetPanAndPinchDeltas = function () {
            //vp.utils.debug("resetPanAndPinchDeltas");
            this._currentScale = 1;
            this._currentOffsetX = 0;
            this._currentOffsetY = 0;
            this._currentRotationZ = 0;
        };
        transformMgrClass.prototype.onUiOpStart = function () {
            this.onDataChanged("uiOpStart");
            this.resetPanAndPinchDeltas();
            this._xRotDamp.startUiOperation();
            this._yRotDamp.startUiOperation();
            this._zRotDamp.startUiOperation();
        };
        transformMgrClass.prototype.onUiOpStop = function () {
            this.onDataChanged("uiOpStop");
            this.resetPanAndPinchDeltas();
            this._xRotDamp.stopUIOperation();
            this._yRotDamp.stopUIOperation();
            this._zRotDamp.stopUIOperation();
            return this.hasInertia();
        };
        transformMgrClass.prototype.isInertiaEnabled = function (value) {
            if (value === undefined) {
                return this._isInertialEnabled;
            }
            this._isInertialEnabled = value;
            this.onDataChanged("isInertiaEnabled");
        };
        transformMgrClass.prototype.hasInertia = function () {
            var xHas = this._xRotDamp.hasInertia();
            var yHas = this._yRotDamp.hasInertia();
            var zHas = this._zRotDamp.hasInertia();
            var has = (xHas || yHas || zHas);
            return has;
        };
        transformMgrClass.prototype.resetCamera = function () {
            if (this._transformer) {
                this._transformer.resetMatrices();
            }
            //this._xRotDamp.reset();
            //this._yRotDamp.reset();
            //this._zRotDamp.reset();
            this.resetPanAndPinchDeltas();
        };
        transformMgrClass.prototype.applyPanMovement = function (xdiff, ydiff, targetX, targetY, mousePos) {
            var maxDiff = xdiff;
            if (Math.abs(ydiff) > Math.abs(xdiff)) {
                maxDiff = ydiff;
            }
            if (this._transformer) {
                //var inerita = this._isInertialEnabled;
                if (this._transformMode == beachParty.TransformMode.move) {
                    this._transformer.translateMatrixEx(xdiff, ydiff, 0);
                }
                else if (this._transformMode == beachParty.TransformMode.spin) {
                    this.rotateMatrixZ(maxDiff);
                }
                else if (this._transformMode == beachParty.TransformMode.turn) {
                    this.rotateMatrixY(-maxDiff);
                }
                else if (this._transformMode == beachParty.TransformMode.flip) {
                    this.rotateMatrixX(maxDiff);
                }
                else if (this._transformMode == beachParty.TransformMode.zoom) {
                    var factor = (maxDiff > 0) ? 1.3 : 1 / 1.3;
                    this.scaleCameraRelative(factor, mousePos);
                }
            }
        };
        transformMgrClass.prototype.transformMode = function (value) {
            if (value === undefined) {
                var enumName = beachParty.TransformMode[this._transformMode];
                return enumName;
            }
            if (vp.utils.isString(value)) {
                this._transformMode = beachParty.TransformMode[value];
            }
            else {
                this._transformMode = value;
            }
            this.onDataChanged("transformMode");
        };
        transformMgrClass.prototype.resetTransform = function () {
            this.transformMode(beachParty.TransformMode.move);
            if (this._transformer) {
                this._transformer.clearTransforms();
            }
        };
        transformMgrClass.prototype.moveCamera = function (targetX, targetY, mousePos) {
            var xdiff = targetX - this._currentOffsetX;
            var ydiff = targetY - this._currentOffsetY;
            //console.log("pan: " + targetX + ", " + targetY + ", diff=" + xdiff + ", " + ydiff);
            //---- todo: apply change in xy to our current position ----
            this.applyPanMovement(xdiff, ydiff, targetX, targetY, mousePos);
            this._currentOffsetX = targetX;
            this._currentOffsetY = targetY;
        };
        transformMgrClass.prototype.xRotation = function (value) {
            if (value === undefined) {
                return this._transformer.xRotation();
            }
            this._transformer.xRotation(value);
            this.onDataChanged("xRotation");
        };
        transformMgrClass.prototype.yRotation = function (value) {
            if (value === undefined) {
                return this._transformer.yRotation();
            }
            this._transformer.yRotation(value);
            this.onDataChanged("yRotation");
        };
        transformMgrClass.prototype.zRotation = function (value) {
            if (value === undefined) {
                return this._transformer.zRotation();
            }
            this._transformer.zRotation(value);
            this.onDataChanged("zRotation");
        };
        transformMgrClass.prototype.translateCamera = function (x, y, z) {
            this._transformer.translateMatrixEx(-x, -y, -z);
        };
        /** normally adds "value" (in radians) to the current X rotation, in the world matrix.  If additive=false, the x rotation is set
        to "value". */
        transformMgrClass.prototype.rotateMatrixX = function (value, additive, useInertia) {
            if (additive === void 0) { additive = true; }
            if (useInertia === void 0) { useInertia = true; }
            if (this._isInertialEnabled && useInertia) {
                //vp.utils.debug("xRotDamp: target=" + value);
                this._xRotDamp.setTarget(value);
            }
            else {
                this._transformer.rotateMatrixX(value, additive);
            }
        };
        //reverseDampX()
        //{
        //    if (this._isInertialEnabled)
        //    {
        //        this._xRotDamp.reverseAccum();
        //    }
        //    else
        //    {
        //        this._transformer.clearTransforms();
        //    }
        //}
        transformMgrClass.prototype.rotateMatrixY = function (rotStep, usePostZ) {
            this._usePostZ = usePostZ;
            if (this._isInertialEnabled) {
                //vp.utils.debug("yRotDamp: target=" + rotStep);
                this._yRotDamp.setTarget(rotStep);
            }
            else {
                this._transformer.rotateMatrixY(rotStep, false, usePostZ);
            }
        };
        transformMgrClass.prototype.rotateMatrixZ = function (rotStep) {
            if (this._isInertialEnabled) {
                //vp.utils.debug("zRotDamp: target=" + rotStep);
                this._zRotDamp.setTarget(rotStep);
            }
            else {
                this._transformer.rotateMatrixZ(rotStep);
            }
        };
        ///** Rotate the camera about the specified Z axis (relative to the value at the start of this gesture). */
        //rotateMatrixZAbsolute(value: number)
        //{
        //    var rotStep = value - this._currentRotationZ;
        //    this._transformer.rotateMatrixZ(rotStep);
        //    this._currentRotationZ = value;
        //}
        /** Scale the camera by a relative amount. */
        transformMgrClass.prototype.scaleCameraRelative = function (factor, mousePos, isMousePosInWorldUnits) {
            if (factor != 0) {
                var doIt = true;
                if (factor > 1) {
                    doIt = (this._currentScale < 400);
                }
                else {
                    doIt = (this._currentScale > .120);
                }
                if (true) {
                    this._currentScale *= factor;
                    this._transformer.scaleMatrix(factor, mousePos, isMousePosInWorldUnits);
                }
            }
        };
        /** Scale the camera to the specified value (relative to the start of the gesture). */
        transformMgrClass.prototype.scaleCameraAbsolute = function (scale, mousePos) {
            var diffFactor = scale / this._currentScale;
            vp.utils.debug("scaleCameraAbsolute: scale=" + scale + ", currentScale=" + this._currentScale +
                ", diffFactor=" + diffFactor + ", mousePos.x=" + mousePos.x + ", mousePos.y=" + mousePos.y);
            this._transformer.scaleMatrix(diffFactor, mousePos);
            this._currentScale = scale;
        };
        return transformMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.transformMgrClass = transformMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    shapeLegend.ts - draws an interactive, discreet shape legend (shape, ticks, labels).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var shapeLegendClass = (function (_super) {
        __extends(shapeLegendClass, _super);
        function shapeLegendClass(chartRouter, rootName) {
            _super.call(this, chartRouter, "shape", rootName, "shapeLegendTitle");
            this._isNumeric = false;
            this._lastValue = null;
            this._colType = "";
            this.rebuildLegend();
        }
        shapeLegendClass.prototype.shapeMapping = function (value) {
            if (arguments.length === 0) {
                return this._im;
            }
            this._im = value;
            this.onDataChanged("shapeMapping");
            this.rebuildLegend();
        };
        shapeLegendClass.prototype.search = function (colName, value) {
            this.doSearch("Shape", colName, value, value, beachParty.TextSearchType.exactMatch);
        };
        shapeLegendClass.prototype.rebuildLegend = function () {
            var _this = this;
            var im = this._im;
            var showLegend = (im != null && im.imagePalette != null && im.colName != null && im.colName != "");
            //---- show/hide legend ----
            this.show(showLegend);
            if (showLegend) {
                this.measureTextAndSetItemHeight();
                var name = im.colName;
                vp.select(this._titleElem)
                    .text(name);
                var imagePalette = im.imagePalette;
                var breaks = im.breaks;
                var colInfo = this.getColInfo(im.colName);
                var colType = colInfo.colType;
                this._colType = colType;
                var isNumeric = (colType != "string"); // number or date
                this._isNumeric = isNumeric;
                this._lastValue = null;
                this._textElems = [];
                this._paletteElements = [];
                this.buildTexturesOnClient(function (e) {
                    _this.rebuildLegendEx(im, breaks.length, isNumeric);
                });
            }
        };
        shapeLegendClass.prototype.fillLabelEntry = function (parentW, i, yOffset) {
            var _this = this;
            var im = this._im;
            var breaks = im.breaks;
            var value = (breaks) ? breaks[i] : "";
            var text = this.formatLabel(value);
            var tooltip = (text == "Other") ? "All other values mapped here" : text;
            var labelW = parentW.append("div")
                .text(text)
                .addClass("clipText legendLabel")
                .title(tooltip)
                .attach("click", function (e) { return _this.searchForEntryValues(e); });
            if (this._isNumeric) {
                parentW
                    .css("position", "relative");
                //---- shift labels up and to the right ----
                labelW
                    .css("position", "relative")
                    .css("left", "8px")
                    .css("top", (yOffset - this._entryHeight / 2) + "px");
            }
            //---- add information to support click/select ----
            labelW[0].colName = im.colName;
            labelW[0].axisKey = "box" + i;
            if (value == "Other") {
                labelW[0].fromValue = this._lastValue;
                labelW[0].toValue = this._lastValue;
                labelW[0].searchType = beachParty.TextSearchType.greaterThanEqual;
            }
            else if (this._isNumeric) {
                labelW[0].fromValue = (i == 0) ? value : this._lastValue;
                labelW[0].toValue = value;
                labelW[0].searchType = beachParty.TextSearchType.betweenInclusive;
            }
            else {
                labelW[0].fromValue = value;
                labelW[0].toValue = value;
                labelW[0].searchType = beachParty.TextSearchType.exactMatch;
            }
            var colorIndex = i; // (count - 1) - i;
            this._textElems[colorIndex] = labelW[0];
            this._lastValue = value;
        };
        shapeLegendClass.prototype.searchForEntryValues = function (e) {
            var elem = e.target;
            if (elem.imageIndex !== undefined) {
                //---- get text element from this image palette entry ----
                elem = this._textElems[elem.imageIndex];
            }
            var key = "shape." + elem.innerText;
            this.doSearch("Image", elem.colName, elem.fromValue, elem.toValue, elem.searchType, undefined, key);
        };
        shapeLegendClass.prototype.getImageFromSheet = function (imgSheet, width, height, index, count) {
            var srcWidth = imgSheet.width / count;
            var srcHeight = imgSheet.height;
            var canvasW = vp.select(document.createElement("canvas"))
                .attr("width", width)
                .attr("height", height);
            //---- get drawing context ----
            var canvas = canvasW[0];
            var ctx = canvas.getContext("2d");
            //---- draw the selected shape onto the canvas ----
            ctx.clearRect(0, 0, width, height);
            ctx.drawImage(imgSheet, index * srcWidth, 0, srcWidth, srcHeight, 0, 0, width, height);
            return canvas;
        };
        shapeLegendClass.prototype.buildTexturesOnClient = function (callback) {
            var _this = this;
            var im = this._im;
            var texPalette = im.imagePalette;
            var oldCode = false;
            //---- build image as imageSheet ----
            var isShapeNames = (!texPalette[0].contains("."));
            var textureMaker = new beachParty.textureMakerClass(im.imagePalette);
            if (isShapeNames) {
                var drawShapeSize = 32;
                textureMaker.buildShapeMakers(im.imagePalette);
                this._imgSheet = textureMaker.createShapeImages(drawShapeSize, 3);
                callback();
            }
            else {
                textureMaker.registerForChange("loaded", function (e) {
                    _this._imgSheet = textureMaker.getImageSheet();
                    callback();
                });
                //---- create a GL context so textureMaker is happy ----
                var canvas = document.createElement("canvas");
                var gl = beachParty.glUtils.getContext(canvas);
                textureMaker.buildAsync(gl, texPalette, isShapeNames);
            }
        };
        shapeLegendClass.prototype.fillPaletteEntry = function (paletteW, i, isTop) {
            var _this = this;
            var entryWidth = this._entryWidth;
            var entryHeight = this._entryHeight;
            var breaks = this._im.breaks;
            var count = (this._isNumeric) ? (breaks.length - 1) : breaks.length;
            var im = this._im;
            //---- STEPS ----
            //if (count * entryHeight > this._maxPaletteHeight)
            //{
            //    entryHeight = this._maxPaletteHeight / count;
            //}
            var imgIndex = i;
            var text = (breaks) ? breaks[i] : "";
            //---- get image from imageSheet ----
            var drawShapeSize = 32;
            var canvas = this.getImageFromSheet(this._imgSheet, drawShapeSize, drawShapeSize, i, count);
            var cellW = paletteW.append("div")
                .css("width", (entryWidth) + "px")
                .css("height", (entryHeight) + "px")
                .addClass("imagePaletteEntry")
                .customAttr("value", text)
                .css("position", "relative");
            cellW[0].imageIndex = (this._isNumeric) ? (i + 1) : i;
            //---- now add as image within the cell ----
            var shapeSize = entryWidth - 2;
            var left = (entryWidth - shapeSize) / 2;
            var top = (entryHeight - shapeSize) / 2;
            var shapeW = cellW.append("img")
                .addClass("imagePaletteShape")
                .css("width", shapeSize + "px")
                .css("height", shapeSize + "px")
                .css("display", "inline-block")
                .css("left", left + "px")
                .css("top", top + "px")
                .css("position", "absolute")
                .css("object-fit", "contain")
                .attr("src", canvas.toDataURL())
                .attach("click", function (e) { return _this.searchForEntryValues(e); });
            shapeW[0].imageIndex = (this._isNumeric) ? (i + 1) : i;
        };
        return shapeLegendClass;
    }(beachParty.baseLegendClass));
    beachParty.shapeLegendClass = shapeLegendClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    sizeLegend.ts - draws an interactive, continuous/discreet size legend (size palette, ticks, labels).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var sizeLegendClass = (function (_super) {
        __extends(sizeLegendClass, _super);
        function sizeLegendClass(chartRouter, rootName) {
            _super.call(this, chartRouter, "size", rootName, "sizeLegendTitle");
            this._isNumeric = false;
            this._lastValue = null;
            this.rebuildLegend();
        }
        sizeLegendClass.prototype.sizeMapping = function (value) {
            if (arguments.length === 0) {
                return this._sm;
            }
            this._sm = value;
            this.onDataChanged("sizeMapping");
            this.rebuildLegend();
        };
        sizeLegendClass.prototype.search = function (colName, value) {
            this.onSearchRequest.trigger({ legendName: "size", colName: colName, fromValue: value, toValue: value, searchType: beachParty.TextSearchType.exactMatch });
        };
        sizeLegendClass.prototype.rebuildLegend = function () {
            var sm = this._sm;
            var showLegend = (sm != null && sm.sizePalette != null && sm.colName != null && sm.colName != "");
            //---- show/hide legend ----
            this.show(showLegend);
            if (showLegend) {
                var name = sm.colName;
                vp.select(this._titleElem)
                    .text(name);
                this.measureTextAndSetItemHeight();
                var sizePalette = sm.sizePalette;
                var breaks = sm.breaks;
                var count = sizePalette.length;
                if (breaks && breaks.length < count) {
                    count = breaks.length;
                }
                var colInfo = this.getColInfo(sm.colName);
                var isNumeric = (colInfo.colType != "string"); // number or date
                this._isNumeric = isNumeric;
                this._lastValue = null;
                this._textElems = [];
                this._paletteElements = [];
                this.rebuildLegendEx(sm, breaks.length, this._isNumeric);
            }
        };
        sizeLegendClass.prototype.searchForEntryValues = function (e) {
            var elem = e.target;
            if (elem.parentNode && elem.parentNode.sizeIndex !== undefined) {
                elem = elem.parentNode;
            }
            if (elem.sizeIndex !== undefined) {
                //---- get text element from this size palette entry ----
                elem = this._textElems[elem.sizeIndex];
            }
            var key = "size." + elem.innerText;
            this.doSearch("Size", elem.colName, elem.fromValue, elem.toValue, elem.searchType, undefined, key);
        };
        sizeLegendClass.prototype.fillPaletteEntry = function (parentW, i, isTop) {
            var _this = this;
            //---- TODO: continuous size palette not yet supported ---
            var cm = this._sm;
            var sizePalette = cm.sizePalette;
            var breaks = cm.breaks;
            var entryHeight = this._entryHeight;
            var entryWidth = this._entryWidth;
            var isNumeric = this._isNumeric;
            var sz = vp.scales.numberFromDiscretePalette(sizePalette, i);
            var text = (breaks) ? breaks[i] : "";
            //parentW.css("position", "relative")
            var cellW = parentW.append("div")
                .css("width", (entryWidth - 2) + "px")
                .css("height", (entryHeight - 2) + "px")
                .addClass("sizePaletteEntry")
                .customAttr("value", text)
                .attach("click", function (e) { return _this.searchForEntryValues(e); })
                .css("margin-bottom", "-1px") // overlap with next top border
                .css("position", "relative");
            cellW[0].sizeIndex = (isNumeric) ? (i + 1) : i;
            //---- now draw the size shape within the cell ----
            var shapeSize = sz * (entryWidth - 4);
            var left = ((entryWidth - 2) - shapeSize) / 2;
            var top = ((entryHeight - 2) - shapeSize) / 2;
            var shape = cellW.append("span")
                .addClass("sizePaletteShape")
                .css("width", shapeSize + "px")
                .css("height", shapeSize + "px")
                .css("background", "#bbb")
                .css("display", "inline-block")
                .css("margin-top", top + "px")
                .css("margin-left", left + "px");
        };
        sizeLegendClass.prototype.fillLabelEntry = function (parentW, i, yOffset) {
            var _this = this;
            var cm = this._sm;
            var sizePalette = cm.sizePalette;
            var breaks = cm.breaks;
            var entryHeight = this._entryHeight;
            var entryWidth = this._entryWidth;
            var isNumeric = this._isNumeric;
            var value = (breaks) ? breaks[i] : "";
            var text = this.formatLabel(value);
            var tooltip = (text == "Other") ? "All other values mapped here" : text;
            var labelW = parentW.append("div")
                .text(text)
                .addClass("clipText legendLabel")
                .title(tooltip)
                .attach("click", function (e) { return _this.searchForEntryValues(e); });
            if (this._isNumeric) {
                parentW
                    .css("position", "relative");
                //---- shift labels up and to the right ----
                labelW
                    .css("position", "relative")
                    .css("left", "8px")
                    .css("top", (yOffset - this._entryHeight / 2) + "px");
            }
            labelW[0].colName = cm.colName;
            labelW[0].axisKey = "box" + i;
            var lastValue = this._lastValue;
            if (value == "Other") {
                labelW[0].fromValue = lastValue;
                labelW[0].toValue = lastValue;
                labelW[0].searchType = beachParty.TextSearchType.greaterThan;
            }
            else if (isNumeric) {
                labelW[0].fromValue = (i == 0) ? value : lastValue;
                labelW[0].toValue = value;
                labelW[0].searchType = beachParty.TextSearchType.betweenInclusive;
            }
            else {
                labelW[0].fromValue = value;
                labelW[0].toValue = value;
                labelW[0].searchType = beachParty.TextSearchType.exactMatch;
            }
            var sizeIndex = i; // (count - 1) - i;
            this._textElems[sizeIndex] = labelW[0];
            this._lastValue = value;
            //textTop -= entryHeight;
        };
        return sizeLegendClass;
    }(beachParty.baseLegendClass));
    beachParty.sizeLegendClass = sizeLegendClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    textLegend.ts - draws an interactive, continuous/discreet color legend (color palette, ticks, labels).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var textLegendClass = (function (_super) {
        __extends(textLegendClass, _super);
        function textLegendClass(rootName, tm) {
            _super.call(this);
            this._tm = tm;
            var root = vp.select("#" + rootName);
            var colName = (tm) ? tm.colName : "";
            //---- add colName as TITLE ----
            var title = root.append("span")
                .addClass("legendTitle textButton")
                .id("textLegendTitle")
                .text(colName);
            //---- add PALETTE ----
            var palette = root.append("div")
                .addClass("legendPalette");
            this._rootElem = root[0];
            this._titleElem = title[0];
            this._paletteElem = palette[0];
            this.updateLegend();
        }
        textLegendClass.prototype.textMapping = function (value) {
            if (arguments.length === 0) {
                return this._tm;
            }
            this._tm = value;
            this.onDataChanged("textMapping");
            this.updateLegend();
        };
        textLegendClass.prototype.show = function (value) {
            vp.select(this._rootElem)
                .css("display", (value) ? "" : "none");
        };
        textLegendClass.prototype.updateLegend = function () {
            var tm = this._tm;
            if (tm) {
                var name = tm.colName;
                //---- show/hide legend ----
                this.show(name != null);
                vp.select(this._titleElem)
                    .text(name);
                this.rebuildPalette();
            }
        };
        textLegendClass.prototype.rebuildPalette = function () {
            //var cm = this.sm;
            //var colorPalette = cm.colorPalette;
            //var paletteW = vp.select(this._paletteElem);
            //var maxPaletteHeight = 150;
            //var entryHeight = 75;
            //var entryWidth = 20;
            //paletteW
            //    .clear()
            //    .css("width", entryWidth + "px")
            //    .css("opacity", this._opacity+"")
            //var count = colorPalette.length;
            //if (cm.isContinuous)
            //{
            //    var lg = "linear-gradient(";
            //    for (var i = 0; i < count; i++)
            //    {
            //        if (i)
            //        {
            //            lg += ",";
            //        }
            //        var cr = colorPalette[i];
            //        lg += cr;
            //    }
            //    lg += ")";
            //    //---- CONTINUOUS ----
            //    paletteW
            //        .css("background", lg)
            //        .css("height", maxPaletteHeight + "px")
            //}
            //else
            //{
            //    //---- STEPS ----
            //    if (count * entryHeight > maxPaletteHeight)
            //    {
            //        entryHeight = maxPaletteHeight / count;
            //    }
            //    for (var i = 0; i < count; i++)
            //    {
            //        var cr = colorPalette[i];
            //        paletteW.append("div")
            //            .css("background-color", cr)
            //            .addClass("colorPaletteEntry")
            //            .css("width", entryWidth + "px")
            //            .css("height", entryHeight + "px")
            //}
            //}
        };
        return textLegendClass;
    }(beachParty.dataChangerClass));
    beachParty.textLegendClass = textLegendClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    aggColumn.ts - builds a traditional (aggregated) column chart.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var aggColumnClass = (function (_super) {
        __extends(aggColumnClass, _super);
        function aggColumnClass(chart) {
            _super.call(this, chart, "aggColumn");
            this._maxPosSumAllFacets = 0;
            this._maxNegSumAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._heightFactor = 0; // adjust each item's bottom/height to fit the tallest bin
            this._inverseSizeFactor = 0; // used to reverse effect of shader sizing
            this._xMargin = 0;
            this._xBetween = 0;
            this._yMin = 0;
            this._yMax = 0;
            this._chartBuilder.isAggChart(true);
            this._chartBuilder.hideAxes("y");
        }
        /**
         *  truncate data to a single record.  used to bootstrap the development
         *  of aggregation support.
         * @param data
         */
        aggColumnClass.prototype.fakeAggData = function (data) {
            var keys = vp.utils.keys(data);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var numVector = data[key];
                if (numVector instanceof beachParty.NumericVector) {
                    var firstValue = numVector.values[0];
                    numVector.values = new Float32Array(1);
                    numVector.values[0] = firstValue;
                }
            }
        };
        /** Responsiblities:
            1. compute max count for any bin, over all facets.
            2. return max count
        */
        aggColumnClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var xm = this._chart.xMapping();
            var maxPosSum = 0;
            var maxNegSum = 0;
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for consistent facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    //this.fakeAggData(data);
                    var results = beachParty.chartUtils.computeSumForFacet(dc, data, xm, "x", "y");
                    this._facetBinResults.push(results.binResults);
                    maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                    maxNegSum = Math.max(maxNegSum, results.maxNegSum);
                }
            }
            else {
                //this.fakeAggData(dc.nvData);
                var results = beachParty.chartUtils.computeSumForFacet(dc, dc.nvData, xm, "x", "y");
                this._facetBinResults.push(results.binResults);
                maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                maxNegSum = Math.max(maxNegSum, results.maxNegSum);
            }
            this._maxPosSumAllFacets = maxPosSum;
            this._maxNegSumAllFacets = maxNegSum;
            //---- return the sum of both as the "max item count" ----
            return maxPosSum + maxNegSum;
        };
        /** Responsiblities:
           1. adjust Y scale to reflect maxCount (across all facets).
           2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
       */
        aggColumnClass.prototype.adjustScales = function (dc) {
            //---- adjust X scale to reflect BINS ----
            var results = this._facetBinResults; //[0];
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, results);
            //---- adjust Y scale to reflect MAX SUM ----
            var oldScale = dc.scales.y;
            //---- use nice numbers for domain min/max ----
            var nn = vp.scales.niceNumbersAlt.calculate(-this._maxNegSumAllFacets, this._maxPosSumAllFacets);
            dc.scales.y = vp.scales.createLinear()
                .rangeMin(oldScale.rangeMin())
                .rangeMax(oldScale.rangeMax())
                .domainMin(nn.min)
                .domainMax(nn.max);
            //---- mark scale as having pre-computed tickCount ----
            var anyScale = dc.scales.y;
            anyScale._tickCount = nn.steps + 1;
        };
        aggColumnClass.prototype.assignRecordsToBins = function (nv, resultX, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var binAssignments = resultX.assignments;
            var itemHeights = []; // the height of each item (per its Y column value)
            var itemBottoms = []; // the bottom value of each item with its bin 
            var binPosOffsets = []; // next position for an item in positive part of each bin
            var binNegOffsets = []; // next position for an item in negative part of each bin
            //---- process each (sorted) record ----
            for (var vectorIndex = 0; vectorIndex < filter.length; vectorIndex++) {
                if (!filter[vectorIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binAssign = binAssignments[vectorIndex];
                    if (binPosOffsets[binAssign] === undefined) {
                        binPosOffsets[binAssign] = 0;
                        binNegOffsets[binAssign] = 0;
                    }
                    //---- calculate the relative height of this item ----
                    var itemHeight = nv.y.values[vectorIndex];
                    itemHeights[vectorIndex] = itemHeight;
                    if (itemHeight >= 0) {
                        itemBottoms[vectorIndex] = binPosOffsets[binAssign];
                        binPosOffsets[binAssign] += itemHeight;
                    }
                    else {
                        binNegOffsets[binAssign] += itemHeight;
                        itemBottoms[vectorIndex] = binNegOffsets[binAssign];
                    }
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    itemHeights[vectorIndex] = 0;
                    itemBottoms[vectorIndex] = 0;
                }
            }
            this._itemHeights = itemHeights;
            this._itemBottoms = itemBottoms;
            var facetWidth = dc.width;
            var facetHeight = dc.height;
            var binsX = resultX.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var yMin = dc.scales.y.scale(-this._maxNegSumAllFacets);
            var yMax = dc.scales.y.scale(this._maxPosSumAllFacets);
            var availHeight = yMax - yMin;
            /// prevent size adjustments in shader by setting our scale factor here to reverse shader shading.
            this._heightFactor = availHeight / (this._maxPosSumAllFacets + this._maxNegSumAllFacets);
            //---- create bounds ----
            var binLefts = [];
            var binBottoms = [];
            var left = dc.x + this._xMargin; // + dc.itemHalf;
            var bottom = dc.y; // + dc.itemHalf;
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += (this._binWidth + this._xBetween);
                //---- offset all bins by the same amount to enable comparisons ----
                var yOffset = this._heightFactor * this._maxNegSumAllFacets;
                binBottoms[i] = bottom + yOffset;
            }
            this._binLefts = binLefts;
            this._binBottoms = binBottoms;
            this._itemAssignments = binAssignments;
            this._inverseSizeFactor = 1 / dc.userSizeFactor; //  dc.combinedSizeFactor;
        };
        aggColumnClass.prototype.preLayoutLoop = function (dc) {
            //---- compute usable part of Y axis ----
            var yMin = dc.scales.y.scale(this._maxNegSumAllFacets);
            var yMax = dc.scales.y.scale(this._maxPosSumAllFacets);
            this._yMin = yMin;
            this._yMax = yMax;
            if (this._facetBinResults && dc.facetIndex < this._facetBinResults.length) {
                var facetResult = this._facetBinResults[dc.facetIndex];
                var availHeight = yMax - yMin;
                var result = beachParty.chartUtils.computeColumnBinSize(facetResult, dc.width, availHeight);
                this._binWidth = result.binWidth;
                this._binHeight = result.binHeight;
                this._xMargin = result.xMargin;
                this._xBetween = result.xBetween;
                this.assignRecordsToBins(dc.nvData, facetResult, dc);
            }
        };
        aggColumnClass.prototype.layoutDataForRecord = function (itemIndex, dc, dr) {
            var nv = dc.nvData;
            var visibleIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[itemIndex]);
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var binAssign = this._itemAssignments[itemIndex];
            var left = this._binLefts[binAssign];
            var bottom = this._binBottoms[binAssign];
            var heightFactor = this._heightFactor;
            var inverseSizeFactor = this._inverseSizeFactor;
            var trueHeight = Math.abs(heightFactor * this._itemHeights[itemIndex]);
            //---- layout as STACKED rectangles ----
            dr.x = left + this._binWidth / 2; // place at horizontal center of shape
            dr.y = bottom + (heightFactor * this._itemBottoms[itemIndex]);
            dr.y += trueHeight / 2; // place at vertical center of shape
            dr.z = 0;
            dr.height = inverseSizeFactor * trueHeight;
            dr.width = inverseSizeFactor * this._binWidth;
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, itemIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, itemIndex, dc.scales.imageIndex);
        };
        return aggColumnClass;
    }(beachParty.baseLayoutClass));
    beachParty.aggColumnClass = aggColumnClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    barCount.ts - builds a sand Bar chart (unit histogram, where units are arranged in a grid within each column).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var barCountClass = (function (_super) {
        __extends(barCountClass, _super);
        function barCountClass(chart) {
            _super.call(this, chart, "barCount");
            this._maxCountAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._yMargin = 0;
            this._yBetween = 0;
            this._xMin = 0; // start of x space for our drawing (as per x scale)
            this._xMax = 0; // end of x space for drawing (as per x scale)
            this._visibleColPickers = "ya";
            this._visibleBinAdjusters = "y";
            this._chartBuilder.isXAxisClickable(false);
        }
        /** Responsiblities:
            1. compute max count for any bin, over all facets.
            2. return max count
        */
        barCountClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var maxCount = 0;
            var ym = this._chart.yMapping();
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for consistent facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(ym, dc.layoutFilterVector, dc.nvData.y);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var results = beachParty.chartUtils.computeMaxBinCountForData(dc, data, ym, "y");
                    this._facetBinResults.push(results.binResults);
                    maxCount = Math.max(maxCount, results.maxCount);
                }
            }
            else {
                var results = beachParty.chartUtils.computeMaxBinCountForData(dc, dc.nvData, ym, "y");
                this._facetBinResults.push(results.binResults);
                maxCount = results.maxCount;
            }
            //---- does client want to override max count? ----
            if (this._chart.isMaxItemCountEnabled()) {
                maxCount = this._chart.maxItemCount();
            }
            this._maxCountAllFacets = maxCount;
            return maxCount;
        };
        /** Responsiblities:
           1. adjust Y scale to reflect maxCount (across all facets).
           2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
       */
        barCountClass.prototype.adjustScales = function (dc) {
            //---- adjust X scale ----
            this.xScaleAdjust(dc);
            //---- adjust Y scale ----
            var results = this._facetBinResults; //[0];
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, results);
        };
        /** create a new linear scale for X, based on the maximum count for a full bar. */
        barCountClass.prototype.xScaleAdjust = function (dc) {
            var oldScale = dc.scales.x;
            //---- adjust maxCount so that it represents a full bar, for our x scale max ----
            var maxCount = this._maxCountAllFacets;
            var binResults = this._facetBinResults;
            var yResult = binResults[0];
            //---- ESTIMATE itemWidth and itemHeight using full space of canvas ----
            var cb = this._chartBuilder;
            this.preLayoutLoopCore(yResult, cb.getClientWidth(), cb.getClientHeight(), yResult.bins.length);
            //---- NOTE: itemHeight is the height of a single bin container ----
            var aspect = this._itemWidth / this._itemHeight;
            //var aspect = this._itemHeight / this._itemWidth;
            var factor = Math.ceil(Math.sqrt(aspect * maxCount));
            var shapesPerCol = Math.ceil(maxCount / factor);
            var colCount = Math.ceil(maxCount / shapesPerCol);
            //---- lock these values in now ----
            this._shapesPerCol = shapesPerCol;
            this._newColCount = colCount;
            //var maxCountForRow = rowCount * Math.ceil(maxCount / rowCount);
            var result = beachParty.chartUtils.computeBestCountFactor(maxCount, shapesPerCol);
            var maxCountForCol = result.maxCount;
            dc.scales.x = vp.scales.createLinear()
                .rangeMin(oldScale.rangeMin())
                .rangeMax(oldScale.rangeMax())
                .domainMin(0)
                .domainMax(maxCountForCol);
            //---- mark scale as being for chunk-based count ----
            var anyScale = dc.scales.x;
            anyScale._tickCount = result.tickCount;
            dc.xCalcName = "_count"; // so we know this is a calc field
        };
        barCountClass.prototype.assignRecordsToBins = function (nv, resultY, dc, maxBinCountForAllFacets) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignY = resultY.assignments;
            var rowToBinNum = [];
            var rowToBinIndex = [];
            var binCounts = [];
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            //---- process each (sorted) record ----
            for (var i = 0; i < filter.length; i++) {
                var recordIndex = i;
                if (!filter[recordIndex]) {
                    //--- assignments must be indexed by the recordIndex ----
                    var binIndexY = allAssignY[recordIndex];
                    rowToBinNum[recordIndex] = binIndexY;
                    if (binCounts[binIndexY] === undefined) {
                        binCounts[binIndexY] = 0;
                    }
                    //---- this shape's index within its bin ----
                    rowToBinIndex[recordIndex] = binCounts[binIndexY];
                    binCounts[binIndexY] += 1;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    rowToBinNum[recordIndex] = 0;
                    rowToBinIndex[recordIndex] = 0;
                }
            }
            var maxCount = maxBinCountForAllFacets;
            var width = dc.width;
            var height = dc.height;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            //---- create bounds for each BAR bin ----
            var binTops = [];
            var binWidths = [];
            var bottom = dc.y + this._yMargin; // dc.y - height + this._yMargin;
            for (var i = 0; i < binsY.length; i++) {
                binTops[i] = bottom;
                if (binCounts[i] === undefined) {
                    binCounts[i] = 0;
                }
                binWidths[i] = binCounts[i] / maxCount * width;
                bottom += (this._itemHeight + this._yBetween);
            }
            this._binTops = binTops;
            this._binWidths = binWidths;
            this._rowToBinNum = rowToBinNum;
            this._rowToBinIndex = rowToBinIndex;
            //---- set up GRID params ----
            var aspect = this._itemWidth / this._itemHeight;
            //var colCount = this._shapesPerCol;          //  Math.ceil(Math.sqrt(aspect * maxCount));
            //this._colCount = colCount;
            //this._rowCount = rowCount;
            var maxShapeSize = this._itemWidth / this._newColCount;
            maxShapeSize = Math.min(maxShapeSize, .85 * this._itemHeight / this._shapesPerCol);
            this._maxShapeSize = maxShapeSize; //  / dc.transformSizeFactor;
            vp.utils.debug("preLayoutLoopCore: itemWidth=" + this._itemWidth + ", itemHeight=" + this._itemHeight +
                ", maxShapeSize=" + this._maxShapeSize);
            this._nextIndex = 0;
            return maxCount;
        };
        barCountClass.prototype.preLayoutLoop = function (dc) {
            //this.preLayoutLoopCore(dc, true);
            var shapesPerCol = this._shapesPerCol;
            var maxCountFullCol = shapesPerCol * Math.ceil(this._maxCountAllFacets / shapesPerCol);
            //---- don't use all of Y space; let scale determine boundaries ----
            //---- this is needed because sometimes scale may be larger than maxCount. ----
            //---- also, we should allow for optional expand space in range ----
            var xMin = dc.scales.x.scale(0);
            var xMax = dc.scales.x.scale(maxCountFullCol);
            this._xMin = xMin;
            this._xMax = xMax;
            var availWidth = xMax - xMin;
            var availHeight = dc.height;
            var binResults = this._facetBinResults;
            if (binResults && binResults.length) {
                var yResult = binResults[dc.facetIndex];
                this.preLayoutLoopCore(yResult, availWidth, availHeight, yResult.bins.length);
                this.assignRecordsToBins(dc.nvData, yResult, dc, this._maxCountAllFacets);
            }
        };
        barCountClass.prototype.preLayoutLoopCore = function (yResult, availWidth, availHeight, binCount) {
            var result = beachParty.chartUtils.computeBarBinSize(yResult, availWidth, availHeight);
            this._itemWidth = result.binWidth;
            this._itemHeight = result.binHeight;
            this._yMargin = result.yMargin;
            this._yBetween = result.yBetween;
        };
        barCountClass.prototype.layoutDataForRecord = function (recordIndex, dc, dr) {
            var nv = dc.nvData;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[recordIndex]);
            var visibleIndex = 0;
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var binIndexX = this._rowToBinNum[recordIndex];
            var top = this._binTops[binIndexX];
            var bottom = dc.y; // dc.y - dc.height;
            var binWidth = this._binWidths[binIndexX];
            if (this._chartOptions.layout == "Random") {
                var xr = nv.randomX.values[recordIndex];
                var yr = nv.randomY.values[recordIndex];
                dr.x = dc.x + xr * binWidth;
                dr.y = top + yr * this._itemHeight;
            }
            else {
                //---- GRID layout ----
                var indexInBin = this._rowToBinIndex[recordIndex];
                var rowNum = indexInBin % this._shapesPerCol;
                var colNum = Math.floor(indexInBin / this._shapesPerCol);
                //---- center shapes within their x-locations ----
                dr.x = dc.x + ((.5 + colNum) / this._newColCount) * this._itemWidth;
                //---- center shapes relative to their row bottom ----
                dr.y = top + ((.5 + rowNum) / this._shapesPerCol) * this._itemHeight;
            }
            var scaleFactor = this.scaleColData(nv.size, recordIndex, dc.scales.size, 1);
            dr.width = this._maxShapeSize * scaleFactor;
            dr.height = dr.width;
            dr.z = 0;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, recordIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, recordIndex, dc.scales.imageIndex);
        };
        return barCountClass;
    }(beachParty.baseLayoutClass));
    beachParty.barCountClass = barCountClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    barSum.ts - builds a summed sand Bar chart (where each item is a rectangle, stacked on to right of each other, with width
//   proportional to x column value.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var barSumClass = (function (_super) {
        __extends(barSumClass, _super);
        function barSumClass(chart) {
            _super.call(this, chart, "barSum");
            this._maxPosSumAllFacets = 0;
            this._maxNegSumAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._widthFactor = 0; // adjust each item's bottom/height to fit the tallest bin
            this._inverseSizeFactor = 0; // used to reverse effect of shader sizing
            this._yMargin = 0;
            this._yBetween = 0;
            this._xMin = 0;
            this._xMax = 0;
            this._visibleColPickers = "ya";
            this._visibleBinAdjusters = "y";
            this._chartBuilder.isXAxisClickable(false);
        }
        /** Two responsiblities: 1. compute max count for any bin, over all facets.  2. adjust scales as needed for our chart. */
        barSumClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var ym = this._chart.yMapping();
            var maxPosSum = 0;
            var maxNegSum = 0;
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for consistent facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(ym, dc.layoutFilterVector, dc.nvData.y);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var results = beachParty.chartUtils.computeSumForFacet(dc, data, ym, "y", "size");
                    this._facetBinResults.push(results.binResults);
                    maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                    maxNegSum = Math.max(maxNegSum, results.maxNegSum);
                }
            }
            else {
                var results = beachParty.chartUtils.computeSumForFacet(dc, dc.nvData, ym, "y", "size");
                this._facetBinResults.push(results.binResults);
                maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                maxNegSum = Math.max(maxNegSum, results.maxNegSum);
            }
            this._maxPosSumAllFacets = maxPosSum;
            this._maxNegSumAllFacets = maxNegSum;
            vp.utils.debug("computeFacetStats: maxPosSum=" + maxPosSum + ", maxNegSum=" + maxNegSum);
            //---- return the sum of both as the "max item count" ----
            return maxPosSum + maxNegSum;
        };
        /** Responsiblities:
         1. adjust Y scale to reflect maxCount (across all facets).
         2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
        */
        barSumClass.prototype.adjustScales = function (dc) {
            //---- adjust Y scale to reflect BINS ----
            var results = this._facetBinResults; //[0];
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, results);
            //---- adjust X scale to reflect MAX SUM ----
            var oldScale = dc.scales.x;
            //---- use nice numbers for domain min/max ----
            var nn = vp.scales.niceNumbersAlt.calculate(-this._maxNegSumAllFacets, this._maxPosSumAllFacets);
            dc.scales.x = vp.scales.createLinear()
                .rangeMin(oldScale.rangeMin())
                .rangeMax(oldScale.rangeMax())
                .domainMin(nn.min)
                .domainMax(nn.max);
            //---- mark scale as having pre-computed tickCount ----
            var anyScale = dc.scales.x;
            anyScale._tickCount = nn.steps + 1;
        };
        barSumClass.prototype.assignRecordsToBins = function (nv, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var binAssignments = resultY.assignments;
            var itemWidths = []; // the width of each item (per its X column value)
            var itemLefts = []; // the left value of each item within its bin 
            var binPosOffsets = []; // next position for an item in positive part of each bin
            var binNegOffsets = []; // next position for an item in negative part of each bin
            //---- process each (sorted) record ----
            for (var vectorIndex = 0; vectorIndex < filter.length; vectorIndex++) {
                if (!filter[vectorIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binAssign = binAssignments[vectorIndex];
                    if (binPosOffsets[binAssign] === undefined) {
                        binPosOffsets[binAssign] = 0;
                        binNegOffsets[binAssign] = 0;
                    }
                    //---- calculate the relative width of this item ----
                    var itemWidth = nv.size.values[vectorIndex];
                    itemWidths[vectorIndex] = itemWidth;
                    if (itemWidth >= 0) {
                        itemLefts[vectorIndex] = binPosOffsets[binAssign];
                        binPosOffsets[binAssign] += itemWidth;
                    }
                    else {
                        binNegOffsets[binAssign] += itemWidth;
                        itemLefts[vectorIndex] = binNegOffsets[binAssign];
                    }
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    itemWidths[vectorIndex] = 0;
                    itemLefts[vectorIndex] = 0;
                }
            }
            this._itemWidths = itemWidths;
            this._itemLefts = itemLefts;
            var facetWidth = dc.width;
            var facetHeight = dc.height;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the yScale labels ----
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            var xMin = dc.scales.x.scale(-this._maxNegSumAllFacets);
            var xMax = dc.scales.x.scale(this._maxPosSumAllFacets);
            var availWidth = xMax - xMin;
            //// prevent size adjustments in shader by setting our scale factor here to reverse shader shading.
            this._widthFactor = availWidth / (this._maxPosSumAllFacets + this._maxNegSumAllFacets);
            //---- create bounds ----
            var binLefts = [];
            var binBottoms = [];
            var bottom = dc.y + this._yMargin;
            for (var i = 0; i < binsY.length; i++) {
                binBottoms[i] = bottom;
                bottom += (this._binHeight + this._yBetween);
                //---- offset all bins by the same amount to enable comparisons ----
                var xOffset = this._widthFactor * this._maxNegSumAllFacets;
                binLefts[i] = dc.x + xOffset;
            }
            this._binLefts = binLefts;
            this._binBottoms = binBottoms;
            this._itemAssignments = binAssignments;
            //---- setting this to "1" allow us to apply the sizeFactor correctly ----
            this._inverseSizeFactor = 1; // 1 / dc.userSizeFactor;            //  dc.combinedSizeFactor;
        };
        barSumClass.prototype.preLayoutLoop = function (dc) {
            //var options = <sandDensityOptions>this._chartOptions;
            //var nv = dc.nvData;
            //var binResults = this._facetBinResults;
            //if (binResults && binResults.length)
            //{
            //    var yResult = binResults[dc.facetIndex];
            //    var binCount = yResult.bins.length;
            //    var width = dc.width;
            //    var height = dc.height;
            //    var approxItemHeight = height / binCount;
            //    var yMargin = .1 * approxItemHeight;
            //    var yBetween = .1 * approxItemHeight;
            //    this._yMargin = yMargin;
            //    this._yBetween = yBetween;
            //    //---- compute itemWidth and itemHeight ----
            //    var itemHeight = (height - 2 * yMargin - (binCount - 1) * yBetween) / binCount;
            //    var itemWidth = width;
            //    this._binWidth = itemWidth;
            //    this._binHeight = itemHeight;
            //    this.assignRecordsToBins(nv, yResult, dc);
            //}
            //---- compute usable part of X axis ----
            var xMin = dc.scales.x.scale(this._maxNegSumAllFacets);
            var xMax = dc.scales.x.scale(this._maxPosSumAllFacets);
            this._xMin = xMin;
            this._xMax = xMax;
            if (this._facetBinResults && dc.facetIndex < this._facetBinResults.length) {
                var facetResult = this._facetBinResults[dc.facetIndex];
                var availWidth = xMax - xMin;
                var result = beachParty.chartUtils.computeBarBinSize(facetResult, availWidth, dc.height);
                this._binWidth = result.binWidth;
                this._binHeight = result.binHeight;
                this._yMargin = result.yMargin;
                this._yBetween = result.yBetween;
                this.assignRecordsToBins(dc.nvData, facetResult, dc);
            }
        };
        barSumClass.prototype.layoutDataForRecord = function (itemIndex, dc, dr) {
            var nv = dc.nvData;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[itemIndex]);
            var visibleIndex = 0;
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var binAssign = this._itemAssignments[itemIndex];
            var left = this._binLefts[binAssign];
            var bottom = this._binBottoms[binAssign];
            var widthFactor = this._widthFactor;
            var inverseSizeFactor = this._inverseSizeFactor;
            var trueWidth = Math.abs(widthFactor * this._itemWidths[itemIndex]);
            //---- layout as STACKED rectangles ----
            dr.x = left + (widthFactor * this._itemLefts[itemIndex]);
            dr.y = bottom + this._binHeight / 2; // place at horizontal center of shape
            dr.x += trueWidth / 2; // place at horizontal center of shape
            dr.z = 0;
            dr.width = inverseSizeFactor * trueWidth;
            dr.height = inverseSizeFactor * this._binHeight;
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, itemIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, itemIndex, dc.scales.imageIndex);
        };
        return barSumClass;
    }(beachParty.baseLayoutClass));
    beachParty.barSumClass = barSumClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    columnCount.ts - builds a sand Column chart (unit histogram, where units are arranged in a grid within each column).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** this chart groups the items into N bins (using the X column), and then lays out the item's shapes in a grid for each column. All layout is
     * done based on "_maxCountAllFacets" - the maximum # of items in any bin (across all facets).  This determines the "_shapesPerRow"
     * and the "_rowCount".  Each column then drawn according to these variables.
      */
    var columnCountClass = (function (_super) {
        __extends(columnCountClass, _super);
        function columnCountClass(chart) {
            _super.call(this, chart, "columnCount");
            this._maxCountAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._maxShapeWidth = 1;
            this._maxShapeHeight = 1;
            this._xMargin = 0;
            this._yMin = 0; // bottom of y space for our drawing (as per y scale)
            this._yMax = 0; // top of y space for drawing (as per y scale)
            this._xBetween = 0;
            this._visibleColPickers = "xa";
            this._visibleBinAdjusters = "x";
            this._chartBuilder.isYAxisClickable(false);
        }
        /** Responsiblities:
            1. compute max count for any bin, over all facets.
            2. compute xMin, xMax for all data (across facets).
            3. return max count
        */
        columnCountClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var maxCount = 0;
            var xm = this._chart.xMapping();
            //---- compute min/max over all data for consistent facet binning ----
            beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var results = beachParty.chartUtils.computeMaxBinCountForData(dc, data, xm, "x");
                    this._facetBinResults.push(results.binResults);
                    maxCount = Math.max(maxCount, results.maxCount);
                }
            }
            else {
                var results = beachParty.chartUtils.computeMaxBinCountForData(dc, dc.nvData, xm, "x");
                this._facetBinResults.push(results.binResults);
                maxCount = results.maxCount;
            }
            //---- does client want to override max count? ----
            if (this._chart.isMaxItemCountEnabled()) {
                maxCount = this._chart.maxItemCount();
            }
            //vp.utils.debug("columnClass.computeFacetStats: dc.filteredCount=" + dc.filteredRecordCount + ", maxBinCountForAllFacets=" + maxCount);
            this._maxCountAllFacets = maxCount;
            vp.utils.debug("columnCount.computeFacetStats: maxCount=" + maxCount + ", filtered OUT count=" + vector.countOn(dc.nvData.layoutFilter.values));
            return maxCount;
        };
        /** Responsiblities:
            1. adjust Y scale to reflect maxCount (across all facets).
            2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
        */
        columnCountClass.prototype.adjustScales = function (dc) {
            //---- adjust X scale to reflect BINS ----
            var results = this._facetBinResults; // [0];
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, results, "x");
            //---- adjust Y scale to reflect MAX COUNT ----
            this.yScaleAdjust(dc);
        };
        /** create a new linear scale for Y, based on the maximum count for a full column. */
        columnCountClass.prototype.yScaleAdjust = function (dc) {
            var oldScale = dc.scales.y;
            //---- adjust maxCount so that it represents a full column, for our y scale max ----
            var maxCount = this._maxCountAllFacets;
            var binResults = this._facetBinResults;
            if (binResults && binResults.length) {
                var xResult = binResults[0];
                //---- ESTIMATE itemWidth and itemHeight using full space of canvas ----
                var cb = this._chartBuilder;
                this.preLayoutLoopCore(xResult, cb.getClientWidth(), cb.getClientHeight(), xResult.bins.length);
            }
            var binAspect = this._binWidth / this._binHeight;
            var shapesPerRow = Math.ceil(Math.sqrt(binAspect * maxCount));
            this._shapesPerRow = shapesPerRow; // lock this value in now for consistent results
            //vp.utils.debug("maxCount=" + maxCount + ", aspect=" + aspect + ", shapesPerRow=" + shapesPerRow);
            var result = beachParty.chartUtils.computeBestCountFactor(maxCount, shapesPerRow);
            var maxCountForCol = result.maxCount;
            //---- range may not be set for oldScale since it probably didn't have an associated data column ----
            var rangeMin = dc.y; // - dc.height;
            var rangeMax = dc.y + dc.height;
            dc.scales.y = vp.scales.createLinear()
                .rangeMin(rangeMin)
                .rangeMax(rangeMax)
                .domainMin(0)
                .domainMax(maxCountForCol);
            //---- mark scale as having pre-computed tickCount ----
            var anyScale = dc.scales.y;
            anyScale._tickCount = result.tickCount;
            dc.yCalcName = "_count"; // so we know this is a calc field
        };
        columnCountClass.prototype.assignRecordsToBins = function (nv, resultX, dc, maxBinCountForAllFacets) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignX = resultX.assignments;
            var rowToBinNum = [];
            var rowToBinIndex = [];
            var binCounts = [];
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            //vp.utils.debug("columnClass.assignRecordsToBins: dc.filteredCount=" + dc.filteredRecordCount + ", maxBinCountForAllFacets=" + maxBinCountForAllFacets);
            //---- process each (sorted) record ----
            for (var i = 0; i < dc.recordCount; i++) {
                var shapeIndex = i;
                if (!isFiltered || !filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = allAssignX[shapeIndex];
                    rowToBinNum[shapeIndex] = binIndexX;
                    if (binCounts[binIndexX] === undefined) {
                        binCounts[binIndexX] = 0;
                    }
                    //---- this shape's index within its bin ----
                    rowToBinIndex[shapeIndex] = binCounts[binIndexX];
                    binCounts[binIndexX] += 1;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    rowToBinNum[shapeIndex] = 0;
                    rowToBinIndex[shapeIndex] = 0;
                }
            }
            var maxCount = maxBinCountForAllFacets;
            var width = dc.width;
            var height = this._yMax - this._yMin; //  dc.height;
            var binsX = resultX.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            //---- create bounds of each bin ----
            var binLefts = [];
            var binHeights = [];
            var left = dc.x + this._xMargin;
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                binHeights[i] = binCounts[i] / maxCount * height;
                left += (this._binWidth + this._xBetween);
            }
            this._binLefts = binLefts;
            this._binHeights = binHeights;
            this._rowToBinNum = rowToBinNum;
            this._rowToBinIndex = rowToBinIndex;
            //---- set up GRID params ----
            var shapesPerRow = this._shapesPerRow; // use precomputed (locked in) value  
            var rowCount = Math.ceil(maxCount / shapesPerRow);
            //this._colCount = colCount;
            this._rowCount = rowCount;
            var maxShapeWidth = .85 * this._binWidth / this._shapesPerRow;
            var maxShapeHeight = .85 * this._binHeight / this._rowCount;
            this._maxShapeWidth = maxShapeWidth; //  / dc.transformSizeFactor;
            this._maxShapeHeight = maxShapeHeight; //  / dc.transformSizeFactor;
            //vp.utils.debug("assignRecordsToBins: itemWidth=" + this._itemWidth + ", itemHeight=" + this._itemHeight + ", shapesPerRow=" + shapesPerRow +
            //    ", rowCount = " + rowCount + ", maxShapeWidth=" + maxShapeWidth); 
            this._nextIndex = 0;
            return maxCount;
        };
        columnCountClass.prototype.preLayoutLoop = function (dc) {
            vp.utils.debug("columnCount.preLayoutLoop: filtered OUT count=" + vector.countOn(dc.nvData.layoutFilter.values));
            var shapesPerRow = this._shapesPerRow;
            var maxCountFullRow = shapesPerRow * Math.ceil(this._maxCountAllFacets / shapesPerRow);
            //---- don't use all of Y space; let scale determine boundaries ----
            //---- this is needed because sometimes scale may be larger than maxCount. ----
            //---- also, we should allow for optional expand space in range ----
            var yMin = dc.scales.y.scale(0);
            var yMax = dc.scales.y.scale(maxCountFullRow);
            this._yMin = yMin;
            this._yMax = yMax;
            var availWidth = dc.width;
            var availHeight = yMax - yMin;
            var binResults = this._facetBinResults;
            if (binResults && binResults.length) {
                var xResult = binResults[dc.facetIndex];
                this.preLayoutLoopCore(xResult, availWidth, availHeight, xResult.bins.length);
                this.assignRecordsToBins(dc.nvData, xResult, dc, this._maxCountAllFacets);
            }
        };
        columnCountClass.prototype.preLayoutLoopCore = function (xResult, availWidth, availHeight, binCount) {
            var result = beachParty.chartUtils.computeColumnBinSize(xResult, availWidth, availHeight);
            this._binWidth = result.binWidth;
            this._binHeight = result.binHeight;
            this._xMargin = result.xMargin;
            this._xBetween = result.xBetween;
        };
        /** "bufferIndex" in the 0-based indexed into the sorted data buffers. */
        columnCountClass.prototype.layoutDataForRecord = function (bufferIndex, dc, dr) {
            var nv = dc.nvData;
            var visibleIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[bufferIndex]);
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var binIndexX = this._rowToBinNum[bufferIndex];
            var left = this._binLefts[binIndexX];
            //var bottom = dc.y - dc.height;
            var bottom = this._yMin;
            var binHeight = this._binHeights[binIndexX];
            if (this._chartOptions.layout == "Random") {
                var xr = nv.randomX.values[bufferIndex];
                var yr = nv.randomY.values[bufferIndex];
                dr.x = left + xr * this._binWidth;
                dr.y = bottom + yr * binHeight;
            }
            else {
                //---- GRID layout ----
                var indexInBin = this._rowToBinIndex[bufferIndex];
                var colNum = indexInBin % this._shapesPerRow;
                var rowNum = Math.floor(indexInBin / this._shapesPerRow);
                //---- center shapes within their x-locations ----
                dr.x = left + ((.5 + colNum) / this._shapesPerRow) * this._binWidth;
                //---- center shapes relative to their row bottom ----
                dr.y = bottom + ((.5 + rowNum) / this._rowCount) * this._binHeight;
            }
            dr.z = 0;
            var scaleFactor = this.scaleColData(nv.size, bufferIndex, dc.scales.size, 1);
            dr.width = this._maxShapeWidth * scaleFactor;
            dr.height = this._maxShapeHeight * scaleFactor;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, bufferIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, bufferIndex, dc.scales.imageIndex);
        };
        return columnCountClass;
    }(beachParty.baseLayoutClass));
    beachParty.columnCountClass = columnCountClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    columnPercent.ts - builds a sand 100% Column chart (unit histogram, where units are arranged in a grid within each column).  Columns are all of 
//    a fixed height with a variable width.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** this chart groups the items into N bins (using the X column), and then lays out the item's shapes in a grid for each column. All layout is
     * done based on "_maxCountAllFacets" - the maximum # of items in any bin (across all facets).  This determines the "_shapesPerRow"
     * and the "_rowCount".  Each column then drawn according to these variables.
      */
    var columnPercentClass = (function (_super) {
        __extends(columnPercentClass, _super);
        function columnPercentClass(chart) {
            _super.call(this, chart, "columnPercent");
            this._maxCountAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._maxShapeWidth = 1;
            this._maxShapeHeight = 1;
            this._xMargin = 0;
            this._yMin = 0; // bottom of y space for our drawing (as per y scale)
            this._yMax = 0; // top of y space for drawing (as per y scale)
            this._xBetween = 0;
            //---- experimental ----
            this._stretchWidth = true;
            this._visibleColPickers = "xa";
            this._visibleBinAdjusters = "x";
            this._chartBuilder.isYAxisClickable(false);
        }
        /** Responsiblities:
            1. compute max count for any bin, over all facets.
            2. compute xMin, xMax for all data (across facets).
            3. return max count
        */
        columnPercentClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var maxCount = 0;
            var xm = this._chart.xMapping();
            //---- compute min/max over all data for consistent facet binning ----
            beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var results = beachParty.chartUtils.computeMaxBinCountForData(dc, data, xm, "x");
                    this._facetBinResults.push(results.binResults);
                    maxCount = Math.max(maxCount, results.maxCount);
                }
            }
            else {
                var results = beachParty.chartUtils.computeMaxBinCountForData(dc, dc.nvData, xm, "x");
                this._facetBinResults.push(results.binResults);
                maxCount = results.maxCount;
            }
            //---- does client want to override max count? ----
            if (this._chart.isMaxItemCountEnabled()) {
                maxCount = this._chart.maxItemCount();
            }
            //vp.utils.debug("columnClass.computeFacetStats: dc.filteredCount=" + dc.filteredRecordCount + ", maxBinCountForAllFacets=" + maxCount);
            this._maxCountAllFacets = maxCount;
            return maxCount;
        };
        /** Responsiblities:
            1. adjust Y scale to reflect maxCount (across all facets).
            2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
        */
        columnPercentClass.prototype.adjustScales = function (dc) {
            //---- adjust X scale to reflect BINS ----
            var results = this._facetBinResults; // [0];
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, results, "x");
            //---- adjust Y scale to reflect MAX COUNT ----
            this.yScaleAdjust(dc);
        };
        /** create a new linear scale for Y, from 0 to 1. */
        columnPercentClass.prototype.yScaleAdjust = function (dc) {
            var oldScale = dc.scales.y;
            //---- adjust maxCount so that it represents a full column, for our y scale max ----
            var maxCount = this._maxCountAllFacets;
            var binResults = this._facetBinResults;
            if (binResults && binResults.length) {
                var xResult = binResults[0];
                //---- ESTIMATE itemWidth and itemHeight using full space of canvas ----
                var cb = this._chartBuilder;
                this.preLayoutLoopCore(xResult, cb.getClientWidth(), cb.getClientHeight(), xResult.bins.length);
            }
            var binAspect = this._binWidth / this._binHeight;
            var shapesPerRow = Math.ceil(Math.sqrt(binAspect * maxCount));
            this._oldShapesPerRow = shapesPerRow; // lock this value in now for consistent results
            //vp.utils.debug("maxCount=" + maxCount + ", aspect=" + aspect + ", shapesPerRow=" + shapesPerRow);
            //var result = chartUtils.computeBestCountFactor(maxCount, shapesPerRow);
            //---- range may not be set for oldScale since it probably didn't have an associated data column ----
            var rangeMin = dc.y; // - dc.height;
            var rangeMax = dc.y + dc.height;
            dc.scales.y = vp.scales.createLinear()
                .rangeMin(rangeMin)
                .rangeMax(rangeMax)
                .domainMin(0)
                .domainMax(1);
            //---- mark scale as having pre-computed tickCount ----
            var anyScale = dc.scales.y;
            anyScale._tickCount = 6; // result.tickCount;
            dc.yCalcName = "_percent"; // so we know this is a calc field
        };
        columnPercentClass.prototype.assignRecordsToBins = function (nv, resultX, dc, maxBinCountForAllFacets) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignX = resultX.assignments;
            var rowToBinNum = [];
            var rowToBinIndex = [];
            var binCounts = [];
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            //vp.utils.debug("columnClass.assignRecordsToBins: dc.filteredCount=" + dc.filteredRecordCount + ", maxBinCountForAllFacets=" + maxBinCountForAllFacets);
            //---- process each (sorted) record ----
            for (var i = 0; i < dc.recordCount; i++) {
                var shapeIndex = i;
                if (!isFiltered || !filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = allAssignX[shapeIndex];
                    rowToBinNum[shapeIndex] = binIndexX;
                    if (binCounts[binIndexX] === undefined) {
                        binCounts[binIndexX] = 0;
                    }
                    //---- this shape's index within its bin ----
                    rowToBinIndex[shapeIndex] = binCounts[binIndexX];
                    binCounts[binIndexX] += 1;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    rowToBinNum[shapeIndex] = 0;
                    rowToBinIndex[shapeIndex] = 0;
                }
            }
            var maxCount = maxBinCountForAllFacets;
            var width = dc.width;
            var height = this._yMax - this._yMin; //  dc.height;
            var binsX = resultX.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            //---- create bounds ----
            var binLefts = [];
            var binWidths = [];
            var binRowCounts = [];
            var shapesPerRow = [];
            var oldShapesPerRow = this._oldShapesPerRow; // use precomputed (locked in) value  
            if (this._stretchWidth) {
                var centerOfNextBin = dc.x + this._xMargin; // + this._binWidth / 2 ;
            }
            else {
                var centerOfNextBin = dc.x + this._xMargin + this._binWidth / 2;
            }
            var maxRowCount = Math.ceil(maxCount / oldShapesPerRow);
            var totalShapeWidth = this._binWidth / oldShapesPerRow;
            for (var i = 0; i < binsX.length; i++) {
                shapesPerRow[i] = Math.ceil(binCounts[i] / maxRowCount);
                binRowCounts[i] = binCounts[i] / shapesPerRow[i];
                if (this._stretchWidth) {
                    binWidths[i] = this._binWidth;
                    binLefts[i] = centerOfNextBin;
                }
                else {
                    binWidths[i] = totalShapeWidth * shapesPerRow[i];
                    binLefts[i] = centerOfNextBin - binWidths[i] / 2;
                }
                centerOfNextBin += (this._binWidth + this._xBetween);
                vp.utils.debug("assignRecordsToBins: binLefts[i]=" + binLefts[i] + ", binWidths[i]=" + binWidths[i] + ", rowCounts[i]=" + binRowCounts[i] +
                    ", shapesPerRow[i]=" + shapesPerRow[i]);
            }
            this._binLefts = binLefts;
            this._binWidths = binWidths;
            this._shapesPerRow = shapesPerRow;
            this._rowToBinNum = rowToBinNum;
            this._rowToBinIndex = rowToBinIndex;
            this._binRowCounts = binRowCounts;
            //---- set up GRID params ----
            //this._colCount = colCount;
            this._rowCount = maxRowCount;
            var maxShapeWidth = this.shapeSize(this._binWidth / oldShapesPerRow);
            var maxShapeHeight = this.shapeSize(this._binHeight / this._rowCount);
            this._maxShapeWidth = maxShapeWidth; //  / dc.transformSizeFactor;
            this._maxShapeHeight = maxShapeHeight; //  / dc.transformSizeFactor;
            //vp.utils.debug("assignRecordsToBins: itemWidth=" + this._itemWidth + ", itemHeight=" + this._itemHeight + ", shapesPerRow=" + shapesPerRow +
            //    ", rowCount = " + rowCount + ", maxShapeWidth=" + maxShapeWidth); 
            this._nextIndex = 0;
            return maxCount;
        };
        columnPercentClass.prototype.preLayoutLoop = function (dc) {
            var oldShapesPerRow = this._oldShapesPerRow;
            var maxCountFullRow = oldShapesPerRow * Math.ceil(this._maxCountAllFacets / oldShapesPerRow);
            //---- don't use all of Y space; let scale determine boundaries ----
            //---- this is needed because sometimes scale may be larger than maxCount. ----
            //---- also, we should allow for optional expand space in range ----
            var yMin = dc.scales.y.scale(0);
            var yMax = dc.scales.y.scale(maxCountFullRow);
            this._yMin = yMin;
            this._yMax = yMax;
            var availWidth = dc.width;
            var availHeight = yMax - yMin;
            var binResults = this._facetBinResults;
            if (binResults && binResults.length) {
                var xResult = binResults[dc.facetIndex];
                this.preLayoutLoopCore(xResult, availWidth, availHeight, xResult.bins.length);
                this.assignRecordsToBins(dc.nvData, xResult, dc, this._maxCountAllFacets);
            }
        };
        columnPercentClass.prototype.preLayoutLoopCore = function (xResult, availWidth, availHeight, binCount) {
            var result = beachParty.chartUtils.computeColumnBinSize(xResult, availWidth, availHeight);
            this._binWidth = result.binWidth;
            this._binHeight = result.binHeight;
            this._xMargin = result.xMargin;
            this._xBetween = result.xBetween;
        };
        columnPercentClass.prototype.shapeSize = function (maxSize) {
            var gap = Math.min(.02, .15 * maxSize);
            return maxSize - gap;
        };
        /** "bufferIndex" in the 0-based indexed into the sorted data buffers. */
        columnPercentClass.prototype.layoutDataForRecord = function (bufferIndex, dc, dr) {
            var nv = dc.nvData;
            var visibleIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[bufferIndex]);
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var binIndexX = this._rowToBinNum[bufferIndex];
            var left = this._binLefts[binIndexX];
            //var bottom = dc.y - dc.height;
            var bottom = this._yMin;
            var binWidth = this._binWidths[binIndexX];
            var shapesPerMyRow = this._shapesPerRow[binIndexX];
            //---- GRID layout ----
            var indexInBin = this._rowToBinIndex[bufferIndex];
            var colNum = indexInBin % shapesPerMyRow;
            var rowNum = Math.floor(indexInBin / shapesPerMyRow);
            var scaleFactor = this.scaleColData(nv.size, bufferIndex, dc.scales.size, 1);
            var shapeWidth = this.shapeSize(this._binWidth / shapesPerMyRow);
            var myRowCount = this._binRowCounts[binIndexX];
            var fullHeight = this._binHeight / myRowCount;
            var shapeHeight = this.shapeSize(fullHeight);
            vp.utils.debug("shapeHeight=" + shapeHeight);
            dr.width = shapeWidth * scaleFactor;
            dr.height = shapeHeight * scaleFactor;
            dr.depth = dc.defaultDepth2d;
            //---- center shapes within their x-locations ----
            dr.x = left + ((.5 + colNum) / shapesPerMyRow) * binWidth;
            //---- center shapes relative to their row bottom ----
            //dr.y = bottom + ((.5 + rowNum) / this._rowCount) * this._binHeight;
            dr.y = bottom + (.5 + rowNum) * fullHeight;
            dr.z = 0;
            dr.colorIndex = this.scaleColData(nv.colorIndex, bufferIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, bufferIndex, dc.scales.imageIndex);
        };
        return columnPercentClass;
    }(beachParty.baseLayoutClass));
    beachParty.columnPercentClass = columnPercentClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    columnSquarify.ts - builds a Column chart (with inner layout = squrify)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var columnSquarifyClass = (function (_super) {
        __extends(columnSquarifyClass, _super);
        function columnSquarifyClass(chart) {
            _super.call(this, chart, "columnSquarify");
            this._maxPosSumAllFacets = 0;
            this._maxNegSumAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._itemBounds = {}; // map from itemIndex to absolute rectangle bounds of each shape
            this._heightFactor = 0; // adjust each item's bottom/height to fit the tallest bin
            this._inverseSizeFactor = 0; // used to reverse effect of shader sizing
            this._xMargin = 0;
            this._xBetween = 0;
            this._yMin = 0;
            this._yMax = 0;
            this._visibleColPickers = "xa";
            this._visibleBinAdjusters = "x";
            this._chartBuilder.isYAxisClickable(false);
        }
        /** Responsiblities:
            1. compute max count for any bin, over all facets.
            2. return max count
        */
        columnSquarifyClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var xm = this._chart.xMapping();
            var maxPosSum = 0;
            var maxNegSum = 0;
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for consistent facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var results = beachParty.chartUtils.computeSumForFacet(dc, data, xm, "x", "aux");
                    this._facetBinResults.push(results.binResults);
                    maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                    maxNegSum = Math.max(maxNegSum, results.maxNegSum);
                }
            }
            else {
                var results = beachParty.chartUtils.computeSumForFacet(dc, dc.nvData, xm, "x", "aux");
                this._facetBinResults.push(results.binResults);
                maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                maxNegSum = Math.max(maxNegSum, results.maxNegSum);
            }
            this._maxPosSumAllFacets = maxPosSum;
            this._maxNegSumAllFacets = maxNegSum;
            //---- return the sum of both as the "max item count" ----
            return maxPosSum + maxNegSum;
        };
        /** Responsiblities:
           1. adjust Y scale to reflect maxCount (across all facets).
           2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
       */
        columnSquarifyClass.prototype.adjustScales = function (dc) {
            //---- adjust X scale to reflect BINS ----
            var results = this._facetBinResults; //[0];
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, results);
            //---- adjust Y scale to reflect MAX SUM ----
            var oldScale = dc.scales.y;
            //---- use nice numbers for domain min/max ----
            var nn = vp.scales.niceNumbersAlt.calculate(-this._maxNegSumAllFacets, this._maxPosSumAllFacets);
            dc.scales.y = vp.scales.createLinear()
                .rangeMin(oldScale.rangeMin())
                .rangeMax(oldScale.rangeMax())
                .domainMin(nn.min)
                .domainMax(nn.max);
            //---- mark scale as having pre-computed tickCount ----
            var anyScale = dc.scales.y;
            anyScale._tickCount = nn.steps + 1;
        };
        columnSquarifyClass.prototype.assignRecordsToBins = function (nv, resultX, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var binAssignments = resultX.assignments;
            var itemBounds = {};
            var facetWidth = dc.width;
            var facetHeight = dc.height;
            var binsX = resultX.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var yMin = dc.scales.y.scale(-this._maxNegSumAllFacets);
            var yMax = dc.scales.y.scale(this._maxPosSumAllFacets);
            var availHeight = yMax - yMin;
            /// prevent size adjustments in shader by setting our scale factor here to reverse shader shading.
            this._heightFactor = availHeight / (this._maxPosSumAllFacets + this._maxNegSumAllFacets);
            //---- create bounds ----
            var binLefts = [];
            var binBottoms = [];
            var left = dc.x + this._xMargin; // + dc.itemHalf;
            var bottom = dc.y;
            var top = bottom + dc.height;
            var spacing = dc.spacingFactor; //   this.getSpacingFactor(dc);
            //---- layout each bin ----
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += (this._binWidth + this._xBetween);
                //---- offset all bins by the same amount to enable comparisons ----
                var yOffset = this._heightFactor * this._maxNegSumAllFacets;
                binBottoms[i] = bottom + yOffset;
                var binSizes = binsX[i].rowIndexes.map(function (itemNum) {
                    if (!filter[itemNum]) {
                        var size = nv.aux.values[itemNum];
                    }
                    else {
                        //---- if it is FILTERED OUT, don't include it in the layout ----
                        var size = 0;
                    }
                    //---- relative size of item ----
                    return size;
                });
                //---- layout records within the bin ----
                var binSum = binSizes.sum();
                var binHeightFactor = binSum / this._maxPosSumAllFacets;
                var binHeight = binHeightFactor * this._binHeight;
                var rc = vp.geom.createRect(binLefts[i], binBottoms[i], this._binWidth, binHeight);
                this.layoutBin(rc, binsX[i].rowIndexes, binSizes, itemBounds, spacing);
            }
            //---- not quite right...----
            this._itemBounds = itemBounds;
            this._binLefts = binLefts;
            this._binBottoms = binBottoms;
            this._itemAssignments = binAssignments;
            //---- setting this to "1" allow us to apply the sizeFactor correctly ----
            this._inverseSizeFactor = 1; // 1 / dc.userSizeFactor;            //  dc.combinedSizeFactor;
        };
        columnSquarifyClass.prototype.layoutBin = function (rc, itemIndexes, binSizes, itemBounds, spacing) {
            //---- do a squarify layout for the items in this bin ----
            var squarify = new beachParty.squarifyLayoutClass();
            var cellMargin = spacing; // 0.00001;
            var cells = squarify.layout(binSizes, rc, cellMargin);
            //---- update itemBounds with results----
            for (var b = 0; b < cells.length; b++) {
                var rcItem = cells[b].rect;
                var itemIndex = itemIndexes[b];
                itemBounds[itemIndex] = rcItem;
            }
        };
        columnSquarifyClass.prototype.preLayoutLoop = function (dc) {
            //---- compute usable part of Y axis ----
            var yMin = dc.scales.y.scale(this._maxNegSumAllFacets);
            var yMax = dc.scales.y.scale(this._maxPosSumAllFacets);
            this._yMin = yMin;
            this._yMax = yMax;
            if (this._facetBinResults && dc.facetIndex < this._facetBinResults.length) {
                var facetResult = this._facetBinResults[dc.facetIndex];
                var availHeight = yMax - yMin;
                var result = beachParty.chartUtils.computeColumnBinSize(facetResult, dc.width, availHeight);
                this._binWidth = result.binWidth;
                this._binHeight = result.binHeight;
                this._xMargin = result.xMargin;
                this._xBetween = result.xBetween;
                this.assignRecordsToBins(dc.nvData, facetResult, dc);
            }
        };
        columnSquarifyClass.prototype.layoutDataForRecord = function (itemIndex, dc, dr) {
            var nv = dc.nvData;
            var visibleIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[itemIndex]);
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var inverseSizeFactor = this._inverseSizeFactor;
            //---- layout as rectangles in our facet/plot space ----
            if (!layoutFilterVector[itemIndex]) {
                //---- IN FILTER - give it the next rcArray ----
                var rc = this._itemBounds[itemIndex];
            }
            else {
                //---- OUT OF FILTER; give it default rc ----
                var rc = vp.geom.createRect(0, 0, 1, 1);
            }
            var isRect = false; // (shapeType == ShapeType.rectangle);
            var fillCell = true;
            if (fillCell) {
                dr.width = rc.width / dc.userSizeFactor; // dc.combinedSizeFactor;
                dr.height = rc.height / dc.userSizeFactor; // dc.combinedSizeFactor;
            }
            //else
            //{
            //    dr.width = this._maxShapeSize * this.scaleColData(nv.size, i, scales.size, 1);
            //    dr.height = dr.width;
            //}
            dr.depth = dc.defaultDepth2d;
            //---- center drawing within cell ----
            dr.x = rc.left + rc.width / 2;
            //---- work around facet vs. non-facet inconsistency in bottom/top usage ----
            dr.y = Math.min(rc.bottom, rc.top) + rc.height / 2; // rc.top
            dr.z = 0;
            dr.height = inverseSizeFactor * rc.height;
            dr.width = inverseSizeFactor * rc.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, itemIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, itemIndex, dc.scales.imageIndex);
        };
        return columnSquarifyClass;
    }(beachParty.baseLayoutClass));
    beachParty.columnSquarifyClass = columnSquarifyClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    columnSum.ts - builds a summed sand Column chart (where each item is a rectangle, stacked on top of each other, with height
//   proportional to y column value.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var columnSumClass = (function (_super) {
        __extends(columnSumClass, _super);
        function columnSumClass(chart) {
            _super.call(this, chart, "columnSum");
            this._maxPosSumAllFacets = 0;
            this._maxNegSumAllFacets = 0;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._heightFactor = 0; // adjust each item's bottom/height to fit the tallest bin
            this._inverseSizeFactor = 0; // used to reverse effect of shader sizing
            this._xMargin = 0;
            this._xBetween = 0;
            this._yMin = 0;
            this._yMax = 0;
            this._visibleColPickers = "xa";
            this._visibleBinAdjusters = "x";
            this._chartBuilder.isYAxisClickable(false);
        }
        /** Responsiblities:
            1. compute max count for any bin, over all facets.
            2. return max count
        */
        columnSumClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._facetBinResults = [];
            var xm = this._chart.xMapping();
            var maxPosSum = 0;
            var maxNegSum = 0;
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for consistent facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var results = beachParty.chartUtils.computeSumForFacet(dc, data, xm, "x", "aux");
                    this._facetBinResults.push(results.binResults);
                    maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                    maxNegSum = Math.max(maxNegSum, results.maxNegSum);
                }
            }
            else {
                var results = beachParty.chartUtils.computeSumForFacet(dc, dc.nvData, xm, "x", "aux");
                this._facetBinResults.push(results.binResults);
                maxPosSum = Math.max(maxPosSum, results.maxPosSum);
                maxNegSum = Math.max(maxNegSum, results.maxNegSum);
            }
            this._maxPosSumAllFacets = maxPosSum;
            this._maxNegSumAllFacets = maxNegSum;
            //---- return the sum of both as the "max item count" ----
            return maxPosSum + maxNegSum;
        };
        /** Responsiblities:
           1. adjust Y scale to reflect maxCount (across all facets).
           2. adjust X scale to reflect bin labels (on ticks, or in middle of ticks).
       */
        columnSumClass.prototype.adjustScales = function (dc) {
            //---- adjust X scale to reflect BINS ----
            var results = this._facetBinResults; //[0];
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, results);
            //---- adjust Y scale to reflect MAX SUM ----
            var oldScale = dc.scales.y;
            //---- use nice numbers for domain min/max ----
            var nn = vp.scales.niceNumbersAlt.calculate(-this._maxNegSumAllFacets, this._maxPosSumAllFacets);
            dc.scales.y = vp.scales.createLinear()
                .rangeMin(oldScale.rangeMin())
                .rangeMax(oldScale.rangeMax())
                .domainMin(nn.min)
                .domainMax(nn.max);
            //---- mark scale as having pre-computed tickCount ----
            var anyScale = dc.scales.y;
            anyScale._tickCount = nn.steps + 1;
        };
        columnSumClass.prototype.assignRecordsToBins = function (nv, resultX, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var binAssignments = resultX.assignments;
            var itemHeights = []; // the height of each item (per its Y column value)
            var itemBottoms = []; // the bottom value of each item with its bin 
            var binPosOffsets = []; // next position for an item in positive part of each bin
            var binNegOffsets = []; // next position for an item in negative part of each bin
            //---- process each (sorted) record ----
            for (var vectorIndex = 0; vectorIndex < filter.length; vectorIndex++) {
                if (!filter[vectorIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binAssign = binAssignments[vectorIndex];
                    if (binPosOffsets[binAssign] === undefined) {
                        binPosOffsets[binAssign] = 0;
                        binNegOffsets[binAssign] = 0;
                    }
                    //---- calculate the relative height of this item ----
                    var itemHeight = nv.aux.values[vectorIndex];
                    itemHeights[vectorIndex] = itemHeight;
                    if (itemHeight >= 0) {
                        itemBottoms[vectorIndex] = binPosOffsets[binAssign];
                        binPosOffsets[binAssign] += itemHeight;
                    }
                    else {
                        binNegOffsets[binAssign] += itemHeight;
                        itemBottoms[vectorIndex] = binNegOffsets[binAssign];
                    }
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    itemHeights[vectorIndex] = 0;
                    itemBottoms[vectorIndex] = 0;
                }
            }
            this._itemHeights = itemHeights;
            this._itemBottoms = itemBottoms;
            var facetWidth = dc.width;
            var facetHeight = dc.height;
            var binsX = resultX.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var yMin = dc.scales.y.scale(-this._maxNegSumAllFacets);
            var yMax = dc.scales.y.scale(this._maxPosSumAllFacets);
            var availHeight = yMax - yMin;
            /// prevent size adjustments in shader by setting our scale factor here to reverse shader shading.
            this._heightFactor = availHeight / (this._maxPosSumAllFacets + this._maxNegSumAllFacets);
            //---- create bounds ----
            var binLefts = [];
            var binBottoms = [];
            var left = dc.x + this._xMargin; // + dc.itemHalf;
            var bottom = dc.y; // + dc.itemHalf;
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += (this._binWidth + this._xBetween);
                //---- offset all bins by the same amount to enable comparisons ----
                var yOffset = this._heightFactor * this._maxNegSumAllFacets;
                binBottoms[i] = bottom + yOffset;
            }
            this._binLefts = binLefts;
            this._binBottoms = binBottoms;
            this._itemAssignments = binAssignments;
            //---- setting this to "1" allow us to apply the sizeFactor correctly ----
            this._inverseSizeFactor = 1; // 1 / dc.userSizeFactor;            //  dc.combinedSizeFactor;
        };
        columnSumClass.prototype.preLayoutLoop = function (dc) {
            //---- compute usable part of Y axis ----
            var yMin = dc.scales.y.scale(this._maxNegSumAllFacets);
            var yMax = dc.scales.y.scale(this._maxPosSumAllFacets);
            this._yMin = yMin;
            this._yMax = yMax;
            if (this._facetBinResults && dc.facetIndex < this._facetBinResults.length) {
                var facetResult = this._facetBinResults[dc.facetIndex];
                var availHeight = yMax - yMin;
                var result = beachParty.chartUtils.computeColumnBinSize(facetResult, dc.width, availHeight);
                this._binWidth = result.binWidth;
                this._binHeight = result.binHeight;
                this._xMargin = result.xMargin;
                this._xBetween = result.xBetween;
                this.assignRecordsToBins(dc.nvData, facetResult, dc);
            }
        };
        columnSumClass.prototype.layoutDataForRecord = function (itemIndex, dc, dr) {
            var nv = dc.nvData;
            var visibleIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[itemIndex]);
            if (!filtered) {
                visibleIndex = this._nextIndex++;
            }
            var binAssign = this._itemAssignments[itemIndex];
            var left = this._binLefts[binAssign];
            var bottom = this._binBottoms[binAssign];
            var heightFactor = this._heightFactor;
            var inverseSizeFactor = this._inverseSizeFactor;
            var trueHeight = Math.abs(heightFactor * this._itemHeights[itemIndex]);
            //---- layout as STACKED rectangles ----
            dr.x = left + this._binWidth / 2; // place at horizontal center of shape
            dr.y = bottom + (heightFactor * this._itemBottoms[itemIndex]);
            dr.y += trueHeight / 2; // place at vertical center of shape
            dr.z = 0;
            dr.height = inverseSizeFactor * trueHeight;
            dr.width = inverseSizeFactor * this._binWidth;
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, itemIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, itemIndex, dc.scales.imageIndex);
        };
        return columnSumClass;
    }(beachParty.baseLayoutClass));
    beachParty.columnSumClass = columnSumClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    densityCircle.ts - builds a density chart (2D histogram, with CIRCLE layout within each heatmap tile). 
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var densityCircle = (function (_super) {
        __extends(densityCircle, _super);
        function densityCircle(chart) {
            _super.call(this, chart, "densityCircle");
            //---- all facet results ----
            this._xFacetBinResults = null;
            this._yFacetBinResults = null;
            this._phyloSeed = 137.508; // "golden angle"
            this._radius = 0;
            this._spacing = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._sideMargin = 0;
            this._betweenMargin = 0;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "xy";
        }
        /** Adjust scales as needed for our chart. */
        densityCircle.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._xFacetBinResults = [];
            this._yFacetBinResults = [];
            var xm = this._chart.xMapping();
            var ym = this._chart.yMapping();
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var xResults = beachParty.chartUtils.binTheDataForCount(dc, data, xm, "x");
                    this._xFacetBinResults.push(xResults);
                    var yResults = beachParty.chartUtils.binTheDataForCount(dc, data, ym, "y");
                    this._yFacetBinResults.push(yResults);
                }
            }
            else {
                var xResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, xm, "x");
                this._xFacetBinResults.push(xResults);
                var yResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, ym, "y");
                this._yFacetBinResults.push(yResults);
            }
            //---- adjust X scale ----
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, [xResults]);
            //---- adjust Y scale ----
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, [yResults]);
            return dc.filteredRecordCount;
        };
        densityCircle.prototype.computeCircleParams = function (rcxWorld, maxRecordsInABin) {
            var xSize = this._itemWidth;
            var ySize = this._itemHeight;
            this._radius = Math.min(xSize, ySize);
            this._spacing = .5 * this._radius / Math.sqrt(maxRecordsInABin);
            this._nextIndex = 0;
            //this._center.x = (rcxWorld.right + rcxWorld.left) / 2;
            //this._center.y = (rcxWorld.bottom + rcxWorld.top) / 2;
        };
        densityCircle.prototype.assignRecordsToBins = function (nv, resultX, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var isFiltered = (dc.layoutFilterVector != null);
            var filter = dc.layoutFilterVector;
            //var isFiltered = dc.data.isFilteredOutOfLayout();
            var allAssignX = resultX.assignments;
            var allAssignY = resultY.assignments;
            var binIndexesX = [];
            var binIndexesY = [];
            var binRelativeIndexes = [];
            var binCounts = {}; // will use string as our 3d index   (facet, x, y)
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            for (var i = 0; i < filter.length; i++) {
                var shapeIndex = i; // sri[i];        // process shape indexes, in sorted order
                if (!filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = allAssignX[shapeIndex];
                    var binIndexY = allAssignY[shapeIndex];
                    binIndexesX[shapeIndex] = binIndexX;
                    binIndexesY[shapeIndex] = binIndexY;
                    //---- update bin COUNTS ----
                    //---- we are called once for each facet, so we don't need that in our countKey anymore ----
                    var countKey = binIndexX + "," + binIndexY;
                    if (binCounts[countKey] === undefined) {
                        binCounts[countKey] = 0;
                    }
                    var binRelativeIndex = binCounts[countKey];
                    binRelativeIndexes[shapeIndex] = binRelativeIndex;
                    binCounts[countKey] = binRelativeIndex + 1;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    binIndexesX[shapeIndex] = 0;
                    binIndexesY[shapeIndex] = 0;
                }
            }
            //---- find max # of entries in any bin ----
            var maxCount = 0;
            var keys = vp.utils.keys(binCounts);
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var count = binCounts[key];
                maxCount = Math.max(count, maxCount);
            }
            var width = dc.width;
            var height = dc.height;
            var binsX = resultX.bins;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            //---- create bounds ----
            var binLefts = [];
            var binTops = [];
            var left = dc.x + this._sideMargin;
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += (this._itemWidth + this._betweenMargin);
            }
            var top = dc.y + this._sideMargin + this._itemHeight;
            for (var i = 0; i < binsY.length; i++) {
                binTops[i] = top;
                top += (this._itemHeight + this._betweenMargin);
            }
            this._binLefts = binLefts;
            this._binTops = binTops;
            this._binIndexesX = binIndexesX;
            this._binIndexesY = binIndexesY;
            this._binRelativeIndexes = binRelativeIndexes;
            return maxCount;
        };
        densityCircle.prototype.preLayoutLoop = function (dc) {
            var options = this._chartOptions;
            var nv = dc.nvData;
            //---- use pre-computed bins ----
            var xResult = this._xFacetBinResults[dc.facetIndex];
            var yResult = this._yFacetBinResults[dc.facetIndex];
            var xBinCount = xResult.bins.length;
            var yBinCount = yResult.bins.length;
            var width = dc.width;
            var height = dc.height;
            var sideMargin = .002 * dc.width;
            var betweenMargin = 3 * sideMargin;
            this._sideMargin = sideMargin;
            this._betweenMargin = betweenMargin;
            //---- compute itemWidth and itemHeight ----
            var itemWidth = (width - 2 * sideMargin - (xBinCount - 1) * betweenMargin) / xBinCount;
            var itemHeight = (height - 2 * sideMargin - (yBinCount - 1) * betweenMargin) / yBinCount;
            this._itemWidth = itemWidth;
            this._itemHeight = itemHeight;
            var maxRecordsInABin = this.assignRecordsToBins(nv, xResult, yResult, dc);
            var rcBin = vp.geom.createRect(this._binLefts[0], this._binTops[0], this._itemWidth, this._itemHeight);
            this.computeCircleParams(rcBin, maxRecordsInABin);
        };
        densityCircle.prototype.layoutDataForRecord = function (recordIndex, dc, dr) {
            var nv = dc.nvData;
            var rowIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[recordIndex]);
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var left = this._binLefts[binIndexX];
            var top = this._binTops[binIndexY];
            var cx = left + this._itemWidth / 2;
            var cy = top - this._itemHeight / 2;
            //var cx = this._center.x;
            //var cy = this._center.y;
            var binRelativeIndex = this._binRelativeIndexes[recordIndex];
            var r = this._spacing * Math.sqrt(binRelativeIndex);
            var theta = Math.PI / 180 * (binRelativeIndex * this._phyloSeed);
            dr.x = cx + r * Math.sin(theta);
            dr.y = cy + r * Math.cos(theta);
            dr.z = 0;
            dr.width = dc.maxShapeSize * this.scaleColData(nv.size, recordIndex, dc.scales.size, 1);
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, recordIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, recordIndex, dc.scales.imageIndex);
        };
        return densityCircle;
    }(beachParty.baseLayoutClass));
    beachParty.densityCircle = densityCircle;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    densityGrid.ts - builds a density chart (2D histogram, with grid layout within each heatmap tile). 
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var densityGrid = (function (_super) {
        __extends(densityGrid, _super);
        function densityGrid(chart) {
            _super.call(this, chart, "densityGrid");
            //---- all facet results ----
            this._xFacetBinResults = null;
            this._yFacetBinResults = null;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._hMargin = 0;
            this._vMargin = 0;
            this._hBetween = 0;
            this._vBetween = 0;
            this._xglobalmax = 1;
            this._yglobalmax = 1;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "xy";
        }
        /** Adjust scales as needed for our chart. */
        densityGrid.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._xFacetBinResults = [];
            this._yFacetBinResults = [];
            var xm = this._chart.xMapping();
            var ym = this._chart.yMapping();
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for consistent facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
                beachParty.chartUtils.setFilteredMinMaxBreak(ym, dc.layoutFilterVector, dc.nvData.y);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var xResults = beachParty.chartUtils.binTheDataForCount(dc, data, xm, "x");
                    this._xFacetBinResults.push(xResults);
                    var yResults = beachParty.chartUtils.binTheDataForCount(dc, data, ym, "y");
                    this._yFacetBinResults.push(yResults);
                }
            }
            else {
                var xResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, xm, "x");
                this._xFacetBinResults.push(xResults);
                var yResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, ym, "y");
                this._yFacetBinResults.push(yResults);
            }
            this.adjustScales(dc);
            return dc.filteredRecordCount;
        };
        densityGrid.prototype.adjustScales = function (dc) {
            //---- adjust X scale ----
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, [this._xFacetBinResults[0]]);
            //---- adjust Y scale ----
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, [this._yFacetBinResults[0]]);
        };
        densityGrid.prototype.assignRecordsToBins = function (nv, resultX, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignX = resultX.assignments;
            var allAssignY = resultY.assignments;
            var binIndexesX = [];
            var binIndexesY = [];
            var binRelativeIndexes = [];
            this._binCounts = {}; // will use string as our 3d index   (facet, x, y)
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            for (var i = 0; i < filter.length; i++) {
                var shapeIndex = i; // sri[i];        // process shape indexes, in sorted order
                if (!filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = allAssignX[shapeIndex];
                    var binIndexY = allAssignY[shapeIndex];
                    binIndexesX[shapeIndex] = binIndexX;
                    binIndexesY[shapeIndex] = binIndexY;
                    //---- we are called once for each facet, so we don't need that in our countKey anymore ----
                    var countKey = binIndexX + "," + binIndexY;
                    if (this._binCounts[countKey] === undefined) {
                        this._binCounts[countKey] = 0;
                    }
                    //binIndexes[shapeIndex] = binCounts[countKey];
                    this._binCounts[countKey] += 1;
                    var binRelativeIndex = this._binCounts[countKey];
                    binRelativeIndexes[shapeIndex] = binRelativeIndex;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    binIndexesX[shapeIndex] = 0;
                    binIndexesY[shapeIndex] = 0;
                }
            }
            //---- find max # of entries in any bin ----
            var maxCount = 0;
            var keys = vp.utils.keys(this._binCounts);
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var count = this._binCounts[key];
                maxCount = Math.max(count, maxCount);
            }
            var width = dc.width;
            var height = dc.height;
            var binsX = resultX.bins;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            //---- create bounds ----
            var binLefts = [];
            var binTops = [];
            var left = dc.x + this._hMargin;
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += (this._itemWidth + this._hBetween);
            }
            var top = dc.y + this._vMargin + this._itemHeight;
            for (var i = 0; i < binsY.length; i++) {
                binTops[i] = top;
                top += (this._itemHeight + this._vBetween);
            }
            this._binLefts = binLefts;
            this._binTops = binTops;
            this._binIndexesX = binIndexesX;
            this._binIndexesY = binIndexesY;
            this._binRelativeIndexes = binRelativeIndexes;
            return maxCount;
        };
        densityGrid.prototype.preLayoutLoop = function (dc) {
            var options = this._chartOptions;
            var nv = dc.nvData;
            //---- use pre-computed bins ----
            var xResult = this._xFacetBinResults[dc.facetIndex];
            var yResult = this._yFacetBinResults[dc.facetIndex];
            var xBinCount = xResult.bins.length;
            var yBinCount = yResult.bins.length;
            var width = dc.width;
            var height = dc.height;
            var hMargin = 2 * dc.itemSize;
            var hBetween = .1 * (dc.width / xBinCount);
            var vMargin = 2 * dc.itemSize;
            var vBetween = .2 * (dc.height / yBinCount);
            this._hMargin = hMargin;
            this._hBetween = hBetween;
            this._vMargin = vMargin;
            this._vBetween = vBetween;
            //---- compute itemWidth and itemHeight ----
            var itemWidth = (width - 2 * hMargin - (xBinCount - 1) * hBetween) / xBinCount;
            var itemHeight = (height - 2 * vMargin - (yBinCount - 1) * vBetween) / yBinCount;
            var ySpace = .1 * itemHeight;
            var binHeight = itemHeight - ySpace;
            this._itemWidth = itemWidth;
            this._itemHeight = itemHeight;
            var maxRecordsInABin = this.assignRecordsToBins(nv, xResult, yResult, dc);
            this._maxCount = maxRecordsInABin;
            var rcBin = vp.geom.createRect(this._binLefts[0], this._binTops[0], this._itemWidth, this._itemHeight);
            this._xglobalmax = Math.max(Math.ceil(Math.sqrt(this._maxCount)), 1);
            this._yglobalmax = Math.max(Math.ceil(this._maxCount / this._xglobalmax), 1);
            this._xspace = this._itemWidth / (this._xglobalmax);
            this._yspace = this._itemHeight / (this._yglobalmax);
            this._space = Math.min(this._xspace, this._yspace);
            var maxShapeSize = Math.min(.85 * this._itemWidth / this._xglobalmax, .85 * this._itemHeight / this._yglobalmax);
            this._maxShapeSize = maxShapeSize; //   / dc.transformSizeFactor;
        };
        densityGrid.prototype.layoutDataForRecord = function (recordIndex, dc, dr) {
            var nv = dc.nvData;
            var rowIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[recordIndex]);
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var left = this._binLefts[binIndexX];
            var top = this._binTops[binIndexY];
            var cx = left + this._itemWidth / 2;
            var cy = top - this._itemHeight / 2;
            var binRelativeIndex = this._binRelativeIndexes[recordIndex] - 1;
            var countKey = binIndexX + "," + binIndexY;
            var binCount = 0;
            if (this._binCounts[countKey] === undefined) {
                binCount = 0;
            }
            else {
                binCount = this._binCounts[countKey];
            }
            var xlocalmax = Math.max(Math.ceil(Math.sqrt(binCount)), 1);
            var ylocalmax = Math.max(Math.ceil(binCount / xlocalmax), 1);
            var maxWidth = xlocalmax * this._space;
            var maxHeight = ylocalmax * this._space;
            var xrel = binRelativeIndex % xlocalmax;
            var yrel = Math.floor(binRelativeIndex / xlocalmax);
            dr.x = cx - maxWidth / 2.0 + xrel * this._space;
            dr.y = cy + maxHeight / 2.0 - yrel * this._space;
            dr.z = 0;
            dr.width = this._maxShapeSize;
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, recordIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, recordIndex, dc.scales.imageIndex);
        };
        return densityGrid;
    }(beachParty.baseLayoutClass));
    beachParty.densityGrid = densityGrid;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    densityRandom.ts - builds a density chart (2D histogram, with RANDOM layout within each heatmap tile). 
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var densityRandom = (function (_super) {
        __extends(densityRandom, _super);
        function densityRandom(chart) {
            _super.call(this, chart, "densityRandom");
            //---- all facet results ----
            this._xFacetBinResults = null;
            this._yFacetBinResults = null;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._hMargin = 0;
            this._vMargin = 0;
            this._hBetween = 0;
            this._vBetween = 0;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "xy";
        }
        /** Adjust scales as needed for our chart. */
        densityRandom.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._xFacetBinResults = [];
            this._yFacetBinResults = [];
            var xm = this._chart.xMapping();
            var ym = this._chart.yMapping();
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var xResults = beachParty.chartUtils.binTheDataForCount(dc, data, xm, "x");
                    this._xFacetBinResults.push(xResults);
                    var yResults = beachParty.chartUtils.binTheDataForCount(dc, data, ym, "y");
                    this._yFacetBinResults.push(yResults);
                }
            }
            else {
                var xResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, xm, "x");
                this._xFacetBinResults.push(xResults);
                var yResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, ym, "y");
                this._yFacetBinResults.push(yResults);
            }
            //---- adjust X scale ----
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, [xResults]);
            //---- adjust Y scale ----
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, [yResults]);
            return dc.filteredRecordCount;
        };
        densityRandom.prototype.assignRecordsToBins = function (nv, resultX, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignX = resultX.assignments;
            var allAssignY = resultY.assignments;
            var binIndexesX = [];
            var binIndexesY = [];
            var binCounts = {}; // will use string as our 3d index   (facet, x, y)
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            for (var i = 0; i < filter.length; i++) {
                var shapeIndex = i; // sri[i];        // process shape indexes, in sorted order
                if (!filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = allAssignX[shapeIndex];
                    var binIndexY = allAssignY[shapeIndex];
                    binIndexesX[shapeIndex] = binIndexX;
                    binIndexesY[shapeIndex] = binIndexY;
                    //---- we are called once for each facet, so we don't need that in our countKey anymore ----
                    var countKey = binIndexX + "," + binIndexY;
                    if (binCounts[countKey] === undefined) {
                        binCounts[countKey] = 0;
                    }
                    //binIndexes[shapeIndex] = binCounts[countKey];
                    binCounts[countKey] += 1;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    binIndexesX[shapeIndex] = 0;
                    binIndexesY[shapeIndex] = 0;
                }
            }
            //---- find max # of entries in any bin ----
            var maxCount = 0;
            var keys = vp.utils.keys(binCounts);
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var count = binCounts[key];
                maxCount = Math.max(count, maxCount);
            }
            var width = dc.width;
            var height = dc.height;
            var binsX = resultX.bins;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            //---- create bounds ----
            var binLefts = [];
            var binTops = [];
            var left = dc.x + this._hMargin;
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += (this._itemWidth + this._hBetween);
            }
            var top = (dc.y - height) + this._vMargin + this._itemHeight;
            for (var i = 0; i < binsY.length; i++) {
                binTops[i] = top;
                top += (this._itemHeight + this._vBetween);
            }
            this._binLefts = binLefts;
            this._binTops = binTops;
            this._binIndexesX = binIndexesX;
            this._binIndexesY = binIndexesY;
            return maxCount;
        };
        densityRandom.prototype.preLayoutLoop = function (dc) {
            var options = this._chartOptions;
            var nv = dc.nvData;
            //---- use pre-computed bins ----
            var xResult = this._xFacetBinResults[dc.facetIndex];
            var yResult = this._yFacetBinResults[dc.facetIndex];
            var xBinCount = xResult.bins.length;
            var yBinCount = yResult.bins.length;
            var width = dc.width;
            var height = dc.height;
            var hMargin = 2 * dc.itemSize;
            var hBetween = .1 * (dc.width / xBinCount);
            var vMargin = 2 * dc.itemSize;
            var vBetween = .2 * (dc.height / yBinCount);
            this._hMargin = hMargin;
            this._hBetween = hBetween;
            this._vMargin = vMargin;
            this._vBetween = vBetween;
            //---- compute itemWidth and itemHeight ----
            var itemWidth = (width - 2 * hMargin - (xBinCount - 1) * hBetween) / xBinCount;
            var itemHeight = (height - 2 * vMargin - (yBinCount - 1) * vBetween) / yBinCount;
            var ySpace = .1 * itemHeight;
            var binHeight = itemHeight - ySpace;
            this._itemWidth = itemWidth;
            this._itemHeight = itemHeight;
            var maxRecordsInABin = this.assignRecordsToBins(nv, xResult, yResult, dc);
            var rcBin = vp.geom.createRect(this._binLefts[0], this._binTops[0], this._itemWidth, this._itemHeight);
        };
        densityRandom.prototype.layoutDataForRecord = function (recordIndex, dc, dr) {
            var nv = dc.nvData;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (dc.layoutFilterVector && dc.layoutFilterVector[recordIndex]);
            var rowIndex = 0;
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            //var trueRecordIndex = nv.recordIndex[recordIndex];
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var left = this._binLefts[binIndexX];
            var top = this._binTops[binIndexY];
            var xr = nv.randomX.values[recordIndex];
            var yr = nv.randomY.values[recordIndex];
            dr.x = left + xr * this._itemWidth;
            dr.y = top - yr * this._itemHeight;
            dr.z = 0;
            dr.width = dc.maxShapeSize * this.scaleColData(nv.size, recordIndex, dc.scales.size, 1);
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, recordIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, recordIndex, dc.scales.imageIndex);
        };
        return densityRandom;
    }(beachParty.baseLayoutClass));
    beachParty.densityRandom = densityRandom;
    var sandDensityOptions = (function () {
        function sandDensityOptions(columns, rows, layout) {
            this.columns = columns;
            this.rows = rows;
            this.layout = layout;
        }
        return sandDensityOptions;
    }());
    beachParty.sandDensityOptions = sandDensityOptions;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    flatCircle.ts - builds a phylogenic circle (spiral) layout of sand shapes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var flatCircle = (function (_super) {
        __extends(flatCircle, _super);
        function flatCircle(chart) {
            _super.call(this, chart, "flatCircle");
            //_phyloSeed = 137.508;           // "golden angle"
            this._maxCount = 0;
            this._radius = 0;
            this._spacing = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape_center = { x: 0, y: 0 };
            this._center = { x: 0, y: 0 };
            this._maxShapeSize = 1;
            this._maxCountOverFacets = 0;
            this._visibleColPickers = "";
            this._visibleBinAdjusters = "";
            this._chartBuilder.hideAxes(true);
        }
        flatCircle.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            this._maxCountOverFacets = beachParty.chartUtils.computeMaxCountOverFacets(dc, nvFacetBuckets);
            return this._maxCountOverFacets;
        };
        flatCircle.prototype.preLayoutLoop = function (dc) {
            var margin = 2 * dc.maxShapeSize; //   dc.itemSize;
            var xSize = dc.width - (margin);
            var ySize = dc.height - (margin);
            this._maxCount = dc.filteredRecordCount;
            this._radius = Math.min(xSize, ySize);
            this._spacing = .5 * this._radius / Math.sqrt(this._maxCount);
            this._nextIndex = 0;
            this._center.x = dc.x + dc.width / 2;
            this._center.y = dc.y + dc.height / 2;
            this._maxShapeSize = beachParty.chartUtils.getScatterShapeSize(dc, this._maxCountOverFacets, this._chart);
        };
        flatCircle.prototype.layoutDataForRecord = function (i, dc, dr) {
            var nv = dc.nvData;
            var sp = this._chart.spiralParams();
            var filtered = (dc.layoutFilterVector && dc.layoutFilterVector[i]);
            var rowIndex = 0;
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            //---- filtered code can calc stuff here, but it will not be used ----
            var cx = this._center.x;
            var cy = this._center.y;
            var r = this._spacing * Math.sqrt(rowIndex);
            var theta = Math.PI / 180 * (rowIndex * sp.seed);
            dr.x = cx + r * Math.sin(theta);
            dr.y = cy + r * Math.cos(theta);
            dr.z = 0;
            dr.width = this._maxShapeSize * this.scaleColData(nv.size, i, dc.scales.size, 1);
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, i, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, i, dc.scales.imageIndex);
        };
        return flatCircle;
    }(beachParty.baseLayoutClass));
    beachParty.flatCircle = flatCircle;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    flatGrid.ts - builds a GROD 2d layout of sand shapes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var flatGrid = (function (_super) {
        __extends(flatGrid, _super);
        function flatGrid(chart) {
            _super.call(this, chart, "flatGrid");
            //---- all facets info ----
            this._maxCountAllFacets = 0;
            this._colCount = 0;
            this._rowCount = 0;
            this._nextIndex = 0;
            this._maxShapeWidth = 1;
            this._maxShapeHeight = 1;
            this._itemSize = 0;
            this._visibleColPickers = "y";
            this._visibleBinAdjusters = "";
            this._chartBuilder.hideAxes(true);
        }
        flatGrid.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            this._maxCountAllFacets = beachParty.chartUtils.computeMaxCountOverFacets(dc, nvFacetBuckets);
            this._itemSize = dc.itemSize;
            return this._maxCountAllFacets;
        };
        flatGrid.prototype.buildScales = function (nv, rcxWorld, filteredRecordCount, facetCount) {
            var result = this._chartBuilder.buildDefaultScales(nv, rcxWorld, filteredRecordCount, facetCount);
            var margin = this._itemSize / 4;
            var fp = this._chart.flatParams();
            //---- override X and Y scales - force the domain to [0..1] ----
            result.x = beachParty.cbUtils.makeLinearScale(0, 1, rcxWorld.left + margin, rcxWorld.right - margin);
            if (fp.buildFromTop) {
                result.y = beachParty.cbUtils.makeLinearScale(0, 1, rcxWorld.top - margin, rcxWorld.bottom + margin);
            }
            else {
                result.y = beachParty.cbUtils.makeLinearScale(0, 1, rcxWorld.bottom + margin, rcxWorld.top - margin);
            }
            return result;
        };
        flatGrid.prototype.preLayoutLoop = function (dc) {
            var maxCount = this._maxCountAllFacets;
            var fp = this._chart.flatParams();
            var colCount = fp.numColumns;
            if (!colCount) {
                //---- num of columns not specified by user; compute it so that shapes are square ----
                var aspect = dc.width / dc.height;
                colCount = Math.ceil(Math.sqrt(aspect * maxCount));
            }
            var rowCount = Math.ceil(maxCount / colCount);
            this._colCount = colCount;
            this._rowCount = rowCount;
            //---- use .85 to allow some space between shapes ----
            var spaceFactor = 1 - (.15 * this._chart.separationFactor());
            this._maxShapeWidth = spaceFactor * dc.width / this._colCount;
            this._maxShapeHeight = spaceFactor * dc.height / this._rowCount;
            this._nextIndex = 0;
        };
        /** "bufferIndex" in the 0-based indexed into the sorted data buffers. */
        flatGrid.prototype.layoutDataForRecord = function (bufferIndex, dc, dr) {
            //---- flat grid layout ----
            var nv = dc.nvData;
            var scales = dc.scales;
            var filtered = (dc.layoutFilterVector && dc.layoutFilterVector[bufferIndex]);
            //---- "layoutIndex" is the index into the FILTERED-IN shapes that are being layed out in this plot. */
            var layoutIndex = 0;
            if (!filtered) {
                layoutIndex = this._nextIndex++;
            }
            var xData = layoutIndex % this._colCount;
            var yData = Math.floor(layoutIndex / this._colCount);
            dr.x = scales.x.scale((xData + .5) / this._colCount);
            dr.y = scales.y.scale((yData + .5) / this._rowCount);
            dr.z = 0;
            var sizeFactor = this.scaleColData(nv.size, bufferIndex, dc.scales.size, 1);
            dr.width = this._maxShapeWidth * sizeFactor;
            dr.height = this._maxShapeHeight * sizeFactor;
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, bufferIndex, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, bufferIndex, dc.scales.imageIndex);
        };
        return flatGrid;
    }(beachParty.baseLayoutClass));
    beachParty.flatGrid = flatGrid;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    flatRandom.ts - builds a random 2d layout of sand shapes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var flatRandom = (function (_super) {
        __extends(flatRandom, _super);
        function flatRandom(chart) {
            _super.call(this, chart, "flatRandom");
            this._randomX = [];
            this._randomY = [];
            this._maxShapeSize = 1;
            this._nextRandIndex = 0;
            this._itemSize = 0;
            this._visibleColPickers = "";
            this._visibleBinAdjusters = "";
            this._chartBuilder.hideAxes(true);
        }
        flatRandom.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            this._itemSize = dc.maxShapeSize; // dc.itemSize;
            return _super.prototype.computeFacetStats.call(this, dc, nvFacetBuckets);
        };
        flatRandom.prototype.buildScales = function (nv, rcxWorld, filteredRecordCount, facetCount) {
            var result = this._chartBuilder.buildDefaultScales(nv, rcxWorld, filteredRecordCount, facetCount);
            var itemSize = this._itemSize;
            //---- override X and Y scales - force the domain to [0..1] ----
            result.x = beachParty.cbUtils.makeLinearScale(0, 1, rcxWorld.left + itemSize, rcxWorld.right - itemSize);
            result.y = beachParty.cbUtils.makeLinearScale(0, 1, rcxWorld.bottom + itemSize, rcxWorld.top - itemSize);
            return result;
        };
        flatRandom.prototype.preLayoutLoop = function (dc) {
            this._maxShapeSize = dc.maxShapeSize;
            this._nextRandIndex = 0;
        };
        flatRandom.prototype.layoutDataForRecord = function (i, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            var ri = 0;
            if (dc.layoutFilterVector && (!dc.layoutFilterVector[i])) {
                ri = this._nextRandIndex++;
            }
            var xr = nv.randomX.values[ri];
            var yr = nv.randomY.values[ri];
            dr.x = scales.x.scale(xr);
            dr.y = scales.y.scale(yr);
            dr.z = 0;
            dr.width = this._maxShapeSize * this.scaleColData(nv.size, i, scales.size, 1);
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, i, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, i, dc.scales.imageIndex);
        };
        return flatRandom;
    }(beachParty.baseLayoutClass));
    beachParty.flatRandom = flatRandom;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    linePlot.ts - builds a 2D line plot from pairs of records describing the FROM and TO positions.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var linePlotClass = (function (_super) {
        __extends(linePlotClass, _super);
        function linePlotClass(chart, useLinePrim, useLinePairs) {
            _super.call(this, chart, "linePlot");
            this._ptLast = null;
            this._inverseSizeFactor = 0;
            this._useLinePrim = false;
            this._useLinePairs = false;
            this._useLinePrim = useLinePrim;
            this._useLinePairs = useLinePairs;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "";
            if (useLinePairs) {
                var shapeEng = this._chartBuilder.getShapeEngine();
                shapeEng.overrideDrawPrimitive(beachParty.DrawPrimitive.linePairs);
            }
        }
        linePlotClass.prototype.preLayoutLoop = function (dc) {
            this._ptLast = null;
            this._inverseSizeFactor = 1 / dc.userSizeFactor; // / dc.combinedSizeFactor;
            //this._uniformsChanged.lines = true;
        };
        linePlotClass.prototype.positionLine = function (x1, y1, x2, y2) {
            var xdiff = x1 - x2;
            var ydiff = y1 - y2;
            var width = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
            var cx = (x1 + x2) / 2;
            var cy = (y1 + y2) / 2;
            var theta = Math.atan2(ydiff, xdiff);
            return { cx: cx, cy: cy, width: width, theta: theta };
        };
        linePlotClass.prototype.layoutDataForRecord = function (i, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            var sx = this.scaleColData(nv.x, i, scales.x);
            var sy = this.scaleColData(nv.y, i, scales.y);
            var sz = this.scaleColData(nv.size, i, scales.size, 1);
            if (this._useLinePrim) {
                dr.x = sx;
                dr.y = sy;
                dr.width = sz;
                dr.height = dr.width;
            }
            else {
                if (this._ptLast == null) {
                    dr.x = 0;
                    dr.y = 0;
                    dr.width = 0;
                    dr.height = 0;
                }
                else {
                    var result = this.positionLine(sx, sy, this._ptLast.x, this._ptLast.y);
                    dr.x = result.cx;
                    dr.y = result.cy;
                    dr.width = sz * this._inverseSizeFactor * result.width; // prevent shader from scaling this width
                    dr.height = .005; // 1;
                    dr.theta = result.theta;
                }
            }
            dr.z = -0; // for correct rotation about Y axis
            dr.depth = dc.defaultDepth2d; // test out 3d cube in a 2d shape
            dr.colorIndex = this.scaleColData(nv.colorIndex, i, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, i, dc.scales.imageIndex);
            this._ptLast = { x: sx, y: sy };
        };
        return linePlotClass;
    }(beachParty.baseLayoutClass));
    beachParty.linePlotClass = linePlotClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    partyGenPlot.ts - creates a custom plot based on recursive binning and space division, as 
//          developed in the PartyGen tool.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var partyGenPlotClass = (function (_super) {
        __extends(partyGenPlotClass, _super);
        function partyGenPlotClass(chart, chartType) {
            _super.call(this, chart, "partyGenPlot");
            //---- all facets info ----
            this._maxCountAllFacets = 0;
            this._maxShapeSize = 0;
            this._nextInFilterIndex = 0;
            this._fillCell = false; // whether shapes should fill their layout cells
            this._chartType = chartType;
            this._dataDivider1 = new beachParty.DataDivider();
            this._dataDivider2 = new beachParty.DataDivider();
            this._dataDivider3 = new beachParty.DataDivider();
            this._dataDivider4 = new beachParty.DataDivider();
            this._spaceDivider1 = new beachParty.SpaceDivider();
            this._spaceDivider2 = new beachParty.SpaceDivider();
            this._spaceDivider3 = new beachParty.SpaceDivider();
            this._spaceDivider4 = new beachParty.SpaceDivider();
            if (chartType == "FlatSquarify") {
                this._visibleColPickers = "y";
                this._visibleBinAdjusters = "";
            }
            this._shapeMaker = new beachParty.ShapeMaker(null, beachParty.ShapeType.none);
        }
        partyGenPlotClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            this._maxCountAllFacets = beachParty.chartUtils.computeMaxCountOverFacets(dc, nvFacetBuckets);
            //---- call this now so that "this._hideAxes" gets set in time to take effect ----
            this.applyPresets(dc);
            return this._maxCountAllFacets;
        };
        partyGenPlotClass.prototype.applyPresets = function (dc) {
            this.resetDividersAndShapes(dc);
            var chartType = this._chartType;
            var xm = this._chart.xMapping();
            var ym = this._chart.yMapping();
            var chart = this._chart;
            var chartBuilder = this._chartBuilder;
            this._fillCell = false;
            if (chartType == "Scatter") {
                this._spaceDivider4.spaceType = beachParty.SpaceType.plotXY;
            }
            else if (chartType == "FlatCircle") {
                this._spaceDivider4.spaceType = beachParty.SpaceType.fillOut;
                chartBuilder.hideAxes(true);
            }
            else if (chartType == "FlatGrid") {
                this._spaceDivider4.spaceType = beachParty.SpaceType.packXY;
                this._spaceDivider4.reverse = true; // flipped Y
                chartBuilder.hideAxes(true);
            }
            else if (chartType == "FlatRandom") {
                this._spaceDivider4.spaceType = beachParty.SpaceType.random;
                chartBuilder.hideAxes(true);
            }
            else if (chartType == "FlatSquarify") {
                //var marginBase = dc.width / 5000;
                //if (this._facetHelper)
                //{
                //    marginBase *= 5;
                //}
                //var cellMargin = view.separationFactor() * marginBase;       // (dc.filteredRecordCount) ? (dc.width / Math.sqrt(dc.filteredRecordCount)) : 0;
                this._spaceDivider4.spaceType = beachParty.SpaceType.squarify;
                this._spaceDivider4.cellMargin = dc.spacingFactor;
                chartBuilder.hideAxes(true);
                this._fillCell = true;
            }
            else if (chartType == "FlatPoisson") {
                this._spaceDivider4.spaceType = beachParty.SpaceType.poisson;
                chartBuilder.hideAxes(true);
            }
            else if (chartType == "ColumnGrid") {
                this._dataDivider3.colName = xm.colName;
                this._dataDivider3.groupCount = xm.binCount;
                this._dataDivider3.groupSorting = xm.binSorting;
                this._spaceDivider3.spaceType = beachParty.SpaceType.fillX;
                this._spaceDivider3.cellMargin = dc.width / 50;
                this._spaceDivider4.spaceType = beachParty.SpaceType.packXY;
                this._spaceDivider4.reverse = true; // flipped Y
                chartBuilder.hideAxes(true);
            }
            else if (chartType == "BarGrid") {
                this._dataDivider3.colName = ym.colName;
                this._dataDivider3.groupCount = ym.binCount;
                this._dataDivider3.groupSorting = ym.binSorting;
                this._spaceDivider3.spaceType = beachParty.SpaceType.fillY;
                this._spaceDivider3.cellMargin = dc.width / 50;
                //this._spaceDivider3.reverse = true; 
                this._spaceDivider4.spaceType = beachParty.SpaceType.packYX;
                this._spaceDivider4.reverse = true; // flipped Y
                chartBuilder.hideAxes(true);
            }
        };
        partyGenPlotClass.prototype.resetDividersAndShapes = function (dc) {
            this._chartBuilder.hideAxes(false);
            if (this._chartType == "FlatSquarify") {
                //---- this is still messy while chart type /layout design in flux ----
                var primaryCol = this._chart.auxMapping().colName;
                if (!primaryCol) {
                    primaryCol = this._chart.xMapping().colName;
                }
            }
            else {
                var primaryCol = this._chart.xMapping().colName;
            }
            var secondaryCol = this._chart.yMapping().colName;
            this._spaceDivider1.xStat.colName = primaryCol;
            this._spaceDivider2.xStat.colName = primaryCol;
            this._spaceDivider3.xStat.colName = primaryCol;
            this._spaceDivider4.xStat.colName = primaryCol;
            this._spaceDivider1.yStat.colName = secondaryCol;
            this._spaceDivider2.yStat.colName = secondaryCol;
            this._spaceDivider3.yStat.colName = secondaryCol;
            this._spaceDivider4.yStat.colName = secondaryCol;
            this._dataDivider1.colName = primaryCol;
            this._dataDivider2.colName = primaryCol;
            this._dataDivider3.colName = primaryCol;
            this._dataDivider1.groupCount = 5;
            this._dataDivider2.groupCount = 5;
            this._dataDivider3.groupCount = 5;
            beachParty.maxContainers = 0; // off by default
            this._spaceDivider1.margin = 0;
            this._spaceDivider2.margin = 0;
            this._spaceDivider3.margin = 0;
            this._spaceDivider4.margin = 0;
            this._spaceDivider1.cellMargin = 0;
            this._spaceDivider2.cellMargin = 0;
            this._spaceDivider3.cellMargin = 0;
            this._spaceDivider4.cellMargin = 0;
            this._spaceDivider1.spaceType = beachParty.SpaceType.none;
            this._spaceDivider2.spaceType = beachParty.SpaceType.none;
            this._spaceDivider3.spaceType = beachParty.SpaceType.none;
            this._spaceDivider4.spaceType = beachParty.SpaceType.packXY;
            this._spaceDivider1.reverse = false;
            this._spaceDivider2.reverse = false;
            this._spaceDivider3.reverse = false;
            this._spaceDivider4.reverse = false;
            this._spaceDivider1.hAlign = beachParty.HAlign.left;
            this._spaceDivider2.hAlign = beachParty.HAlign.left;
            this._spaceDivider3.hAlign = beachParty.HAlign.left;
            this._spaceDivider4.hAlign = beachParty.HAlign.left;
            this._spaceDivider1.vAlign = beachParty.VAlign.bottom;
            this._spaceDivider2.vAlign = beachParty.VAlign.bottom;
            this._spaceDivider3.vAlign = beachParty.VAlign.bottom;
            this._spaceDivider4.vAlign = beachParty.VAlign.bottom;
            this._spaceDivider1.xStat.peerScale = false;
            this._spaceDivider2.xStat.peerScale = false;
            this._spaceDivider3.xStat.peerScale = false;
            this._spaceDivider4.xStat.peerScale = false;
            this._spaceDivider1.yStat.peerScale = false;
            this._spaceDivider2.yStat.peerScale = false;
            this._spaceDivider3.yStat.peerScale = false;
            this._spaceDivider4.yStat.peerScale = false;
        };
        partyGenPlotClass.prototype.addDivider = function (dividers, dd, sd, layers) {
            if (layers === void 0) { layers = []; }
            var divider = new beachParty.ChartDivider();
            divider.dd = dd;
            divider.sd = sd;
            divider.shapeLayers = layers;
            dividers.push(divider);
            return divider;
        };
        /** called for each facet. */
        partyGenPlotClass.prototype.preLayoutLoop = function (dc) {
            this.applyPresets(dc);
            this._maxShapeSize = dc.maxShapeSize;
            this._shapeMaker.shapeSize = this._maxShapeSize;
            this._spaceDivider4.xRandom = (dc.nvData.randomX) ? dc.nvData.randomX.values : null;
            this._spaceDivider4.yRandom = (dc.nvData.randomY) ? dc.nvData.randomY.values : null;
            var rc = vp.geom.createRect(dc.x, dc.y, dc.width, dc.height);
            //---- build "dividers" ----
            var dividers = [];
            if (this._dataDivider1.colName && this._spaceDivider1.spaceType != beachParty.SpaceType.none) {
                this.addDivider(dividers, this._dataDivider1, this._spaceDivider1);
            }
            if (this._dataDivider2.colName && this._spaceDivider2.spaceType != beachParty.SpaceType.none) {
                this.addDivider(dividers, this._dataDivider2, this._spaceDivider2);
            }
            if (this._dataDivider3.colName && this._spaceDivider3.spaceType != beachParty.SpaceType.none) {
                this.addDivider(dividers, this._dataDivider3, this._spaceDivider3);
            }
            if (this._spaceDivider4.spaceType != beachParty.SpaceType.none) {
                this.addDivider(dividers, this._dataDivider4, this._spaceDivider4);
            }
            //---- get a dataFrame of the records for this facet ----
            var facetIndexes = null;
            if (dc.facetHelper) {
                facetIndexes = dc.facetHelper.binResult().bins[dc.facetIndex].rowIndexes;
            }
            var origDataFrame = this._chart.getDataFrame();
            var dataFrame = origDataFrame.copyData(facetIndexes);
            if (dc.filteredRecordCount != dc.recordCount) {
                var indexes = [];
                var filter = dc.layoutFilterVector;
                var count = dataFrame.getRecordCount();
                //---- filter data before layout ----
                for (var i = 0; i < count; i++) {
                    if (!filter[i]) {
                        indexes.push(i);
                    }
                }
                dataFrame = dataFrame.copyData(indexes);
            }
            //---- build the rcArray's for each container ----
            this.genLayout(null, rc, dataFrame, dividers, 0);
            this._nextInFilterIndex = 0;
        };
        partyGenPlotClass.prototype.genLayout = function (svg, rc, dataFrame, dividers, divideLevel) {
            //var shapeMakers = [shapeMaker];
            //---- GENERATE containers ----
            var root = new beachParty.Container(dataFrame, 0);
            root.binAndGen(dividers);
            //---- MEASURE sizes & stats ----
            var results = root.measure(dividers);
            //---- LAYOUT all containers ----
            var leafRcArray = [];
            var cellData = beachParty.CellData.fromRect(rc, beachParty.CellShape.rectangle);
            root.layout(dividers, cellData, results.scaleData, svg, leafRcArray);
            this._leafRcArray = leafRcArray;
        };
        partyGenPlotClass.prototype.layoutDataForRecord = function (i, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            var filter = dc.layoutFilterVector;
            if (!filter[i]) {
                //---- IN FILTER - give it the next rcArray ----
                var index = this._nextInFilterIndex++;
                var cellData = this._leafRcArray[index];
                var rc = cellData.rect;
            }
            else {
                //---- OUT OF FILTER; give it default rc ----
                var rc = vp.geom.createRect(0, 0, 1, 1);
            }
            var isRect = false; // (shapeType == ShapeType.rectangle);
            if (this._fillCell) {
                dr.width = rc.width; // / dc.userSizeFactor;       // dc.combinedSizeFactor;
                dr.height = rc.height; // / dc.userSizeFactor;     // dc.combinedSizeFactor;
            }
            else {
                dr.width = this._maxShapeSize * this.scaleColData(nv.size, i, scales.size, 1);
                dr.height = dr.width;
            }
            dr.depth = dc.defaultDepth2d;
            //---- center drawing within cell ----
            dr.x = rc.left + rc.width / 2;
            //---- work around facet vs. non-facet inconsistency in bottom/top usage ----
            dr.y = Math.min(rc.bottom, rc.top) + rc.height / 2; // rc.top
            dr.z = 0;
            if (isRect) {
                dr.x -= dr.width / 2;
                dr.y -= dr.height / 2;
            }
            dr.colorIndex = this.scaleColData(nv.colorIndex, i, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, i, dc.scales.imageIndex);
        };
        return partyGenPlotClass;
    }(beachParty.baseLayoutClass));
    beachParty.partyGenPlotClass = partyGenPlotClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    sandRadial.ts - builds a 2D scatter plot of sand shapes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var radialClass = (function (_super) {
        __extends(radialClass, _super);
        function radialClass(chart) {
            _super.call(this, chart, "radial");
            this._cx = 0;
            this._cy = 0;
            this._maxShapeSize = 1;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "";
            this._chartBuilder.hideAxes(true);
        }
        radialClass.prototype.buildScales = function (nv, rcxWorld, filteredRecordCount, facetCount) {
            //---- modify X and Y scales - force the RANGE to [0..2*PI], [0..maxRadius] ----
            var maxRadius = Math.min(rcxWorld.width / 2, rcxWorld.height / 2);
            var rcx = beachParty.cbUtils.cloneMap(rcxWorld);
            //---- scales.x RANGE: 0-2*PI ----
            rcx.left = 0;
            rcx.right = 2 * Math.PI;
            rcx.width = rcxWorld.right - rcxWorld.left;
            //---- scales.y RANGE: 0-maxRadius ----
            rcx.top = maxRadius;
            rcx.bottom = 0;
            rcx.height = rcxWorld.top - rcxWorld.bottom;
            var result = this._chartBuilder.buildDefaultScales(nv, rcx, filteredRecordCount, facetCount);
            return result;
        };
        radialClass.prototype.preLayoutLoop = function (dc) {
            this._cx = dc.x + dc.width / 2;
            this._cy = dc.y + dc.height / 2;
            this._maxShapeSize = dc.maxShapeSize;
        };
        radialClass.prototype.layoutDataForRecord = function (i, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            var theta = -(Math.PI / 2 + this.scaleColData(nv.x, i, scales.x));
            var radius = this.scaleColData(nv.y, i, scales.y);
            dr.x = this._cx + radius * Math.cos(theta);
            dr.y = this._cy + radius * Math.sin(theta);
            dr.z = 0;
            dr.width = this._maxShapeSize * this.scaleColData(nv.size, i, scales.size, 1);
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, i, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, i, dc.scales.imageIndex);
        };
        return radialClass;
    }(beachParty.baseLayoutClass));
    beachParty.radialClass = radialClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    scatterPlot.ts - builds a 2D scatter plot of sand shapes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    ///-------------------------------------------------------------------------------------------------------------------------------------
    /// Chart Layout rules:
    ///     1. to honor the 2-stage filter, only layout the records not removed by dc.layoutFilterVector.
    ///     2. dc.filteredRecordCount correctly counts the filtered-in records (as per the 2-stage filter)
    ///     3. honor facets by using dc.x, dc.y, dc.width, dc.height for the bounds of the facet/chart
    ///     4. CAUTION with overriding "buildScales()" since it is called TWICE (computeFacetStats & final scales) (not per facet)
    ///     5. If you build info for shapes, be consistent with its index (suggest using true shapeIndex rather than facet-relative index)
    ///     6. use "computeFacetStats(dc, data)" for operations across facets (like maxBinCount used by Column chart) AND to adjust scales.
    ///-------------------------------------------------------------------------------------------------------------------------------------
    ///-------------------------------------------------------------------------------------------------------------------------------------
    /// CAUTION: the below info is this comment needs to be checked for accuracy (as of 9/18/2016) - rfernand.
    ///
    /// chartBuilder layout steps: (charts should override the CHART.xxx() calls)
    ///     - prepassAndFrameBuild()
    ///         - buildNamedVectors()
    ///
    ///         - //---- build PREPASS info ----
    ///         - updateChartBounds()       // with 0 size chartFrame
    ///         - calcRanges()
    ///         - buildScales()
    ///         - dc = new DrawContext()
    ///         - CHART.computeFacetStats()               // chart should compute stats across all facets
    ///         - CHART.adjustScales()
    ///         - chartFrameHelper.build()      // build Y and X axes
    ///
    ///         - //---- build FINAL info ----
    ///         - updateChartBounds()           // finalize space for plot area
    ///         - calcRanges()
    ///         - buildScales()                 // build scales using finalized space
    ///         - dc = new DrawContext()
    ///         - CHART.adjustScales()          // adjust scales
    ///     - getAttributesForCycle()
    ///     - getNamedBuffers()
    ///     - for each facet:
    ///         - layoutChartOrFacet()              
    ///             - CHART.preLayoutLoop()
    ///             - for each record:
    ///                 - CHART.layoutDataForRecord()
    ///                 - processRecord()
    ///                 - fillBuffersForRecord()
    ///             - fillGridLinesBuffer()
    ///-------------------------------------------------------------------------------------------------------------------------------------
    var scatterPlotClass = (function (_super) {
        __extends(scatterPlotClass, _super);
        function scatterPlotClass(chart) {
            _super.call(this, chart, "scatterPlot");
            this._maxShapeSize = 0;
            this._halfSizeSize = 0;
            this._z = 0;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "";
        }
        scatterPlotClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            //---- this call modifies the PREPASS scales (for use by the chart frame) ----
            this.modifyXYScales(dc);
            return dc.filteredRecordCount;
        };
        scatterPlotClass.prototype.modifyXYScales = function (dc, halfShapeSize) {
            //---- add spacing on both sides of X and Y scales to keep shapes within the borders ----
            if (halfShapeSize != undefined) {
                var xExpand = halfShapeSize;
                var yExpand = halfShapeSize;
            }
            else {
                var sp = this._chart.scatterParams();
                var shapeSize = dc.maxShapeSize;
                if (sp) {
                    var xExpand = sp.percentExpandX * shapeSize;
                    var yExpand = sp.percentExpandY * shapeSize;
                }
                else {
                    var xExpand = .5 * shapeSize;
                    var yExpand = .5 * shapeSize;
                }
            }
            //---- note: expandSpace() for scale in specifed in range units (world units, in this case) ----
            dc.scales.x
                .expandSpace(xExpand);
            dc.scales.y
                .expandSpace(yExpand);
            this._halfSizeSize = xExpand;
        };
        scatterPlotClass.prototype.preLayoutLoop = function (dc) {
            //---- this call modifies the FINAL scales (for use by our X/Y mapping) ----
            this.modifyXYScales(dc, this._halfSizeSize);
            this._maxShapeSize = dc.maxShapeSize;
            //---- place our 2D place in middle of Z space ----
            this._z = dc.z + dc.depth / 2;
        };
        /** "bufferIndex" in the 0-based indexed into the sorted data buffers. */
        scatterPlotClass.prototype.layoutDataForRecord = function (bufferIndex, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            dr.x = this.scaleColData(nv.x, bufferIndex, scales.x);
            dr.y = this.scaleColData(nv.y, bufferIndex, scales.y);
            dr.z = this._z; // for correct rotation about Y axis
            dr.width = this._maxShapeSize * this.scaleColData(nv.size, bufferIndex, scales.size, 1);
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, bufferIndex, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, bufferIndex, dc.scales.imageIndex);
        };
        return scatterPlotClass;
    }(beachParty.baseLayoutClass));
    beachParty.scatterPlotClass = scatterPlotClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    scatterplot3d.ts - builds a 3D scatter plot.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var scatterPlot3dClass = (function (_super) {
        __extends(scatterPlot3dClass, _super);
        function scatterPlot3dClass(chart) {
            _super.call(this, chart, "scatterPlot3d");
            this._maxShapeSize = 0;
            this._visibleColPickers = "xyz";
            this._visibleBinAdjusters = "";
            var transformMgr = this._chartBuilder.getTransformMgr();
            //---- zoom camera out a bit so we can see full bounding box ----
            transformMgr.scaleCameraRelative(1 / 1.3, { x: 0, y: 0 });
            this._is3dChart = true;
        }
        scatterPlot3dClass.prototype.preLayoutLoop = function (dc) {
            this._maxShapeSize = dc.maxShapeSize; //  chartUtils.getScatterShapeSize(dc);
        };
        scatterPlot3dClass.prototype.layoutDataForRecord = function (i, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            dr.x = this.scaleColData(nv.x, i, scales.x);
            dr.y = this.scaleColData(nv.y, i, scales.y);
            dr.z = this.scaleColData(nv.z, i, scales.z);
            dr.width = this._maxShapeSize * this.scaleColData(nv.size, i, scales.size, 1);
            dr.height = dr.width;
            dr.depth = dr.width; // .1 / dc.combinedSizeFactor;
            dr.colorIndex = this.scaleColData(nv.colorIndex, i, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, i, dc.scales.imageIndex);
        };
        return scatterPlot3dClass;
    }(beachParty.baseLayoutClass));
    beachParty.scatterPlot3dClass = scatterPlot3dClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    stacksBins.ts - builds a stacked (in Z) 2D histogram, wheere each stack in a set of NxN substacks.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var stacksBinClass = (function (_super) {
        __extends(stacksBinClass, _super);
        function stacksBinClass(chart) {
            _super.call(this, chart, "stacksBin");
            //---- all facet results ----
            this._xFacetBinResults = null;
            this._yFacetBinResults = null;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._hMargin = 0;
            this._vMargin = 0;
            this._hBetween = 0;
            this._vBetween = 0;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "xyz";
            var transformMgr = this._chartBuilder.getTransformMgr();
            //---- initially rotate about X axis 45 degrees for perspective view ----
            transformMgr.rotateMatrixX(Math.PI / 4.0, false, false);
            //---- zoom camera out a bit so we can see full bounding box ----
            transformMgr.scaleCameraRelative(1 / 1.3, { x: 0, y: 0 });
            this._is3dChart = true;
        }
        /** Adjust scales as needed for our chart. */
        stacksBinClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._xFacetBinResults = [];
            this._yFacetBinResults = [];
            var xm = this._chart.xMapping();
            var ym = this._chart.yMapping();
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for CONSISTENT facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
                beachParty.chartUtils.setFilteredMinMaxBreak(ym, dc.layoutFilterVector, dc.nvData.y);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var xResults = beachParty.chartUtils.binTheDataForCount(dc, data, xm, "x");
                    this._xFacetBinResults.push(xResults);
                    var yResults = beachParty.chartUtils.binTheDataForCount(dc, data, ym, "y");
                    this._yFacetBinResults.push(yResults);
                }
            }
            else {
                var allData = dc.nvData;
                var xResults = beachParty.chartUtils.binTheDataForCount(dc, allData, xm, "x");
                this._xFacetBinResults.push(xResults);
                var yResults = beachParty.chartUtils.binTheDataForCount(dc, allData, ym, "y");
                this._yFacetBinResults.push(yResults);
            }
            //---- adjust X scale ----
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, [xResults]);
            //---- adjust Y scale ----
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, [yResults]);
            return dc.filteredRecordCount;
        };
        stacksBinClass.prototype.assignRecordsToBins = function (nv, resultX, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var binWidthCount = this._chart.zMapping().binCount;
            var binHeightCount = this._chart.zMapping().binCount;
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignX = resultX.assignments;
            var allAssignY = resultY.assignments;
            var binIndexesX = [];
            var binIndexesY = [];
            var stackIndexes = [];
            var binCounts = {}; // will use string as our 3d index   (facet, x, y)
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            for (var i = 0; i < filter.length; i++) {
                var shapeIndex = i; // sri[i];        // process shape indexes, in sorted order
                if (!filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = allAssignX[shapeIndex];
                    var binIndexY = allAssignY[shapeIndex];
                    binIndexesX[shapeIndex] = binIndexX;
                    binIndexesY[shapeIndex] = binIndexY;
                    //---- we are called once for each facet, so we don't need that in our countKey anymore ----
                    var countKey = binIndexX + "," + binIndexY;
                    if (binCounts[countKey] === undefined) {
                        binCounts[countKey] = 0;
                    }
                    stackIndexes[shapeIndex] = binCounts[countKey];
                    binCounts[countKey] += 1;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    binIndexesX[shapeIndex] = 0;
                    binIndexesY[shapeIndex] = 0;
                    stackIndexes[shapeIndex] = 0;
                }
            }
            //---- find max # of entries in any bin ----
            var maxCount = 0;
            var keys = vp.utils.keys(binCounts);
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var count = binCounts[key];
                maxCount = Math.max(count, maxCount);
            }
            //---- number of cubes in a stack should be a whole number ----
            var maxCubesInAStack = Math.ceil(maxCount / (binWidthCount * binHeightCount));
            this._maxCubesInAStack = maxCubesInAStack;
            var binDepth = dc.depth / maxCubesInAStack;
            //binDepth = Math.min(this._itemWidth, this._itemHeight, binDepth);
            this._binDepth = binDepth;
            /*
            var totalZHeight = 4;
            this._binDepth = totalZHeight / maxCount;
            this._itemDepth = .9 * this._binDepth;           // .9 * this._binDepth;
            */
            var width = dc.width;
            var height = dc.height;
            var binsX = resultX.bins;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            //---- create bounds ----
            var binLefts = [];
            var binTops = [];
            var left = dc.x + this._hMargin;
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += (this._binWidth + this._hBetween);
            }
            var top = dc.y + this._vMargin + this._binHeight;
            for (var i = 0; i < binsY.length; i++) {
                binTops[i] = top;
                top += (this._binHeight + this._vBetween);
            }
            this._binLefts = binLefts;
            this._binTops = binTops;
            this._binIndexesX = binIndexesX;
            this._binIndexesY = binIndexesY;
            this._stackIndexes = stackIndexes;
            return maxCount;
        };
        stacksBinClass.prototype.preLayoutLoop = function (dc) {
            var binWidthCount = this._chart.zMapping().binCount;
            var binHeightCount = this._chart.zMapping().binCount;
            var options = this._chartOptions;
            var nv = dc.nvData;
            //---- use pre-computed bins ----
            var xResult = this._xFacetBinResults[dc.facetIndex];
            var yResult = this._yFacetBinResults[dc.facetIndex];
            var xBinCount = xResult.bins.length;
            var yBinCount = yResult.bins.length;
            var width = dc.width;
            var height = dc.height;
            var hMargin = 2 * dc.itemSize;
            var hBetween = .1 * (dc.width / xBinCount);
            var vMargin = 2 * dc.itemSize;
            var vBetween = .2 * (dc.height / yBinCount);
            this._hMargin = hMargin;
            this._hBetween = hBetween;
            this._vMargin = vMargin;
            this._vBetween = vBetween;
            //---- compute itemWidth and itemHeight ----
            var binWidth = (width - 2 * hMargin - (xBinCount - 1) * hBetween) / xBinCount;
            var binHeight = (height - 2 * vMargin - (yBinCount - 1) * vBetween) / yBinCount;
            var ySpace = .1 * binHeight;
            var binHeight = binHeight - ySpace;
            //---- limit size, so we don't get slow ----
            this._binWidth = binWidth;
            this._binHeight = binHeight;
            var innerMargin = .001; // ??? what should inner margin be?
            var innerBetween = .001; // ?? what should innerBetween be?
            var potItemWidth = (binWidth - 2 * innerMargin - (binWidthCount - 1) * innerBetween) / binWidthCount;
            var potItemHeight = (binHeight - 2 * innerMargin - (binHeightCount - 1) * innerBetween) / binHeightCount;
            this._itemWidth = Math.min(potItemWidth, potItemHeight);
            this._itemHeight = Math.min(potItemWidth, potItemHeight);
            // this._itemWidth = Math.min(.2, binWidth);
            // this._itemHeight = Math.min(.2, binHeight);
            this._space = Math.min(1.1 * this._itemWidth, 1.1 * this._itemHeight);
            this._leftOff = (binWidth - this._itemWidth) / 2;
            this._topOff = (binHeight - this._itemHeight) / 2;
            var maxRecordsInABin = this.assignRecordsToBins(nv, xResult, yResult, dc);
            var rcBin = vp.geom.createRect(this._binLefts[0], this._binTops[0], this._binWidth, this._binHeight);
        };
        stacksBinClass.prototype.layoutDataForRecord = function (recordIndex, dc, dr) {
            var stackWidth = this._chart.zMapping().binCount;
            var stackHeight = this._chart.zMapping().binCount;
            var nv = dc.nvData;
            var filtered = (dc.layoutFilterVector && dc.layoutFilterVector[recordIndex]);
            var rowIndex = 0;
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            //var trueRecordIndex = nv.recordIndex[recordIndex];
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var left = this._binLefts[binIndexX];
            var top = this._binTops[binIndexY];
            //---- stackIndex in an index into a 1x1 stack; must adjust for our stackWidth and stackHeight ----
            var stackIndex = this._stackIndexes[recordIndex];
            var zlocalmax = stackWidth * stackHeight;
            var layernum = Math.floor(stackIndex / zlocalmax);
            var layerindex = stackIndex % zlocalmax;
            var xrel = layerindex % stackWidth;
            var yrel = Math.floor(layerindex / stackWidth);
            dr.x = left + (xrel * this._space);
            dr.y = top + (yrel * this._space);
            // var z = -2.0 + (layernum * this._itemHeight * 1.1);
            dr.width = Math.abs(this._itemWidth);
            dr.height = Math.abs(this._itemHeight);
            var stackDepth = this._binDepth;
            if (this._chartOptions.layout == "Cubes") {
                //----- make the shapes as close to cubes as possible ----
                stackDepth = 1.1 * Math.abs(dr.width);
                dr.depth = dr.width;
            }
            else {
                //----- try to make the tallest column fill our z-range (this is the current "Stacks" view) ----
                //---- support for variable size columns (most useful if stackcount=1) ----
                if (nv.size && nv.size.count) {
                    dr.width = dr.width * this.scaleColData(nv.size, recordIndex, dc.scales.size, 1);
                    dr.height = dr.width;
                }
                //---- this keeps the shapes from becomming too distorted, so we don't always fill the space ----
                stackDepth = Math.min(this._binDepth, dr.width);
                dr.depth = .9 * stackDepth;
            }
            dr.z = dc.z + (layernum * stackDepth) + stackDepth / 2;
            dr.colorIndex = this.scaleColData(nv.colorIndex, recordIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, recordIndex, dc.scales.imageIndex);
        };
        return stacksBinClass;
    }(beachParty.baseLayoutClass));
    beachParty.stacksBinClass = stacksBinClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    trueCustom.ts - builds a generalized custom chart from specified parameters.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var trueCustomClass = (function (_super) {
        __extends(trueCustomClass, _super);
        function trueCustomClass(chart) {
            _super.call(this, chart, "trueCustom");
            this._xFacetBinResults = null;
            this._yFacetBinResults = null;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._isFlat = false; // true if no bins are defined 
            //---- for spiral layout ----
            this._radius = 0;
            this._spacing = 0;
            this._center = { x: 0, y: 0 };
            //---- indexed by countKey, holds an array of pts for each bin (produced by bestPoission layout) ----
            this._binPts = {};
            this._binRects = {};
            this._hMargin = 0;
            this._vMargin = 0;
            this._hBetween = 0;
            this._vBetween = 0;
            this._xglobalmax = 1;
            this._yglobalmax = 1;
        }
        /** Adjust scales as needed for our chart. */
        trueCustomClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var cp = this._chart.customParams();
            this._customParams = cp;
            this._layoutName = beachParty.CustomLayout[cp.layout];
            var facetHelper = dc.facetHelper;
            this._xFacetBinResults = [];
            this._yFacetBinResults = [];
            var xm = this._chart.xMapping();
            var ym = this._chart.yMapping();
            var cp = this._customParams;
            this._isFlat = (cp.xUsage != beachParty.CustomColUsage.bin && cp.yUsage != beachParty.CustomColUsage.bin);
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    if (cp.xUsage == beachParty.CustomColUsage.bin) {
                        var xResults = beachParty.chartUtils.binTheDataForCount(dc, data, xm, "x");
                        this._xFacetBinResults.push(xResults);
                    }
                    if (cp.yUsage == beachParty.CustomColUsage.bin) {
                        var yResults = beachParty.chartUtils.binTheDataForCount(dc, data, ym, "y");
                        this._yFacetBinResults.push(yResults);
                    }
                }
            }
            else {
                if (cp.xUsage == beachParty.CustomColUsage.bin) {
                    var xResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, xm, "x");
                    this._xFacetBinResults.push(xResults);
                }
                if (cp.yUsage == beachParty.CustomColUsage.bin) {
                    var yResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, ym, "y");
                    this._yFacetBinResults.push(yResults);
                }
            }
            //---- adjust X scale ----
            if (xResults) {
                dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, [xResults]);
            }
            //---- adjust Y scale ----
            if (yResults) {
                dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, [yResults]);
            }
            var returnValue = dc.filteredRecordCount;
            if (this._layoutName == "Spiral") {
                this._maxCountOverFacets = beachParty.chartUtils.computeMaxCountOverFacets(dc, nvFacetBuckets);
                returnValue = this._maxCountOverFacets;
            }
            return returnValue;
        };
        trueCustomClass.prototype.assignRecordsToBins = function (nv, resultX, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignX = (resultX) ? resultX.assignments : null;
            var allAssignY = (resultY) ? resultY.assignments : null;
            var binIndexesX = [];
            var binIndexesY = [];
            var binRelativeIndexes = [];
            this._binCounts = {}; // will use string as our 3d index   (facet, x, y)
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            for (var i = 0; i < filter.length; i++) {
                var shapeIndex = i; // sri[i];        // process shape indexes, in sorted order
                if (!filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = (allAssignX) ? allAssignX[shapeIndex] : 0;
                    var binIndexY = (allAssignY) ? allAssignY[shapeIndex] : 0;
                    binIndexesX[shapeIndex] = binIndexX;
                    binIndexesY[shapeIndex] = binIndexY;
                    //---- we are called once for each facet, so we don't need that in our countKey anymore ----
                    var countKey = binIndexX + "," + binIndexY;
                    if (this._binCounts[countKey] === undefined) {
                        this._binCounts[countKey] = 0;
                    }
                    //binIndexes[shapeIndex] = binCounts[countKey];
                    this._binCounts[countKey] += 1;
                    var binRelativeIndex = this._binCounts[countKey];
                    binRelativeIndexes[shapeIndex] = binRelativeIndex;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    binIndexesX[shapeIndex] = 0;
                    binIndexesY[shapeIndex] = 0;
                }
            }
            //---- find max # of entries in any bin ----
            var maxCount = 0;
            var keys = vp.utils.keys(this._binCounts);
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var count = this._binCounts[key];
                maxCount = Math.max(count, maxCount);
            }
            var width = dc.width;
            var height = dc.height;
            if (resultX) {
                //---- build an array of the bin names for the xScale labels ----
                var binsX = resultX.bins;
                var binNamesX = [];
                for (var i = 0; i < binsX.length; i++) {
                    binNamesX[i] = binsX[i].name;
                }
            }
            if (resultY) {
                var binsY = resultY.bins;
                var binNamesY = [];
                for (var i = 0; i < binsY.length; i++) {
                    binNamesY[i] = binsY[i].name;
                }
            }
            //---- create bounds ----
            var binLefts = [];
            var binTops = [];
            var left = dc.x + this._hMargin;
            var top = dc.y + this._vMargin + this._itemHeight;
            if (binsX) {
                for (var i = 0; i < binsX.length; i++) {
                    binLefts[i] = left;
                    left += (this._itemWidth + this._hBetween);
                }
            }
            else {
                binLefts[0] = left;
            }
            if (binsY) {
                for (var i = 0; i < binsY.length; i++) {
                    binTops[i] = top;
                    top += (this._itemHeight + this._vBetween);
                }
            }
            else {
                binTops[0] = top;
            }
            this._binLefts = binLefts;
            this._binTops = binTops;
            this._binIndexesX = binIndexesX;
            this._binIndexesY = binIndexesY;
            this._binRelativeIndexes = binRelativeIndexes;
            this.prepLayouts(dc, nv, keys);
            return maxCount;
        };
        trueCustomClass.prototype.prepLayouts = function (dc, nv, keys) {
            //---- poisson/squarify: layout shapes within each bin now ----
            var cp = this._customParams;
            var binPts = {};
            this._binPts = binPts;
            var binRects = {};
            this._binRects = binRects;
            if (cp.layout == beachParty.CustomLayout.poisson) {
                var rc = vp.geom.createRect(0, 0, this._itemWidth, this._itemHeight);
                for (var k = 0; k < keys.length; k++) {
                    var key = keys[k];
                    var count = this._binCounts[key];
                    if (count > 0) {
                        var poisson = new beachParty.bestPoisson();
                        var pts = poisson.layout(rc, count);
                        binPts[key] = pts;
                    }
                }
            }
            else if (cp.layout == beachParty.CustomLayout.squarify) {
                var rc = vp.geom.createRect(0, 0, this._itemWidth, this._itemHeight);
                for (var k = 0; k < keys.length; k++) {
                    var key = keys[k];
                    var count = this._binCounts[key];
                    if (count > 0) {
                        var squarifyLayout = new beachParty.squarifyLayoutClass();
                        var marginBase = dc.width / 5000;
                        if (this._chartBuilder.getFacetHelper()) {
                            marginBase *= 5;
                        }
                        var cellMargin = this._chart.separationFactor() * marginBase;
                        var xVector = nv.x.values;
                        var cellArray = squarifyLayout.layout(xVector, rc, cellMargin);
                        var rects = cellArray.map(function (d) { return d.rect; });
                        binRects[key] = rects;
                    }
                }
            }
            //---- set the type of layout now (so we don't have to cacl it each time in layoutRecord) ----
            var layoutFunc = null;
            if (cp.layout == beachParty.CustomLayout.grid) {
                layoutFunc = this.gridLayout;
            }
            else if (cp.layout == beachParty.CustomLayout.map) {
                layoutFunc = this.mapLayout;
            }
            else if (cp.layout == beachParty.CustomLayout.radial) {
                layoutFunc = this.radialLayout;
            }
            else if (cp.layout == beachParty.CustomLayout.random) {
                layoutFunc = this.randomLayout;
            }
            else if (cp.layout == beachParty.CustomLayout.poisson) {
                layoutFunc = this.poissonLayout;
            }
            else if (cp.layout == beachParty.CustomLayout.squarify) {
                layoutFunc = this.squarifyLayout;
            }
            else if (cp.layout == beachParty.CustomLayout.spiral) {
                layoutFunc = this.spiralLayout;
            }
            this._layoutFunc = layoutFunc;
        };
        trueCustomClass.prototype.preLayoutLoop = function (dc) {
            var options = this._chartOptions;
            var nv = dc.nvData;
            //---- use pre-computed bins ----
            var xResult = (this._xFacetBinResults.length) ? this._xFacetBinResults[dc.facetIndex] : null;
            var yResult = (this._yFacetBinResults.length) ? this._yFacetBinResults[dc.facetIndex] : null;
            var xBinCount = (xResult) ? xResult.bins.length : 1;
            var yBinCount = (yResult) ? yResult.bins.length : 1;
            var width = dc.width;
            var height = dc.height;
            var hMargin = 2 * dc.itemSize;
            var hBetween = .1 * (dc.width / xBinCount);
            var vMargin = 2 * dc.itemSize;
            var vBetween = .2 * (dc.height / yBinCount);
            this._hMargin = hMargin;
            this._hBetween = hBetween;
            this._vMargin = vMargin;
            this._vBetween = vBetween;
            //---- compute itemWidth and itemHeight ----
            var itemWidth = (width - 2 * hMargin - (xBinCount - 1) * hBetween) / xBinCount;
            var itemHeight = (height - 2 * vMargin - (yBinCount - 1) * vBetween) / yBinCount;
            var ySpace = .1 * itemHeight;
            var binHeight = itemHeight - ySpace;
            this._itemWidth = itemWidth;
            this._itemHeight = itemHeight;
            var maxRecordsInABin = this.assignRecordsToBins(nv, xResult, yResult, dc);
            this._maxCount = maxRecordsInABin;
            var rcBin = vp.geom.createRect(this._binLefts[0], this._binTops[0], this._itemWidth, this._itemHeight);
            this._xglobalmax = Math.max(Math.ceil(Math.sqrt(this._maxCount)), 1);
            this._yglobalmax = Math.max(Math.ceil(this._maxCount / this._xglobalmax), 1);
            this._xspace = this._itemWidth / (this._xglobalmax);
            this._yspace = this._itemHeight / (this._yglobalmax);
            this._space = Math.min(this._xspace, this._yspace);
            var maxShapeSize = Math.min(.85 * this._itemWidth / this._xglobalmax, .85 * this._itemHeight / this._yglobalmax);
            this._maxShapeSize = maxShapeSize; //   / dc.transformSizeFactor;
            var margin = 2 * dc.maxShapeSize; //   dc.itemSize;
            var xSize = dc.width - (margin);
            var ySize = dc.height - (margin);
            var cp = this._customParams;
            if (cp.layout == beachParty.CustomLayout.spiral) {
                //---- for spiral layout ----
                this._maxCount = dc.filteredRecordCount;
                this._radius = Math.min(xSize, ySize);
                this._spacing = .5 * this._radius / Math.sqrt(this._maxCount);
                this._nextIndex = 0;
                this._center.x = dc.x + dc.width / 2;
                this._center.y = dc.y + dc.height / 2;
                this._maxShapeSize = beachParty.chartUtils.getScatterShapeSize(dc, this._maxCountOverFacets, this._chart);
            }
        };
        trueCustomClass.prototype.mapLayout = function (recordIndex, dc, dr, left, top, width, height) {
            var nv = dc.nvData;
            var cp = this._customParams;
            if (cp.xUsage == beachParty.CustomColUsage.map) {
                dr.x = this.scaleColData(nv.x, recordIndex, dc.scales.x);
            }
            if (cp.yUsage == beachParty.CustomColUsage.map) {
                dr.y = this.scaleColData(nv.y, recordIndex, dc.scales.y);
            }
            if (cp.zUsage == beachParty.CustomColUsage.map) {
                dr.z = this.scaleColData(nv.z, recordIndex, dc.scales.z);
            }
        };
        trueCustomClass.prototype.radialLayout = function (recordIndex, dc, dr, left, top, width, height) {
            var nv = dc.nvData;
            var theta = -(Math.PI / 2 + this.scaleColData(nv.x, recordIndex, dc.scales.x));
            var radius = this.scaleColData(nv.y, recordIndex, dc.scales.y);
            //---- cx and cy are the center of the bin that this shape belongs to ----
            var cx = left + this._itemWidth / 2;
            var cy = top - this._itemHeight / 2;
            dr.x = cx + radius * Math.cos(theta);
            dr.y = cy + radius * Math.sin(theta);
        };
        trueCustomClass.prototype.spiralLayout = function (recordIndex, dc, dr, left, top, width, height) {
            var nv = dc.nvData;
            var sp = this._chart.spiralParams();
            var filtered = (dc.layoutFilterVector && dc.layoutFilterVector[recordIndex]);
            var rowIndex = 0;
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            //---- filtered code can calc stuff here, but it will not be used ----
            var cx = this._center.x;
            var cy = this._center.y;
            var r = this._spacing * Math.sqrt(rowIndex);
            var theta = Math.PI / 180 * (rowIndex * sp.seed);
            dr.x = cx + r * Math.sin(theta);
            dr.y = cy + r * Math.cos(theta);
        };
        trueCustomClass.prototype.randomLayout = function (recordIndex, dc, dr, left, top, width, height) {
            var nv = dc.nvData;
            dr.x = left + width * nv.randomX.values[recordIndex];
            dr.y = top - height * nv.randomY.values[recordIndex];
        };
        trueCustomClass.prototype.squarifyLayout = function (recordIndex, dc, dr, left, top, width, height) {
            var binRelativeIndex = this._binRelativeIndexes[recordIndex] - 1;
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var countKey = binIndexX + "," + binIndexY;
            var rects = this._binRects[countKey];
            var rc = rects[binRelativeIndex];
            dr.x = left + rc.left - rc.width / 2;
            dr.y = top - rc.top + rc.height / 2;
            dr.width = 3 * rc.width;
            dr.height = 3 * rc.height;
        };
        trueCustomClass.prototype.poissonLayout = function (recordIndex, dc, dr, left, top, width, height) {
            var binRelativeIndex = this._binRelativeIndexes[recordIndex] - 1;
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var countKey = binIndexX + "," + binIndexY;
            var pts = this._binPts[countKey];
            var pt = pts[binRelativeIndex];
            dr.x = left + pt[0];
            dr.y = top - pt[1];
        };
        trueCustomClass.prototype.gridLayout = function (recordIndex, dc, dr, left, top, width, height) {
            var binRelativeIndex = this._binRelativeIndexes[recordIndex] - 1;
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var countKey = binIndexX + "," + binIndexY;
            var binCount = 0;
            if (this._binCounts[countKey] === undefined) {
                binCount = 0;
            }
            else {
                binCount = this._binCounts[countKey];
            }
            var xlocalmax = Math.max(Math.ceil(Math.sqrt(binCount)), 1);
            var ylocalmax = Math.max(Math.ceil(binCount / xlocalmax), 1);
            var maxWidth = xlocalmax * this._space;
            var maxHeight = ylocalmax * this._space;
            var xrel = binRelativeIndex % xlocalmax;
            var yrel = Math.floor(binRelativeIndex / xlocalmax);
            //---- cx and cy are the center of the bin that this shape belongs to ----
            var cx = left + this._itemWidth / 2;
            var cy = top - this._itemHeight / 2;
            dr.x = cx - maxWidth / 2.0 + xrel * this._space;
            dr.y = cy + maxHeight / 2.0 - yrel * this._space;
        };
        trueCustomClass.prototype.layoutDataForRecord = function (recordIndex, dc, dr) {
            var nv = dc.nvData;
            var rowIndex = 0;
            var layoutFilterVector = dc.layoutFilterVector;
            var filtered = (layoutFilterVector && layoutFilterVector[recordIndex]);
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var left = this._binLefts[binIndexX];
            var top = this._binTops[binIndexY];
            //---- predefine with defaults ----
            dr.x = 0;
            dr.y = 0;
            dr.z = 0;
            dr.width = this._maxShapeSize;
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, recordIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, recordIndex, dc.scales.imageIndex);
            //---- let layout override defaults it cares about ----
            this._layoutFunc(recordIndex, dc, dr, left, top, this._itemWidth, this._itemHeight);
        };
        return trueCustomClass;
    }(beachParty.baseLayoutClass));
    beachParty.trueCustomClass = trueCustomClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    sandViolin.ts - builds a unit violin plot (2D histogram, with variable width, with RANDOM layout within each heatmap tile). 
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var violinClass = (function (_super) {
        __extends(violinClass, _super);
        //_chartOptions = new sandDensityOptions(5, 5, "Circle");
        function violinClass(chart) {
            _super.call(this, chart, "violin");
            //---- all facet results ----
            this._xFacetBinResults = null;
            this._yFacetBinResults = null;
            this._maxCount = 0;
            this._nextIndex = 0; // index to assigned to next unfiltered shape
            this._xSpacing = 0;
            this._ySpacing = 0;
            this._visibleColPickers = "xy";
            this._visibleBinAdjusters = "xy";
        }
        /** Adjust scales as needed for our chart. */
        violinClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            var facetHelper = dc.facetHelper;
            this._xFacetBinResults = [];
            this._yFacetBinResults = [];
            var xm = this._chart.xMapping();
            var ym = this._chart.yMapping();
            if (facetHelper) {
                var facetCount = facetHelper.facetCount();
                //---- compute min/max over all data for CONSISTENT facet binning ----
                beachParty.chartUtils.setFilteredMinMaxBreak(xm, dc.layoutFilterVector, dc.nvData.x);
                beachParty.chartUtils.setFilteredMinMaxBreak(ym, dc.layoutFilterVector, dc.nvData.y);
                for (var i = 0; i < facetCount; i++) {
                    var data = nvFacetBuckets[i];
                    var xResults = beachParty.chartUtils.binTheDataForCount(dc, data, xm, "x");
                    this._xFacetBinResults.push(xResults);
                    var yResults = beachParty.chartUtils.binTheDataForCount(dc, data, ym, "y");
                    this._yFacetBinResults.push(yResults);
                }
            }
            else {
                var xResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, xm, "x");
                this._xFacetBinResults.push(xResults);
                var yResults = beachParty.chartUtils.binTheDataForCount(dc, dc.nvData, ym, "y");
                this._yFacetBinResults.push(yResults);
            }
            this.adjustScales(dc);
            return dc.filteredRecordCount;
        };
        violinClass.prototype.adjustScales = function (dc) {
            //---- adjust X scale ----
            dc.scales.x = beachParty.chartUtils.adjustScaleForBin(dc.scales.x, [this._xFacetBinResults[0]]);
            //---- adjust Y scale ----
            dc.scales.y = beachParty.chartUtils.adjustScaleForBin(dc.scales.y, [this._yFacetBinResults[0]]);
        };
        violinClass.prototype.assignRecordsToBins = function (nv, resultX, resultY, dc) {
            //---- determine each item's position ("itemIndex") within its bin ----
            //---- for this part, we need to process the items in their sorted order ----
            var filter = dc.layoutFilterVector;
            var isFiltered = (filter != null);
            var allAssignX = resultX.assignments;
            var allAssignY = resultY.assignments;
            var binIndexesX = [];
            var binIndexesY = [];
            var binCounts = {}; // will use string as our 3d index   (facet, x, y)
            var facetAssignments = (dc.facetHelper) ? dc.facetHelper.binResult().assignments : null;
            var lastFacetIndex = 0;
            for (var i = 0; i < filter.length; i++) {
                var shapeIndex = i; // sri[i];        // process shape indexes, in sorted order
                if (!filter[shapeIndex]) {
                    //--- assignments must be indexed by the shapeIndex ----
                    var binIndexX = allAssignX[shapeIndex];
                    var binIndexY = allAssignY[shapeIndex];
                    binIndexesX[shapeIndex] = binIndexX;
                    binIndexesY[shapeIndex] = binIndexY;
                    if (facetAssignments) {
                        var facetIndex = facetAssignments[shapeIndex];
                        if (i == 0) {
                            lastFacetIndex = facetIndex;
                        }
                        else {
                            if (facetIndex != lastFacetIndex) {
                                vp.utils.debug("----> ERROR: facetIndex changed");
                            }
                        }
                    }
                    //---- update bin COUNTS ----
                    //---- we are called once for each facet, so we don't need that in our countKey anymore ----
                    var countKey = binIndexX + "," + binIndexY;
                    if (binCounts[countKey] === undefined) {
                        binCounts[countKey] = 0;
                    }
                    binCounts[countKey] += 1;
                }
                else {
                    //---- generate data for these items but don't include in layout ----
                    binIndexesX[shapeIndex] = 0;
                    binIndexesY[shapeIndex] = 0;
                }
            }
            //---- find max # of entries in any bin ----
            var maxCount = 0;
            var keys = vp.utils.keys(binCounts);
            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var count = binCounts[key];
                maxCount = Math.max(count, maxCount);
            }
            var width = dc.width;
            var height = dc.height;
            var binsX = resultX.bins;
            var binsY = resultY.bins;
            //---- build an array of the bin names for the xScale labels ----
            var binNamesX = [];
            for (var i = 0; i < binsX.length; i++) {
                binNamesX[i] = binsX[i].name;
            }
            var binNamesY = [];
            for (var i = 0; i < binsY.length; i++) {
                binNamesY[i] = binsY[i].name;
            }
            //---- create bounds for each bin ----
            var binLefts = [];
            var binTops = [];
            var binWidths = [];
            //---- compute binLefts[] ----
            var left = dc.x + (this._xSpacing / 2);
            for (var i = 0; i < binsX.length; i++) {
                binLefts[i] = left;
                left += this._boxWidth;
            }
            //---- compute binTops[] ----
            var top = dc.y + this._boxHeight - (this._ySpacing / 2);
            for (var i = 0; i < binsY.length; i++) {
                binTops[i] = top;
                top += this._boxHeight;
            }
            //---- compute binWidths[] ----
            for (var i = 0; i < binsX.length; i++) {
                for (var j = 0; j < binsY.length; j++) {
                    //---- compute width of this bin ----
                    var countKey = i + "," + j;
                    var count = binCounts[countKey];
                    if (count === undefined) {
                        count = 0;
                    }
                    var binWidth = vp.data.mapValue(count, 0, maxCount, 0, this._maxBinWidth);
                    binWidths[countKey] = binWidth;
                }
            }
            this._binLefts = binLefts;
            this._binTops = binTops;
            this._binWidths = binWidths;
            this._binIndexesX = binIndexesX;
            this._binIndexesY = binIndexesY;
            return maxCount;
        };
        violinClass.prototype.preLayoutLoop = function (dc) {
            var options = this._chartOptions;
            var nv = dc.nvData;
            //---- use pre-computed bins ----
            var xResult = this._xFacetBinResults[dc.facetIndex];
            var yResult = this._yFacetBinResults[dc.facetIndex];
            var xBinCount = xResult.bins.length;
            var yBinCount = yResult.bins.length;
            var xSpacing = .02 * dc.height;
            var ySpacing = .02 * dc.height;
            //---- compute itemWidth and itemHeight ----
            var boxWidth = dc.width / xBinCount;
            var boxHeight = dc.height / yBinCount;
            var itemWidth = Math.max(0, boxWidth - xSpacing);
            var itemHeight = Math.max(0, boxHeight - ySpacing);
            this._xSpacing = xSpacing;
            this._maxBinWidth = itemWidth;
            this._boxWidth = boxWidth;
            this._ySpacing = ySpacing;
            this._binHeight = itemHeight;
            this._boxHeight = boxHeight;
            var maxRecordsInABin = this.assignRecordsToBins(nv, xResult, yResult, dc);
        };
        violinClass.prototype.layoutDataForRecord = function (recordIndex, dc, dr) {
            var nv = dc.nvData;
            var filtered = (dc.layoutFilterVector && dc.layoutFilterVector[recordIndex]);
            var rowIndex = 0;
            if (!filtered) {
                rowIndex = this._nextIndex++;
            }
            var binIndexX = this._binIndexesX[recordIndex];
            var binIndexY = this._binIndexesY[recordIndex];
            var left = this._binLefts[binIndexX];
            var top = this._binTops[binIndexY];
            var xr = nv.randomX.values[recordIndex];
            var yr = nv.randomY.values[recordIndex];
            var countKey = binIndexX + "," + binIndexY;
            var binWidth = this._binWidths[countKey];
            var innerLeft = left + (this._maxBinWidth / 2) - (binWidth / 2);
            dr.x = innerLeft + (xr * binWidth);
            dr.y = top - (yr * this._binHeight);
            dr.z = 0;
            dr.width = dc.maxShapeSize * this.scaleColData(nv.size, recordIndex, dc.scales.size, 1);
            dr.height = dr.width;
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, recordIndex, dc.scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, recordIndex, dc.scales.imageIndex);
        };
        return violinClass;
    }(beachParty.baseLayoutClass));
    beachParty.violinClass = violinClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    xBand.ts - builds a horizontal rug plot (a 1D scatterplot)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var xBandClass = (function (_super) {
        __extends(xBandClass, _super);
        function xBandClass(chart) {
            _super.call(this, chart, "xBand");
            this._maxShapeSize = 0;
            this._halfSizeSize = 0;
            this._z = 0;
            this._visibleColPickers = "x";
            this._visibleBinAdjusters = "";
            this._chartBuilder.hideAxes("y");
        }
        xBandClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            //---- this call modifies the PREPASS scales (for use by the chart frame) ----
            this.modifyXYScales(dc);
            return dc.filteredRecordCount;
        };
        xBandClass.prototype.modifyXYScales = function (dc, halfShapeSize) {
            //---- add spacing on both sides of X and Y scales to keep shapes within the borders ----
            if (!halfShapeSize) {
                halfShapeSize = (dc.maxShapeSize / 2); //  * dc.transformSizeFactor;       //  dc.combinedSizeFactor;
            }
            //---- note: expandSpace() for scale in specifed in range units (world units, in this case) ----
            dc.scales.x
                .expandSpace(halfShapeSize);
            dc.scales.y
                .expandSpace(halfShapeSize);
            this._halfSizeSize = halfShapeSize;
        };
        xBandClass.prototype.preLayoutLoop = function (dc) {
            //---- this call modifies the FINAL scales (for use by our X/Y mapping) ----
            this.modifyXYScales(dc, this._halfSizeSize);
            this._maxShapeSize = dc.maxShapeSize;
            //---- place our 2D place in middle of Z space ----
            this._z = dc.z + dc.depth / 2;
        };
        /** "bufferIndex" in the 0-based indexed into the sorted data buffers. */
        xBandClass.prototype.layoutDataForRecord = function (bufferIndex, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            dr.x = this.scaleColData(nv.x, bufferIndex, scales.x);
            dr.y = 0;
            dr.z = this._z; // for correct rotation about Y axis
            var usingShape = (this._chart.shapeImage() != "none");
            if (usingShape) {
                dr.height = this._maxShapeSize * this.scaleColData(nv.size, bufferIndex, scales.size, 1);
                dr.width = dr.height;
            }
            else {
                dr.height = 30 * this._maxShapeSize;
                dr.width = .1 * this._maxShapeSize;
            }
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, bufferIndex, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, bufferIndex, dc.scales.imageIndex);
        };
        return xBandClass;
    }(beachParty.baseLayoutClass));
    beachParty.xBandClass = xBandClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    yBand.ts - builds a vertical rug plot (a 1D scatterplot)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var yBandClass = (function (_super) {
        __extends(yBandClass, _super);
        function yBandClass(chart) {
            _super.call(this, chart, "yBand");
            this._maxShapeSize = 0;
            this._halfSizeSize = 0;
            this._z = 0;
            this._visibleColPickers = "y";
            this._visibleBinAdjusters = "";
            this._chartBuilder.hideAxes("x");
        }
        yBandClass.prototype.computeFacetStats = function (dc, nvFacetBuckets) {
            //---- this call modifies the PREPASS scales (for use by the chart frame) ----
            this.modifyXYScales(dc);
            return dc.filteredRecordCount;
        };
        yBandClass.prototype.modifyXYScales = function (dc, halfShapeSize) {
            //---- add spacing on both sides of X and Y scales to keep shapes within the borders ----
            if (!halfShapeSize) {
                halfShapeSize = (dc.maxShapeSize / 2); //  * dc.transformSizeFactor;       //  dc.combinedSizeFactor;
            }
            //---- note: expandSpace() for scale in specifed in range units (world units, in this case) ----
            dc.scales.x
                .expandSpace(halfShapeSize);
            dc.scales.y
                .expandSpace(halfShapeSize);
            this._halfSizeSize = halfShapeSize;
        };
        yBandClass.prototype.preLayoutLoop = function (dc) {
            //---- this call modifies the FINAL scales (for use by our X/Y mapping) ----
            this.modifyXYScales(dc, this._halfSizeSize);
            this._maxShapeSize = dc.maxShapeSize;
            //---- place our 2D place in middle of Z space ----
            this._z = dc.z + dc.depth / 2;
        };
        /** "bufferIndex" in the 0-based indexed into the sorted data buffers. */
        yBandClass.prototype.layoutDataForRecord = function (bufferIndex, dc, dr) {
            var nv = dc.nvData;
            var scales = dc.scales;
            dr.x = 0;
            dr.y = this.scaleColData(nv.y, bufferIndex, scales.y);
            dr.z = this._z; // for correct rotation about Y axis
            var usingShape = (this._chart.shapeImage() != "none");
            if (usingShape) {
                dr.height = this._maxShapeSize * this.scaleColData(nv.size, bufferIndex, scales.size, 1);
                dr.width = dr.height;
            }
            else {
                dr.width = 30 * this._maxShapeSize;
                dr.height = .1 * this._maxShapeSize;
            }
            dr.depth = dc.defaultDepth2d;
            dr.colorIndex = this.scaleColData(nv.colorIndex, bufferIndex, scales.colorIndex);
            dr.imageIndex = this.scaleColData(nv.imageIndex, bufferIndex, dc.scales.imageIndex);
        };
        return yBandClass;
    }(beachParty.baseLayoutClass));
    beachParty.yBandClass = yBandClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    bestPoisson.ts - does "best candidate" algorithm using a high resolution hit testing grid.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var bestCache = {}; // caches pts for layout consistency between changes
    var bestPoisson = (function () {
        function bestPoisson() {
        }
        bestPoisson.prototype.distSquared = function (p1, p2) {
            var dx = p1[0] - p2[0];
            var dy = p1[1] - p2[1];
            var dist = dx * dx + dy * dy;
            return dist;
        };
        /** if any points in cellPts are closer to pt than minDist, return that new minDist. */
        bestPoisson.prototype.checkCellPoints = function (minDist, pt, cellPts) {
            for (var i = 0; i < cellPts.length; i++) {
                var cellPt = cellPts[i];
                var dist = this.distSquared(pt, cellPt);
                if (dist < minDist) {
                    minDist = dist;
                }
            }
            return minDist;
        };
        bestPoisson.prototype.checkGrid = function (minDist, pt, r, c) {
            //vp.utils.debug("checkGrid: x=" + pt[0] + ", y=" + pt[1] + ", r=" + r + ", c=" + c);
            if (r >= 0 && r < this.grid.length) {
                var row = this.grid[r];
                if (c >= 0 && c < row.length) {
                    var cellPts = row[c];
                    if (cellPts.length) {
                        minDist = this.checkCellPoints(minDist, pt, cellPts);
                    }
                }
            }
            return minDist;
        };
        /** returns the DIST between pt and closest of points in grid/pts. */
        bestPoisson.prototype.findClosest = function (pts, pt) {
            var minDist = Number.MAX_VALUE;
            var col = Math.floor((pt[0] - this.rc.left) / this.cellWidth);
            var row = Math.floor((pt[1] - this.rc.top) / this.cellHeight);
            minDist = this.checkGrid(minDist, pt, row - 1, col - 1);
            minDist = this.checkGrid(minDist, pt, row - 1, col);
            minDist = this.checkGrid(minDist, pt, row - 1, col + 1);
            minDist = this.checkGrid(minDist, pt, row, col - 1);
            minDist = this.checkGrid(minDist, pt, row, col);
            minDist = this.checkGrid(minDist, pt, row, col + 1);
            minDist = this.checkGrid(minDist, pt, row + 1, col - 1);
            minDist = this.checkGrid(minDist, pt, row + 1, col);
            minDist = this.checkGrid(minDist, pt, row + 1, col + 1);
            return minDist;
        };
        bestPoisson.prototype.findBestPoissonCandidate = function (pts, rc, maxSamples, grid) {
            var bestPt = null;
            var bestDist = 0;
            var width = rc.width;
            var height = rc.height;
            for (var i = 0; i < maxSamples; i++) {
                var pt = [rc.left + width * Math.random(), rc.top + height * Math.random()];
                var dist = this.findClosest(pts, pt);
                if (i == 0 || dist > bestDist) {
                    bestPt = pt;
                    bestDist = dist;
                }
            }
            return bestPt;
        };
        bestPoisson.prototype.makeGrid = function (rowCount, colCount) {
            var grid = [];
            for (var r = 0; r < rowCount; r++) {
                var row = [];
                grid[r] = row;
                for (var c = 0; c < colCount; c++) {
                    row[c] = [];
                }
            }
            return grid;
        };
        bestPoisson.prototype.layout = function (rc, count, maxSamples) {
            if (maxSamples === void 0) { maxSamples = 30; }
            var pts = [];
            if (count && rc && rc.width > 0 && rc.height > 0) {
                var cacheKey = rc.left + "," + rc.top + "," + rc.width + "," + rc.height + "," + count;
                if (bestCache[cacheKey]) {
                    pts = bestCache[cacheKey];
                }
                else {
                    //---- compute cell size, for hit-testing points ----
                    var aspect = rc.width / rc.height;
                    //var cellWidth = aspect * Math.sqrt(count);
                    //var cellHeight = count / cellWidth;
                    var colCount = Math.ceil(Math.sqrt(aspect * count));
                    var rowCount = Math.ceil(count / colCount);
                    var cellWidth = rc.width / colCount;
                    var cellHeight = rc.height / rowCount;
                    //---- make them so small, they can only hold max of 1 optimially distributed points ----
                    //cellWidth /= 10;
                    //cellHeight /= 10;
                    //---- make cells bigger so that checking neighbor will check 2-3 sizes bigger than optimally distributed points ----
                    //---- FACTOR is critical for perf: the lower the factor, the smaller the avg count of a grid cell & the faster we can check a candidate. ----
                    //---- FACTOR is critical for quality of layout - if it is too small, local clumping results. ----
                    var exp3 = Math.max(.1, Math.log10(count) - 3);
                    var factor = 1 / (10 * exp3);
                    cellWidth *= factor;
                    cellHeight *= factor;
                    var colCount = Math.ceil(rc.width / cellWidth);
                    var rowCount = Math.ceil(rc.height / cellHeight);
                    var grid = this.makeGrid(rowCount, colCount);
                    //---- update this vars ----
                    this.cellHeight = cellHeight;
                    this.cellWidth = cellWidth;
                    this.grid = grid;
                    this.rc = rc;
                    for (var i = 0; i < count; i++) {
                        var pt = this.findBestPoissonCandidate(pts, rc, maxSamples, grid);
                        //---- add to grid ----
                        var col = Math.floor((pt[0] - this.rc.left) / this.cellWidth);
                        var row = Math.floor((pt[1] - this.rc.top) / this.cellHeight);
                        grid[row][col].push(pt);
                        pts.push(pt);
                    }
                    //---- calculate the avg grid cell count ----
                    var entryCouint = 0;
                    var cellCount = 0;
                    for (var i = 0; i < rowCount; i++) {
                        var rr = grid[i];
                        for (var c = 0; c < colCount; c++) {
                            var cells = rr[c];
                            entryCouint += cells.length;
                            cellCount++;
                        }
                    }
                    this.avgCellCount = entryCouint / cellCount;
                }
                bestCache[cacheKey] = pts;
            }
            return pts;
        };
        return bestPoisson;
    }());
    beachParty.bestPoisson = bestPoisson;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    choropletHelper.ts - helps read & process shapes from geoJSON files.
//-------------------------------------------------------------------------------------
//var mediumSales: any[];
var beachParty;
(function (beachParty) {
    var choroplethHelper = (function () {
        function choroplethHelper() {
        }
        choroplethHelper.atBottom = function (coords) {
            var firstEntry = coords[0];
            var bottom = ((firstEntry.length == 2) && (!isNaN(firstEntry[0])));
            return bottom;
        };
        choroplethHelper.buildPath = function (rc, ranges, coords) {
            var linePath = "";
            for (var a = 0; a < coords.length; a++) {
                var coordA = coords[a];
                var atBottom = this.atBottom(coordA);
                if (atBottom) {
                    linePath = this.makePathPart(rc, linePath, coordA, ranges);
                }
                else {
                    for (var b = 0; b < coordA.length; b++) {
                        var coorB = coordA[b];
                        linePath = this.makePathPart(rc, linePath, coorB, ranges);
                    }
                }
            }
            //vp.utils.debug("buildPath: linePath=" + linePath);
            return linePath;
        };
        choroplethHelper.makePathPart = function (rc, linePath, coords, ranges) {
            linePath += "M ";
            for (var c = 0; c < coords.length; c++) {
                var coord = coords[c];
                var x = coord[0];
                var y = coord[1];
                var xScaled = vp.data.mapValue(x, ranges.xMin, ranges.xMax, rc.left, rc.right);
                var yScaled = vp.data.mapValue(y, ranges.yMin, ranges.yMax, rc.bottom, rc.top);
                if (c == 1) {
                    linePath += "L ";
                }
                linePath += xScaled + "," + yScaled + " ";
            }
            return linePath;
        };
        choroplethHelper.computeXYRange = function (ranges, coords) {
            for (var a = 0; a < coords.length; a++) {
                var coordA = coords[a];
                var atBottom = this.atBottom(coordA);
                if (atBottom) {
                    this.computeXYRangeEx(ranges, coordA);
                }
                else {
                    for (var b = 0; b < coordA.length; b++) {
                        var coorB = coordA[b];
                        this.computeXYRangeEx(ranges, coorB);
                    }
                }
            }
        };
        choroplethHelper.computeXYRangeEx = function (ranges, coords) {
            for (var g = 0; g < coords.length; g++) {
                var coord = coords[g];
                var x = coord[0];
                var y = coord[1];
                if (isNaN(x) || isNaN(y)) {
                    vp.utils.debug("NAN found: x=" + x + ", y=" + y);
                }
                ranges.xMin = Math.min(x, ranges.xMin);
                ranges.xMax = Math.max(x, ranges.xMax);
                ranges.yMin = Math.min(y, ranges.yMin);
                ranges.yMax = Math.max(y, ranges.yMax);
            }
        };
        choroplethHelper.getShapeCoords = function (geoJson, shapeName) {
            var features = geoJson.features;
            for (var i = 0; i < features.length; i++) {
                var feature = features[i];
                if (feature.properties.NAME == shapeName) {
                    var coords = feature.geometry.coordinates;
                    break;
                }
            }
            return coords;
        };
        choroplethHelper.getShapeCoordsByIndex = function (geoJson, index) {
            var feature = geoJson.features[index];
            var coords = null;
            if (feature) {
                var name = feature.properties.NAME;
                var coords = feature.geometry.coordinates;
                coords.name = name;
            }
            return coords;
        };
        return choroplethHelper;
    }());
    beachParty.choroplethHelper = choroplethHelper;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// colorPalettes.ts.
///     - A thin TypeScript wrapper for [the third party code] colorbrewer_schemes.js [lightly modified]
///      plus some of our own helper methods.
///-----------------------------------------------------------------------------------------------------------------
/*
-------------------------------------------------------------- START OF THIRD PARTY NOTICE ------------------------------------------------------------------------
This file is based on or incorporates material from the projects listed below (collectively, "Third Party Code"). Microsoft is not the original author of the Third Party Code.
The original copyright notice and the license under which Microsoft received such Third Party Code, are set forth below.
Such licenses and notices are provided for informational purposes only.
Microsoft licenses the Third Party Code to you under the terms set forth in the EULA for the Microsoft Product.
Microsoft reserves all other rights not expressly granted under this agreement, whether by implication, estoppel or otherwise.

jeanlauliac-colorbrewer
Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The Pennsylvania State University.
Provided for Informational Purposes Only
Apache 2.0 License
Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions and limitations under the License.
----------------------------------------------------------- END OF THIRD PARTY NOTICE -----------------------------------------------------------------------------
*/
/*
 * This product includes color specifications and designs developed by Cynthia
 * Brewer (http://colorbrewer.org/).  https://groups.google.com/forum/?fromgroups=#!topic/d3-js/iyXFgJR1JY0
 */
var beachParty;
(function (beachParty) {
    var colorPalettesClass = (function () {
        function colorPalettesClass() {
        }
        colorPalettesClass.getColorSchemeNames = function (colorSchemeType) {
            var colorSchemes = colorPalettesClass.colorBrewerSchemes; // For shorthand
            var colorSchemeNames = [];
            switch (colorSchemeType) {
                case "sequential":
                    colorSchemeNames = colorSchemes.sequentialColorSchemes;
                    break;
                case "diverging":
                    colorSchemeNames = colorSchemes.divergingColorSchemes;
                    break;
                case "qualitative":
                    colorSchemeNames = colorSchemes.qualitativeColorSchemes;
                    break;
                case "custom":
                    colorSchemeNames = colorSchemes.customColorSchemes;
                    break;
                default:
                    throw "Unknown colorSchemeType '" + colorSchemeType + "'";
            }
            return (colorSchemeNames);
        };
        colorPalettesClass.getColorSchemeByName = function (colorSchemeName) {
            var colorSchemes = colorPalettesClass.colorBrewerSchemes; // For shorthand
            if (colorSchemes[colorSchemeName] != null) {
                return (colorSchemes[colorSchemeName]);
            }
            else {
                throw "Unknown colorSchemeName '" + colorSchemeName + "'";
            }
        };
        colorPalettesClass.getColorPaletteTypeFromName = function (paletteName) {
            var classes = ["sequential", "diverging", "qualitative", "custom"];
            var ptn = null;
            for (var i = 0; i < classes.length; i++) {
                var className = classes[i];
                var names = this.getColorSchemeNames(className);
                if (names.indexOf(paletteName) > -1) {
                    ptn = className;
                    break;
                }
            }
            return ptn;
        };
        colorPalettesClass.getPaletteFromSettings = function (colorSchemeName, numSteps, reverse, invertColors) {
            var palette = null;
            var scheme = this.getColorSchemeByName(colorSchemeName);
            //var scheme = colorPalettesClass.getPalettesFromColorScheme(colorSchemeName, i, reverse);
            if (scheme) {
                //---- build scheme array, so we can call getPaletteFromSteps() ----
                var schemeArray = [];
                var keys = vp.utils.keys(scheme);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var value = scheme[key];
                    schemeArray.push(value);
                }
                palette = this.getPaletteFromSteps(colorSchemeName, schemeArray, numSteps);
                /// palettes in this class are defined from LIGHT to DARK but clients expect them as DARK to LIGHT, so we 
                /// reverse the requested orders.  
                reverse = (!reverse);
                if (palette) {
                    if (reverse) {
                        palette = vp.utils.copyArray(palette).reverse();
                    }
                    if (invertColors) {
                        palette = vp.utils.copyArray(palette);
                        for (var i = 0; i < palette.length; i++) {
                            var cr = palette[i];
                            palette[i] = colorPalettesClass.invertThisColor(cr);
                        }
                    }
                }
            }
            return palette;
        };
        colorPalettesClass.invertThisColor = function (cr) {
            var rgbArray = vp.color.getColorFromString(cr);
            //---- invert the color components for this color ----
            for (var c = 0; c < 3; c++) {
                rgbArray[c] = 255 - rgbArray[c];
            }
            //---- convert back to color string ----
            var newCr = vp.color.toColor(rgbArray);
            return newCr;
        };
        // Qualitative schemes are special in that they don't all contain the same number of palettes:
        //   4 schemes contain palettes with 2 to 8 colors
        //   2 schemes contain palettes with 2 to 9 colors
        //   2 schemes contain palettes with 2 to 12 colors
        // Consequently when we display Qualitative schemes sometime we show all 8 schemes (if we need up to 8 colors), sometimes
        // we show 4 schemes (if we need up to 9 colors), and sometimes we only show 2 schemes (if we need up to 12 colors).
        // So when a selection is made we only have the RELATIVE scheme index (eg. "the 3rd qualitative scheme with 9 colors").
        // This method provides a way to convert the relative scheme index into an ABSOLUTE scheme index.
        colorPalettesClass.getQualitativeColorSchemeIndex = function (relativeSchemeIndex, numColors) {
            var colorSchemeNames = colorPalettesClass.getColorSchemeNames("qualitative");
            var countOfSchemesWithRequiredNumberOfColors = 0;
            for (var i = 0; i < colorSchemeNames.length; i++) {
                var colorSchemeName = colorSchemeNames[i];
                var colorScheme = colorPalettesClass.getColorSchemeByName(colorSchemeName);
                if (colorScheme[numColors] || (numColors == 1)) {
                    if (countOfSchemesWithRequiredNumberOfColors == relativeSchemeIndex) {
                        return (i);
                    }
                    countOfSchemesWithRequiredNumberOfColors++;
                }
            }
            throw "Unable to find the absolute scheme index for relative index " + relativeSchemeIndex + " in 'Qualitative' schemes containing " + numColors + " colors";
        };
        // Makes an array of SandDance palettes using ALL the schemes of type "qualitative", but including only those schemes that contain a palette with numQualitativeColors.
        // Note: A SandDance palette is an array of [r,g,b] color arrays.
        colorPalettesClass.getQualitativePalettes = function (numQualitativeColors, reverseColors, invertColors) {
            return (colorPalettesClass.getPalettesFromColorSchemeType("qualitative", numQualitativeColors, reverseColors, invertColors));
        };
        colorPalettesClass.getPaletteFromSteps = function (paletteName, scheme, stepsRequested) {
            var palette = [];
            if (stepsRequested == 1) {
                // Palette[0] has 2 colors, so if only one color is desired then we create a single-color SandDance palette using the first color of Palette[0]
                var schemeIndex = (scheme.length > 1) ? 1 : 0;
                palette.push(scheme[schemeIndex][0]);
            }
            else if (stepsRequested == 2 && scheme.length > 1) {
                // Palette[1] has 3 colors; use first and last.  Don't use Palette[0] - it was built incorrectly.
                var schemeIndex = (scheme.length > 1) ? 1 : 0;
                palette.push(scheme[schemeIndex][0]);
                palette.push(scheme[schemeIndex][2]);
            }
            else {
                var maxColorsInPaletteArray = scheme.length + 1;
                var stepCount = Math.min(maxColorsInPaletteArray, stepsRequested);
                palette = scheme[stepCount - 2]; // Palette[0] has 2 colors   
            }
            palette.name = paletteName;
            return palette;
        };
        // Makes an array of SandDance palettes using ALL the schemes of the specified type, but including only those schemes that contain a palette with numDesiredColors.
        // Note: A SandDance palette is an array of [r,g,b] color arrays.
        colorPalettesClass.getPalettesFromColorSchemeType = function (colorSchemeType, numDesiredColors, reverseColors, invertColors) {
            var colorSchemeNames = colorPalettesClass.getColorSchemeNames(colorSchemeType);
            var palettes = [];
            if (numDesiredColors < 1) {
                throw "The specified number of desired colors must be at least 1";
            }
            for (var i = 0; i < colorSchemeNames.length; i++) {
                var name = colorSchemeNames[i];
                var candidatePaletteArray = colorPalettesClass.getPalettesFromColorScheme(colorSchemeType, i, reverseColors, invertColors);
                var maxColorsInPaletteArray = candidatePaletteArray.length + 1;
                var palette = this.getPaletteFromSteps(name, candidatePaletteArray, numDesiredColors);
                palettes.push(palette);
            }
            return (palettes);
        };
        // Makes an array of SandDance palettes using ALL the palettes in the color scheme of the specified type/index.
        // Note: A SandDance palette is an array of [r,g,b] color arrays.
        colorPalettesClass.getPalettesFromColorScheme = function (colorSchemeType, colorSchemeIndex, reverseColors, invertColors) {
            var colorSchemeNames = colorPalettesClass.getColorSchemeNames(colorSchemeType);
            // If colorSchemeIndex is greater than the number of schemes [of the specified type] then we default to scheme 0
            if ((colorSchemeIndex < 0) || (colorSchemeIndex >= colorSchemeNames.length)) {
                colorSchemeIndex = 0;
            }
            var colorSchemeName = colorSchemeNames[colorSchemeIndex];
            var paletteArray = colorPalettesClass.getPalettesFromColorSchemeName(colorSchemeName, reverseColors, invertColors);
            return (paletteArray);
        };
        // Makes an array of SandDance palettes using ALL the palettes in the named color scheme.
        // Note: A SandDance palette is an array of [r,g,b] color arrays.
        colorPalettesClass.getPalettesFromColorSchemeName = function (colorSchemeName, reverseColors, invertColors) {
            var palettes = [];
            var colorScheme = colorPalettesClass.getColorSchemeByName(colorSchemeName);
            var colorSchemePaletteNames = vp.utils.keys(colorScheme);
            /// palettes in this class are defined from LIGHT to DARK but clients expect them as DARK to LIGHT, so we 
            /// reverse the requested orders.  
            var actualReverse = (!reverseColors);
            for (var colorSchemePaletteNameIndex = 0; colorSchemePaletteNameIndex < colorSchemePaletteNames.length; colorSchemePaletteNameIndex++) {
                var colorSchemePaletteName = colorSchemePaletteNames[colorSchemePaletteNameIndex]; // Eg. "3"
                var colorSchemePalette = colorScheme[colorSchemePaletteName]; // An array of strings of the form "rgb(rrr,ggg,bbb)"
                var palette = []; // An array of rgb arrays
                // Convert each color in the color-scheme palette from "rgb(r,g,b)" to [r,g,b], then add that color array to our palette
                for (var i = 0; i < colorSchemePalette.length; i++) {
                    try {
                        //---- we no longer need rgb arrays on the client ----
                        //var rgbArray: number[] = colorPalettesClass.getRgbColorArrayFromRgbColorString(colorSchemePalette[i]);
                        var rgbString = colorSchemePalette[i];
                        if (invertColors) {
                            rgbString = colorPalettesClass.invertThisColor(rgbString);
                        }
                        if (actualReverse) {
                            var rIndex = (colorSchemePalette.length - 1) - i;
                            palette[rIndex] = rgbString;
                        }
                        else {
                            palette.push(rgbString);
                        }
                    }
                    catch (err) {
                        throw err + " in color scheme '" + colorSchemeName + "',  palette '" + colorSchemePaletteName + "'.";
                    }
                }
                palettes.push(palette);
            }
            return (palettes);
        };
        colorPalettesClass.getRgbColorArrayFromRgbColorString = function (rgbColorString) {
            var colorsArray = rgbColorString.replace("rgb(", "").replace(")", "").split(','); // rgbColorStrings is an array of string of the form "rgb(rrr, ggg, bbb)"
            var rgbArray = [];
            if (colorsArray.length == 3) {
                rgbArray.push(parseInt(colorsArray[0]));
                rgbArray.push(parseInt(colorsArray[1]));
                rgbArray.push(parseInt(colorsArray[2]));
            }
            else {
                throw "Malformed rgb() value '" + rgbColorString + "'";
            }
            return (rgbArray);
        };
        colorPalettesClass.MaxQualitativeColors = 12;
        // This is the "heart" of colorbrewer_schemes.js 
        colorPalettesClass.colorBrewerSchemes = {
            // Note: These 3 members were not part of the original colorbrewer_schemes.js 
            divergingColorSchemes: ['Spectral', 'RdYlGn', 'RdBu', 'PiYG', 'PRGn', 'RdYlBu', 'BrBG', 'RdGy', 'PuOr'],
            //qualitativeColorSchemesOld: ['Khronos', 'Accent', 'Dark2', 'Pastel2', 'Set2', 'Pastel1', 'Set1', 'Paired', 'Set3'], // MUST be ordered by number of palettes
            qualitativeColorSchemes: ['Set3', 'Paired', 'Set1', 'Pastel1', 'Set2', 'Pastel2', 'Dark2', 'Accent', 'Khronos'],
            sequentialColorSchemes: ["Blues", "Greens", "Greys", "Oranges", "Purples", "Reds", "BuGn", "BuPu", "GnBu", "OrRd", "PuBu", "PuBuGn",
                "PuRd", "RdPu", "YlGn", "YlGnBu", "YlOrBu", "YlOrRd"],
            customColorSchemes: ["SpectralEx", "RedGreen", "RedBlue"],
            // Diverging color schemes [all palettes have 2..11 colors]
            Spectral: { 2: ['rgb(252,141,89)', 'rgb(153,213,148)'], 3: ['rgb(252,141,89)', 'rgb(255,255,191)', 'rgb(153,213,148)'], 4: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(171,221,164)', 'rgb(43,131,186)'], 5: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(255,255,191)', 'rgb(171,221,164)', 'rgb(43,131,186)'], 6: ['rgb(213,62,79)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(230,245,152)', 'rgb(153,213,148)', 'rgb(50,136,189)'], 7: ['rgb(213,62,79)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(230,245,152)', 'rgb(153,213,148)', 'rgb(50,136,189)'], 8: ['rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)'], 9: ['rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)'], 10: ['rgb(158,1,66)', 'rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)', 'rgb(94,79,162)'], 11: ['rgb(158,1,66)', 'rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)', 'rgb(94,79,162)'] },
            RdYlGn: { 2: ['rgb(252,141,89)', 'rgb(145,207,96)'], 3: ['rgb(252,141,89)', 'rgb(255,255,191)', 'rgb(145,207,96)'], 4: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(166,217,106)', 'rgb(26,150,65)'], 5: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(255,255,191)', 'rgb(166,217,106)', 'rgb(26,150,65)'], 6: ['rgb(215,48,39)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(217,239,139)', 'rgb(145,207,96)', 'rgb(26,152,80)'], 7: ['rgb(215,48,39)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(217,239,139)', 'rgb(145,207,96)', 'rgb(26,152,80)'], 8: ['rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(217,239,139)', 'rgb(166,217,106)', 'rgb(102,189,99)', 'rgb(26,152,80)'], 9: ['rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(217,239,139)', 'rgb(166,217,106)', 'rgb(102,189,99)', 'rgb(26,152,80)'], 10: ['rgb(165,0,38)', 'rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(217,239,139)', 'rgb(166,217,106)', 'rgb(102,189,99)', 'rgb(26,152,80)', 'rgb(0,104,55)'], 11: ['rgb(165,0,38)', 'rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(217,239,139)', 'rgb(166,217,106)', 'rgb(102,189,99)', 'rgb(26,152,80)', 'rgb(0,104,55)'] },
            RdBu: { 2: ['rgb(239,138,98)', 'rgb(103,169,207)'], 3: ['rgb(239,138,98)', 'rgb(247,247,247)', 'rgb(103,169,207)'], 4: ['rgb(202,0,32)', 'rgb(244,165,130)', 'rgb(146,197,222)', 'rgb(5,113,176)'], 5: ['rgb(202,0,32)', 'rgb(244,165,130)', 'rgb(247,247,247)', 'rgb(146,197,222)', 'rgb(5,113,176)'], 6: ['rgb(178,24,43)', 'rgb(239,138,98)', 'rgb(253,219,199)', 'rgb(209,229,240)', 'rgb(103,169,207)', 'rgb(33,102,172)'], 7: ['rgb(178,24,43)', 'rgb(239,138,98)', 'rgb(253,219,199)', 'rgb(247,247,247)', 'rgb(209,229,240)', 'rgb(103,169,207)', 'rgb(33,102,172)'], 8: ['rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(209,229,240)', 'rgb(146,197,222)', 'rgb(67,147,195)', 'rgb(33,102,172)'], 9: ['rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(247,247,247)', 'rgb(209,229,240)', 'rgb(146,197,222)', 'rgb(67,147,195)', 'rgb(33,102,172)'], 10: ['rgb(103,0,31)', 'rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(209,229,240)', 'rgb(146,197,222)', 'rgb(67,147,195)', 'rgb(33,102,172)', 'rgb(5,48,97)'], 11: ['rgb(103,0,31)', 'rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(247,247,247)', 'rgb(209,229,240)', 'rgb(146,197,222)', 'rgb(67,147,195)', 'rgb(33,102,172)', 'rgb(5,48,97)'] },
            PiYG: { 2: ['rgb(233,163,201)', 'rgb(161,215,106)'], 3: ['rgb(233,163,201)', 'rgb(247,247,247)', 'rgb(161,215,106)'], 4: ['rgb(208,28,139)', 'rgb(241,182,218)', 'rgb(184,225,134)', 'rgb(77,172,38)'], 5: ['rgb(208,28,139)', 'rgb(241,182,218)', 'rgb(247,247,247)', 'rgb(184,225,134)', 'rgb(77,172,38)'], 6: ['rgb(197,27,125)', 'rgb(233,163,201)', 'rgb(253,224,239)', 'rgb(230,245,208)', 'rgb(161,215,106)', 'rgb(77,146,33)'], 7: ['rgb(197,27,125)', 'rgb(233,163,201)', 'rgb(253,224,239)', 'rgb(247,247,247)', 'rgb(230,245,208)', 'rgb(161,215,106)', 'rgb(77,146,33)'], 8: ['rgb(197,27,125)', 'rgb(222,119,174)', 'rgb(241,182,218)', 'rgb(253,224,239)', 'rgb(230,245,208)', 'rgb(184,225,134)', 'rgb(127,188,65)', 'rgb(77,146,33)'], 9: ['rgb(197,27,125)', 'rgb(222,119,174)', 'rgb(241,182,218)', 'rgb(253,224,239)', 'rgb(247,247,247)', 'rgb(230,245,208)', 'rgb(184,225,134)', 'rgb(127,188,65)', 'rgb(77,146,33)'], 10: ['rgb(142,1,82)', 'rgb(197,27,125)', 'rgb(222,119,174)', 'rgb(241,182,218)', 'rgb(253,224,239)', 'rgb(230,245,208)', 'rgb(184,225,134)', 'rgb(127,188,65)', 'rgb(77,146,33)', 'rgb(39,100,25)'], 11: ['rgb(142,1,82)', 'rgb(197,27,125)', 'rgb(222,119,174)', 'rgb(241,182,218)', 'rgb(253,224,239)', 'rgb(247,247,247)', 'rgb(230,245,208)', 'rgb(184,225,134)', 'rgb(127,188,65)', 'rgb(77,146,33)', 'rgb(39,100,25)'] },
            PRGn: { 2: ['rgb(175,141,195)', 'rgb(127,191,123)'], 3: ['rgb(175,141,195)', 'rgb(247,247,247)', 'rgb(127,191,123)'], 4: ['rgb(123,50,148)', 'rgb(194,165,207)', 'rgb(166,219,160)', 'rgb(0,136,55)'], 5: ['rgb(123,50,148)', 'rgb(194,165,207)', 'rgb(247,247,247)', 'rgb(166,219,160)', 'rgb(0,136,55)'], 6: ['rgb(118,42,131)', 'rgb(175,141,195)', 'rgb(231,212,232)', 'rgb(217,240,211)', 'rgb(127,191,123)', 'rgb(27,120,55)'], 7: ['rgb(118,42,131)', 'rgb(175,141,195)', 'rgb(231,212,232)', 'rgb(247,247,247)', 'rgb(217,240,211)', 'rgb(127,191,123)', 'rgb(27,120,55)'], 8: ['rgb(118,42,131)', 'rgb(153,112,171)', 'rgb(194,165,207)', 'rgb(231,212,232)', 'rgb(217,240,211)', 'rgb(166,219,160)', 'rgb(90,174,97)', 'rgb(27,120,55)'], 9: ['rgb(118,42,131)', 'rgb(153,112,171)', 'rgb(194,165,207)', 'rgb(231,212,232)', 'rgb(247,247,247)', 'rgb(217,240,211)', 'rgb(166,219,160)', 'rgb(90,174,97)', 'rgb(27,120,55)'], 10: ['rgb(64,0,75)', 'rgb(118,42,131)', 'rgb(153,112,171)', 'rgb(194,165,207)', 'rgb(231,212,232)', 'rgb(217,240,211)', 'rgb(166,219,160)', 'rgb(90,174,97)', 'rgb(27,120,55)', 'rgb(0,68,27)'], 11: ['rgb(64,0,75)', 'rgb(118,42,131)', 'rgb(153,112,171)', 'rgb(194,165,207)', 'rgb(231,212,232)', 'rgb(247,247,247)', 'rgb(217,240,211)', 'rgb(166,219,160)', 'rgb(90,174,97)', 'rgb(27,120,55)', 'rgb(0,68,27)'] },
            RdYlBu: { 2: ['rgb(252,141,89)', 'rgb(145,191,219)'], 3: ['rgb(252,141,89)', 'rgb(255,255,191)', 'rgb(145,191,219)'], 4: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(171,217,233)', 'rgb(44,123,182)'], 5: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(255,255,191)', 'rgb(171,217,233)', 'rgb(44,123,182)'], 6: ['rgb(215,48,39)', 'rgb(252,141,89)', 'rgb(254,224,144)', 'rgb(224,243,248)', 'rgb(145,191,219)', 'rgb(69,117,180)'], 7: ['rgb(215,48,39)', 'rgb(252,141,89)', 'rgb(254,224,144)', 'rgb(255,255,191)', 'rgb(224,243,248)', 'rgb(145,191,219)', 'rgb(69,117,180)'], 8: ['rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,144)', 'rgb(224,243,248)', 'rgb(171,217,233)', 'rgb(116,173,209)', 'rgb(69,117,180)'], 9: ['rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,144)', 'rgb(255,255,191)', 'rgb(224,243,248)', 'rgb(171,217,233)', 'rgb(116,173,209)', 'rgb(69,117,180)'], 10: ['rgb(165,0,38)', 'rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,144)', 'rgb(224,243,248)', 'rgb(171,217,233)', 'rgb(116,173,209)', 'rgb(69,117,180)', 'rgb(49,54,149)'], 11: ['rgb(165,0,38)', 'rgb(215,48,39)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,144)', 'rgb(255,255,191)', 'rgb(224,243,248)', 'rgb(171,217,233)', 'rgb(116,173,209)', 'rgb(69,117,180)', 'rgb(49,54,149)'] },
            BrBG: { 2: ['rgb(216,179,101)', 'rgb(90,180,172)'], 3: ['rgb(216,179,101)', 'rgb(245,245,245)', 'rgb(90,180,172)'], 4: ['rgb(166,97,26)', 'rgb(223,194,125)', 'rgb(128,205,193)', 'rgb(1,133,113)'], 5: ['rgb(166,97,26)', 'rgb(223,194,125)', 'rgb(245,245,245)', 'rgb(128,205,193)', 'rgb(1,133,113)'], 6: ['rgb(140,81,10)', 'rgb(216,179,101)', 'rgb(246,232,195)', 'rgb(199,234,229)', 'rgb(90,180,172)', 'rgb(1,102,94)'], 7: ['rgb(140,81,10)', 'rgb(216,179,101)', 'rgb(246,232,195)', 'rgb(245,245,245)', 'rgb(199,234,229)', 'rgb(90,180,172)', 'rgb(1,102,94)'], 8: ['rgb(140,81,10)', 'rgb(191,129,45)', 'rgb(223,194,125)', 'rgb(246,232,195)', 'rgb(199,234,229)', 'rgb(128,205,193)', 'rgb(53,151,143)', 'rgb(1,102,94)'], 9: ['rgb(140,81,10)', 'rgb(191,129,45)', 'rgb(223,194,125)', 'rgb(246,232,195)', 'rgb(245,245,245)', 'rgb(199,234,229)', 'rgb(128,205,193)', 'rgb(53,151,143)', 'rgb(1,102,94)'], 10: ['rgb(84,48,5)', 'rgb(140,81,10)', 'rgb(191,129,45)', 'rgb(223,194,125)', 'rgb(246,232,195)', 'rgb(199,234,229)', 'rgb(128,205,193)', 'rgb(53,151,143)', 'rgb(1,102,94)', 'rgb(0,60,48)'], 11: ['rgb(84,48,5)', 'rgb(140,81,10)', 'rgb(191,129,45)', 'rgb(223,194,125)', 'rgb(246,232,195)', 'rgb(245,245,245)', 'rgb(199,234,229)', 'rgb(128,205,193)', 'rgb(53,151,143)', 'rgb(1,102,94)', 'rgb(0,60,48)'] },
            RdGy: { 2: ['rgb(239,138,98)', 'rgb(153,153,153)'], 3: ['rgb(239,138,98)', 'rgb(255,255,255)', 'rgb(153,153,153)'], 4: ['rgb(202,0,32)', 'rgb(244,165,130)', 'rgb(186,186,186)', 'rgb(64,64,64)'], 5: ['rgb(202,0,32)', 'rgb(244,165,130)', 'rgb(255,255,255)', 'rgb(186,186,186)', 'rgb(64,64,64)'], 6: ['rgb(178,24,43)', 'rgb(239,138,98)', 'rgb(253,219,199)', 'rgb(224,224,224)', 'rgb(153,153,153)', 'rgb(77,77,77)'], 7: ['rgb(178,24,43)', 'rgb(239,138,98)', 'rgb(253,219,199)', 'rgb(255,255,255)', 'rgb(224,224,224)', 'rgb(153,153,153)', 'rgb(77,77,77)'], 8: ['rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(224,224,224)', 'rgb(186,186,186)', 'rgb(135,135,135)', 'rgb(77,77,77)'], 9: ['rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(255,255,255)', 'rgb(224,224,224)', 'rgb(186,186,186)', 'rgb(135,135,135)', 'rgb(77,77,77)'], 10: ['rgb(103,0,31)', 'rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(224,224,224)', 'rgb(186,186,186)', 'rgb(135,135,135)', 'rgb(77,77,77)', 'rgb(26,26,26)'], 11: ['rgb(103,0,31)', 'rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(255,255,255)', 'rgb(224,224,224)', 'rgb(186,186,186)', 'rgb(135,135,135)', 'rgb(77,77,77)', 'rgb(26,26,26)'] },
            PuOr: { 2: ['rgb(241,163,64)', 'rgb(153,142,195)'], 3: ['rgb(241,163,64)', 'rgb(247,247,247)', 'rgb(153,142,195)'], 4: ['rgb(230,97,1)', 'rgb(253,184,99)', 'rgb(178,171,210)', 'rgb(94,60,153)'], 5: ['rgb(230,97,1)', 'rgb(253,184,99)', 'rgb(247,247,247)', 'rgb(178,171,210)', 'rgb(94,60,153)'], 6: ['rgb(179,88,6)', 'rgb(241,163,64)', 'rgb(254,224,182)', 'rgb(216,218,235)', 'rgb(153,142,195)', 'rgb(84,39,136)'], 7: ['rgb(179,88,6)', 'rgb(241,163,64)', 'rgb(254,224,182)', 'rgb(247,247,247)', 'rgb(216,218,235)', 'rgb(153,142,195)', 'rgb(84,39,136)'], 8: ['rgb(179,88,6)', 'rgb(224,130,20)', 'rgb(253,184,99)', 'rgb(254,224,182)', 'rgb(216,218,235)', 'rgb(178,171,210)', 'rgb(128,115,172)', 'rgb(84,39,136)'], 9: ['rgb(179,88,6)', 'rgb(224,130,20)', 'rgb(253,184,99)', 'rgb(254,224,182)', 'rgb(247,247,247)', 'rgb(216,218,235)', 'rgb(178,171,210)', 'rgb(128,115,172)', 'rgb(84,39,136)'], 10: ['rgb(127,59,8)', 'rgb(179,88,6)', 'rgb(224,130,20)', 'rgb(253,184,99)', 'rgb(254,224,182)', 'rgb(216,218,235)', 'rgb(178,171,210)', 'rgb(128,115,172)', 'rgb(84,39,136)', 'rgb(45,0,75)'], 11: ['rgb(127,59,8)', 'rgb(179,88,6)', 'rgb(224,130,20)', 'rgb(253,184,99)', 'rgb(254,224,182)', 'rgb(247,247,247)', 'rgb(216,218,235)', 'rgb(178,171,210)', 'rgb(128,115,172)', 'rgb(84,39,136)', 'rgb(45,0,75)'] },
            // custom schemes
            SpectralEx: { 2: ['rgb(215,25,28)', 'rgb(43,131,186)'], 3: ['rgb(215,25,28)', 'rgb(255,255,191)', 'rgb(43,131,186)'], 4: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(171,221,164)', 'rgb(43,131,186)'], 5: ['rgb(215,25,28)', 'rgb(253,174,97)', 'rgb(255,255,191)', 'rgb(171,221,164)', 'rgb(43,131,186)'], 6: ['rgb(215,25,28)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(230,245,152)', 'rgb(153,213,148)', 'rgb(43,131,186)'], 7: ['rgb(215,25,28)', 'rgb(252,141,89)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(230,245,152)', 'rgb(153,213,148)', 'rgb(43,131,186)'], 8: ['rgb(215,25,28)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(43,131,186)'], 9: ['rgb(215,25,28)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(43,131,186)'], 10: ['rgb(215,25,28)', 'rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)', 'rgb(43,131,186)'], 11: ['rgb(215,25,28)', 'rgb(213,62,79)', 'rgb(244,109,67)', 'rgb(253,174,97)', 'rgb(254,224,139)', 'rgb(255,255,191)', 'rgb(230,245,152)', 'rgb(171,221,164)', 'rgb(102,194,165)', 'rgb(50,136,189)', 'rgb(43,131,186)'] },
            RedGreen: { 2: ["rgb(255, 0, 0)", "rgb(127, 255, 127)"] },
            RedBlue: { 2: ["rgb(255, 0, 0)", "rgb(0, 0, 255)"] },
            // Qualitative color schemes
            // [Palettes with 2..6 colors]
            Khronos: { 2: ['rgb(157,190,127)', 'rgb(255,255,255)'], 3: ['rgb(157,190,127)', 'rgb(232,109,113)', 'rgb(255,255,255)'], 4: ['rgb(157,190,127)', 'rgb(232,109,113)', 'rgb(194,195,178)', 'rgb(255,255,255)'], 5: ['rgb(157,190,127)', 'rgb(232,109,113)', 'rgb(252,238,78)', 'rgb(238,160,41)', 'rgb(255,255,255)'], 6: ['rgb(157,190,127)', 'rgb(232,109,113)', 'rgb(252,238,78)', 'rgb(238,160,41)', 'rgb(194,195,178)', 'rgb(255,255,255)'] },
            // [Palettes with 2..8 colors]
            Accent: { 2: ['rgb(127,201,127)', 'rgb(190,174,212)'], 3: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)'], 4: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)', 'rgb(255,255,153)'], 5: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)', 'rgb(255,255,153)', 'rgb(56,108,176)'], 6: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)', 'rgb(255,255,153)', 'rgb(56,108,176)', 'rgb(240,2,127)'], 7: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)', 'rgb(255,255,153)', 'rgb(56,108,176)', 'rgb(240,2,127)', 'rgb(191,91,23)'], 8: ['rgb(127,201,127)', 'rgb(190,174,212)', 'rgb(253,192,134)', 'rgb(255,255,153)', 'rgb(56,108,176)', 'rgb(240,2,127)', 'rgb(191,91,23)', 'rgb(102,102,102)'] },
            Dark2: { 2: ['rgb(27,158,119)', 'rgb(217,95,2)'], 3: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)'], 4: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)', 'rgb(231,41,138)'], 5: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)', 'rgb(231,41,138)', 'rgb(102,166,30)'], 6: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)', 'rgb(231,41,138)', 'rgb(102,166,30)', 'rgb(230,171,2)'], 7: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)', 'rgb(231,41,138)', 'rgb(102,166,30)', 'rgb(230,171,2)', 'rgb(166,118,29)'], 8: ['rgb(27,158,119)', 'rgb(217,95,2)', 'rgb(117,112,179)', 'rgb(231,41,138)', 'rgb(102,166,30)', 'rgb(230,171,2)', 'rgb(166,118,29)', 'rgb(102,102,102)'] },
            Pastel2: { 2: ['rgb(179,226,205)', 'rgb(253,205,172)'], 3: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)'], 4: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)', 'rgb(244,202,228)'], 5: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)', 'rgb(244,202,228)', 'rgb(230,245,201)'], 6: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)', 'rgb(244,202,228)', 'rgb(230,245,201)', 'rgb(255,242,174)'], 7: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)', 'rgb(244,202,228)', 'rgb(230,245,201)', 'rgb(255,242,174)', 'rgb(241,226,204)'], 8: ['rgb(179,226,205)', 'rgb(253,205,172)', 'rgb(203,213,232)', 'rgb(244,202,228)', 'rgb(230,245,201)', 'rgb(255,242,174)', 'rgb(241,226,204)', 'rgb(204,204,204)'] },
            Set2: { 2: ['rgb(102,194,165)', 'rgb(252,141,98)'], 3: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)'], 4: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)', 'rgb(231,138,195)'], 5: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)', 'rgb(231,138,195)', 'rgb(166,216,84)'], 6: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)', 'rgb(231,138,195)', 'rgb(166,216,84)', 'rgb(255,217,47)'], 7: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)', 'rgb(231,138,195)', 'rgb(166,216,84)', 'rgb(255,217,47)', 'rgb(229,196,148)'], 8: ['rgb(102,194,165)', 'rgb(252,141,98)', 'rgb(141,160,203)', 'rgb(231,138,195)', 'rgb(166,216,84)', 'rgb(255,217,47)', 'rgb(229,196,148)', 'rgb(179,179,179)'] },
            // [Palettes with 2..9 colors]
            Pastel1: { 2: ['rgb(251,180,174)', 'rgb(179,205,227)'], 3: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)'], 4: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)'], 5: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)', 'rgb(254,217,166)'], 6: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)', 'rgb(254,217,166)', 'rgb(255,255,204)'], 7: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)', 'rgb(254,217,166)', 'rgb(255,255,204)', 'rgb(229,216,189)'], 8: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)', 'rgb(254,217,166)', 'rgb(255,255,204)', 'rgb(229,216,189)', 'rgb(253,218,236)'], 9: ['rgb(251,180,174)', 'rgb(179,205,227)', 'rgb(204,235,197)', 'rgb(222,203,228)', 'rgb(254,217,166)', 'rgb(255,255,204)', 'rgb(229,216,189)', 'rgb(253,218,236)', 'rgb(242,242,242)'] },
            Set1: { 2: ['rgb(228,26,28)', 'rgb(55,126,184)'], 3: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)'], 4: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)'], 5: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)', 'rgb(255,127,0)'], 6: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)', 'rgb(255,127,0)', 'rgb(255,255,51)'], 7: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)', 'rgb(255,127,0)', 'rgb(255,255,51)', 'rgb(166,86,40)'], 8: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)', 'rgb(255,127,0)', 'rgb(255,255,51)', 'rgb(166,86,40)', 'rgb(247,129,191)'], 9: ['rgb(228,26,28)', 'rgb(55,126,184)', 'rgb(77,175,74)', 'rgb(152,78,163)', 'rgb(255,127,0)', 'rgb(255,255,51)', 'rgb(166,86,40)', 'rgb(247,129,191)', 'rgb(153,153,153)'] },
            // [Palettes with 2..12 colors]
            Paired: { 2: ['rgb(166,206,227)', 'rgb(31,120,180)'], 3: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)'], 4: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)'], 5: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)'], 6: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)'], 7: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)'], 8: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)', 'rgb(255,127,0)'], 9: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)', 'rgb(255,127,0)', 'rgb(202,178,214)'], 10: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)', 'rgb(255,127,0)', 'rgb(202,178,214)', 'rgb(106,61,154)'], 11: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)', 'rgb(255,127,0)', 'rgb(202,178,214)', 'rgb(106,61,154)', 'rgb(255,255,153)'], 12: ['rgb(166,206,227)', 'rgb(31,120,180)', 'rgb(178,223,138)', 'rgb(51,160,44)', 'rgb(251,154,153)', 'rgb(227,26,28)', 'rgb(253,191,111)', 'rgb(255,127,0)', 'rgb(202,178,214)', 'rgb(106,61,154)', 'rgb(255,255,153)', 'rgb(177,89,40)'] },
            Set3: { 2: ['rgb(141,211,199)', 'rgb(255,255,179)'], 3: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)'], 4: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)'], 5: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)'], 6: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)'], 7: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)'], 8: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)', 'rgb(252,205,229)'], 9: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)', 'rgb(252,205,229)', 'rgb(217,217,217)'], 10: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)', 'rgb(252,205,229)', 'rgb(217,217,217)', 'rgb(188,128,189)'], 11: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)', 'rgb(252,205,229)', 'rgb(217,217,217)', 'rgb(188,128,189)', 'rgb(204,235,197)'], 12: ['rgb(141,211,199)', 'rgb(255,255,179)', 'rgb(190,186,218)', 'rgb(251,128,114)', 'rgb(128,177,211)', 'rgb(253,180,98)', 'rgb(179,222,105)', 'rgb(252,205,229)', 'rgb(217,217,217)', 'rgb(188,128,189)', 'rgb(204,235,197)', 'rgb(255,237,111)'] },
            // Sequential color schemes [all palettes have 2..9 colors]
            Blues: { 2: ['rgb(222,235,247)', 'rgb(158,202,225)'], 3: ['rgb(222,235,247)', 'rgb(158,202,225)', 'rgb(49,130,189)'], 4: ['rgb(239,243,255)', 'rgb(189,215,231)', 'rgb(107,174,214)', 'rgb(33,113,181)'], 5: ['rgb(239,243,255)', 'rgb(189,215,231)', 'rgb(107,174,214)', 'rgb(49,130,189)', 'rgb(8,81,156)'], 6: ['rgb(239,243,255)', 'rgb(198,219,239)', 'rgb(158,202,225)', 'rgb(107,174,214)', 'rgb(49,130,189)', 'rgb(8,81,156)'], 7: ['rgb(239,243,255)', 'rgb(198,219,239)', 'rgb(158,202,225)', 'rgb(107,174,214)', 'rgb(66,146,198)', 'rgb(33,113,181)', 'rgb(8,69,148)'], 8: ['rgb(247,251,255)', 'rgb(222,235,247)', 'rgb(198,219,239)', 'rgb(158,202,225)', 'rgb(107,174,214)', 'rgb(66,146,198)', 'rgb(33,113,181)', 'rgb(8,69,148)'], 9: ['rgb(247,251,255)', 'rgb(222,235,247)', 'rgb(198,219,239)', 'rgb(158,202,225)', 'rgb(107,174,214)', 'rgb(66,146,198)', 'rgb(33,113,181)', 'rgb(8,81,156)', 'rgb(8,48,107)'] },
            Greens: { 2: ['rgb(229,245,224)', 'rgb(161,217,155)'], 3: ['rgb(229,245,224)', 'rgb(161,217,155)', 'rgb(49,163,84)'], 4: ['rgb(237,248,233)', 'rgb(186,228,179)', 'rgb(116,196,118)', 'rgb(35,139,69)'], 5: ['rgb(237,248,233)', 'rgb(186,228,179)', 'rgb(116,196,118)', 'rgb(49,163,84)', 'rgb(0,109,44)'], 6: ['rgb(237,248,233)', 'rgb(199,233,192)', 'rgb(161,217,155)', 'rgb(116,196,118)', 'rgb(49,163,84)', 'rgb(0,109,44)'], 7: ['rgb(237,248,233)', 'rgb(199,233,192)', 'rgb(161,217,155)', 'rgb(116,196,118)', 'rgb(65,171,93)', 'rgb(35,139,69)', 'rgb(0,90,50)'], 8: ['rgb(247,252,245)', 'rgb(229,245,224)', 'rgb(199,233,192)', 'rgb(161,217,155)', 'rgb(116,196,118)', 'rgb(65,171,93)', 'rgb(35,139,69)', 'rgb(0,90,50)'], 9: ['rgb(247,252,245)', 'rgb(229,245,224)', 'rgb(199,233,192)', 'rgb(161,217,155)', 'rgb(116,196,118)', 'rgb(65,171,93)', 'rgb(35,139,69)', 'rgb(0,109,44)', 'rgb(0,68,27)'] },
            Greys: { 2: ['rgb(240,240,240)', 'rgb(189,189,189)'], 3: ['rgb(240,240,240)', 'rgb(189,189,189)', 'rgb(99,99,99)'], 4: ['rgb(247,247,247)', 'rgb(204,204,204)', 'rgb(150,150,150)', 'rgb(82,82,82)'], 5: ['rgb(247,247,247)', 'rgb(204,204,204)', 'rgb(150,150,150)', 'rgb(99,99,99)', 'rgb(37,37,37)'], 6: ['rgb(247,247,247)', 'rgb(217,217,217)', 'rgb(189,189,189)', 'rgb(150,150,150)', 'rgb(99,99,99)', 'rgb(37,37,37)'], 7: ['rgb(247,247,247)', 'rgb(217,217,217)', 'rgb(189,189,189)', 'rgb(150,150,150)', 'rgb(115,115,115)', 'rgb(82,82,82)', 'rgb(37,37,37)'], 8: ['rgb(255,255,255)', 'rgb(240,240,240)', 'rgb(217,217,217)', 'rgb(189,189,189)', 'rgb(150,150,150)', 'rgb(115,115,115)', 'rgb(82,82,82)', 'rgb(37,37,37)'], 9: ['rgb(255,255,255)', 'rgb(227,227,227)', 'rgb(200,200,200)', 'rgb(145,145,145)', 'rgb(127,127,127)', 'rgb(117,117,117)', 'rgb(89,89,89)', 'rgb(62,62,62)', 'rgb(34,34,34)'] },
            Oranges: { 2: ['rgb(254,230,206)', 'rgb(253,174,107)'], 3: ['rgb(254,230,206)', 'rgb(253,174,107)', 'rgb(230,85,13)'], 4: ['rgb(254,237,222)', 'rgb(253,190,133)', 'rgb(253,141,60)', 'rgb(217,71,1)'], 5: ['rgb(254,237,222)', 'rgb(253,190,133)', 'rgb(253,141,60)', 'rgb(230,85,13)', 'rgb(166,54,3)'], 6: ['rgb(254,237,222)', 'rgb(253,208,162)', 'rgb(253,174,107)', 'rgb(253,141,60)', 'rgb(230,85,13)', 'rgb(166,54,3)'], 7: ['rgb(254,237,222)', 'rgb(253,208,162)', 'rgb(253,174,107)', 'rgb(253,141,60)', 'rgb(241,105,19)', 'rgb(217,72,1)', 'rgb(140,45,4)'], 8: ['rgb(255,245,235)', 'rgb(254,230,206)', 'rgb(253,208,162)', 'rgb(253,174,107)', 'rgb(253,141,60)', 'rgb(241,105,19)', 'rgb(217,72,1)', 'rgb(140,45,4)'], 9: ['rgb(255,245,235)', 'rgb(254,230,206)', 'rgb(253,208,162)', 'rgb(253,174,107)', 'rgb(253,141,60)', 'rgb(241,105,19)', 'rgb(217,72,1)', 'rgb(166,54,3)', 'rgb(127,39,4)'] },
            Purples: { 2: ['rgb(239,237,245)', 'rgb(188,189,220)'], 3: ['rgb(239,237,245)', 'rgb(188,189,220)', 'rgb(117,107,177)'], 4: ['rgb(242,240,247)', 'rgb(203,201,226)', 'rgb(158,154,200)', 'rgb(106,81,163)'], 5: ['rgb(242,240,247)', 'rgb(203,201,226)', 'rgb(158,154,200)', 'rgb(117,107,177)', 'rgb(84,39,143)'], 6: ['rgb(242,240,247)', 'rgb(218,218,235)', 'rgb(188,189,220)', 'rgb(158,154,200)', 'rgb(117,107,177)', 'rgb(84,39,143)'], 7: ['rgb(242,240,247)', 'rgb(218,218,235)', 'rgb(188,189,220)', 'rgb(158,154,200)', 'rgb(128,125,186)', 'rgb(106,81,163)', 'rgb(74,20,134)'], 8: ['rgb(252,251,253)', 'rgb(239,237,245)', 'rgb(218,218,235)', 'rgb(188,189,220)', 'rgb(158,154,200)', 'rgb(128,125,186)', 'rgb(106,81,163)', 'rgb(74,20,134)'], 9: ['rgb(252,251,253)', 'rgb(239,237,245)', 'rgb(218,218,235)', 'rgb(188,189,220)', 'rgb(158,154,200)', 'rgb(128,125,186)', 'rgb(106,81,163)', 'rgb(84,39,143)', 'rgb(63,0,125)'] },
            Reds: { 2: ['rgb(254,224,210)', 'rgb(252,146,114)'], 3: ['rgb(254,224,210)', 'rgb(252,146,114)', 'rgb(222,45,38)'], 4: ['rgb(254,229,217)', 'rgb(252,174,145)', 'rgb(251,106,74)', 'rgb(203,24,29)'], 5: ['rgb(254,229,217)', 'rgb(252,174,145)', 'rgb(251,106,74)', 'rgb(222,45,38)', 'rgb(165,15,21)'], 6: ['rgb(254,229,217)', 'rgb(252,187,161)', 'rgb(252,146,114)', 'rgb(251,106,74)', 'rgb(222,45,38)', 'rgb(165,15,21)'], 7: ['rgb(254,229,217)', 'rgb(252,187,161)', 'rgb(252,146,114)', 'rgb(251,106,74)', 'rgb(239,59,44)', 'rgb(203,24,29)', 'rgb(153,0,13)'], 8: ['rgb(255,245,240)', 'rgb(254,224,210)', 'rgb(252,187,161)', 'rgb(252,146,114)', 'rgb(251,106,74)', 'rgb(239,59,44)', 'rgb(203,24,29)', 'rgb(153,0,13)'], 9: ['rgb(255,245,240)', 'rgb(254,224,210)', 'rgb(252,187,161)', 'rgb(252,146,114)', 'rgb(251,106,74)', 'rgb(239,59,44)', 'rgb(203,24,29)', 'rgb(165,15,21)', 'rgb(103,0,13)'] },
            BuGn: { 2: ['rgb(229,245,249)', 'rgb(153,216,201)'], 3: ['rgb(229,245,249)', 'rgb(153,216,201)', 'rgb(44,162,95)'], 4: ['rgb(237,248,251)', 'rgb(178,226,226)', 'rgb(102,194,164)', 'rgb(35,139,69)'], 5: ['rgb(237,248,251)', 'rgb(178,226,226)', 'rgb(102,194,164)', 'rgb(44,162,95)', 'rgb(0,109,44)'], 6: ['rgb(237,248,251)', 'rgb(204,236,230)', 'rgb(153,216,201)', 'rgb(102,194,164)', 'rgb(44,162,95)', 'rgb(0,109,44)'], 7: ['rgb(237,248,251)', 'rgb(204,236,230)', 'rgb(153,216,201)', 'rgb(102,194,164)', 'rgb(65,174,118)', 'rgb(35,139,69)', 'rgb(0,88,36)'], 8: ['rgb(247,252,253)', 'rgb(229,245,249)', 'rgb(204,236,230)', 'rgb(153,216,201)', 'rgb(102,194,164)', 'rgb(65,174,118)', 'rgb(35,139,69)', 'rgb(0,88,36)'], 9: ['rgb(247,252,253)', 'rgb(229,245,249)', 'rgb(204,236,230)', 'rgb(153,216,201)', 'rgb(102,194,164)', 'rgb(65,174,118)', 'rgb(35,139,69)', 'rgb(0,109,44)', 'rgb(0,68,27)'] },
            BuPu: { 2: ['rgb(224,236,244)', 'rgb(136,86,167)'], 3: ['rgb(224,236,244)', 'rgb(158,188,218)', 'rgb(136,86,167)'], 4: ['rgb(237,248,251)', 'rgb(179,205,227)', 'rgb(140,150,198)', 'rgb(136,65,157)'], 5: ['rgb(237,248,251)', 'rgb(179,205,227)', 'rgb(140,150,198)', 'rgb(136,86,167)', 'rgb(129,15,124)'], 6: ['rgb(237,248,251)', 'rgb(191,211,230)', 'rgb(158,188,218)', 'rgb(140,150,198)', 'rgb(136,86,167)', 'rgb(129,15,124)'], 7: ['rgb(237,248,251)', 'rgb(191,211,230)', 'rgb(158,188,218)', 'rgb(140,150,198)', 'rgb(140,107,177)', 'rgb(136,65,157)', 'rgb(110,1,107)'], 8: ['rgb(247,252,253)', 'rgb(224,236,244)', 'rgb(191,211,230)', 'rgb(158,188,218)', 'rgb(140,150,198)', 'rgb(140,107,177)', 'rgb(136,65,157)', 'rgb(110,1,107)'], 9: ['rgb(247,252,253)', 'rgb(224,236,244)', 'rgb(191,211,230)', 'rgb(158,188,218)', 'rgb(140,150,198)', 'rgb(140,107,177)', 'rgb(136,65,157)', 'rgb(129,15,124)', 'rgb(77,0,75)'] },
            GnBu: { 2: ['rgb(224,243,219)', 'rgb(168,221,181)'], 3: ['rgb(224,243,219)', 'rgb(168,221,181)', 'rgb(67,162,202)'], 4: ['rgb(240,249,232)', 'rgb(186,228,188)', 'rgb(123,204,196)', 'rgb(43,140,190)'], 5: ['rgb(240,249,232)', 'rgb(186,228,188)', 'rgb(123,204,196)', 'rgb(67,162,202)', 'rgb(8,104,172)'], 6: ['rgb(240,249,232)', 'rgb(204,235,197)', 'rgb(168,221,181)', 'rgb(123,204,196)', 'rgb(67,162,202)', 'rgb(8,104,172)'], 7: ['rgb(240,249,232)', 'rgb(204,235,197)', 'rgb(168,221,181)', 'rgb(123,204,196)', 'rgb(78,179,211)', 'rgb(43,140,190)', 'rgb(8,88,158)'], 8: ['rgb(247,252,240)', 'rgb(224,243,219)', 'rgb(204,235,197)', 'rgb(168,221,181)', 'rgb(123,204,196)', 'rgb(78,179,211)', 'rgb(43,140,190)', 'rgb(8,88,158)'], 9: ['rgb(247,252,240)', 'rgb(224,243,219)', 'rgb(204,235,197)', 'rgb(168,221,181)', 'rgb(123,204,196)', 'rgb(78,179,211)', 'rgb(43,140,190)', 'rgb(8,104,172)', 'rgb(8,64,129)'] },
            OrRd: { 2: ['rgb(254,232,200)', 'rgb(253,187,132)'], 3: ['rgb(254,232,200)', 'rgb(253,187,132)', 'rgb(227,74,51)'], 4: ['rgb(254,240,217)', 'rgb(253,204,138)', 'rgb(252,141,89)', 'rgb(215,48,31)'], 5: ['rgb(254,240,217)', 'rgb(253,204,138)', 'rgb(252,141,89)', 'rgb(227,74,51)', 'rgb(179,0,0)'], 6: ['rgb(254,240,217)', 'rgb(253,212,158)', 'rgb(253,187,132)', 'rgb(252,141,89)', 'rgb(227,74,51)', 'rgb(179,0,0)'], 7: ['rgb(254,240,217)', 'rgb(253,212,158)', 'rgb(253,187,132)', 'rgb(252,141,89)', 'rgb(239,101,72)', 'rgb(215,48,31)', 'rgb(153,0,0)'], 8: ['rgb(255,247,236)', 'rgb(254,232,200)', 'rgb(253,212,158)', 'rgb(253,187,132)', 'rgb(252,141,89)', 'rgb(239,101,72)', 'rgb(215,48,31)', 'rgb(153,0,0)'], 9: ['rgb(255,247,236)', 'rgb(254,232,200)', 'rgb(253,212,158)', 'rgb(253,187,132)', 'rgb(252,141,89)', 'rgb(239,101,72)', 'rgb(215,48,31)', 'rgb(179,0,0)', 'rgb(127,0,0)'] },
            PuBu: { 2: ['rgb(236,231,242)', 'rgb(166,189,219)'], 3: ['rgb(236,231,242)', 'rgb(166,189,219)', 'rgb(43,140,190)'], 4: ['rgb(241,238,246)', 'rgb(189,201,225)', 'rgb(116,169,207)', 'rgb(5,112,176)'], 5: ['rgb(241,238,246)', 'rgb(189,201,225)', 'rgb(116,169,207)', 'rgb(43,140,190)', 'rgb(4,90,141)'], 6: ['rgb(241,238,246)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(116,169,207)', 'rgb(43,140,190)', 'rgb(4,90,141)'], 7: ['rgb(241,238,246)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(116,169,207)', 'rgb(54,144,192)', 'rgb(5,112,176)', 'rgb(3,78,123)'], 8: ['rgb(255,247,251)', 'rgb(236,231,242)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(116,169,207)', 'rgb(54,144,192)', 'rgb(5,112,176)', 'rgb(3,78,123)'], 9: ['rgb(255,247,251)', 'rgb(236,231,242)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(116,169,207)', 'rgb(54,144,192)', 'rgb(5,112,176)', 'rgb(4,90,141)', 'rgb(2,56,88)'] },
            PuBuGn: { 2: ['rgb(236,226,240)', 'rgb(166,189,219)'], 3: ['rgb(236,226,240)', 'rgb(166,189,219)', 'rgb(28,144,153)'], 4: ['rgb(246,239,247)', 'rgb(189,201,225)', 'rgb(103,169,207)', 'rgb(2,129,138)'], 5: ['rgb(246,239,247)', 'rgb(189,201,225)', 'rgb(103,169,207)', 'rgb(28,144,153)', 'rgb(1,108,89)'], 6: ['rgb(246,239,247)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(103,169,207)', 'rgb(28,144,153)', 'rgb(1,108,89)'], 7: ['rgb(246,239,247)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(103,169,207)', 'rgb(54,144,192)', 'rgb(2,129,138)', 'rgb(1,100,80)'], 8: ['rgb(255,247,251)', 'rgb(236,226,240)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(103,169,207)', 'rgb(54,144,192)', 'rgb(2,129,138)', 'rgb(1,100,80)'], 9: ['rgb(255,247,251)', 'rgb(236,226,240)', 'rgb(208,209,230)', 'rgb(166,189,219)', 'rgb(103,169,207)', 'rgb(54,144,192)', 'rgb(2,129,138)', 'rgb(1,108,89)', 'rgb(1,70,54)'] },
            PuRd: { 2: ['rgb(231,225,239)', 'rgb(201,148,199)'], 3: ['rgb(231,225,239)', 'rgb(201,148,199)', 'rgb(221,28,119)'], 4: ['rgb(241,238,246)', 'rgb(215,181,216)', 'rgb(223,101,176)', 'rgb(206,18,86)'], 5: ['rgb(241,238,246)', 'rgb(215,181,216)', 'rgb(223,101,176)', 'rgb(221,28,119)', 'rgb(152,0,67)'], 6: ['rgb(241,238,246)', 'rgb(212,185,218)', 'rgb(201,148,199)', 'rgb(223,101,176)', 'rgb(221,28,119)', 'rgb(152,0,67)'], 7: ['rgb(241,238,246)', 'rgb(212,185,218)', 'rgb(201,148,199)', 'rgb(223,101,176)', 'rgb(231,41,138)', 'rgb(206,18,86)', 'rgb(145,0,63)'], 8: ['rgb(247,244,249)', 'rgb(231,225,239)', 'rgb(212,185,218)', 'rgb(201,148,199)', 'rgb(223,101,176)', 'rgb(231,41,138)', 'rgb(206,18,86)', 'rgb(145,0,63)'], 9: ['rgb(247,244,249)', 'rgb(231,225,239)', 'rgb(212,185,218)', 'rgb(201,148,199)', 'rgb(223,101,176)', 'rgb(231,41,138)', 'rgb(206,18,86)', 'rgb(152,0,67)', 'rgb(103,0,31)'] },
            RdPu: { 2: ['rgb(253,224,221)', 'rgb(250,159,181)'], 3: ['rgb(253,224,221)', 'rgb(250,159,181)', 'rgb(197,27,138)'], 4: ['rgb(254,235,226)', 'rgb(251,180,185)', 'rgb(247,104,161)', 'rgb(174,1,126)'], 5: ['rgb(254,235,226)', 'rgb(251,180,185)', 'rgb(247,104,161)', 'rgb(197,27,138)', 'rgb(122,1,119)'], 6: ['rgb(254,235,226)', 'rgb(252,197,192)', 'rgb(250,159,181)', 'rgb(247,104,161)', 'rgb(197,27,138)', 'rgb(122,1,119)'], 7: ['rgb(254,235,226)', 'rgb(252,197,192)', 'rgb(250,159,181)', 'rgb(247,104,161)', 'rgb(221,52,151)', 'rgb(174,1,126)', 'rgb(122,1,119)'], 8: ['rgb(255,247,243)', 'rgb(253,224,221)', 'rgb(252,197,192)', 'rgb(250,159,181)', 'rgb(247,104,161)', 'rgb(221,52,151)', 'rgb(174,1,126)', 'rgb(122,1,119)'], 9: ['rgb(255,247,243)', 'rgb(253,224,221)', 'rgb(252,197,192)', 'rgb(250,159,181)', 'rgb(247,104,161)', 'rgb(221,52,151)', 'rgb(174,1,126)', 'rgb(122,1,119)', 'rgb(73,0,106)'] },
            YlGn: { 2: ['rgb(247,252,185)', 'rgb(49,163,84)'], 3: ['rgb(247,252,185)', 'rgb(173,221,142)', 'rgb(49,163,84)'], 4: ['rgb(255,255,204)', 'rgb(194,230,153)', 'rgb(120,198,121)', 'rgb(35,132,67)'], 5: ['rgb(255,255,204)', 'rgb(194,230,153)', 'rgb(120,198,121)', 'rgb(49,163,84)', 'rgb(0,104,55)'], 6: ['rgb(255,255,204)', 'rgb(217,240,163)', 'rgb(173,221,142)', 'rgb(120,198,121)', 'rgb(49,163,84)', 'rgb(0,104,55)'], 7: ['rgb(255,255,204)', 'rgb(217,240,163)', 'rgb(173,221,142)', 'rgb(120,198,121)', 'rgb(65,171,93)', 'rgb(35,132,67)', 'rgb(0,90,50)'], 8: ['rgb(255,255,229)', 'rgb(247,252,185)', 'rgb(217,240,163)', 'rgb(173,221,142)', 'rgb(120,198,121)', 'rgb(65,171,93)', 'rgb(35,132,67)', 'rgb(0,90,50)'], 9: ['rgb(255,255,229)', 'rgb(247,252,185)', 'rgb(217,240,163)', 'rgb(173,221,142)', 'rgb(120,198,121)', 'rgb(65,171,93)', 'rgb(35,132,67)', 'rgb(0,104,55)', 'rgb(0,69,41)'] },
            YlGnBu: { 2: ['rgb(237,248,177)', 'rgb(44,127,184)'], 3: ['rgb(237,248,177)', 'rgb(127,205,187)', 'rgb(44,127,184)'], 4: ['rgb(255,255,204)', 'rgb(161,218,180)', 'rgb(65,182,196)', 'rgb(34,94,168)'], 5: ['rgb(255,255,204)', 'rgb(161,218,180)', 'rgb(65,182,196)', 'rgb(44,127,184)', 'rgb(37,52,148)'], 6: ['rgb(255,255,204)', 'rgb(199,233,180)', 'rgb(127,205,187)', 'rgb(65,182,196)', 'rgb(44,127,184)', 'rgb(37,52,148)'], 7: ['rgb(255,255,204)', 'rgb(199,233,180)', 'rgb(127,205,187)', 'rgb(65,182,196)', 'rgb(29,145,192)', 'rgb(34,94,168)', 'rgb(12,44,132)'], 8: ['rgb(255,255,217)', 'rgb(237,248,177)', 'rgb(199,233,180)', 'rgb(127,205,187)', 'rgb(65,182,196)', 'rgb(29,145,192)', 'rgb(34,94,168)', 'rgb(12,44,132)'], 9: ['rgb(255,255,217)', 'rgb(237,248,177)', 'rgb(199,233,180)', 'rgb(127,205,187)', 'rgb(65,182,196)', 'rgb(29,145,192)', 'rgb(34,94,168)', 'rgb(37,52,148)', 'rgb(8,29,88)'] },
            YlOrBu: { 2: ['rgb(255,247,188)', 'rgb(217,95,14)'], 3: ['rgb(255,247,188)', 'rgb(254,196,79)', 'rgb(217,95,14)'], 4: ['rgb(255,255,212)', 'rgb(254,217,142)', 'rgb(254,153,41)', 'rgb(204,76,2)'], 5: ['rgb(255,255,212)', 'rgb(254,217,142)', 'rgb(254,153,41)', 'rgb(217,95,14)', 'rgb(153,52,4)'], 6: ['rgb(255,255,212)', 'rgb(254,227,145)', 'rgb(254,196,79)', 'rgb(254,153,41)', 'rgb(217,95,14)', 'rgb(153,52,4)'], 7: ['rgb(255,255,212)', 'rgb(254,227,145)', 'rgb(254,196,79)', 'rgb(254,153,41)', 'rgb(236,112,20)', 'rgb(204,76,2)', 'rgb(140,45,4)'], 8: ['rgb(255,255,229)', 'rgb(255,247,188)', 'rgb(254,227,145)', 'rgb(254,196,79)', 'rgb(254,153,41)', 'rgb(236,112,20)', 'rgb(204,76,2)', 'rgb(140,45,4)'], 9: ['rgb(255,255,229)', 'rgb(255,247,188)', 'rgb(254,227,145)', 'rgb(254,196,79)', 'rgb(254,153,41)', 'rgb(236,112,20)', 'rgb(204,76,2)', 'rgb(153,52,4)', 'rgb(102,37,6)'] },
            YlOrRd: { 2: ['rgb(255,237,160)', 'rgb(240,59,32)'], 3: ['rgb(255,237,160)', 'rgb(254,178,76)', 'rgb(240,59,32)'], 4: ['rgb(255,255,178)', 'rgb(254,204,92)', 'rgb(253,141,60)', 'rgb(227,26,28)'], 5: ['rgb(255,255,178)', 'rgb(254,204,92)', 'rgb(253,141,60)', 'rgb(240,59,32)', 'rgb(189,0,38)'], 6: ['rgb(255,255,178)', 'rgb(254,217,118)', 'rgb(254,178,76)', 'rgb(253,141,60)', 'rgb(240,59,32)', 'rgb(189,0,38)'], 7: ['rgb(255,255,178)', 'rgb(254,217,118)', 'rgb(254,178,76)', 'rgb(253,141,60)', 'rgb(252,78,42)', 'rgb(227,26,28)', 'rgb(177,0,38)'], 8: ['rgb(255,255,204)', 'rgb(255,237,160)', 'rgb(254,217,118)', 'rgb(254,178,76)', 'rgb(253,141,60)', 'rgb(252,78,42)', 'rgb(227,26,28)', 'rgb(177,0,38)'], 9: ['rgb(255,255,204)', 'rgb(255,237,160)', 'rgb(254,217,118)', 'rgb(254,178,76)', 'rgb(253,141,60)', 'rgb(252,78,42)', 'rgb(227,26,28)', 'rgb(189,0,38)', 'rgb(128,0,38)'] },
        };
        return colorPalettesClass;
    }());
    beachParty.colorPalettesClass = colorPalettesClass;
    (function (KnownPalettes) {
        //---- diverging ----
        KnownPalettes[KnownPalettes["Spectral"] = 0] = "Spectral";
        KnownPalettes[KnownPalettes["RdYlGn"] = 1] = "RdYlGn";
        KnownPalettes[KnownPalettes["RdBu"] = 2] = "RdBu";
        KnownPalettes[KnownPalettes["PiYG"] = 3] = "PiYG";
        KnownPalettes[KnownPalettes["PRGn"] = 4] = "PRGn";
        KnownPalettes[KnownPalettes["RdYlBu"] = 5] = "RdYlBu";
        KnownPalettes[KnownPalettes["BrBG"] = 6] = "BrBG";
        KnownPalettes[KnownPalettes["RdGy"] = 7] = "RdGy";
        KnownPalettes[KnownPalettes["PuOr"] = 8] = "PuOr";
        KnownPalettes[KnownPalettes["separator1"] = 9] = "separator1";
        //---- sequential ----
        KnownPalettes[KnownPalettes["Blues"] = 10] = "Blues";
        KnownPalettes[KnownPalettes["Greens"] = 11] = "Greens";
        KnownPalettes[KnownPalettes["Greys"] = 12] = "Greys";
        KnownPalettes[KnownPalettes["Oranges"] = 13] = "Oranges";
        KnownPalettes[KnownPalettes["Purples"] = 14] = "Purples";
        KnownPalettes[KnownPalettes["Reds"] = 15] = "Reds";
        KnownPalettes[KnownPalettes["separator2"] = 16] = "separator2";
        KnownPalettes[KnownPalettes["BuGn"] = 17] = "BuGn";
        KnownPalettes[KnownPalettes["BuPu"] = 18] = "BuPu";
        KnownPalettes[KnownPalettes["GnBu"] = 19] = "GnBu";
        KnownPalettes[KnownPalettes["OrRd"] = 20] = "OrRd";
        KnownPalettes[KnownPalettes["PuBu"] = 21] = "PuBu";
        KnownPalettes[KnownPalettes["PuBuGn"] = 22] = "PuBuGn";
        KnownPalettes[KnownPalettes["separator3"] = 23] = "separator3";
        KnownPalettes[KnownPalettes["PuRd"] = 24] = "PuRd";
        KnownPalettes[KnownPalettes["RdPu"] = 25] = "RdPu";
        KnownPalettes[KnownPalettes["YlGn"] = 26] = "YlGn";
        KnownPalettes[KnownPalettes["YlGnBu"] = 27] = "YlGnBu";
        KnownPalettes[KnownPalettes["YlOrBu"] = 28] = "YlOrBu";
        KnownPalettes[KnownPalettes["YlOrRd"] = 29] = "YlOrRd";
        KnownPalettes[KnownPalettes["separator4"] = 30] = "separator4";
        //---- qualitative ----
        KnownPalettes[KnownPalettes["Accent"] = 31] = "Accent";
        KnownPalettes[KnownPalettes["Dark2"] = 32] = "Dark2";
        KnownPalettes[KnownPalettes["Paired"] = 33] = "Paired";
        KnownPalettes[KnownPalettes["Pastel1"] = 34] = "Pastel1";
        KnownPalettes[KnownPalettes["Pastel2"] = 35] = "Pastel2";
        KnownPalettes[KnownPalettes["Set1"] = 36] = "Set1";
        KnownPalettes[KnownPalettes["Set2"] = 37] = "Set2";
        KnownPalettes[KnownPalettes["Set3"] = 38] = "Set3";
    })(beachParty.KnownPalettes // for UI access to palettes
     || (beachParty.KnownPalettes // for UI access to palettes
     = {}));
    var KnownPalettes // for UI access to palettes
     = beachParty.KnownPalettes // for UI access to palettes
    ;
})(beachParty || (beachParty = {}));
var beachParty;
(function (beachParty) {
    var colorTest = (function () {
        function colorTest() {
        }
        colorTest.colorBrewerSchemesEx = {
            // "Note": These 3 members were not part of the original colorbrewer_schemes.js 
            "divergingColorSchemes": ["Spectral", "RdYlGn", "RdBu", "PiYG", "PRGn", "RdYlBu", "BrBG", "RdGy", "PuOr"],
            //"qualitativeColorSchemesOld": ["Khronos", "Accent", "Dark2", "Pastel2", "Set2", "Pastel1", "Set1", "Paired", "Set3"], // MUST be ordered by number of palettes
            "qualitativeColorSchemes": ["Set3", "Paired", "Set1", "Pastel1", "Set2", "Pastel2", "Dark2", "Accent", "Khronos"],
            "sequentialColorSchemes": ["Blues", "Greens", "Greys", "Oranges", "Purples", "Reds", "BuGn", "BuPu", "GnBu", "OrRd", "PuBu", "PuBuGn",
                "PuRd", "RdPu", "YlGn", "YlGnBu", "YlOrBu", "YlOrRd"],
            "customColorSchemes": ["SpectralEx", "RedGreen", "RedBlue"],
            // Diverging color schemes [all palettes have 2..11 colors]
            "Spectral": { "2": ["rgb(252,141,89)", "rgb(153,213,148)"], "3": ["rgb(252,141,89)", "rgb(255,255,191)", "rgb(153,213,148)"], "4": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(171,221,164)", "rgb(43,131,186)"], "5": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(255,255,191)", "rgb(171,221,164)", "rgb(43,131,186)"], "6": ["rgb(213,62,79)", "rgb(252,141,89)", "rgb(254,224,139)", "rgb(230,245,152)", "rgb(153,213,148)", "rgb(50,136,189)"], "7": ["rgb(213,62,79)", "rgb(252,141,89)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(230,245,152)", "rgb(153,213,148)", "rgb(50,136,189)"], "8": ["rgb(213,62,79)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(50,136,189)"], "9": ["rgb(213,62,79)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(50,136,189)"], "10": ["rgb(158,1,66)", "rgb(213,62,79)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(50,136,189)", "rgb(94,79,162)"], "11": ["rgb(158,1,66)", "rgb(213,62,79)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(50,136,189)", "rgb(94,79,162)"] },
            "RdYlGn": { "2": ["rgb(252,141,89)", "rgb(145,207,96)"], "3": ["rgb(252,141,89)", "rgb(255,255,191)", "rgb(145,207,96)"], "4": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(166,217,106)", "rgb(26,150,65)"], "5": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(255,255,191)", "rgb(166,217,106)", "rgb(26,150,65)"], "6": ["rgb(215,48,39)", "rgb(252,141,89)", "rgb(254,224,139)", "rgb(217,239,139)", "rgb(145,207,96)", "rgb(26,152,80)"], "7": ["rgb(215,48,39)", "rgb(252,141,89)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(217,239,139)", "rgb(145,207,96)", "rgb(26,152,80)"], "8": ["rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(217,239,139)", "rgb(166,217,106)", "rgb(102,189,99)", "rgb(26,152,80)"], "9": ["rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(217,239,139)", "rgb(166,217,106)", "rgb(102,189,99)", "rgb(26,152,80)"], "10": ["rgb(165,0,38)", "rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(217,239,139)", "rgb(166,217,106)", "rgb(102,189,99)", "rgb(26,152,80)", "rgb(0,104,55)"], "11": ["rgb(165,0,38)", "rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(217,239,139)", "rgb(166,217,106)", "rgb(102,189,99)", "rgb(26,152,80)", "rgb(0,104,55)"] },
            "RdBu": { "2": ["rgb(239,138,98)", "rgb(103,169,207)"], "3": ["rgb(239,138,98)", "rgb(247,247,247)", "rgb(103,169,207)"], "4": ["rgb(202,0,32)", "rgb(244,165,130)", "rgb(146,197,222)", "rgb(5,113,176)"], "5": ["rgb(202,0,32)", "rgb(244,165,130)", "rgb(247,247,247)", "rgb(146,197,222)", "rgb(5,113,176)"], "6": ["rgb(178,24,43)", "rgb(239,138,98)", "rgb(253,219,199)", "rgb(209,229,240)", "rgb(103,169,207)", "rgb(33,102,172)"], "7": ["rgb(178,24,43)", "rgb(239,138,98)", "rgb(253,219,199)", "rgb(247,247,247)", "rgb(209,229,240)", "rgb(103,169,207)", "rgb(33,102,172)"], "8": ["rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(209,229,240)", "rgb(146,197,222)", "rgb(67,147,195)", "rgb(33,102,172)"], "9": ["rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(247,247,247)", "rgb(209,229,240)", "rgb(146,197,222)", "rgb(67,147,195)", "rgb(33,102,172)"], "10": ["rgb(103,0,31)", "rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(209,229,240)", "rgb(146,197,222)", "rgb(67,147,195)", "rgb(33,102,172)", "rgb(5,48,97)"], "11": ["rgb(103,0,31)", "rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(247,247,247)", "rgb(209,229,240)", "rgb(146,197,222)", "rgb(67,147,195)", "rgb(33,102,172)", "rgb(5,48,97)"] },
            "PiYG": { "2": ["rgb(233,163,201)", "rgb(161,215,106)"], "3": ["rgb(233,163,201)", "rgb(247,247,247)", "rgb(161,215,106)"], "4": ["rgb(208,28,139)", "rgb(241,182,218)", "rgb(184,225,134)", "rgb(77,172,38)"], "5": ["rgb(208,28,139)", "rgb(241,182,218)", "rgb(247,247,247)", "rgb(184,225,134)", "rgb(77,172,38)"], "6": ["rgb(197,27,125)", "rgb(233,163,201)", "rgb(253,224,239)", "rgb(230,245,208)", "rgb(161,215,106)", "rgb(77,146,33)"], "7": ["rgb(197,27,125)", "rgb(233,163,201)", "rgb(253,224,239)", "rgb(247,247,247)", "rgb(230,245,208)", "rgb(161,215,106)", "rgb(77,146,33)"], "8": ["rgb(197,27,125)", "rgb(222,119,174)", "rgb(241,182,218)", "rgb(253,224,239)", "rgb(230,245,208)", "rgb(184,225,134)", "rgb(127,188,65)", "rgb(77,146,33)"], "9": ["rgb(197,27,125)", "rgb(222,119,174)", "rgb(241,182,218)", "rgb(253,224,239)", "rgb(247,247,247)", "rgb(230,245,208)", "rgb(184,225,134)", "rgb(127,188,65)", "rgb(77,146,33)"], "10": ["rgb(142,1,82)", "rgb(197,27,125)", "rgb(222,119,174)", "rgb(241,182,218)", "rgb(253,224,239)", "rgb(230,245,208)", "rgb(184,225,134)", "rgb(127,188,65)", "rgb(77,146,33)", "rgb(39,100,25)"], "11": ["rgb(142,1,82)", "rgb(197,27,125)", "rgb(222,119,174)", "rgb(241,182,218)", "rgb(253,224,239)", "rgb(247,247,247)", "rgb(230,245,208)", "rgb(184,225,134)", "rgb(127,188,65)", "rgb(77,146,33)", "rgb(39,100,25)"] },
            "PRGn": { "2": ["rgb(175,141,195)", "rgb(127,191,123)"], "3": ["rgb(175,141,195)", "rgb(247,247,247)", "rgb(127,191,123)"], "4": ["rgb(123,50,148)", "rgb(194,165,207)", "rgb(166,219,160)", "rgb(0,136,55)"], "5": ["rgb(123,50,148)", "rgb(194,165,207)", "rgb(247,247,247)", "rgb(166,219,160)", "rgb(0,136,55)"], "6": ["rgb(118,42,131)", "rgb(175,141,195)", "rgb(231,212,232)", "rgb(217,240,211)", "rgb(127,191,123)", "rgb(27,120,55)"], "7": ["rgb(118,42,131)", "rgb(175,141,195)", "rgb(231,212,232)", "rgb(247,247,247)", "rgb(217,240,211)", "rgb(127,191,123)", "rgb(27,120,55)"], "8": ["rgb(118,42,131)", "rgb(153,112,171)", "rgb(194,165,207)", "rgb(231,212,232)", "rgb(217,240,211)", "rgb(166,219,160)", "rgb(90,174,97)", "rgb(27,120,55)"], "9": ["rgb(118,42,131)", "rgb(153,112,171)", "rgb(194,165,207)", "rgb(231,212,232)", "rgb(247,247,247)", "rgb(217,240,211)", "rgb(166,219,160)", "rgb(90,174,97)", "rgb(27,120,55)"], "10": ["rgb(64,0,75)", "rgb(118,42,131)", "rgb(153,112,171)", "rgb(194,165,207)", "rgb(231,212,232)", "rgb(217,240,211)", "rgb(166,219,160)", "rgb(90,174,97)", "rgb(27,120,55)", "rgb(0,68,27)"], "11": ["rgb(64,0,75)", "rgb(118,42,131)", "rgb(153,112,171)", "rgb(194,165,207)", "rgb(231,212,232)", "rgb(247,247,247)", "rgb(217,240,211)", "rgb(166,219,160)", "rgb(90,174,97)", "rgb(27,120,55)", "rgb(0,68,27)"] },
            "RdYlBu": { "2": ["rgb(252,141,89)", "rgb(145,191,219)"], "3": ["rgb(252,141,89)", "rgb(255,255,191)", "rgb(145,191,219)"], "4": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(171,217,233)", "rgb(44,123,182)"], "5": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(255,255,191)", "rgb(171,217,233)", "rgb(44,123,182)"], "6": ["rgb(215,48,39)", "rgb(252,141,89)", "rgb(254,224,144)", "rgb(224,243,248)", "rgb(145,191,219)", "rgb(69,117,180)"], "7": ["rgb(215,48,39)", "rgb(252,141,89)", "rgb(254,224,144)", "rgb(255,255,191)", "rgb(224,243,248)", "rgb(145,191,219)", "rgb(69,117,180)"], "8": ["rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,144)", "rgb(224,243,248)", "rgb(171,217,233)", "rgb(116,173,209)", "rgb(69,117,180)"], "9": ["rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,144)", "rgb(255,255,191)", "rgb(224,243,248)", "rgb(171,217,233)", "rgb(116,173,209)", "rgb(69,117,180)"], "10": ["rgb(165,0,38)", "rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,144)", "rgb(224,243,248)", "rgb(171,217,233)", "rgb(116,173,209)", "rgb(69,117,180)", "rgb(49,54,149)"], "11": ["rgb(165,0,38)", "rgb(215,48,39)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,144)", "rgb(255,255,191)", "rgb(224,243,248)", "rgb(171,217,233)", "rgb(116,173,209)", "rgb(69,117,180)", "rgb(49,54,149)"] },
            "BrBG": { "2": ["rgb(216,179,101)", "rgb(90,180,172)"], "3": ["rgb(216,179,101)", "rgb(245,245,245)", "rgb(90,180,172)"], "4": ["rgb(166,97,26)", "rgb(223,194,125)", "rgb(128,205,193)", "rgb(1,133,113)"], "5": ["rgb(166,97,26)", "rgb(223,194,125)", "rgb(245,245,245)", "rgb(128,205,193)", "rgb(1,133,113)"], "6": ["rgb(140,81,10)", "rgb(216,179,101)", "rgb(246,232,195)", "rgb(199,234,229)", "rgb(90,180,172)", "rgb(1,102,94)"], "7": ["rgb(140,81,10)", "rgb(216,179,101)", "rgb(246,232,195)", "rgb(245,245,245)", "rgb(199,234,229)", "rgb(90,180,172)", "rgb(1,102,94)"], "8": ["rgb(140,81,10)", "rgb(191,129,45)", "rgb(223,194,125)", "rgb(246,232,195)", "rgb(199,234,229)", "rgb(128,205,193)", "rgb(53,151,143)", "rgb(1,102,94)"], "9": ["rgb(140,81,10)", "rgb(191,129,45)", "rgb(223,194,125)", "rgb(246,232,195)", "rgb(245,245,245)", "rgb(199,234,229)", "rgb(128,205,193)", "rgb(53,151,143)", "rgb(1,102,94)"], "10": ["rgb(84,48,5)", "rgb(140,81,10)", "rgb(191,129,45)", "rgb(223,194,125)", "rgb(246,232,195)", "rgb(199,234,229)", "rgb(128,205,193)", "rgb(53,151,143)", "rgb(1,102,94)", "rgb(0,60,48)"], "11": ["rgb(84,48,5)", "rgb(140,81,10)", "rgb(191,129,45)", "rgb(223,194,125)", "rgb(246,232,195)", "rgb(245,245,245)", "rgb(199,234,229)", "rgb(128,205,193)", "rgb(53,151,143)", "rgb(1,102,94)", "rgb(0,60,48)"] },
            "RdGy": { "2": ["rgb(239,138,98)", "rgb(153,153,153)"], "3": ["rgb(239,138,98)", "rgb(255,255,255)", "rgb(153,153,153)"], "4": ["rgb(202,0,32)", "rgb(244,165,130)", "rgb(186,186,186)", "rgb(64,64,64)"], "5": ["rgb(202,0,32)", "rgb(244,165,130)", "rgb(255,255,255)", "rgb(186,186,186)", "rgb(64,64,64)"], "6": ["rgb(178,24,43)", "rgb(239,138,98)", "rgb(253,219,199)", "rgb(224,224,224)", "rgb(153,153,153)", "rgb(77,77,77)"], "7": ["rgb(178,24,43)", "rgb(239,138,98)", "rgb(253,219,199)", "rgb(255,255,255)", "rgb(224,224,224)", "rgb(153,153,153)", "rgb(77,77,77)"], "8": ["rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(224,224,224)", "rgb(186,186,186)", "rgb(135,135,135)", "rgb(77,77,77)"], "9": ["rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(255,255,255)", "rgb(224,224,224)", "rgb(186,186,186)", "rgb(135,135,135)", "rgb(77,77,77)"], "10": ["rgb(103,0,31)", "rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(224,224,224)", "rgb(186,186,186)", "rgb(135,135,135)", "rgb(77,77,77)", "rgb(26,26,26)"], "11": ["rgb(103,0,31)", "rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(255,255,255)", "rgb(224,224,224)", "rgb(186,186,186)", "rgb(135,135,135)", "rgb(77,77,77)", "rgb(26,26,26)"] },
            "PuOr": { "2": ["rgb(241,163,64)", "rgb(153,142,195)"], "3": ["rgb(241,163,64)", "rgb(247,247,247)", "rgb(153,142,195)"], "4": ["rgb(230,97,1)", "rgb(253,184,99)", "rgb(178,171,210)", "rgb(94,60,153)"], "5": ["rgb(230,97,1)", "rgb(253,184,99)", "rgb(247,247,247)", "rgb(178,171,210)", "rgb(94,60,153)"], "6": ["rgb(179,88,6)", "rgb(241,163,64)", "rgb(254,224,182)", "rgb(216,218,235)", "rgb(153,142,195)", "rgb(84,39,136)"], "7": ["rgb(179,88,6)", "rgb(241,163,64)", "rgb(254,224,182)", "rgb(247,247,247)", "rgb(216,218,235)", "rgb(153,142,195)", "rgb(84,39,136)"], "8": ["rgb(179,88,6)", "rgb(224,130,20)", "rgb(253,184,99)", "rgb(254,224,182)", "rgb(216,218,235)", "rgb(178,171,210)", "rgb(128,115,172)", "rgb(84,39,136)"], "9": ["rgb(179,88,6)", "rgb(224,130,20)", "rgb(253,184,99)", "rgb(254,224,182)", "rgb(247,247,247)", "rgb(216,218,235)", "rgb(178,171,210)", "rgb(128,115,172)", "rgb(84,39,136)"], "10": ["rgb(127,59,8)", "rgb(179,88,6)", "rgb(224,130,20)", "rgb(253,184,99)", "rgb(254,224,182)", "rgb(216,218,235)", "rgb(178,171,210)", "rgb(128,115,172)", "rgb(84,39,136)", "rgb(45,0,75)"], "11": ["rgb(127,59,8)", "rgb(179,88,6)", "rgb(224,130,20)", "rgb(253,184,99)", "rgb(254,224,182)", "rgb(247,247,247)", "rgb(216,218,235)", "rgb(178,171,210)", "rgb(128,115,172)", "rgb(84,39,136)", "rgb(45,0,75)"] },
            // custom schemes
            "SpectralEx": { "2": ["rgb(215,25,28)", "rgb(43,131,186)"], "3": ["rgb(215,25,28)", "rgb(255,255,191)", "rgb(43,131,186)"], "4": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(171,221,164)", "rgb(43,131,186)"], "5": ["rgb(215,25,28)", "rgb(253,174,97)", "rgb(255,255,191)", "rgb(171,221,164)", "rgb(43,131,186)"], "6": ["rgb(215,25,28)", "rgb(252,141,89)", "rgb(254,224,139)", "rgb(230,245,152)", "rgb(153,213,148)", "rgb(43,131,186)"], "7": ["rgb(215,25,28)", "rgb(252,141,89)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(230,245,152)", "rgb(153,213,148)", "rgb(43,131,186)"], "8": ["rgb(215,25,28)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(43,131,186)"], "9": ["rgb(215,25,28)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(43,131,186)"], "10": ["rgb(215,25,28)", "rgb(213,62,79)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(50,136,189)", "rgb(43,131,186)"], "11": ["rgb(215,25,28)", "rgb(213,62,79)", "rgb(244,109,67)", "rgb(253,174,97)", "rgb(254,224,139)", "rgb(255,255,191)", "rgb(230,245,152)", "rgb(171,221,164)", "rgb(102,194,165)", "rgb(50,136,189)", "rgb(43,131,186)"] },
            "RedGreen": { "2": ["rgb(255, 0, 0)", "rgb(127, 255, 127)"] },
            "RedBlue": { "2": ["rgb(255, 0, 0)", "rgb(0, 0, 255)"] },
            // Qualitative color schemes
            // [Palettes with 2..6 colors]
            "Khronos": { "2": ["rgb(157,190,127)", "rgb(255,255,255)"], "3": ["rgb(157,190,127)", "rgb(232,109,113)", "rgb(255,255,255)"], "4": ["rgb(157,190,127)", "rgb(232,109,113)", "rgb(194,195,178)", "rgb(255,255,255)"], "5": ["rgb(157,190,127)", "rgb(232,109,113)", "rgb(252,238,78)", "rgb(238,160,41)", "rgb(255,255,255)"], "6": ["rgb(157,190,127)", "rgb(232,109,113)", "rgb(252,238,78)", "rgb(238,160,41)", "rgb(194,195,178)", "rgb(255,255,255)"] },
            "Accent": { "2": ["rgb(127,201,127)", "rgb(190,174,212)"], "3": ["rgb(127,201,127)", "rgb(190,174,212)", "rgb(253,192,134)"], "4": ["rgb(127,201,127)", "rgb(190,174,212)", "rgb(253,192,134)", "rgb(255,255,153)"], "5": ["rgb(127,201,127)", "rgb(190,174,212)", "rgb(253,192,134)", "rgb(255,255,153)", "rgb(56,108,176)"], "6": ["rgb(127,201,127)", "rgb(190,174,212)", "rgb(253,192,134)", "rgb(255,255,153)", "rgb(56,108,176)", "rgb(240,2,127)"], "7": ["rgb(127,201,127)", "rgb(190,174,212)", "rgb(253,192,134)", "rgb(255,255,153)", "rgb(56,108,176)", "rgb(240,2,127)", "rgb(191,91,23)"], "8": ["rgb(127,201,127)", "rgb(190,174,212)", "rgb(253,192,134)", "rgb(255,255,153)", "rgb(56,108,176)", "rgb(240,2,127)", "rgb(191,91,23)", "rgb(102,102,102)"] },
            "Dark2": { "2": ["rgb(27,158,119)", "rgb(217,95,2)"], "3": ["rgb(27,158,119)", "rgb(217,95,2)", "rgb(117,112,179)"], "4": ["rgb(27,158,119)", "rgb(217,95,2)", "rgb(117,112,179)", "rgb(231,41,138)"], "5": ["rgb(27,158,119)", "rgb(217,95,2)", "rgb(117,112,179)", "rgb(231,41,138)", "rgb(102,166,30)"], "6": ["rgb(27,158,119)", "rgb(217,95,2)", "rgb(117,112,179)", "rgb(231,41,138)", "rgb(102,166,30)", "rgb(230,171,2)"], "7": ["rgb(27,158,119)", "rgb(217,95,2)", "rgb(117,112,179)", "rgb(231,41,138)", "rgb(102,166,30)", "rgb(230,171,2)", "rgb(166,118,29)"], "8": ["rgb(27,158,119)", "rgb(217,95,2)", "rgb(117,112,179)", "rgb(231,41,138)", "rgb(102,166,30)", "rgb(230,171,2)", "rgb(166,118,29)", "rgb(102,102,102)"] },
            "Pastel2": { "2": ["rgb(179,226,205)", "rgb(253,205,172)"], "3": ["rgb(179,226,205)", "rgb(253,205,172)", "rgb(203,213,232)"], "4": ["rgb(179,226,205)", "rgb(253,205,172)", "rgb(203,213,232)", "rgb(244,202,228)"], "5": ["rgb(179,226,205)", "rgb(253,205,172)", "rgb(203,213,232)", "rgb(244,202,228)", "rgb(230,245,201)"], "6": ["rgb(179,226,205)", "rgb(253,205,172)", "rgb(203,213,232)", "rgb(244,202,228)", "rgb(230,245,201)", "rgb(255,242,174)"], "7": ["rgb(179,226,205)", "rgb(253,205,172)", "rgb(203,213,232)", "rgb(244,202,228)", "rgb(230,245,201)", "rgb(255,242,174)", "rgb(241,226,204)"], "8": ["rgb(179,226,205)", "rgb(253,205,172)", "rgb(203,213,232)", "rgb(244,202,228)", "rgb(230,245,201)", "rgb(255,242,174)", "rgb(241,226,204)", "rgb(204,204,204)"] },
            "Set2": { "2": ["rgb(102,194,165)", "rgb(252,141,98)"], "3": ["rgb(102,194,165)", "rgb(252,141,98)", "rgb(141,160,203)"], "4": ["rgb(102,194,165)", "rgb(252,141,98)", "rgb(141,160,203)", "rgb(231,138,195)"], "5": ["rgb(102,194,165)", "rgb(252,141,98)", "rgb(141,160,203)", "rgb(231,138,195)", "rgb(166,216,84)"], "6": ["rgb(102,194,165)", "rgb(252,141,98)", "rgb(141,160,203)", "rgb(231,138,195)", "rgb(166,216,84)", "rgb(255,217,47)"], "7": ["rgb(102,194,165)", "rgb(252,141,98)", "rgb(141,160,203)", "rgb(231,138,195)", "rgb(166,216,84)", "rgb(255,217,47)", "rgb(229,196,148)"], "8": ["rgb(102,194,165)", "rgb(252,141,98)", "rgb(141,160,203)", "rgb(231,138,195)", "rgb(166,216,84)", "rgb(255,217,47)", "rgb(229,196,148)", "rgb(179,179,179)"] },
            "Pastel1": { "2": ["rgb(251,180,174)", "rgb(179,205,227)"], "3": ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)"], "4": ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)", "rgb(222,203,228)"], "5": ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)", "rgb(222,203,228)", "rgb(254,217,166)"], "6": ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)", "rgb(222,203,228)", "rgb(254,217,166)", "rgb(255,255,204)"], "7": ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)", "rgb(222,203,228)", "rgb(254,217,166)", "rgb(255,255,204)", "rgb(229,216,189)"], "8": ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)", "rgb(222,203,228)", "rgb(254,217,166)", "rgb(255,255,204)", "rgb(229,216,189)", "rgb(253,218,236)"], "9": ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)", "rgb(222,203,228)", "rgb(254,217,166)", "rgb(255,255,204)", "rgb(229,216,189)", "rgb(253,218,236)", "rgb(242,242,242)"] },
            "Set1": { "2": ["rgb(228,26,28)", "rgb(55,126,184)"], "3": ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)"], "4": ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)", "rgb(152,78,163)"], "5": ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)", "rgb(152,78,163)", "rgb(255,127,0)"], "6": ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)", "rgb(152,78,163)", "rgb(255,127,0)", "rgb(255,255,51)"], "7": ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)", "rgb(152,78,163)", "rgb(255,127,0)", "rgb(255,255,51)", "rgb(166,86,40)"], "8": ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)", "rgb(152,78,163)", "rgb(255,127,0)", "rgb(255,255,51)", "rgb(166,86,40)", "rgb(247,129,191)"], "9": ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)", "rgb(152,78,163)", "rgb(255,127,0)", "rgb(255,255,51)", "rgb(166,86,40)", "rgb(247,129,191)", "rgb(153,153,153)"] },
            "Paired": { "2": ["rgb(166,206,227)", "rgb(31,120,180)"], "3": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)"], "4": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)"], "5": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)"], "6": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)", "rgb(227,26,28)"], "7": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)", "rgb(227,26,28)", "rgb(253,191,111)"], "8": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)", "rgb(227,26,28)", "rgb(253,191,111)", "rgb(255,127,0)"], "9": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)", "rgb(227,26,28)", "rgb(253,191,111)", "rgb(255,127,0)", "rgb(202,178,214)"], "10": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)", "rgb(227,26,28)", "rgb(253,191,111)", "rgb(255,127,0)", "rgb(202,178,214)", "rgb(106,61,154)"], "11": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)", "rgb(227,26,28)", "rgb(253,191,111)", "rgb(255,127,0)", "rgb(202,178,214)", "rgb(106,61,154)", "rgb(255,255,153)"], "12": ["rgb(166,206,227)", "rgb(31,120,180)", "rgb(178,223,138)", "rgb(51,160,44)", "rgb(251,154,153)", "rgb(227,26,28)", "rgb(253,191,111)", "rgb(255,127,0)", "rgb(202,178,214)", "rgb(106,61,154)", "rgb(255,255,153)", "rgb(177,89,40)"] },
            "Set3": { "2": ["rgb(141,211,199)", "rgb(255,255,179)"], "3": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)"], "4": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)"], "5": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)"], "6": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)"], "7": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)", "rgb(179,222,105)"], "8": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)", "rgb(179,222,105)", "rgb(252,205,229)"], "9": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)", "rgb(179,222,105)", "rgb(252,205,229)", "rgb(217,217,217)"], "10": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)", "rgb(179,222,105)", "rgb(252,205,229)", "rgb(217,217,217)", "rgb(188,128,189)"], "11": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)", "rgb(179,222,105)", "rgb(252,205,229)", "rgb(217,217,217)", "rgb(188,128,189)", "rgb(204,235,197)"], "12": ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)", "rgb(179,222,105)", "rgb(252,205,229)", "rgb(217,217,217)", "rgb(188,128,189)", "rgb(204,235,197)", "rgb(255,237,111)"] },
            // Sequential color schemes [all palettes have 2..9 colors]
            "Blues": { "2": ["rgb(222,235,247)", "rgb(158,202,225)"], "3": ["rgb(222,235,247)", "rgb(158,202,225)", "rgb(49,130,189)"], "4": ["rgb(239,243,255)", "rgb(189,215,231)", "rgb(107,174,214)", "rgb(33,113,181)"], "5": ["rgb(239,243,255)", "rgb(189,215,231)", "rgb(107,174,214)", "rgb(49,130,189)", "rgb(8,81,156)"], "6": ["rgb(239,243,255)", "rgb(198,219,239)", "rgb(158,202,225)", "rgb(107,174,214)", "rgb(49,130,189)", "rgb(8,81,156)"], "7": ["rgb(239,243,255)", "rgb(198,219,239)", "rgb(158,202,225)", "rgb(107,174,214)", "rgb(66,146,198)", "rgb(33,113,181)", "rgb(8,69,148)"], "8": ["rgb(247,251,255)", "rgb(222,235,247)", "rgb(198,219,239)", "rgb(158,202,225)", "rgb(107,174,214)", "rgb(66,146,198)", "rgb(33,113,181)", "rgb(8,69,148)"], "9": ["rgb(247,251,255)", "rgb(222,235,247)", "rgb(198,219,239)", "rgb(158,202,225)", "rgb(107,174,214)", "rgb(66,146,198)", "rgb(33,113,181)", "rgb(8,81,156)", "rgb(8,48,107)"] },
            "Greens": { "2": ["rgb(229,245,224)", "rgb(161,217,155)"], "3": ["rgb(229,245,224)", "rgb(161,217,155)", "rgb(49,163,84)"], "4": ["rgb(237,248,233)", "rgb(186,228,179)", "rgb(116,196,118)", "rgb(35,139,69)"], "5": ["rgb(237,248,233)", "rgb(186,228,179)", "rgb(116,196,118)", "rgb(49,163,84)", "rgb(0,109,44)"], "6": ["rgb(237,248,233)", "rgb(199,233,192)", "rgb(161,217,155)", "rgb(116,196,118)", "rgb(49,163,84)", "rgb(0,109,44)"], "7": ["rgb(237,248,233)", "rgb(199,233,192)", "rgb(161,217,155)", "rgb(116,196,118)", "rgb(65,171,93)", "rgb(35,139,69)", "rgb(0,90,50)"], "8": ["rgb(247,252,245)", "rgb(229,245,224)", "rgb(199,233,192)", "rgb(161,217,155)", "rgb(116,196,118)", "rgb(65,171,93)", "rgb(35,139,69)", "rgb(0,90,50)"], "9": ["rgb(247,252,245)", "rgb(229,245,224)", "rgb(199,233,192)", "rgb(161,217,155)", "rgb(116,196,118)", "rgb(65,171,93)", "rgb(35,139,69)", "rgb(0,109,44)", "rgb(0,68,27)"] },
            "Greys": { "2": ["rgb(240,240,240)", "rgb(189,189,189)"], "3": ["rgb(240,240,240)", "rgb(189,189,189)", "rgb(99,99,99)"], "4": ["rgb(247,247,247)", "rgb(204,204,204)", "rgb(150,150,150)", "rgb(82,82,82)"], "5": ["rgb(247,247,247)", "rgb(204,204,204)", "rgb(150,150,150)", "rgb(99,99,99)", "rgb(37,37,37)"], "6": ["rgb(247,247,247)", "rgb(217,217,217)", "rgb(189,189,189)", "rgb(150,150,150)", "rgb(99,99,99)", "rgb(37,37,37)"], "7": ["rgb(247,247,247)", "rgb(217,217,217)", "rgb(189,189,189)", "rgb(150,150,150)", "rgb(115,115,115)", "rgb(82,82,82)", "rgb(37,37,37)"], "8": ["rgb(255,255,255)", "rgb(240,240,240)", "rgb(217,217,217)", "rgb(189,189,189)", "rgb(150,150,150)", "rgb(115,115,115)", "rgb(82,82,82)", "rgb(37,37,37)"], "9": ["rgb(255,255,255)", "rgb(227,227,227)", "rgb(200,200,200)", "rgb(145,145,145)", "rgb(127,127,127)", "rgb(117,117,117)", "rgb(89,89,89)", "rgb(62,62,62)", "rgb(34,34,34)"] },
            "Oranges": { "2": ["rgb(254,230,206)", "rgb(253,174,107)"], "3": ["rgb(254,230,206)", "rgb(253,174,107)", "rgb(230,85,13)"], "4": ["rgb(254,237,222)", "rgb(253,190,133)", "rgb(253,141,60)", "rgb(217,71,1)"], "5": ["rgb(254,237,222)", "rgb(253,190,133)", "rgb(253,141,60)", "rgb(230,85,13)", "rgb(166,54,3)"], "6": ["rgb(254,237,222)", "rgb(253,208,162)", "rgb(253,174,107)", "rgb(253,141,60)", "rgb(230,85,13)", "rgb(166,54,3)"], "7": ["rgb(254,237,222)", "rgb(253,208,162)", "rgb(253,174,107)", "rgb(253,141,60)", "rgb(241,105,19)", "rgb(217,72,1)", "rgb(140,45,4)"], "8": ["rgb(255,245,235)", "rgb(254,230,206)", "rgb(253,208,162)", "rgb(253,174,107)", "rgb(253,141,60)", "rgb(241,105,19)", "rgb(217,72,1)", "rgb(140,45,4)"], "9": ["rgb(255,245,235)", "rgb(254,230,206)", "rgb(253,208,162)", "rgb(253,174,107)", "rgb(253,141,60)", "rgb(241,105,19)", "rgb(217,72,1)", "rgb(166,54,3)", "rgb(127,39,4)"] },
            "Purples": { "2": ["rgb(239,237,245)", "rgb(188,189,220)"], "3": ["rgb(239,237,245)", "rgb(188,189,220)", "rgb(117,107,177)"], "4": ["rgb(242,240,247)", "rgb(203,201,226)", "rgb(158,154,200)", "rgb(106,81,163)"], "5": ["rgb(242,240,247)", "rgb(203,201,226)", "rgb(158,154,200)", "rgb(117,107,177)", "rgb(84,39,143)"], "6": ["rgb(242,240,247)", "rgb(218,218,235)", "rgb(188,189,220)", "rgb(158,154,200)", "rgb(117,107,177)", "rgb(84,39,143)"], "7": ["rgb(242,240,247)", "rgb(218,218,235)", "rgb(188,189,220)", "rgb(158,154,200)", "rgb(128,125,186)", "rgb(106,81,163)", "rgb(74,20,134)"], "8": ["rgb(252,251,253)", "rgb(239,237,245)", "rgb(218,218,235)", "rgb(188,189,220)", "rgb(158,154,200)", "rgb(128,125,186)", "rgb(106,81,163)", "rgb(74,20,134)"], "9": ["rgb(252,251,253)", "rgb(239,237,245)", "rgb(218,218,235)", "rgb(188,189,220)", "rgb(158,154,200)", "rgb(128,125,186)", "rgb(106,81,163)", "rgb(84,39,143)", "rgb(63,0,125)"] },
            "Reds": { "2": ["rgb(254,224,210)", "rgb(252,146,114)"], "3": ["rgb(254,224,210)", "rgb(252,146,114)", "rgb(222,45,38)"], "4": ["rgb(254,229,217)", "rgb(252,174,145)", "rgb(251,106,74)", "rgb(203,24,29)"], "5": ["rgb(254,229,217)", "rgb(252,174,145)", "rgb(251,106,74)", "rgb(222,45,38)", "rgb(165,15,21)"], "6": ["rgb(254,229,217)", "rgb(252,187,161)", "rgb(252,146,114)", "rgb(251,106,74)", "rgb(222,45,38)", "rgb(165,15,21)"], "7": ["rgb(254,229,217)", "rgb(252,187,161)", "rgb(252,146,114)", "rgb(251,106,74)", "rgb(239,59,44)", "rgb(203,24,29)", "rgb(153,0,13)"], "8": ["rgb(255,245,240)", "rgb(254,224,210)", "rgb(252,187,161)", "rgb(252,146,114)", "rgb(251,106,74)", "rgb(239,59,44)", "rgb(203,24,29)", "rgb(153,0,13)"], "9": ["rgb(255,245,240)", "rgb(254,224,210)", "rgb(252,187,161)", "rgb(252,146,114)", "rgb(251,106,74)", "rgb(239,59,44)", "rgb(203,24,29)", "rgb(165,15,21)", "rgb(103,0,13)"] },
            "BuGn": { "2": ["rgb(229,245,249)", "rgb(153,216,201)"], "3": ["rgb(229,245,249)", "rgb(153,216,201)", "rgb(44,162,95)"], "4": ["rgb(237,248,251)", "rgb(178,226,226)", "rgb(102,194,164)", "rgb(35,139,69)"], "5": ["rgb(237,248,251)", "rgb(178,226,226)", "rgb(102,194,164)", "rgb(44,162,95)", "rgb(0,109,44)"], "6": ["rgb(237,248,251)", "rgb(204,236,230)", "rgb(153,216,201)", "rgb(102,194,164)", "rgb(44,162,95)", "rgb(0,109,44)"], "7": ["rgb(237,248,251)", "rgb(204,236,230)", "rgb(153,216,201)", "rgb(102,194,164)", "rgb(65,174,118)", "rgb(35,139,69)", "rgb(0,88,36)"], "8": ["rgb(247,252,253)", "rgb(229,245,249)", "rgb(204,236,230)", "rgb(153,216,201)", "rgb(102,194,164)", "rgb(65,174,118)", "rgb(35,139,69)", "rgb(0,88,36)"], "9": ["rgb(247,252,253)", "rgb(229,245,249)", "rgb(204,236,230)", "rgb(153,216,201)", "rgb(102,194,164)", "rgb(65,174,118)", "rgb(35,139,69)", "rgb(0,109,44)", "rgb(0,68,27)"] },
            "BuPu": { "2": ["rgb(224,236,244)", "rgb(136,86,167)"], "3": ["rgb(224,236,244)", "rgb(158,188,218)", "rgb(136,86,167)"], "4": ["rgb(237,248,251)", "rgb(179,205,227)", "rgb(140,150,198)", "rgb(136,65,157)"], "5": ["rgb(237,248,251)", "rgb(179,205,227)", "rgb(140,150,198)", "rgb(136,86,167)", "rgb(129,15,124)"], "6": ["rgb(237,248,251)", "rgb(191,211,230)", "rgb(158,188,218)", "rgb(140,150,198)", "rgb(136,86,167)", "rgb(129,15,124)"], "7": ["rgb(237,248,251)", "rgb(191,211,230)", "rgb(158,188,218)", "rgb(140,150,198)", "rgb(140,107,177)", "rgb(136,65,157)", "rgb(110,1,107)"], "8": ["rgb(247,252,253)", "rgb(224,236,244)", "rgb(191,211,230)", "rgb(158,188,218)", "rgb(140,150,198)", "rgb(140,107,177)", "rgb(136,65,157)", "rgb(110,1,107)"], "9": ["rgb(247,252,253)", "rgb(224,236,244)", "rgb(191,211,230)", "rgb(158,188,218)", "rgb(140,150,198)", "rgb(140,107,177)", "rgb(136,65,157)", "rgb(129,15,124)", "rgb(77,0,75)"] },
            "GnBu": { "2": ["rgb(224,243,219)", "rgb(168,221,181)"], "3": ["rgb(224,243,219)", "rgb(168,221,181)", "rgb(67,162,202)"], "4": ["rgb(240,249,232)", "rgb(186,228,188)", "rgb(123,204,196)", "rgb(43,140,190)"], "5": ["rgb(240,249,232)", "rgb(186,228,188)", "rgb(123,204,196)", "rgb(67,162,202)", "rgb(8,104,172)"], "6": ["rgb(240,249,232)", "rgb(204,235,197)", "rgb(168,221,181)", "rgb(123,204,196)", "rgb(67,162,202)", "rgb(8,104,172)"], "7": ["rgb(240,249,232)", "rgb(204,235,197)", "rgb(168,221,181)", "rgb(123,204,196)", "rgb(78,179,211)", "rgb(43,140,190)", "rgb(8,88,158)"], "8": ["rgb(247,252,240)", "rgb(224,243,219)", "rgb(204,235,197)", "rgb(168,221,181)", "rgb(123,204,196)", "rgb(78,179,211)", "rgb(43,140,190)", "rgb(8,88,158)"], "9": ["rgb(247,252,240)", "rgb(224,243,219)", "rgb(204,235,197)", "rgb(168,221,181)", "rgb(123,204,196)", "rgb(78,179,211)", "rgb(43,140,190)", "rgb(8,104,172)", "rgb(8,64,129)"] },
            "OrRd": { "2": ["rgb(254,232,200)", "rgb(253,187,132)"], "3": ["rgb(254,232,200)", "rgb(253,187,132)", "rgb(227,74,51)"], "4": ["rgb(254,240,217)", "rgb(253,204,138)", "rgb(252,141,89)", "rgb(215,48,31)"], "5": ["rgb(254,240,217)", "rgb(253,204,138)", "rgb(252,141,89)", "rgb(227,74,51)", "rgb(179,0,0)"], "6": ["rgb(254,240,217)", "rgb(253,212,158)", "rgb(253,187,132)", "rgb(252,141,89)", "rgb(227,74,51)", "rgb(179,0,0)"], "7": ["rgb(254,240,217)", "rgb(253,212,158)", "rgb(253,187,132)", "rgb(252,141,89)", "rgb(239,101,72)", "rgb(215,48,31)", "rgb(153,0,0)"], "8": ["rgb(255,247,236)", "rgb(254,232,200)", "rgb(253,212,158)", "rgb(253,187,132)", "rgb(252,141,89)", "rgb(239,101,72)", "rgb(215,48,31)", "rgb(153,0,0)"], "9": ["rgb(255,247,236)", "rgb(254,232,200)", "rgb(253,212,158)", "rgb(253,187,132)", "rgb(252,141,89)", "rgb(239,101,72)", "rgb(215,48,31)", "rgb(179,0,0)", "rgb(127,0,0)"] },
            "PuBu": { "2": ["rgb(236,231,242)", "rgb(166,189,219)"], "3": ["rgb(236,231,242)", "rgb(166,189,219)", "rgb(43,140,190)"], "4": ["rgb(241,238,246)", "rgb(189,201,225)", "rgb(116,169,207)", "rgb(5,112,176)"], "5": ["rgb(241,238,246)", "rgb(189,201,225)", "rgb(116,169,207)", "rgb(43,140,190)", "rgb(4,90,141)"], "6": ["rgb(241,238,246)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(116,169,207)", "rgb(43,140,190)", "rgb(4,90,141)"], "7": ["rgb(241,238,246)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(116,169,207)", "rgb(54,144,192)", "rgb(5,112,176)", "rgb(3,78,123)"], "8": ["rgb(255,247,251)", "rgb(236,231,242)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(116,169,207)", "rgb(54,144,192)", "rgb(5,112,176)", "rgb(3,78,123)"], "9": ["rgb(255,247,251)", "rgb(236,231,242)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(116,169,207)", "rgb(54,144,192)", "rgb(5,112,176)", "rgb(4,90,141)", "rgb(2,56,88)"] },
            "PuBuGn": { "2": ["rgb(236,226,240)", "rgb(166,189,219)"], "3": ["rgb(236,226,240)", "rgb(166,189,219)", "rgb(28,144,153)"], "4": ["rgb(246,239,247)", "rgb(189,201,225)", "rgb(103,169,207)", "rgb(2,129,138)"], "5": ["rgb(246,239,247)", "rgb(189,201,225)", "rgb(103,169,207)", "rgb(28,144,153)", "rgb(1,108,89)"], "6": ["rgb(246,239,247)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(103,169,207)", "rgb(28,144,153)", "rgb(1,108,89)"], "7": ["rgb(246,239,247)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(103,169,207)", "rgb(54,144,192)", "rgb(2,129,138)", "rgb(1,100,80)"], "8": ["rgb(255,247,251)", "rgb(236,226,240)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(103,169,207)", "rgb(54,144,192)", "rgb(2,129,138)", "rgb(1,100,80)"], "9": ["rgb(255,247,251)", "rgb(236,226,240)", "rgb(208,209,230)", "rgb(166,189,219)", "rgb(103,169,207)", "rgb(54,144,192)", "rgb(2,129,138)", "rgb(1,108,89)", "rgb(1,70,54)"] },
            "PuRd": { "2": ["rgb(231,225,239)", "rgb(201,148,199)"], "3": ["rgb(231,225,239)", "rgb(201,148,199)", "rgb(221,28,119)"], "4": ["rgb(241,238,246)", "rgb(215,181,216)", "rgb(223,101,176)", "rgb(206,18,86)"], "5": ["rgb(241,238,246)", "rgb(215,181,216)", "rgb(223,101,176)", "rgb(221,28,119)", "rgb(152,0,67)"], "6": ["rgb(241,238,246)", "rgb(212,185,218)", "rgb(201,148,199)", "rgb(223,101,176)", "rgb(221,28,119)", "rgb(152,0,67)"], "7": ["rgb(241,238,246)", "rgb(212,185,218)", "rgb(201,148,199)", "rgb(223,101,176)", "rgb(231,41,138)", "rgb(206,18,86)", "rgb(145,0,63)"], "8": ["rgb(247,244,249)", "rgb(231,225,239)", "rgb(212,185,218)", "rgb(201,148,199)", "rgb(223,101,176)", "rgb(231,41,138)", "rgb(206,18,86)", "rgb(145,0,63)"], "9": ["rgb(247,244,249)", "rgb(231,225,239)", "rgb(212,185,218)", "rgb(201,148,199)", "rgb(223,101,176)", "rgb(231,41,138)", "rgb(206,18,86)", "rgb(152,0,67)", "rgb(103,0,31)"] },
            "RdPu": { "2": ["rgb(253,224,221)", "rgb(250,159,181)"], "3": ["rgb(253,224,221)", "rgb(250,159,181)", "rgb(197,27,138)"], "4": ["rgb(254,235,226)", "rgb(251,180,185)", "rgb(247,104,161)", "rgb(174,1,126)"], "5": ["rgb(254,235,226)", "rgb(251,180,185)", "rgb(247,104,161)", "rgb(197,27,138)", "rgb(122,1,119)"], "6": ["rgb(254,235,226)", "rgb(252,197,192)", "rgb(250,159,181)", "rgb(247,104,161)", "rgb(197,27,138)", "rgb(122,1,119)"], "7": ["rgb(254,235,226)", "rgb(252,197,192)", "rgb(250,159,181)", "rgb(247,104,161)", "rgb(221,52,151)", "rgb(174,1,126)", "rgb(122,1,119)"], "8": ["rgb(255,247,243)", "rgb(253,224,221)", "rgb(252,197,192)", "rgb(250,159,181)", "rgb(247,104,161)", "rgb(221,52,151)", "rgb(174,1,126)", "rgb(122,1,119)"], "9": ["rgb(255,247,243)", "rgb(253,224,221)", "rgb(252,197,192)", "rgb(250,159,181)", "rgb(247,104,161)", "rgb(221,52,151)", "rgb(174,1,126)", "rgb(122,1,119)", "rgb(73,0,106)"] },
            "YlGn": { "2": ["rgb(247,252,185)", "rgb(49,163,84)"], "3": ["rgb(247,252,185)", "rgb(173,221,142)", "rgb(49,163,84)"], "4": ["rgb(255,255,204)", "rgb(194,230,153)", "rgb(120,198,121)", "rgb(35,132,67)"], "5": ["rgb(255,255,204)", "rgb(194,230,153)", "rgb(120,198,121)", "rgb(49,163,84)", "rgb(0,104,55)"], "6": ["rgb(255,255,204)", "rgb(217,240,163)", "rgb(173,221,142)", "rgb(120,198,121)", "rgb(49,163,84)", "rgb(0,104,55)"], "7": ["rgb(255,255,204)", "rgb(217,240,163)", "rgb(173,221,142)", "rgb(120,198,121)", "rgb(65,171,93)", "rgb(35,132,67)", "rgb(0,90,50)"], "8": ["rgb(255,255,229)", "rgb(247,252,185)", "rgb(217,240,163)", "rgb(173,221,142)", "rgb(120,198,121)", "rgb(65,171,93)", "rgb(35,132,67)", "rgb(0,90,50)"], "9": ["rgb(255,255,229)", "rgb(247,252,185)", "rgb(217,240,163)", "rgb(173,221,142)", "rgb(120,198,121)", "rgb(65,171,93)", "rgb(35,132,67)", "rgb(0,104,55)", "rgb(0,69,41)"] },
            "YlGnBu": { "2": ["rgb(237,248,177)", "rgb(44,127,184)"], "3": ["rgb(237,248,177)", "rgb(127,205,187)", "rgb(44,127,184)"], "4": ["rgb(255,255,204)", "rgb(161,218,180)", "rgb(65,182,196)", "rgb(34,94,168)"], "5": ["rgb(255,255,204)", "rgb(161,218,180)", "rgb(65,182,196)", "rgb(44,127,184)", "rgb(37,52,148)"], "6": ["rgb(255,255,204)", "rgb(199,233,180)", "rgb(127,205,187)", "rgb(65,182,196)", "rgb(44,127,184)", "rgb(37,52,148)"], "7": ["rgb(255,255,204)", "rgb(199,233,180)", "rgb(127,205,187)", "rgb(65,182,196)", "rgb(29,145,192)", "rgb(34,94,168)", "rgb(12,44,132)"], "8": ["rgb(255,255,217)", "rgb(237,248,177)", "rgb(199,233,180)", "rgb(127,205,187)", "rgb(65,182,196)", "rgb(29,145,192)", "rgb(34,94,168)", "rgb(12,44,132)"], "9": ["rgb(255,255,217)", "rgb(237,248,177)", "rgb(199,233,180)", "rgb(127,205,187)", "rgb(65,182,196)", "rgb(29,145,192)", "rgb(34,94,168)", "rgb(37,52,148)", "rgb(8,29,88)"] },
            "YlOrBu": { "2": ["rgb(255,247,188)", "rgb(217,95,14)"], "3": ["rgb(255,247,188)", "rgb(254,196,79)", "rgb(217,95,14)"], "4": ["rgb(255,255,212)", "rgb(254,217,142)", "rgb(254,153,41)", "rgb(204,76,2)"], "5": ["rgb(255,255,212)", "rgb(254,217,142)", "rgb(254,153,41)", "rgb(217,95,14)", "rgb(153,52,4)"], "6": ["rgb(255,255,212)", "rgb(254,227,145)", "rgb(254,196,79)", "rgb(254,153,41)", "rgb(217,95,14)", "rgb(153,52,4)"], "7": ["rgb(255,255,212)", "rgb(254,227,145)", "rgb(254,196,79)", "rgb(254,153,41)", "rgb(236,112,20)", "rgb(204,76,2)", "rgb(140,45,4)"], "8": ["rgb(255,255,229)", "rgb(255,247,188)", "rgb(254,227,145)", "rgb(254,196,79)", "rgb(254,153,41)", "rgb(236,112,20)", "rgb(204,76,2)", "rgb(140,45,4)"], "9": ["rgb(255,255,229)", "rgb(255,247,188)", "rgb(254,227,145)", "rgb(254,196,79)", "rgb(254,153,41)", "rgb(236,112,20)", "rgb(204,76,2)", "rgb(153,52,4)", "rgb(102,37,6)"] },
            "YlOrRd": { "2": ["rgb(255,237,160)", "rgb(240,59,32)"], "3": ["rgb(255,237,160)", "rgb(254,178,76)", "rgb(240,59,32)"], "4": ["rgb(255,255,178)", "rgb(254,204,92)", "rgb(253,141,60)", "rgb(227,26,28)"], "5": ["rgb(255,255,178)", "rgb(254,204,92)", "rgb(253,141,60)", "rgb(240,59,32)", "rgb(189,0,38)"], "6": ["rgb(255,255,178)", "rgb(254,217,118)", "rgb(254,178,76)", "rgb(253,141,60)", "rgb(240,59,32)", "rgb(189,0,38)"], "7": ["rgb(255,255,178)", "rgb(254,217,118)", "rgb(254,178,76)", "rgb(253,141,60)", "rgb(252,78,42)", "rgb(227,26,28)", "rgb(177,0,38)"], "8": ["rgb(255,255,204)", "rgb(255,237,160)", "rgb(254,217,118)", "rgb(254,178,76)", "rgb(253,141,60)", "rgb(252,78,42)", "rgb(227,26,28)", "rgb(177,0,38)"], "9": ["rgb(255,255,204)", "rgb(255,237,160)", "rgb(254,217,118)", "rgb(254,178,76)", "rgb(253,141,60)", "rgb(252,78,42)", "rgb(227,26,28)", "rgb(189,0,38)", "rgb(128,0,38)"] },
        };
        return colorTest;
    }());
    beachParty.colorTest = colorTest;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    container.ts - layout class that manages a set of sub-containers or shapes.
//-------------------------------------------------------------------------------------
//var mediumSales: any[];
var beachParty;
(function (beachParty) {
    var Container = (function () {
        function Container(data, level, binMap) {
            this.statType = null;
            this.statColName = "";
            this.inputData = data;
            this.childData = new beachParty.frameOrArrayClass(data, data._groupName);
            this.name = data._groupName;
            this.children = [];
            this.level = level;
            this.binMap = (binMap) ? binMap : {};
            //---- add my binInfo to binMap ----
            if (data._groupColName) {
                this.binMap = vp.utils.copyMap(this.binMap);
                this.binMap[data._groupColName] = data._groupName;
            }
        }
        Container.prototype.binAndGen = function (dividers) {
            var divideLevel = this.level;
            if (divideLevel < dividers.length) {
                var dataDivider = dividers[divideLevel].dd;
                //var spaceDivider = <SpaceDivider> dividers[divideLevel].sd;
                //---- divide the DATA ----
                var dataGroups = dataDivider.divide(this.inputData);
                if (dataGroups) {
                    //---- data was BINNED ----
                    this.childData = new beachParty.frameOrArrayClass(dataGroups, this.inputData._groupName);
                    if (divideLevel != dividers.length - 1) {
                        //---- not at leaf, so create subContainers ----
                        var childLevel = divideLevel + 1;
                        //---- create child containers for each data group ----
                        for (var i = 0; i < dataGroups.length; i++) {
                            var childData = dataGroups[i];
                            var child = new Container(childData, childLevel, this.binMap);
                            this.children.push(child);
                            if (true) {
                                //---- use next set of dividers on this ----
                                child.binAndGen(dividers);
                            }
                        }
                    }
                }
            }
        };
        Container.prototype.measure = function (dividers) {
            var scaleData = new ScaleData();
            if (dividers && dividers.length) {
                var divider = dividers[this.level];
                var spaceDivider = divider.sd;
                var xStat = spaceDivider.xStat;
                var yStat = spaceDivider.yStat;
                if (this.children.length === 0) {
                    //---- process LEAF container ----
                    var data = this.childData;
                    scaleData.minCount = data.length;
                    scaleData.maxCount = data.length;
                    if (xStat.colName) {
                        var vector = data.getNumericVectorFromStat(xStat).values;
                        scaleData.xMin = vector.min();
                        scaleData.xMax = vector.max();
                    }
                    if (yStat.colName) {
                        var vector = data.getNumericVectorFromStat(yStat).values;
                        scaleData.yMin = vector.min();
                        scaleData.yMax = vector.max();
                    }
                    var shapeData = this.aggOrCopy(this.childData, divider);
                    this.shapeData = shapeData;
                    scaleData.allLeafData = shapeData;
                }
                else {
                    //---- process INNER container ----
                    for (var i = 0; i < this.children.length; i++) {
                        var child = this.children[i];
                        var results = child.measure(dividers);
                        var sd = results.scaleData;
                        if (i == 0) {
                            scaleData = sd;
                        }
                        else {
                            scaleData.minCount = Math.min(scaleData.minCount, sd.minCount);
                            scaleData.maxCount = Math.max(scaleData.maxCount, sd.maxCount);
                            scaleData.xMin = Math.min(scaleData.xMin, sd.xMin);
                            scaleData.xMax = Math.max(scaleData.xMax, sd.xMax);
                            scaleData.yMin = Math.min(scaleData.yMin, sd.yMin);
                            scaleData.yMax = Math.max(scaleData.yMax, sd.yMax);
                            if (scaleData.allLeafData) {
                                var dataCopy = scaleData.allLeafData.copyData();
                                dataCopy.append(sd.allLeafData);
                                scaleData.allLeafData = dataCopy;
                            }
                            else {
                                scaleData.allLeafData = sd.allLeafData;
                            }
                        }
                    }
                }
            }
            return { scaleData: scaleData };
        };
        Container.prototype.layout = function (dividers, cellData, scaleData, svg, leafRcArray) {
            var primaryShapeSize = null;
            if (dividers && dividers.length) {
                var div0 = dividers[0];
                if (div0.shapeLayers && div0.shapeLayers.length) {
                    primaryShapeSize = div0.shapeLayers[0].shapeSize;
                }
            }
            if (this.level < dividers.length) {
                var divider = dividers[this.level];
                var spaceDivider = divider.sd;
                //---- divide the SPACE ----
                var cellArray = spaceDivider.divide(cellData, this.name, this.childData, primaryShapeSize, scaleData, svg);
                //---- call LAYOUT for children, if any ----
                for (var i = 0; i < this.children.length; i++) {
                    var child = this.children[i];
                    var cdChild = cellArray[i];
                    if (child && cdChild) {
                        child.layout(dividers, cdChild, scaleData, svg, leafRcArray);
                    }
                }
                //---- for last divider PAIR, assign shapes ----
                if (this.level == dividers.length - 1) {
                    //---- ASSIGN SHAPES ----
                    if (leafRcArray) {
                        for (var i = 0; i < cellArray.length; i++) {
                            var cellData = cellArray[i];
                            leafRcArray.push(cellData);
                        }
                    }
                }
                //---- render each layer of shapes ----
                var shapeMakers = divider.shapeLayers;
                for (var i = 0; i < shapeMakers.length; i++) {
                    var shapeMaker = shapeMakers[i];
                    shapeMaker.generate(cellArray, this.shapeData, scaleData.allLeafData);
                }
            }
        };
        Container.prototype.addAggColumn = function (df, record, stat, colName, statType) {
            if (!stat) {
                stat = new beachParty.StatInfo(colName, statType);
            }
            if (stat.colName) {
                if (true) {
                    var aggColName = stat.getAggColName();
                    if (record[aggColName] == undefined && record[stat.colName] == undefined) {
                        var value = df.aggData(stat);
                        record[aggColName] = value;
                    }
                }
            }
        };
        Container.prototype.aggOrCopy = function (anyData, divider) {
            var newData = null;
            if (anyData.single) {
                newData = anyData.single.copyData();
            }
            else {
                var dfa = anyData.array;
                var records = [];
                var sd = divider.sd;
                //---- process each group of data into record ----
                for (var i = 0; i < dfa.length; i++) {
                    //---- create an aggregated record ----
                    var record = {};
                    var df = dfa[i];
                    var value = null;
                    //---- add each col of binColumns ----
                    var keys = vp.utils.keys(this.binMap);
                    for (var b = 0; b < keys.length; b++) {
                        var colName = keys[b];
                        value = this.binMap[colName];
                        record[colName] = value;
                    }
                    //---- add my binCol and value ----
                    var colName = df._groupColName;
                    value = df._groupName;
                    record[colName] = value;
                    //---- for the X, Y, and Color columns, if they are not category columns, we aggregate their data ----
                    //---- and add the colName/value to the aggregate record. ----
                    this.addAggColumn(df, record, sd.xStat);
                    this.addAggColumn(df, record, sd.yStat);
                    //---- add COLOR column, from each shapeMaker ----
                    var shapeMakers = divider.shapeLayers;
                    for (var s = 0; s < shapeMakers.length; s++) {
                        var shapeMaker = shapeMakers[s];
                        this.addAggColumn(df, record, null, shapeMaker.fillColorMapping.colName, shapeMaker.fillColorStat);
                        this.addAggColumn(df, record, null, shapeMaker.strokeColorMapping.colName, shapeMaker.strokeColorStat);
                    }
                    records.push(record);
                }
                newData = beachParty.dataFrameClass.jsonToDataFrame(records);
            }
            return newData;
        };
        return Container;
    }());
    beachParty.Container = Container;
    var ScaleData = (function () {
        function ScaleData() {
        }
        return ScaleData;
    }());
    beachParty.ScaleData = ScaleData;
    var ChartDivider = (function () {
        function ChartDivider(svg, dd, sd, shapeMaker1, shapeMaker2) {
            this.dd = dd || new beachParty.DataDivider();
            this.sd = sd || new beachParty.SpaceDivider();
            shapeMaker1 = shapeMaker1 || new beachParty.ShapeMaker(svg, beachParty.ShapeType.rectangle);
            shapeMaker2 = shapeMaker2 || new beachParty.ShapeMaker(svg, beachParty.ShapeType.none);
            this.shapeLayers = [shapeMaker1, shapeMaker2];
        }
        return ChartDivider;
    }());
    beachParty.ChartDivider = ChartDivider;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    dataDivider.ts - divides data into groups.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var DataDivider = (function () {
        function DataDivider(colName, groupCount, groupingType, aggregateType, groupSorting) {
            if (colName === void 0) { colName = ""; }
            if (groupCount === void 0) { groupCount = 5; }
            if (groupingType === void 0) { groupingType = GroupingType.bin; }
            if (aggregateType === void 0) { aggregateType = AggregateType.none; }
            if (groupSorting === void 0) { groupSorting = beachParty.BinSorting.none; }
            this.colName = colName;
            this.groupingType = groupingType;
            this.aggregateType = aggregateType;
            this.groupCount = groupCount;
            this.groupSorting = groupSorting;
        }
        DataDivider.prototype.divide = function (dataFrame) {
            var _this = this;
            var newData = null; // default output
            //vp.utils.debug("dataDivider.divide: orig data.length=" + data.length);
            if (this.colName && this.groupingType != GroupingType.none && dataFrame.getRecordCount()) {
                if (this.groupingType == GroupingType.bin) {
                    var requestedBins = this.groupCount;
                    var sortOptions = new beachParty.binSortOptionsClass();
                    sortOptions.sortDirection = this.groupSorting;
                    sortOptions.sortByAggregateType = "count";
                    var maxCount = 0;
                    //---- create a NamedVector object for binHelper ----
                    var nv = new beachParty.NamedVectors(dataFrame.getRecordCount());
                    nv.x = dataFrame.getNumericVector(this.colName);
                    var binResults = beachParty.binHelper.createBins(nv, "x", requestedBins, requestedBins, false, true, true, sortOptions, null, false);
                    var bins = binResults.bins;
                    newData = bins.map(function (bin) {
                        var group = dataFrame.copyData(bin.rowIndexes);
                        group._groupName = bin.name;
                        group._groupColName = _this.colName;
                        return group;
                    });
                }
            }
            return newData;
        };
        return DataDivider;
    }());
    beachParty.DataDivider = DataDivider;
    (function (GroupingType) {
        GroupingType[GroupingType["none"] = 0] = "none";
        GroupingType[GroupingType["bin"] = 1] = "bin";
        GroupingType[GroupingType["multiBin"] = 2] = "multiBin";
    })(beachParty.GroupingType || (beachParty.GroupingType = {}));
    var GroupingType = beachParty.GroupingType;
    (function (AggregateType) {
        AggregateType[AggregateType["none"] = 0] = "none";
        AggregateType[AggregateType["count"] = 1] = "count";
        AggregateType[AggregateType["sum"] = 2] = "sum";
    })(beachParty.AggregateType || (beachParty.AggregateType = {}));
    var AggregateType = beachParty.AggregateType;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    frameOrArray.ts - encapsulates an array of dataFrameClass or a single instance.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var frameOrArrayClass = (function () {
        function frameOrArrayClass(data, name) {
            if (vp.utils.isArray(data)) {
                this.array = data;
                this.length = data.length;
            }
            else if (data.getVector) {
                this.single = data;
                this.length = this.single.getRecordCount();
            }
            else {
                throw "Error: not a dataFrame or an Array";
            }
            this.name = name;
        }
        frameOrArrayClass.prototype.slice = function (from, to) {
            var value = null;
            if (this.array) {
                value = this.array.slice(from, to);
            }
            else {
                value = this.single.copyData(vp.data.range(from, to));
            }
            var foa = new frameOrArrayClass(value, this.name);
            return foa;
        };
        frameOrArrayClass.prototype.getItem = function (index) {
            var item = null;
            if (this.array) {
                item = this.array[index];
            }
            else if (this.single) {
                item = this.single.getRecordByVectorIndex(index);
            }
            return item;
        };
        frameOrArrayClass.prototype.getVector = function (colName, countIfArray) {
            var vector = null;
            if (this.single) {
                vector = this.single.getVector(colName, false);
            }
            else {
                //---- array of dataFrames ----
                if (this.array.length) {
                    //---- ensure colName exists on first dataFrame ----
                    var firstDf = this.array[0];
                    if (firstDf._groupColName == colName) {
                        vector = this.array.map(function (df) {
                            return df._groupName;
                        });
                    }
                    else if (countIfArray) {
                        if (firstDf.getVector(colName, false)) {
                            vector = this.array.map(function (df) {
                                return df.getRecordCount();
                            });
                        }
                    }
                }
            }
            return vector;
        };
        frameOrArrayClass.prototype.getNumericVectorFromStat = function (statInfo, countIfArray) {
            var numVector = null;
            var colName = statInfo.colName;
            if (colName || statInfo.statType == beachParty.StatType.count) {
                var aggColName = statInfo.getAggColName();
                if (this.single) {
                    if (this.single.isColumnName(aggColName)) {
                        colName = aggColName;
                    }
                    if (statInfo.statType == beachParty.StatType.count) {
                        var vector = vp.data.dataRepeat(1, this.single.getRecordCount());
                        numVector = new beachParty.NumericVector(vector, "Count@", "number", null);
                    }
                    else {
                        numVector = this.single.getNumericVector(colName);
                    }
                }
                else {
                    vector = [];
                    for (var i = 0; i < this.array.length; i++) {
                        var df = this.array[i];
                        var value = df.aggData(statInfo);
                        vector.push(value);
                    }
                    numVector = new beachParty.NumericVector(vector, "aggColName", "number", null);
                }
            }
            return numVector;
        };
        frameOrArrayClass.prototype.map = function (callback) {
            var value = null;
            if (this.array) {
                value = this.array.map(callback);
            }
            else {
                var firstName = this.single.getColumnNames()[0];
                var firstVector = this.single.getVector(firstName, false);
                value = firstVector.map(callback);
            }
            return value;
        };
        return frameOrArrayClass;
    }());
    beachParty.frameOrArrayClass = frameOrArrayClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    shapeMaker.ts - generates shapes for containers.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var ShapeMaker = (function () {
        function ShapeMaker(svg, shapeType, shapeSize, shapeFill, shapeStroke, strokeSize) {
            if (shapeType === void 0) { shapeType = ShapeType.rectangle; }
            if (shapeSize === void 0) { shapeSize = 10; }
            if (shapeFill === void 0) { shapeFill = "none"; }
            if (shapeStroke === void 0) { shapeStroke = "#333"; }
            if (strokeSize === void 0) { strokeSize = 1; }
            this.textSize = 16;
            this.fillColorStat = beachParty.StatType.none;
            this.strokeColorStat = beachParty.StatType.none;
            this.svg = svg;
            this.shapeType = shapeType;
            this.shapeFill = shapeFill;
            this.shapeStroke = shapeStroke;
            this.shapeSize = shapeSize;
            this.strokeSize = strokeSize;
            this.opacity = 1;
            this.textCol = "";
            this.fillColorMapping = new beachParty.ColorMappingData("", "", false, 12);
            this.strokeColorMapping = new beachParty.ColorMappingData("", "", false, 12);
        }
        ShapeMaker.prototype.generate = function (cellArray, data, allData) {
            this.fillScale = null;
            this.strokeScale = null;
            if (this.svg) {
                var svgParentW = vp.select(this.svg);
                var rcAll = svgParentW.getBounds(false);
                rcAll = vp.geom.createRect(0, 0, rcAll.width, rcAll.height);
                //---- build color scales, if needed ----
                if (this.fillColorMapping.colName) {
                    this.buildColorPaletteFromSettings(this.fillColorMapping, allData);
                    //---- use allData to build color scale (for consistency and full color range across containers) ----
                    var result = this.buildShapeColorScale(this.fillColorMapping, this.fillColorStat, allData);
                    this.fillScale = result.scale;
                    this.fillVector = null;
                    if (this.fillScale) {
                        //---- use data to build fillVector (for color values for this container) ----
                        this.fillVector = data.getNumericVector(result.colName, false, result.keys, false).values.toArray();
                    }
                }
                if (this.strokeColorMapping.colName) {
                    this.buildColorPaletteFromSettings(this.strokeColorMapping, data);
                    //---- use allData to build color scale (for consistency and full color range across containers) ----
                    var result = this.buildShapeColorScale(this.strokeColorMapping, this.fillColorStat, data);
                    this.strokeScale = result.scale;
                    this.strokeVector = null;
                    if (this.strokeScale) {
                        //---- use data to build strokeVector (for color values for this container) ----
                        this.strokeVector = data.getNumericVector(result.colName, false, result.keys).values.toArray();
                    }
                }
                if (this.shapeType == ShapeType.line) {
                    this.genLine(cellArray, data);
                }
                else if (this.shapeType != ShapeType.none) {
                    for (var i = 0; i < cellArray.length; i++) {
                        var cellData = cellArray[i];
                        //var rcAny = <any>cellData.rect;
                        var dataItem = data.getRecordByVectorIndex(i);
                        if (cellData.cellShape == beachParty.CellShape.path) {
                            this.genSinglePath(cellData, dataItem, i, data);
                        }
                        else {
                            this.genSingle(cellData, dataItem, i, data);
                        }
                    }
                }
            }
        };
        ShapeMaker.prototype.genLine = function (cellData, data) {
            var svgW = vp.select(this.svg);
            var points = "M ";
            var fill = this.getFillColor(0);
            var stroke = this.getStrokeColor(0);
            for (var i = 0; i < cellData.length; i++) {
                var rc = cellData[i].rect;
                var x = rc.left + rc.width / 2;
                var y = rc.top + rc.height / 2;
                if (i == 1) {
                    points += "L ";
                }
                points += x + "," + y + " ";
            }
            svgW.append("path")
                .colors(fill, stroke, this.strokeSize)
                .attr("opacity", this.opacity)
                .attr("d", points);
        };
        ShapeMaker.prototype.makeTooltip = function (record, dataFrame) {
            var ttMsg = "";
            if (this.toolTipFields) {
                var keys = this.toolTipFields;
            }
            else {
                var keys = vp.utils.keys(record);
                keys.sort();
            }
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = record[key];
                var colType = dataFrame.getColType(key);
                if (colType == "number") {
                    value = vp.formatters.comma(value, 2, false, true);
                }
                else if (colType == "date") {
                    value = vp.formatters.formatDateTime(value, " m/dd/yyyy");
                }
                if (!key.startsWith("_")) {
                    if (i > 0) {
                        //---- NOTE: linebreaks on SVG tooltips are not supported by IE. ----
                        ttMsg += "\n";
                    }
                    ttMsg += key + ": " + value;
                }
            }
            return ttMsg;
        };
        ShapeMaker.prototype.getFillColor = function (index) {
            var fill = this.shapeFill;
            if (this.fillScale) {
                var value = this.fillVector[index];
                var paletteIndex = this.fillScale.scale(value);
                if (paletteIndex != undefined) {
                    fill = vp.color.colorFromPalette(this.fillColorMapping.colorPalette, paletteIndex);
                }
            }
            return fill;
        };
        ShapeMaker.prototype.getStrokeColor = function (index) {
            var stroke = this.shapeStroke;
            if (this.strokeScale) {
                var value = this.strokeVector[index];
                var paletteIndex = this.strokeScale.scale(value);
                if (paletteIndex != undefined) {
                    stroke = vp.color.colorFromPalette(this.strokeColorMapping.colorPalette, paletteIndex);
                }
            }
            return stroke;
        };
        //genPath(cellArray: CellData[], data: dataFrameClass)
        //{
        //    var svgW = vp.select(this.svg);
        //    for (var i = 0; i < cellArray.length; i++)
        //    {
        //        var cellData = cellArray[i];
        //        var path = cellData.path;
        //        if (path)
        //        {
        //            var fill = this.getFillColor(i);
        //            var stroke = this.getStrokeColor(i);
        //            var dataRecord = data.getRecord(i);
        //            var tipText = (this.showTooltips) ? this.makeTooltip(dataRecord, data) : null;
        //            svgW.append("path")
        //                .colors(fill, stroke, this.strokeSize)
        //                .attr("d", path)
        //                .attr("tooltip", tipText);
        //        }
        //    }
        //}
        ShapeMaker.prototype.genSinglePath = function (cellData, dataRecord, index, dataFrame) {
            var tipText = (this.showTooltips) ? this.makeTooltip(dataRecord, dataFrame) : null;
            var fill = this.getFillColor(index);
            var stroke = this.getStrokeColor(index);
            var svgW = vp.select(this.svg);
            var path = cellData.path;
            if (this.shapeType == ShapeType.path) {
                svgW.append("path")
                    .colors(fill, stroke, this.strokeSize)
                    .attr("d", path)
                    .attr("tooltip", tipText);
            }
            else if (this.shapeType == ShapeType.circle) {
            }
        };
        ShapeMaker.prototype.genSingle = function (cellData, dataRecord, index, dataFrame) {
            var rc = cellData.rect;
            var left = rc.left;
            var top = rc.top;
            var cx = left + rc.width / 2;
            var cy = top + rc.height / 2;
            var svgW = vp.select(this.svg);
            var halfSize = this.shapeSize / 2;
            var tipText = (this.showTooltips) ? this.makeTooltip(dataRecord, dataFrame) : null;
            var fill = this.getFillColor(index);
            var stroke = this.getStrokeColor(index);
            if (this.shapeType == ShapeType.circle) {
                var elemW = svgW.append("circle")
                    .attr("r", halfSize)
                    .colors(fill, stroke, this.strokeSize)
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("opacity", this.opacity);
            }
            else if (this.shapeType == ShapeType.circleFill) {
                var radius = Math.min(rc.width, rc.height) / 2;
                var elemW = svgW.append("circle")
                    .attr("r", radius)
                    .colors(fill, stroke, this.strokeSize)
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("opacity", this.opacity);
            }
            else if (this.shapeType == ShapeType.square) {
                var x = cx - halfSize;
                var y = cy - halfSize;
                var elemW = svgW.append("rect")
                    .colors(fill, stroke, this.strokeSize)
                    .bounds(x, y, this.shapeSize, this.shapeSize)
                    .attr("opacity", this.opacity);
            }
            else if (this.shapeType == ShapeType.rectangle) {
                var left = rc.left;
                var top = rc.top;
                var width = rc.width;
                var height = rc.height;
                if (cellData.cellShape == beachParty.CellShape.circle) {
                    var r = Math.min(width, height) / 2;
                    var half = r / Math.sqrt(2);
                    var width = 2 * half;
                    height = width;
                    left = cellData.circle.cx - half;
                    top = cellData.circle.cy - half;
                }
                var elemW = svgW.append("rect")
                    .colors(fill, stroke, this.strokeSize)
                    .bounds(left, top, width, height)
                    .attr("opacity", this.opacity);
            }
            else if (this.shapeType == ShapeType.text) {
                var text = dataRecord[this.textCol];
                var elemW = svgW.append("text")
                    .colors(fill, stroke, this.strokeSize)
                    .attr("x", cx)
                    .attr("y", cy)
                    .attr("text-anchor", "middle")
                    .attr("opacity", this.opacity)
                    .text(text);
                if (this.textSize) {
                    elemW.css("font-size", this.textSize + "px");
                }
                //---- vertical align text in middle of cell ----
                var delta = vp.dom.computeTextBaselineDelta(elemW[0], "middle");
                elemW.attr("dy", delta);
            }
            else {
                throw "Error: shapeType not yet supported: " + this.shapeType;
            }
            if (elemW && tipText) {
                elemW.attr("tooltip", tipText);
            }
        };
        ShapeMaker.prototype.buildShapeColorScale = function (cm, statType, allData) {
            var colName = cm.colName;
            var scale = null;
            var keys = null;
            //---- do we want the aggregated column, or the regular?  which is present? ----
            var statInfo = new beachParty.StatInfo(colName, statType);
            var aggColName = statInfo.getAggColName();
            if (allData.isColumnName(aggColName)) {
                colName = aggColName;
            }
            var nvColorIndex = allData.getNumericVector(colName, false);
            if (nvColorIndex) {
                var isContinuous = cm.isContinuous;
                var colorCount = cm.colorPalette.length;
                //---- palette index=0 is reserved for the selection color, so we use index=1 to index=N for our colors ----
                var maxIndex = colorCount;
                var maxColors = colorCount;
                keys = (nvColorIndex.keyInfo) ? nvColorIndex.keyInfo.sortedKeys : null;
                if (!isContinuous) {
                    //---- if keyCount is smaller than color palette, only map to keyCount entries ----
                    if (nvColorIndex && nvColorIndex.keyInfo && nvColorIndex.keyInfo.keyCount) {
                        var keyCount = nvColorIndex.keyInfo.keyCount;
                        if (keyCount < colorCount) {
                            maxIndex = keyCount;
                            maxColors = keyCount;
                        }
                        else if (keyCount > colorCount) {
                            //---- scale for # of keys & then truncate to maxColors (in vertex shader) ----
                            maxIndex = keyCount;
                        }
                    }
                    //---- add this so that when we take floor(scaledValue), we correctly map to stepped palette entries ----
                    maxIndex += .999999; // adding another "9" here breaks scaling on WebGL (gets interpreted as a "1")
                }
                if (cm.customScalingCallback) {
                    if (vp.utils.isString(cm.customScalingCallback)) {
                        //----  convert from string to func ----
                        var foo = null;
                        //eval("foo = " + cm.customScalingCallback);
                        throw "custom scaling callbacks not currently supported";
                    }
                    colorIndexScale = cm.customScalingCallback;
                }
                else {
                    var result = beachParty.cbUtils.getMinMax(nvColorIndex, null, cm); //  nv.layoutFilter);
                    if (cm.spread == beachParty.MappingSpread.low) {
                        var colorIndexScale = vp.scales.createLowBias()
                            .domainMin(result.min)
                            .domainMax(result.max)
                            .range(1, maxIndex);
                    }
                    else if (cm.spread == beachParty.MappingSpread.high) {
                        var colorIndexScale = vp.scales.createHighBias()
                            .domainMin(result.min)
                            .domainMax(result.max)
                            .range(1, maxIndex);
                    }
                    else {
                        var colorIndexScale = vp.scales.createLinear()
                            .domainMin(result.min)
                            .domainMax(result.max)
                            .range(1, maxIndex);
                    }
                }
            }
            return { scale: colorIndexScale, keys: keys, colName: colName };
        };
        ShapeMaker.prototype.buildColorPaletteFromSettings = function (cm, dataFrame) {
            if (cm) {
                var colName = cm.colName;
                if (colName) {
                    var numVector = dataFrame.getNumericVector(colName);
                    var colType = numVector.colType;
                    var isCategory = (cm.forceCategory || colType == "string");
                    var paletteName = cm.paletteName;
                    if (!paletteName) {
                        paletteName = (isCategory) ? "Paired" : "Blues";
                    }
                    var palette = beachParty.colorPalettesClass.getPaletteFromSettings(paletteName, cm.binCount, // stepsRequested,
                    cm.isReversed, cm.isInverted);
                    var breaks = null;
                    if (isCategory) {
                        var keys = numVector.keyInfo.sortedKeys;
                        var keyCount = keys.length;
                        if (keyCount < palette.length) {
                            palette = palette.slice(0, keyCount);
                        }
                        breaks = [];
                        for (var i = 0; i < palette.length; i++) {
                            if (i == palette.length - 1 && keyCount > palette.length) {
                                breaks.push("Other");
                            }
                            else {
                                breaks.push(keys[i]);
                            }
                        }
                    }
                    //---- add a selected color at palette[0] so that our color scaling works correctly ----
                    palette.insert(0, "pink");
                    cm.colorPalette = palette;
                    cm.breaks = breaks;
                }
            }
        };
        return ShapeMaker;
    }());
    beachParty.ShapeMaker = ShapeMaker;
    (function (ShapeType) {
        ShapeType[ShapeType["none"] = 0] = "none";
        ShapeType[ShapeType["circle"] = 1] = "circle";
        ShapeType[ShapeType["circleFill"] = 2] = "circleFill";
        ShapeType[ShapeType["line"] = 3] = "line";
        ShapeType[ShapeType["path"] = 4] = "path";
        ShapeType[ShapeType["square"] = 5] = "square";
        ShapeType[ShapeType["rectangle"] = 6] = "rectangle";
        ShapeType[ShapeType["text"] = 7] = "text";
    })(beachParty.ShapeType || (beachParty.ShapeType = {}));
    var ShapeType = beachParty.ShapeType;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    spaceDivider.ts - algorithm(s) for dividing up a container into sub-containers.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// Data Aggregation and Scaling for layouts:
    ///
    ///   There are several types of layouts supported by this class:
    ///
    ///     1. PLOT layouts (e.g., plotXY, polarXY)
    ///     2. PROPORTIONAL CELL SIZE layouts (e.g., fillX, fillY, squarify)
    ///     3. DATA INSENSITIVE layouts (e.g., packXY, poisson)
    ///
    ///   Types 1 & 2 need different X and/or Y values for each cell layed out (specified in the X and Y column mappings for
    ///   the associated spaceDivider).  For leaf nodes, these values are obtained directly from the leaf node record values.
    ///   For higher level ("inner") nodes, the column values at the leaf node are aggregated using a "leafStat" and then propagated up to the 
    ///   associated spaceDivider/container using a "innerStat".  
    ///
    ///   For example, you could have a #2 spaceDivider that uses "squarify" layout with "X" (the spacing column) mapped to the "Sales" column, 
    ///   with leafStat set to "Sum()" and innerStat set to "Sum"()".  This would compute the sum(Sales) for each group of level 3 and then
    ///   sum those for each group of level 2, and then layout each cell of level 2 like the outer containers in a Treemap.
    ///
    ///   All 3 of the above types may need to use a common scale (in X and/or Y), to facilitate comparison among containers
    ///   at various levels.  To accomplish that, they need to calculate the min/max (count or state) of X/Y at the leaf levels and 
    ///   then propagate  this to the root, so it can be passed to each of the relevant containers at layout() time.
    ///
    var SpaceDivider = (function () {
        function SpaceDivider(spaceType, margin) {
            if (spaceType === void 0) { spaceType = SpaceType.none; }
            if (margin === void 0) { margin = 2; }
            this.showContainers = false;
            this.showCounts = false;
            //---- labels ----
            this.showLabels = false;
            this.labelColName = "CabinClass";
            this.labelAddColon = false;
            this.labelPosition = LabelPositon.top;
            this.labelHalfCell = false;
            this.labelSize = 16;
            this.labelFill = "black";
            this.labelOpacity = 1;
            //---- stats for leaf and inner containers (must be set explictly by presets/UI)----
            this.xStat = new StatInfo();
            this.yStat = new StatInfo();
            //---- for drawing containers ----
            this.containerFill = "#ccc";
            this.containerStroke = "none";
            this.containerStrokeSize = 1;
            //---- X and Y mappings ----
            this.hAlign = HAlign.left; // how to align cells that are not full width
            this.vAlign = VAlign.bottom; // how to align cells that are not full height
            this.xMaxPeer = false; // for fillX/FillY: scale X values relative to max(peer values)
            this.yMaxPeer = false; // for fillX/fillY: scale Y values relative to max(peer values)
            //---- pre-computed random data (for reproducible drawing when attribute changes) ----
            this.xRandom = null;
            this.yRandom = null;
            //---- choropleth support ----
            this.choroData = null; // geoJSON shapes for ShapeType.choropleth
            this.choroMapType = ChoroMapType.none;
            this.choroColName = ""; // name of column that matches NAME in choroData
            this.spaceType = spaceType;
            this.margin = margin;
            this.cellMargin = margin;
            this.reverse = false;
            this.cellShape = CellShape.rectangle;
        }
        SpaceDivider.prototype.drawLabelsOnTop = function (cellData, svg, name) {
            var textHeight = 18;
            var rc = cellData.rect;
            var yText = rc.top + textHeight - 3;
            //labelPosition = LabelPositon.top;
            //labelHalfCell = false;
            var text = (this.labelAddColon) ? (name + ":") : name;
            var textW = vp.select(svg).append("text")
                .text(text)
                .attr("x", rc.left + rc.width / 2)
                .attr("y", yText)
                .attr("text-anchor", "middle")
                .colors(this.labelFill, "none", 0);
            if (this.labelSize) {
                textW.css("font-size", this.labelSize + "px");
            }
            if (this.labelOpacity != undefined) {
                textW.css("opacity", this.labelOpacity + "");
            }
            rc = vp.geom.createRect(rc.left, rc.top + textHeight, rc.width, rc.height - textHeight);
            var cd = CellData.fromRect(rc, this.cellShape);
            return cd;
        };
        /** data can be either a dataFrameClass or an array of DataFrameClass objects. */
        SpaceDivider.prototype.divide = function (cellData, name, data, shapeSize, scaleData, svg) {
            var _this = this;
            var cellArray = [];
            var margin = this.margin;
            var cellMargin = this.cellMargin;
            //---- get X and Y STAT data, if requested ----
            var xnv = data.getNumericVectorFromStat(this.xStat);
            this.xVector = (xnv) ? xnv.values.toArray() : null;
            var ynv = data.getNumericVectorFromStat(this.yStat);
            this.yVector = (ynv) ? ynv.values.toArray() : null;
            this.scaleData = scaleData;
            //---- apply margins ----
            var rcFull = cellData.rect;
            var rcMarg = vp.geom.createRect(rcFull.left + margin, rcFull.top + margin, rcFull.width - 2 * margin, rcFull.height - 2 * margin);
            var count = data.length;
            //vp.utils.debug("spaceDivider.divide: rcMarg.left=" + rcMarg.left + ", rcMarg.top=" + rcMarg.top);
            if (count) {
                //---- limit data ----
                var maxItems = beachParty.maxContainers;
                if (maxItems && count > maxItems) {
                    //var nd = <INumericRecords>data;
                    data = data.slice(0, maxItems - 1);
                    count = maxItems;
                }
                if (this.spaceType == SpaceType.overlay) {
                    cellArray = data.map(function (pt) {
                        return vp.geom.createRect(rcMarg.left, rcMarg.top, rcMarg.width, rcMarg.height);
                    });
                }
                else if (this.spaceType == SpaceType.poisson) {
                    var best = new beachParty.bestPoisson();
                    var pts = best.layout(rcMarg, count);
                    cellArray = pts.map(function (pt) {
                        //---- upper left corner ----
                        var x = pt[0] - .5;
                        var y = pt[1] - .5;
                        return CellData.fromRect(vp.geom.createRect(x, y, 1, 1), _this.cellShape);
                    });
                }
                else if (this.spaceType == SpaceType.random) {
                    var rIndex = 0;
                    cellArray = data.map(function (d) {
                        if (_this.xRandom) {
                            var xr = _this.xRandom[rIndex];
                            var yr = _this.yRandom[rIndex];
                            rIndex++;
                        }
                        else {
                            var xr = Math.random();
                            var yr = Math.random();
                        }
                        var cx = rcMarg.left + rcMarg.width * xr;
                        var cy = rcMarg.top + rcMarg.height * yr;
                        //---- upper left corner ----
                        var x = cx - .5;
                        var y = cy - .5;
                        return CellData.fromRect(vp.geom.createRect(x, y, 1, 1), _this.cellShape);
                    });
                }
                else if (this.spaceType == SpaceType.fillXY) {
                    cellArray = this.fillXY(rcMarg, data);
                }
                else if (this.spaceType == SpaceType.packXY) {
                    cellArray = this.packXY(rcMarg, data);
                }
                else if (this.spaceType == SpaceType.packYX) {
                    cellArray = this.packYX(rcMarg, data);
                }
                else if (this.spaceType == SpaceType.fillOut) {
                    cellArray = this.fillOut(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.packOut) {
                    cellArray = this.packOut(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.plotXY) {
                    cellArray = this.plotXY(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.polarXY) {
                    cellArray = this.polarXY(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.fillX) {
                    cellArray = this.fillXWithProp(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.fillY) {
                    cellArray = this.fillYWithProp(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.record) {
                    cellArray = this.record(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.squarify) {
                    cellArray = this.squarify(rcMarg, data, shapeSize);
                }
                else if (this.spaceType == SpaceType.choropleth) {
                    cellArray = this.choroLayout(rcMarg, data);
                }
                //---- debug -----
                if (this.spaceType != SpaceType.none && this.spaceType != SpaceType.choropleth) {
                    if (cellArray.length != data.length) {
                        throw "Layout error - size(cellArray) is different from data.length";
                    }
                }
                //---- draw containers ----
                if (svg && (this.showContainers || this.showCounts || this.showLabels)) {
                    this.drawContainerOutlines(svg, cellArray, data);
                }
            }
            return cellArray;
        };
        SpaceDivider.prototype.choroLayout = function (rcMarg, data) {
            var cellArray = [];
            if (this.choroData && this.choroColName) {
                var ranges = { xMin: Number.MAX_VALUE, xMax: -Number.MAX_VALUE, yMin: Number.MAX_VALUE, yMax: -Number.MAX_VALUE };
                var coordsMap = {};
                var shapeNames = data.getVector(this.choroColName, false);
                if (shapeNames) {
                    //---- first pass: find shapes and compute min/max of X/Y ----
                    for (var i = 0; i < shapeNames.length; i++) {
                        var shapeName = shapeNames[i];
                        var coords = beachParty.choroplethHelper.getShapeCoords(this.choroData, shapeName);
                        if (coords) {
                            beachParty.choroplethHelper.computeXYRange(ranges, coords);
                            coordsMap[shapeName] = coords;
                        }
                    }
                    //---- second pass: build path strings ----
                    for (var i = 0; i < shapeNames.length; i++) {
                        var shapeName = shapeNames[i];
                        var coords = coordsMap[shapeName];
                        if (coords) {
                            var path = beachParty.choroplethHelper.buildPath(rcMarg, ranges, coords);
                            var cellData = new CellData();
                            cellData.cellShape = CellShape.path;
                            cellData.path = path;
                            cellArray.push(cellData);
                        }
                    }
                }
            }
            return cellArray;
        };
        SpaceDivider.prototype.makeScaleForCol = function (vector, colType, minRange, maxRange, maxPeer, zeroBased) {
            var scale = null;
            if (vector && vector.length) {
                var min = vector.min();
                var max = (maxPeer) ? maxPeer : vector.max();
                if (zeroBased) {
                    if (max < 0) {
                        max = 0;
                    }
                    else if (min > 0) {
                        min = 0;
                    }
                }
                if (colType == "date") {
                    scale = vp.scales.createDate();
                }
                else if (colType == "number") {
                    scale = vp.scales.createLinear();
                }
                else {
                    //---- not sure - should this be createCategoryKey()? ----
                    scale = vp.scales.createCategoryIndex();
                }
                scale
                    .domain(min, max)
                    .range(minRange, maxRange);
            }
            return scale;
        };
        /** lays out containers, one per     */
        SpaceDivider.prototype.record = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            //---- for legends, we don't call measure, so no childStats exists ----
            var xVector = this.xVector;
            if (xVector && xVector.length) {
                var squarifyLayout = new beachParty.squarifyLayoutClass();
                cellArray = squarifyLayout.layout(xVector, rcMarg, this.cellMargin);
            }
            return cellArray;
        };
        /** lays out containers in a single-level squarified treemap.  Here, the "color" of a squarify cell
        will be determined by the shapes that populate it.  The size of each cell at the leaf nodes can be based
        on a column or just "1".  The size of intermediate container cells is based on the child data groups: count of    */
        SpaceDivider.prototype.squarify = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            //---- for legends, we don't call measure, so no childStats exists ----
            var xVector = this.xVector;
            if (xVector && xVector.length) {
                var squarifyLayout = new beachParty.squarifyLayoutClass();
                cellArray = squarifyLayout.layout(xVector, rcMarg, this.cellMargin);
            }
            return cellArray;
        };
        /** maps X, Y values to polar coordinates to plot shapes.  */
        SpaceDivider.prototype.polarXY = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            var xCol = this.xStat.colName;
            var yCol = this.yStat.colName;
            var xnv = data.getNumericVectorFromStat(this.xStat);
            var xVector = (xnv) ? xnv.values.toArray() : null;
            var ynv = data.getNumericVectorFromStat(this.yStat);
            var yVector = (ynv) ? ynv.values.toArray() : null;
            var maxRadius = Math.min(rcMarg.width / 2, rcMarg.height / 2);
            var anyData = data;
            var xColType = (anyData.colTypes) ? anyData.colTypes[xCol] : "number";
            var yColType = (anyData.colTypes) ? anyData.colTypes[yCol] : "number";
            //---- X range: 0-2*PI ----
            var xScale = this.makeScaleForCol(xVector, xColType, 0, 2 * Math.PI);
            //---- Y range: 0-maxRadius ----
            var yScale = this.makeScaleForCol(yVector, yColType, 0, maxRadius);
            var cx = rcMarg.left + rcMarg.width / 2;
            var cy = rcMarg.top + rcMarg.height / 2;
            var xScaled = 0;
            var yScaled = 0;
            for (var i = 0; i < data.length; i++) {
                if (xVector) {
                    var xValue = xVector[i];
                    xScaled = xScale.scale(xValue);
                }
                if (yVector) {
                    var yValue = yVector[i];
                    yScaled = yScale.scale(yValue);
                }
                var theta = -(Math.PI / 2 + xScaled);
                var radius = yScaled;
                var cxx = cx + radius * Math.cos(theta);
                var cyy = cy + radius * Math.sin(theta);
                //---- upper left corner ----
                var x = cxx - .5;
                var y = cyy - .5;
                var rcChild = vp.geom.createRect(x, y, 1, 1);
                cellArray.push(CellData.fromRect(rcChild, this.cellShape));
            }
            return cellArray;
        };
        /** maps shapes along the X/Y axis using the xCol and yCol values.  */
        SpaceDivider.prototype.plotXY = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            var xCol = this.xStat.colName;
            var yCol = this.yStat.colName;
            var xVector = data.getVector(xCol);
            var yVector = data.getVector(yCol);
            var anyData = data;
            var xColType = (anyData.colTypes) ? anyData.colTypes[xCol] : "number";
            var yColType = (anyData.colTypes) ? anyData.colTypes[yCol] : "number";
            var xScale = this.makeScaleForCol(xVector, xColType, rcMarg.left, rcMarg.right);
            var yScale = this.makeScaleForCol(yVector, yColType, rcMarg.top, rcMarg.bottom);
            var cx = 0;
            var cy = 0;
            for (var i = 0; i < data.length; i++) {
                if (xVector) {
                    var xValue = xVector[i];
                    cx = xScale.scale(xValue);
                }
                if (yVector) {
                    var yValue = yVector[i];
                    cy = yScale.scale(yValue);
                }
                //---- upper left corner ----
                var x = cx - .5;
                var y = cy - .5;
                var rcChild = vp.geom.createRect(x, y, 1, 1);
                cellArray.push(CellData.fromRect(rcChild, this.cellShape));
            }
            return cellArray;
        };
        /** does a FILL along the X axis, where the width and height of each cell is proportional to xCol/yCol. */
        SpaceDivider.prototype.fillXWithProp = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            var xVector = this.xVector;
            var yVector = this.yVector;
            var cellMargin = this.cellMargin;
            var halfMargin = cellMargin / 2;
            var count = data.length;
            var uniformHeight = rcMarg.height;
            var uniformWidth = Math.max(0, rcMarg.width / count - cellMargin);
            var xFactor = 0;
            var yScale = null;
            if (xVector && xVector.length) {
                var xSum = xVector.sum(function (v) { return Math.abs(v); });
                xFactor = Math.max(0, (rcMarg.width - count * cellMargin) / xSum);
            }
            if (yVector && yVector.length) {
                yScale = this.makeScaleForCol(yVector, "number", 0, rcMarg.height, null, true);
            }
            var left = rcMarg.left + halfMargin;
            var valign = this.vAlign;
            var yCenter = rcMarg.top + rcMarg.height / 2;
            for (var i = 0; i < data.length; i++) {
                var width = (xVector) ? (Math.abs(xVector[i]) * xFactor) : uniformWidth;
                var height = (yVector) ? yScale.scale(yVector[i]) : uniformHeight;
                //---- make sure we can see all cells ----
                //width = Math.max(1, width);
                //height = Math.max(1, height);
                var top = rcMarg.bottom - height;
                if (valign == VAlign.middle) {
                    top = yCenter - height / 2;
                }
                else if (valign == VAlign.top) {
                    top = rcMarg.top;
                }
                var rcChild = vp.geom.createRect(left, top, width, height);
                cellArray.push(CellData.fromRect(rcChild, this.cellShape));
                left += (width + cellMargin);
            }
            return cellArray;
        };
        /** does a FILL along the Y axis, where the width and height of each cell is proportional to xCol/yCol. */
        SpaceDivider.prototype.fillYWithProp = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            var xCol = this.xStat.colName;
            var yCol = this.yStat.colName;
            var xVector = data.getVector(xCol, true);
            var yVector = data.getVector(yCol, true);
            var cellMargin = this.cellMargin;
            var halfMargin = cellMargin / 2;
            var count = data.length;
            var uniformHeight = Math.max(0, (rcMarg.height / count - cellMargin));
            var uniformWidth = rcMarg.width;
            var xScale = null;
            var yFactor = 0;
            var xCol = this.xStat.colName;
            var yCol = this.yStat.colName;
            if (xVector) {
                var maxPeer = (this.xMaxPeer) ? this.scaleData.xMax : undefined;
                xScale = this.makeScaleForCol(xVector, "number", 0, rcMarg.width, maxPeer);
            }
            if (yVector) {
                var ySum = (this.yMaxPeer) ? this.scaleData.yMax : yVector.sum(function (v) { return Math.abs(v); });
                yFactor = Math.max(0, (rcMarg.height - count * cellMargin) / ySum);
            }
            var hAlign = this.hAlign;
            var xCenter = rcMarg.left + rcMarg.width / 2;
            var yOffset = (this.reverse) ? (rcMarg.bottom - halfMargin) : (rcMarg.top + halfMargin);
            var yDir = (this.reverse) ? -1 : 1;
            for (var i = 0; i < data.length; i++) {
                var width = (xVector) ? xScale.scale(xVector[i]) : uniformWidth;
                var height = (yVector) ? (Math.abs(yVector[i]) * yFactor) : uniformHeight;
                ////---- make sure we can see all cells ----
                //width = Math.max(1, width);
                //height = Math.max(1, height);
                var left = rcMarg.left;
                if (xVector) {
                    if (hAlign == HAlign.center) {
                        left = xCenter - width / 2;
                    }
                    else if (hAlign == HAlign.right) {
                        left = rcMarg.right - width;
                    }
                }
                if (yDir == -1) {
                    var rcChild = vp.geom.createRect(left, yOffset - height, width, height);
                }
                else {
                    var rcChild = vp.geom.createRect(left, yOffset, width, height);
                }
                cellArray.push(CellData.fromRect(rcChild, this.cellShape));
                yOffset += yDir * (height + cellMargin);
            }
            return cellArray;
        };
        /** puts first shape at center, then packs other shapes around the first, starting at upper left corner of first shape. repeats
        until all shapes have been placed around the prior shapes.  */
        SpaceDivider.prototype.packOut = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            var halfSize = shapeSize / 2;
            var cx = rcMarg.left + rcMarg.width / 2 - halfSize;
            var cy = rcMarg.top + rcMarg.height / 2 - halfSize;
            var count = data.length;
            var cellMargin = this.cellMargin;
            //---- start algotirhm at dir=center ----
            var x = cx;
            var y = cy;
            var fillDir = FillDir.center;
            var dirMax = 1;
            var dirCount = 0;
            while (count--) {
                var rcChild = vp.geom.createRect(x, y, shapeSize, shapeSize);
                cellArray.push(CellData.fromRect(rcChild, this.cellShape));
                dirCount++;
                if (dirCount == dirMax) {
                    //---- change direction ----
                    if (fillDir == FillDir.down) {
                        fillDir = FillDir.right;
                    }
                    else if (fillDir == FillDir.right) {
                        fillDir = FillDir.up;
                    }
                    else if (fillDir == FillDir.up) {
                        fillDir = FillDir.left;
                    }
                    else if (fillDir == FillDir.left) {
                        fillDir = FillDir.down;
                        //---- start a new layer ----
                        dirMax += 2;
                        x -= (shapeSize + cellMargin);
                        y -= (shapeSize + cellMargin); // comphensate for upcoming y adjustment
                    }
                    dirCount = 0;
                }
                //---- move to next location ----
                if (fillDir == FillDir.center) {
                    //---- special handling for first shape ----
                    fillDir = FillDir.down;
                    dirMax = 2;
                    dirCount = 0;
                    x -= (shapeSize + cellMargin);
                }
                else if (fillDir == FillDir.down) {
                    y += (shapeSize + cellMargin);
                }
                else if (fillDir == FillDir.right) {
                    x += (shapeSize + cellMargin);
                }
                else if (fillDir == FillDir.up) {
                    y -= (shapeSize + cellMargin);
                }
                else if (fillDir == FillDir.left) {
                    x -= (shapeSize + cellMargin);
                }
            }
            return cellArray;
        };
        /** uses sunFlower drawing algorithm (aka fermat's apiral and disc phyllotaxis) to layout shapes in a spiral pattern that
        fills the specified space. */
        SpaceDivider.prototype.fillOut = function (rcMarg, data, shapeSize) {
            var cellArray = [];
            var phyloSeed = 137.508; // "golden angle"
            var count = data.length;
            var xSize = rcMarg.width;
            var ySize = rcMarg.height;
            var radius = Math.min(xSize, ySize);
            var spacing = .5 * radius / Math.sqrt(count);
            var nextIndex = 0;
            var cx = rcMarg.left + rcMarg.width / 2;
            var cy = rcMarg.top + rcMarg.height / 2;
            for (var i = 0; i < count; i++) {
                //---- filtered code can calc stuff here, but it will not be used ----
                var r = spacing * Math.sqrt(i);
                var theta = Math.PI / 180 * (i * phyloSeed);
                var cxx = cx + r * Math.sin(theta);
                var cyy = cy + r * Math.cos(theta);
                var x = cxx - shapeSize / 2;
                var y = cyy - shapeSize / 2;
                var rcChild = vp.geom.createRect(x, y, shapeSize, shapeSize);
                cellArray.push(CellData.fromRect(rcChild, this.cellShape));
            }
            return cellArray;
        };
        SpaceDivider.prototype.fillXY = function (rcMarg, data) {
            var cellArray = [];
            var width = rcMarg.width;
            var height = rcMarg.height;
            var aspect = width / height;
            //---- space between facets ----
            var xMargin = this.cellMargin;
            var yMargin = this.cellMargin;
            var cellsPerRowByCount = {
                0: 0, 1: 1, 2: 2, 3: 3, 4: 2, 5: 3, 6: 3, 7: 4, 8: 4, 9: 3, 10: 5,
                11: 4, 12: 4, 13: 4, 14: 4, 15: 4, 16: 4
            };
            var count = data.length;
            //---- hard code layout for 0-16 cells ----
            var cellsPerRow = cellsPerRowByCount[count];
            if (cellsPerRow === undefined) {
                cellsPerRow = Math.ceil(Math.sqrt(aspect * count));
            }
            var rowCount = Math.ceil(count / cellsPerRow);
            //---- use whole numbers for sizes, for crisp drawing of frames ----
            var cellWidth = (width - xMargin * (cellsPerRow - 1)) / cellsPerRow;
            var cellHeight = (height - yMargin * (rowCount - 1)) / rowCount;
            var facetBounds = [];
            var margin2 = 2 * xMargin;
            for (var i = 0; i < count; i++) {
                var colIndex = Math.floor(i % cellsPerRow);
                var rowIndex = Math.floor(i / cellsPerRow);
                //---- use whole numbers for offsets ----
                //---- must align left cells to left edge of container (so labels outside are right next to them) ----
                var x = rcMarg.left + colIndex * (cellWidth + xMargin);
                var y = rcMarg.top + rowIndex * (cellHeight + yMargin);
                //---- make sure all facets are the SAME width and height (critical for shape drawing algorithm and visual comparisons) ----
                var rc = vp.geom.createRect(x, y, cellWidth, cellHeight);
                var cellData = CellData.fromRect(rc, this.cellShape);
                cellArray.push(cellData);
            }
            return cellArray;
        };
        SpaceDivider.prototype.packXY = function (rcMarg, data) {
            var _this = this;
            var cellMargin = this.cellMargin;
            var halfMargin = cellMargin / 2;
            var maxCount = (this.scaleData && this.scaleData.maxCount) ? this.scaleData.maxCount : this.getMaxCountInGroups(data);
            var aspect = rcMarg.width / rcMarg.height;
            var colCount = Math.ceil(Math.sqrt(aspect * maxCount));
            var rowCount = Math.ceil(maxCount / colCount);
            var boxWidth = rcMarg.width / colCount;
            var boxHeight = rcMarg.height / rowCount;
            var cellWidth = Math.max(0, boxWidth - cellMargin);
            var cellHeight = Math.max(0, boxHeight - cellMargin);
            var i = 0;
            var yStart = (this.reverse) ? (rcMarg.top + halfMargin) : (rcMarg.bottom - cellHeight - halfMargin);
            var yDir = (this.reverse) ? 1 : -1;
            var cellArray = data.map(function (d) {
                var colNum = i % colCount;
                var rowNum = Math.floor(i / colCount);
                var x = rcMarg.left + halfMargin + colNum * boxWidth;
                var y = yStart + yDir * rowNum * boxHeight;
                i++;
                return CellData.fromRect(vp.geom.createRect(x, y, cellWidth, cellHeight), _this.cellShape);
            });
            return cellArray;
        };
        SpaceDivider.prototype.packYX = function (rcMarg, data) {
            var _this = this;
            var cellMargin = this.cellMargin;
            var halfMargin = cellMargin / 2;
            var maxCount = (this.scaleData && this.scaleData.maxCount) ? this.scaleData.maxCount : this.getMaxCountInGroups(data);
            var aspect = rcMarg.width / rcMarg.height;
            var rowCount = Math.ceil(Math.sqrt(maxCount / aspect));
            var colCount = Math.ceil(maxCount / rowCount);
            var boxWidth = rcMarg.width / colCount;
            var boxHeight = rcMarg.height / rowCount;
            var cellWidth = Math.max(0, boxWidth - cellMargin);
            var cellHeight = Math.max(0, boxHeight - cellMargin);
            var i = 0;
            var yStart = (this.reverse) ? (rcMarg.top + halfMargin) : (rcMarg.bottom - cellHeight - halfMargin);
            var yDir = (this.reverse) ? 1 : -1;
            var cellArray = data.map(function (d) {
                var rowNum = i % rowCount;
                var colNum = Math.floor(i / rowCount);
                var x = rcMarg.left + halfMargin + colNum * boxWidth;
                var y = yStart + yDir * rowNum * boxHeight;
                i++;
                return CellData.fromRect(vp.geom.createRect(x, y, cellWidth, cellHeight), _this.cellShape);
            });
            return cellArray;
        };
        SpaceDivider.prototype.getMaxCountInGroups = function (frameOrArray) {
            var maxCount = 0;
            if (frameOrArray.array) {
                var firstGroup = frameOrArray.array[0];
                var isArray = (vp.utils.isArray(firstGroup));
                if (isArray) {
                    for (var i = 0; i < frameOrArray.length; i++) {
                        var group = frameOrArray[i];
                        var count = group.length;
                        maxCount = Math.max(maxCount, count);
                    }
                }
                else {
                    //----- just a set of records ----
                    maxCount = frameOrArray.length;
                }
            }
            else {
                //----- just a set of records ----
                maxCount = frameOrArray.length;
            }
            //---- don't exceed our demo-tool max ----
            if (beachParty.maxContainers) {
                maxCount = Math.min(maxCount, beachParty.maxContainers);
            }
            return maxCount;
        };
        SpaceDivider.prototype.drawContainerOutlines = function (svg, cellArray, data) {
            //---- draw containers in red ----
            for (var i = 0; i < cellArray.length; i++) {
                var cellData = cellArray[i];
                var rcx = cellData.rect;
                var dataGroup = data.getItem(i);
                var name = null;
                if (dataGroup.ctr == "dataFrameClass") {
                    name = (dataGroup._groupName) ? dataGroup._groupName : data.name;
                }
                else if (this.labelColName) {
                    name = dataGroup[this.labelColName];
                }
                if (this.showContainers) {
                    //---- make sure container is visible ----
                    var width = Math.max(2, rcx.width);
                    var height = Math.max(2, rcx.height);
                    if (this.cellShape == CellShape.rectangle) {
                        vp.select(svg).append("rect")
                            .bounds(rcx.left, rcx.top, width, height)
                            .colors(this.containerFill, this.containerStroke, this.containerStrokeSize);
                    }
                    else {
                        var radius = Math.min(width, height) / 2;
                        var cx = rcx.left + rcx.width / 2;
                        var cy = rcx.top + rcx.height / 2;
                        vp.select(svg).append("circle")
                            .attr("cx", cx)
                            .attr("cy", cy)
                            .attr("r", radius)
                            .colors(this.containerFill, this.containerStroke, this.containerStrokeSize);
                    }
                }
                if (this.showCounts) {
                    var groupCount = dataGroup.length;
                    var yText = rcx.top + 20;
                    if (this.spaceType == SpaceType.fillX) {
                        //groupCount = Math.min(maxContainers, groupCount);
                        yText = rcx.bottom;
                    }
                    vp.select(svg).append("text")
                        .text(data + "")
                        .attr("x", rcx.left + rcx.width / 2)
                        .attr("y", yText)
                        .attr("text-anchor", "middle")
                        .colors("black", "none", 0);
                }
                //---- draw label ----
                var minWidth = 10;
                var minHeight = 10;
                if (this.showLabels && name && rcx.width >= minWidth && rcx.height >= minHeight) {
                    var cdAdj = this.drawLabelsOnTop(cellData, svg, name);
                    cellArray[i] = cdAdj;
                }
            }
        };
        SpaceDivider.prototype.showStuff = function (showContainers, showCounts) {
            this.showContainers = showContainers;
            this.showCounts = showCounts;
        };
        return SpaceDivider;
    }());
    beachParty.SpaceDivider = SpaceDivider;
    var FillDir;
    (function (FillDir) {
        FillDir[FillDir["center"] = 0] = "center";
        FillDir[FillDir["down"] = 1] = "down";
        FillDir[FillDir["right"] = 2] = "right";
        FillDir[FillDir["up"] = 3] = "up";
        FillDir[FillDir["left"] = 4] = "left";
    })(FillDir || (FillDir = {}));
    (function (SpaceType) {
        SpaceType[SpaceType["none"] = 0] = "none";
        SpaceType[SpaceType["choropleth"] = 1] = "choropleth";
        SpaceType[SpaceType["fillX"] = 2] = "fillX";
        SpaceType[SpaceType["fillY"] = 3] = "fillY";
        SpaceType[SpaceType["fillXY"] = 4] = "fillXY";
        SpaceType[SpaceType["fillOut"] = 5] = "fillOut";
        SpaceType[SpaceType["packXY"] = 6] = "packXY";
        SpaceType[SpaceType["packYX"] = 7] = "packYX";
        SpaceType[SpaceType["packOut"] = 8] = "packOut";
        SpaceType[SpaceType["plotXY"] = 9] = "plotXY";
        SpaceType[SpaceType["polarXY"] = 10] = "polarXY";
        SpaceType[SpaceType["overlay"] = 11] = "overlay";
        SpaceType[SpaceType["poisson"] = 12] = "poisson";
        SpaceType[SpaceType["random"] = 13] = "random";
        SpaceType[SpaceType["record"] = 14] = "record";
        SpaceType[SpaceType["squarify"] = 15] = "squarify";
    })(beachParty.SpaceType || (beachParty.SpaceType = {}));
    var SpaceType = beachParty.SpaceType;
    (function (CellShape) {
        CellShape[CellShape["circle"] = 0] = "circle";
        CellShape[CellShape["path"] = 1] = "path";
        CellShape[CellShape["pieSlice"] = 2] = "pieSlice";
        CellShape[CellShape["rectangle"] = 3] = "rectangle";
    })(beachParty.CellShape || (beachParty.CellShape = {}));
    var CellShape = beachParty.CellShape;
    (function (HAlign) {
        HAlign[HAlign["left"] = 0] = "left";
        HAlign[HAlign["center"] = 1] = "center";
        HAlign[HAlign["right"] = 2] = "right";
    })(beachParty.HAlign || (beachParty.HAlign = {}));
    var HAlign = beachParty.HAlign;
    (function (VAlign) {
        VAlign[VAlign["top"] = 0] = "top";
        VAlign[VAlign["middle"] = 1] = "middle";
        VAlign[VAlign["bottom"] = 2] = "bottom";
    })(beachParty.VAlign || (beachParty.VAlign = {}));
    var VAlign = beachParty.VAlign;
    /** Type of statistic to gather about children of current container. Some stats use "statCol". */
    (function (StatType) {
        StatType[StatType["none"] = 0] = "none";
        StatType[StatType["count"] = 1] = "count";
        StatType[StatType["min"] = 2] = "min";
        StatType[StatType["max"] = 3] = "max";
        StatType[StatType["sum"] = 4] = "sum";
        StatType[StatType["avg"] = 5] = "avg";
        StatType[StatType["median"] = 6] = "median";
        StatType[StatType["mode"] = 7] = "mode";
        StatType[StatType["std"] = 8] = "std";
        StatType[StatType["variance"] = 9] = "variance";
    })(beachParty.StatType || (beachParty.StatType = {}));
    var StatType = beachParty.StatType;
    var StatInfo = (function () {
        function StatInfo(colName, statType) {
            if (colName === void 0) { colName = ""; }
            if (statType === void 0) { statType = StatType.none; }
            this.colValueTransform = null; // a callback to transform col value before building stat (e.g., Math.abs)
            this.statType = statType;
            this.colName = colName;
            this.peerScale = false;
            this.colValueTransform = null;
        }
        StatInfo.prototype.getAggColName = function () {
            var name = this.colName;
            if (this.statType == StatType.count) {
                name = "Count@";
            }
            else {
                var statType = (this.statType == StatType.none) ? "sum" : StatType[this.statType];
                name = statType.capitalize() + "@" + name;
            }
            return name;
        };
        return StatInfo;
    }());
    beachParty.StatInfo = StatInfo;
    var CircleData = (function () {
        function CircleData(cx, cy, radius) {
            this.cx = cx;
            this.cy = cy;
            this.radius = radius;
        }
        return CircleData;
    }());
    beachParty.CircleData = CircleData;
    var PieSliceData = (function (_super) {
        __extends(PieSliceData, _super);
        function PieSliceData() {
            _super.apply(this, arguments);
        }
        return PieSliceData;
    }(CircleData));
    beachParty.PieSliceData = PieSliceData;
    var CellData = (function () {
        function CellData() {
        }
        CellData.fromRect = function (rect, cellShape) {
            var cd = new CellData();
            cd.cellShape = cellShape;
            cd.rect = rect;
            if (cellShape == CellShape.circle) {
                var radius = Math.min(rect.width, rect.height) / 2;
                cd.circle = new CircleData(rect.left + rect.width / 2, rect.top + rect.height / 2, radius);
            }
            return cd;
        };
        return CellData;
    }());
    beachParty.CellData = CellData;
    (function (ChoroMapType) {
        ChoroMapType[ChoroMapType["none"] = 0] = "none";
        ChoroMapType[ChoroMapType["usStates"] = 1] = "usStates";
        ChoroMapType[ChoroMapType["usCounties"] = 2] = "usCounties";
    })(beachParty.ChoroMapType || (beachParty.ChoroMapType = {}));
    var ChoroMapType = beachParty.ChoroMapType;
    (function (LabelPositon) {
        LabelPositon[LabelPositon["left"] = 0] = "left";
        LabelPositon[LabelPositon["top"] = 1] = "top";
        LabelPositon[LabelPositon["right"] = 2] = "right";
        LabelPositon[LabelPositon["bottom"] = 3] = "bottom";
    })(beachParty.LabelPositon || (beachParty.LabelPositon = {}));
    var LabelPositon = beachParty.LabelPositon;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    squarifyLayout.ts - lays out items in a single-level squarified treemap.
//    adapted from: "Squarified Treemaps" paper by Mark Bruls, et al.  
//    http://www.win.tue.nl/~vanwijk/stm.pdf
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var squarifyLayoutClass = (function () {
        function squarifyLayoutClass() {
            this._isRowVertical = false;
            this._cellArray = [];
            this._cellMargin = 0;
            this._sortedPairs = [];
        }
        squarifyLayoutClass.prototype.layout = function (origValues, rc, cellMargin) {
            //---- use TEST DATA ----
            //values = [6, 6, 4, 3, 2, 2, 1];
            //rc = vp.geom.createRect(0, 0, 600, 400);
            var valuePairs = [];
            var now = vp.utils.now();
            //---- ensure all values are not too small, and pair them with a record index ----
            for (var i = 0; i < origValues.length; i++) {
                var value = Math.max(.00001, origValues[i]);
                valuePairs[i] = { value: value, index: i };
            }
            //---- sort the values ----
            var sortedPairs = valuePairs.orderByNum(function (v) { return v.value; });
            sortedPairs = sortedPairs.reverse();
            this._sortedPairs = sortedPairs;
            //---- extract just the values ----
            var values = sortedPairs.map(function (v) { return v.value; });
            //---- normalize the data to the size of the rc ----
            var area = rc.width * rc.height;
            var totalSum = values.sum();
            for (var i = 0; i < values.length; i++) {
                values[i] = values[i] / totalSum * area;
            }
            this._values = values;
            this._rc = rc;
            this._cellMargin = cellMargin;
            //---- report time taken to prep the data ----
            var elapsed = vp.utils.now() - now;
            var msg = "data prep of SQUARIFY took: " + elapsed + " ms";
            vp.utils.debug(msg);
            //vp.select("#consoleDiv").text(msg);
            var now = vp.utils.now();
            this.squarify();
            //---- report time taken to layout the cells ----
            var elapsed = vp.utils.now() - now;
            var msg = "cell layout of SQUARIFY took: " + elapsed + " ms";
            vp.utils.debug(msg);
            //vp.select("#consoleDiv").text(msg);
            return this._cellArray;
        };
        /** Returns the highest aspect ratio of the list of rectangles represented by "row". */
        squarifyLayoutClass.prototype.worst = function (row, w) {
            var wSquare = w * w;
            var sum = row.sum();
            var sSquare = sum * sum;
            var rMax = row.max();
            var rMin = row.min();
            var maxRatio = Math.max(wSquare * rMax / sSquare, sSquare / (wSquare * rMin));
            return maxRatio;
        };
        /** layout out the relative area sizes in "row", as a vertical or horizontal row in "rc". */
        squarifyLayoutClass.prototype.layoutRow = function (row, rowIndexes, remainingChildren) {
            var rowSum = row.sum();
            var totalSum = (remainingChildren.length) ? (rowSum + remainingChildren.sum()) : rowSum;
            var rc = this._rc;
            var left = rc.left;
            var cm = this._cellMargin;
            var cm2 = 2 * cm;
            if (this._isRowVertical) {
                //---- layout VERTICAL ROW (divisions in Y) ----
                var heightFactor = rc.height / rowSum;
                var width = rc.width * rowSum / totalSum;
                var adjWidth = Math.max(0, width - cm2);
                var bottom = rc.bottom;
                for (var i = 0; i < row.length; i++) {
                    var height = row[i] * heightFactor;
                    var adjHeight = Math.max(0, height - cm2);
                    var rcChild = vp.geom.createRect(left + cm, bottom - height + cm, adjWidth, adjHeight);
                    var cdChild = beachParty.CellData.fromRect(rcChild, beachParty.CellShape.rectangle);
                    //---- add index back to original data record ----
                    var index = rowIndexes[i];
                    this._cellArray[index] = cdChild;
                    bottom -= height;
                }
                //---- subtract used space from "rc" ----
                this._rc = vp.geom.createRect(rc.left + width, rc.top, rc.width - width, rc.height);
            }
            else {
                //---- layout HORIZONTAL ROW (divisions in X) ----
                var widthFactor = rc.width / rowSum;
                var height = rc.height * rowSum / totalSum;
                var adjHeight = Math.max(0, height - cm2);
                var top = rc.bottom - height;
                for (var i = 0; i < row.length; i++) {
                    var width = row[i] * widthFactor;
                    var adjWidth = Math.max(0, width - cm2);
                    var rcChild = vp.geom.createRect(left + cm, top + cm, adjWidth, adjHeight);
                    var cdChild = beachParty.CellData.fromRect(rcChild, beachParty.CellShape.rectangle);
                    //---- add index back to original data record ----
                    var index = rowIndexes[i];
                    this._cellArray[index] = cdChild;
                    left += width;
                }
                //---- subtract used space from "rc" ----
                this._rc = vp.geom.createRect(rc.left, rc.top, rc.width, rc.height - height);
            }
        };
        /** returns the length of the shortest side of remaining subrect in which current row is placed (this._rc). */
        squarifyLayoutClass.prototype.width = function () {
            var rc = this._rc;
            this._isRowVertical = (rc.width > rc.height);
            return Math.min(rc.width, rc.height);
        };
        squarifyLayoutClass.prototype.squarify = function () {
            var row = [];
            var rowIndexes = [];
            var nextRowIndex = 0;
            var children = this._values;
            var w = this.width();
            while (children.length) {
                var c = children[0];
                var wCurrent = this.worst(row, w);
                var wNext = this.worst(row.concat(c), w);
                //vp.utils.debug("squarify: c=" + c + ", wCurrent=" + wCurrent + ", wNext=" + wNext);
                //if (this.worst(row, w) <= this.worst(row.concat(c), w))
                if (row.length == 0 || (wNext <= wCurrent)) {
                    children.removeAt(0);
                    row.push(c);
                    var origRowIndex = this._sortedPairs[nextRowIndex++].index;
                    rowIndexes.push(origRowIndex);
                }
                else {
                    this.layoutRow(row, rowIndexes, children);
                    row = [];
                    rowIndexes = [];
                    w = this.width();
                }
            }
            this.layoutRow(row, rowIndexes, children);
        };
        return squarifyLayoutClass;
    }());
    beachParty.squarifyLayoutClass = squarifyLayoutClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    dampener.ts - class for smoothing out drag/pinch motion, as applied to world matrix.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var dampenerClass = (function () {
        function dampenerClass(applyCallback) {
            this._applyCallback = null;
            this._dampenFactor = .1; //   .3;     // .7;
            this._keepMoving = true;
            this._isOperationActive = false;
            this._firstTargetFrame = true;
            this._applyCallback = applyCallback;
            this._slidingWindow = new beachParty.slidingWindowClass(dampenerClass.windowDuration);
            this.startUiOperation();
        }
        dampenerClass.prototype.inertia = function (value) {
            if (arguments.length == 0) {
                return (this._isOperationActive) ? 0 : this._firstActual;
            }
            this._firstActual = value;
        };
        dampenerClass.prototype.hasInertia = function () {
            var has = (!this._isOperationActive) && (this._firstActual != 0);
            return has;
        };
        dampenerClass.prototype.startUiOperation = function () {
            this._target = 0;
            this._accum = 0;
            this._firstActual = 0;
            this._isOperationActive = true;
            //vp.utils.debug("startUiOperation called");
        };
        dampenerClass.prototype.stopUIOperation = function () {
            this._isOperationActive = false;
            //vp.utils.debug("stopUIOperation called");
            //---- if we didn't move the requd distance in last "windowDuration" ms, clear the inertia ----
            var samples = this._slidingWindow.getSamples();
            var count = samples.length;
            var dist = Math.abs(samples.sum(function (samp) { return +samp.value; }));
            //vp.utils.debug("--> length=" + count + ", dist=" + dist);
            if (count < 7) {
                this._firstActual = 0;
            }
        };
        dampenerClass.prototype.setTarget = function (value) {
            this._target += value;
            this._firstTargetFrame = true;
            this._slidingWindow.addSample(value);
            //vp.utils.debug("dampener.setTarget: value=" + value);
        };
        dampenerClass.prototype.apply = function (value) {
            if (Math.abs(value) > .0001) {
                if (this._applyCallback) {
                    this._applyCallback(value);
                }
            }
        };
        /**
         *  this must be called on each frame move.
         */
        dampenerClass.prototype.onFrameApply = function () {
            var hasInertia = false;
            if (this._isOperationActive) {
                if (this._accum != this._target) {
                    var frameTarget = vp.data.lerp(this._dampenFactor, this._accum, this._target);
                    var actual = frameTarget - this._accum;
                    //vp.utils.debug("dampener.onFrameApply: accum=" + this._accum + ", target=" + this._target +
                    //    ", frameTarget=" + frameTarget + ", actual=" + actual);
                    this.apply(actual);
                    if (this._firstTargetFrame) {
                        this._firstActual = actual;
                        this._firstTargetFrame = false;
                    }
                    this._accum = frameTarget;
                }
            }
            else if (this._keepMoving) {
                this.apply(this._firstActual);
                var epsilon = .001;
                hasInertia = (Math.abs(this._firstActual) > epsilon);
            }
            return hasInertia;
        };
        dampenerClass.createCycle = function (group, data) {
            var count = data.length;
            //---- draw circles ----
            for (var i = 0; i < count; i++) {
            }
            //---- draw arrows ----
            for (var i = 0; i < count; i++) {
            }
        };
        dampenerClass.windowDuration = 500; // ms
        return dampenerClass;
    }());
    beachParty.dampenerClass = dampenerClass;
})(beachParty || (beachParty = {}));
