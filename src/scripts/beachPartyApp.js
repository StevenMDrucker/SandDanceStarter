var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    baseAppControl.ts - base class for custom controls in BeachParty
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var baseAppControlClass = (function (_super) {
        __extends(baseAppControlClass, _super);
        function baseAppControlClass() {
            _super.apply(this, arguments);
            this._isClosing = false;
        }
        baseAppControlClass.prototype.getRootElem = function () {
            return this._root;
        };
        baseAppControlClass.prototype.showAt = function (left, top, right, bottom, fadeInOpts) {
            var rootW = vp.select(this._root)
                .css("left", "")
                .css("top", "")
                .css("right", "")
                .css("bottom", "");
            if (left != null) {
                rootW
                    .css("left", left + "px");
            }
            else if (right != null) {
                //---- convert right to offset from right edge ----
                right = innerWidth - right;
                rootW
                    .css("right", right + "px");
            }
            if (top != null) {
                rootW
                    .css("top", top + "px");
            }
            else if (bottom != null) {
                //---- convert bottom to offset from bottom edge ----
                bottom = innerHeight - bottom;
                rootW
                    .css("bottom", bottom + "px");
            }
            //rootW.show(true);
            beachParty.chartUtils.fadeIn(rootW[0], fadeInOpts);
            rootW[0].focus();
        };
        baseAppControlClass.prototype.hide = function () {
            vp.select(this._root).hide();
        };
        baseAppControlClass.prototype.remove = function () {
            this.hide();
            vp.select(this._root)
                .remove();
        };
        baseAppControlClass.prototype.onClose = function () {
        };
        /** Remove the panel from the DOM and unhook non-DOM event handlers on this._dataOwner. */
        baseAppControlClass.prototype.close = function () {
            this._isClosing = true;
            this.onClose();
            this.remove();
            this.onDataChanged("close");
        };
        return baseAppControlClass;
    }(beachParty.dataChangerClass));
    beachParty.baseAppControlClass = baseAppControlClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    basePanel.ts - base class for a floating (and optionally modal) panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var nextId = 1;
    var basePopupClass = (function (_super) {
        __extends(basePopupClass, _super);
        /** "openerIds" are id's of controls that can open this panel. */
        function basePopupClass(openerIds, ownerElem, isOpenId) {
            var _this = this;
            _super.call(this);
            //---- removeable event handlers ----
            this._keyboardFunc = null;
            this._mouseDownFunc = null;
            this._dblClickFunc = null;
            this._autoCloseOnDblClick = true;
            this._autoCloseOnOwnerMouseDown = true; // apply autoClose to me if mouseDown on my owner
            this._autoCloseOnOwneeMouseDown = false; // apply autoClose to me if mouseDown on an element that I own
            this._openerIds = openerIds;
            this._isOpenId = isOpenId;
            this.installEventHandlers();
            this._popupId = nextId++;
            this._ownerElem = ownerElem;
            //---- if "ownerElem" is based on basePopupClass, we will hook its close and close this object ---
            if (ownerElem) {
                var ownerParent = this.getTopLevelParent(ownerElem);
                var jsObj = ownerParent.jsObj;
                if (jsObj && jsObj instanceof basePopupClass) {
                    var ownerPopup = jsObj;
                    ownerPopup.registerForChange("close", function (e) {
                        if (_this.isAutoClose()) {
                            //--- if our owner closes, we should close ----
                            _this.close();
                        }
                    });
                }
            }
        }
        basePopupClass.prototype.getTopLevelParent = function (elem) {
            var parent = elem;
            while (parent && parent.parentNode && parent.parentNode != document.body) {
                parent = parent.parentElement;
            }
            return parent;
        };
        basePopupClass.prototype.setOpenerSelected = function (value) {
            if (this._isOpenId) {
                vp.select("#" + this._isOpenId).attr("data-selected", (value) ? "true" : "false");
            }
        };
        basePopupClass.prototype.showAt = function (left, top, right, bottom, fadeInOpts, clearBounds) {
            if (clearBounds === void 0) { clearBounds = true; }
            var rootElem = this.getRootElem();
            var rcPopup = vp.select(rootElem).getBounds();
            //---- remove RIGHT and BOTTOM alignment (they make for an unpredictable UX) ----
            if (right != undefined) {
                left = Math.max(0, right - rcPopup.width);
                right = undefined;
            }
            if (bottom != undefined) {
                top = Math.max(0, bottom - rcPopup.height);
                bottom = undefined;
            }
            //---- workaround for IE: measurement of panel WIDTH/HEIGHT seems to be wrong for certain panels ----
            if (vp.utils.isIE || vp.utils.isEdge) {
                if (rootElem.id == "sizePanelPanel") {
                    left -= 25;
                }
                else if (rootElem.id == "shapePanelPanel") {
                    left -= 15;
                }
            }
            if (vp.utils.isIE) {
                if (rootElem.id == "xPanelPanel") {
                    top += 8;
                }
            }
            this.openWithoutOverlap(left, top, right, bottom, fadeInOpts, clearBounds);
        };
        basePopupClass.prototype.checkForTopOverlap = function (top, bottom, yMargin, panelHeight) {
            var delta = 0;
            if (top != null) {
                var topOverlap = (top - yMargin);
                var yBottom = top + panelHeight;
                if (topOverlap < 0) {
                    //---- move DOWN ----
                    delta = -topOverlap;
                }
                else {
                    //---- check for BOTTOM overlap ----
                    var bottomOverlap = (yBottom + yMargin) - innerHeight;
                    if (bottomOverlap > 0) {
                        //---- move UP ----
                        delta = -bottomOverlap;
                    }
                }
            }
            else if (bottom != null) {
                var topOverlap = ((bottom - panelHeight) - yMargin);
                var yBottom = bottom;
                if (topOverlap < 0) {
                    //---- move DOWN ----
                    delta = -topOverlap;
                }
                else {
                    //---- check for BOTTOM overlap ----
                    var bottomOverlap = (yBottom + yMargin) - innerHeight;
                    if (bottomOverlap > 0) {
                        //---- move UP ----
                        delta = -bottomOverlap;
                    }
                }
            }
            return delta;
        };
        basePopupClass.prototype.checkForLeftOverlap = function (left, right, xMargin, panelWidth) {
            var delta = 0;
            if (left != null) {
                //---- check for LEFT overlap ----
                var leftOverlap = (left - xMargin);
                if (leftOverlap < 0) {
                    //---- move RIGHT ----
                    delta = -leftOverlap;
                }
                else {
                    //---- check for RIGHT overlap ----
                    var myWidth = panelWidth;
                    var rightOverlap = (left + myWidth + xMargin) - innerWidth;
                    if (rightOverlap > 0) {
                        //---- move LEFT ----
                        delta = -rightOverlap;
                    }
                }
            }
            else if (right != null) {
                //---- check for LEFT overlap ----
                var leftOverlap = ((right - panelWidth) - xMargin);
                if (leftOverlap < 0) {
                    //---- move RIGHT ----
                    delta = -leftOverlap;
                }
                else {
                    //---- check for RIGHT overlap ----
                    var rightOverlap = (right + xMargin) - innerWidth;
                    if (rightOverlap > 0) {
                        //---- move LEFT ----
                        delta = -rightOverlap;
                    }
                }
            }
            return delta;
        };
        /** Open the specified panel so that it is near x,y but not overlapping with any of the 4 window edges. */
        basePopupClass.prototype.openWithoutOverlap = function (left, top, right, bottom, fadeInOpts, clearBounds) {
            if (clearBounds === void 0) { clearBounds = true; }
            var rootW = vp.select(this._root);
            var rcPanel = rootW.getBounds(false);
            var maxWidth = .9 * innerWidth;
            var maxHeight = .9 * innerHeight;
            ////---- check for sizes exceeding 90% of screen ----
            //if (rcPanel.width > maxWidth)
            //{
            //    rootW.css("max-width", maxWidth + "px");
            //}
            //if (rcPanel.height > maxHeight)
            //{
            //    rootW.css("max-height", maxHeight + "px");
            //}
            //---- refresh RC after potentially setting max sizes ----
            var rcPanel = rootW.getBounds(false);
            var yMargin = 20;
            var xMargin = 0; // so "Dataset" panel can open left aligned to button
            //---- check for TOP overlap ----
            var ydelta = this.checkForTopOverlap(top, bottom, yMargin, rcPanel.height);
            var xdelta = this.checkForLeftOverlap(left, right, xMargin, rcPanel.width);
            if (clearBounds) {
                //---- clear previous settings ----
                rootW
                    .css("left", "")
                    .css("top", "")
                    .css("right", "")
                    .css("bottom", "");
            }
            if (left != null) {
                rootW
                    .css("left", (left + xdelta) + "px");
            }
            else if (right != null) {
                right += xdelta;
                //---- convert right to offset from right edge ----
                right = innerWidth - right;
                rootW
                    .css("right", right + "px");
            }
            if (top != null) {
                rootW
                    .css("top", (top + ydelta) + "px");
            }
            else if (bottom != null) {
                bottom += ydelta;
                //---- convert bottom to offset from bottom edge ----
                bottom = innerHeight - bottom;
                rootW
                    .css("bottom", bottom + "px");
            }
            //rootW.show(true);
            if (fadeInOpts !== -1) {
                beachParty.chartUtils.fadeIn(rootW[0], fadeInOpts);
            }
            rootW[0].focus();
            //---- set our button to "selected" state ----
            this.setOpenerSelected(true);
        };
        basePopupClass.prototype.fixUpMouseEvent = function (e) {
            if (!e.target && e.__proto__) {
                e = e.__proto__;
            }
            return e;
        };
        basePopupClass.prototype.onAnyKeyDown = function (e) {
            e = this.fixUpMouseEvent(e);
            if (e.keyCode == vp.events.keyCodes.escape) {
                this.close();
            }
        };
        basePopupClass.prototype.onMyDblClick = function (e) {
            e = this.fixUpMouseEvent(e);
            //if (this._autoCloseOnDblClick && this.isAutoClose())
            //{
            //    this.close();
            //}
        };
        /** is overriden by subclasses, like basePopup. */
        basePopupClass.prototype.isAutoClose = function () {
            return true;
        };
        basePopupClass.prototype.doesElementBelongToMe = function (elem) {
            var parent = elem;
            //---- get top-most element OR owner (whichever comes first)  ----
            while (parent && parent != this._root && parent != this._ownerElem && parent.parentElement &&
                parent.parentElement != document.body) {
                parent = parent.parentElement;
            }
            var isMyElem = (parent == this._root ||
                (!this._autoCloseOnOwnerMouseDown && parent == this._ownerElem));
            if (!isMyElem && !this._autoCloseOnOwneeMouseDown) {
                //---- see if this was a child popup belonging to me or one of my controls ----
                var anyParent = parent;
                if (anyParent && anyParent.jsObj) {
                    var jsObj = anyParent.jsObj;
                    if (jsObj instanceof basePopupClass) {
                        var popup = jsObj;
                        isMyElem = this.doesElementBelongToMe(popup._ownerElem);
                    }
                }
            }
            return isMyElem;
        };
        basePopupClass.prototype.onAnyMouseDown = function (e) {
            e = this.fixUpMouseEvent(e);
            if (e && e.target && (this.isAutoClose())) {
                var elem = e.target;
                var isMyElem = this.doesElementBelongToMe(elem);
                if (!isMyElem) {
                    //---- mouse clicked on an element that is NOT part of this popup/panel ----
                    this.close();
                    //---- find elem with id (some inner parts of buttons don't have them ----
                    if (!elem.id) {
                        elem = elem.parentElement;
                    }
                    //---- cancel event if this was one of my openers (to prevent this panel from immediately reopening ----
                    //---- when the user was clicking on our opener UI to TOGGLE our panel closed. ----
                    var isMine = false;
                    if (elem) {
                        isMine = this.isMyOpener(elem.id);
                        if (!isMine && elem.parentNode) {
                            elem = elem.parentNode;
                            if (elem.parentNode) {
                                isMine = this.isMyOpener(elem.parentNode.id);
                            }
                        }
                        if (isMine) {
                            //vp.events.cancelEventBubble(e);
                            //vp.events.cancelEventDefault(e);
                            //---- we can't prevent the upcoming CLICK event, so we mark the element instead ---
                            elem.ignoreNextClick = true;
                            vp.utils.debug("marking elem.ignoreNextClick=true for id=" + elem.id);
                        }
                    }
                }
            }
        };
        basePopupClass.prototype.isMyOpener = function (id) {
            var isMine = false;
            if (this._openerIds) {
                var oNames = this._openerIds.split(" ");
                for (var i = 0; i < oNames.length; i++) {
                    var oName = oNames[i];
                    if (id.contains(oName)) {
                        isMine = true;
                        break;
                    }
                }
            }
            return isMine;
        };
        basePopupClass.prototype.isVisible = function () {
            var elem = this._root;
            var isVisible = (vp.select(elem).css("visibility") == "visible");
            return isVisible;
        };
        basePopupClass.prototype.installEventHandlers = function () {
            var _this = this;
            //---- install event handlers to capture ESCAPE or MOUSEDOWN at DOCUMENT level ----
            this._keyboardFunc = function (e) { return _this.onAnyKeyDown(e); };
            this._mouseDownFunc = function (e) { return _this.onAnyMouseDown(e); };
            this._dblClickFunc = function (e) { return _this.onMyDblClick(e); };
            //---- set this to install async so that current click doesn't interfere ----
            setTimeout(function (e) {
                document.addEventListener("keydown", _this._keyboardFunc);
                document.addEventListener("mousedown", _this._mouseDownFunc);
                _this._root.addEventListener("dblclick", _this._dblClickFunc);
            }, 1);
        };
        basePopupClass.prototype.show = function (value) {
            if (value === void 0) { value = true; }
            if (value) {
                this.showAt(undefined, undefined, undefined, undefined, undefined, false);
            }
            else {
                this.hide();
            }
        };
        basePopupClass.prototype.hide = function () {
            //---- set visibility=hidden with display='', so we can measure our panel parts while it is not visible ----
            _super.prototype.hide.call(this);
            var elem = this._root;
            //---- remove our DOCUMENT event handlers ----
            document.removeEventListener("keydown", this._keyboardFunc);
            document.removeEventListener("mousedown", this._mouseDownFunc);
            this._root.removeEventListener("dblclick", this._dblClickFunc);
        };
        /** Remove the panel from the DOM and unhook non-DOM event handlers on this._dataOwner. */
        basePopupClass.prototype.close = function () {
            //---- remove ptr to this code to prevent holding memory ----
            var anyRoot = this._root;
            if (anyRoot.jsObj && anyRoot.jsObj != this) {
                //---- remove ptr to this code to prevent holding memory ----
                anyRoot.jsObj = null;
            }
            _super.prototype.close.call(this);
            //---- set our button to NOT "selected" state ----
            this.setOpenerSelected(false);
        };
        return basePopupClass;
    }(beachParty.baseAppControlClass));
    beachParty.basePopupClass = basePopupClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    basePanel.ts - base class for a floating (and optionally modal) panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var nextId = 1;
    /// panel layout strategy:
    ///   As of 9/16/2016, we switched to using flexBox - removes the need for layout code!
    var basePanelClass = (function (_super) {
        __extends(basePanelClass, _super);
        function basePanelClass(app, name, isDialog, bgColor, title, width, height, resizeable, tooltip, hideTitleCloseButton, addAutoClose, omitCloseButtons, isOpacityDisabled, isFlexPanel, uiOpenName) {
            var _this = this;
            _super.call(this, name, undefined, uiOpenName);
            this._hasTitle = false;
            this._isOpacityDisabled = false;
            //---- DRAG of title bar ----
            this._onMouseMoveFunc = null; // setCapture
            this._onMouseUpFunc = null; // setCapture
            this._isDragging = false;
            this._isFloating = false;
            this._closeOnAction = true;
            //---- DRAG of resize gripper ----
            this._isUserSized = false;
            this._sizeAtMouseDown = null;
            this._onResizeMouseMoveFunc = null; // setCapture
            this._onResizeMouseUpFunc = null; // setCapture
            this._onResizeCallback = null;
            this._app = app;
            this._isFlexPanel = isFlexPanel;
            this._onResizeCallback = function (e) { return _this.setHeightForIE(); };
            //---- IE workaround for flexBox scrolling child vs. parent min-height issue ----
            if (vp.utils.isIE) {
                vp.select(window).attach("resize", this._onResizeCallback);
            }
            basePanelClass.panelCount++;
            this._title = title;
            this._tooltip = tooltip || "";
            this._hideTitleCloseButton = hideTitleCloseButton;
            this._isOpacityDisabled = isOpacityDisabled;
            //---- create ROOT DIV ----
            var divW = vp.select(document.body).append("div")
                .addClass("appBody") // so it inherits the CSS of the appDiv (since it will be parented to document.body)
                .addClass("flexRows panel")
                .id(name + "Panel")
                .css("visibility", "hidden") // this allows us to correctly measure panel while it is not visible to user
                .css("position", "absolute")
                .css("overflow-y", "auto") // when user window is small, we will need this (especially for color palette in color panel)
                .css("overflow-x", "hidden") // let panel control the width and consequences
                .attach("focus", function (e) {
                _this.onFocus(e);
            });
            //---- by using "vh" and "vw", we get dynamic sizing from HTML! ----
            divW
                .css("max-width", "80vw")
                .css("max-height", "80vh");
            this._root = divW[0];
            this._root.jsObj = this;
            //---- experiment ----
            vp.select(this._root).css("display", "");
            //---- don't build a title panel if no title has been specified ----
            if (title) {
                this.buildTitleRow(divW, title);
            }
            var contentW = divW.append("div")
                .addClass("flexGrow flexRows")
                .id("panelContent");
            this._contentRow = contentW[0];
            if (bgColor) {
                divW
                    .css("background", bgColor);
            }
            this._onMouseMoveFunc = function (e) { return _this.onDragMouseMove(e); };
            this._onMouseUpFunc = function (e) { return _this.onDragMouseUp(e); };
            this._onResizeMouseMoveFunc = function (e) { return _this.onResizeMouseMove(e); };
            this._onResizeMouseUpFunc = function (e) { return _this.onResizeMouseUp(e); };
            this._isDialog = isDialog;
            if (this._isDialog) {
                //---- don't show pin for dialogs ----
                this._isFloating = true;
            }
            if (resizeable) {
                this.createResizer(divW);
            }
            if (width !== undefined) {
                divW.css("width", width + "px");
            }
            if (height !== undefined) {
                divW.css("height", height + "px");
            }
            if (vp.utils.isIE) {
                setTimeout(function (e) { return _this.setHeightForIE(); }, 1); // set height after subclass has finished adding controls
            }
        }
        basePanelClass.prototype.setHeightForIE = function () {
            if (vp.utils.isIE && this._isFlexPanel && !this._isUserSized) {
                var panel = this._root;
                //---- remove height to measure natural size, subject to max-height ----
                panel.style.height = "";
                var rc = panel.getBoundingClientRect();
                //---- set height explictly ----
                panel.style.height = rc.height + "px";
            }
        };
        basePanelClass.prototype.getContentRoot = function () {
            return this._contentRow;
        };
        basePanelClass.prototype.buildTitleRow = function (rootW, text) {
            var _this = this;
            //---- TITLE ROW ----
            var rowW = rootW.append("div")
                .addClass("flexAuto flexColumns flexSpace")
                .id("panelTitleRow")
                .css("padding", "4px")
                .css("border-bottom", "1px solid #555")
                .css("margin-bottom", "4px");
            //---- TITLE HOLDER (so we can hide title without collasping layout ----
            var titleHolderW = rowW.append("div")
                .addClass("flexAuto");
            //---- TITLE ----
            var titleW = titleHolderW.append("div")
                .addClass("flexAuto panelPrompt")
                .id("title")
                .title(this._tooltip)
                .text(this._title);
            //---- BUTTON HOLDER ----
            var buttonHolderW = rowW.append("div")
                .addClass("flexAuto flexColumns")
                .id("buttonHolder");
            //---- PUSH PIN ----
            var imgPinW = buttonHolderW.append("img")
                .addClass("flexAuto clickIcon")
                .id("imgPin")
                .css("width", "18px")
                .css("height", "18px")
                .css("margin-right", "2px")
                .attach("click", function (e) { return _this.togglePin(e, true); });
            beachParty.setIconName(this._app._themeMgr, imgPinW[0], beachParty.fnPinLeft, "dockedPanel", true);
            //---- CLOSE button----
            var imgCloseW = buttonHolderW.append("img")
                .id("closeButton")
                .addClass("flexAuto clickIcon")
                .css("width", "12px")
                .css("height", "12px")
                .css("margin", "2px")
                .attach("click", function (e) { return _this.close(); });
            beachParty.setIconName(this._app._themeMgr, imgCloseW[0], beachParty.fnClose, "dockedPanel", true);
            this._imgPin = imgPinW[0];
            this._titleElem = titleW[0];
            this._titleRowElem = rowW[0];
            //---- hook mouse down on title bar, as long as it isn't in the button area ----
            rowW
                .attach("mousedown", function (e) {
                var pt = vp.events.mousePosition(e);
                var rcButtons = buttonHolderW.getBounds();
                if (pt.x < rcButtons.left) {
                    _this.onDragMouseDown(e);
                    _this.onFocus(e);
                }
            });
        };
        basePanelClass.prototype.updateTextBoxClasses = function (newClassName) {
            //---- for each textbox contained in panel, ensure it uses the specified class ----
            vp.select(this._root, ".panelText").each(function (index, elemW) {
                //---- ensure this is a wrapped elem ----
                if (elemW.length === undefined) {
                    elemW = vp.select(elemW);
                }
                elemW.setClass(".panelText " + newClassName);
            });
        };
        basePanelClass.prototype.isAutoClose = function () {
            //return (! this.isShowingTitle());
            return (!this._isFloating);
        };
        basePanelClass.prototype.getDataOwner = function (memberName) {
            /// _dataOwner could be null, a single object, or an array of objects.
            /// below code will put it into array form, as needed.
            var owners = this._dataOwner;
            if (!owners) {
                //---- was null ----
                owners = [this._app];
            }
            else if (!owners.length) {
                //---- was single object ----
                owners = [owners, this._app];
            }
            var owner = null;
            for (var i = 0; i < owners.length; i++) {
                var thisObj = owners[i];
                if (thisObj[memberName]) {
                    owner = thisObj;
                    break;
                }
            }
            if (!owner) {
                vp.utils.error("Could not find owner for panel dataName=" + memberName);
            }
            return owner;
        };
        basePanelClass.prototype.callMethod = function (methodName) {
            var params = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                params[_i - 1] = arguments[_i];
            }
            if (methodName) {
                var thisObj = this.getDataOwner(methodName);
                var func = thisObj[methodName];
                var returnValue = func.apply(thisObj, params);
                return returnValue;
            }
            return undefined;
        };
        basePanelClass.prototype.getValue = function (propName) {
            //---- call property getter on dataOwner obj ----
            var thisObj = this.getDataOwner(propName);
            var value = thisObj[propName]();
            return value;
        };
        basePanelClass.prototype.setValue = function (propName, value) {
            //---- call property setter on dataOwner obj ----
            var thisObj = this.getDataOwner(propName);
            thisObj[propName](value);
        };
        basePanelClass.prototype.onUserAction = function (row, isCloseAction, gesture, elementType, name) {
            gesture = gesture || beachParty.Gesture.notAvailable;
            elementType = elementType || beachParty.ElementType.notAvailable;
            var dataName = (row) ? row.dataName : null;
            if (!name && row) {
                name = row.id;
            }
            var action = beachParty.Action.adjust;
            var target = beachParty.Target.currentPanel;
            var isUndoable = false;
            if (dataName) {
                var value = (row.button === undefined) ? this.getValue(dataName) : "clicked";
                //---- a central place to log panel UI pushes ----
                this._app.logAction(gesture, name, elementType, action, target, isUndoable, { dataName: dataName, value: value, panelName: this._title });
            }
            //---- look for "closeAction: true" from panel rows ---
            var closeMe = (isCloseAction != null) ? isCloseAction : row.closeAction;
            if (closeMe && this._closeOnAction && !this._isFloating) {
                this.close();
            }
            else {
                //---- turn off autoClose if first action wasn't a closing action ----
                this._closeOnAction = false;
            }
        };
        basePanelClass.prototype.isFloating = function (value) {
            if (arguments.length == 0) {
                return this._isFloating;
            }
            this._isFloating = value;
            this.onPinnedDownChanged();
            this.onDataChanged("isFloating");
        };
        basePanelClass.prototype.onPinnedDownChanged = function () {
            this.showTitle(this._isFloating);
            if (this._isFloating) {
                beachParty.setIconName(this._app._themeMgr, this._imgPin, beachParty.fnPinDown, "dockedPanel", true);
            }
            else {
                beachParty.setIconName(this._app._themeMgr, this._imgPin, beachParty.fnPinLeft, "dockedPanel", true);
            }
            if (this._isFloating) {
                //---- convert to a draggable panel with a title bar ----
                vp.select(this._imgPin).css("display", "none"); // hide auto close buttons
                if (this._isOpacityDisabled) {
                    vp.select(this._root).css("opacity", "1");
                }
                this.onLayoutChanged();
            }
            else {
                vp.select(this._imgPin).css("display", ""); // show
            }
        };
        basePanelClass.prototype.onLayoutChanged = function () {
            //---- workaround for layout bug in IE ----
            if (vp.utils.isIE) {
                var anyThis = this;
                if (anyThis.layoutFix) {
                    var rootW = vp.select(this._root);
                    rootW
                        .css("visibility", "hidden");
                    anyThis.layoutFix();
                    rootW
                        .css("visibility", "visible");
                }
            }
        };
        basePanelClass.prototype.togglePin = function (e, fromUserClick) {
            this.isFloating(!this._isFloating);
            if (fromUserClick) {
                this._app.logAction(beachParty.Gesture.click, e.target.id, beachParty.ElementType.button, beachParty.Action.adjust, beachParty.Target.panelPin, false);
            }
        };
        basePanelClass.prototype.centerPanel = function () {
            var rc = vp.select(this._root).getBounds(false);
            var left = window.innerWidth / 2 - rc.width / 2;
            var top = window.innerHeight / 2 - rc.height / 2;
            vp.select(this._root)
                .css("left", left + "px")
                .css("top", top + "px")
                .css("right", "")
                .css("bottom", "");
        };
        basePanelClass.prototype.onFocus = function (e) {
            if (this._primaryControl) {
                var elem = this._primaryControl.getRootElem();
                setTimeout(function (e) { return elem.focus(); }, 100);
            }
        };
        basePanelClass.prototype.createResizer = function (rootW) {
            var _this = this;
            //---- add RESIZE icon as affordance ----
            var imgW = rootW.append("img")
                .addClass("clickIcon panelResizer")
                .attr("src", "resize.png")
                .css("position", "absolute")
                .css("right", "0px")
                .css("bottom", "0px")
                .css("z-index", "999"); // keep on top of all other elements
            //this._resizeElem = imgW[0];
            imgW
                .attach("mousedown", function (e) {
                _this._ptDown = vp.events.mousePosition(e, _this._root);
                _this._sizeAtMouseDown = vp.dom.getBounds(_this._root);
                _this._isUserSized = true;
                _this.removeRightBottomAlignment(_this._root);
                vp.events.setCaptureWindow(_this._onResizeMouseMoveFunc, _this._onResizeMouseUpFunc);
                _this.onFocus(e);
                vp.events.cancelEventBubble(e);
                vp.events.cancelEventDefault(e);
            });
        };
        basePanelClass.prototype.setFloatingClass = function (value) {
            if (value) {
                vp.select(this._root).removeClass("dockedPanel");
                vp.select(this._root).addClass("undockedPanel");
            }
            else {
                vp.select(this._root).removeClass("undockedPanel");
                vp.select(this._root).addClass("dockedPanel");
            }
        };
        basePanelClass.prototype.showTitle = function (value) {
            this.setFloatingClass(value);
            vp.select(this._titleElem).css("display", (value) ? "" : "none");
            vp.select(this._autoCloseRow).css("display", (!value) ? "" : "none");
            //---- show/hide line under title ----
            vp.select(this._titleRowElem)
                .css("border-bottom", (value) ? "1px solid #555" : "0")
                .css("margin-bottom", (value) ? "4px" : "-4px");
            //---- show/hide the PIN button ----
            vp.select(this._imgPin).css("display", (value) ? "none" : "");
            //this.onPanelSizeChanged();
        };
        basePanelClass.prototype.isShowingTitle = function () {
            return (vp.select(this._titleElem).css("display") != "none");
        };
        basePanelClass.prototype.open = function (left, top, right, bottom) {
            if (arguments.length == 0) {
                this.centerPanel();
            }
            else {
                var rootW = vp.select(this._root);
                //if (right != undefined)
                //{
                //    //---- convert to left ----
                //    left = right - rootW.width();
                //}
                //if (bottom != undefined)
                //{
                //    //---- convert to top ----
                //    top = bottom - rootW.height();
                //}
                _super.prototype.openWithoutOverlap.call(this, left, top, right, bottom);
                rootW
                    .css("display", "block");
            }
        };
        basePanelClass.prototype.onResizeMouseMove = function (e) {
            var pt = vp.events.mousePosition(e, this._root);
            var rcDown = this._sizeAtMouseDown;
            var xDiff = pt.x - this._ptDown.x;
            var yDiff = pt.y - this._ptDown.y;
            vp.utils.debug("onResizeMouseMove: xDiff=" + xDiff + ", yDiff=" + yDiff);
            var minWidth = 75;
            var minHeight = 35; //75;
            var width = Math.max(minWidth, rcDown.width + xDiff);
            var height = Math.max(minHeight, rcDown.height + yDiff);
            this.changePanelSize(width, height);
        };
        basePanelClass.prototype.removeRightBottomAlignment = function (elem) {
            var cs = getComputedStyle(elem);
            if (cs.right || cs.bottom) {
                var rc = vp.select(elem).getBounds();
                if (cs.right) {
                    vp.select(elem)
                        .css("right", "")
                        .css("left", rc.left + "px");
                }
                if (cs.bottom) {
                    vp.select(elem)
                        .css("bottom", "")
                        .css("top", rc.top + "px");
                }
            }
        };
        basePanelClass.prototype.changePanelSize = function (width, height) {
            var root = this._root;
            ////---- remove sizes ----
            //root.style.width = "";
            //root.style.height = "";
            var targetW = vp.select(this._root);
            targetW.css("width", width + "px");
            targetW.css("height", height + "px");
            vp.utils.debug("changePanelSize: width=" + width + ", height=" + height);
            this.onDataChanged("size");
        };
        basePanelClass.prototype.onResizeMouseUp = function (e) {
            vp.events.releaseCaptureWindow();
            var rc = vp.select(this._root).getBounds();
            this._app.logAction(beachParty.Gesture.drag, null, beachParty.ElementType.resizer, beachParty.Action.adjust, beachParty.Target.panelSize, false, { width: rc.width, height: rc.height, panel: this._title });
        };
        basePanelClass.prototype.onDragMouseDown = function (e) {
            this._ptDown = vp.events.mousePosition(e, this._root);
            this._isDragging = true;
            //---- move this to the top of the panels ----
            var rootW = vp.select(this._root);
            rootW.remove();
            vp.select(document.body).append(rootW[0]);
            if (!this._isFloating) {
                this.togglePin(e, false);
            }
            vp.events.setCaptureWindow(this._onMouseMoveFunc, this._onMouseUpFunc);
        };
        basePanelClass.prototype.onDragMouseMove = function (e) {
            if (this._isDragging) {
                var pt = vp.events.mousePosition(e);
                var x = pt.x - this._ptDown.x;
                var y = pt.y - this._ptDown.y;
                vp.select(this._root)
                    .css("left", x + "px")
                    .css("top", y + "px")
                    .css("right", "")
                    .css("bottom", "");
                this.onDataChanged("location");
                if (!this.isShowingTitle()) {
                    this.showTitle(true);
                }
            }
        };
        basePanelClass.prototype.onDragMouseUp = function (e) {
            this._isDragging = false;
            vp.events.releaseCaptureWindow();
            var rc = vp.select(this._root).getBounds();
            this._app.logAction(beachParty.Gesture.drag, null, beachParty.ElementType.panelTitle, beachParty.Action.adjust, beachParty.Target.panelLocation, false, { left: rc.left, top: rc.top, panel: this._title });
        };
        //---- override basePopup onKey handling ----
        basePanelClass.prototype.onAnyKeyDown = function (e) {
            if (e.keyCode == vp.events.keyCodes.enter) {
                this.onEnterKey(true, false);
                if (this._isClosing) {
                    vp.events.cancelEventBubble(e);
                    vp.events.cancelEventDefault(e);
                }
            }
            else if (e.keyCode == vp.events.keyCodes.escape) {
                this.onEscapeKey();
                vp.events.cancelEventBubble(e);
                vp.events.cancelEventDefault(e);
            }
        };
        basePanelClass.prototype.commitEditOnCurrentControl = function () {
            var focusElem = document.activeElement;
            vp.utils.debug("commitEditOnCurrentControl: BEFORE focusElem.id=" + focusElem + ", value=" + vp.dom.value(focusElem));
            //---- trigger BLUR event on active text field to commit its data to asscoiated property ----
            document.body.focus();
            var bodyFocusElem = document.activeElement;
            vp.utils.debug("commitEditOnCurrentControl: MIDDLE focusElem.id=" + bodyFocusElem);
            //---- move focus back to element, so user can try another value, tab, etc. ----
            focusElem.focus();
            var postFocusElem = document.activeElement;
            vp.utils.debug("commitEditOnCurrentControl: AFTER focusElem.id=" + postFocusElem + ", value=" + vp.dom.value(postFocusElem));
        };
        basePanelClass.prototype.processOnEnter = function () {
            this.onDataChanged("onAccept");
            if (!this._isFloating) {
                this.scheduleClose();
            }
        };
        basePanelClass.prototype.scheduleClose = function () {
            var _this = this;
            this._isClosing = true;
            //---- give focus a chance to get processed ----
            setTimeout(function (e) {
                _this.close();
            }, 100);
        };
        basePanelClass.prototype.onEnterKey = function (isFromKeyboard, fromAcceptButton) {
            this.commitEditOnCurrentControl();
            this.processOnEnter();
        };
        basePanelClass.prototype.onEscapeKey = function () {
            //---- should floating panels be closed on ESCAPE key? ----
            var closeFloat = false;
            if (!this._isFloating || closeFloat) {
                this.close();
                this.onDataChanged("onCancel");
            }
        };
        basePanelClass.prototype.close = function () {
            //---- unhook events so that we don't hold panel open ----
            vp.select(window).detach("resize", this._onResizeCallback);
            _super.prototype.close.call(this);
        };
        basePanelClass.panelCount = 0;
        return basePanelClass;
    }(beachParty.basePopupClass));
    beachParty.basePanelClass = basePanelClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    jsonPanel.ts - panel that is built from a JSON description
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var nextId = 1;
    ///----------------------------------------------------------
    /// Supported control properties include:
    ///     isFloating: true    // use the "floatingPanel" style for this panel (not docked)
    ///     cellPadding: 3,     // padding around each cell set to 3px (in the grid/table)
    ///     colFill: true,      // aligns controls to GRID columns 
    ///     width: 300,         // force width of control to 300px
    ///     newRowIndent: true  // starts a new row, but with an indent of approx 50px.
    ///     sameRow: true       // adds this control onto the row of the previous control
    ///     sameCell: true     // puts control in previous table cell 
    ///     sameCellAsPrompt: true     // puts prompt and control in same table cell
    ///     top: -10px          // does position=relative TOP adjustment on the control
    ///     promptTop: -10px    // does position=relative TOP adjustment on the prompt text element
    ///     marginLeft: 10px    // aplies the specified margin to the control (or prompt, if it exists) 
    ///     emptyRow: true      // inserts a blank row
    /// Supported controls:
    ///
    ///     prompt      - static text (usually used to introduce control on next line; non-breaking span)
    ///     longPrompt  - multi-line static text
    ///     display     - bound text (readonly - user cannot change)
    ///     textBox     - a single line of text that user can edit
    ///     textArea    - multiline text control that user can edit
    ////
    ///     hr          - a horizontal line to divide previous/next rows
    ///     progress    - a progress bar
    ///     image       - an image
    ///     button      - a text button
    ///     checkbox    - a checkbox with text following it (prompt)
    ///     radio       - a radio button with text following it (prompt)
    ///     pane        - a nested set of controls that can be toggled open/closed
    ///     numAdjuster - a numeric textbox with a openable side control (slider with minus, plus buttons)
    ///     
    ///     tourPicker      - a dropdown that allows user to select a tour
    ///     palettePicker   - a dropdown that allows a user to select a color palette
    ///     scriptPicker    - a dropdown that allows a user to select a script
    ///     themePicker     - a dropdown that allows a user to select a theme
    ///     colPicker       - a dropdown that allows a user to select a column name
    ///     knownDataPicker - a dropdown that allows a user to select a known dataset name
    ///     enumPicker      - a dropdown that allows a user to select 1 of a set of enum values
    ///     scrubberPicker  - a dropdown that allows a user to select 1 of a set of scrubber templates
    ///     shapePicker     - a dropdown that allows a user to select a shape type (image)
    ///     colorPicker     - a dropdown that allows a user to select a color from a small set of colors or enter a custom color string
    ///     lineColorPicker - a dropdown that allows a user to select a color from a small set of line color names
    ///
    ///     colPickerList         - a list of selectable column names
    ///     knownDataPickerList   - a list of known dataset names
    ///     testDataPickerList    - a list of test dataset names
    ///     openDataPickerList    - a list of open dataset names (allowing user to switch between datasets quickly)
    ///     customList            - a custom list (whose contents are filled by the calling code)
    ///     control               - a custom control (todo: define how this is used)
    /// Layout strategy:
    ///     Overall, we use flexBox for panels.  In jsonPanel, the tabControls are a "flexAuto" row, as are tables that contain the controls.  The one exception
    ///     is that lists that grow with the panel size are added outside of the tables as their own "flexGrow" row.
    var jsonPanelClass = (function (_super) {
        __extends(jsonPanelClass, _super);
        function jsonPanelClass(app, openerIds, dataOwner, name, json, bgColor, isCol1Indent, title, tip, localeName, isFlexPanel, uiOpenName) {
            var _this = this;
            if (isCol1Indent === void 0) { isCol1Indent = true; }
            if (isFlexPanel === void 0) { isFlexPanel = true; }
            _super.call(this, app, name, json.isDialog, bgColor, title, json.width, json.height, json.resizable, tip, json.hideClose, json.autoClose, json.OpacityDisabled, null, isFlexPanel, uiOpenName);
            this._isPanelLoading = true;
            this._lastRowW = null;
            this._controlsById = {};
            this._primaryControl = null; // if set, pass focus to this control
            this._isCol1Indent = true; // by default,  use indent instead of another TD
            this._rowSpacing = null;
            this._controls = [];
            this._lastTdW = null;
            this._acceptDataName = null; // data name from the ACCEPT BUTTON
            //_adjustSize = null;
            //_longListByTabs = null;
            this._currentTabId = null; // e.g, "tab0"
            this._nameOfTabBeingBuilt = null; // e.g., "Columns"
            this._tabNames = [];
            this._isColFillGrid = false;
            //---- we must unregister our event handlers with these owners when we are closed ----
            this._ownersWithCallbacks = [];
            this._app = app;
            this._jsonObj = json;
            this._panelName = localeName; // name;
            if (json.hideTitle) {
                this.showTitle(false);
            }
            this._dataOwner = dataOwner;
            this._isCol1Indent = isCol1Indent;
            this._openerIds = openerIds;
            this._rowSpacing = json.rowSpacing;
            this._isDialog = json.isDialog;
            if (json.minHeight) {
                vp.select(this._root)
                    .css("min-height", json.minHeight + "px");
            }
            if (json.minWidth) {
                vp.select(this._root)
                    .css("min-width", json.minWidth + "px");
            }
            if (json.maxWidth) {
                vp.select(this._root)
                    .css("max-width", json.maxWidth + "px");
            }
            var rootW = vp.select(this._contentRow);
            //---- create CONTENT ----
            if (json.tabs) {
                this.buildTabs(rootW, json.tabs, json.rightAlignTabs);
            }
            else if (json.rows) {
                //---- rows at top level (no tabs) ----
                this.createTabContent(rootW, null, json.rows, json);
            }
            this.onPinnedDownChanged(); // update listbox classes to match gray/black background
            if (json.isFloating !== undefined) {
                this.isFloating(json.isFloating);
            }
            beachParty.matchIconsToTheme(this._app._themeMgr, this._root);
            this.setFocusToFirstControl();
            setTimeout(function (e) { return _this._isPanelLoading = false; }, 200);
        }
        jsonPanelClass.prototype.showTab = function (tabName, show) {
            vp.select(this._root, "#" + tabName).css("display", (show) ? "" : "none");
        };
        jsonPanelClass.prototype.getTabContentRoot = function (tabName) {
            var tabRootW = vp.select(this.getContentRoot(), "#" + tabName + "Content");
            return tabRootW[0];
        };
        jsonPanelClass.prototype.setFocusToFirstControl = function (tabId) {
            var lowElem = null;
            var lowIndex = null;
            for (var i = 0; i < this._controls.length; i++) {
                var control = this._controls[i];
                //---- if tabId was specified, ensure this control belongs to the same tab ----
                if (tabId && control.tabId != tabId) {
                    continue;
                }
                var strIndex = control.getAttribute("tabIndex");
                if (strIndex && strIndex != "") {
                    var index = +strIndex;
                    if (lowIndex == null || index <= lowIndex) {
                        lowIndex = index;
                        lowElem = control;
                    }
                }
            }
            if (lowElem) {
                setTimeout(function (e) { return lowElem.focus(); }, 50); // delay 100 ms as needed
            }
        };
        jsonPanelClass.prototype.buildTabs = function (parentW, tabs, rightAlignTabs) {
            var _this = this;
            var firstTabButton = null;
            var localeMgr = this._app._localeMgr;
            var panelName = this._panelName;
            this._tabParentElem = parentW[0];
            //---- create container for tab buttons ----
            var tabButtonContainerW = parentW.append("div")
                .addClass("flexAuto flexColumns flexPack tabButtonContainer")
                .css("margin-right", "10px");
            //---- set min-height to prevent this element from shrinking in height when panel is low on vertical space ----
            tabButtonContainerW
                .css("min-height", "24px");
            for (var i = 0; i < tabs.length; i++) {
                var tab = tabs[i];
                //---- add tab button ----
                var id = (tab.id) ? tab.id : ("tab" + i);
                var tabName = tab.tabName;
                this._tabNames.push(tabName);
                var tip = tab.tip;
                //---- LOCALIZE the tab title / tooltip ----
                var tt = localeMgr.getText(panelName + "." + tabName);
                if (tt) {
                    tabName = tt[0];
                    tip = tt[1];
                }
                var tabButtonW = tabButtonContainerW.append("div")
                    .addClass("flexAuto tabButton")
                    .id(id)
                    .text(tabName)
                    .title(tip)
                    .attach("click", function (e) {
                    _this.onTabSelected(e.target);
                });
                tabButtonW.attr("data-tabIndex", i + "");
                if (i == 0) {
                    firstTabButton = tabButtonW[0];
                }
                //---- content is built on-demand (when tab is first opened) ----
                if (tab.loadOnInit) {
                    this.forceTabBuild(i);
                }
            }
            //---- make the first tab active ----
            this.onTabSelected(firstTabButton);
        };
        jsonPanelClass.prototype.getTabIndex = function (tabName) {
            tabName = tabName.toLowerCase();
            var index = -1;
            for (var i = 0; i < this._tabNames.length; i++) {
                var tn = this._tabNames[i].toLowerCase();
                if (tn == tabName) {
                    index = i;
                    break;
                }
            }
            return index;
        };
        jsonPanelClass.prototype.selectTab = function (tabId) {
            if (isNaN(+tabId)) {
                var tabIndex = this.getTabIndex(tabId);
            }
            else {
                tabIndex = tabId;
            }
            tabId = "tab" + tabIndex;
            var tabButton = vp.select(this._root, "#" + tabId)[0];
            this.onTabSelected(tabButton);
        };
        jsonPanelClass.prototype.onTabSelected = function (tabButton) {
            //---- hide current tab content ----
            if (this._currentTabContentElem) {
                vp.select(this._currentTabContentElem)
                    .css("display", "none");
                vp.select(this._currentTabButtonElem)
                    .removeClass("tabButtonOpen");
                this._currentTabContentElem = null;
                this._currentTabButtonElem = null;
                this._currentTabId = null;
            }
            //---- make new tab content visible ----
            var buttonId = tabButton.id;
            var contentId = buttonId + "Content";
            var tabIndex = +tabButton.getAttribute("data-tabIndex");
            //---- this must be set before we build so that _longListByTabs gets set correctly ----
            this._currentTabId = buttonId;
            var tabContentW = this.forceTabBuild(tabIndex);
            if (tabContentW.length) {
                tabContentW
                    .css("display", ""); // makes it default to visible
                var tabButtonW = vp.select(this._root, "#" + buttonId)
                    .addClass("tabButtonOpen");
                this._currentTabContentElem = tabContentW[0];
                this._currentTabButtonElem = tabButtonW[0];
                this._currentTabId = buttonId;
            }
            else {
                //---- revert currentTabId ----
                this._currentTabId = null;
            }
            if (!this._isPanelLoading) {
                //---- LOG this action ----
                var tabName = tabButtonW.text();
                this._app.logAction(beachParty.Gesture.click, "", beachParty.ElementType.button, beachParty.Action.select, beachParty.Target.panelTab, false, { tabName: tabName, tabIndex: tabIndex, panelName: this._panelName });
            }
            this.setFocusToFirstControl(this._currentTabId);
            this.setHeightForIE();
        };
        jsonPanelClass.prototype.forceTabBuild = function (tabIndex) {
            var buttonId = "tab" + tabIndex;
            var contentId = buttonId + "Content";
            var tabContentW = vp.select(this._root, "#" + contentId);
            if (tabContentW.length == 0) {
                //---- build content NOW ----
                var parentW = vp.select(this._tabParentElem);
                var jsonObj = this._jsonObj;
                var tabButtonW = vp.select(this._root, "#" + buttonId);
                var tabObj = jsonObj.tabs[tabIndex];
                this._nameOfTabBeingBuilt = tabObj.tabName;
                tabContentW = this.createTabContent(parentW, contentId, tabObj.rows, tabObj);
                beachParty.matchIconsToTheme(this._app._themeMgr, this._root);
            }
            return tabContentW;
        };
        jsonPanelClass.prototype.addRow = function (tableW) {
            var rowW = tableW.append("tr")
                .addClass("panelRow");
            if (this._rowSpacing) {
                //---- always add a spacer row, to allow us to control space between rows -----
                tableW.append("tr")
                    .addClass("panelRowSpacer")
                    .css("height", this._rowSpacing);
            }
            return rowW;
        };
        jsonPanelClass.prototype.startNewTable = function (parentW, rowSpanPos) {
            var rowSpanTdW = null;
            if (rowSpanPos) {
                //---- create "outer" table under parentW (to hold rowSpan content and normal innerTable) ----
                var outerTableW = parentW.append("table")
                    .css("position", "relative");
                var outerRowW = this.addRow(outerTableW);
                if (rowSpanPos == "left") {
                    rowSpanTdW = outerRowW.append("td")
                        .css("vertical-align", "top")
                        .id("rowSpanHolder");
                }
                var tdMiddle = outerRowW.append("td")
                    .css("vertical-align", "top");
                var normalTableW = tdMiddle
                    .append("table")
                    .css("vertical-align", "top")
                    .css("position", "relative");
                if (rowSpanPos == "right") {
                    rowSpanTdW = outerRowW.append("td")
                        .css("vertical-align", "top")
                        .id("rowSpanHolder");
                }
                if (rowSpanTdW) {
                    //---- add table/row ----
                    var tabW = rowSpanTdW = rowSpanTdW.append("table")
                        .css("position", "relative");
                    rowSpanTdW = this.addRow(tabW);
                }
            }
            else {
                var normalTableW = parentW.append("table")
                    .css("position", "relative");
            }
            return { normalTableW: normalTableW, rowSpanTdW: rowSpanTdW };
        };
        jsonPanelClass.prototype.createTabContent = function (parentW, id, rows, parentObj) {
            var myThis = this; // typescript bug workaround
            var divW = parentW.append("div")
                .addClass("flexGrow flexRows tabContent")
                .css("margin-bottom", "10px")
                .css("overflow-x", "hidden")
                .css("overflow-y", "auto")
                .css("display", "block")
                .css("padding", "0 10px 0 10px")
                .attach("mousedown", function (e) { return myThis.onFocus(e); });
            if (id) {
                //---- tab content - needs padding on top ----
                divW.css("padding-top", "12px");
                divW
                    .css("display", "none")
                    .id(id);
            }
            if (parentObj.marginTop !== undefined) {
                divW.css("margin-top", parentObj.marginTop + "px");
            }
            if (parentObj.marginBottom != undefined) {
                divW.css("margin-bottom", parentObj.marginBottom + "px");
            }
            this._isColFillGrid = parentObj.colFill;
            var grid = new beachParty.gridLayoutClass(divW[0], parentObj.colFill, parentObj.cellPadding);
            var isDevSession = this._app.isInternalSession();
            for (var i = 0; i < rows.length; i++) {
                this._firstRowOfContent = (i == 0);
                var row = rows[i];
                if (!row.isDevMode || isDevSession) {
                    this.buildRow(grid, row);
                }
            }
            return divW;
        };
        jsonPanelClass.prototype.getControlById = function (id) {
            return this._controlsById[id];
        };
        /** we return 'tableW', in case we created a new table that caller should continue using. */
        jsonPanelClass.prototype.buildRow = function (grid, row) {
            var _this = this;
            var rowW = null;
            var startNewRow = ((row.sameCell !== true) && (row.sameRow != true));
            this._promptForCurrentRow = null;
            var holderW = grid.getNextHolder(row.sameCell, startNewRow);
            if (row.fillClient) {
                holderW
                    .attr("rowSpan", "999")
                    .attr("colSpan", "999");
            }
            if (row.newRowIndent) {
                holderW.css("padding-left", "40px");
            }
            else if (row.skipCol) {
                for (var i = 0; i < row.skipCol; i++) {
                    holderW = grid.getNextHolder();
                }
            }
            if (row.emptyRow) {
                grid.setRowHeight(row.height, row.id);
                if (this._isColFillGrid) {
                    holderW = grid.getNextHolder(false, true, row.height, row.id);
                }
            }
            else if (row.hr) {
                this.createHorizontalRule(row.hr, grid, row);
            }
            else if (row.prompt !== undefined) {
                //---- create PROMPT ----
                this.createLabel(row.prompt, grid, row, false);
                this._groupDataName = row.dataName;
            }
            else if (row.longPrompt !== undefined) {
                //---- create LONG PROMPT ----
                this.createLongPrompt(row.longPrompt, grid, row, false);
            }
            else if (row.progress !== undefined) {
                //---- create PROGRESS BAR ----
                this.createProgress(row.progress, grid, row);
            }
            else if (row.image !== undefined) {
                this.createImage(row.image, grid, row);
            }
            else if (row.button !== undefined) {
                this.createButton(row.button, grid, row);
            }
            else if (row.textBox !== undefined) {
                this.createTextBox(row.textBox, grid, row);
                this._groupDataName = row.dataName;
            }
            else if (row.display !== undefined) {
                this.createDisplay(row.display, grid, row);
            }
            else if (row.textArea !== undefined) {
                this.createTextArea(row.textArea, grid, row);
                this._groupDataName = row.dataName;
            }
            else if (row.checkbox !== undefined) {
                this.createCheckbox(row.checkbox, grid, row);
            }
            else if (row.radio !== undefined) {
                this.createRadioButton(row.radio, grid, row);
            }
            else if (row.pane !== undefined) {
                this.createPane(row.pane, grid, row);
            }
            else if (row.numAdjuster !== undefined) {
                this.createNumAdjuster(row.numAdjuster, grid, row);
            }
            else if (row.tourPicker !== undefined) {
                this.createPicker(row.tourPicker, grid, row, function (dataName, ddText, chevronW, e) {
                    _this.showGeneralPicker(row, row.touchPicker, row.dataName, ddText, chevronW, e, null, "createTourPicker");
                });
            }
            else if (row.palettePicker !== undefined) {
                this.createPicker(row.palettePicker, grid, row, function (dataName, ddText, chevronW, e) {
                    _this.showGeneralPicker(row, row.palettePicker, row.dataName, ddText, chevronW, e, null, "createPalettePicker");
                });
            }
            else if (row.scriptPicker !== undefined) {
                this.createPicker(row.scriptPicker, grid, row, function (dataName, ddText, chevronW, e) {
                    _this.showGeneralPicker(row, row.scriptPicker, row.dataName, ddText, chevronW, e, null, "createScriptPicker");
                });
            }
            else if (row.themePicker !== undefined) {
                this.createPicker(row.themePicker, grid, row, function (dataName, ddText, chevronW, e) {
                    _this.showGeneralPicker(row, row.themePicker, row.dataName, ddText, chevronW, e, null, "createThemePicker");
                });
            }
            else if (row.colPicker !== undefined) {
                var noneName = row.noneName || "None";
                this.createPicker(row.colPicker, grid, row, function (dataName, ddText, chevronW, e) {
                    _this.showGeneralPicker(row, row.colPicker, row.dataName, ddText, chevronW, e, true, "createColumnPicker", undefined, noneName);
                }, noneName);
            }
            else if (row.colorPicker !== undefined) {
                this.createColorPicker(row.colorPicker, grid, row);
            }
            else if (row.lineColorPicker !== undefined) {
                this.createPicker(row.colorPicker, grid, row, function (dataName, ddText, chevronW, e) {
                    _this.showGeneralPicker(row, row.colorPicker, row.dataName, ddText, chevronW, e, row.includeShapeColor, "createLineColorPicker");
                });
            }
            else if (row.knownDataPicker !== undefined) {
                this.createPicker(row.knownDataPicker, grid, row, function (dataName, ddText, chevronW, e) {
                    _this.showGeneralPicker(row, row.knownDataPicker, row.dataName, ddText, chevronW, e, null, "createKnownDataPicker");
                });
            }
            else if (row.enumPicker !== undefined) {
                this.createPicker(row.enumPicker, grid, row, function (dataName, ddText, chevronW, e) {
                    _this.showGeneralPicker(row, row.enumPicker, row.dataName, ddText, chevronW, e, row.enumType, "createEnumPicker", function (valueObj) {
                        //---- some enums start with lowercase letter which are capitalized for UI ----
                        if (!row.isEnumUppercase) {
                            valueObj.propValue = beachParty.appUtils.lowerCaseFirstLetter(valueObj.propValue);
                        }
                    });
                });
            }
            else if (row.scrubberPicker !== undefined) {
                this.createPicker(row.scrubberPicker, grid, row, function (dataName, ddText, chevronW, e) {
                    _this.showGeneralPicker(row, row.scribberPicker, row.dataName, ddText, chevronW, e, null, "createScrubberPicker");
                });
            }
            else if (row.shapePicker !== undefined) {
                this.createPicker(row.shapePicker, grid, row, function (dataName, ddText, chevronW, e) {
                    _this.showGeneralPicker(row, row.shapePicker, row.dataName, ddText, chevronW, e, null, "createShapePicker");
                });
            }
            else if (row.colPickerList !== undefined) {
                var listBox = this.createGeneralList(row.colPickerList, grid, row, "createColumnPickerList", "colPickerList");
                //---- when data structure changes (usually a new file), rebuild the listBox ----
                this._app.registerForRemovableChange("ColInfos", this, function (e) {
                    var colItems = _this.callPanelCreator("getMappingCols", row.includeNone);
                    listBox.buildList(colItems, "popupMenuIconColPicker");
                    beachParty.matchIconsToTheme(_this._app._themeMgr, _this._root);
                });
                var settings = this._app._appSettingsMgr;
                //---- when column picker settings change, rebuild the listbox ----
                settings.registerForRemovableChange("colPickerSettings", this, function (e) {
                    var colItems = _this.callPanelCreator("getMappingCols", row.includeNone);
                    listBox.buildList(colItems, "popupMenuIconColPicker");
                    beachParty.matchIconsToTheme(_this._app._themeMgr, _this._root);
                });
            }
            else if (row.knownDataPickerList !== undefined) {
                this.createKnownDataPickerList(row.knownDataPickerList, grid, row, false);
            }
            else if (row.testDataPickerList !== undefined) {
                this.createKnownDataPickerList(row.openDataPickerList, grid, row, true);
            }
            else if (row.openDataPickerList !== undefined) {
                this.createOpenDataPickerList(row.openDataPickerList, grid, row);
            }
            else if (row.customList !== undefined) {
                this.createCustomList(row.customList, grid, row);
            }
            else if (row.control) {
                this.createCustomControl(row.control, grid, row);
            }
            this._lastRowW = rowW;
            var elemW = grid.getCurrentElement(true);
            if (elemW.length) {
                this.applyCommonProperties(grid, row);
            }
        };
        jsonPanelClass.prototype.createCustomControl = function (prompt, grid, row) {
            var _this = this;
            var parts = row.control.split(".");
            var controlCreateFunc = window;
            for (var p = 0; p < parts.length; p++) {
                var part = parts[p];
                controlCreateFunc = controlCreateFunc[part];
            }
            var control = controlCreateFunc(this);
            var dataName = row.dataName;
            var thisObj = this.getDataOwner(dataName);
            if (control.dataParent) {
                control.dataParent(thisObj);
            }
            var holderW = grid.getCurrentHolder();
            var rootElem = control.getRootElem();
            holderW.append(rootElem);
            //---- set initial data ----
            var value = this.getValue(dataName);
            control[dataName](value);
            //---- route data from owner to control ----
            //thisObj.registerForRemovableChange(dataName, this, (e) =>
            this.registerForRemovableChangeInOwner(thisObj, dataName, function (e) {
                var value = _this.getValue(dataName);
                control[dataName](value);
            });
            this._primaryControl = control;
        };
        jsonPanelClass.prototype.createCustomList = function (prompt, grid, row) {
            var _this = this;
            this.createLabel(prompt, grid, row, true);
            var holderW = grid.getNextHolder(row.sameCell);
            //---- create a vertically-scrolling list ----
            var listW = holderW.append("div")
                .css("overflow-y", "auto")
                .css("overflow-x", "hidden")
                .addClass("customList")
                .css("vertical-align", "top");
            //.css("background", "yellow")
            if (row.refreshEvent) {
                var thisObj = this.getDataOwner(row.dataName);
                //thisObj.registerForRemovableChange(row.refreshEvent, this, (e) =>
                this.registerForRemovableChangeInOwner(thisObj, row.refreshEvent, function (e) {
                    _this.rebuildCustomList(listW, row);
                });
            }
            //this.setLongList(listW[0]);
            this.rebuildCustomList(listW, row);
        };
        jsonPanelClass.prototype.rebuildCustomList = function (listW, row) {
            var _this = this;
            listW
                .clear();
            var itemGetter = row.itemGetter;
            for (var i = 0; i < 999; i++) {
                //---- add each item ----
                var thisObj = this.getDataOwner(itemGetter);
                var itemElem = thisObj[itemGetter](i);
                if (!itemElem) {
                    break;
                }
                itemElem._index = i;
                listW.append(itemElem)
                    .attach("click", function (e) {
                    var elem = e.target;
                    while (elem.parentElement && elem._index === undefined) {
                        elem = elem.parentElement;
                    }
                    var value = (elem._value !== undefined) ? elem._value : elem._index;
                    _this.setValue(row.dataName, value);
                });
            }
        };
        jsonPanelClass.prototype.createButton = function (prompt, grid, row) {
            var _this = this;
            var holderW = grid.getCurrentHolder();
            //---- create BUTTON ----
            if (row.img != undefined) {
                //---- an IMAGE-based button ----
                var buttonW = holderW.append("img")
                    .addClass("clickIcon")
                    .attr("src", row.img)
                    .title(row.tip)
                    .attr("tabIndex", "100");
            }
            else {
                var text = row.button;
                var tip = row.tip;
                //---- LOCALIZE the tab title / tooltip ----
                var tt = this._app._localeMgr.getText(this._panelName + "." + text);
                if (tt) {
                    text = tt[0];
                    tip = tt[1];
                }
                //---- a TEXT-based button ----
                var buttonW = holderW.append("span")
                    .addClass("panelButton")
                    .text(text)
                    .title(tip)
                    .attr("tabIndex", "100");
            }
            //---- store on-click properties on each instance ----
            buttonW[0].dataName = row.dataName;
            buttonW[0].acceptButton = row.acceptButton;
            buttonW[0].cancelButton = row.cancelButton;
            if (row.acceptButton) {
                this._acceptDataName = row.dataName;
                buttonW[0].acceptButton = true;
            }
            if (row.cancelButton) {
                buttonW[0].cancelButton = true;
            }
            buttonW.attach("click", function (e) {
                _this.onClickButton(e);
                _this.onUserAction(row, null, beachParty.Gesture.click, beachParty.ElementType.button, row.button);
            });
            buttonW.attach("keydown", function (e) {
                if (e.keyCode == vp.events.keyCodes.enter) {
                    _this.onClickButton(e);
                }
            });
            if (row.defaultButton) {
                this._defaultButton = buttonW[0];
            }
        };
        jsonPanelClass.prototype.createImage = function (src, grid, row) {
            var holderW = grid.getCurrentHolder();
            //---- create IMG ----
            var imgW = holderW.append("img")
                .addClass("panelImage clickIcon")
                .attr("src", src);
            if (row.tip) {
                imgW
                    .title(row.tip);
            }
        };
        jsonPanelClass.prototype.createProgress = function (prompt, grid, row) {
            var tip = row.tip;
            var pgName = "progress" + nextId++;
            if (prompt) {
                this.createLabel(prompt, grid, row, true);
                //---- create PROGRESS BAR ----
                //---- don't use HTML 5 since it uses animation, which we do NOT want ----
                //var progressW = tdW.append("progress")
                //    .attr("value", row.value)
                //    .attr("max", row.max)
                var holderW = grid.getNextHolder(row.sameCell);
            }
            else {
                var holderW = grid.getCurrentHolder();
            }
            var progressW = holderW.append("div")
                .addClass("panelProgressBar");
            var innerW = progressW.append("div")
                .addClass("panelInnerProgressBar")
                .css("width", "0%");
        };
        jsonPanelClass.prototype.onEnterKey = function (isFromKeyboard, fromAcceptButton) {
            /// rules:
            ///   - ENTER key outside of a textarea pressed the "defaultButton: true" BUTTON 
            ///
            ///   - clicking on the "acceptButton: true" button:
            ///         - calls onDataChanged("onAccept")
            ///         - closes dialog
            ///
            ///   - clicking on the "cancelButton: true" button:
            ///         - closes dialog
            var _this = this;
            var focusElem = document.activeElement;
            if (this._defaultButton) {
                if (focusElem.tagName != "TEXTAREA") {
                    //---- commit changes to current field by lose/restore focus ----
                    this.commitEditOnCurrentControl();
                    //---- simulate a click ----
                    setTimeout(function (e) { return _this._defaultButton.click(); }, 100);
                }
            }
            else if (focusElem.tagName == "INPUT") {
                if (!focusElem.ignoreBlur) {
                    //---- commit changes to current field by lose/restore focus ----
                    this.commitEditOnCurrentControl();
                }
            }
        };
        jsonPanelClass.prototype.onAcceptButton = function () {
            this.onDataChanged("onAccept");
            this.scheduleClose();
        };
        jsonPanelClass.prototype.onCancelButton = function () {
            this.onDataChanged("onCancel");
            this.scheduleClose();
        };
        jsonPanelClass.prototype.close = function () {
            //---- unregister with all data owners so that memory used by this panel & class instance are released ----
            var owners = this._ownersWithCallbacks;
            if (owners) {
                for (var i = 0; i < owners.length; i++) {
                    var owner = owners[i];
                    owner.unregisterForChanges(this);
                }
                this._ownersWithCallbacks = null;
            }
            this._app.unregisterForChanges(this, "ColInfos");
            this._app._appSettingsMgr.unregisterForChanges(this, "colPickerSettings");
            _super.prototype.close.call(this);
        };
        jsonPanelClass.prototype.onClickButton = function (e) {
            var elem = e.target;
            //---- call associated method, if specified ----
            if (elem.dataName) {
                this.callMethod(elem.dataName);
            }
            if (elem.acceptButton) {
                //this.onEnterKey(false, true);
                this.onAcceptButton();
            }
            else if (elem.cancelButton) {
                this.onCancelButton();
            }
            if (elem.cancelButton) {
                this.onEscapeKey();
            }
        };
        jsonPanelClass.prototype.layoutFix = function () {
            //---- this "kicks" the HTML layout enough to workaround an IE layout bug ----
            if (this._tabNames.length > 0) {
                var currentTab = +this._currentTabId.substr(3);
                this.selectTab(currentTab);
            }
        };
        jsonPanelClass.prototype.applyCommonProperties = function (grid, row) {
            var _this = this;
            var holderW = grid.getCurrentHolder();
            var elemW = grid.getCurrentElement();
            if (this._promptForCurrentRow) {
                var promptW = vp.select(this._promptForCurrentRow);
            }
            if (row.id) {
                this._controlsById[row.id] = elemW[0];
            }
            this._controls.push(elemW[0]);
            //---- record tab index for this control ----
            elemW[0].tabId = this._currentTabId;
            //---- ROW properties ----
            var rowW = grid.getCurrentRow();
            if (row.rowMarginTop) {
                rowW.css("margin-top", this.getSizeWithUnits(row.rowMarginTop));
            }
            //---- HOLDER properties ----
            if (row.textAlign) {
                //---- set on PARENT ----
                holderW
                    .css("textAlign", row.textAlign)
                    .css("display", "block");
            }
            //---- HOLDER properties ----
            if (row.float) {
                //---- set on PARENT ----
                holderW
                    .css("float", row.float);
            }
            if (row.colSpan !== undefined) {
                holderW.attr("colspan", row.colSpan);
            }
            if (row.rowSpan !== undefined) {
                grid.getCurrentRow()
                    .attr("rowspan", row.rowSpan);
            }
            //---- ELEMENT properties ----
            if (row.fillParent) {
                //elemW.css("display", "block");
                //---- this correctly fills the containing TD ----
                elemW
                    .css("width", "100%")
                    .css("box-sizing", "border-box"); // include border + padding in box
            }
            if (row.readOnly) {
                elemW.attr("readonly", "true");
            }
            if (row.tabIndex !== undefined) {
                elemW[0].tabIndex = row.tabIndex;
            }
            if (row.width) {
                var px = this.getSizeWithUnits(row.width);
                elemW.css("width", px);
            }
            if (row.height) {
                var px = this.getSizeWithUnits(row.height);
                elemW.css("height", px);
            }
            if (row.minWidth) {
                var px = this.getSizeWithUnits(row.minWidth);
                elemW.css("min-width", px);
            }
            if (row.minHeight) {
                var px = this.getSizeWithUnits(row.minHeight);
                elemW.css("min-height", px);
            }
            if (row.marginLeft) {
                var px = this.getSizeWithUnits(row.marginLeft);
                if (promptW) {
                    promptW.css("margin-left", px);
                }
                else {
                    elemW.css("margin-left", px);
                }
            }
            if (row.marginRight) {
                var px = this.getSizeWithUnits(row.marginRight);
                elemW.css("margin-right", px);
            }
            if (row.marginTop) {
                var px = this.getSizeWithUnits(row.marginTop);
                elemW.css("margin-top", px);
            }
            if (row.top) {
                var px = this.getSizeWithUnits(row.top);
                rowW.css("position", "relative");
                elemW
                    .css("position", "relative")
                    .css("top", px);
            }
            if (row.promptTop && promptW && promptW.length) {
                var px = this.getSizeWithUnits(row.promptTop);
                rowW.css("position", "relative");
                promptW
                    .css("position", "relative")
                    .css("top", px);
            }
            if (row.marginBottom) {
                var px = this.getSizeWithUnits(row.marginBottom);
                elemW.css("margin-bottom", px);
            }
            if (row.id) {
                elemW.attr("id", row.id);
            }
            if (vp.utils.isString(row.disabled)) {
                var thisObj = this.getDataOwner(row.disabled);
                // thisObj.registerForChange(row.disabled, (e) =>
                this.registerForRemovableChangeInOwner(thisObj, row.disabled, function (e) {
                    var value = _this.getValue(row.disabled);
                    //---- not sure if this is form control, so disable using both methods ----
                    elemW.attr("data-disabled", value);
                    if (value) {
                        elemW.attr("disabled", "true");
                    }
                    else {
                        elemW[0].removeAttribute("disabled");
                    }
                });
            }
        };
        jsonPanelClass.prototype.getSizeWithUnits = function (value) {
            var numValue = +value;
            if (!isNaN(numValue)) {
                //---- number by itself ----
                value = "" + numValue + "px";
            }
            return value;
        };
        jsonPanelClass.prototype.sendText = function (row, e, text, optArg) {
            var cmdHistory = e.target.cmdHistory;
            if (cmdHistory) {
                cmdHistory.pushCmd(text);
            }
            this.callMethod(row.dataName, text, optArg);
        };
        jsonPanelClass.prototype.createTextBox = function (prompt, grid, row) {
            var _this = this;
            var holderW = grid.getCurrentHolder();
            var value = this.getValue(row.dataName);
            if (value && row.capitalize) {
                value = value.capitalize();
            }
            if (prompt) {
                this.createLabel(prompt, grid, row, true);
                holderW = grid.getNextHolder(row.sameCell);
            }
            //---- create TEXT ----
            var textW = holderW.append("input")
                .addClass("panelText")
                .attr("spellcheck", "false")
                .attr("type", "text")
                .value(value)
                .title(row.tip)
                .css("margin-top", "-7px")
                .attach("focus", function (e) {
                if (!row.noSelectOnFocus) {
                    //---- select all text on focus ----
                    e.target.select();
                }
            })
                .attach("dblclick", function (e) {
                if (row.sampleText && (!e.target.value)) {
                    var text = _this.callMethod(row.sampleText);
                    e.target.value = text;
                }
            });
            if (row.cmdHistory) {
                var cmdHistory = new beachParty.cmdHistoryClass();
                textW[0].cmdHistory = cmdHistory;
            }
            textW[0].ignoreBlur = row.ignoreBlur;
            if (!row.ignoreBlur) {
                textW.attach("blur", function (e) {
                    //---- textbox lost focus - grab its value now ----
                    var newValue = vp.dom.value(e.target);
                    _this.sendText(row, e, newValue);
                });
            }
            textW.attach("keydown", function (e) {
                if (e.keyCode == 13) {
                    //---- enter key ----
                    var newValue = vp.dom.value(e.target);
                    _this.sendText(row, e, newValue);
                }
                else if (e.keyCode == 27) {
                    //---- escape key ----
                    e.target.value = "";
                }
            });
            textW.attach("keyup", function (e) {
                cmdHistory = e.target.cmdHistory;
                if (e.keyCode == 38 && cmdHistory) {
                    var cmd = cmdHistory.getCmd(-1);
                    if (cmd) {
                        e.target.value = cmd;
                    }
                }
                else if (e.keyCode == 40 && cmdHistory) {
                    var cmd = cmdHistory.getCmd(1);
                    if (cmd) {
                        e.target.value = cmd;
                    }
                }
                if (row.incremental) {
                    var newValue = vp.dom.value(e.target);
                    _this.sendText(row, e, newValue, true);
                }
            });
            if (row.placeHolder != undefined) {
                textW.attr("placeHolder", row.placeHolder);
            }
            var thisObj = this.getDataOwner(row.dataName);
            //thisObj.registerForRemovableChange(row.dataName, this, (e) =>
            this.registerForRemovableChangeInOwner(thisObj, row.dataName, function (e) {
                value = _this.getValue(row.dataName);
                if (value && row.capitalize) {
                    value = value.capitalize();
                }
                if (textW.value() != value) {
                    textW.value(value);
                }
            });
        };
        /** create a div that displays readonly text. */
        jsonPanelClass.prototype.createDisplay = function (prompt, grid, row) {
            var _this = this;
            var holderW = grid.getCurrentHolder();
            var value = this.getValue(row.dataName);
            if (value && row.capitalize) {
                value = value.capitalize();
            }
            if (prompt && prompt != "") {
                this.createLabel(prompt, grid, row, true);
                holderW = grid.getNextHolder(row.sameCell);
            }
            //---- create DISPLAY ----
            var textW = holderW.append("div")
                .addClass("panelDisplay")
                .title(row.tip);
            if (row.isHtml) {
                textW.html(value);
            }
            else {
                textW.text(value);
            }
            if (row.leftMargin != undefined) {
                textW.css("margin-left", row.leftMargin + "px");
            }
            var thisObj = this.getDataOwner(row.dataName);
            //thisObj.registerForRemovableChange(row.dataName, this, (e) =>
            this.registerForRemovableChangeInOwner(thisObj, row.dataName, function (e) {
                value = _this.getValue(row.dataName);
                if (value && row.capitalize) {
                    value = value.capitalize();
                }
                if (row.isHtml) {
                    textW.html(value);
                }
                else {
                    textW.text(value);
                }
            });
        };
        jsonPanelClass.prototype.removePromptSuffix = function (prompt) {
            if (prompt) {
                if (prompt.endsWith(":")) {
                    prompt = prompt.substr(0, prompt.length - 1);
                }
                else if (prompt.endsWith(": ")) {
                    prompt = prompt.substr(0, prompt.length - 2);
                }
            }
            return prompt;
        };
        //---- all forms of "panelPrompt" class elements are created here, so we can ensure ----
        //---- the localization code doesn't have to be repeated. ----
        jsonPanelClass.prototype.createPromptElem = function (parentW, prompt, tip, isHtml, elemName) {
            if (elemName === void 0) { elemName = "span"; }
            //---- LOCALIZE the PROMPT title / tooltip ----
            var simplePrompt = this.removePromptSuffix(prompt);
            var tt = this._app._localeMgr.getText(this._panelName + "." + this._nameOfTabBeingBuilt + "." + simplePrompt);
            if (tt) {
                prompt = tt[0];
                tip = tt[1];
            }
            //---- create PROMPT ----
            var spanW = parentW.append(elemName)
                .addClass("panelPrompt")
                .css("display", "inline-block");
            this._promptForCurrentRow = spanW[0];
            if (tip) {
                spanW
                    .title(tip);
            }
            if (isHtml) {
                spanW.html(prompt);
            }
            else {
                spanW.text(prompt);
            }
            return spanW;
        };
        jsonPanelClass.prototype.createLabel = function (prompt, grid, row, isPromptForElem) {
            var holderW = grid.getCurrentHolder();
            var spanW = this.createPromptElem(holderW, prompt, row.tip, row.isHtml);
            if (isPromptForElem) {
                this._promptForCurrentRow = spanW[0];
            }
            //---- make this cell top-aligned ----
            holderW
                .css("vertical-align", "top");
            return spanW;
        };
        jsonPanelClass.prototype.createLongPrompt = function (prompt, grid, row, isPromptForElem) {
            var tip = row.top;
            var isHtml = row.isHtml;
            //---- create label ----
            var holderW = grid.getCurrentHolder();
            var spanW = holderW.append("span")
                .addClass("panelLongPrompt")
                .css("display", "inline-block");
            if (tip) {
                spanW
                    .title(tip);
            }
            if (isHtml) {
                spanW.html(prompt);
            }
            else {
                spanW.text(prompt);
            }
            if (isPromptForElem) {
                this._promptForCurrentRow = spanW[0];
            }
            //---- make this cell top-aligned ----
            holderW
                .css("vertical-align", "top");
            return spanW;
        };
        jsonPanelClass.prototype.createHorizontalRule = function (prompt, grid, row) {
            var tip = row.top;
            var isHtml = row.isHtml;
            //---- create HR ----
            var holderW = grid.getCurrentHolder();
            var spanW = holderW.append("div") // hr")
                .addClass("panelHR")
                .css("display", "block");
            holderW
                .attr("colspan", "99");
            if (row.display == "block") {
                holderW
                    .css("display", "block"); // vs. normal inline-block
            }
            return spanW;
        };
        jsonPanelClass.prototype.createTextArea = function (prompt, grid, row) {
            var _this = this;
            var value = this.getValue(row.dataName);
            if (prompt) {
                this.createLabel(prompt, grid, row, true);
            }
            var holderW = grid.getCurrentHolder();
            //---- create TEXTAREA ----
            var textW = holderW.append("textarea")
                .addClass("panelTextArea")
                .value(value)
                .title(row.tip)
                .attach("focus", function (e) {
                //---- select all text on focus ----
                e.target.select();
            })
                .attach("input", function (e) {
                var newValue = vp.dom.value(e.target);
                _this.callMethod(row.dataName, newValue);
            });
            if (row.placeHolder != undefined) {
                textW.attr("placeholder", row.placeHolder);
            }
            var thisObj = this.getDataOwner(row.dataName);
            //thisObj.registerForRemovableChange(row.dataName, this, (e) =>
            this.registerForRemovableChangeInOwner(thisObj, row.dataName, function (e) {
                value = _this.getValue(row.dataName);
                textW.value(value);
            });
        };
        //createNumAdjuster(prompt: string, rowW: vp.dom.IWrapperOuter, tdW: vp.dom.IWrapperOuter, row: any)
        jsonPanelClass.prototype.createNumAdjuster = function (prompt, grid, row) {
            var _this = this;
            var value = this.getValue(row.dataName);
            var holderW = grid.getCurrentHolder();
            //---- create prompt ----
            var spanW = this.createPromptElem(holderW, prompt, row.tip, row.isHtml);
            holderW = grid.getNextHolder(row.sameCellAsPrompt);
            var parentId = "numAdjuster" + nextId++;
            var initValue = this.getValue(row.dataName);
            var hostInPanel = row.hostInPanel; // default to false
            var numAdjuster = beachParty.createNumAdjusterClass(this._app, holderW[0], "", initValue, row.min, row.max, row.tip, beachParty.AdjusterStyle.bottomInPanel, row.roundValues, row.syncChanges, row.spreadLow, row.sliderWidth, undefined, hostInPanel, row.nameValueMap, row.textWidth);
            numAdjuster.show(true);
            //---- route events FROM DATAOWNER to numAdjuster ----
            var thisObj = this.getDataOwner(row.dataName);
            //thisObj.registerForRemovableChange(row.dataName, this, (name, dataChanger) =>
            this.registerForRemovableChangeInOwner(thisObj, row.dataName, function (name, dataChanger) {
                //---- allow changes from ourselves so that when app ajusts our requested value, we can reflect the adjustment ----
                if (dataChanger._className != "numAdjusterClass") {
                    var value = _this.getValue(row.dataName);
                    numAdjuster.value(value);
                }
            });
            //---- route events FROM NUMADJUSTER to dataOwner ----
            //numAdjuster.registerForRemovableChange("value", this, (e) =>
            this.registerForRemovableChangeInOwner(numAdjuster, "value", function (e) {
                var value = numAdjuster.value();
                //this.setValue(row.dataName, value);
                var thisObj = _this.getDataOwner(row.dataName);
                thisObj.setDataWithChanger(row.dataName, value, numAdjuster);
                _this.onUserAction(row, null, beachParty.Gesture.click, beachParty.ElementType.numAdjuster, prompt);
            });
            if (row.dataCompletedName) {
                //---- route events FROM NUMADJUSTER to dataOwner ----
                //numAdjuster.registerForRemovableChange("valueCompleted", this, (e) =>
                this.registerForRemovableChangeInOwner(numAdjuster, "valueCompleted", function (e) {
                    var value = numAdjuster.value();
                    //this.setValue(row.dataName, value);
                    var thisObj = _this.getDataOwner(row.dataCompletedName);
                    thisObj.setDataWithChanger(row.dataCompletedName, value, numAdjuster);
                    _this.onUserAction(row, null, beachParty.Gesture.click, beachParty.ElementType.numAdjuster, prompt);
                });
            }
        };
        jsonPanelClass.prototype.createColorPicker = function (prompt, grid, row) {
            var _this = this;
            var value = this.getValue(row.dataName);
            var holderW = grid.getCurrentHolder();
            //---- create prompt ----
            var spanW = this.createPromptElem(holderW, prompt, row.tip, row.isHtml);
            holderW = grid.getNextHolder(row.sameCellAsPrompt);
            var parentId = "colorPicker" + nextId++;
            var initValue = this.getValue(row.dataName);
            var textWidth = (row.width) ? row.width : 126;
            var crPicker = new beachParty.colorPickerClass(this._app, holderW[0], initValue, row.tip, textWidth);
            crPicker.show(true);
            //---- route events FROM DATAOWNER to numAdjuster ----
            var thisObj = this.getDataOwner(row.dataName);
            this.registerForRemovableChangeInOwner(thisObj, row.dataName, function (name, dataChanger) {
                //---- allow changes from ourselves so that when app ajusts our requested value, we can reflect the adjustment ----
                if (dataChanger._className != "colorPickerClass") {
                    var value = _this.getValue(row.dataName);
                    crPicker.value(value);
                }
            });
            //---- route events FROM NUMADJUSTER to dataOwner ----
            this.registerForRemovableChangeInOwner(crPicker, "value", function (e) {
                var value = crPicker.value();
                var thisObj = _this.getDataOwner(row.dataName);
                thisObj.setDataWithChanger(row.dataName, value, crPicker);
                _this.onUserAction(row, null, beachParty.Gesture.click, beachParty.ElementType.numAdjuster, prompt);
            });
        };
        jsonPanelClass.prototype.createPicker = function (prompt, grid, row, onOpenCallback, noneName) {
            var _this = this;
            var holderW = grid.getCurrentHolder();
            var value = this.getValue(row.dataName);
            if (prompt) {
                //----create prompt for dropdown ----
                var ddPromptW = this.createPromptElem(holderW, prompt, row.tip, row.isHtml);
                //var ddPromptW = holderW.append("span")
                //    .addClass("panelPrompt")
                //    .title(row.tip)
                //    .text(prompt)
                ddPromptW
                    .css("margin-right", "4px");
                holderW = grid.getNextHolder(row.sameCell);
            }
            //---- create DROPDOWN BUTTON to hold text and chevron ----
            var ddButton = holderW.append("span")
                .addClass("panelButton")
                .title(row.tip)
                .css("white-space", "nowrap")
                .css("padding-bottom", "4px")
                .id("ddButton" + jsonPanelClass.nextPickerButtonId++);
            //---- right align contents within our span ----
            ddButton.css("text-align", "right");
            // ----create TEXT part of button ----
            var ddText = ddButton.append("span")
                .addClass("panelButtonText")
                .css("vertical-align", "middle")
                .css("text-align", "left");
            if (row.width != undefined) {
            }
            //---- to workaround issue of mouse "dead zones" around img, try embedding it inside a in-line block span ----
            var divW = ddButton.append("span")
                .addClass("panelButtonChevron")
                .css("display", "inline-block");
            //---- add dropdown CHEVRON icon ----
            var chevronW = divW.append("img")
                .addClass("clickIcon")
                .css("margin-left", "4px")
                .css("margin-bottom", "2px")
                .css("vertical-align", "bottom")
                .attach("dragstart", function (e) {
                //---- prevent drag of icon ----
                e.preventDefault();
            });
            //---- todo: what about undocked? ----
            beachParty.setIconName(this._app._themeMgr, chevronW[0], beachParty.fnChevron, "dockedPanel", true);
            ddButton
                .attach("click", function (e) {
                if (ddButton.attr("data-disabled") != "true") {
                    beachParty.chartUtils.callPanelOpen(e, function (ee) {
                        onOpenCallback(row.dataName, ddText, chevronW, e);
                    });
                }
            });
            //---- set initial value ----
            var value = this.getValue(row.dataName) || noneName;
            if (row.enumPicker !== undefined) {
                //---- change all enum values to start with a capital letter ----
                value = beachParty.chartUtils.capitalizeFirstLetter(value);
            }
            ddText.text(value);
            //---- listen to associated property changes & update HTML ----
            var thisObj = this.getDataOwner(row.dataName);
            //thisObj.registerForRemovableChange(row.dataName, this, (e) =>
            this.registerForRemovableChangeInOwner(thisObj, row.dataName, function (e) {
                var value = _this.getValue(row.dataName) || noneName;
                if (row.enumPicker !== undefined) {
                    //---- change all enum values to start with a capital letter ----
                    value = beachParty.chartUtils.capitalizeFirstLetter(value);
                }
                ddText.text(value);
            });
            //---- is this a column picker dropdown? ----
            if (row.mapToDefaultCol) {
                //---- when data structure changes (usually a new file), set value to default column ----
                this._app.registerForRemovableChange("ColInfos", this, function (e) {
                    var value = _this._app.getDefaultCol();
                    ddText.text(value);
                    _this.setValue(row.dataName, value);
                });
            }
            if (row.tabIndex !== undefined) {
                ddButton[0].tabIndex = row.tabIndex;
            }
        };
        jsonPanelClass.prototype.showGeneralPicker = function (row, prompt, propName, ddTextW, chevronW, e, p2, creatorFuncName, valueCallback, noneName) {
            var _this = this;
            var parentElem = ddTextW[0].parentElement;
            var openerIds = parentElem.id;
            var picker = this.callPanelCreator(creatorFuncName, openerIds, p2, function (mid) {
                var value = (mid.text !== undefined) ? mid.text : mid;
                var valueObj = { propValue: value, textValue: value };
                if (valueCallback) {
                    valueCallback(valueObj);
                }
                ddTextW.text(valueObj.textValue);
                _this.setValue(propName, valueObj.propValue);
                _this.onUserAction(row, null, beachParty.Gesture.select, beachParty.ElementType.picklist, prompt);
            }, this._root, noneName);
            if (!this._isFloating) {
                picker.setDockedTheme(true);
            }
            this.openPicker(picker, chevronW);
        };
        jsonPanelClass.prototype.createOpenDataPickerList = function (prompt, grid, row) {
            var _this = this;
            var holderW = grid.getCurrentHolder();
            //---- growable lists are added as a peer to the outer control table -----
            holderW = this.getParentForListOutsideOfGrid(grid);
            var listBox = this.callPanelCreator("createOpenDataPickerList", holderW[0], true, function (mid) {
                var text = (mid.text) ? mid.text : mid;
                _this.setValue(row.dataName, text);
                _this.onUserAction(row, null, beachParty.Gesture.select, beachParty.ElementType.picklist, prompt);
            });
            return listBox;
        };
        jsonPanelClass.prototype.createKnownDataPickerList = function (propName, grid, row, useTestData) {
            var _this = this;
            var holderW = grid.getCurrentHolder();
            //---- growable lists are added as a peer to the outer control table -----
            holderW = this.getParentForListOutsideOfGrid(grid);
            var listBox = this.callPanelCreator("createKnownDataPickerList", holderW[0], true, function (mid) {
                //ddTextW.text(mid.text)
                _this.setValue(row.dataName, mid.text);
                _this.onUserAction(row, null, beachParty.Gesture.select, beachParty.ElementType.picklist, propName);
            }, useTestData);
            return listBox;
        };
        jsonPanelClass.prototype.getParentForListOutsideOfGrid = function (grid) {
            grid.deleteCurrentRowIfEmpty();
            var parent = grid.getParent();
            var holderW = vp.select(parent);
            //---- TODO: start a new table in case controls are added after list ----
            return holderW;
        };
        jsonPanelClass.prototype.createGeneralList = function (prompt, grid, row, creatorFuncName, id) {
            var _this = this;
            var holderW = grid.getCurrentHolder();
            if (prompt) {
                //----create prompt for list ----
                var ddPromptW = this.createPromptElem(holderW, prompt, row.tip, row.isHtml);
                ddPromptW
                    .css("vertical-align", "right")
                    .css("margin-right", "4px");
                var holderW = grid.getNextHolder(row.sameCellAsPrompt);
            }
            //---- growable lists are added as a peer to the outer control table -----
            holderW = this.getParentForListOutsideOfGrid(grid);
            var listBox = this.callPanelCreator(creatorFuncName, holderW[0], row.includeNone, function (mid) {
                //---- process each item in the list ----
                //ddTextW.text(mid.text)
                _this.setValue(row.dataName, mid.text);
                _this.onUserAction(row, null, beachParty.Gesture.select, beachParty.ElementType.picklist, prompt);
            });
            //---- listen to associated property changes & update HTML ----
            var thisObj = this.getDataOwner(row.dataName);
            //thisObj.registerForRemovableChange(row.dataName, this, (e) =>
            this.registerForRemovableChangeInOwner(thisObj, row.dataName, function (e) {
                var value = _this.getValue(row.dataName);
                listBox.selectedValue(value);
            });
            var listBoxW = vp.select(listBox._root)
                .id(id)
                .addClass("flexGrow");
            //.css("border", "1px solid red")
            //---- Edge bug WORKAROUND ----
            if (vp.utils.isEdge) {
                listBoxW.css("margin-top", "25px");
            }
            //---- set initial value ----
            var value = this.getValue(row.dataName);
            listBox.selectedValue(value);
            return listBox;
        };
        jsonPanelClass.prototype.callPanelCreator = function (creatorMethod, parent, p2, p3, p4, p5, p6, p7) {
            return this._app[creatorMethod](parent, p2, p3, p4, p5, p6, p7);
        };
        jsonPanelClass.prototype.openPicker = function (picker, chevronW) {
            if (picker) {
                var rcChevron = chevronW.getBounds(false);
                var pickerElem = picker.getRootElem();
                var rcPicker = vp.select(pickerElem).getBounds(false);
                //---- right align picker with right of text/chevon box ----
                var x = rcChevron.right + 4 - rcPicker.width;
                //---- ENUM PICKERS seem to need this adjustment - does this break anything else? ----
                picker.openWithoutOverlap(x + 2, rcChevron.bottom + 5, null, null);
            }
        };
        jsonPanelClass.prototype.createCheckbox = function (prompt, grid, row) {
            var _this = this;
            var cbName = "checkbox" + nextId++;
            var holderW = grid.getCurrentHolder();
            holderW
                .css("white-space", "nowrap");
            var divW = holderW.append("div")
                .addClass("checkboxAssembly")
                .css("cursor", "pointer");
            if (row.id) {
                divW.id(row.id);
            }
            //---- create CHECKBOX ----
            var cbW = divW.append("input")
                .addClass("panelCheckbox")
                .attr("type", "checkbox")
                .attr("id", cbName)
                .css("cursor", "pointer")
                .title(row.tip)
                .attach("dblclick", function (e) {
                e.preventDefault();
                cbW[0].click();
            });
            //---- the checkbox TEXT ----
            var labW = this.createPromptElem(divW, prompt, row.tip, row.isHtml, "label");
            labW
                .attr("for", cbName) // relays click to element with id=cbName
                .css("position", "relative")
                .css("cursor", "pointer")
                .css("top", "-2px")
                .css("margin-left", "2px")
                .attach("dblclick", function (e) {
                e.preventDefault();
                labW[0].click();
                _this.onUserAction(row, null, beachParty.Gesture.click, beachParty.ElementType.checkbox, prompt);
            });
            //---- for the purposes of layout, cbW is our prompt ----
            this._promptForCurrentRow = cbW[0];
            cbW.attach("click", function (e) {
                var value = cbW[0].checked;
                _this.setValue(row.dataName, value);
                _this.onUserAction(row, null, beachParty.Gesture.click, beachParty.ElementType.checkbox, prompt);
            });
            var value = this.getValue(row.dataName);
            if (value) {
                cbW[0].checked = true;
            }
            //---- listen to associated property changes & update HTML ----
            var thisObj = this.getDataOwner(row.dataName);
            //thisObj.registerForRemovableChange(row.dataName, this, (e) =>
            this.registerForRemovableChangeInOwner(thisObj, row.dataName, function (e) {
                var value = _this.getValue(row.dataName);
                if (value) {
                    cbW[0].checked = true;
                }
                else {
                    var elem = cbW[0];
                    cbW[0].checked = false;
                }
            });
            if (row.topMargin !== undefined) {
                cbW.css("margin-top", row.topMargin + "px");
            }
        };
        jsonPanelClass.prototype.registerForRemovableChangeInOwner = function (thisObj, dataName, callback) {
            thisObj.registerForRemovableChange(dataName, this, callback);
            this._ownersWithCallbacks.push(thisObj);
        };
        jsonPanelClass.prototype.createRadioButton = function (prompt, grid, row) {
            var _this = this;
            var rbName = "radio" + nextId++;
            if (!row.dataName) {
                row.dataName = this._groupDataName;
            }
            var holderW = grid.getCurrentHolder();
            var assemblyW = holderW.append("div")
                .addClass("radioAssembly");
            //---- create RADIOBUTTON ----
            var cb = assemblyW.append("input")
                .addClass("panelRadio")
                .css("cursor", "pointer")
                .attr("type", "radio")
                .attr("id", rbName)
                .attr("name", row.dataName) // for grouping radio buttons together
                .title(row.tip)
                .attach("dblclick", function (e) {
                e.preventDefault();
                cb[0].click();
            });
            if (row.checked) {
                cb[0].checked = true;
            }
            if (row.leftMargin != undefined) {
                cb.css("margin-left", row.leftMargin + "px");
            }
            //var lab = holderW.append("label")
            //    .addClass("panelPrompt")
            var labW = this.createPromptElem(assemblyW, row.radio, row.tip, row.isHtml, "label");
            labW
                .attr("for", rbName) // relays click to element with id=cbName
                .css("position", "relative")
                .css("top", "-3px")
                .css("cursor", "pointer")
                .attach("dblclick", function (e) {
                e.preventDefault();
                labW[0].click();
                _this.onUserAction(row, null, beachParty.Gesture.click, beachParty.ElementType.radioButton, prompt);
            });
            //---- on CLICK, update OWNER property ----
            cb.attach("click", function (e) {
                var value = cb[0].checked;
                if (value) {
                    _this.setValue(row.dataName, row.value);
                    _this.onUserAction(row, null, beachParty.Gesture.click, beachParty.ElementType.radioButton, prompt);
                }
            });
            //---- set INITIAL VALUE in element ----
            this.updateRadio(row.dataName, row.value, cb[0]);
            //---- list to associated property changes & update HTML ----
            var thisObj = this.getDataOwner(row.dataName);
            //thisObj.registerForRemovableChange(row.dataName, this, (e) =>
            this.registerForRemovableChangeInOwner(thisObj, row.dataName, function (e) {
                _this.updateRadio(row.dataName, row.value, cb[0]);
            });
        };
        jsonPanelClass.prototype.createPane = function (prompt, grid, row) {
            var _this = this;
            //---- create a labeled pane with a button that toggles the pane open / closed ----
            var holderW = grid.getCurrentHolder();
            //---- make parent display=block to fill the current table ----
            holderW.css("display", "block");
            //---- create DIV to hold stuff ----
            var paneRootW = holderW.append("div")
                .addClass("paneDiv")
                .css("colSpan", "99");
            //---- create PROMPT and BUTTON row ----
            var rowW = paneRootW.append("div")
                .addClass("paneTopRow")
                .title(row.tip)
                .css("position", "relative");
            //var promptW = rowW.append("span")
            //    .text(prompt)
            //    .addClass("panelPrompt panePrompt")
            var promptW = this.createPromptElem(rowW, prompt, row.tip, row.isHtml);
            if (!row.hideToggle) {
                var imgW = rowW.append("img")
                    .addClass("clickIcon paneToggleButton")
                    .css("margin-left", "10px")
                    .css("position", "relative")
                    .css("top", "4px")
                    .attach("dragstart", function (e) {
                    //---- prevent drag of icon ----
                    e.preventDefault();
                });
                beachParty.setIconName(this._app._themeMgr, imgW[0], beachParty.fnOpenPane, null, true);
            }
            var grid = new beachParty.gridLayoutClass(paneRootW[0], row.colFill, row.cellPadding);
            var isDevSession = this._app.isInternalSession();
            var tableW = grid.getCurrentTable();
            tableW.css("textAlign", "left"); // in case parent prompt was centered
            if (!row.hideToggle) {
                tableW.css("display", "none"); // initially hidden
                imgW.attach("click", function (e) {
                    var imgElem = e.target;
                    if (imgElem.src.contains("Down")) {
                        tableW.css("display", "");
                        beachParty.setIconName(_this._app._themeMgr, imgW[0], beachParty.fnClosePane, null, true);
                    }
                    else {
                        tableW.css("display", "none");
                        beachParty.setIconName(_this._app._themeMgr, imgW[0], beachParty.fnOpenPane, null, true);
                    }
                });
            }
            if (row.rows) {
                var rows = row.rows;
                for (var i = 0; i < rows.length; i++) {
                    this._firstRowOfContent = false;
                    var row = rows[i];
                    if (!row.isDevMode || isDevSession) {
                        this.buildRow(grid, row);
                    }
                }
            }
        };
        jsonPanelClass.prototype.updateRadio = function (dataName, myValue, rbElem) {
            var value = this.getValue(dataName);
            if (value == myValue) {
                rbElem.checked = true;
            }
        };
        jsonPanelClass.nextPickerButtonId = 1;
        return jsonPanelClass;
    }(beachParty.basePanelClass));
    beachParty.jsonPanelClass = jsonPanelClass;
    function buildJsonPanel(app, openerIds, dataOwner, panelName, openPanel, left, top, right, bottom, toggleOpen, isCol1Indent, isFlexPanel, uiOpenName) {
        //var panel : jsonPanelClass = null;
        if (toggleOpen === void 0) { toggleOpen = true; }
        if (isCol1Indent === void 0) { isCol1Indent = true; }
        if (isFlexPanel === void 0) { isFlexPanel = true; }
        //var panelW = vp.select("#" + panelName + "Panel");
        var w = window;
        var desc = w.panelDescriptions[panelName];
        var title = desc.title;
        var tip = desc.tip;
        var localeName = title;
        //---- LOCALIZE the panel title / tooltip ----
        var tt = app._localeMgr.getText(localeName + ".Panel");
        if (tt) {
            title = tt[0];
            tip = tt[1];
        }
        var panel = new jsonPanelClass(app, openerIds, dataOwner, panelName, desc, undefined, isCol1Indent, title, tip, localeName, isFlexPanel, uiOpenName);
        var rc = vp.dom.getBounds(panel.getRootElem(), false);
        if (left === undefined && right === undefined) {
            //---- center horizontally ----
            left = window.innerWidth / 2 - rc.width / 2;
        }
        if (top === undefined && bottom === undefined) {
            //---- center vertically ----
            top = window.innerHeight / 2 - rc.height / 2;
        }
        if (openPanel) {
            panel.open(left, top, right, bottom);
        }
        return panel;
    }
    beachParty.buildJsonPanel = buildJsonPanel;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    baseJsonControl.ts - base class for controls that use jsonPanelClass to build their controls.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var baseJsonControlClass = (function (_super) {
        __extends(baseJsonControlClass, _super);
        function baseJsonControlClass() {
            _super.apply(this, arguments);
        }
        baseJsonControlClass.prototype.getRootElem = function () {
            return this._jsonPanel.getRootElem();
        };
        baseJsonControlClass.prototype.getButtonRect = function (buttonId) {
            var rc = null;
            var ids = buttonId.split(" ");
            for (var i = 0; i < ids.length; i++) {
                var id = ids[i];
                var buttonW = vp.select("#" + id);
                if (buttonW.length) {
                    rc = buttonW.getBounds(false);
                    break;
                }
            }
            return rc;
        };
        baseJsonControlClass.prototype.showAt = function (left, top, right, bottom, fadeInOpts) {
            this._jsonPanel.showAt(left, top, right, bottom, fadeInOpts);
        };
        baseJsonControlClass.prototype.show = function (value) {
            this._jsonPanel.show(value);
        };
        baseJsonControlClass.prototype.hide = function () {
            this._jsonPanel.hide();
        };
        baseJsonControlClass.prototype.remove = function () {
            this._jsonPanel.remove();
        };
        baseJsonControlClass.prototype.getJsonPanel = function () {
            return this._jsonPanel;
        };
        //isFloating(value?: boolean)
        //{
        //    return this._jsonPanel.isFloating.apply(this._jsonPanel, arguments);
        //}
        baseJsonControlClass.prototype.close = function () {
            this._jsonPanel.close();
        };
        return baseJsonControlClass;
    }(beachParty.dataChangerClass));
    beachParty.baseJsonControlClass = baseJsonControlClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    numAdjustDial.ts - gauge-type control to allow numeric values to be adjusted thru rotational dragging.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var gaugeCircleRadius = 50;
    var numAdjustDial = (function (_super) {
        __extends(numAdjustDial, _super);
        /** if "syncChanges" is true, a dataChanged event on "value" is issued whenever the numAdjuster value is changed.  if false,
        event is only triggered on mouse up. */
        function numAdjustDial(rootName, name, initialValue, minValue, maxValue, tooltip, style, roundValues, syncChanges, spreadLow) {
            var _this = this;
            _super.call(this);
            this._className = "numAdjusterClass";
            this._valueAtStartOfDrag = 0;
            this._isEndOfDrag = false;
            this._isDragging = false;
            this._ptDown = null;
            this._isMouseDown = false;
            this._delayTimer = null; // used to throttle the large amount of mouse move messages
            //----- center of circles ----
            this._xCircle = 0;
            this._yCircle = 0;
            this._angleAdj = 0;
            this._numValue = initialValue;
            this._minValue = minValue;
            this._maxValue = maxValue;
            this._tooltip = tooltip;
            this._style = style;
            this._name = name;
            this._roundValues = roundValues;
            this._syncChanges = syncChanges;
            this._spreadLow = spreadLow;
            //---- adjust ROOT ----
            var root = vp.select("#" + rootName)
                .addClass("numAdjuster")
                .title(tooltip)
                .css("position", "relative")
                .css("width", "40px")
                .attach("click", function (e) {
                _this.onClickInCircle(e);
            });
            this._root = root[0];
            this._root.control = this;
            this.buildControlParts(root);
            this.hookEvents();
            //---- initialize the value text ----
            this.updateValueText();
            //---- make hidden initially ----
            this.show(false);
        }
        numAdjustDial.prototype.minValue = function (value) {
            if (arguments.length == 0) {
                return this._minValue;
            }
            this._minValue = value;
            this.onDataChanged("minValue");
        };
        numAdjustDial.prototype.maxValue = function (value) {
            if (arguments.length == 0) {
                return this._maxValue;
            }
            this._maxValue = value;
            this.onDataChanged("maxValue");
        };
        numAdjustDial.prototype.getRoot = function () {
            return this._root;
        };
        numAdjustDial.prototype.value = function (value, notifyChanged) {
            if (arguments.length === 0) {
                return this._numValue;
            }
            //vp.utils.debug("numAdjuster.value(): value=" + value + ", _value=" + this._numValue);
            if (value != this._numValue) {
                value = Math.max(this._minValue, Math.min(this._maxValue, value));
                this._numValue = value;
                this.updateValueText();
                if (notifyChanged) {
                    this.onDataChanged("value");
                }
            }
        };
        numAdjustDial.prototype.buildControlParts = function (root) {
            /// valueX, valueY is where the value text should be placed
            /// ptX, ptY is an offset for the center of the circle 
            /// nameY is where the optional name label for the adjuster should be placed 
            var topData = { valueX: 7, valueY: 13, minX: 32, minY: 28, maxX: 32, maxY: 9, ptX: 19, ptY: 0, angle: -270, nameY: -4 };
            //var rightData = { valueX: 7, valueY: 15, minX: 32, minY: 28, maxX: 32, maxY: 9, ptX: 32, ptY: 20, angle: -0, nameY: -4 };
            var rightData = { valueX: 7, valueY: 21, minX: 32, minY: 28, maxX: 32, maxY: 9, ptX: 32, ptY: 20, angle: -0, nameY: -4 };
            //var bottomData = { valueX: 7, valueY: 13, minX: 32, minY: 28, maxX: 32, maxY: 9, ptX: 19, ptY: 31, angle: -90, nameY: -4 };
            var topInPanelData = { valueX: 7, valueY: -11, minX: 32, minY: 28, maxX: 32, maxY: 9, ptX: 19, ptY: 0, angle: -270, nameY: -4 };
            //---- primary styles for BeachParty ----
            var leftData = { valueX: 7, valueY: 13, minX: 32, minY: 28, maxX: 32, maxY: 9, ptX: 0, ptY: 20, angle: -180, nameY: -2 };
            var bottomInPanelData = { valueX: 7, valueY: 13, minX: 32, minY: 28, maxX: 32, maxY: 9, ptX: 19, ptY: 31, angle: -90, nameY: -8 };
            var bottomData = { valueX: 8, valueY: 14, minX: 32, minY: 28, maxX: 32, maxY: 9, ptX: 19, ptY: 31, angle: -90, nameY: -8 };
            var inPanel = false;
            var fnImg = null;
            var data = null;
            if (this._style == AdjusterStyle.left) {
                data = leftData;
                fnImg = beachParty.fnAdjustDialLeft;
            }
            else if (this._style == AdjusterStyle.top) {
                data = topData;
                fnImg = beachParty.fnAdjustDialTop;
            }
            else if (this._style == AdjusterStyle.right) {
                data = rightData;
                fnImg = beachParty.fnAdjustDialRight;
            }
            else if (this._style == AdjusterStyle.bottom) {
                data = bottomData;
                fnImg = beachParty.fnAdjustDialBottom;
            }
            else if (this._style == AdjusterStyle.bottomInPanel) {
                data = bottomInPanelData;
                fnImg = beachParty.fnAdjustDialBottom;
                inPanel = true;
            }
            else if (this._style == AdjusterStyle.topInPanel) {
                data = topInPanelData;
                fnImg = beachParty.fnAdjustDialTop;
                inPanel = true;
            }
            //---- add SEMI-CIRCLE image ----
            var styleForImg = this._style;
            if (this._style == AdjusterStyle.bottomInPanel) {
                styleForImg = AdjusterStyle.bottom;
            }
            else if (this._style == AdjusterStyle.topInPanel) {
                styleForImg = AdjusterStyle.top;
            }
            var imgW = root.append("img")
                .addClass("numAdjusterImg")
                .attr("src", fnImg)
                .css("width", "40px")
                .attach("dragstart", function (e) {
                //---- prevent drag of icon ----
                e.preventDefault();
            });
            //---- add NAME ----
            var nameW = root.append("span")
                .text(this._name)
                .addClass("numAdjusterName")
                .css("position", "relative")
                .css("top", data.nameY + "px") // "-4px")
                .css("width", "40px")
                .css("text-align", "center");
            //---- add VALUE TEXT ----
            var valueW = root.append("span")
                .addClass("numAdjusterValue")
                .text(this._numValue + "")
                .css("position", "absolute")
                .css("left", data.valueX + "px")
                .css("top", data.valueY + "px");
            if (this._style == AdjusterStyle.topInPanel || this._style == AdjusterStyle.bottomInPanel) {
                valueW
                    .addClass("numAdjusterInPanel");
            }
            this._xCircle = data.ptX;
            this._yCircle = data.ptY;
            this._angleAdj = data.angle;
            //---- add DRAG LINE ----
            var lineW = vp.select(document.body).append("span")
                .addClass("numAdjusterLine")
                .css("position", "absolute");
            this._imgCircle = imgW[0];
            this._nameText = nameW[0];
            this._valueText = valueW[0];
            this._draggingLine = lineW[0];
        };
        numAdjustDial.prototype.show = function (value) {
            //---- use "inline-block" as workaround for IE and Chrome layout issues ----
            vp.select(this._root).css("display", (value) ? "inline-block" : "none");
        };
        numAdjustDial.prototype.isShowing = function () {
            return (vp.select(this._root).css("display") != "none");
        };
        /** if user clicked on left side of circle, decrement count by 1; otherwise, increment count by 1. */
        numAdjustDial.prototype.onClickInCircle = function (e) {
            var rc = vp.dom.getBounds(this._imgCircle, false);
            var w = rc.width;
            var pt = vp.events.mousePosition(e, this._imgCircle);
            if (pt.x >= 0 && pt.x < w) {
                var delta = (pt.x < w / 2) ? -1 : 1;
                this.value(this._numValue + delta, true);
            }
        };
        numAdjustDial.prototype.positionLine = function (p1, p2) {
            var rc = vp.dom.getBounds(this._imgCircle);
            var xdiff = p2.x - p1.x;
            var ydiff = p2.y - p1.y;
            var width = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
            var height = 1;
            var cx = (p1.x + p2.x) / 2;
            var cy = (p1.y + p2.y) / 2;
            var left = rc.left + cx - width / 2;
            var top = rc.top + cy - height / 2;
            var theta = Math.atan2(p1.y - p2.y, p1.x - p2.x);
            var angle = theta * 180 / Math.PI;
            var rotateStr = "rotate(" + angle + "deg)";
            vp.select(this._draggingLine)
                .css("width", width + "px")
                .css("left", left + "px")
                .css("top", top + "px")
                .transform(rotateStr);
        };
        numAdjustDial.prototype.updateValueText = function () {
            var str = vp.formatters.comma(this._numValue);
            vp.dom.text(this._valueText, str);
            //vp.utils.debug("numAdjuster.updateValueText: str=" + str);
        };
        numAdjustDial.prototype.onMouseDown = function (e) {
            var _this = this;
            //---- use mouse to move our dial ----
            var isInGauge = true;
            this._isMouseDown = true;
            if (isInGauge) {
                this._ptDown = vp.events.mousePosition(e);
                vp.select(this._valueText)
                    .addClass("numAdjusterActiveValue");
                //---- TODO: replace "chart1" with name of chart that owns this dataTip ----
                vp.events.setCaptureWindow(function (e) { return _this.onMouseMove(e); }, function (e) { return _this.onMouseUp(e); }, ["chart1"]);
            }
            vp.events.cancelEventDefault(e);
            e.stopPropagation();
        };
        numAdjustDial.prototype.onMouseMove = function (e) {
            //vp.utils.debug("numAdjuster.onMouseMove: delayTimer=" + this._delayTimer);
            if (!this._delayTimer) {
                //---- mousePosition of "group" is unreliable, so we use "outCircle" with small adjustment as needed ----
                var pt = vp.events.mousePosition(e, this._imgCircle);
                if (this._isMouseDown && (!this._isDragging)) {
                    //---- don't start the value adjusting until user has dragged at least 3 pixels ----
                    var xd = Math.abs(pt.x - this._ptDown.x);
                    var yd = Math.abs(pt.y - this._ptDown.y);
                    if (Math.max(xd, yd) >= 3) {
                        this._isDragging = true;
                        this._valueAtStartOfDrag = this._numValue;
                    }
                }
                if (this._isDragging) {
                    var xDiff = pt.x - this._xCircle;
                    var yDiff = pt.y - this._yCircle;
                    this.positionLine(pt, vp.geom.createPoint2(this._xCircle, this._yCircle));
                    vp.select(this._draggingLine)
                        .css("display", "block");
                    //---- calculate angle from pt to center of circle ----
                    var theta = Math.atan2(yDiff, xDiff);
                    var angle = vp.utils.toDegrees(theta);
                    angle += this._angleAdj;
                    //angle -= 90;        // angle will=0 when mouse is at direct bottom (in middle of gap) 
                    //angle += 90;        // adjust for style=left
                    if (angle < 0) {
                        angle += 360;
                    }
                    var inDeadZone = (angle < 90 || angle > 270);
                    angle = vp.data.clamp(angle, 90, 270); // valid values (not in gap) 
                    //---- convert angle to percent ----
                    var percent = vp.data.mapValue(angle, 90, 270, 0, 1);
                    this.setValueFromPercent(percent, inDeadZone);
                }
                //vp.utils.debug("numAdjuster mousemove: percent: " + percent + ", value=" + this._currentValue + ", angle=" + angle + ", x=" + pt.x + ", y=" + pt.y);
                this.setNextMsgDelay();
            }
            vp.events.cancelEventDefault(e);
            e.stopPropagation();
        };
        numAdjustDial.prototype.setValueFromPercent = function (percent, inDeadZone) {
            var range = this._maxValue - this._minValue;
            if (this._spreadLow) {
                var goodRange = (range < 10) ? 10 * range : range;
                var maxExponent = Math.log(goodRange) / Math.log(2); // take log base 2 of percent
                var exponent = vp.data.mapValue(percent, 0, 1, 1, maxExponent);
                var result = Math.pow(2, exponent);
                percent = vp.data.mapValue(result, 2, goodRange, 0, 1);
            }
            var value = this._minValue + percent * range;
            if (this._roundValues) {
                value = Math.round(value);
            }
            //if (false)       // inDeadZone)
            //{
            //    //---- in dead zone, value is restored to "before drag" value ----
            //    value = this._valueAtStartOfDrag;
            //}
            //else
            {
                value = vp.data.clamp(value, this._minValue, this._maxValue);
            }
            this.value(value, this._syncChanges);
        };
        numAdjustDial.prototype.setNextMsgDelay = function () {
            var _this = this;
            var delay = (this._syncChanges) ? 30 : 15;
            this._delayTimer = setTimeout(function (e) {
                _this._delayTimer = null;
            }, delay);
        };
        numAdjustDial.prototype.onMouseUp = function (e) {
            this._isDragging = false;
            this._isMouseDown = true;
            vp.events.releaseCaptureWindow();
            vp.events.cancelEventDefault(e);
            vp.select(this._valueText)
                .removeClass("numAdjusterActiveValue");
            vp.select(this._draggingLine)
                .css("display", "none");
            this.onDataChanged("value");
            this.onDataChanged("valueMouseUp");
            //vp.utils.debug("numAdjuster.onMouseUp: onDataChanges('value') called - this._value=" + this._numValue);
        };
        numAdjustDial.prototype.hookEvents = function () {
            var _this = this;
            var root = this._root;
            root.onmousedown = function (e) {
                _this.onMouseDown(e);
            };
            if (!vp.utils.isIE) {
                root.ontouchstart = function (e) {
                    _this.onMouseDown(e);
                };
            }
        };
        return numAdjustDial;
    }(beachParty.dataChangerClass));
    beachParty.numAdjustDial = numAdjustDial;
    /** Choose the style according to where the adjuster will be placed within the window.  Use "bottom" for centeral placements. */
    (function (AdjusterStyle) {
        AdjusterStyle[AdjusterStyle["left"] = 0] = "left";
        AdjusterStyle[AdjusterStyle["top"] = 1] = "top";
        AdjusterStyle[AdjusterStyle["right"] = 2] = "right";
        AdjusterStyle[AdjusterStyle["bottom"] = 3] = "bottom";
        AdjusterStyle[AdjusterStyle["bottomInPanel"] = 4] = "bottomInPanel";
        AdjusterStyle[AdjusterStyle["topInPanel"] = 5] = "topInPanel";
    })(beachParty.AdjusterStyle || (beachParty.AdjusterStyle = {}));
    var AdjusterStyle = beachParty.AdjusterStyle;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    numAdjustSlider.ts - slider based control for adjusting numbers.  This replaces the dial-based "numAdjuster" class.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var gaugeCircleRadius = 50;
    var numAdjustSliderClass = (function (_super) {
        __extends(numAdjustSliderClass, _super);
        function numAdjustSliderClass(app, parentElem, prompt, initialValue, minValue, maxValue, tooltip, style, roundValues, syncChanges, spreadLow, sliderWidth, useDeskStyle, hostSliderInPanel, nameValueMap, textForWidth) {
            var _this = this;
            if (sliderWidth === void 0) { sliderWidth = 100; }
            _super.call(this);
            this._textForWidth = null;
            this._app = app;
            this._prompt = prompt;
            this._minValue = minValue;
            this._maxValue = maxValue;
            this._numValue = initialValue;
            this._syncChanges = syncChanges;
            this._spreadLow = spreadLow;
            this._roundValues = roundValues;
            this._hostSliderInPanel = hostSliderInPanel;
            this._nameValueMap = nameValueMap;
            this._sliderWidth = sliderWidth;
            this._textForWidth = textForWidth;
            //---- ROOT ----
            var rootW = vp.select(parentElem)
                .addClass("numAdjuster flexColumns flexOtherAutoCenter")
                .title(tooltip);
            this._root = rootW[0];
            this._root.control = this;
            if (prompt) {
                rootW.append("div")
                    .addClass("deskText")
                    .text(prompt)
                    .css("margin-right", "4px");
            }
            var text = this.valueToDisplay(initialValue);
            this.addTextBox(rootW, text, useDeskStyle); // tdW
            if (!this._hostSliderInPanel) {
                //---- CHEVRON ----
                this.addChevron(rootW);
            }
            if (this._hostSliderInPanel) {
                //---- SLIDER HOST ----
                var sliderHostW = rootW.append("div");
                this._sliderHostElem = sliderHostW[0];
            }
            if (hostSliderInPanel) {
                //---- slider should always be open ----
                this.openSlider();
            }
            else {
                //--- protect our popup from ugly events ----
                vp.events.attach(window, "resize", function (e) { return _this.closeSlider(); });
            }
            beachParty.matchIconsToTheme(this._app._themeMgr, this._root);
        }
        numAdjustSliderClass.prototype.addChevron = function (tdW) {
            var _this = this;
            var chevronW = tdW.append("img")
                .addClass("clickIcon openSlider")
                .css("width", "16px")
                .css("margin-left", "3px")
                .title("Click to adjust this value with a slider")
                .attach("dragstart", function (e) {
                //---- prevent drag of icon ----
                e.preventDefault();
            })
                .attach("click", function (e) {
                _this.toggleSliderAssembly();
            })
                .attach("mousedown", function (e) {
                _this._isMouseDownOnChevon = true;
            })
                .attach("mouseup", function (e) {
                _this._isMouseDownOnChevon = false;
            });
            //---- open slider "chevron" button ---
            beachParty.setIconName(this._app._themeMgr, chevronW[0], beachParty.fnOpenSlider);
            this._chevronElem = chevronW[0];
        };
        numAdjustSliderClass.prototype.closeSlider = function () {
            if (this._sliderAssembly) {
            }
            if (this._popupHost) {
                this._popupHost.close();
            }
        };
        numAdjustSliderClass.prototype.toggleSliderAssembly = function () {
            if (this._sliderAssembly) {
                this.closeSlider();
            }
            else {
                this.openSlider();
            }
        };
        numAdjustSliderClass.prototype.createPopupHost = function () {
            var popup = new beachParty.basePopupClass("", this._root);
            this._popupHost = popup;
            var rootW = vp.select(document.body).append("div");
            popup._root = rootW[0];
            //---- point root of popup to its class instance ----
            rootW[0].jsObj = popup;
            popup._autoCloseOnDblClick = false;
            //---- treat mouseDown on owner as an extension of our popup ----
            popup._autoCloseOnOwnerMouseDown = false;
            vp.select(popup.getRootElem())
                .css("z-index", "1999")
                .css("position", "absolute");
            return popup;
        };
        numAdjustSliderClass.prototype.updateAssemblyPosition = function () {
            if (this._popupHost) {
                //---- position to right of our chevorn ----
                var rc = vp.select(this._root, ".openSlider").getBounds(false);
                this._popupHost.showAt(25 + rc.left, rc.top + 0);
            }
        };
        numAdjustSliderClass.prototype.openSlider = function () {
            var _this = this;
            //---- create the parent of the slider assembly ----
            var host = this._sliderHostElem;
            var popup = null;
            if (!host) {
                //---- create a popup to hold the slider ----
                popup = this.createPopupHost();
                host = popup.getRootElem();
            }
            var sliderWidth = (popup) ? this._sliderWidth : 60;
            var sliderClass = (popup) ? null : "sliderAssemblyInPanel";
            this._sliderAssembly = new beachParty.sliderAssemblyClass(this._app, host, this._numValue, this._minValue, this._maxValue, this._roundValues, this._spreadLow, sliderWidth, sliderClass);
            //vp.utils.debug("SLIDER ASSEMBLY CREATED");
            this.updateAssemblyPosition();
            this.refreshChevron();
            this._sliderAssembly.registerForChange("value", function (e) {
                if (_this._sliderAssembly) {
                    var newValue = _this._sliderAssembly.value();
                    _this.value(newValue, _this._syncChanges);
                }
            });
            this._sliderAssembly.registerForChange("valueCompleted", function (e) {
                if (_this._sliderAssembly) {
                    var newValue = _this._sliderAssembly.value();
                    _this.value(newValue, true);
                    _this.updateAssemblyPosition();
                    _this.onDataChanged("valueCompleted");
                }
            });
            if (popup) {
                popup.registerForChange("close", function (e) {
                    vp.utils.debug("SLIDER ASSEMBLY CLOSED");
                    _this._sliderAssembly = null;
                    _this.refreshChevron();
                    _this._sliderAssembly = null;
                });
            }
            //---- give it focus (so when focus is lost, we can auto hide it) ----
            this._sliderAssembly.setFocusToSlider();
        };
        numAdjustSliderClass.prototype.refreshChevron = function () {
            if (this._chevronElem) {
                var src = (this._sliderAssembly) ? beachParty.fnCloseSlider : beachParty.fnOpenSlider;
                beachParty.setIconName(this._app._themeMgr, this._chevronElem, src);
                beachParty.matchIconsToTheme(this._app._themeMgr, this._root);
            }
        };
        numAdjustSliderClass.prototype.onUpOrDown = function (isUp) {
            var changed = false;
            var delta = (this._roundValues) ? 1 : ((this._maxValue - this._minValue) / 100);
            if (isUp) {
                var newValue = this._numValue + delta;
                if (newValue <= this._maxValue) {
                    this.value(newValue, true);
                    changed = true;
                }
            }
            else {
                var newValue = this._numValue - delta;
                if (newValue >= this._minValue) {
                    this.value(newValue, true);
                    changed = true;
                }
            }
            return changed;
        };
        numAdjustSliderClass.prototype.addTextBox = function (textRowW, text, useDeskStyle) {
            var _this = this;
            var textClass = (useDeskStyle) ? "deskText" : "panelText";
            //---- note: these textboxes will be dynamically resized on font change to fit text="Auto" ----
            var textW = textRowW.append("input")
                .attr("type", "text")
                .addClass(textClass + " numAdjusterText")
                .css("text-align", "center")
                .css("padding", "0 2px 0 2px")
                .value(text)
                .attach("focus", function (e) {
                e.target.select();
            })
                .attach("keydown", function (e) {
                _this.onTextKeyDown(e);
            })
                .attach("change", function (e) {
                _this.value(e.target.value, true, "text");
                //---- keep focus in our text control ----
                vp.events.cancelEventBubble(e);
                vp.events.cancelEventDefault(e);
            });
            this._textElem = textW[0];
            textW[0]._numAdjustSliderInst = this;
            this.setWidthForFont();
        };
        numAdjustSliderClass.prototype.setWidthForFont = function () {
            var elemW = vp.select(this._textElem);
            var elem = elemW[0];
            var style = getComputedStyle(elem);
            var tempW = vp.select(document.body).append("span")
                .css("padding-left", style.paddingLeft)
                .css("padding-right", style.paddingRight)
                .css("border-left-width", style.borderLeftWidth)
                .css("border-right-width", style.borderRightWidth)
                .css("font-family", style.fontFamily)
                .css("font-size", style.fontSize)
                .text(this._textForWidth);
            var width = tempW.width();
            tempW.remove();
            //var origText = elemW.text();
            ////---- find width of "textForWidth" using current font ----
            //elemW
            //    .text(this._textForWidth)
            //    .css("width", "");
            //var width = elemW.width();
            //elemW
            //    .text(origText)
            elemW
                .css("width", width + "px");
        };
        numAdjustSliderClass.prototype.onTextKeyDown = function (e) {
            var _this = this;
            if (e.keyCode == vp.events.keyCodes.enter) {
                e.target.select();
                this.value(e.target.value, true, "text");
            }
            else if (e.keyCode == vp.events.keyCodes.escape) {
                setTimeout(function (ee) {
                    e.target.select();
                    _this.value(e.target.value, true, "text");
                }, 10);
            }
            else if (e.keyCode == vp.events.keyCodes.up) {
                if (this.onUpOrDown(true)) {
                    setTimeout(function (ee) { return e.target.select(); }, 10);
                }
            }
            else if (e.keyCode == vp.events.keyCodes.down) {
                if (this.onUpOrDown(false)) {
                    setTimeout(function (ee) { return e.target.select(); }, 10);
                }
            }
        };
        numAdjustSliderClass.prototype.format = function (value, decimals) {
            var str = vp.formatters.comma(value, 2);
            return str;
        };
        numAdjustSliderClass.prototype.show = function (value) {
            vp.select(this._root).css("display", (value) ? "" : "none");
        };
        numAdjustSliderClass.prototype.isShowing = function () {
            return (vp.select(this._root).css("display") != "none");
        };
        numAdjustSliderClass.prototype.minValue = function (value) {
            if (arguments.length == 0) {
                return this._minValue;
            }
            this._minValue = value;
            this.onDataChanged("minValue");
        };
        numAdjustSliderClass.prototype.maxValue = function (value) {
            if (arguments.length == 0) {
                return this._maxValue;
            }
            this._maxValue = value;
            this.onDataChanged("maxValue");
        };
        numAdjustSliderClass.prototype.getRoot = function () {
            return this._root;
        };
        numAdjustSliderClass.prototype.getKeyMatch = function (str) {
            var key = undefined;
            str = str.toLowerCase();
            if (this._nameValueMap) {
                var keys = vp.utils.keys(this._nameValueMap);
                for (var i = 0; i < keys.length; i++) {
                    var thisKey = keys[i].toLowerCase();
                    if (thisKey == str) {
                        key = keys[i]; // the correct case
                        break;
                    }
                }
            }
            return key;
        };
        numAdjustSliderClass.prototype.valueToDisplay = function (value) {
            var str = this.format(value, 2);
            if (this._nameValueMap) {
                var map = this._nameValueMap;
                var keys = vp.utils.keys(map);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var v = +map[key];
                    if (v == value) {
                        str = key;
                        break;
                    }
                }
            }
            return str;
        };
        numAdjustSliderClass.prototype.displayToValue = function (str) {
            var value = undefined;
            var key = this.getKeyMatch(str + "");
            if (key !== undefined) {
                value = this._nameValueMap[key];
                if (value !== undefined) {
                    value = +value;
                }
            }
            if (value === undefined) {
                value = +str;
            }
            if (isNaN(value)) {
                value = 0;
            }
            return value;
        };
        numAdjustSliderClass.prototype.value = function (value, notifyChanged, source) {
            if (arguments.length === 0) {
                //var str = this.valueToDisplay(this._numValue);
                return this._numValue;
            }
            //vp.utils.debug("numAdjustSlide.value(): value=" + value + ", _value=" + this._numValue);
            var numValue = this.displayToValue(value);
            if (numValue != this._numValue || notifyChanged) {
                numValue = Math.max(this._minValue, Math.min(this._maxValue, numValue));
                this._numValue = numValue;
                if (true) {
                    this.updateTextBox();
                }
                if (source != "slider") {
                    this.updateSliderValue();
                }
                if (notifyChanged) {
                    this.onDataChanged("value");
                }
            }
        };
        numAdjustSliderClass.prototype.updateSliderValue = function () {
            if (this._sliderAssembly) {
                this._sliderAssembly.value(this._numValue);
            }
        };
        numAdjustSliderClass.prototype.updateTextBox = function () {
            var strValue = this.valueToDisplay(this._numValue);
            vp.select(this._textElem)
                .value(strValue);
            //vp.utils.debug("numAdjuster.updateValueText: str=" + str);
        };
        return numAdjustSliderClass;
    }(beachParty.dataChangerClass));
    beachParty.numAdjustSliderClass = numAdjustSliderClass;
    //---- this is switch point for using older dial-based numAjuster class or new numAdjustSlider class ----
    function createNumAdjusterClass(app, parent, name, initialValue, minValue, maxValue, tooltip, style, roundValues, syncChanges, spreadLow, sliderWidth, useDeskStyle, hostSliderInPanel, nameValueMap, textForWidth) {
        if (textForWidth === void 0) { textForWidth = "Auto"; }
        if (true) {
            var parentElem = parent;
            if (vp.utils.isString(parent)) {
                parentElem = document.getElementById(parent);
            }
            return new numAdjustSliderClass(app, parentElem, name, initialValue, minValue, maxValue, tooltip, style, roundValues, syncChanges, spreadLow, sliderWidth, useDeskStyle, hostSliderInPanel, nameValueMap, textForWidth);
        }
        //else
        //{
        //    return new numAdjustDial(parent, name, initialValue, minValue, maxValue, tooltip, style, roundValues,
        //        syncChanges, spreadLow);
        //}
    }
    beachParty.createNumAdjusterClass = createNumAdjusterClass;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// popupMenu.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - code for managing a simple popup menu
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var popupMenuClass = (function (_super) {
        __extends(popupMenuClass, _super);
        function popupMenuClass(app, openerIds, id, items, callback, hideAfterCallback, limitHeight, verticalMargin, iconWidth, ownerElem, iconClassName) {
            if (hideAfterCallback === void 0) { hideAfterCallback = false; }
            if (limitHeight === void 0) { limitHeight = true; }
            if (verticalMargin === void 0) { verticalMargin = 0; }
            _super.call(this, openerIds, ownerElem);
            this.context = null;
            this._iconWidth = 0;
            this._verticalMargin = 0;
            this._maxPanelHeight = 0;
            this._app = app;
            this._hideAfterCallback = hideAfterCallback;
            this._callback = callback;
            this._iconWidth = iconWidth;
            this._verticalMargin = verticalMargin;
            this._maxPanelHeight = maxPanelHeight;
            this._iconClassName = iconClassName;
            var maxPanelHeight = beachParty.appClass.maxPanelHeight;
            //---- close and remove any existing popup menus before creating this one ----
            //vp.select("popupMenu")
            //    .remove();
            var rootW = vp.select(document.createElement("div"))
                .attr("id", id)
                .css("position", "absolute")
                .css("overflow-x", "hidden")
                .css("overflow-y", "auto")
                .addClass("flexGrow appBody popupMenu");
            document.body.appendChild(rootW[0]);
            this._root = rootW[0];
            rootW[0].jsObj = this;
            //---- holder of menu items ----
            var tableW = rootW.append("table") //div")
                .addClass("menuItemHolder noSpaceTable")
                .css("width", "100%"); // behave like a <div>
            this._table = tableW[0];
            this.buildMenu(items);
            this.setDockedTheme(false); // default
        }
        popupMenuClass.prototype.setDockedTheme = function (value) {
            var rootW = vp.select(this._root);
            if (value) {
                rootW
                    .removeClass("onUndocked")
                    .addClass("onDocked");
            }
            else {
                rootW
                    .removeClass("onDocked")
                    .addClass("onUndocked");
            }
        };
        popupMenuClass.prototype.buildMenu = function (items) {
            var _this = this;
            var textItemIndex = 0;
            var menuItemIndex = 0;
            var indexes = { menuItemIndex: menuItemIndex, textItemIndex: textItemIndex };
            var themeMgr = this._app._themeMgr;
            var tableW = vp.select(this._table)
                .clear();
            for (var i = 0; i < items.length; i++) {
                var info = items[i];
                popupMenuClass.addItem(themeMgr, tableW, info, indexes, this._hideAfterCallback, this._callback, function (e) { return _this.close(); }, this._iconWidth, false, this._iconClassName, this._ownerElem);
            }
            //---- adjust height of holder to be <= panel ----
            var holderHeight = Math.min(this._maxPanelHeight - this._verticalMargin, tableW.height());
            tableW
                .css("margin-top", this._verticalMargin + "px")
                .css("margin-bottom", this._verticalMargin + "px")
                .css("height", holderHeight + "px");
            beachParty.matchIconsToTheme(this._app._themeMgr, this._root);
        };
        popupMenuClass.prototype.changeRootClass = function (newClass) {
            vp.select(this._root)
                .removeClass("popupMenu")
                .addClass(newClass);
        };
        popupMenuClass.addItem = function (themeMgr, itemsW, item, indexes, hideAfterCallback, clickCallback, hideCallback, iconWidth, clipText, iconClassName, ownerElem) {
            var name = item;
            var disabled = false;
            var tip = null;
            var iconSrc = null;
            var padding = null;
            var preText = undefined;
            if (!vp.utils.isString(item)) {
                var md = item;
                name = md.text;
                disabled = md.isDisabled;
                tip = md.tooltip;
                iconSrc = md.iconSrc;
                padding = md.padding;
                preText = md.preText;
            }
            var rowW = itemsW.append("tr");
            if (name == "-") {
                //---- add simple LINE SEPARATOR ----
                var tdW = rowW.append("td")
                    .attr("colspan", "99");
                var menuItemW = tdW.append("div")
                    .addClass("popupMenuHR")
                    .attr("_menuIndex", indexes.menuItemIndex++);
            }
            else {
                rowW
                    .addClass("popupMenuItemHolder")
                    .attr("_menuIndex", indexes.menuItemIndex)
                    .attr("_textIndex", indexes.textItemIndex)
                    .attr("title", tip);
                if (iconSrc) {
                    //---- add ICON ----
                    var tdW = rowW.append("td");
                    //.css("width", "1px");             // use min width for this column
                    var imgW = tdW.append("img")
                        .addClass("clickIcon popupMenuIcon")
                        .css("margin-top", "2px")
                        .attach("dragstart", function (e) {
                        //---- prevent drag of icon ----
                        e.preventDefault();
                    });
                    if (iconClassName) {
                        imgW.addClass(iconClassName);
                    }
                    beachParty.setIconName(themeMgr, imgW[0], iconSrc);
                    if (iconWidth !== undefined) {
                        imgW.css("width", iconWidth + "px");
                    }
                }
                if (preText !== undefined) {
                    //---- add PRETEXT ----
                    var tdW = rowW.append("td");
                    //.css("width", "1px");             // use min width for this column
                    var pretextW = tdW.append("span") //"span")
                        .addClass("popupMenuPretext")
                        .text(preText)
                        .attr("_menuIndex", indexes.menuItemIndex)
                        .attr("_textIndex", indexes.textItemIndex);
                }
                //---- add TEXT ----
                var tdW = rowW.append("td");
                var menuItemW = tdW.append("div")
                    .addClass("popupMenuItem")
                    .text(name)
                    .attr("_menuIndex", indexes.menuItemIndex)
                    .attr("_textIndex", indexes.textItemIndex);
                if (clipText) {
                    menuItemW
                        .id("collapsibleColumn")
                        .addClass("clipText");
                }
                if (padding) {
                    menuItemW
                        .css("padding", padding);
                }
                indexes.menuItemIndex++;
                indexes.textItemIndex++;
                if (disabled) {
                    //---- we use the custom attribute form here, since "disabled" only works on FORM elements ----
                    rowW.attr("data-disabled", true + "");
                }
                rowW.attach("click", function (e) {
                    var mi = e.target;
                    while (mi && !vp.dom.hasClass(mi, "popupMenuItemHolder")) {
                        mi = mi.parentElement;
                    }
                    if (mi.getAttribute("data-disabled") != "true") {
                        if (!hideAfterCallback) {
                            if (hideCallback) {
                                hideCallback();
                            }
                        }
                        var cbMenuItem = e.target;
                        while (cbMenuItem && !vp.dom.hasClass(cbMenuItem, "popupMenuItemHolder")) {
                            cbMenuItem = cbMenuItem.parentElement;
                        }
                        var menuIndex = cbMenuItem.getAttribute("_menuIndex");
                        var textIndex = cbMenuItem.getAttribute("_textIndex");
                        clickCallback(e, itemsW, textIndex, menuIndex);
                        if (hideAfterCallback) {
                            if (hideCallback) {
                                hideCallback();
                            }
                        }
                    }
                });
                return menuItemW;
            }
        };
        popupMenuClass.prototype.close = function () {
            _super.prototype.close.call(this);
        };
        return popupMenuClass;
    }(beachParty.basePopupClass));
    beachParty.popupMenuClass = popupMenuClass;
    var MenuItemData = (function () {
        function MenuItemData(text, tooltip, iconSrc, isDisabled, padding, preText) {
            this.text = text;
            //this.menuId = (menuId) ? menuId : text;
            this.tooltip = tooltip;
            this.iconSrc = iconSrc;
            this.isDisabled = isDisabled;
            this.padding = padding;
            this.preText = preText;
        }
        return MenuItemData;
    }());
    beachParty.MenuItemData = MenuItemData;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    app.ts - defines app class (that builds and controls BeachParty App UI)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var appClass = (function (_super) {
        __extends(appClass, _super);
        //_chartMenuItems: any[] = null;
        function appClass() {
            _super.call(this);
            this._nextSnapShotNum = 1;
            this._chartIsLoaded = false;
            this._searchCol = "";
            this._searchValue = "";
            this._edition = "client";
            this._serverCmds = [];
            this._finishInitNeeded = true;
            this._fileLoadCount = 0; // number of data set loads that have occured
            this._isLoggingEnabled = false;
            this._showInsightPanelOnStop = false;
            this._chartCycleNum = 0;
            this._infoMsgTimer = null;
            this._animateDisabledFromUrlParams = false;
            this._blankValueStr = "<blank>";
            this._unnamedColStr = "<blank>";
            //_clusteringParams: ClusteringParams;
            this._iconBarBuilt = false;
            this._maxScatterSizeInPixels = 2; // updated on each draw cycle by plot engine
            this._defaultCol = "";
            this._layoutTimer = null;
            this._trueRecordCount = 0;
            this._aggFilteredRecordCount = 0;
            this._isUiVisible = false;
            this._errorCount = 0;
            this._isInstancing = false;
            this._frameStatsMsgBlock = null;
            this._forceExternalSession = false;
            this._includeMissingData = false;
            this._forceCategory = false;
            this._initialLocale = "us";
            this._selectionMode = beachParty.SelectMode.smartToggle;
            this._hideLogoOnInit = false;
            this._hideUiOnInit = false;
            this._areLegendsEnabled = true;
            this._hasCmdServer = false;
            this._webSocketConnected = false;
            this._cmdServerUrl = null;
            this._uiVisibleTimer = null;
            this._isFirstInfoBox = true;
            this._isInitializing = true;
            //---- multiple chart support ----
            this._charts = [];
            //---- insights ----
            this._isInsightLoading = false;
            this._insightWaitingForFilterChanged = false;
            //---- todo: move functionality from their wierd class into the new search panel ----
            this._slicerPanel = null;
            //---- support our APP being hosted in an iframe ----
            this._clientAppId = null;
            this._hostDomain = null;
            this._slicerInitialValue = null;
            this._slicerControl = null;
            if (!this.isBrowserModern()) {
                //---- show old browser message ----
                vp.select("#oldBrowserMsg").css("display", "");
                throw "error - this browser is not supported by SandDance (could not initialize WebGL)";
            }
        }
        appClass.prototype.run = function () {
            this.appInit();
            this.createFakeTextElement();
            this._bigDataMgr = new beachParty.bigDataMgrClass(this);
            this.buildInsightBar();
            this.buildBinAdjusters();
            var settings = this._appSettingsMgr;
            settings._isSavingSettingsDisabled = true;
            try {
                settings.loadAppSettings();
                //settings.registerForChange("shapeImage", (e) =>
                //{
                //    this.useShapeForMapLayouts();
                //});
                //settings.registerForChange("layoutImage", (e) =>
                //{
                //    this.useShapeForMapLayouts();
                //});
                var themeData = this._themeMgr.getTheme();
                var themeName = themeData.propMap.themeName.toLowerCase();
                this._iconBarMgr = new beachParty.iconBarMgrClass(this, this._panelMaster, this._chartRouter);
                this._bigBarMgr = new beachParty.bigBarMgrClass(this, this._panelMaster, this._chartRouter);
                this.rebuildBothToolBars();
                //---- quick fix to hide disabled entries ----
                this.rebuildBothToolBars();
                this.buildAxisButtons();
                this._scriptRecorder = new beachParty.scriptRecorderClass(settings);
            }
            finally {
                settings._isSavingSettingsDisabled = false;
                if (this._animateDisabledFromUrlParams) {
                    settings.isAnimationEnabled(false);
                }
            }
            this.initPart2();
        };
        appClass.prototype.rebuildBothToolBars = function () {
            var settings = this._appSettingsMgr;
            var includeIconButtons = settings.isIconButtonsOnBigBar();
            //---- show/hide the icon bar ----
            var barElemW = vp.select("#iconBar");
            if (includeIconButtons) {
                barElemW.css("display", "none");
            }
            else if (!this._isInitializing) {
                beachParty.chartUtils.fadeIn(barElemW[0]);
            }
            if (this._iconBarMgr) {
                this._iconBarMgr.buildIconBar();
            }
            if (this._bigBarMgr) {
                this._bigBarMgr.buildBigBar();
            }
        };
        appClass.prototype.stopUiVisibleTimer = function () {
            if (this._uiVisibleTimer) {
                clearTimeout(this._uiVisibleTimer);
                this._uiVisibleTimer = null;
            }
        };
        appClass.prototype.startListeningForServerCommands = function (url) {
            var _this = this;
            this._hasCmdServer = true;
            //---- turn off localstorge-based selection sharing ----
            var chart = this.currentChart();
            chart.enableSelectionSharing(false);
            // Create a socket instance
            var ws = new WebSocket(url);
            this._webSocket = ws;
            vp.utils.debug("created the socket");
            ws.onopen = function () {
                _this.showInfoMsg("Info:", "connected to command server: " + url);
                _this._webSocketConnected = true;
            };
            ws.onmessage = function (evt) {
                _this._serverCmds = evt.data.split(";");
                _this.runNextServerCmd(true, true);
            };
            ws.onclose = function () {
                //alert("Connection is closed on client...");
            };
        };
        appClass.prototype.runNextServerCmd = function (displayCmds, delayBetweenCmds) {
            var _this = this;
            var cmds = this._serverCmds;
            var showCmd = displayCmds;
            while (cmds && cmds.length) {
                var cmd = cmds[0];
                cmds.removeAt(0);
                if (cmd.startsWith("{")) {
                    this.createTestMgrIfNeeded();
                    var jsonObj = JSON.parse(cmd);
                    if (jsonObj.target != undefined) {
                        this._scriptRunner.runCmd(jsonObj);
                    }
                    else {
                        //---- its a Composite Project cmd (tangible charts) ----
                        if (jsonObj.Mode == "SandDance") {
                            this.runCompositeCmd(jsonObj);
                        }
                        showCmd = false;
                    }
                }
                else {
                    this.runBotCommand(cmd);
                }
                if (showCmd) {
                    this.showInfoMsg("Remote Cmd:", cmd);
                }
                //---- more cmds to process? ----
                if (cmds.length > 0 && delayBetweenCmds) {
                    //---- add a delay between cmd executions ----
                    var delay = 1000;
                    setTimeout(function (e) { return _this.runNextServerCmd(true, true); }, delay);
                    break;
                }
            }
        };
        appClass.prototype.mapCompositeAttr = function (attrName, value) {
            if (value && value != "undefined" && value != "null") {
                this.runBotCommand("map " + attrName + " to " + value);
            }
            else if (attrName == "color") {
                this.runBotCommand("clear mapping " + attrName);
            }
        };
        appClass.prototype.runCompositeCmd = function (cmdObj) {
            if (cmdObj && cmdObj.Queries && cmdObj.Queries.length) {
                var query = cmdObj.Queries[0];
                var chart = this.currentChart();
                var x = query.Attributes[0];
                var y = query.Attributes[1];
                var z = query.Attributes[2];
                var color = query.Encode;
                //var filters = query.Filters;
                //var filter0 = filters[0];
                var view = query.Schema;
                if (view && view == "Bar") {
                    view = (z) ? "Stacks" : "Column";
                }
                if (view && view == "Scatter") {
                    view = (z) ? "Scatter3D" : "Scatter";
                }
                //---- DATA SET ----
                var fn = "coffeesales";
                var cfn = chart.getFileName();
                cfn = (cfn) ? cfn.toLowerCase() : null;
                if (!fn || fn != cfn) {
                    this.runBotCommand("load data " + fn);
                }
                //---- VIEW ----
                if (chart.getViewName() != view) {
                    this.runBotCommand("set view  " + view);
                }
                //---- X ----
                if (x != chart.getAttribute("x").colName) {
                    this.mapCompositeAttr("x", x);
                }
                //---- Y ----
                if (y != chart.getAttribute("y").colName) {
                    this.mapCompositeAttr("y", y);
                }
                //---- Z ----
                if (z != chart.getAttribute("z").colName) {
                    this.mapCompositeAttr("z", z);
                }
                //---- COLOR ----
                if (color != chart.getAttribute("color").colName) {
                    this.mapCompositeAttr("color", color);
                }
            }
        };
        appClass.prototype.createChart = function (chartName) {
            var _this = this;
            var dataMgr = this._dataEngine.createDataMgr();
            dataMgr.onDataLoadStart.attach(this, function (e) {
                _this.showMsg("Loading data", e.fn, "Please wait...");
            });
            var chartDiv = vp.select("#" + chartName)[0];
            var chart = new beachParty.chartClass(this, dataMgr, chartDiv, false);
            chart.onAttrColNameChange.attach(this, function (e) {
                _this.setAxisButtonText(e.attrName, e.colName);
                if (e.attrName == "y" || e.attrName == "aux") {
                    _this.manualLayoutForYStuff();
                }
            });
            chart.registerForChange("chartName", function (e) {
                //---- relay to any listening UI controls ----
                _this.onDataChanged("chartName");
            });
            chart.registerForChange("xMapping", function (e) {
                _this._xMgr.pushUiUpdate();
            });
            chart.registerForChange("yMapping", function (e) {
                _this._yMgr.pushUiUpdate();
            });
            chart.registerForChange("isSelectionLocked", function (e) {
                //---- manual control binding ----
                var cbElem = vp.select("#cbLockSelection")[0];
                cbElem.checked = chart.isSelectionLocked();
            });
            chart.registerForChange("onTitleTextClicked", function (e) {
                _this.toggleDatasetPanel(event, true);
            });
            chart.registerForChange("onTitleItemsClicked", function (e) {
                _this._bigBarMgr.toggleItemsPanel(event);
            });
            chart.registerForChange("onTitleStatsClicked", function (e) {
                _this._bigBarMgr.onFilteredInCountClick(event);
            });
            chart.registerForChange("onTitleSelectedClicked", function (e) {
                _this._bigBarMgr.onSelectedCountClick(event);
            });
            chart.registerForChange("sortParams", function (e) {
                _this.onSortByChanged();
            });
            chart.registerForChange("customParams", function (e) {
                _this.toggleAxisButtonsAndBins();
            });
            chart.registerForChange("chartOrLayout", function (e) {
                _this.toggleAxisButtonsAndBins();
                _this.updateUiAfterChartViewChanged();
            });
            chart.onActionDectected.attach(this, function (e) {
                if (e.action == "swipe") {
                    var delta = (e.subAction.dir == "up") ? -1 : 1;
                    _this.onNextInsight(delta, true);
                }
            });
            chart.onSearchStarted.attach(this, function (e) {
                _this._selectionDesc = e.selectionDesc;
            });
            var theme = this._themeMgr.getTheme();
            if (theme.propMap.showTitle || this._hideUiOnInit) {
                //---- enable title initially ----
                chart.showTitleText(true);
            }
            if (theme.propMap.showItemStats) {
                chart.showItemCounts(true);
            }
            chart.registerForChange("dataFrame", function (e) {
                _this.onDataFrame(chart);
            });
            //---- turn on tooltips ----
            var toolTipElem = vp.select(this.getAppDivElem(), "#toolTipDiv")[0];
            chart.toolTipElem(toolTipElem);
            chart.hoverOnMouseMove(true);
            chart.isTooltipsEnabled(true);
            return chart;
        };
        appClass.prototype.onSortByChanged = function () {
            this.setBigValue("Sort", this.currentChart().sortItemColumn());
        };
        appClass.prototype.onDataFrame = function (chart) {
            document.title = "SandDance: " + chart.getFileName();
            var preload = chart.getPreload();
            this._fileOpenMgr.preload(preload);
            var strItems = "Items";
            var aggResult = (preload) ? preload.aggResult : null;
            if (aggResult && aggResult.wasSampled) {
                strItems = "Sampled";
            }
            else if (aggResult && aggResult.wasAggregated) {
                strItems = "Aggregated";
            }
            this.setBigPrompt("Items", strItems);
            var recordCount = chart.getRecordCount();
            this.setBigValue("Items", recordCount + "");
            var strCount = vp.formatters.comma(recordCount);
            vp.select("#titleItemCount").text(strCount + " RECORDS");
            if (aggResult && aggResult.trueRecordCount !== undefined) {
                this._trueRecordCount = aggResult.trueRecordCount;
                this._aggFilteredRecordCount = aggResult.aggFilteredRecordCount;
            }
            else {
                this._trueRecordCount = recordCount;
                this._aggFilteredRecordCount = recordCount;
            }
            //this._currentFileParams = msgBlock.preload;
            this.closeScrubberDialog();
            var settings = this._appSettingsMgr;
            settings.saveAppSettings();
            //---- hide last info/error after successful operation (resulting in chart redraw) ----
            this.hideInfoMsg();
            //---- avoid redundant "saveAppSettings()" calls during this call ----
            settings._isSavingSettingsDisabled = true;
            var fileNameChanged = true;
            if (fileNameChanged || !aggResult || !aggResult.wasSampled) {
                try {
                    this.resetMappingsForNewFile();
                }
                finally {
                    settings._isSavingSettingsDisabled = false;
                }
            }
            this.onDataChanged("dataFrame");
            if (this._fileLoadCount == 0) {
                //---- bug workaround - poke layout needed here ----
                this.layoutScreen("firstDataFile");
            }
            this._fileLoadCount++;
            if (preload.fileSource != null && preload.fileSource != "memory") {
                if (settings.rememberLastFile()) {
                    settings.initialDataParams(preload);
                }
            }
            if (this._finishInitNeeded) {
                this.finishInitAfterFileLoad();
            }
            //var pi = this.getPreload(msgBlock.preload);
            //this._selectedSampleName = (pi) ? this._preload.name : "";
        };
        appClass.prototype.getAppDivElem = function () {
            var appDivElem = window["appDiv"];
            return appDivElem;
        };
        appClass.prototype.getBlankValueStr = function () {
            return this._blankValueStr;
        };
        appClass.prototype.updateUiAfterChartViewChanged = function () {
            var chart = this.currentChart();
            var uiName = chart.getUiChartName();
            //var layoutName = chart.layoutName();
            var cop = this._panelMaster.getPanelMgr("viewAsPanel");
            if (cop) {
                cop.updateControlsToMatchChart(uiName, chart.isChartCustom());
            }
            this.setBigValue("View", uiName);
            this.showOrHideLineBy();
            //this.useShapeForMapLayouts();
            //chart.onChartChanged(layout);
            //chart.changeToChart(uiName);
            this.updateClusterPanel();
        };
        appClass.prototype.updateUiAfterFileChange = function () {
            this.updateUiAfterChartViewChanged();
            this.onSortByChanged();
            this.updateBigButton("Facet", "facet");
            this.updateBigButton("Color", "color");
            this.updateBigButton("Size", "size");
            this.updateBigButton("Shape", "shape");
        };
        appClass.prototype.updateBigButton = function (baseName, attrName) {
            var chart = this.currentChart();
            var attr = chart.getAttribute(attrName);
            var colName = attr.colName();
            this.setBigValue(baseName, colName);
        };
        appClass.prototype.createCharts = function () {
            this._paletteMgr = new beachParty.paletteMgrClass(this);
            //---- build charts ----
            var charts = [];
            this._charts = charts;
            var chart1 = this.createChart("chart1");
            charts.push(chart1);
            //var chart2 = this.createChart("chart2");
            //charts.push(chart2);
            this.currentChart(chart1);
            //---- now its safe to apply changes ----
            //chart1.changeToChart("Scatter", null, null);
        };
        appClass.prototype.currentChart = function (value) {
            if (arguments.length == 0) {
                return this._chartRouter.getChart();
            }
            var chartRouter = this._chartRouter;
            chartRouter.setChart(value);
            this.onDataChanged("currentChart");
        };
        appClass.prototype.dataToLoadOnInit = function (value) {
            if (arguments.length == 0) {
                return this._dataToLoadOnInit;
            }
            this._dataToLoadOnInit = value;
            this.onDataChanged("dataToLoadOnInit");
        };
        appClass.prototype.addStyleSheetToCharts = function (rule) {
            //---- apply to all charts ----
            var charts = this._charts;
            for (var i = 0; i < charts.length; i++) {
                var chart = charts[i];
                chart.addStyleSheet(rule);
            }
        };
        //layoutCharts()
        //{
        //    var charts = this._charts;
        //    for (var i = 0; i < charts.length; i++)
        //    {
        //        var chart = charts[i]; 
        //        chart.layoutChart();
        //    }
        //}
        appClass.prototype.getChartDataMgr = function () {
            return this.currentChart().getDataMgr();
        };
        appClass.prototype.initChartSubscriptions = function (chart) {
            var _this = this;
            this._dataEngine.getKnownPreloads(function (knownData) {
                //---- process preload info ----
                _this._knownFileParams = knownData.orderByStr(function (p) { return p.dataName; });
            });
            chart.onCycleStart.attach(this, function (e) {
                if (!e.isSelectionChangeOnly) {
                    _this._dataTipMgr.hideDataTipsBeforeLayout();
                }
            });
            chart.onCycleEnd.attach(this, function (cs) {
                _this.onFrameStats(cs);
            });
            chart.registerForChange("selectedCount", function (e) {
                _this.onSelectionChanged();
            });
            chart.registerForChange("filteredInCount", function (e) {
                _this.onFilteredInCountChanged();
                var filteredInCount = chart.getFilteredInCount();
                var recordCount = chart.getRecordCount();
                var count = (filteredInCount == recordCount) ? 0 : filteredInCount;
                _this.updateSelectionButton("Filtered", _this._filterDesc, count);
            });
        };
        appClass.prototype.initPart2 = function () {
            var _this = this;
            var settings = this._appSettingsMgr;
            this.buildLegends();
            // Prevent images from being draggable on Firefox [the "draggable" element attribute stops functioning on Firefox if "-moz-user-select: none" is also set]
            // [see http://stackoverflow.com/questions/12906789/preventing-an-image-from-being-draggable-or-selectable-without-using-js]
            if (vp.utils.isFireFox) {
                vp.select("img").attach('dragstart', function (e) { e.preventDefault(); });
            }
            this.preventHtmlSelection();
            //---- prevent overall context menu ----
            document.oncontextmenu = function () {
                return false;
            };
            //document.body.addEventListener("MSHoldVisual", function (e) { e.preventDefault(); }, false);
            for (var i = 0; i < this._charts.length; i++) {
                var chart = this._charts[i];
                this.initChartSubscriptions(chart);
            }
            this._dataTipMgr = new beachParty.dataTipMgrClass(this);
            vp.select(window).attach("resize", function (e) {
                _this.markLayoutNeeded("resize event");
                _this.logAction(beachParty.Gesture.system, null, beachParty.ElementType.none, beachParty.Action.adjust, beachParty.Target.documentSize, false, { width: innerWidth, height: innerHeight });
                _this.requestFullChartBuild();
            });
            if (settings.isChartPanelOpen()) {
                this._bigBarMgr.openChartPanel(true, true);
            }
            //if (this._clientAppId)
            //{
            //    this.postMessageToHost({ msg: "clientAppLoaded" });
            //}
            //this.markLayoutNeeded("initPart2");
            //---- test app API's ----
            //this.setAppBackgroundStyle("background: black");
            //this._appSettingsMgr.legendLabelStyle("color: green !important; font-size: 22px !important");
            //this.areLegendsEnabled(false);
            //this.setInsightTitleStyle("color: purple; font-size: 8px");
            //setTimeout((e) =>
            //{
            //    //this._appSettingsMgr.rememberLastInsights(false);
            //    //this.showBigBar(false);
            //}, 1000);
            //---- final phase of initialization ----
            this.onChartsCreated();
        };
        appClass.prototype.onFrameStats = function (cs) {
            var settings = this._appSettingsMgr;
            this._chartCycleNum = cs.cycleNum;
            this._maxScatterSizeInPixels = cs.maxScatterSizeInPixels;
            var memObj = window.performance.memory;
            if (!this._scriptRunner || !this._scriptRunner._isRunning) {
                //---- hide last info/error after successful operation (resulting in chart redraw) ----
                this.hideInfoMsg();
            }
            var msg = cs.cycleNum + ": " + cs.cmdTime + "." + Math.round(cs.buildChartElapsed)
                + "." + cs.lastCycleFrameRate;
            //this._isInstancing = cs.isInstancing;
            if (memObj) {
                msg + "." + vp.formatters.comma(memObj.usedJSHeapSize);
            }
            this.quickStats(msg);
            //---- log frame stats so we can search for slow responses ----
            this.logAction(beachParty.Gesture.system, null, beachParty.ElementType.none, beachParty.Action.report, beachParty.Target.frameStats, false, {
                cycleNum: cs.cycleNum, cmdTime: cs.cmdTime, buildChart: Math.round(cs.buildChartElapsed),
                frameRate: cs.lastCycleFrameRate
            });
            this._frameStatsMsgBlock = cs;
            this.onDataChanged("buildInfo");
            this.onDataChanged("opsInfo");
            this.onDataChanged("lastCycleInfo");
            this.onDataChanged("buildChartDetail");
            if (this._scriptRunner) {
                this._scriptRunner.reportFrameStats(cs.cmdTime, cs.buildChartElapsed, cs.lastCycleFrameRate, cs.lastCycleFrameCount, cs.cycleNum, cs.cmdId);
            }
            if (!cs.isFirstFilterStage) {
                this._dataTipMgr.updateDataTipsAfterLayout();
            }
            else {
                //---- let them stay hidden until end of 2nd stage ----
                var dummyStage = 0;
            }
            //---- if hosted in browser, trigger client's "onPageLoaded" event ----
            if (window.external) {
                var anyExternal = window.external;
                if (anyExternal.OnPageLoaded) {
                    anyExternal.OnPageLoaded();
                }
            }
            if (settings._rememberLastSession) {
                //---- write sessions state (as insight/preload) to localstorage ----
                settings.saveSessionToLocalStorage();
            }
            //---- switch to lower cost drawPrimitive, if possible ----
            //if (this._drawingPrimitive == DrawPrimitive.cube && ! this.is3DChart(this._chartName))
            //{
            //    setTimeout((e) =>
            //    {
            //        this._currentChart.setAutoRebuild(false, false);
            //        this.drawingPrimitive("quad");
            //        this._currentChart.setAutoRebuild(true, false);
            //    }, 100);
            //}
        };
        //getFileName()
        //{
        //    return this._filename;
        //}
        appClass.prototype.toggleDatasetPanel = function (e, isFromLegend) {
            this._bigBarMgr.toggleDataPanel(e, isFromLegend);
        };
        appClass.prototype.onSelectedCountChanged = function () {
            var chart = this.currentChart();
            var selectedCount = chart.getSelectedCount();
            var countMsg = (selectedCount) ? (vp.formatters.comma(selectedCount) + " selected") : "";
            var countMsg = (vp.formatters.comma(selectedCount) + " selected");
            if (countMsg) {
                vp.select("#selectedCountText")
                    .text(countMsg)
                    .css("display", "")
                    .attr("data-disabled", (selectedCount) ? "false" : "true");
            }
            else {
                vp.select("#selectedCountText")
                    .css("display", "none");
            }
            var selDisabled = (!selectedCount);
            this.disableIconButton("isolate", selDisabled);
            this.disableIconButton("exclude", selDisabled);
            //this.disableIconButton("details", selDisabled);
            this.disableBigButton("isolate", selDisabled);
            this.disableBigButton("exclude", selDisabled);
            this.disableBigButton("details", selDisabled);
            this.updateResetButton();
        };
        appClass.prototype.onSelectionChanged = function () {
            var chart = this.currentChart();
            var dataMgr = chart.getDataMgr();
            var selectedCount = dataMgr.getSelectedCount();
            chart.setSelectedCount(selectedCount);
            this.onSelectedCountChanged();
            //chart.setSelectedRecords(msgBlock.selectedRecords);
            this.updateSelectionButton("Selected", this._selectionDesc, selectedCount);
            if (vp.utils.isIE) {
                //---- bug workaround - force storage event trigger for IE from OUTER HTML (not IFRAME) ----
                beachParty.localStorageMgr.save(beachParty.StorageType.sessionShare, beachParty.StorageSubType.triggerEngineRead, null, this._sessionId + "");
            }
            if (selectedCount == 0) {
                this._selectionDesc = null;
            }
            //---- for sharing selection in script recording and command server/listener scenarios ----
            var selectedKeys = dataMgr.getPrimaryKeys(true, true);
            //---- this causes the selection to be sent to listening sessions ----
            this.logAction(beachParty.Gesture.drag, "canvas", beachParty.ElementType.canvas, beachParty.Action.adjust, beachParty.Target.selection, true, null, null, { selectedKeys: selectedKeys });
            this.onDataChanged("selected");
        };
        appClass.prototype.getDataTipMgr = function () {
            return this._dataTipMgr;
        };
        appClass.prototype.getAppSettingsMgr = function () {
            return this._appSettingsMgr;
        };
        appClass.prototype.includeMissingData = function (value) {
            if (arguments.length == 0) {
                return this._includeMissingData;
            }
            this._includeMissingData = value;
            this.onDataChanged("includeMissingData");
        };
        //onDataFrameLoaded(msgBlock: any)
        //{
        //    var preload = <Preload>msgBlock.preload;
        //    //this.onDataLoaded(null, null, preload, msgBlock.fn, msgBlock.recordCount, msgBlock.colInfos, msgBlock.origColInfos);
        //}
        appClass.prototype.isLineByEnabled = function () {
            var isEnabled = false;
            var settings = this._appSettingsMgr;
            if (settings && settings.isButtonEnabled("LineBy")) {
                var chartName = this.currentChart().chartName();
                isEnabled = (chartName == "Scatter" || chartName == "Radial");
            }
            return isEnabled;
        };
        appClass.prototype.runBotCommand = function (cmd) {
            if (!this._botChat) {
                this._botChat = new beachParty.botChatClass(this, null);
            }
            this._botChat.parseChatInput(cmd);
            //---- add to botPanel history, if panel is open ----
            var botPanelMgr = this._panelMaster.getPanelMgr("botPanel");
            if (botPanelMgr) {
                botPanelMgr.addToHistory(cmd);
            }
        };
        appClass.prototype.finishInitAfterFileLoad = function () {
            this._isLoggingEnabled = true;
            this._finishInitNeeded = false;
            //---- we set undo=true in this call to make the current app state the base/home state of undoMgr ----
            var hostName = location.origin;
            this.logAction(beachParty.Gesture.none, null, beachParty.ElementType.none, beachParty.Action.start, beachParty.Target.app, true, { machineId: this._machineId, buildNum: appClass.buildId, hostName: hostName });
            this.makeUIVisible();
            this.hookLocalStorageChanges();
            this.logAction(beachParty.Gesture.none, null, beachParty.ElementType.none, beachParty.Action.capture, beachParty.Target.documentSize, false, { width: innerWidth, height: innerHeight });
            var settings = this._appSettingsMgr;
            if (this._serverCmds && this._serverCmds.length) {
                this.runNextServerCmd(false, false);
            }
            if (settings.runTourOnStartUp()) {
                var theme = this._themeMgr.getTheme();
                if (theme.propMap.firstRunTour) {
                    var tourName = theme.propMap.firstRunTour;
                    //---- over-ridden by cmdline arg? ----
                    if (this._tourToLoadOnInit) {
                        tourName = this._tourToLoadOnInit;
                    }
                    if (tourName && tourName != "none") {
                        this.startTourName(tourName);
                    }
                }
            }
            //---- CHROME layout bug workaround ----
            if (vp.utils.isChrome) {
                this.layoutScreen("fixYStuffPosition");
            }
        };
        appClass.prototype.startTourName = function (tourName) {
            var strJson = beachParty.tourLoaderMgr.loadKnownTourFile(tourName);
            this.startTourFromJson(tourName, strJson, 1750);
        };
        appClass.prototype.isHosted = function () {
            return (window.external && window.external.isHosted);
        };
        appClass.prototype.startTourFromJson = function (name, strJson, delay) {
            var _this = this;
            if (delay === void 0) { delay = 1; }
            if (!strJson) {
                throw "Could not read file: " + name;
            }
            if (vp.utils.isString(strJson)) {
                var tour = JSON.parse(strJson);
            }
            else if (vp.utils.isObject(strJson)) {
                var tour = strJson;
            }
            if (!tour || !tour.steps) {
                throw "Invalid tour file" + name;
            }
            setTimeout(function (e) { return _this.startTour(tour); }, delay);
        };
        appClass.prototype.isNextEdition = function () {
            return (this._edition != "client");
        };
        appClass.prototype.updateSelectionButton = function (buttonBaseName, selectDesc, count) {
            var reason = null;
            var toolTip = null;
            var sd = this._selectionDesc;
            if (sd) {
                if (sd.rectSelect) {
                    reason = "rect select";
                    toolTip = "rect select";
                }
                else {
                    var sp = sd.searchParams;
                    if (sp) {
                        var st = sp.searchType;
                        if (vp.utils.isString(st)) {
                            st = beachParty.TextSearchType[st];
                        }
                        reason = sp.colName;
                        toolTip = "[from " + sd.legendSource + "]:\r\n"
                            + "    ";
                        var minValue = vp.formatters.format(sp.minValue);
                        var maxValue = vp.formatters.format(sp.maxValue);
                        //---- add operator, value, value ----
                        if (st == beachParty.TextSearchType.betweenInclusive) {
                            toolTip += minValue + " <= " + sp.colName + " <= " + maxValue;
                        }
                        else if (st == beachParty.TextSearchType.contains) {
                            toolTip += sp.colName + " contains '" + minValue + "'";
                        }
                        else if (st == beachParty.TextSearchType.exactMatch) {
                            toolTip += sp.colName + " = " + minValue;
                        }
                        else if (st == beachParty.TextSearchType.greaterThan) {
                            toolTip += sp.colName + " > " + minValue;
                        }
                        else if (st == beachParty.TextSearchType.gtrValueAndLeqValue2) {
                            toolTip += minValue + " < " + sp.colName + " <= " + maxValue;
                        }
                        else if (st == beachParty.TextSearchType.lessThan) {
                            toolTip += sp.colName + " < " + minValue;
                        }
                        else if (st == beachParty.TextSearchType.lessThanEqual) {
                            toolTip += sp.colName + " <= " + minValue;
                        }
                        else if (st == beachParty.TextSearchType.notEqual) {
                            toolTip += sp.colName + " != " + minValue;
                        }
                        else if (st == beachParty.TextSearchType.startsWith) {
                            toolTip += sp.colName + " startsWith '" + minValue + "'";
                        }
                    }
                }
            }
            //---- for now, just show count ----
            reason = (count == 0) ? null : (count + "");
            //---- let chart class update their own labels ----
            this.setBigValue(buttonBaseName, reason, toolTip);
        };
        appClass.prototype.onResetTransforms = function () {
            this.currentChart().resetTransform();
        };
        appClass.prototype.appInit = function () {
            var _this = this;
            //---- catch initialization errors  ----
            window.onerror = function (errorMsg, errorUrl, errorLineNum) {
                var msg = "Error: \r\n" + errorMsg;
                if (_this._appSettingsMgr && _this._appSettingsMgr._isErrorReportingDisabled) {
                    vp.utils.debug(msg);
                }
                else {
                    _this.showError(msg);
                }
            };
            if (window.location.hostname == "localhost") {
                appClass.buildId += "-dev";
            }
            this._panelMaster = new beachParty.panelMasterClass(this);
            this._chartRouter = new beachParty.chartRouterClass();
            this.createAppSettings();
            this.processUrlParams();
            this._dataEngine = new beachParty.dataEngineClass(this, this._appSettingsMgr.cacheWebFiles());
            //---- don't create this until we have processed the URL params ----
            this._localeMgr = new beachParty.localeMgrClass(this, this._initialLocale);
            this._fileOpenMgr = new beachParty.dataPanelMgr(this, this._chartRouter);
            this._undoMgr = new beachParty.undoMgrClass();
            this._undoMgr.registerForChange("undoStack", function (e) { return _this.onUndoStackChange(); });
            this.onUndoStackChange();
            this._themeMgr = new beachParty.themeMgrClass(this);
            //this._buttonBuilder = new buttonBuilderClass(this, this._themeMgr);
            //---- load (but don't apply) the current theme ----
            //---- applying the theme this early in the init process causes problems ----
            //this._themeMgr.loadCachedCurrentTheme();
            //---- init logging variables ----
            var sessionNum = +beachParty.localStorageMgr.get(beachParty.StorageType.logTokens, beachParty.StorageSubType.sessionId, null);
            var machineId = beachParty.localStorageMgr.get(beachParty.StorageType.logTokens, beachParty.StorageSubType.machineId, null);
            if (machineId === undefined) {
                //----- get it a pseudo GUID ----
                machineId = vp.utils.now() + "|" + Math.random();
                beachParty.localStorageMgr.save(beachParty.StorageType.logTokens, beachParty.StorageSubType.machineId, null, machineId);
                sessionNum = 1;
            }
            sessionNum = sessionNum + 1;
            beachParty.localStorageMgr.save(beachParty.StorageType.logTokens, beachParty.StorageSubType.sessionId, null, sessionNum + "");
            this._machineId = machineId;
            this._sessionId = sessionNum + "";
            var settings = this._appSettingsMgr;
            vp.events.attach(window, "dblclick", function (e) {
                vp.events.cancelEventBubble(e);
                vp.events.cancelEventDefault(e);
                return false; // prevent default
            });
            //---- turn this on for normal use, but OFF FOR DEBUGGING ----
            window.onerror = function (errorMsg, errorUrl, errorLineNum) {
                var msg = "Error: \r\n" + errorMsg;
                if (_this._appSettingsMgr && _this._appSettingsMgr._isErrorReportingDisabled) {
                    vp.utils.debug(msg);
                }
                else {
                    _this.showError(msg);
                }
            };
            vp.utils.setDebugId("client");
            var chartRouter = this._chartRouter;
            this._xMgr = new beachParty.attrMgrClass(this, chartRouter, "x");
            this._yMgr = new beachParty.attrMgrClass(this, chartRouter, "y");
            this._zMgr = new beachParty.attrMgrClass(this, chartRouter, "z");
            this._auxMgr = new beachParty.auxMgrClass(this, chartRouter);
            this._imageMgr = new beachParty.attrMgrClass(this, chartRouter, "image");
            this._facetMgr = new beachParty.attrMgrClass(this, chartRouter, "facet");
            this._sizeMgr = new beachParty.sizeMgrClass(this, chartRouter);
            this._shapeMgr = new beachParty.shapeMgrClass(this, chartRouter);
            this._lineMgr = new beachParty.lineMgrClass(this, chartRouter);
            this._textMgr = new beachParty.textMgrClass(this, chartRouter);
            this._colorMgr = new beachParty.colorMgrClass(this, chartRouter);
            this.createCharts();
            if (this._cmdServerUrl) {
                this.startListeningForServerCommands(this._cmdServerUrl);
            }
            this._layersMgr = new beachParty.layersMgrClass(this, this._chartRouter, this._textMgr, this._lineMgr);
            this._timeMgr = new beachParty.timeMgrClass(this);
            this._detailsMgr = new beachParty.detailsPanelMgrClass(this, "detailsButton");
            this._insightMgr = new beachParty.insightMgrClass(this);
            this._insightMgr.registerForChange("layout", function (e) { return _this.markLayoutNeeded("insightMgr.layout event"); });
            this._insightMgr.registerForChange("insightLoaded", function (e) { return _this.loadInsight(); });
            this._insightMgr.registerForChange("currentInsight", function (e) { return _this.onCurrentInsightChanged(); });
            this._insightMgr.registerForChange("onAddInsightRequest", function (name, changedBy, e) { return _this.addNewInsight(e); });
            this._insightMgr.registerForChange("playing", function (e) { return _this.onInsightPlayingChanged(); });
            this._insightMgr.registerForChange("showInsightBar", function (e) { return _this.onShowInsightBarChanged(); });
            this.registerStdPanels();
            this.registerMgrPanels();
            var anyWin = window;
            settings.resetAppSettings();
            //settings.shapeOpacity(appClass.defaultOpacity);
            //---- enable DRAG and DROP on whole client document ---
            setTimeout(function (e) {
                vp.select(document.body)
                    .attach("dragover", function (e) { return e.preventDefault(); })
                    .attach("drop", function (e) { return _this._fileOpenMgr.processDroppedTextOrFile(e); });
            }, 1);
            //---- hook WINDOW keyboard/mouse down ----
            var windowW = vp.select(window);
            //---- do these AFTER creating chartUx/rubberBand ----
            windowW.attach("mousedown", function (e) { return _this.onWindowMouseDown(e); });
            windowW.attach("keydown", function (e) { return _this.onWindowKeyDown(e); });
            this.updateIconNames();
        };
        appClass.prototype.setElemIcon = function (selectExp, fn) {
            var elem = vp.select(selectExp)[0];
            beachParty.setIconName(this._themeMgr, elem, fn, null, true);
        };
        appClass.prototype.showMsg = function (title, objName, msg) {
            var localeMgr = this._localeMgr;
            //---- use localized strings ----
            var tt = localeMgr.getText("Message." + title);
            if (tt) {
                title = tt[0];
                msg = tt[1];
            }
            this.showInfoMsg(title + ": " + objName, msg);
        };
        /**
         *  Shutdown the app & release as much memory as possible.
        */
        appClass.prototype.shutDown = function () {
            //---- shut down all charts ----
            for (var i = 0; i < this._charts.length; i++) {
                var chart = this._charts[i];
                chart.shutDown();
            }
        };
        appClass.prototype.updateIconNames = function () {
            var _this = this;
            //---- to reflect latest theme change ----
            this.setElemIcon("#insightMenuButton", beachParty.fnMenuBars);
            this.setElemIcon("#insightCloseButton", beachParty.fnClose);
            this.setElemIcon("#infoMsgCloseButton", beachParty.fnClose);
            this.setElemIcon("#btLogo", beachParty.fnSandDanceLogo);
            //---- update num adjuster open/close icons ----
            vp.select(".openSlider").each(function (index, elemW) {
                beachParty.processImgElem(_this._themeMgr, "appPanel", index, elemW);
            });
        };
        //---- called by partyGen and SELF ----
        appClass.prototype.createAppSettings = function () {
            this._appSettingsMgr = new beachParty.appSettingsMgr(this, this._chartRouter);
        };
        appClass.prototype.getPanelMaster = function () {
            return this._panelMaster;
        };
        appClass.prototype.setSelectionDesc = function (selectDesc) {
            selectDesc.selectMode = this._selectionMode;
            this._selectionDesc = selectDesc;
        };
        appClass.prototype.isBrowserModern = function () {
            var isModern = true;
            //---- for now, just test for WebGL support ----
            var canvas = document.createElement("canvas");
            var gl = canvas.getContext("webgl");
            if (!gl) {
                gl = canvas.getContext("experimental-webgl");
            }
            isModern = (!!gl);
            return isModern;
        };
        appClass.prototype.setHelperCmdId = function (value) {
            this.currentChart().setCmdId(value);
        };
        appClass.prototype.hookLocalStorageChanges = function () {
            var _this = this;
            //---- IE bug workaround - listen for storage events from OUTER HTML (not IFRAME) ----
            if (vp.utils.isIE) {
                //vp.utils.debug("hookLocalStorageChanges");
                beachParty.localStorageMgr.hookChanges(function (e) {
                    if (e.key != "appSettings") {
                        var process = true;
                        var strTrigger = beachParty.StorageSubType[beachParty.StorageSubType.triggerEngineRead];
                        if (e.key == strTrigger) {
                            var value = beachParty.localStorageMgr.get(beachParty.StorageType.sessionShare, beachParty.StorageSubType.triggerEngineRead, null);
                            if (value == _this._sessionId) {
                                process = false;
                            }
                        }
                        if (process) {
                            //vp.utils.debug("******* shareMgr.changeFunc: e.key=" + e.key);
                            //alert("storage event");
                            _this.currentChart().onLocalStorageChange();
                        }
                    }
                });
            }
        };
        appClass.prototype.onShowInsightBarChanged = function () {
        };
        appClass.prototype.onFilenameChanged = function () {
            var chart = this.currentChart();
            var fn = chart.getFileName();
            vp.select("#filenameText")
                .text(fn);
            this.currentChart().titleText(fn);
            vp.select("#titleText")
                .text(fn);
            this.setBigValue("Data", fn);
        };
        appClass.prototype.onAppFileLoaded = function () {
            this.onFilenameChanged();
            this.onRecordCountChanged();
            this.currentChart().onChartOrLayoutChanged();
        };
        appClass.prototype.markIconBarBuildNeeded = function () {
            if (this._iconBarMgr) {
                this._iconBarMgr.buildIconBar();
            }
        };
        appClass.prototype.buildInsightBar = function () {
            //---- this elem has class: flexColumns flexSpace ----
            var barW = vp.select("#insightBar");
            var toolbar = new beachParty.toolbarClass(this, barW[0], [this]);
            toolbar.startBuild(true);
            var textForWidth = "Show";
            //---- ADD insight button (without icon) ----
            this.addIconButton(toolbar, "addNewInsight", "addinsight", "Add a new insight", null, "Add", undefined, textForWidth)
                .addClass("flexAuto playPanelButton");
            //---- add a container for playShow to keep them together ----
            var playShowHolderW = barW.append("div")
                .addClass("flexColumns");
            var toolbar = new beachParty.toolbarClass(this, playShowHolderW[0], [this]);
            toolbar.startBuild(true);
            //---- PLAY insights button (without icon) ----
            this.addIconButton(toolbar, "startPlayback", "playinsights", "Play the insights", null, "Play", undefined, textForWidth)
                .addClass("flexAuto playPanelButton");
            //---- SHOW insights button (without icon) ----
            this.addIconButton(toolbar, "startInsightsShow", "showInsights", "Show the insights", null, "Show", undefined, textForWidth)
                .addClass("flexAuto playPanelButton");
        };
        appClass.prototype.toBlob = function (canvas, callback) {
            if (canvas.toBlob) {
                //---- typescript doesn't know correct signature for this method ----
                var anyCanvas = canvas;
                anyCanvas.toBlob(callback);
            }
            else {
                var blob = canvas.msToBlob();
                callback(blob);
            }
        };
        appClass.prototype.buildAxisButtons = function () {
            //----- convert X, Y, Z placeholders to ICON TEXT PAIR ----
            this.addAxisButton("x", "Specify the column mapped to the X axis", "X", true, false, 200);
            this.addAxisButton("y", "Specify the column mapped to the Y axis", "Y", true, true, 200);
            this.addAxisButton("z", "Specify the column mapped to the Z axis", "Z", true, false, 200);
            //---- initially hide X, Y, and Z buttons ----
            vp.select("#xButtonOuter").css("display", "none");
            vp.select("#yButtonOuter").css("display", "none");
            vp.select("#zButtonOuter").css("display", "none");
        };
        appClass.prototype.addAxisButton = function (axisName, tooltip, prompt, addChevron, isRotated, maxTextWidth) {
            var barW = vp.select("#" + axisName + "ButtonOuter");
            var toolbar = new beachParty.toolbarClass(this, barW[0], [this]);
            toolbar.startBuild(true);
            var callbackName = null;
            var elemW = this.addIconButton(toolbar, callbackName, axisName, tooltip, null, prompt, isRotated);
            elemW
                .css((isRotated) ? "max-height" : "max-width", maxTextWidth + "px");
            //---- prevent wrapping of 'axisName: columnName' ----
            vp.select("#" + axisName + "Text")
                .css("white-space", "nowrap");
        };
        appClass.prototype.addIconButton = function (toolbar, callbackName, rootName, tip, imgSrc, prompt, isRotated, textForWidth) {
            var buttonInfo = {
                prompt: prompt, chevron: false, set: rootName, root: rootName, tip: tip, cbName: callbackName, icon: imgSrc,
                rotated: isRotated, textForWidth: textForWidth };
            var elem = toolbar.addIconButton(buttonInfo);
            return vp.select(elem);
        };
        appClass.prototype.postIconBarBuild = function () {
            //---- refresh these after rebuild ----
            this.onSelectedCountChanged();
            this.onFilteredInCountChanged();
            this.onUndoStackChange();
            this.fixUpButtonsAfterRuleChange();
        };
        appClass.prototype.onRelationsClick = function () {
        };
        //---- called from appSettings panel ----
        appClass.prototype.toggleStats = function () {
            var settings = this._appSettingsMgr;
            settings.isShowingDrawStats(!settings._isShowingDrawStats);
        };
        appClass.prototype.disableIconButton = function (baseName, isDisabled) {
            var value = (isDisabled) ? "true" : "false";
            vp.select("#" + baseName + "Button").attr("data-disabled", value);
            vp.select("#" + baseName + "ButtonInner").attr("data-disabled", value);
        };
        appClass.prototype.disableBigButton = function (baseName, isDisabled) {
            var value = (isDisabled) ? "true" : "false";
            var name = "#bb" + beachParty.chartUtils.capitalizeFirstLetter(baseName);
            vp.select(name).attr("data-disabled", value);
            vp.select(name + "Value").attr("data-disabled", value);
            //---- hide chevron if disabled ----
            vp.select(name + "Chevron").css("display", (isDisabled) ? "none" : "");
        };
        appClass.prototype.onSelectClick = function () {
            var _this = this;
            var items = [];
            items.push(new beachParty.MenuItemData("Smart Toggle", "Toggle the selection of axis box shapes", beachParty.fnSelectionToggle));
            items.push(new beachParty.MenuItemData("Select", "Select only the specified shapes", beachParty.fnSelectionNormal));
            items.push(new beachParty.MenuItemData("Add", "Add the specified shapes to the selection", beachParty.fnSelectionUnite));
            items.push(new beachParty.MenuItemData("Subtract", "The new selection is subtracted from the previous selection", beachParty.fnSelectionSubtract));
            items.push(new beachParty.MenuItemData("Intersect", "Selects the intersection of the new and previous selections", beachParty.fnSelectionIntersect));
            var picker = this.createGeneralPicker("selectButton", "selectionMode", items, function (mid) {
                var selectName = mid.text;
                var mode = beachParty.SelectMode.smartToggle;
                if (selectName == "Smart Toggle") {
                    mode = beachParty.SelectMode.smartToggle;
                }
                else if (selectName == "Select") {
                    mode = beachParty.SelectMode.normal;
                }
                else if (selectName == "Add") {
                    mode = beachParty.SelectMode.additive;
                }
                else if (selectName == "Subtract") {
                    mode = beachParty.SelectMode.subtractive;
                }
                else if (selectName == "Intersect") {
                    mode = beachParty.SelectMode.intersection;
                }
                //this._currentChart.setSelectionMode(mode);
                _this._selectionMode = mode;
                //---- keep all charts in sync on value ----
                var charts = _this._charts;
                for (var i = 0; i < charts.length; i++) {
                    charts[i].selectMode(mode);
                }
                _this.onSelectionModeChanged(mid.iconSrc);
            });
            if (picker) {
                var rc = this.getAppRelBounds("#selectButton");
                picker.showAt(rc.left, rc.bottom);
            }
        };
        appClass.prototype.onSelectionModeChanged = function (imgSrc) {
            //---- update the selection button to reflect the new mode ----
            var isSelected = (imgSrc != beachParty.fnSelectionNormal);
            if (isSelected) {
                imgSrc = imgSrc.replace("white", "black");
            }
            var imgW = vp.select("#selectIcon");
            if (imgW.length) {
                beachParty.setIconName(this._themeMgr, imgW[0], imgSrc, "iconBarPanel", true);
                //---- don't enable this until we have the negative selectionMode icons ----
                imgW
                    .attr("data-selected", (isSelected) ? "true" : "false");
            }
        };
        appClass.prototype.fixUpButtonsAfterRuleChange = function () {
            //---- handle exceptions to app options for text/icons/chevrons in buttons ----
            vp.select("#xText").css("display", "block");
            vp.select("#yText").css("display", "block");
            vp.select("#zText").css("display", "block");
            //vp.select("#insightChevron").css("display", "none");
        };
        appClass.prototype.onWindowMouseDown = function (e) {
            //if (e && this._rcPlot)
            //{
            //    var pt = vp.events.mousePosition(e);
            //    //---- ensure mouse is over PLOT area ----
            //    if (vp.geom.rectContainsPoint(this._rcPlot, pt))
            //    {
            //        if (e.which == 3)
            //        {
            //            //---- right click: toggle DATA TIP ----
            //        }
            //    }
            //    else if (e.which == 1)
            //    {
            //        //---- LEFT CLICK ----
            //        //var elem = vp.events.elementFromPoint(pt.x, pt.y);
            //        //if (elem && elem.control && elem.control instanceof dataTipClass)
            //        //{
            //        //    var dataTip = <dataTipClass>elem.control;
            //        //    //---- pass click to dataTip (since it has its pointer-events turned off) ----
            //        //    dataTip.onMouseDown(e);
            //        //}
            //    }
            //}
        };
        appClass.prototype.onWindowKeyDown = function (e) {
            if (e.keyCode == 8) {
                var focusElem = document.activeElement;
                if (focusElem.tagName != "INPUT" && focusElem.tagName != "TEXTAREA") {
                    //---- block BACKSPACE so users can type safely ----
                    vp.events.cancelEventBubble(e);
                    vp.events.cancelEventDefault(e);
                }
            }
        };
        appClass.prototype.closeAllPopups = function () {
            //---- old code - track each popup ----
            //this.closeGeneralPicker();
            //this.closeContextMenu();
            //this._insightMgr.closeMenus();
            //---- new code - find all close all popupMenu's and panels without a title bar ----
            var popups = vp.select(".popupMenu");
            popups.toArray().forEach(function (p) {
                p.jsObj.close();
            });
            var panels = vp.select(".panel");
            panels.toArray().forEach(function (p) {
                //---- do not close PINNED panels ---
                var basePanel = p.jsObj;
                if (!basePanel.isFloating()) {
                    p.jsObj.close();
                }
            });
            var panels = vp.select(".popupPanel");
            panels.toArray().forEach(function (p) {
                p.jsObj.close();
            });
        };
        appClass.prototype.showTestAlert = function () {
            alert("this is the test alert");
        };
        appClass.prototype.onInsightPlayingChanged = function () {
            var isPlaying = (this._insightMgr.isPlaying());
            if (isPlaying) {
                if (this._insightMgr.isPaused()) {
                    this.onPlaybackPaused();
                }
                else {
                    var wasPaused = this._insightMgr._wasPaused;
                    this.onPlaybackStarted(wasPaused);
                }
            }
            else {
                this.onPlaybackStopped();
            }
        };
        appClass.prototype.stopPlayback = function () {
            if (this._insightMgr.isPlaying()) {
                this._insightMgr.stopPlayback();
            }
        };
        appClass.prototype.pausePlayback = function () {
            if (this._insightMgr.isPlaying()) {
                this._insightMgr.pausePlayback();
            }
        };
        appClass.prototype.showPlayUI = function (isPlaying, isPaused) {
            //---- show VCR BUTTONS when PLAY or PAUSED ----
            var showPlayButtons = (isPlaying || isPaused);
            vp.select("#playPanel").css("display", (showPlayButtons) ? "" : "none");
            var theme = this._themeMgr.getTheme();
            if (this._appSettingsMgr.isIconButtonsOnBigBar()) {
                vp.select("#playAndIconBar").css("display", (showPlayButtons) ? "" : "none");
            }
            //---- show BIG BAR and ICON BAR if not playing ----
            this._bigBarMgr.show(!isPlaying);
            vp.select("#iconBar").css("display", (isPlaying) ? "none" : "");
            //---- show/hide axis bins adjusters ----
            this.toggleAxisButtonsAndBins(isPlaying);
            //---- show/hide bot panel ----
            var botPanel = this._panelMaster.getPanelMgr("botPanel");
            if (botPanel) {
                botPanel.show(!isPlaying);
            }
            var charts = this._charts;
            for (var i = 0; i < charts.length; i++) {
                var chart = charts[i];
                chart.setPresentationMode(isPlaying);
            }
            this.layoutScreen("showPlayUI");
        };
        appClass.prototype.onPlaybackStarted = function (wasPaused) {
            //vp.select("#stopButton")
            //    .css("display", "")
            vp.select("#playExButton")
                .text("Pause");
            this.showPlayUI(true);
            this._showInsightPanelOnStop = this._insightMgr.isPanelOpen();
            if (!wasPaused) {
                this._insightMgr.showInsightBar(false);
            }
            this.layoutScreen("onPlaybackStarted");
        };
        appClass.prototype.onPlaybackPaused = function () {
            //vp.select("#stopButton").css("display", "");
            vp.select("#playExButton")
                .text("Resume");
            this.showPlayUI(false, true);
            this._insightMgr.showInsightBar(false);
            this.layoutScreen("onPlaybackPaused");
        };
        appClass.prototype.onPlaybackStopped = function () {
            //vp.select("#stopButton").css("display", "none")
            this.showPlayUI(false);
            if (this._showInsightPanelOnStop) {
                this._insightMgr.showInsightBar(true);
            }
            this.layoutScreen("onPlaybackStopped");
        };
        appClass.prototype.onPlayExClick = function (e) {
            var text = vp.select("#playExButton").text();
            if (text == "Pause") {
                this.pausePlayback();
            }
            else if (text == "Resume") {
                this.resumePlayback();
            }
        };
        appClass.prototype.startPlayback = function (useAnimation) {
            if (useAnimation === void 0) { useAnimation = true; }
            this.stopPlayback();
            this._insightMgr.startPlayback(useAnimation);
            this.switchPlaybackButtons(!this._insightMgr._playWithAnimation);
        };
        /**
         *  Switch from pause/stop buttons to the prev/next buttons.
         * @param value
         */
        appClass.prototype.switchPlaybackButtons = function (usePrevNext) {
            vp.select("#playExButton").css("display", (!usePrevNext) ? "inline-block" : "none");
            //vp.select("#stopButton").css("display", (!usePrevNext) ? "inline-block" : "none");
            vp.select("#prevButton").css("display", (usePrevNext) ? "inline-block" : "none");
            vp.select("#nextButton").css("display", (usePrevNext) ? "inline-block" : "none");
            //vp.select("#insightProgress").css("display", (usePrevNext) ? "inline-block" : "none");
        };
        appClass.prototype.startInsightsShow = function () {
            this.startPlayback(false);
        };
        appClass.prototype.onNextInsight = function (delta, preventTimer) {
            this._insightMgr.syncPlaybackWithCurrentInsight();
            this._insightMgr.showNextInsight(delta, preventTimer);
        };
        appClass.prototype.resumePlayback = function () {
            this._insightMgr.resumePlayback();
        };
        appClass.prototype.onChartNotesClick = function () {
            //---- for now, click means HIDE notes ----
            vp.select("#chartNotes")
                .css("display", "none");
        };
        appClass.prototype.onCurrentInsightChanged = function () {
            var _this = this;
            var insight = this._insightMgr.currentInsight();
            var source = (insight) ? insight.notesSource : null;
            var notes = null;
            var title = null;
            if (insight && source != beachParty.NotesSource.none) {
                if (source == beachParty.NotesSource.name && insight.name) {
                    notes = insight.name;
                }
                else if (source == beachParty.NotesSource.notes && insight.notes) {
                    notes = insight.notes;
                }
                else if (source == beachParty.NotesSource.both) {
                    title = insight.name;
                    notes = insight.notes;
                }
            }
            //---- close current panel, if open ----
            this.closeNotesPanel();
            //---- enable chart's title panel if in presentation mode ----
            this.currentChart().enableTitlePanel(reason == "load");
            //---- only show notes panel for insight if it was result of a LOAD (vs. new insight) ----
            var reason = this._insightMgr.getCurrentInsightReason();
            if (reason == "load" || reason == "play load") {
                if (title || notes) {
                    if (!title) {
                        title = notes;
                        notes = null;
                    }
                    //this._chartRouter.getPlotBounds((msgBlock) => 
                    //{
                    //    var rcPlot = msgBlock.rcPlot;
                    //    //---- convert rcPlot from relative to window coordinates ----
                    //    var rcChart = this._chartRouter.getBounds();
                    //    rcPlot = vp.geom.createRect(rcChart.left + rcPlot.left, rcChart.top + rcPlot.top, rcPlot.width, rcPlot.height);
                    //    this._notesPanel = new notesPanelClass(this, title, notes, insight.notesBounds, rcPlot);
                    //    //---- track panel movements ----
                    //    this._notesPanel.registerForChange("location", (e) => this.onInsightBoundsChange(insight));
                    //    this._notesPanel.registerForChange("size", (e) => this.onInsightBoundsChange(insight));
                    //});
                    var rcPlot = this.currentChart().getPlotBounds();
                    //---- convert rcPlot from relative to window coordinates ----
                    var rcChart = this.currentChart().getBounds();
                    rcPlot = vp.geom.createRect(rcChart.left + rcPlot.left, rcChart.top + rcPlot.top, rcPlot.width, rcPlot.height);
                    this._notesPanel = new beachParty.notesPanelClass(this, title, notes, insight.notesBounds, rcPlot, reason == "play load");
                    //---- track panel movements ----
                    this._notesPanel.registerForChange("location", function (e) { return _this.onInsightBoundsChange(insight); });
                    this._notesPanel.registerForChange("size", function (e) { return _this.onInsightBoundsChange(insight); });
                }
            }
        };
        appClass.prototype.onInsightBoundsChange = function (insight) {
            var rc = vp.select(this._notesPanel.getRootElem()).getBounds(false);
            insight.notesBounds = rc;
        };
        appClass.prototype.closeNotesPanel = function () {
            if (this._notesPanel) {
                this._notesPanel.close();
                this._notesPanel = null;
            }
        };
        appClass.prototype.applyDefaultBins = function () {
            //var settings = this._appSettingsMgr;
            //var binCount = settings._defaultBins;
            //this.bins(binCount, true);
            //this._facetMgr.bins(binCount);  //, true);
            //this.xBins(binCount);
            //this.yBins(binCount);
            //this.setXBinCounts();
            //this.setYBinCounts();
            //this.setFacetBinCounts();
        };
        appClass.prototype.onAddView = function (e) {
            window.open(window.location.href, "_blank", "resizable,scrollbars,status=0,titlebar=0");
            //---- log as not-undoable ----
            this.logAction(beachParty.Gesture.click, e.target.id, beachParty.ElementType.button, beachParty.Action.open, beachParty.Target.newAppInstance, false);
        };
        appClass.prototype.createTestMgrIfNeeded = function () {
            if (!this._scriptRunner) {
                this._scriptRunner = new beachParty.scriptRunnerClass(this);
            }
        };
        appClass.prototype.plotTestResults = function () {
            this.createTestMgrIfNeeded();
            this._scriptRunner.plotPerfResults();
        };
        appClass.prototype.plotEngineEvents = function () {
            var _this = this;
            //---- close the settings panel ----
            this.toggleSettingsPanel(null);
            this.currentChart().getEngineEvents(function (msgBlock) {
                var engineEvents = msgBlock.engineEvents;
                if (engineEvents && engineEvents.length) {
                    var dataMgr = _this.getChartDataMgr();
                    dataMgr.loadFrom(engineEvents, "engineEvents", undefined, function (e) {
                        _this.currentChart().changeToChart(beachParty.ChartType.Scatter, null, beachParty.Gesture.automatedTest);
                        //this.xColumn("time");
                        _this._xMgr.colName("time");
                        _this._yMgr.colName("eventName");
                        _this._colorMgr.colName("eventName");
                        //this.changeShapeMapping("eventType");
                        _this._lineMgr.colName("durationId");
                    });
                }
            });
        };
        appClass.prototype.addClientMemoryUse = function (memUse) {
            //---- first build a map of major objects in engine ----
            var memObjs = {};
            memObjs.app = this;
            memObjs.appSettingsMgr = this._appSettingsMgr;
            ;
            memObjs.charts = this._charts;
            memObjs.fileOpenMgr = beachParty.dataPanelMgr;
            memObjs.insightMgr = this._insightMgr;
            memObjs.undoMgr = this._undoMgr;
            beachParty.cbUtils.getMemoryUse(memObjs, memUse);
        };
        appClass.prototype.plotEngineMemoryUse = function () {
            var _this = this;
            //---- close the settings panel ----
            this.toggleSettingsPanel(null);
            this.currentChart().getMemoryUse(function (msgBlock) {
                var memUse = msgBlock.memUse;
                var engKeyCount = vp.utils.keys(memUse).length;
                _this.addClientMemoryUse(memUse);
                //---- create a JSON record for each name/value pair ----
                var records = [];
                var keys = vp.utils.keys(memUse);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var space = (i < engKeyCount) ? "engine" : "client";
                    var record = { name: key, value: memUse[key], space: space };
                    records.push(record);
                }
                var dataMgr = _this.getChartDataMgr();
                dataMgr.loadFrom(records, "memoryUse", undefined, function (e) {
                    _this.currentChart().changeToChart(beachParty.ChartType.Column, null, beachParty.Gesture.automatedTest);
                    //this.xColumn("name");
                    _this._xMgr.colName("name");
                    _this._sizeMgr.colName("value");
                    //this.colName("eventName");
                });
            });
        };
        appClass.prototype.startAutomatedTest = function (scriptData, fn, runCount) {
            if (this._scriptRunner && this._scriptRunner._isRunning) {
                this._scriptRunner.stop();
                this._scriptRunner = null;
            }
            else {
                this.createTestMgrIfNeeded();
                this._scriptRunner.start(scriptData, fn, runCount);
            }
        };
        appClass.prototype.stopAutomatedTest = function () {
            if (this._scriptRunner && this._scriptRunner._isRunning) {
                this._scriptRunner.stop();
                this._scriptRunner = null;
            }
        };
        appClass.prototype.getPlotBounds = function () {
            return this.currentChart().getBounds();
        };
        appClass.prototype.quickStats = function (msg) {
            vp.select("#lastCycleFPS")
                .text(msg);
        };
        //showTitle(value: boolean)
        //{
        //    this._currentChart.showTitle(value);
        //}
        appClass.prototype.showAllCharts = function (value) {
            vp.select("#chart1")
                .css("display", value ? "" : "none");
        };
        appClass.prototype.toggleXPanel = function (e, fromLegend) {
            this._bigBarMgr.toggleXPanel(e, fromLegend);
        };
        appClass.prototype.toggleYPanel = function (e, fromLegend) {
            this._bigBarMgr.toggleYPanel(e, fromLegend);
        };
        appClass.prototype.toggleZPanel = function (e, fromLegend) {
            this._bigBarMgr.toggleZPanel(e, fromLegend);
        };
        appClass.prototype.makeUIVisible = function () {
            this.stopUiVisibleTimer();
            var theme = this._themeMgr.getTheme();
            if (!this._hideUiOnInit) {
                if (!theme.propMap.iconButtonsOnBigBar) {
                    //vp.select("#iconBar").css("display", "inline-block");
                    beachParty.chartUtils.fadeIn("#iconBar", 3500);
                }
                //this._bigBarMgr.show(true);
                beachParty.chartUtils.fadeIn("#" + this._bigBarMgr.getRootName(), 3500);
            }
            for (var i = 0; i < this._charts.length; i++) {
                var chart = this._charts[i];
                //chart.enableTitlePanel(true);
                chart.isVisible(true);
            }
            //vp.select("#feedbackBar")
            //    .css("display", "")
            vp.select("#leftPanel").css("display", "");
            vp.select("#bottomPanel").css("display", "");
            this.showRightPanel(true);
            this.showAllCharts(true);
            //---- restore zindex of logo to normal ----
            vp.select("#btLogo").css("z-index", "1");
            //---- force Y label box size to be recalcuated now that everything is visible ----
            this.currentChart().onChartChanged();
            this._isUiVisible = true;
            //---- move infoMsgBox below the big bar ----
            //vp.select("#infoMsgBox")
            //    .css("top", "150px")
            //---- call immediately so that we minimize time that we show screen in un-layedout form ----
            //this.markLayoutNeeded("makeUIVisible");
            this.layoutScreen("makeUiVisible");
            this._isInitializing = false;
        };
        appClass.prototype.showRightPanel = function (value) {
            value = value && this._areLegendsEnabled;
            vp.select("#rightPanel").css("display", (value) ? "" : "none");
        };
        appClass.prototype.selectFacetBox = function (index) {
            var chart = this.currentChart();
            chart.selectFacetBox(index);
        };
        appClass.prototype.getIndexOfFacetLabel = function (label) {
            var chart = this.currentChart();
            return this.getIndexOfFacetLabel(label);
        };
        appClass.prototype.selectXBox = function (index) {
            this.currentChart().selectXTickBox(index);
        };
        appClass.prototype.selectYBox = function (index) {
            this.currentChart().selectYTickBox(index);
        };
        appClass.prototype.selectColorBox = function (index) {
            this._colorLegend.selectBox(index);
        };
        appClass.prototype.selectSizeBox = function (index) {
            this._sizeLegend.selectBox(index);
        };
        appClass.prototype.selectShapeBox = function (index) {
            this._shapeLegend.selectBox(index);
        };
        appClass.prototype.onChartsCreated = function () {
            var _this = this;
            //---- only do this once ----
            if (!this._chartIsLoaded) {
                this._chartIsLoaded = true;
                //---- use a timer to make UI visible if something goes wrong with initial data loading ----
                this._uiVisibleTimer = setTimeout(function (e) {
                    _this.makeUIVisible();
                }, 10 * 1000);
                //---- catch errors here so that we don't let bad data/session file ruin our initialization ----
                try {
                    if (this._initSessionId) {
                        //---- load session specified in url (sharing with self or others) ----
                        this._insightMgr.loadSessionFromServer(this._initSessionId, function (e) {
                            //this.finishInitAfterFileLoad();
                        });
                    }
                    else if (!this._clientAppId) {
                        var loadedSomething = false;
                        var settings = this._appSettingsMgr;
                        if (settings.rememberLastSession()) {
                            loadedSomething = (this.loadLastSession() != null);
                        }
                        if (settings.rememberLastInsights()) {
                            setTimeout(function (d) { return _this.restoreInsightsFromLastSession(); }, 100);
                        }
                        if (settings.openBotOnStartUp()) {
                            if (!this._hideUiOnInit) {
                                setTimeout(function (d) { return _this.loadBotPanel(); }, 100);
                            }
                        }
                        if (!loadedSomething) {
                            //---- load start-up file ----
                            this.loadInitialDataSet();
                        }
                    }
                }
                catch (error) {
                    this.showError(error);
                    this.finishInitAfterFileLoad();
                }
            }
        };
        appClass.prototype.loadBotPanel = function () {
            //---- start with bot open ----
            this.toggleBotPanel();
            //---- move to upper right of screen ----
            var botPanel = this._panelMaster.getJsonPanel("botPanel");
            var rightPanel = document.getElementById("rightPanel");
            var newPanelW = this.dockPanel(botPanel, rightPanel);
            newPanelW
                .height(150)
                .css("display", "");
            //var rootElem = botPanel.getRootElem();
            //vp.select(rootElem)
            //    .left(innerWidth - 420)
            //    .top(100);
        };
        appClass.prototype.dockPanel = function (panel, newParent) {
            var rootElem = panel.getRootElem();
            //---- hide title ----
            vp.select(rootElem, ".panelTitle")
                .css("display", "none");
            var firstChild = newParent.firstChild;
            var newPanelW = vp.select(firstChild).insertBefore(rootElem)
                .addClass("dockedPanel")
                .css("left", "0")
                .css("top", "0")
                .css("right", "0")
                .css("bottom", "0")
                .css("position", "static");
            return newPanelW;
        };
        appClass.prototype.getNameFromUrl = function (path) {
            var name = path;
            var index = name.lastIndexOf("/");
            if (index > -1) {
                name = name.substr(index + 1);
            }
            return name;
        };
        appClass.prototype.loadInitialDataSet = function () {
            var _this = this;
            var settings = this._appSettingsMgr;
            var wdp = settings.initialDataParams();
            //var strWdp = JSON.stringify(settings._initFileParams);
            //var wdp = <WorkingDataParams>vp.utils.parseJsonIntoObj(strWdp, new Preload());
            //---- cmd line URL overrides ----
            if (this._dataToLoadOnInit) {
                if (this._dataToLoadOnInit == "none") {
                    wdp = null;
                }
                else {
                    var name = this.getNameFromUrl(this._dataToLoadOnInit);
                    wdp = new beachParty.WorkingDataParams(name, this._dataToLoadOnInit, "url");
                }
            }
            if (!wdp) {
                //---- no data; make the UI visible now ----
                this.finishInitAfterFileLoad();
            }
            else {
                //---- we have an initial file to load ----
                var chart = this.currentChart();
                var dataMgr = this.getChartDataMgr();
                chart.autoLoadFile(wdp, function (dataFrame, dataMgr, wdParams) {
                    if (!dataFrame) {
                        //---- if cannot autoload LAST loaded file, fallback to default file ----
                        wdp = settings.getDefaultInitFile();
                        chart.autoLoadFile(wdp, function (dataFrame, dataMgr, wdParams) {
                            if (!dataFrame) {
                                _this.finishInitAfterFileLoad();
                            }
                        });
                    }
                });
            }
        };
        appClass.prototype.loadLastSession = function () {
            var preload = null;
            var strPreload = beachParty.localStorageMgr.get(beachParty.StorageType.sessionShare, beachParty.StorageSubType.lastSessionState, null);
            if (strPreload) {
                preload = JSON.parse(strPreload);
                if (preload) {
                    this.loadInsightCore(preload);
                }
            }
            return preload;
        };
        appClass.prototype.loadInsight = function () {
            var insight = this._insightMgr.currentInsight();
            if (insight) {
                this.loadInsightCore(insight);
                this.logAction(beachParty.Gesture.click, null, beachParty.ElementType.button, beachParty.Action.load, beachParty.Target.insight, true);
            }
        };
        appClass.prototype.onInsightLoadStarted = function () {
            //var svd = new SystemViewData();
            this._isLoggingEnabled = false;
            this._isInsightLoading = true;
            vp.utils.debug("setting _isInsightLoading = TRUE");
            //---- turn off auto draw of chart since we will be doing multiple async steps ----
            //---- this usually gets turned back on when we receive a "filterChanged" event from the engine ----
            this.currentChart().setAppAutoRebuild(false, false);
        };
        appClass.prototype.onInsightLoadCompleted = function () {
            this._isLoggingEnabled = true;
            this._isInsightLoading = false;
            vp.utils.debug("setting _isInsightLoading = FALSE");
            this._insightMgr.onInsightLoadCompleted();
            //---- force a chart draw & turn autoRebuild back on ----
            this.currentChart().setAppAutoRebuild(true, true, true); // true, false, true);
            //vp.utils.debug("---> onInsightLoadCompleted");
        };
        appClass.prototype.loadInsightCore = function (insight) {
            var _this = this;
            vp.utils.debug("loading insight: " + insight.name);
            this.onInsightLoadStarted();
            //---- supply a dataName so we can refer to this open data source when needed ----
            if (!insight.preload.dataName) {
                insight.preload.dataName = insight.name; //  insight.preload.name;
            }
            var loadData = (insight.loadAction == beachParty.LoadAction.all || insight.loadAction == beachParty.LoadAction.data
                || insight.loadAction == undefined);
            var preload = null;
            var data = null;
            var chart = this.currentChart();
            if (loadData) {
                if (insight.preload.dataName != chart.getFileName()) {
                    //---- clear local file data from last load ----
                    var dataMgr = this.getChartDataMgr();
                    dataMgr.loadedFileOpenText(null);
                    //---- change preload data to real object ----
                    preload = vp.utils.copyMapIntoObj(insight.preload, new beachParty.Preload(), true);
                    if (preload.fileSource == "local") {
                        var dataMgr = this.getChartDataMgr();
                        dataMgr.getLocalFileFromCache(preload, true);
                    }
                }
            }
            var svd = this.buildSystemViewData(insight);
            //---- this has been optimized to do ONE engine call to get all needed info to finish loading the insight ----
            var chart = this.currentChart();
            chart.setDataAndSystemView(data, preload, svd, function (msgBlock) {
                if (msgBlock.dataFrameLoadedMsgBlock) {
                }
                if (msgBlock.selectedChangedMsgBlock) {
                    _this.onSelectionChanged();
                }
                if (msgBlock.filterChangedMsgBlock) {
                    _this.postFilterChange();
                }
                _this.loadInsightPost(insight, msgBlock);
            });
        };
        appClass.prototype.buildSystemViewData = function (insight) {
            //---- load SYSTEM VIEW properties ----
            var svd = new beachParty.SystemViewData();
            var preload = insight.preload;
            var chart = this.currentChart();
            var selectionLocked = chart.isSelectionLocked();
            if (insight.loadAction == beachParty.LoadAction.selection && !selectionLocked) {
                svd.selectedKeys = preload.selectedKeys;
            }
            else if (insight.loadAction == beachParty.LoadAction.filter) {
                svd.filteredOutKeys = preload.filteredOutKeys;
            }
            else if (insight.loadAction == beachParty.LoadAction.all) {
                //----FULL LOAD of insight ----
                if (!selectionLocked) {
                    svd.selectedKeys = preload.selectedKeys;
                }
                svd.filteredOutKeys = preload.filteredOutKeys;
                svd.worldTransform = preload.worldTransform;
                svd.rotationInertia = preload.rotationInertia;
            }
            return svd;
        };
        appClass.prototype.loadInsightPost = function (insight, msgBlock) {
            //vp.utils.debug("--> loadInsightPost starting");
            if (insight.loadAction == beachParty.LoadAction.all || insight.loadAction == beachParty.LoadAction.view) {
                this.applyInsightViewParams(insight);
            }
            this._isInsightLoading = false;
            this.onInsightLoadCompleted();
            //---- update progress display ----
            var msg = "(" + (1 + this._insightMgr._playbackIndex) + "/" + this._insightMgr._session.insights.length + ")";
            vp.select("#insightProgress").text(msg);
            //vp.utils.debug("--> loadInsightPost ended.");
        };
        appClass.prototype.applyInsightViewParams = function (insight) {
            var preload = insight.preload;
            var settings = this._appSettingsMgr;
            vp.utils.debug("loadInsightPost: --> finished calling setSystemViewData");
            this.currentChart().applyInsightToChart(insight);
            //---- client-specific properties ----
            this.searchValue(insight.searchText);
            this.searchCol(insight.searchColumn);
            //this.isDetailsPanelOpen(insight.isDetailsPanelOpen);
            //this.isSortPanelOpen(insight.isSortPanelOpen);
            //this.isAppPanelOpen(insight.isAppPanelOpen);
            //this.isColorPanelOpen(insight.isColorPanelOpen);
            //this.isSlicerPanelOpen(insight.isSlicerPanelOpen);
            //this.isShowing3DWheel(insight.isShowing3DWheel);
            this.loadDataTips(preload.dataTips);
            //---- trigger dataChanged events for all insight loaded properties that appear in controls or panels ----
            this.onDataChanged(null);
        };
        appClass.prototype.openScrubberDialog = function (e) {
            var _this = this;
            //---- only open if not already open ----
            if (!this._scrubberDialog) {
                var chart = this.currentChart();
                var colInfos = chart.getColInfos();
                var origColInfos = chart.getOrigColInfos();
                this._scrubberDialog = new beachParty.scrubberDialogClass(this, origColInfos, colInfos);
                this._scrubberDialog.registerForChange("ok", function (e) {
                    var editInfos = _this._scrubberDialog.getEditInfos();
                    _this._fileOpenMgr.reloadDataPerScrubbing(editInfos, function (dataFrame, dataMgr, wdParams) {
                        //---- reload data with new fieldList ----
                        if (dataFrame) {
                            chart.onDataLoaded();
                        }
                        else {
                            //var dataMgr = this.getChartDataMgr();
                            dataMgr.loadData(wdParams, null);
                        }
                    });
                });
                this._scrubberDialog.registerForChange("close", function (e) {
                    _this._scrubberDialog = null;
                });
            }
        };
        appClass.prototype.closeScrubberDialog = function () {
            if (this._scrubberDialog) {
                this._scrubberDialog.close();
                this._scrubberDialog = null;
            }
        };
        appClass.prototype.loadDataTips = function (dataTips) {
            if (dataTips) {
                this._dataTipMgr.clearDataTips();
                for (var i = 0; i < dataTips.length; i++) {
                    var dtd = dataTips[i];
                    //---- todo: replace this._currentChart with the actual chart that is loading the data tips ----
                    var dataTip = this._dataTipMgr.addDataTip(this.currentChart(), dtd.title, dtd.colNames, dtd.includeNames, "chart1");
                    dataTip.setDataTipData(dtd);
                }
            }
        };
        appClass.prototype.isSlicerPanelOpen = function (value) {
            var isOpen = (this._slicerPanel != null);
            if (arguments.length == 0) {
                return isOpen;
            }
            if (value != isOpen) {
                this.toggleSlicerPanel(null);
            }
            this.onDataChanged("isSlicerPanelOpen");
        };
        /**
         * this is used by WinSandDance (SandDance.exe).
         * @param source
         * @param name
         * @param fn
         * @param delim
         * @param text
         */
        appClass.prototype.setDataFromHost = function (source, name, fn, delim, text) {
            var wdp = new beachParty.WorkingDataParams(name, fn, source);
            wdp.separator = delim;
            //---- for now, broadcast this to all charts ----
            for (var i = 0; i < this._charts.length; i++) {
                var chart = this._charts[i];
                var dataMgr = chart.getDataMgr();
                dataMgr.loadFrom(text, fn, wdp);
            }
        };
        appClass.prototype.getContextMenuItems = function (isDragSelecting) {
            var menuItems = [];
            if (isDragSelecting) {
                var mi = new beachParty.MenuItemData("Select", "Set the selection to the shapes bound by the rectangle", null, false);
                var mi = new beachParty.MenuItemData("Select additive", "Add the shapes bound by the rectangle to the selection", null, false);
                var mi = new beachParty.MenuItemData("Select subtractive", "Remove the shapes bound by the rectangle from the selection", null, false);
                var mi = new beachParty.MenuItemData("Select intersection", "Set the selection to the intersection of the current selection and the shapes bound by the rectangle", null, false);
                var mi = new beachParty.MenuItemData("Select non-intersection", "Set the selection to the union of current selection and the bound shapes, minus the intersection of the two", null, false);
                var mi = new beachParty.MenuItemData("-", "", null, false);
                var mi = new beachParty.MenuItemData("Data zoom", "Zoom-in on the data bound by the rectangle", null, true);
                menuItems.push(mi);
            }
            else {
                var mi = new beachParty.MenuItemData("3D wheel", "Show/hide the 3D wheel", null, false);
                menuItems.push(mi);
            }
            return menuItems;
        };
        /**
         *  Return build info & instancing info used by About Panel.
         */
        appClass.prototype.buildInfo = function () {
            var msg = "Build: " + appClass.buildId;
            return msg;
        };
        appClass.prototype.opsInfo = function () {
            var msgBlock = this._frameStatsMsgBlock;
            var chart = this.currentChart();
            var strVertexCount = vp.formatters.comma(msgBlock.totalVertexCount);
            var strMemUsage = vp.formatters.comma(msgBlock.bufferMemUsage / (1024 * 1024), 2) + " MB";
            var strItemCount = vp.formatters.comma(chart.getRecordCount());
            var strPrim = beachParty.DrawPrimitive[this.currentChart().getActualDrawingPrimitive()];
            var msg = "instancing: " + msgBlock.isInstancing + "<br/>";
            msg += "itemCount: " + strItemCount + "<br/>";
            msg += "drawPrimitive: " + strPrim + "<br/>";
            msg += "totalVertexCount: " + strVertexCount + "<br/>";
            msg += "bufferMemUsage: " + strMemUsage + "<br/>";
            return msg;
        };
        appClass.prototype.lastCycleInfo = function () {
            var msgBlock = this._frameStatsMsgBlock;
            var msg = "cmdTime: " + msgBlock.cmdTime + "<br/>";
            msg += "frameRate: " + msgBlock.lastCycleFrameRate + "<br/>";
            msg += "frameCount: " + msgBlock.lastCycleFrameCount + "<br/>";
            msg += "cycleNum: " + msgBlock.cycleNum + "<br/>";
            msg += "buildChartElapsed: " + msgBlock.buildChartElapsed + "<br/>";
            return msg;
        };
        appClass.prototype.buildChartDetail = function () {
            var msgBlock = this._frameStatsMsgBlock;
            var msg = "layout: " + msgBlock.layoutTime + "<br/>";
            msg += "glBufferFill: " + msgBlock.glBufferTime + "<br/>";
            msg += "glDraw: " + msgBlock.glDrawTime + "<br/>";
            return msg;
        };
        appClass.prototype.setContextMenu = function (pm) {
            if (this._activeContextMenu) {
                this._activeContextMenu.close();
            }
            this._activeContextMenu = pm;
        };
        appClass.prototype.closeContextMenu = function () {
            if (this._activeContextMenu) {
                this._activeContextMenu.hide();
                this._activeContextMenu = null;
            }
        };
        /**
         * Cmd line arguments:
            - reset=true    (resets all local storage - all app options and all other SandDance-related cached data)
            - data=xx       (specifies initial data file)
            - theme=xx      (specifies theme to use)
            - script=xx     (specifies script to load on init)
            - session=guid  (loads a set of insights from the bpServer)

            - edition=next  (specifies that certain in-progress features are visible)
            - zoom=1.5          (OBSOLETE - sets the current zoom factor in use)
            - animate=false     (turns off animation)
            - persistchanges=false      (turns off saving of app settings)
            - isbrowsercontrol=xx       (?)
         */
        appClass.prototype.processUrlParams = function () {
            var cmdParams = vp.utils.getUrlParams();
            var settings = this._appSettingsMgr;
            if (cmdParams) {
                var keys = vp.utils.keys(cmdParams);
                for (var k = 0; k < keys.length; k++) {
                    var rawKey = keys[k];
                    var value = cmdParams[rawKey];
                    var lowKey = rawKey.toLowerCase();
                    var boolValue = (value == "true");
                    if (lowKey == "reset" && boolValue) {
                        this.deleteLocalStorageInfo(false);
                    }
                    else if (lowKey == "theme") {
                        settings._initialTheme = value;
                    }
                    else if (lowKey == "external") {
                        this._forceExternalSession = boolValue;
                    }
                    else if (lowKey == "edition") {
                        this.setEdition(value);
                    }
                    else if (lowKey == "cmdserver") {
                        //---- value is the webSocket URL of the server to read cmds from (e.g., "ws://vibe10:81") ----
                        this._cmdServerUrl = value;
                    }
                    else if (lowKey == "session") {
                        //---- value is the GUID of the insights to load ----
                        this._initSessionId = value;
                    }
                    else if (lowKey == "insights") {
                        //---- alias for "session" ----
                        this._initSessionId = value;
                    }
                    else if (lowKey == "zoom") {
                        //---- programatically set the zoom (for taking snapshots) ----
                        document.body.style.zoom = value;
                    }
                    else if (lowKey == "cmds") {
                        this._serverCmds = value.split(";");
                    }
                    else if (lowKey == "animate") {
                        if (value == "false") {
                            this._animateDisabledFromUrlParams = true;
                        }
                    }
                    else if (lowKey == "persistchanges") {
                        if (value == "false") {
                            settings._persistChangesDisabledFromUrlParams = true;
                        }
                    }
                    else if (lowKey == "isbrowsercontrol") {
                    }
                    else if (lowKey == "hideui") {
                        this._hideUiOnInit = value;
                    }
                    else if (lowKey == "hidelogo") {
                        this._hideLogoOnInit = value;
                        this.showLogo(!value);
                    }
                    else if (lowKey == "data") {
                        this._dataToLoadOnInit = value;
                    }
                    else if (lowKey == "tour") {
                        this._tourToLoadOnInit = value;
                    }
                    else if (lowKey == "locale") {
                        this._initialLocale = value;
                    }
                    else {
                        throw "Error: unrecognized URL param=" + lowKey;
                    }
                }
            }
        };
        appClass.prototype.areLegendsEnabled = function (value) {
            this._areLegendsEnabled = value;
            this.showRightPanel(true);
        };
        appClass.prototype.setInsightTitleStyle = function (value) {
            var rule = ".insightNotes {" + value + "}";
            vp.dom.createStyleSheet(rule);
        };
        appClass.prototype.setAppBackgroundStyle = function (value) {
            var rule = ".appBody {" + value + "}";
            vp.dom.createStyleSheet(rule);
        };
        appClass.prototype.showLogo = function (value) {
            if (this._hideLogoOnInit || this._appSettingsMgr.isLogoHidden()) {
                value = false;
            }
            vp.select("#btLogo").css("display", (value) ? "" : "none");
        };
        /// this is called from:
        ///     - "?reset=true" as part of SandDance URL (deletes all info)
        ///     - when buildId of current build doesn't match buildId of app settings
        ///     - when user does "reset app settins" from settings dialog.
        ///
        appClass.prototype.deleteLocalStorageInfo = function (onlyAppSettings) {
            if (onlyAppSettings) {
                //---- for now, let's always zap everything ----
                beachParty.localStorageMgr.clearAll();
            }
            else {
                beachParty.localStorageMgr.clearAll();
            }
        };
        appClass.prototype.setEdition = function (value) {
            this._edition = value;
            //if (value == "server")
            //{
            //    vp.select("#btBeachParty")
            //        .text("BEACH PARTY SE")
            //        .css("color", "#0cf")
            //}
            //else if (value == "unlimited")
            //{
            //    vp.select("#btBeachParty")
            //        .text("BEACH PARTY UL")
            //        .css("color", "rgb(255,201,14)")
            //}
        };
        //onConditionalFormatTest(value?: boolean)
        //{
        //    if (arguments.length === 0)
        //    {
        //        return (!!this._currentColorMapping.customScalingCallback);
        //    }
        //    if (value)
        //    {
        //        var cbFunc = function (value)
        //        {
        //            return (value < 0) ? 2 : 1;
        //        };
        //        this._currentColorMapping.customScalingCallback = cbFunc.toString();
        //        this._currentColorMapping.colorPalette = ["red", "gray"];
        //    }
        //    else
        //    {
        //        this._currentColorMapping.customScalingCallback = null;
        //        this.buildColorPaletteFromSettings();
        //    }
        //    this.onColorMappingChanged(false);
        //}
        ///**
        // * Selected records are an array of primary key strings.  The app keeps a local copy for session
        //sharing purposes.
        // * @param value
        // */
        //getSelectedRecords()
        //{
        //    var chart = this.currentChart();
        //    return chart.getSelectedRecords();
        //    //if (arguments.length === 0)
        //    //{
        //    //    return this._selectedRecords;
        //    //}
        //    //this._selectedRecords = value;
        //    //this.onDataChanged("selectedRecords");
        //}
        appClass.prototype.slicerColName = function (value) {
            if (arguments.length === 0) {
                return this._slicerColName;
            }
            this._slicerColName = value;
            this.onDataChanged("slicerColName");
            this.rebinDataForSlicer();
        };
        appClass.prototype.rebinDataForSlicer = function () {
            var _this = this;
            var colName = this._slicerColName;
            //---- request binResult for colName ----
            var md = new beachParty.MappingData("none", colName);
            md.tagDelimiter = (this._slicerControl) ? this._slicerControl.tagDelimiter() : beachParty.TagDelimiter.none;
            var colInfo = this.getColInfo(colName);
            var isCategory = (md.forceCategory || colInfo.colType == "string");
            if (isCategory) {
                md.binSorting = beachParty.BinSorting.ascending;
                md.binCount = beachParty.chartClass.maxCategoryBins; // max category bins
            }
            this.currentChart().getBinData(md, function (msgBlock) {
                var binData = JSON.parse(msgBlock.param);
                _this.slicerData(binData);
                if (_this._slicerControl) {
                    _this._slicerControl.colName(colName);
                    if (_this._slicerInitialValue) {
                        _this._slicerControl.selectedValue(_this._slicerInitialValue);
                        _this._slicerInitialValue = null;
                    }
                }
            });
        };
        appClass.prototype.slicerData = function (value) {
            if (arguments.length === 0) {
                return this._slicerData;
            }
            this._slicerData = value;
            this.onDataChanged("slicerData");
        };
        //facetBinSorting(value?: BinSorting, disableNotify?: boolean)
        //{
        //    if (arguments.length === 0)
        //    {
        //        return this._facetMapping.binSorting;
        //    }
        //    this._facetMapping.binSorting = value;
        //    if (!disableNotify)
        //    {
        //        this.onFacetMappingChanged(false);
        //        this.onDataChanged("facetBinSorting");
        //        logAction(Gesture.select, "facetBins", ElementType.radioButton, Action.adjust, Target.sortParams, true, "facetBinSort",
        //            BinSorting[value]);
        //    }
        //}
        appClass.prototype.onItemsByColorClick = function () {
            this.currentChart().sortItemsByColor();
        };
        appClass.prototype.useCustomXBreaks = function () {
            return true;
        };
        appClass.prototype.customXBreaks = function () {
            return "";
        };
        appClass.prototype.resetMappingsForNewFile = function () {
            var isLoadingInsight = this._isInsightLoading;
            var defaultCols = null;
            var chart = this.currentChart();
            var colInfos = chart.getColInfos();
            if (colInfos && colInfos.length) {
                //---- get DEFAULT COLUMNS ----
                defaultCols = this.getDefaultXYZCols();
            }
            //----- RESET EACH CHART (until we have an association between this call and a chart) ----
            var charts = this._charts;
            for (var i = 0; i < charts.length; i++) {
                var chart = charts[i];
                chart.resetMappingsForNewFile(isLoadingInsight, defaultCols);
            }
            if (colInfos && colInfos.length) {
                //---- get DEFAULT COLUMNS ----
                this._defaultCol = defaultCols.x;
                this.searchCol(defaultCols.x);
                this.updatePanelColPickers(defaultCols.x);
            }
            else {
                this._defaultCol = null;
            }
            this._dataTipMgr.clearDataTips();
            if (!isLoadingInsight) {
                //this._sizeFactorByChart = {};
                //---- selection ----
                //chart.setSelectedRecords(null);
                //---- change to initial chart ----
                var settings = this._appSettingsMgr;
                var initChart = settings.initialChartType();
                if (initChart == "Custom") {
                    initChart = settings._predefinedCustomChart;
                }
                var preload = chart.getPreload();
                if (preload) {
                    if (preload.aggResult && preload.aggResult.wasAggregated) {
                        initChart = "AggColumn";
                    }
                }
                if (initChart) {
                    var initChartType = beachParty.chartClass.getChartTypeFromName(initChart, beachParty.LayoutType.Default);
                    for (var i = 0; i < charts.length; i++) {
                        var chart = charts[i];
                        chart.changeToChart(initChartType, null, beachParty.Gesture.system);
                    }
                }
            }
            this.applyDefaultBins();
            //---- update UI params ----
            this.onFilenameChanged();
            this.onRecordCountChanged();
            this.onSelectedCountChanged();
            this.onFilteredInCountChanged();
            this.updateUiAfterFileChange();
        };
        appClass.prototype.getDefaultCol = function () {
            return this._defaultCol;
        };
        appClass.prototype.updatePanelColPickers = function (defaultCol) {
            this.onDataChanged("ColInfos");
            ////---- clear open slicer controls ----
            //if (this._slicerControl)
            //{
            //    this.slicerColName(defaultCol);
            //}
        };
        //onClientFilterChange()
        //{
        //    //---- prevent chart from rebuilding until engine sends us new filter info ----
        //    this.setAppAutoRebuild(false, false);
        //}
        appClass.prototype.postFilterChange = function () {
            var chart = this.currentChart();
            var wasFilterReset = (chart.getRecordCount() == chart.getFilteredInCount());
            //---- when filter is reset, force new attribute mapping ----
            if (wasFilterReset) {
                if (this._colorMgr.colName()) {
                    //this.onColorMappingChanged(false, true);
                    this._colorMgr.onMappingChanged(true, true);
                }
                if (this._sizeMgr.colName()) {
                    this._sizeMgr.onMappingChanged(true);
                }
                if (this._shapeMgr.colName()) {
                    this._shapeMgr.onMappingChanged(true);
                }
            }
            if (this._facetMgr.colName()) {
                this._facetMgr.onMappingChanged(true);
            }
            if (this._insightWaitingForFilterChanged) {
                if (this._isInsightLoading) {
                    this._insightWaitingForFilterChanged = false;
                    this.onInsightLoadCompleted();
                }
            }
            else {
                this.currentChart().setAppAutoRebuild(true, true);
            }
        };
        appClass.prototype.chart = function (value) {
            var chart = this.currentChart();
            if (arguments.length == 0) {
                return chart.getUiChartName();
            }
            var chartType = beachParty.chartClass.getChartTypeFromName(value, beachParty.LayoutType.Default);
            chart.changeToChart(chartType);
        };
        appClass.prototype.registerStdPanels = function () {
            var _this = this;
            var pm = this._panelMaster;
            //---- TIME ----
            pm.registerPanel("timePanel", "bbTime", beachParty.ButtonAlign.belowButton, false, beachParty.Target.timePanel, false, function (openEvent) {
            }, function (closeEvent) {
            }, [this._timeMgr, this._appSettingsMgr, this]);
            //---- LAYERS ----
            pm.registerPanel("layersPanel", "bbLayers", beachParty.ButtonAlign.belowButton, false, beachParty.Target.navPanel, false, function (openEvent) {
            }, function (closeEvent) {
            }, [this._layersMgr, this.currentChart(), this._appSettingsMgr, this]);
            //---- NAV ----
            pm.registerPanel("navPanel", "navButton", beachParty.ButtonAlign.belowButton, true, beachParty.Target.navPanel, false, function (openEvent) {
                beachParty.appUtils.setButtonSelectedState(_this._themeMgr, "nav", true, beachParty.fnNav, beachParty.fnNavSelected);
                _this.currentChart().dragAction("select");
            }, function (closeEvent) {
                beachParty.appUtils.setButtonSelectedState(_this._themeMgr, "wheel", false, beachParty.fnNav, beachParty.fnNavSelected);
                _this.currentChart().dragAction("select");
            }, [this.currentChart(), this._appSettingsMgr, this]);
            //---- SETTINGS ----
            this._panelMaster.registerPanel("settingsPanel", "settingsButton", beachParty.ButtonAlign.belowButton, true, beachParty.Target.settingsPanel, false, function (openEvent) {
            }, function (closeEvent) {
            }, [this._appSettingsMgr, this]);
            //---- FILTER ----
            this._panelMaster.registerPanel("filterPanel", "bbFiltered", beachParty.ButtonAlign.belowButton, false, beachParty.Target.filterPanel, false, function (openEvent) {
            }, function (closeEvent) {
            }, [this._filterMgr, this]);
            //---- SELECTION ----
            this._panelMaster.registerPanel("selectionPanel", "bbSelected", beachParty.ButtonAlign.belowButton, false, beachParty.Target.selectionPanel, false, function (openEvent) {
            }, function (closeEvent) {
            }, [this._selectionMgr, this]);
            //---- ABOUT ----
            this._panelMaster.registerPanel("aboutPanel", "aboutButton", beachParty.ButtonAlign.belowButton, true, beachParty.Target.aboutPanel, false, function (openEvent) {
                _this.addMicrosoftFooterToPanel(openEvent.panel);
            }, function (closeEvent) {
            }, [this, this.currentChart(), this._appSettingsMgr]);
            //---- SORT ----
            this._panelMaster.registerPanel("sortPanel", "bbSort", beachParty.ButtonAlign.belowButton, false, beachParty.Target.sortPanel, false, function (openEvent) {
                //openEvent.panel.setLongListForSizing(".listBox", 110);
            }, function (closeEvent) {
            }, [this._chartRouter, this]);
            //---- X PANEL----
            this._panelMaster.registerPanel("xPanel", "bbX xButton", beachParty.ButtonAlign.belowButton, false, beachParty.Target.xPanel, false, function (openEvent) {
                _this._xMgr.updateAttrPanel(openEvent.panel);
            }, function (closeEvent) {
            }, [this._xMgr, this._appSettingsMgr]);
            //---- Y ----
            this._panelMaster.registerPanel("yPanel", "bbY yButton", null, false, beachParty.Target.yPanel, false, function (openEvent) {
                _this._yMgr.updateAttrPanel(openEvent.panel);
            }, function (closeEvent) {
            }, [this._yMgr, this._appSettingsMgr]);
            //---- Z ----
            this._panelMaster.registerPanel("zPanel", "bbZ zButton", null, false, beachParty.Target.zPanel, false, function (openEvent) {
                _this._zMgr.updateAttrPanel(openEvent.panel);
            }, function (closeEvent) {
            }, [this._zMgr, this._appSettingsMgr]);
            //---- IMAGE BY ----
            this._panelMaster.registerPanel("imagePanel", "bbImage", beachParty.ButtonAlign.belowButton, false, beachParty.Target.imagePanel, false, function (openEvent) {
                _this._imageMgr.updateAttrPanel(openEvent.panel);
            }, function (closeEvent) {
            }, [this._imageMgr, this._appSettingsMgr]);
            //---- FACET ----
            this._panelMaster.registerPanel("facetPanel", "bbFacet", beachParty.ButtonAlign.belowButton, false, beachParty.Target.facetPanel, false, function (openEvent) {
                //openEvent.panel.setLongListForSizing(".listBox", 110);
                _this._facetMgr.updateAttrPanel(openEvent.panel);
            }, function (closeEvent) {
            }, [this._facetMgr, this._appSettingsMgr]);
            //---- DETAILS ----
            this._panelMaster.registerPanel("detailsPanel", "detailsButton", beachParty.ButtonAlign.belowButton, true, beachParty.Target.detailsPanel, false, function (openEvent) {
                _this._detailsMgr.updateAttrPanel(openEvent.panel);
            }, function (closeEvent) {
                _this._detailsMgr.onClose();
            }, [this._detailsMgr, this._appSettingsMgr, this], -1);
            //---- COLOR BY ----
            this._panelMaster.registerPanel("colorPanel", "bbColor colorLegendTitle", beachParty.ButtonAlign.belowButton, false, beachParty.Target.colorPanel, false, function (openEvent, isFromLegend) {
                _this._bigBarMgr.onColorPanelOpened(openEvent.panel, isFromLegend);
            }, function (closeEvent) {
            }, [this._colorMgr, this._appSettingsMgr]);
            //---- SIZE BY ----
            this._panelMaster.registerPanel("sizePanel", "bbSize sizeLegendTitle", beachParty.ButtonAlign.belowButton, false, beachParty.Target.sizePanel, null, function (openEvent) {
                _this._sizeMgr.updateAttrPanel(openEvent.panel);
            }, function (closeEvent) {
            }, [this._sizeMgr, this._appSettingsMgr, this]);
            //---- SUM BY ----
            this._panelMaster.registerPanel("sumPanel", "bbSum yButton", beachParty.ButtonAlign.belowButton, false, beachParty.Target.sumPanel, false, function (openEvent) {
                //openEvent.panel.setLongListForSizing(".listBox", 150);
            }, function (closeEvent) {
            }, [this._auxMgr, this._appSettingsMgr, this]);
            //---- TEXT BY ----
            this._panelMaster.registerPanel("textPanel", "bbText", null, false, beachParty.Target.textPanel, false, function (openEvent) {
                //openEvent.panel.setLongListForSizing(".listBox", 110);
            }, function (closeEvent) {
            });
            //---- LINE BY ----
            this._panelMaster.registerPanel("lineByPanel", "bbLine", null, false, beachParty.Target.lineByPanel, false, function (openEvent) {
                //openEvent.panel.setLongListForSizing(".listBox", 110);
            }, function (closeEvent) {
            }, [this._layersMgr, this._appSettingsMgr, this]);
            //---- SHAPE BY ----
            this._panelMaster.registerPanel("shapePanel", "bbShape shapeLegendTitle", beachParty.ButtonAlign.belowButton, false, beachParty.Target.shapePanel, null, function (openEvent) {
                //this.onShapeOpened(openEvent.panel, isFromLegend);
            }, function (closeEvent) {
            }, [this._shapeMgr, this._appSettingsMgr, this]);
        };
        appClass.prototype.colorColumn = function () {
            return this._colorMgr.colName();
        };
        appClass.prototype.registerMgrPanels = function () {
            var _this = this;
            //---- CLUSTER ----
            this._panelMaster.registerPanelMgr("clusterPanel", "clusterButton", beachParty.ButtonAlign.belowButton, true, beachParty.Target.clusterPanel, false, function (createEvent) {
                var columns = _this.currentChart().getAxisColumnsInCurrentChart();
                var cp = new beachParty.clusterPanelMgrClass(_this, "clusterButton", columns, 5);
                return cp;
            }, function (closeEvent) {
            });
            //---- TIPS ----
            this._panelMaster.registerPanelMgr("tipsPanel", "tipsButton", beachParty.ButtonAlign.belowButton, true, beachParty.Target.tipsPanel, false, function (createEvent) {
                var tipsPanel = new beachParty.tipsPanelMgr(_this, "tipsButton");
                tipsPanel.tooltipColumns(_this.currentChart().tooltipColumns());
                tipsPanel.registerForChange("tooltipColumns", function (e) {
                    _this.currentChart().tooltipColumns(tipsPanel.tooltipColumns());
                });
                return tipsPanel;
            }, function (closeEvent) {
            });
            //---- SIMPLE SEARCH ----
            this._panelMaster.registerPanelMgr("searchPanel", "searchButton", beachParty.ButtonAlign.belowButton, true, beachParty.Target.searchPanel, false, function (createEvent) {
                var dm = new beachParty.searchPanelMgr(_this, "searchButton", _this._xMgr.colName());
                return dm;
            }, function (closeEvent) {
            });
            //---- BROWSE ----
            this._panelMaster.registerPanelMgr("browsePanel", "browseButton", beachParty.ButtonAlign.belowButton, true, beachParty.Target.browsePanel, false, function (createEvent) {
                var dm = new beachParty.browsePanelMgr(_this, "browseButton", _this._xMgr.colName());
                return dm;
            }, function (closeEvent) {
            });
            //---- TOUR RUNNER ----
            this._panelMaster.registerPanelMgr("tourPanel", "", beachParty.ButtonAlign.belowButton, true, beachParty.Target.tourLoaderPanel, false, function (createEvent) {
                var dm = new beachParty.tourPanelMgr(_this, "tourButton", null);
                return dm;
            }, function (closeEvent) {
            }, function (openEvent) {
                openEvent.panelMgr.centerPanel();
            });
            //---- TOUR LOADER ----
            this._panelMaster.registerPanelMgr("tourLoaderPanel", "tourButton", beachParty.ButtonAlign.belowButton, true, beachParty.Target.tourLoaderPanel, false, function (createEvent) {
                var dm = new beachParty.tourLoaderMgr(_this, "tourButton");
                return dm;
            }, function (closeEvent) {
            });
            //---- HELP ----
            this._panelMaster.registerPanelMgr("helpPanel", "helpButton", beachParty.ButtonAlign.belowButton, true, beachParty.Target.helpPanel, false, function (createEvent) {
                _this._appSettingsMgr.openBotOnStartUp(true);
                var dm = new beachParty.helpPanelMgrClass(_this, "helpButton");
                return dm;
            }, function (closeEvent) {
                _this._appSettingsMgr.openBotOnStartUp(false);
            });
            //---- BOT ----
            this._panelMaster.registerPanelMgr("botPanel", "botButton", beachParty.ButtonAlign.belowButton, true, beachParty.Target.botPanel, false, function (createEvent) {
                //this._appSettingsMgr.openBotOnStartUp(true);
                var dm = new beachParty.botPanelMgrClass(_this, "botButton");
                return dm;
            }, function (closeEvent) {
                //this._appSettingsMgr.openBotOnStartUp(false);
            });
            //---- SCRIPTS ----
            this._panelMaster.registerPanelMgr("scriptsPanel", "scriptsButton", beachParty.ButtonAlign.belowButton, true, beachParty.Target.scriptsPanel, false, function (createEvent) {
                var dm = new beachParty.scriptsPanelMgr(_this, "scriptsButton");
                return dm;
            }, function (closeEvent) {
            });
            //---- THEMES ----
            this._panelMaster.registerPanelMgr("themesPanel", "themesButton", beachParty.ButtonAlign.belowButton, true, beachParty.Target.themesPanel, false, function (createEvent) {
                var dm = new beachParty.themesPanelMgr(_this, "themesButton");
                return dm;
            }, function (closeEvent) {
            });
            //---- AGG ----
            this._panelMaster.registerPanelMgr("aggPanel", "aggButton", beachParty.ButtonAlign.belowButton, true, beachParty.Target.aggPanel, false, function (createEvent) {
                var dm = new beachParty.aggPanelMgr(_this, "aggButton");
                return dm;
            }, function (closeEvent) {
            });
            //---- PALETTES ----
            this._panelMaster.registerPanelMgr("palettesPanel", "palettesButton", beachParty.ButtonAlign.belowButton, true, beachParty.Target.palettesPanel, false, function (createEvent) {
                var dm = new beachParty.palettesPanelMgr(_this, "palettesButton");
                return dm;
            }, function (closeEvent) {
            });
            ////---- CHART PICKER ----
            //this._panelMaster.registerPanelMgr("chartPicker", "bbView", ButtonAlign.belowButton, false,
            //    Target.chartPicker, false,
            //    (createEvent) =>
            //    {
            //        var chartPicker = this._bigBarMgr.createChartPicker();
            //        return chartPicker;
            //    },
            //    (closeEvent) =>
            //    {
            //    });
            //---- TASKS ----
            this._panelMaster.registerPanelMgr("tasksPanel", "tasksButton", beachParty.ButtonAlign.belowButton, false, beachParty.Target.tasksPanel, false, function (createEvent) {
                var tasksPanel = new beachParty.tasksPanelMgrClass(_this, "tasksButton");
                return tasksPanel;
            }, function (closeEvent) {
            });
            //---- ITEMS ----
            this._panelMaster.registerPanelMgr("itemsPanel", "bbItems titleItemCount", beachParty.ButtonAlign.belowButton, true, beachParty.Target.itemsPanel, false, function (createEvent) {
                var dm = new beachParty.itemsPanelMgr(_this, "bbItems titleItemCount");
                return dm;
            }, function (closeEvent) {
            });
            //---- VIEW ----
            this._panelMaster.registerPanelMgr("viewAsPanel", "bbView", beachParty.ButtonAlign.belowButton, true, beachParty.Target.itemsPanel, false, function (createEvent) {
                var chart = _this.currentChart();
                var dm = new beachParty.viewPanelMgrClass(_this, "bbView", chart.getUiChartName(), chart.isChartCustom(), function (uiName) {
                    _this._bigBarMgr.onChartPicked(uiName);
                });
                return dm;
            }, function (closeEvent) {
            }, null);
        };
        appClass.prototype.toggleNavPanel = function (e) {
            this._panelMaster.togglePanel("navPanel", e);
        };
        appClass.prototype.showBigBar = function (value) {
            this._bigBarMgr.show(value);
        };
        appClass.prototype.onLockSelection = function (e) {
            var value = e.target.checked;
            var chart = this.currentChart();
            chart.isSelectionLocked(value);
        };
        appClass.prototype.onWheelUp = function (e) {
            //var elapsed = vp.utils.now() - this._wheelDownTime;
            //if (elapsed > 1000)
            //{
            //    //---- restore previous visiblity ----
            //    this.isShowing3DWheel(!this._isShowing3DWheel);
            //}
        };
        appClass.prototype.buildShapePalette = function (steps) {
            //---- the default image palette, for now ----
            //var palette = ["filled circle", "filled square", "filled triangle", "circle", "square", "triangle"];
            //---- local photo-based images (test) ----
            var palette = [];
            for (var i = 1; i < 18; i++) {
                palette.push("p" + i);
            }
            if (steps < palette.length) {
                palette = palette.slice(0, steps);
            }
            return palette;
        };
        appClass.prototype.setMappingDataFormatting = function (md) {
            var formatting = null;
            if (md.colName) {
                var dataFrame = this.getChartDataMgr().getDataFrame();
                var pf = dataFrame.getPreloadField(md.colName);
                if (pf) {
                    formatting = pf.formatting;
                }
            }
            md.formatting = formatting;
        };
        appClass.prototype.buildSizePalette = function (steps) {
            //---- the default image palette, for now ----
            var incr = 1 / steps;
            var palette = [];
            for (var i = 1; i <= steps; i++) {
                palette.push(i * incr);
            }
            return palette;
        };
        appClass.prototype.getColInfo = function (colName, ignoreCase) {
            var colInfo = null;
            var chart = this.currentChart();
            var colInfos = chart.getColInfos();
            if (ignoreCase) {
                colName = colName.toLowerCase();
            }
            if (colInfos) {
                for (var i = 0; i < colInfos.length; i++) {
                    var ci = colInfos[i];
                    var name = (ignoreCase) ? (ci.name.toLowerCase()) : ci.name;
                    if (name == colName) {
                        colInfo = ci;
                        break;
                    }
                }
            }
            return colInfo;
        };
        appClass.prototype.colNames = function (includeSysCols) {
            var names = [];
            var chart = this.currentChart();
            var colInfos = chart.getColInfos();
            if (colInfos) {
                for (var i = 0; i < colInfos.length; i++) {
                    var name = colInfos[i].name;
                    if (!name.startsWith("_") || includeSysCols) {
                        names.push(name);
                    }
                }
            }
            return names;
        };
        appClass.prototype.getColType = function (colName) {
            var colInfo = this.getColInfo(colName);
            var colType = (colInfo) ? colInfo.colType : null;
            return colType;
        };
        appClass.prototype.manualLayoutForYStuff = function () {
            var rc = vp.select("#yText").getBounds();
            var textHeight = (rc) ? rc.height : 0;
            var textWidth = (rc) ? rc.width : 0;
            //---- adjust position of chevron due to y text rotation ----
            var chevTop = textHeight / 2 - 15;
            vp.select("#yChevron")
                .css("position", "relative")
                .css("left", "35px")
                .css("top", chevTop + "px");
            //---- adjust yButton to correct size, so that background (hover) will cover the text and chevron correctly ----
            var buttonTop = -(10 + textHeight / 2);
            vp.select("#yButton")
                .css("height", (textHeight + 12) + "px") // padding-top=6, padding-bottom=6
                .css("width", (textWidth + 8) + "px") // padding-left=4, padding-right=4
                .css("position", "relative")
                .css("left", "0px");
            vp.select("#yButtonOuter")
                .css("margin-top", (buttonTop) + "px"); // + 55
            //---- adjust position of y bin numAdjuster to be under the name ----
            var binTop = 6; //(textHeight / 2) - 20;
            vp.select("#yBins")
                .css("top", binTop + "px");
            //.css("left", "2px")
        };
        //onAppShapeOpacityChanged()
        //{
        //    if (this._vsCurrent)
        //    {
        //        var settings = this._appSettingsMgr;
        //        this._vsCurrent.shapeOpacity = settings._shapeOpacity;
        //    }
        //}
        appClass.prototype.onAppPlaybackDurationChanged = function () {
            var settings = this._appSettingsMgr;
            this._insightMgr.playbackDuration(settings._playbackDuration);
        };
        appClass.prototype.onAppPlaybackLoopngChanged = function () {
            var settings = this._appSettingsMgr;
            this._insightMgr.isPlaybackLooping(settings._isPlaybackLooping);
        };
        appClass.prototype.infoMsg = function (msg) {
            this.showInfoMsg("Information", msg);
        };
        appClass.prototype.showError = function (msg) {
            //---- keep track of all errors encountered in this session ----
            this._errorCount++;
            if (msg.name !== undefined && msg.message !== undefined) {
                //---- from try/catch error object ----
                msg = msg.name + "\r\n" + msg.message;
            }
            else if (msg.errorMsg !== undefined && msg.errorUrl !== undefined) {
                //---- from engineError (appMgr.onerror) ----
                msg = msg.errorMsg + "\r\nLine " + msg.errorLineNum + " in " + msg.errorUrl;
            }
            //---- remove "Error: " suffix since we will use the title to display that ----
            if (msg.startsWith("Error: \r\n")) {
                msg = msg.substr(7).trim();
            }
            if (msg.startsWith("\r\n")) {
                msg = msg.substr(2).trim();
            }
            this.showInfoMsg("Error", msg);
        };
        appClass.prototype.showInfoMsg = function (title, msg, timeout) {
            var _this = this;
            vp.select("#infoMsgTitle")
                .text(title);
            if (!timeout && title.startsWith("Info")) {
                timeout = 4000;
            }
            var str = msg.replace(/\r\n/g, "<br />");
            vp.select("#infoMsgText").html(str);
            var boxW = vp.select("#infoMsgBox")
                .css("max-width", (window.innerWidth - 100) + "px");
            if (this._isFirstInfoBox) {
                //chartUtils.fadeIn(boxW[0], 500);
                this._isFirstInfoBox = false;
            }
            else {
                beachParty.chartUtils.fadeIn(boxW[0], 350);
            }
            if (timeout) {
                //---- set timer to hide after specifed ms ----
                this.cancelErrorTimer();
                this._infoMsgTimer = setTimeout(function (e) {
                    _this.hideInfoMsg();
                }, timeout);
            }
        };
        appClass.prototype.cancelErrorTimer = function () {
            if (this._infoMsgTimer) {
                clearTimeout(this._infoMsgTimer);
                this._infoMsgTimer = null;
            }
        };
        appClass.prototype.openErrorPanel = function () {
            var left = 300;
            var top = 100;
            var errorPanel = beachParty.buildJsonPanel(this, null, this, "errorPanel", true, left, top, undefined, undefined);
        };
        appClass.prototype.searchCol = function (value) {
            if (arguments.length === 0) {
                return this._searchCol;
            }
            if (value != this._searchCol) {
                this._searchCol = value;
                //this._currentChart.search(this._searchCol, this._searchValue);
                vp.select("#searchCol")
                    .text(value);
                this.onDataChanged("searchCol");
                this.onSearchParamsChanged();
            }
        };
        appClass.prototype.searchValue = function (legendSource, value, searchType, forceSet, selectMode) {
            if (searchType === void 0) { searchType = beachParty.TextSearchType.startsWith; }
            if (arguments.length === 0) {
                return this._searchValue;
            }
            if (forceSet || value != this._searchValue) {
                value = value || "";
                this._searchValue = value;
                this.onSearchParamsChanged(searchType, selectMode);
                this.onDataChanged("searchValue");
            }
        };
        appClass.prototype.onSearchParamsChanged = function (searchType, selectMode) {
            if (searchType === void 0) { searchType = beachParty.TextSearchType.startsWith; }
            if (this._searchValue) {
                this.currentChart().search(this._searchCol, this._searchValue, null, searchType, beachParty.SearchAction.selectMatches, undefined, undefined, selectMode);
            }
        };
        appClass.prototype.createShapesUrl = function (shapeTypes) {
            var count = shapeTypes.length;
            var szPixels = 32;
            var width = szPixels * count;
            var height = szPixels;
            //---- create canvas we can draw on ----
            var canvasW = vp.select(document.body).append("canvas")
                .attr("width", width)
                .attr("height", height);
            //---- get drawing context ----
            var canvas = canvasW[0];
            var ctx = canvas.getContext("2d");
            //---- draw the circle ----
            ctx.clearRect(0, 0, width, height);
            var x = 0;
            var y = 0;
            for (var i = 0; i < shapeTypes.length; i++) {
                var shapeType = shapeTypes[i];
                this.drawShapeType(ctx, shapeType, x, y, szPixels, szPixels);
                x += szPixels;
            }
            var imgSrc = canvas.toDataURL();
            //---- remove the canvas ----
            document.body.removeChild(canvas);
            return imgSrc;
        };
        appClass.prototype.drawShapeType = function (ctx, shapeType, x, y, width, height) {
            if (shapeType == "filled square") {
            }
            // var r = size / 2 - strokeSize / 2;
            //ctx.beginPath();
            //ctx.arc(size / 2, size / 2, r, 0, 2 * Math.PI, false);
            //if (strokeSize != 0)
            //{
            //    ctx.lineWidth = strokeSize;
            //    ctx.strokeStyle = "white";
            //    ctx.stroke();
            //}
            //else
            //{
            //    ctx.fillStyle = "white";
            //    ctx.fill();
            //    //ctx.font = "50px Tahoma";
            //    //ctx.fillText("x", 0, 0);
            //}
        };
        appClass.prototype.buildLegends = function () {
            var _this = this;
            //---- COLOR legend ----
            var colorLegend = new beachParty.colorLegendClass(this._chartRouter, "colorLegend");
            this._colorLegend = colorLegend;
            //---- connect to a colorMgr "mappingData()" function so we can find the current colorMgr and route event to him ----
            beachParty.connectModelView(this._colorMgr, "mappingData", colorLegend, "colorMapping");
            colorLegend.onPanelRequest.attach(this, function (map) {
                beachParty.chartUtils.callPanelOpen(map.e, function (e) {
                    _this._bigBarMgr.toggleColorPanel(null, true);
                });
            });
            colorLegend.onSearchRequest.attach(this, function (map) {
                var chart = _this.currentChart();
                chart.doSearch(map.legendName, map.colName, map.fromValue, map.toValue, map.searchType, map.selectMode, map.selectKey);
            });
            //---- rebuild legend with this option changes ----
            this._colorMgr.registerForChange("isLegendBottomUp", function (e) { return _this._colorLegend.rebuildLegend(); });
            //---- SIZE legend ----
            var sizeLegend = new beachParty.sizeLegendClass(this._chartRouter, "sizeLegend");
            this._sizeLegend = sizeLegend;
            sizeLegend.onPanelRequest.attach(this, function (map) {
                beachParty.chartUtils.callPanelOpen(map.e, function (e) {
                    _this._bigBarMgr.toggleSizePanel(null, true);
                });
            });
            beachParty.connectModelView(this._sizeMgr, "mappingData", sizeLegend, "sizeMapping");
            //---- rebuild legend with this option changes ----
            this._sizeMgr.registerForChange("isLegendBottomUp", function (e) { return _this._sizeLegend.rebuildLegend(); });
            //---- SHAPE legend ----
            var shapeLegend = new beachParty.shapeLegendClass(this._chartRouter, "shapeLegend");
            this._shapeLegend = shapeLegend;
            shapeLegend.onPanelRequest.attach(this, function (map) {
                beachParty.chartUtils.callPanelOpen(map.e, function (e) {
                    _this._bigBarMgr.toggleShapePanel(null, true);
                });
            });
            beachParty.connectModelView(this._shapeMgr, "mappingData", shapeLegend, "shapeMapping");
            //---- rebuild legend with this option changes ----
            this._shapeMgr.registerForChange("isLegendBottomUp", function (e) { return _this._shapeLegend.rebuildLegend(); });
            //---- TEXT legend ----
            var textLegend = new beachParty.textLegendClass("textLegend", this._textMgr.mappingData());
            this._textLegend = textLegend;
            beachParty.connectModelView(this._textMgr, "mappingData", textLegend, "textMapping");
            ////---- FACET legend ----
            //var facetLegend = new facetLegendClass("facetLegend", this._facetMapping);
            //this._facetLegend = facetLegend;
            //facetLegend.registerForChange("facetColPickerRequest", (e) =>
            //{
            //    this.onFacetClick(e);
            //});
            ////---- for now, don't show facet legend ----
            //connectModelView(this, "facetMapping", facetLegend, "facetMapping");
        };
        appClass.prototype.rebuildLegends = function () {
            if (this._colorLegend) {
                this._colorLegend.rebuildLegend();
            }
            if (this._sizeLegend) {
                this._sizeLegend.rebuildLegend();
            }
            if (this._shapeLegend) {
                this._shapeLegend.rebuildLegend();
            }
        };
        appClass.prototype.loadAutomatedTest = function () {
        };
        //loadAutomatedTest()
        //{
        //    localFileHelper.loadFile(".json", (text, fn) => 
        //    {
        //        try
        //        {
        //            var testObj = JSON.parse(text);
        //            settings.automatedTestName(fn);
        //        }
        //        catch (ex)
        //        {
        //            throw ("Error parsing test file: " + ex);
        //        }
        //    });
        //    settings.automatedTestName("beachPartyTest");
        //}
        appClass.prototype.buildBinAdjusters = function () {
            var settings = this._appSettingsMgr;
            //---- X bins ----
            var xBins = this._xMgr.binCount();
            this._xBinAdjuster = beachParty.createNumAdjusterClass(this, "xBins", "", xBins, 0, 999, "The number of X-axis bins to create.", beachParty.AdjusterStyle.bottom, true, false, true, 120, true, false, { Auto: 0 });
            beachParty.connectModelView(this._xMgr, "sliderBinCount", this._xBinAdjuster, "value");
            //---- Y bins ----
            var yBins = this._yMgr.binCount();
            this._yBinAdjuster = beachParty.createNumAdjusterClass(this, "yBins", "", yBins, 0, 999, "The number of Y-axis bins to create.", beachParty.AdjusterStyle.left, true, false, true, 120, true, false, { Auto: 0 });
            beachParty.connectModelView(this._yMgr, "sliderBinCount", this._yBinAdjuster, "value");
            //---- Z bins ----
            var zBins = this._zMgr.binCount();
            this._zBinAdjuster = beachParty.createNumAdjusterClass(this, "zBins", "Stacks:", zBins, 1, 10, "The number of z bins to create.", beachParty.AdjusterStyle.left, true, false, false, 80, true, false);
            beachParty.connectModelView(this._zMgr, "sliderBinCount", this._zBinAdjuster, "value");
        };
        appClass.prototype.isLoggingEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isLoggingEnabled;
            }
            this._isLoggingEnabled = value;
            this.onDataChanged("isLoggingEnabled");
        };
        appClass.prototype.logAction = function (gesture, elementId, elementType, action, target, isUndoable, options, forceLog, nonLogOptions) {
            var _this = this;
            //---- only log when past first data load and outside of a "load insight" operation ----
            if (forceLog || this._isLoggingEnabled) {
                var sessionId = this._machineId + "-" + appClass.buildId + "-" + this._sessionId;
                var strGesture = beachParty.Gesture[gesture];
                var strElementType = beachParty.ElementType[elementType];
                var strAction = beachParty.Action[action];
                var strTarget = beachParty.Target[target];
                if (!options) {
                    options = {};
                }
                // restore this TODO: fixme
                this.logActionToAzureInsights(sessionId, strGesture, elementId, strElementType, strAction, strTarget, options);
                //---- build "tip" for insight and debugging ----
                var tip = strAction + "-" + strTarget;
                //---- now that we have logged our info, we can append the nonLogOptions ----
                //--- "nonLogOptions" contains personal user info that cannot be logged (for privacy protection), but its OK to record it for cmd playback ----
                //---- TODO: should we make it explicit to user that when recording scripts or using remote commands, private info may be recorded in files & transmitted on network? ----
                if (nonLogOptions) {
                    var keys = vp.utils.keys(nonLogOptions);
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        var value = nonLogOptions[key];
                        options[key] = value;
                    }
                }
                if (options) {
                    var keys = vp.utils.keys(options);
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        var value = options[key];
                        tip = this.appendTip(tip, key, value);
                    }
                }
                if (target != beachParty.Target.frameStats) {
                    vp.utils.debug("logAction: tip=" + tip);
                }
                var settings = this._appSettingsMgr;
                var recordNav = settings.isPanelNavRecorded();
                var recorder = this._scriptRecorder;
                var chart = this.currentChart();
                var hasCmdServer = (this._hasCmdServer && chart && this._isUiVisible);
                if (gesture != beachParty.Gesture.system && (recordNav || isUndoable || hasCmdServer)) {
                    if ((recorder && recorder.isRecording()) || hasCmdServer) {
                        //---- record user cmd ----
                        var cmd = new beachParty.ScriptCmd(action, target);
                        if (options) {
                            var keys = vp.utils.keys(options);
                            for (var i = 0; i < keys.length; i++) {
                                var key = keys[i];
                                var value = options[key];
                                cmd[key] = value;
                            }
                        }
                        if (cmd) {
                            if (recordNav) {
                                recorder.log(cmd);
                            }
                            else if (hasCmdServer) {
                                this.sendCmdToServer(cmd);
                            }
                        }
                    }
                    //---- don't try to create an insight if no data has been loaded ----                
                    if (chart && chart.hasData() && this._undoMgr) {
                        this.createInsight(beachParty.SnapshotType.none, false, function (insight) {
                            _this._undoMgr.push(insight, tip);
                        });
                    }
                }
            }
        };
        appClass.prototype.logActionToAzureInsights = function (sessionId, gesture, elementId, elementType, action, target, options) {
            var anyWindow = window;
            var appInsightsObj = anyWindow.appInsights;
            if (appInsightsObj) {
                var props = {};
                props.sessionId = sessionId;
                props.gesture = gesture;
                props.elementId = elementId;
                props.target = target;
                props.timeStamp = +Date.now();
                if (options) {
                    var keys = vp.utils.keys(options);
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        var value = options[key];
                        props[key] = value;
                    }
                }
                appInsightsObj.trackEvent(action, props);
            }
        };
        appClass.prototype.sendCmdToServer = function (cmd) {
            if (this._webSocketConnected && cmd.action != "start") {
                var str = JSON.stringify(cmd);
                //---- don't send our current cmd that we received (avoid loops) ----
                if (!this._scriptRunner || str != this._scriptRunner.currentCmd()) {
                    this._webSocket.send(str);
                }
            }
        };
        appClass.prototype.appendTip = function (tip, name, value) {
            if (!tip.contains("=")) {
                tip += ": ";
            }
            else {
                tip += ", ";
            }
            tip += name + "=" + value;
            return tip;
        };
        appClass.prototype.requestFullChartBuild = function () {
            this._xMgr.onMappingChanged(); // will trigger full build
        };
        appClass.prototype.toggleSettingsPanel = function (e) {
            this._panelMaster.togglePanel("settingsPanel", e);
        };
        appClass.prototype.toggleAboutPanel = function (e, fromButton) {
            if (fromButton === void 0) { fromButton = "aboutButton"; }
            var chart = this.currentChart();
            if (!chart.isVisible()) {
                this.makeUIVisible(); // in case we are stuck without UI (error during startup)
            }
            else {
                this._panelMaster.togglePanel("aboutPanel", e);
            }
        };
        appClass.prototype.addMicrosoftFooterToPanel = function (panel) {
            var contentW = vp.select(panel.getTabContentRoot("tab0"));
            var footerW = contentW.append("div")
                .css("margin-top", "20px")
                .css("margin-bottom", "10px");
            var spanHolderW = footerW.append("div")
                .css("text-align", "center")
                .css("position", "relative");
            //---- CONTACT US ----
            spanHolderW.append("a")
                .addClass("panelLink footerLink")
                .text("Contact us")
                .attr("target", "_blank")
                .attr("href", "mailto:sanddance@microsoft.com");
            //---- PRIVAVY & COOKIES ----
            spanHolderW.append("a")
                .addClass("panelLink footerLink")
                .text("Privacy & cookies")
                .attr("target", "_blank")
                .attr("href", "http://go.microsoft.com/fwlink/?LinkId=521839");
            //---- TERMS OF USE ----
            spanHolderW.append("a")
                .addClass("panelLink footerLink")
                .text("Terms of use")
                .attr("target", "_blank")
                .attr("href", "http://go.microsoft.com/fwlink/?LinkID=206977");
            //---- TRADEMARKS ----
            spanHolderW.append("a")
                .addClass("panelLink footerLink")
                .text("Trademarks")
                .attr("target", "_blank")
                .attr("href", "http://go.microsoft.com/fwlink/?LinkID=506942");
            //---- COPYRIGHT ----
            spanHolderW.append("a")
                .addClass("panelLink footerLink")
                .html("&copy;2016 Microsoft")
                .attr("target", "_blank")
                .attr("href", "http://microsoft.com");
            //---- MICROSOFT LOGO ----
            var anchorW = spanHolderW.append("a")
                .css("position", "relative")
                .css("top", "6px")
                .css("left", "10px")
                .attr("href", "http://microsoft.com");
            anchorW.append("img")
                .attr("src", "http://research.microsoft.com/a/i/c/ms-logo.png");
        };
        /** At some point, we might want to support opening of multiple slicer panels. */
        appClass.prototype.onSlicerClick = function (e) {
            this.toggleSlicerPanel(e);
        };
        appClass.prototype.toggleSlicerPanel = function (e) {
            var isOpen = this.isSlicerPanelOpen();
            if (isOpen) {
                this.closeSlicerPanel();
                var action = beachParty.Action.close;
            }
            else {
                this.openSlicerPanel(e);
                var action = beachParty.Action.open;
            }
            if (e) {
                this.logAction(beachParty.Gesture.click, e.target.id, beachParty.ElementType.button, action, beachParty.Target.slicerPanel, true);
            }
        };
        appClass.prototype.openSlicerPanel = function (e) {
            var colName = vp.select("#searchCol").text();
            this.openSlicerCore(colName);
        };
        appClass.prototype.openSlicerCore = function (colName, value, toggleOpen) {
            var _this = this;
            if (toggleOpen === void 0) { toggleOpen = true; }
            var rc = vp.select("#slicerButton").getBounds(false);
            var right = rc.right;
            var top = rc.bottom;
            this.slicerColName(colName);
            this._slicerInitialValue = value;
            var panel = beachParty.buildJsonPanel(this, null, this, "slicerPanel", true, undefined, top, right, undefined, toggleOpen);
            this._slicerPanel = panel;
            if (panel) {
                //---- must set initial colName, since it is not a known data binding to the jsonPanel ----
                var slicerControl = panel.getControlById("slicer");
                this._slicerControl = slicerControl;
                slicerControl.colName(colName);
                slicerControl.registerForChange("selectedValue", function (e) {
                    var sp = slicerControl.getSearchParams();
                    _this.currentChart().search(sp.colName, sp.minValue, sp.maxValue, sp.searchType, sp.searchAction, sp.searchRawValues);
                });
                slicerControl.registerForChange("slicerColName", function (e) {
                    var colName = slicerControl.colName();
                    _this.slicerColName(colName);
                });
                slicerControl.registerForChange("tagDelimiter", function (e) {
                    _this.rebinDataForSlicer();
                });
                this._slicerPanel.registerForChange("close", function (e) {
                    _this._slicerPanel = null;
                });
            }
        };
        appClass.prototype.doSearch = function (legendSource, colName, minValue, maxValue, searchType, selectMode, selectKey) {
            var chart = this.currentChart();
            chart.doSearch(legendSource, colName, minValue, maxValue, searchType, selectMode, selectKey);
        };
        appClass.prototype.closeSlicerPanel = function () {
            if (this._slicerPanel) {
                this._slicerPanel.close();
                this._slicerPanel = null;
            }
        };
        appClass.prototype.createDataTip = function (title, colNames, includeNames) {
            var dataTipIcon = vp.select("#dataTipIcon")[0];
            //---- todo: replace this._currentChart with the actual chart that is loading the data tips ----
            var dataTip = this._dataTipMgr.addDataTip(this.currentChart(), title, colNames, includeNames);
            //---- TODO: move to center of PLOT (not screen) ----
            dataTip.moveToPoint(innerWidth / 2, innerHeight / 2);
        };
        //---- this toggles the Help panel ----
        appClass.prototype.toggleHelpPanel = function (e, isFromLegend) {
            this._panelMaster.togglePanel("helpPanel", e, undefined, isFromLegend);
        };
        //---- this toggles the Bot panel ----
        appClass.prototype.toggleBotPanel = function (e, isFromLegend) {
            this._panelMaster.togglePanel("botPanel", e, undefined, isFromLegend);
        };
        //---- this toggles the Scripts panel ----
        appClass.prototype.toggleScriptsPanel = function (e, isFromLegend) {
            this._panelMaster.togglePanel("scriptsPanel", e, undefined, isFromLegend);
        };
        //---- this toggles the Themes panel ----
        appClass.prototype.toggleThemesPanel = function (e, isFromLegend) {
            this._panelMaster.togglePanel("themesPanel", e, undefined, isFromLegend);
        };
        //---- this toggles the Agg panel ----
        appClass.prototype.toggleAggPanel = function (e, isFromLegend) {
            this._panelMaster.togglePanel("aggPanel", e, undefined, isFromLegend);
        };
        //---- this toggles the Palettes panel ----
        appClass.prototype.togglePalettesPanel = function (e, isFromLegend) {
            this._panelMaster.togglePanel("palettesPanel", e, undefined, isFromLegend);
        };
        appClass.prototype.toggleTipsPanel = function (e, isFromLegend) {
            this._panelMaster.togglePanel("tipsPanel", e, (beachParty.ButtonAlign.matchRight | beachParty.ButtonAlign.belowButton), isFromLegend);
        };
        appClass.prototype.toggleSearchPanel = function (e, isFromLegend) {
            this._panelMaster.togglePanel("searchPanel", e, undefined, isFromLegend);
        };
        appClass.prototype.toggleBrowsePanel = function (e, isFromLegend) {
            this._panelMaster.togglePanel("browsePanel", e, undefined, isFromLegend);
        };
        /**
         *  this launches the specified tour.
         * @param tour
         */
        appClass.prototype.startTour = function (tour) {
            //---- close any running tour ----
            this._panelMaster.closePanelMgr("tourPanel");
            var tourMgr = this._panelMaster.showPanel("tourPanel", null);
            tourMgr.tour(tour);
        };
        appClass.prototype.stopTour = function () {
            var foundTourMgr = false;
            var tourMgr = this._panelMaster.getPanelMgr("tourPanel");
            if (tourMgr) {
                foundTourMgr = true;
                tourMgr.close();
            }
            return foundTourMgr;
        };
        //---- this toggles the Tour Loader panel ----
        appClass.prototype.toggleTourLoaderPanel = function (e, isFromLegend) {
            this._panelMaster.togglePanel("tourLoaderPanel", e, undefined, isFromLegend);
        };
        /**
         * Returns TRUE if this session is being run by someone on the SANDDANCE team.
         */
        appClass.prototype.isInternalSession = function () {
            return (!this._forceExternalSession && (location.href.contains("localhost") || location.href.contains("vibe10")));
        };
        appClass.prototype.toggleClusterPanel = function (e) {
            this._panelMaster.togglePanel("clusterPanel", e);
        };
        appClass.prototype.toggleDetailsPanel = function (e) {
            this._panelMaster.togglePanel("detailsPanel", e);
        };
        appClass.prototype.imgUrlToBlob = function (url, callback) {
            var _this = this;
            var img = new Image();
            img.onload = function (e) {
                //---- draw image onto canvas ----
                var canvas = document.createElement("canvas");
                canvas.setAttribute("width", img.width + "");
                canvas.setAttribute("height", img.height + "");
                var ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, img.width, img.height);
                _this.toBlob(canvas, callback);
            };
            img.src = url;
        };
        appClass.prototype.onSnapshotClick = function (e) {
            /// NOTE: insight stored in undoMgr doesn't have images 
            //var insight = this._undoMgr.getCurrentInsight();
            var _this = this;
            this.createInsight(beachParty.SnapshotType.chart, false, function (insight) {
                var imgUrl = insight.imageAsUrl;
                //---- create an image from imgUrl so that we can draw with it ----
                var img = new Image();
                img.onload = function (e) {
                    var canvas = _this.finishSnapshot(img);
                    _this.toBlob(canvas, function (blob) {
                        beachParty.localFileHelper.saveBlobToLocalFile("snapshot-" + _this._nextSnapShotNum + ".png", blob, "image/png");
                        _this._nextSnapShotNum++;
                    });
                };
                img.src = imgUrl;
            });
        };
        appClass.prototype.makeQuotedString = function (value, delimiter) {
            var str = "\"";
            for (var i = 0; i < value.length; i++) {
                var ch = value[i];
                if (ch == "\"") {
                    //---- escape embedded quotes ----
                    str += (ch + ch);
                }
                else {
                    str += ch;
                }
            }
            str += "\"";
            return str;
        };
        appClass.prototype.dataVectorsToCsv = function (colNames, nv, delimiter) {
            var csvText = "";
            //---- write col headers ----
            for (var c = 0; c < colNames.length; c++) {
                if (c > 0) {
                    csvText += delimiter;
                }
                csvText += colNames[c];
            }
            csvText += "\r\n";
            //---- write col data records ----
            var recordCount = this.currentChart().getRecordCount();
            for (var r = 0; r < recordCount; r++) {
                var recordText = "";
                for (var c = 0; c < colNames.length; c++) {
                    var colName = colNames[c];
                    var data = nv[colName];
                    var value = data[r] + "";
                    if (value.contains(delimiter)) {
                        value = this.makeQuotedString(value, delimiter);
                    }
                    if (c > 0) {
                        recordText += delimiter;
                    }
                    recordText += value;
                }
                csvText += recordText + "\r\n";
            }
            return csvText;
        };
        appClass.prototype.onExportData = function (e) {
            var _this = this;
            //---- request all columns ----
            var chart = this.currentChart();
            var colInfos = chart.getColInfos();
            var colNames = colInfos.map(function (ci) { return ci.name; });
            var dataMgr = this.currentChart().getDataMgr();
            dataMgr.getDataVectors(colNames, false, function (nv) {
                //---- create CSV text ----
                var csvText = _this.dataVectorsToCsv(colNames, nv, "\t");
                beachParty.localFileHelper.saveToLocalFile(chart.getFileName() + ".txt", csvText);
            });
        };
        appClass.prototype.finishSnapshot = function (img) {
            var canvas = document.createElement("canvas");
            var rcFullChart = vp.select("#fullChartPanel").getBounds();
            var width = rcFullChart.width;
            var height = rcFullChart.height;
            canvas.width = width;
            canvas.height = height;
            var ctx = canvas.getContext("2d");
            //---- draw black bg ----
            ctx.fillStyle = this._appSettingsMgr.appBgColor();
            ctx.fillRect(0, 0, width, height);
            //---- draw CHART (plot + axes) ----
            var rcChart = vp.select("#clientHolder").getBounds();
            ctx.drawImage(img, rcChart.left - rcFullChart.left, rcChart.top - rcFullChart.top);
            //---- offset drawing context so we can draw relative to rcFullChart ----
            var tx = -rcFullChart.left;
            var ty = -rcFullChart.top;
            var drawInfo = { tx: tx, ty: ty };
            ctx.translate(tx, ty);
            //---- draw left panel ----
            beachParty.drawHtmlChildren(ctx, document.getElementById("leftPanel"));
            //---- draw bottom panel ----
            beachParty.drawHtmlChildren(ctx, document.getElementById("bottomPanel"));
            //---- draw right panel ----
            beachParty.drawHtmlChildren(ctx, document.getElementById("rightPanel"), undefined, undefined, "botPanelPanel");
            //---- draw facet labels ----
            beachParty.drawHtmlChildren(ctx, document.getElementById("facetLabelHolder"));
            //---- draw data tips ----
            beachParty.drawHtmlChildren(ctx, document.getElementById("dataTipsRoot"));
            //---- draw title/description ----
            beachParty.drawHtmlChildren(ctx, document.getElementById("titlePanel"));
            return canvas;
        };
        appClass.prototype.preventHtmlSelection = function () {
            //---- prevent HTML selection in our app ----
            //---- don't use this in its current forms - it prevents user text selection, which we want ----
            //hostControls.enableElementSelection(document.body, false);
            //---- this doesn't stop the majority of the select problems - not called when starting drag on background and moving over ----
            //---- things like buttons, images, text spans, textBoxes. ----
            //---- define a funtion to prevent select on all non-textbox/non-HTML elements ----
            //---- but, keep it for now - it does prevent selection issues when setting legend constant values by dragging mouse ----
            vp.select(document.body).attach("selectstart", function (e) {
                var tt = vp.select(e.target);
                var isTextBox = ((tt.is("input")) && (tt.attr("type") == "text"));
                var isSelectable = (isTextBox || tt.is("html") || tt.is("textarea"));
                vp.utils.debug("selectstart: isSelectable=" + isSelectable);
                return isSelectable;
            });
            //function preventNodeSelection(node)
            //{
            //    if (node.nodeType == 1)
            //    {
            //        node.setAttribute("unselectable", "on");
            //    }
            //    var child = node.firstChild;
            //    while (child)
            //    {
            //        preventNodeSelection(child);
            //        child = child.nextSibling;
            //    }
            //}
            //preventNodeSelection(document.body);
        };
        appClass.prototype.getKnownFiles = function (useTestData) {
            var knownData = this._knownFileParams;
            var knownFileItems = [];
            if (useTestData) {
                //---- add a "none" entry to allow SD team to close open file ----
                var none = new beachParty.MenuItemData("None", "Close the current data set", null, false, "8px 2px");
                knownFileItems.push(none);
            }
            for (var i = 0; i < knownData.length; i++) {
                var kd = knownData[i];
                if ((kd.showInFileOpen && !useTestData) || (!kd.showInFileOpen && useTestData)) {
                    //if (this._edition == "client" && (kd.name == "AthensCa" || kd.name == "RainFall" || kd.name == "Pitches"))
                    //{
                    //    continue;
                    //}
                    var tip = kd.description + "\r\nrows: " + vp.formatters.comma(kd.recordCount);
                    var mid = new beachParty.MenuItemData(kd.dataName, tip, null, false, "8px 2px");
                    knownFileItems.push(mid);
                }
            }
            return knownFileItems;
        };
        /** get files from the current dataset. */
        appClass.prototype.getOpenFiles = function () {
            var fileList = this._dataEngine.getRelationMgr().getFileObjs();
            var openFiles = [];
            for (var i = 0; i < fileList.length; i++) {
                var fileObj = fileList[i];
                var tip = "Changed: " + vp.formatters.formatDateTime(fileObj.lastModifiedDate, "m/dd/yyyy");
                var mid = new beachParty.MenuItemData(fileObj.name, tip, null, false, "8px 2px");
                openFiles.push(mid);
            }
            return openFiles;
        };
        appClass.prototype.isKnownFile = function (name) {
            var isKnown = false;
            if (this._knownFileParams) {
                for (var i = 0; i < this._knownFileParams.length; i++) {
                    //if (this._knownFileParams[i].name == name)
                    if (this._knownFileParams[i].dataName == name) {
                        isKnown = true;
                        break;
                    }
                }
            }
            return isKnown;
        };
        appClass.prototype.onClusterIdCreated = function (newColInfos, action, outputColName, numClusters) {
            //---- get the chart the updated colInfos with the new/updated ClusterId column ----
            var chart = this.currentChart();
            chart.setColInfos(newColInfos);
            //---- now apply the _ClusterId to the requested color/size/shape mapping ----
            if (action == beachParty.ClusterResultMapping.color) {
                var colorMgr = this._colorMgr;
                colorMgr.colName(outputColName, true, true);
                colorMgr.sliderBinCount(numClusters);
            }
            else if (action == beachParty.ClusterResultMapping.size) {
                this._sizeMgr.colName(outputColName, true);
                this._sizeMgr.binCount(numClusters);
            }
            else if (action == beachParty.ClusterResultMapping.shape) {
                this._shapeMgr.colName(outputColName, true);
                this._shapeMgr.binCount(numClusters);
            }
        };
        appClass.prototype.getMappingCols = function (includeNone, noneName) {
            if (noneName === void 0) { noneName = "None"; }
            var chart = this.currentChart();
            var colInfos = chart.getColInfos();
            var colItems = [];
            var settings = this._appSettingsMgr;
            for (var i = 0; i < colInfos.length; i++) {
                var colInfo = colInfos[i];
                var menuText = colInfo.name;
                if (menuText.startsWith("_") && !this._appSettingsMgr.showSysColsInColPicker()) {
                    //---- don't show ----
                    continue;
                }
                var preText = "";
                var colType = colInfo.colType;
                var desc = (colInfo.desc) ? colInfo.desc : "";
                var stats = colInfo.stats;
                var values = (stats.sortedKeys) ? stats.sortedKeys.length : 0;
                var tooltip = "Name: " + menuText + "\r\nType: " + colType + "\r\nDesc: " + desc;
                if (values) {
                    tooltip += "\r\nValues: " + vp.formatters.comma(values);
                }
                else if (colType == "number") {
                    var formatter = vp.formatters.createCommaFormatter(2); // (colInfo.min, colInfo.max);
                    tooltip += "\r\nMin: " + formatter(stats.min);
                    tooltip += "\r\nMax: " + formatter(stats.max);
                }
                else if (colType == "date") {
                    var formatter = vp.formatters.createDateFormatterFromRange(stats.min, stats.max);
                    tooltip += "\r\nMin: " + formatter(stats.min);
                    tooltip += "\r\nMax: " + formatter(stats.max);
                }
                var imgSrc = null;
                if (settings.showTypesInColPicker()) {
                    if (colType == "number") {
                        imgSrc = beachParty.fnColPickerNumber;
                    }
                    else if (colType == "date") {
                        imgSrc = beachParty.fnColPickerDate;
                    }
                    else {
                        imgSrc = beachParty.fnColPickerString;
                    }
                }
                if (colType == "string" && settings.showCountsInColPicker()) {
                    //---- add count of values on end of name for category columns ----
                    var keyCount = colInfo.stats.sortedKeys.length;
                    var countStr = vp.formatters.comma(keyCount, 0);
                    if (true) {
                        preText = countStr;
                    }
                }
                if (menuText == "") {
                    menuText = this._unnamedColStr;
                }
                colItems.push(new beachParty.MenuItemData(menuText, tooltip, imgSrc, false, undefined, preText));
            }
            if (settings._isColPickerSorted) {
                colItems.sort(function (a, b) { return (a.text < b.text) ? -1 : ((a.text == b.text) ? 0 : 1); });
            }
            if (includeNone) {
                imgSrc = (settings.showTypesInColPicker()) ? beachParty.fnColPickerNone : null;
                colItems.insert(0, new beachParty.MenuItemData(noneName, "Unmap this attribute", imgSrc, false, undefined, ""));
                colItems.insert(1, new beachParty.MenuItemData("-"));
            }
            return colItems;
        };
        appClass.prototype.createKnownDataPicker = function (openerIds, callback, ownerElem) {
            var knownFiles = this.getKnownFiles();
            var picker = this.createGeneralPicker(openerIds, "dataPicker", knownFiles, callback, undefined, undefined, ownerElem);
            return picker;
        };
        //getBinCountForFacetColumn(colName: string)
        //{
        //    var ci = this.getColInfo(colName);
        //    if (ci == null)         // "None" column was selected in UI
        //    {
        //        //---- not too important- just give some reasonable values ----
        //        var maxCount = 1;
        //        var defaultCount = 1;
        //    }
        //    else if (ci.colType == "string")
        //    {
        //        var maxCount = Math.min(appClass.maxFacetCategoryBins, ci.sortedKeys.length);
        //        var defaultCount = maxCount;
        //    }
        //    else
        //    {
        //        var maxCount = appClass.maxFacetNumericBins;
        //        var defaultCount = appClass.defaultNumericBins;
        //    }
        //    var binCount = this._colOptMgr.getBinCount();
        //    if (binCount === undefined)
        //    {
        //        binCount = defaultCount;
        //    }
        //    return { binCount: binCount, maxCount: maxCount };
        //}
        /** should be called: on chart change, on x/y/z col change, on data change. */
        appClass.prototype.updateClusterPanel = function () {
            var clusterPanel = this._panelMaster.getPanelMgr("clusterPanel");
            if (clusterPanel) {
                var cols = this.currentChart().getAxisColumnsInCurrentChart();
                var colStr = beachParty.cbUtils.arrayToString(cols, ", ");
                clusterPanel.columns(colStr);
            }
        };
        appClass.prototype.applySearchPanelParams = function (e, searchCol, searchValue, selectMode, searchType) {
            //var text = vp.select("#searchText").value();
            //var gesture = (e.keyCode) ? Gesture.keyDown : Gesture.click;
            var text = searchValue;
            var gesture = beachParty.Gesture.keyDown;
            this._searchCol = searchCol;
            //---- parse text for comparison or range operators ----
            var scanner = new vp.utils.scannerClass(text);
            var tokType = scanner.scan();
            var opTok = null;
            if (tokType == vp.utils.TokenType.operator) {
                this.doOperatorSearch(e, "Search", gesture, text, searchCol, selectMode);
            }
            else if (tokType == vp.utils.TokenType.number) {
                //---- look for range ----
                var minValue = scanner.token();
                tokType = scanner.scan();
                var tok = scanner.token();
                //---- caution: if no space bewteen dash and number, scanner will treat as a negative number ----
                if (tok.startsWith("-")) {
                    this.doRangeSearch(e, "Search", gesture, minValue, scanner, tok, selectMode);
                }
                else {
                    this.doValueSearch(e, "Search", gesture, text, selectMode, searchType);
                }
            }
            else {
                this.doValueSearch(e, "Search", gesture, text, selectMode);
            }
        };
        appClass.prototype.doValueSearch = function (e, legendSource, gesture, text, selectMode, searchType) {
            var forceSearch = true;
            this.searchValue(legendSource, text, searchType, forceSearch, selectMode);
            var id = (e && e.target) ? e.target.id : null;
            this.logAction(gesture, id, beachParty.ElementType.textBox, beachParty.Action.adjust, beachParty.Target.selection, true, { searchType: "startsWith" });
        };
        appClass.prototype.doRangeSearch = function (e, legendSource, gesture, minValue, scanner, tok, selectMode) {
            if (tok.length > 1) {
                var maxValue = tok.substr(1).trim();
            }
            else {
                scanner.scan();
                var maxValue = scanner.token();
            }
            this.doSearch(legendSource, this._searchCol, minValue, maxValue, beachParty.TextSearchType.betweenInclusive, selectMode);
            var id = (e && e.target) ? e.target.id : null;
            this.logAction(gesture, id, beachParty.ElementType.textBox, beachParty.Action.adjust, beachParty.Target.selection, true, { searchType: "betweenInclusive" });
        };
        appClass.prototype.doOperatorSearch = function (e, legendSource, gesture, text, searchCol, selectMode) {
            var scanner = new vp.utils.scannerClass(text);
            scanner.scan();
            //---- <operator> <value> ----
            var tok = scanner.token();
            scanner.scan();
            var value = scanner.token();
            var op = null;
            if (tok == "<") {
                op = beachParty.TextSearchType.lessThan;
            }
            else if (tok == "<=") {
                op = beachParty.TextSearchType.lessThanEqual;
            }
            else if (tok == ">") {
                op = beachParty.TextSearchType.greaterThan;
            }
            else if (tok == ">=") {
                op = beachParty.TextSearchType.greaterThanEqual;
            }
            else if ((tok == "=") || (tok == "==")) {
                op = beachParty.TextSearchType.exactMatch;
            }
            else if ((tok == "!=") || (tok = "<>")) {
                op = beachParty.TextSearchType.notEqual;
            }
            if (op !== null) {
                //---- VALID OP ----
                //this.searchValue(value, op);
                this.doSearch(legendSource, searchCol, value, value, op, selectMode);
                var gesture = (e.keyCode) ? beachParty.Gesture.keyDown : beachParty.Gesture.click;
                var id = (e && e.target) ? e.target.id : null;
                this.logAction(gesture, id, beachParty.ElementType.textBox, beachParty.Action.adjust, beachParty.Target.selection, true, { op: tok });
            }
            else {
                //---- UNRECOGNIZED OPERATOR ----
                this.currentChart().clearSelection();
                var id = (e && e.target) ? e.target.id : null;
                this.logAction(gesture, id, beachParty.ElementType.textBox, beachParty.Action.clear, beachParty.Target.selection, true, { reason: "unrecognized expression" });
            }
        };
        appClass.prototype.onSearchColClick = function (e) {
            var _this = this;
            var picker = this.createColumnPicker("btSearchCol", false, function (mid) {
                _this.searchCol(mid.text);
                _this.logAction(beachParty.Gesture.select, null, beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.searchCol, true);
                var st = vp.select("#searchText")[0];
                st.focus();
            });
            if (picker) {
                var rcText = vp.select("#searchCol").getBounds(false);
                var rcMenu = vp.select("#generalColPicker").getBounds(false);
                var x = rcText.left - rcMenu.width;
                var y = rcText.top + 4;
                picker.showAt(x, y);
            }
        };
        appClass.prototype.getTourItems = function () {
            //---- start with standard tours ----
            var tours = ["Build53", "Bot", "FirstTour", "Search", "Titanic"];
            var cachedTours = beachParty.localStorageMgr.enumerate(beachParty.StorageType.tour, beachParty.StorageSubType.local, true);
            tours = tours.concat(cachedTours);
            return tours;
        };
        appClass.prototype.createEnumPicker = function (openerIds, enumType, callback, ownerElem) {
            var pickerItems = vp.utils.keys(enumType);
            //---- capitalize the first letter of each enum name ----
            pickerItems = pickerItems.map(function (name) { return beachParty.chartUtils.capitalizeFirstLetter(name); });
            //---- todo: what does this filter out? ----
            var pickerItems = pickerItems.filter(function (k) {
                return (isNaN(+k));
            });
            //---- some long list of enum values have separators in them; substitute a menu line marker ----
            var pickerItems = pickerItems.map(function (val) {
                return (val == "separator") ? "-" : val;
            });
            var picker = this.createGeneralPicker(openerIds, "enumPicker", pickerItems, callback, undefined, undefined, ownerElem);
            return picker;
        };
        appClass.prototype.getCurrentFileParams = function (value) {
            return this._fileOpenMgr.preload();
        };
        appClass.prototype.createScrubberPicker = function (openerIds, callback, ownerElem) {
            var items = beachParty.localStorageMgr.enumerate(beachParty.StorageType.preload, beachParty.StorageSubType.local, true);
            items.insert(0, "None");
            var picker = this.createGeneralPicker(openerIds, "scrubberPicker", items, callback, undefined, undefined, ownerElem);
            return picker;
        };
        appClass.prototype.createColumnPicker = function (openerIds, includeBlank, callback, ownerElem, noneName) {
            if (noneName === void 0) { noneName = "None"; }
            var colItems = this.getMappingCols(includeBlank, noneName);
            var verticalMargin = 5;
            var iconWidth = 14;
            var picker = this.createGeneralPicker(openerIds, "colPicker", colItems, function (mid) {
                if (mid.text == noneName) {
                    //---- replace "None" with "" ----
                    mid.text = "";
                }
                callback(mid);
            }, verticalMargin, iconWidth, ownerElem, "popupMenuIconColPicker");
            return picker;
        };
        //---- creates a picker for the list of available tours (standard & cached) ----
        appClass.prototype.createTourPicker = function (openerIds, includeBlank, callback, ownerElem) {
            var colItems = this.getTourItems();
            var verticalMargin = 5;
            var iconWidth = 20;
            var picker = this.createGeneralPicker(openerIds, "tourPicker", colItems, function (mid) {
                if (mid.text == "None") {
                    //---- replace "None" with "" ----
                    //mid = vp.utils.copyMap(mid);
                    mid.text = "";
                }
                callback(mid);
            }, verticalMargin, iconWidth, ownerElem);
            return picker;
        };
        //---- creates a picker for the list of available palette sets (standard & cached) ----
        appClass.prototype.createPalettePicker = function (openerIds, includeBlank, callback, ownerElem) {
            var colItems = beachParty.palettesPanelMgr.getPaletteItems();
            var verticalMargin = 5;
            var iconWidth = 20;
            var picker = this.createGeneralPicker(openerIds, "palettePicker", colItems, function (mid) {
                if (mid.text == "None") {
                    //---- replace "None" with "" ----
                    //mid = vp.utils.copyMap(mid);
                    mid.text = "";
                }
                callback(mid);
            }, verticalMargin, iconWidth, ownerElem);
            return picker;
        };
        //---- creates a picker for the list of available scripts (standard & cached) ----
        appClass.prototype.createScriptPicker = function (openerIds, includeBlank, callback, ownerElem) {
            var colItems = beachParty.scriptsPanelMgr.getScriptItems();
            var verticalMargin = 5;
            var iconWidth = 20;
            var picker = this.createGeneralPicker(openerIds, "scriptPicker", colItems, function (mid) {
                if (mid.text == "None") {
                    //---- replace "None" with "" ----
                    //mid = vp.utils.copyMap(mid);
                    mid.text = "";
                }
                callback(mid);
            }, verticalMargin, iconWidth, ownerElem);
            return picker;
        };
        //---- creates a picker for the list of available Themes (standard & cached) ----
        appClass.prototype.createThemePicker = function (openerIds, includeBlank, callback, ownerElem) {
            var colItems = beachParty.themesPanelMgr.getThemeItems();
            var verticalMargin = 5;
            var iconWidth = 20;
            var picker = this.createGeneralPicker(openerIds, "themePicker", colItems, function (mid) {
                if (mid.text == "None") {
                    //---- replace "None" with "" ----
                    //mid = vp.utils.copyMap(mid);
                    mid.text = "";
                }
                callback(mid);
            }, verticalMargin, iconWidth, ownerElem);
            return picker;
        };
        appClass.prototype.createColumnPickerList = function (parent, includeBlank, callback) {
            var colItems = this.getMappingCols(includeBlank);
            var iconWidth = undefined;
            var listBox = new beachParty.listBoxClass(this, parent, colItems, function (mid) {
                if (mid) {
                    if (mid.text == "None") {
                        //---- replace "None" with "" ----
                        //mid = vp.utils.copyMap(mid);
                        mid.text = "";
                    }
                    callback(mid);
                }
            }, iconWidth, true, "popupMenuIconColPicker");
            return listBox;
        };
        appClass.prototype.createKnownDataPickerList = function (parent, includeBlank, callback, useTestData) {
            var colItems = this.getKnownFiles(useTestData);
            var listBox = new beachParty.listBoxClass(this, parent, colItems, callback);
            vp.select(listBox._root)
                .id("knownDataPickerList");
            return listBox;
        };
        appClass.prototype.createOpenDataPickerList = function (parent, includeBlank, callback) {
            var colItems = [];
            if (this._dataEngine.getRelationMgr().getFileCount() > 1) {
                colItems = this.getOpenFiles();
            }
            var listBox = new beachParty.listBoxClass(this, parent, colItems, callback);
            vp.select(listBox._root)
                .id("openDataPickerList");
            return listBox;
        };
        appClass.prototype.createColorPicker = function (openerIds, includeTransparent, callback, ownerElem) {
            var colItems = ["beach blue", "black", "blue", "gray", "green", "orange", "purple", "red", "violet", "white", "yellow"];
            if (includeTransparent) {
                colItems.insert(0, "none");
            }
            var picker = this.createGeneralPicker(openerIds, "colorPicker", colItems, callback, undefined, undefined, ownerElem);
            return picker;
        };
        appClass.prototype.createLineColorPicker = function (openerIds, includeShapeColor, callback, ownerElem) {
            var colItems = ["beach blue", "black", "blue", "gray", "green", "orange", "purple", "red", "violet", "white", "yellow"];
            if (includeShapeColor) {
                colItems.insert(0, "shapeColor");
            }
            var picker = this.createGeneralPicker(openerIds, "colorPicker", colItems, callback, undefined, undefined, ownerElem);
            return picker;
        };
        appClass.prototype.createShapePicker = function (openerIds, p2, callback, ownerElem) {
            var colItems = ["none", "circle", "square", "triangle", "filled circle", "filled square", "filled triangle"];
            var picker = this.createGeneralPicker(openerIds, "shapePicker", colItems, callback, undefined, undefined, ownerElem);
            return picker;
        };
        appClass.prototype.closeGeneralPicker = function () {
            //---- close & remove from DOM ----
            if (this._generalPicker) {
                this._generalPicker.remove();
                this._generalPicker = null;
            }
        };
        appClass.prototype.createGeneralPicker = function (openerIds, name, colItems, callback, verticalMargin, iconWidth, ownerElem, iconClassName) {
            if (verticalMargin === void 0) { verticalMargin = 0; }
            var pm = null;
            if (colItems) {
                pm = new beachParty.popupMenuClass(this, openerIds, "generalColPicker", colItems, function (e, menu, textIndex, menuIndex) {
                    var mid = colItems[menuIndex];
                    callback(mid);
                }, undefined, undefined, verticalMargin, iconWidth, ownerElem, iconClassName);
            }
            this._generalPicker = pm;
            return pm;
        };
        appClass.prototype.createListBox = function (colItems, callback) {
        };
        appClass.prototype.getPreload = function (name) {
            var preload = null;
            for (var i = 0; i < this._knownFileParams.length; i++) {
                var pl = this._knownFileParams[i];
                //if (pl.name == name)
                if (pl.dataName == name) {
                    preload = pl;
                }
            }
            return preload;
        };
        appClass.prototype.clipTextLength = function (text, maxLength) {
            var ellipseWidth = 15; //  this._ellipsesBounds.width;
            return vp.formatters.truncateText(text, maxLength, true, this._fakeLabel, ellipseWidth);
        };
        appClass.prototype.createFakeTextElement = function () {
            var fakeLabel = vp.select(document.body).append("text")
                .addClass("vpxAxisLabel")
                .id("fakeLabelForMeasuring")
                .css("opacity", "0")
                .css("position", "absolute")
                .css("left", "-1000px");
            this._fakeLabel = fakeLabel[0];
        };
        appClass.prototype.setBigPrompt = function (baseName, value) {
            vp.select("#bb" + baseName + "Prompt").text(value);
        };
        appClass.prototype.setBigValue = function (baseName, value, toolTip) {
            var buttonW = vp.select("#bb" + baseName);
            if (buttonW[0]) {
                var valueW = vp.select("#bb" + baseName + "Value");
                var clippedValue = this.clipTextLength(value, 150);
                //---- add/remove NONE class ----
                if (!value || value == "Shapes") {
                    valueW
                        .addClass("noneValue");
                }
                else {
                    valueW
                        .removeClass("noneValue");
                }
                //---- set TEXT and TOOPTIP ----
                if (!value) {
                    valueW
                        .text("None")
                        .title("Not currently set");
                }
                else {
                    var vtip = value;
                    if (toolTip) {
                        vtip += " (" + toolTip + ")";
                    }
                    valueW
                        .text(clippedValue)
                        .title(vtip);
                }
            }
        };
        appClass.prototype.toggleWheelMode = function (e) {
            var chart = this.currentChart();
            chart.toggleWheel();
        };
        appClass.prototype.onRecordCountChanged = function () {
            var recordCount = this.currentChart().getRecordCount();
            var countMsg = vp.formatters.comma(recordCount) + " items";
            if (countMsg) {
                vp.select("#itemCountText")
                    .text(countMsg)
                    .css("display", "");
            }
            else {
                vp.select("#itemCountText")
                    .css("display", "none");
            }
        };
        appClass.prototype.onUndoClick = function () {
            if (this._undoMgr) {
                var tooltip = this._undoMgr.getUndoTooltip();
                var entry = this._undoMgr.undo();
                if (entry) {
                    this.logAction(beachParty.Gesture.click, "undoButton", beachParty.ElementType.button, beachParty.Action.load, beachParty.Target.undoEntry, false);
                    this.loadInsightCore(entry.insight);
                }
            }
        };
        appClass.prototype.onRedoClick = function () {
            if (this._undoMgr) {
                var tooltip = this._undoMgr.getRedoTooltip();
                var entry = this._undoMgr.redo();
                if (entry) {
                    this.logAction(beachParty.Gesture.click, "redoButton", beachParty.ElementType.button, beachParty.Action.load, beachParty.Target.redoEntry, false, { tooltip: tooltip });
                    this.loadInsightCore(entry.insight);
                }
            }
        };
        appClass.prototype.onUndoStackChange = function () {
            if (this._undoMgr) {
                var undoTip = this._undoMgr.getUndoTooltip();
                vp.select("#undoButton")
                    .title(undoTip);
                var redoTip = this._undoMgr.getRedoTooltip();
                vp.select("#redoButton")
                    .title(redoTip);
                var isUndoAvail = this._undoMgr.isUndoAvailable();
                this.disableIconButton("undo", (!isUndoAvail));
                var isRedoAvail = this._undoMgr.isRedoAvailable();
                this.disableIconButton("redo", (!isRedoAvail));
            }
        };
        appClass.prototype.updateResetButton = function () {
            var chart = this.currentChart();
            var isFiltered = (chart.getFilteredInCount() < chart.getRecordCount());
            var resetDisabled = (!chart.getSelectedCount() && !isFiltered);
            this.disableIconButton("reset", resetDisabled);
            this.disableBigButton("reset", resetDisabled);
        };
        appClass.prototype.onFilteredInCountChanged = function () {
            //var countMsg = (this._filteredInCount < this._recordCount) ? (vp.formatters.comma(this._filteredInCount) + " in filter") : "";
            var chart = this.currentChart();
            var filteredInCount = chart.getFilteredInCount();
            var recordCount = chart.getRecordCount();
            var dim = (filteredInCount == recordCount);
            if (dim) {
                var countMsg = (vp.formatters.comma(chart.getRecordCount())) + " items";
            }
            else {
                var countMsg = (vp.formatters.comma(filteredInCount)) + " of " + (vp.formatters.comma(recordCount)) + " items";
            }
            vp.select("#filteredInCountText")
                .text(countMsg);
            vp.select("#filteredInCountTextHolder")
                .attr("data-disabled", (dim) ? "true" : "false");
            this.updateResetButton();
        };
        appClass.prototype.onIsolateClick = function (e) {
            var _this = this;
            var chart = this.currentChart();
            if (chart.getSelectedCount()) {
                this._filterDesc = this._selectionDesc;
                //this.onClientFilterChange();
                this.currentChart().isolateSelection(function (msgBlock) {
                    _this.postFilterChange();
                });
                var id = (e) ? e.target.id : null;
                this.logAction(beachParty.Gesture.click, id, beachParty.ElementType.button, beachParty.Action.adjust, beachParty.Target.filter, true, { type: "Isolate" });
                this.onDataChanged("isolateButton");
            }
        };
        appClass.prototype.toggleTasksPanel = function (e, isFromLegend) {
            this._panelMaster.togglePanel("tasksPanel", e, beachParty.ButtonAlign.belowButton, isFromLegend);
        };
        appClass.prototype.onExcludeClick = function (e) {
            var _this = this;
            var chart = this.currentChart();
            if (chart.getSelectedCount()) {
                this._filterDesc = this._selectionDesc;
                //this.onClientFilterChange();
                this.currentChart().excludeSelection(function (msgBlock) {
                    _this.postFilterChange();
                });
                var id = (e) ? e.target.id : null;
                this.logAction(beachParty.Gesture.click, id, beachParty.ElementType.button, beachParty.Action.adjust, beachParty.Target.filter, true, { type: "Exclude" });
                this.onDataChanged("excludeButton");
            }
        };
        appClass.prototype.onResetClick = function (e, filterOnly) {
            var _this = this;
            if (!filterOnly) {
                this.currentChart().clearSelection();
            }
            this.currentChart().resetFilter(function (msgBlock) {
                _this.postFilterChange();
                if (!filterOnly) {
                    //---- why does animatin get turned off here? ----
                    _this.currentChart().resetTransform();
                }
            });
            var id = (e) ? e.target.id : null;
            this.logAction(beachParty.Gesture.click, id, beachParty.ElementType.button, beachParty.Action.clear, beachParty.Target.filterAndSelection, true);
            this.onDataChanged("resetButton");
        };
        appClass.prototype.resetSelection = function () {
            this.currentChart().clearSelection();
            this.logAction(beachParty.Gesture.chatBot, "", beachParty.ElementType.textBox, beachParty.Action.clear, beachParty.Target.filter, true);
        };
        appClass.prototype.onBigBarChanged = function () {
            this.toggleAxisButtonsAndBins();
        };
        /**
         * Show or hide the AXIS BUTTONS and BIN COUNT ADJUSTERS, based on current view.  Also, adjust layout "X" and "Y" layouts, as needed.
         * @param hideBins
         */
        appClass.prototype.toggleAxisButtonsAndBins = function (hideBins) {
            var chart = this.currentChart();
            if (chart && this._xBinAdjuster) {
                //---- ensure current layout matches latest chartName ----
                chart.getChartBuilder().onLayoutNameChanged();
                var chartName = chart.chartName();
                var hasRecords = (chart.getRecordCount() > 0);
                var visibleColPickers = chart.getVisibleColPickers();
                var visibleBinAdjusters = chart.getVisibleBinAdjusters();
                var showX = hasRecords && visibleColPickers.contains("x");
                var showY = hasRecords && visibleColPickers.contains("y");
                var showZ = hasRecords && visibleColPickers.contains("z");
                var showAux = hasRecords && visibleColPickers.contains("a");
                var showSumBy = this.isSumByEnabled();
                var showXBin = hasRecords && visibleBinAdjusters.contains("x");
                var showYBin = hasRecords && visibleBinAdjusters.contains("y");
                var showZBin = hasRecords && visibleBinAdjusters.contains("z");
                //---- toggle big bar COL PICKER buttons ----
                vp.select("#bbX").css("display", (showX) ? "" : "none");
                vp.select("#bbY").css("display", (showY) ? "" : "none");
                vp.select("#bbZ").css("display", (showZ) ? "" : "none");
                vp.select("#bbSum").css("display", showSumBy ? "" : "none");
                //---- tobble axis COL PICKER buttons ----
                //---- Bar view does not yet support "count/sum" picker correctly ----
                //vp.select("#xButtonOuter").css("display", (showX || showAux) ? "" : "none");
                vp.select("#xButtonOuter").css("display", (showX) ? "" : "none");
                vp.select("#yButtonOuter").css("display", (showY || showAux) ? "" : "none");
                vp.select("#zButtonOuter").css("display", (showZ) ? "" : "none");
                //---- toggle axis BIN ADJUSTERS ----
                this._xBinAdjuster.show(showXBin && !hideBins);
                this._yBinAdjuster.show(showYBin && !hideBins);
                this._zBinAdjuster.show(showZBin && !hideBins);
                //---- adjust xStuff to keep in place when showZ is true ----
                vp.select("#xStuff")
                    .css("top", (showZ) ? "17px" : ((showXBin) ? "10px" : "21px"));
                //---- ensure this is called the first time we show the Y button / bins ----
                this.manualLayoutForYStuff();
                chart.on3dViewChanged();
            }
        };
        appClass.prototype.setAxisButtonText = function (attrName, colName) {
            var chart = this.currentChart();
            var chartName = chart.chartName();
            var valueText = colName;
            if (attrName == "aux") {
                attrName = "y";
            }
            var upAttrName = beachParty.chartUtils.capitalizeFirstLetter(attrName);
            var prompt = upAttrName + ": ";
            if (attrName == "y" && chart.isCountOrSumOrGrid("y")) {
                var auxCol = this._auxMgr.colName();
                prompt = "";
                if (auxCol) {
                    valueText = "Sum: " + auxCol;
                }
                else {
                    if (this._auxMgr.countLayout() == "percent") {
                        valueText = "Percent";
                    }
                    else {
                        valueText = "Count";
                    }
                }
            }
            //---- update chart button ----
            vp.select("#" + attrName + "Text").text(prompt + valueText);
            //---- update bigbar button ----
            if (auxCol) {
                this.setBigValue("Sum", valueText);
            }
            else {
                this.setBigValue(upAttrName, valueText);
                this.setBigValue("Sum", "");
            }
        };
        appClass.prototype.isSumByEnabled = function () {
            var chartName = this.currentChart().chartName();
            var isEnabled = (chartName == "Column" || chartName == "Bar");
            return isEnabled;
        };
        appClass.prototype.showOrHideLineBy = function () {
            var isOn = this.isLineByEnabled();
            vp.select("#bbLine").css("display", (isOn) ? "" : "none");
        };
        //useShapeForMapLayouts()
        //{
        //    var isMappingChart = this.isMappingChartAndNot3d();
        //    var settings = this._appSettingsMgr;
        //    if (isMappingChart)
        //    {
        //        var mappingImage = settings.mappingImage();
        //        settings.shapeImage(mappingImage);
        //    }
        //    else
        //    {
        //        var layoutImage = settings.layoutImage();
        //        settings.shapeImage(layoutImage);
        //    }
        //    var size = this._sizeFactor * this._maxScatterSizeInPixels;
        //    var useImage = (size >= 1.4);
        //    this._currentChart.enableShapeImage(useImage);
        //}
        appClass.prototype.isMappingChartAndNot3d = function () {
            var name = this.currentChart().chartName();
            var value = (name == "Scatter" || name == "X-Band" || name == "Y-Band" || name == "Radial");
            return value;
        };
        appClass.prototype.toggleInsightPanel = function (e) {
            this._insightMgr.toggleInsightsPanel();
        };
        appClass.prototype.showInsightsPanel = function (value) {
            this._insightMgr.showInsightBar(value);
        };
        appClass.prototype.showInsightMenu = function (e) {
            this._activeContextMenu = this._insightMgr.showInsightButtonContextMenu(e);
        };
        appClass.prototype.addNewInsight = function (e) {
            var _this = this;
            this.createInsight(beachParty.SnapshotType.chart, true, function (insight) {
                var imgUrl = insight.imageAsUrl;
                //---- create an image from imgUrl so that we can draw with it ----
                var img = new Image();
                img.onload = function (e) {
                    var canvas = _this.finishSnapshot(img);
                    canvas.setAttribute('crossOrigin', 'anonymous');
                    insight.imageAsUrl = canvas.toDataURL();
                    _this._insightMgr.addNewInsight(insight);
                    _this.onInsightAdded();
                    _this.logAction(beachParty.Gesture.click, "add", beachParty.ElementType.button, beachParty.Action.add, beachParty.Target.insight, false);
                };
                img.src = imgUrl;
            });
        };
        appClass.prototype.setAllChartsProperty = function (propName, value) {
            //---- ensure first chart has been set ----
            if (this._chartRouter.getChart()) {
                var charts = this._charts;
                for (var i = 0; i < charts.length; i++) {
                    var chart = charts[i];
                    //---- call the property setter ----
                    chart[propName](value);
                }
            }
        };
        appClass.prototype.onInsightAdded = function () {
            if (this._appSettingsMgr.rememberLastInsights()) {
                //---- write set of insights to local strorage so they can be restored when next session starts ----
                var insights = this._insightMgr._session.insights;
                var jsonStr = JSON.stringify(insights);
                beachParty.localStorageMgr.save(beachParty.StorageType.insights, beachParty.StorageSubType.lastSessionState, null, jsonStr);
            }
        };
        appClass.prototype.restoreInsightsFromLastSession = function () {
            if (this._appSettingsMgr.rememberLastInsights()) {
                var jsonStr = beachParty.localStorageMgr.get(beachParty.StorageType.insights, beachParty.StorageSubType.lastSessionState, null);
                if (jsonStr != null && jsonStr != "[]") {
                    this._insightMgr.loadInsightsFromText(jsonStr, "lastSession");
                }
            }
        };
        appClass.prototype.createInsight = function (snapshotType, getRepro, callback) {
            var _this = this;
            var insight = new beachParty.InsightData(null);
            //---- save some properties as early as possible (keys on text change quickly) ----
            //---- client-specific properties ----
            insight.searchText = this._searchValue;
            insight.searchColumn = this._searchCol;
            //---- request some additional data about current state from BPS ----
            var chartBgColor = this._appSettingsMgr.appBgColor();
            this.currentChart().getSystemViewData(snapshotType, getRepro, chartBgColor, function (svd) {
                //---- IMPORTANT: wait until engine has processed our "getSystemViewData" before we record properties of insight ----
                //---- this gives the engine a chance to process all of our previous cmds and have them trickle to client properties ----
                var preload = vp.utils.copyMap(_this._fileOpenMgr.preload());
                insight.preload = preload;
                var settings = _this._appSettingsMgr;
                var chart = _this.currentChart();
                chart.captureInsightProperties(preload);
                preload.selectedKeys = svd.selectedKeys;
                preload.filteredOutKeys = svd.filteredOutKeys;
                preload.worldTransform = svd.worldTransform;
                preload.rotationInertia = svd.rotationInertia;
                insight.imageAsUrl = svd.imageAsUrl;
                insight.chartRepro = svd.chartRepro;
                insight.name = chart.titleText();
                _this._dataTipMgr.getDataFromDataTips(preload);
                callback(insight);
            });
        };
        appClass.prototype.isSet = function (md) {
            return (md.colName != null && md.colName != "");
        };
        appClass.prototype.onLegendsChanged = function () {
            var colorMgr = this._colorMgr;
            var isLegendNeeded = (colorMgr.isSet() || this._sizeMgr.isSet()
                || this._shapeMgr.isSet() || this._textMgr.isSet());
            //---- for now, try holding right panel always open ----
            isLegendNeeded = true;
            var isRightPanelShowing = (vp.select("#rightPanel").css("display") != "none");
            if (isLegendNeeded != isRightPanelShowing) {
                if (this._isUiVisible) {
                    //---- hide or show right panel ----
                    //vp.select("#rightPanel").css("display", (isLegendNeeded) ? "" : "none");
                    this.showRightPanel(isLegendNeeded);
                    this.markLayoutNeeded("onLegendsChanged");
                }
            }
        };
        appClass.prototype.markLayoutNeeded = function (reason) {
            var _this = this;
            if (!this._layoutTimer) {
                this._layoutTimer = setTimeout(function (e) { return _this.layoutScreen(reason); }, 10);
            }
        };
        appClass.prototype.getPaletteMgr = function () {
            return this._paletteMgr;
        };
        appClass.prototype.isVisible = function (name) {
            return vp.select("#" + name).css("display") != "none";
        };
        /**
         *  get bounds of an element, relative to the appDiv (the div containing our HTML app instance).
         */
        appClass.prototype.getAppRelBounds = function (selector) {
            var elemW = selector;
            if (true) {
                elemW = vp.select(selector);
            }
            var rcElem = elemW.getBounds(false);
            var rcApp = vp.select(this.getAppDivElem()).getBounds(false);
            rcElem = vp.geom.createRect(rcElem.left - rcApp.left, rcElem.top - rcApp.top, rcElem.width, rcElem.height);
            return rcElem;
        };
        appClass.prototype.layoutScreen = function (layoutReason) {
            if (this._layoutTimer) {
                clearTimeout(this._layoutTimer);
                this._layoutTimer = null;
            }
            if (this._isUiVisible) {
                vp.utils.debug("--> layoutScreen: reason=" + layoutReason);
                //---- scrolling flexbox WORKAROUND: set height of a parent explictly ----
                var elem = vp.select("#clientPanel")[0];
                elem.style.height = ""; // remove height before we measure
                var cpHeight = vp.select(elem).height();
                //---- apply measured height explictly ----
                elem.style.height = cpHeight + "px";
                var chart = this.currentChart();
                if (chart) {
                    chart.onBoundsChanged();
                }
            }
        };
        appClass.prototype.pickGoodColorColumn = function () {
            var chart = this.currentChart();
            var colInfos = chart.getColInfos();
            var colInfos = colInfos;
            var preload = this._fileOpenMgr._preload;
            var crColumn = null;
            if (preload && preload.colMappings) {
                var cm = preload.colMappings.color;
                crColumn = cm.colName;
            }
            if (!crColumn) {
                //---- search for a column not mapped to x/y/z that is categorical with 2-12 cardinality ----
                for (var i = 0; i < colInfos.length; i++) {
                    var colInfo = colInfos[i];
                    var colName = colInfo.name;
                    if (!this.currentChart().isMappedToXYZ(colName)) {
                        if (colInfo.colType == "string") {
                            var keyCount = colInfo.stats.sortedKeys.length;
                            if (keyCount >= 2 && keyCount <= 12) {
                                crColumn = colName;
                            }
                        }
                    }
                }
            }
            if (!crColumn) {
                crColumn = colInfos[0].name;
            }
            return crColumn;
        };
        appClass.prototype.hideInfoMsg = function () {
            beachParty.chartUtils.fadeOut("#infoMsgBox", 350);
        };
        appClass.prototype.getDefaultXYZCols = function () {
            var chart = this.currentChart();
            var colInfos = chart.getColInfos();
            var xm = null;
            var ym = null;
            var zm = null;
            var preload = this._fileOpenMgr._preload;
            if (preload && preload.colMappings) {
                xm = preload.colMappings.x;
                ym = preload.colMappings.y;
                zm = preload.colMappings.z;
            }
            var x = (xm) ? xm.colName : null;
            var y = (ym) ? ym.colName : null;
            var z = (zm) ? zm.colName : null;
            if (!x || !y || !z) {
                for (var i = 0; i < colInfos.length; i++) {
                    var colInfo = colInfos[i];
                    var name = colInfo.name.toLowerCase();
                    if (name == "lat" || name == "latitude") {
                        y = colInfo.name;
                    }
                    else if (name == "lon" || name == "long" || name == "longitude" || name == "date" || name == "year" || name == "time") {
                        x = colInfo.name;
                    }
                }
            }
            if (!x || !y || !z) {
                for (var i = 0; i < colInfos.length; i++) {
                    var colInfo = colInfos[i];
                    var colType = colInfo.colType;
                    var colName = colInfo.name;
                    if (colName.startsWith("_")) {
                        //---- don't use system columns (will confuse the user since they don't appear in col pickers) ----
                        continue;
                    }
                    if (colType == "number") {
                        if (!x) {
                            x = colName;
                        }
                        if (!y && x != colName) {
                            y = colName;
                        }
                        if (!z && x != colName && y != colName) {
                            z = colName;
                        }
                    }
                    if (x && y && z) {
                        break;
                    }
                }
            }
            if (!x) {
                x = colInfos[0].name;
            }
            if (!y) {
                y = colInfos[0].name;
            }
            if (!z) {
                z = this.pickGoodColorColumn();
                if (!z) {
                    z = colInfos[0].name;
                }
            }
            return { x: x, y: y, z: z };
        };
        //---- now that we have real customers, let's only rev "buildId" when absolutely necessary, ----
        //---- that is, when the appSettings and other localstorage data are not forward compatible. ---- 
        appClass.buildId = "53-beta-2"; // increment this at last moment before running "vibe10.bat"
        //---- todo: make this dynamic (to fit current size of window, not just initial) ----
        appClass.maxPanelHeight = .65 * window.innerHeight;
        appClass.maxPanelWidth = .75 * window.innerWidth;
        return appClass;
    }(beachParty.dataChangerClass));
    beachParty.appClass = appClass;
    var FilterStack = (function () {
        function FilterStack() {
        }
        return FilterStack;
    }());
    beachParty.FilterStack = FilterStack;
    var SelectionStack = (function () {
        function SelectionStack() {
        }
        return SelectionStack;
    }());
    beachParty.SelectionStack = SelectionStack;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    attrMgr.ts - manages an attribute mapping.  does data binding needed by controls and the 
//      attribute panel that does column picking and column options.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var attrMgrClass = (function (_super) {
        __extends(attrMgrClass, _super);
        function attrMgrClass(app, chartRouter, attributeName) {
            var _this = this;
            _super.call(this);
            this._app = app;
            this._chartRouter = chartRouter;
            this._attributeName = attributeName;
            this._app.registerForChange("chart", function (e) {
                if (_this._jsonPanel) {
                    _this.updateAttrPanel(_this._jsonPanel);
                }
            });
            chartRouter.registerForChange("chart", function (e) { return _this.onCurrentChartChanged(); });
            this.onCurrentChartChanged();
        }
        attrMgrClass.prototype.getRootElem = function () {
            return (this._jsonPanel) ? this._jsonPanel.getRootElem() : null;
        };
        attrMgrClass.prototype.close = function () {
            return (this._jsonPanel) ? this._jsonPanel.close() : null;
        };
        attrMgrClass.prototype.showAt = function (left, top, right, bottom, fadeInOpts) {
            return (this._jsonPanel) ? this._jsonPanel.showAt(left, top, right, bottom, fadeInOpts) : null;
        };
        attrMgrClass.prototype.show = function () {
            return (this._jsonPanel) ? this._jsonPanel.show() : null;
        };
        attrMgrClass.prototype.hide = function () {
            return (this._jsonPanel) ? this._jsonPanel.hide() : null;
        };
        attrMgrClass.prototype.getJsonPanel = function () {
            return this._jsonPanel;
        };
        attrMgrClass.prototype.onCurrentChartChanged = function () {
            var _this = this;
            //---- unregister events from old chart ----
            if (this._currentChart) {
                var attr = this.getAttribute();
                attr.unregisterForChanges(this, null, true);
            }
            //---- register events from new chart ----
            this._currentChart = this._chartRouter.getChart();
            if (this._currentChart) {
                var attr = this.getAttribute();
                attr.registerForRemovableChange(null, this, function (e) {
                    _this.onDataChanged(e);
                });
            }
        };
        attrMgrClass.prototype.getAttribute = function () {
            var attribute = this._chartRouter.getAttribute(this._attributeName);
            return attribute;
        };
        //attrCall(methodName: string)
        //{
        //    var attribute = this.getAttribute();
        //    return attribute[methodName].apply(attribute, arguments);
        //}
        attrMgrClass.prototype.isSet = function () {
            var attribute = this.getAttribute();
            return attribute.isSet.apply(attribute, arguments);
        };
        attrMgrClass.prototype.mappingData = function (value) {
            var attribute = this.getAttribute();
            return (attribute) ? attribute.mappingData.apply(attribute, arguments) : null;
        };
        attrMgrClass.prototype.colName = function (value, omitLogging, rebindColInfo) {
            var attribute = this.getAttribute();
            return attribute.colName.apply(attribute, arguments);
        };
        attrMgrClass.prototype.defaultBinCountForColumn = function (colName) {
            var attribute = this.getAttribute();
            return attribute.defaultBinCountForColumn.apply(attribute, arguments);
        };
        attrMgrClass.prototype.getMaxKeysForColumn = function (colName) {
            var attribute = this.getAttribute();
            return attribute.getMaxKeysForColumn.apply(attribute, arguments);
        };
        attrMgrClass.prototype.onColNameChanged = function (forceColRemap, omitOnMappingCall) {
            vp.utils.debug("onColNameChanged...");
            var attribute = this.getAttribute();
            var md = attribute.mappingData();
            if (attribute._colOptMgr) {
                var opts = attribute._colOptMgr.getOrMakeOptions(md.colName);
                try {
                    //---- apply column-remembered options when we change our colName ----
                    attribute._isMappingEnabled = false; // prevent multiple calls during this sequence
                    this.forceCategory(opts.forceCategory, true);
                    this.customBreaks(opts.customBreaks, true);
                    this.useCustomBreaks(opts.useCustomBreaks, true);
                    this.customLabels(opts.customLabels, true);
                    this.useCustomLabels(opts.useCustomLabels, true);
                    this.useNiceNumbers(opts.useNiceNumbers, true);
                    var strBinSort = beachParty.BinSorting[opts.binSort];
                    this.binSorting(strBinSort, false, true);
                    var strSpread = beachParty.MappingSpread[opts.valueSpread];
                    this.valueSpread(strSpread, true);
                    this.setMappingDataFormatting();
                }
                finally {
                    attribute._isMappingEnabled = true;
                    if (!omitOnMappingCall) {
                        this.onMappingChanged(true);
                    }
                }
            }
            if (this._jsonPanel) {
                this.updateAttrPanel(this._jsonPanel);
            }
            this.onDataChanged("colName");
        };
        attrMgrClass.prototype.calcCustomBreaks = function () {
            var attribute = this.getAttribute();
            return attribute.calcCustomBreaks.apply(attribute, arguments);
        };
        attrMgrClass.prototype.getCommaSeparatedValues = function (str) {
            var attribute = this.getAttribute();
            return attribute.getCommaSeparatedValues.apply(attribute, arguments);
        };
        attrMgrClass.prototype.onCustomStuffChanged = function () {
            var attribute = this.getAttribute();
            return attribute.onCustomStuffChanged.apply(attribute, arguments);
        };
        attrMgrClass.prototype.onMappingChanged = function (binCountChanged, omitDataChangedCall) {
            var attribute = this.getAttribute();
            return attribute.onMappingChanged.apply(attribute, arguments);
        };
        attrMgrClass.prototype.pushUiUpdate = function () {
            var attribute = this.getAttribute();
            var md = attribute.mappingData();
            this._app.setAxisButtonText(md.attrName, md.colName);
        };
        attrMgrClass.prototype.setBinCountFromDefault = function () {
            var attribute = this.getAttribute();
            return attribute.setBinCountFromDefault.apply(attribute, arguments);
        };
        attrMgrClass.prototype.binCount = function (value) {
            var attribute = this.getAttribute();
            return (attribute) ? attribute.binCount.apply(attribute, arguments) : 0;
        };
        attrMgrClass.prototype.sliderBinCount = function (value) {
            var attribute = this.getAttribute();
            return (attribute) ? attribute.sliderBinCount.apply(attribute, arguments) : 0;
        };
        attrMgrClass.prototype.binSorting = function (value, disableNotify, skipOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.binSorting.apply(attribute, arguments);
        };
        attrMgrClass.prototype.setMappingDataFormatting = function () {
            var attribute = this.getAttribute();
            return attribute.setMappingDataFormatting.apply(attribute, arguments);
        };
        attrMgrClass.prototype.forceCategory = function (value, skipOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.forceCategory.apply(attribute, arguments);
        };
        attrMgrClass.prototype.useNiceNumbers = function (value, omitOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.useNiceNumbers.apply(attribute, arguments);
        };
        attrMgrClass.prototype.updateNiceNumbersInMapping = function (md) {
            var attribute = this.getAttribute();
            return attribute.updateNiceNumbersInMapping.apply(attribute, arguments);
        };
        attrMgrClass.prototype.valueSpread = function (value, omitOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.valueSpread.apply(attribute, arguments);
        };
        attrMgrClass.prototype.useCustomBreaks = function (value, skipOptUpdate) {
            var attribute = this.getAttribute();
            return attribute.useCustomBreaks.apply(attribute, arguments);
        };
        attrMgrClass.prototype.customBreaks = function (value, skipOptUpdate) {
            var attribute = this.getAttribute();
            return attribute.customBreaks.apply(attribute, arguments);
        };
        attrMgrClass.prototype.useCustomLabels = function (value, skipOptUpdate) {
            var attribute = this.getAttribute();
            return attribute.useCustomLabels.apply(attribute, arguments);
        };
        attrMgrClass.prototype.customLabels = function (value, skipOptUpdate) {
            var attribute = this.getAttribute();
            return attribute.customLabels.apply(attribute, arguments);
        };
        attrMgrClass.prototype.isLegendBottomUp = function (value, omitOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.isLegendBottomUp.apply(attribute, arguments);
        };
        attrMgrClass.prototype.clearForDataChanged = function () {
            var attribute = this.getAttribute();
            return attribute.clearForDataChanged.apply(attribute, arguments);
        };
        attrMgrClass.prototype.updateAttrPanel = function (jsonPanel) {
            var _this = this;
            var attribute = this.getAttribute();
            var md = attribute.mappingData();
            this._jsonPanel = jsonPanel;
            if (jsonPanel) {
                //---- on first use of panel, hook the "close" to keep _jsonPanel current ----
                jsonPanel.registerForRemovableChange("close", this, function (e) {
                    _this.onClose();
                });
            }
            var usingBins = this._chartRouter.isChartUsingBins(md.attrName);
            //---- force the controls on all tab to be created so we can update them ----
            jsonPanel.forceTabBuild(1);
            jsonPanel.forceTabBuild(2);
            //---- update BIN OPTIONS pane ----
            var paneW = vp.select(jsonPanel.getRootElem(), "#binOptionsPane");
            vp.select(paneW[0], ".panePrompt")
                .text("Other options for: " + md.colName);
            //---- update MAPPING OPTIONS pane ----
            var paneW = vp.select(jsonPanel.getRootElem(), "#mappingOptionsPane");
            vp.select(paneW[0], ".panePrompt")
                .text("Break options for: " + md.colName);
            //---- disable "force category" if colType is string ----
            var colType = this._app.getColType(md.colName);
            var isDisabled = (colType == "string");
            var assemblyW = vp.select(jsonPanel.getRootElem(), "#cbForceCategory");
            beachParty.appUtils.disableCheckbox(assemblyW, isDisabled);
            //---- disable "value spread" if chart is bin type ----
            var assemblyW = vp.select(jsonPanel.getRootElem(), "#ddValueSpread");
            beachParty.appUtils.disableEnum(assemblyW, usingBins);
            //---- disable "bin sort" if chart is NOT bin type ----
            var assemblyW = vp.select(jsonPanel.getRootElem(), "#ddBinSort");
            beachParty.appUtils.disableEnum(assemblyW, (!usingBins));
        };
        attrMgrClass.prototype.onClose = function () {
            //---- unregister with other data objects to avoid leaking memory ----
            //this._app.unregisterForChanges(this, "chart");
            //this._chartRouter.unregisterForChanges(this, "chart");
            //var attr = this.getAttribute();
            //attr.unregisterForChanges(this, null, true);
            if (this._jsonPanel) {
                this._jsonPanel.unregisterForChanges(this, "close");
                this._jsonPanel = null;
            }
            this.onDataChanged("close");
        };
        return attrMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.attrMgrClass = attrMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    lineMgr.ts - manages the LINE attribute (for the LINE BY mapping).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var lineMgrClass = (function (_super) {
        __extends(lineMgrClass, _super);
        function lineMgrClass(app, currentChart) {
            _super.call(this, app, currentChart, "color");
        }
        lineMgrClass.prototype.maxLineShapes = function (value, omitLogging) {
            var attribute = this.getAttribute();
            return attribute.maxLineShapes.apply(attribute, arguments);
        };
        lineMgrClass.prototype.lineColor = function (value, omitLogging) {
            var attribute = this.getAttribute();
            return attribute.lineColor.apply(attribute, arguments);
        };
        return lineMgrClass;
    }(beachParty.attrMgrClass));
    beachParty.lineMgrClass = lineMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    navPanel.ts - sets mouse/touch drag action for 3D nav, while panel is open.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    if (!anyWindow.panelDescriptions) {
        anyWindow.panelDescriptions = {};
    }
    anyWindow.panelDescriptions.aboutPanel =
        {
            title: "About SandDance",
            tip: "View information about SandDance and access (for internal use) Debug and Test pages",
            //isDialog: true,
            minWidth: 300,
            tabs: [
                {
                    tabName: "About", tip: "Information about the SandDance apo", rows: [
                        { image: "SandDanceLogoTransparent.png", textAlign: "left", marginTop: 15 },
                        {
                            newRowIndent: true, prompt: "SandDance, Copyright (c) 2016, Microsoft Corporation.  All rights reserved.",
                            marginRight: 20, marginTop: 10
                        },
                        {
                            newRowIndent: true, display: null, marginRight: 20, dataName: "buildInfo", marginLeft: -4,
                        },
                        {
                            newRowIndent: true, prompt: "Brought to you by Steven M. Drucker, Roland Fernandez, and the extended SandDance team at Microsoft Research.",
                            maxWidth: 150, marginRight: 20, marginTop: 10
                        },
                        {
                            newRowIndent: true, prompt: "For more infomation, visit our <a class='panelLink' target='_blank' " +
                                "href='http://sanddancehome.azurewebsites.net'>website</a>, " +
                                "or email us at <a class='panelLink' target='_blank' href='mailto:sanddance@microsoft.com'" +
                                "> SandDance </a>.",
                            isHtml: true
                        },
                        {
                            newRowIndent: true, prompt: "Third party data and library attribution can be found <a class='panelLink' target='_blank' href='https://sanddancehome.azurewebsites.net/?page_id=6591'>here</a >.",
                            maxWidth: 150, marginRight: 20, marginTop: 10, isHtml: true
                        },
                    ]
                },
                {
                    tabName: "Stats", tip: "Information about app operation", rows: [
                        {
                            prompt: "Shape Buffers:", marginRight: 20, marginTop: 10
                        },
                        {
                            //---- "opsInfo" is 5 lines of text ----
                            newRowIndent: true, display: null, marginRight: 20, dataName: "opsInfo", isHtml: true,
                        },
                        {
                            prompt: "Last Cycle:", marginRight: 20, marginTop: 10
                        },
                        {
                            //---- "lastCycleInfo" is 5 lines of text ----
                            newRowIndent: true, display: null, marginRight: 20, dataName: "lastCycleInfo", isHtml: true,
                        },
                        {
                            prompt: "Build Chart Detail:", marginRight: 20, marginTop: 10
                        },
                        {
                            //---- "buildChartDetail" is 3 lines of text ----
                            newRowIndent: true, display: null, marginRight: 20, dataName: "buildChartDetail", isHtml: true,
                        },
                    ]
                },
                //{
                //    tabName: "Debug", tip: "Internal settings for use by the SandDance development team", rows:
                //    [
                //        { prompt: "Info:", tip: "General debug support" },
                //        { newRowIndent: true, checkbox: "Engine drawing stats", tip: "Show chart engine stats info at top of chart", dataName: "isShowingDrawStats" },
                //        { newRowIndent: true, checkbox: "Last cycle stats", tip: "Show summary of stats from last animation cycle", dataName: "isShowingLastCycle" },
                //        { newRowIndent: true, checkbox: "Event stats", tip: "Show event attach/fire stats", dataName: "isShowingEventStats" },
                //        { newRowIndent: true, checkbox: "Disable error reporting", tip: "Turn off display of errors in client UI", dataName: "isErrorReportingDisabled" },
                //        { prompt: "Memory:", tip: "Memory usage information" },
                //        { newRowIndent: true, button: "Plot memory use", tip: "Plot memory used by major engine objects", dataName: "plotEngineMemoryUse" },
                //        { prompt: "Other:", tip: "Other debug-related controls" },
                //        { newRowIndent: true, button: "Plot engine events", tip: "Plot the most recent engine trace events", dataName: "plotEngineEvents" },
                //    ]
                //},
                {
                    tabName: "Diagnostics",
                    tip: "Information about app operation",
                    rows: [
                        {
                            prompt: "Hit Testing:", marginRight: 20, marginTop: 10
                        },
                        {
                            newRowIndent: true, display: "Cursor: ", marginRight: 20, dataName: "cursorHitTestLoc", tip: "The location of the mouse cursor for hit-testing shapes",
                        },
                        {
                            newRowIndent: true, display: "Shape: ", marginRight: 20, dataName: "cursorHitTestShape", tip: "The shape found from most recent hit-testing of cursor",
                        },
                        {
                            prompt: "Show Frames:", marginRight: 20, marginTop: 10
                        },
                        { newRowIndent: true, checkbox: "Client", tip: "Show the border around the Client Area of the chart", dataName: "showClientFrame" },
                        { newRowIndent: true, checkbox: "GlCanvas", tip: "Show the border around the WegGL canvas", dataName: "showGlCanvasFrame" },
                        { newRowIndent: true, checkbox: "ChartUX", tip: "Show the border around the canvas used for pointer-events", dataName: "showChartUxFrame" },
                    ]
                }
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    renamePanel.ts - dialog panel to rename a item.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.renamePanel =
        {
            title: "Rename",
            isDialog: true,
            autoClose: true,
            rows: [
                {
                    textBox: "Name:", tip: "The name of the item", dataName: "editItemName", width: "150px",
                    tabIndex: 1
                },
                { emptyRow: true },
                {
                    newRowIndent: true, button: "OK", tip: "Rename the item and close the panel", width: 80, textAlign: "right",
                    defaultButton: true, acceptButton: true, dataName: "onRenameOK", tabIndex: 100, closeAction: true,
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    themesPanel.ts - describes the panel for loading and manager Themes
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.themesPanel =
        {
            title: "Themes",
            cellPadding: "8px 2px 0px 2px",
            isFloating: true,
            rows: [
                { prompt: "Select theme:", tip: "Select the current theme", marginTop: 0 },
                {
                    newRowIndent: true, themePicker: null, tip: "Select a standard or cached theme", dataName: "themeName",
                },
                {
                    sameRow: true, button: null, img: "menuBars.png", width: 24,
                    tip: "Select an action for the specified Theme", leftMargin: 4, id: "btMenu"
                },
                { prompt: "Set current:", tip: "Control the running of the specified theme", marginTop: 10 },
                {
                    button: "Load", tip: "Load the specified theme as the new current theme",
                    defaultButton: true, dataName: "onLoadTheme", tabIndex: 100, closeAction: false,
                    textAlign: "center", colSpan: 99, width: 80, marginTop: 0,
                },
            ]
        };
})(beachParty || (beachParty = {}));
//---- NOTE: this file should be directly in the project folder (NOT under "scripts") ----
//---- NOTE #2: this file does NOT need to be referenced by each *.ts file; it will be implicitly referenced by VS/TSC.
/// <reference path="scripts/thirdParty/hammer.d.ts" /> 
/// <reference path="scripts/thirdParty/jszip.d.ts" />  
/// <reference path="scripts/vuePlotCore.d.ts" />     
/// <reference path="scripts/beachPartyShape.d.ts" />     
/// <reference path="scripts/beachPartyChart.d.ts" />     
//---- this list of TS files is needed to control the order the files in which the files and processed and loaded ----
/// <reference path="controls/baseAppControl.ts" /> 
/// <reference path="controls/basePopup.ts" /> 
/// <reference path="panelMgrs/basePanel.ts" /> 
/// <reference path="panelMgrs/jsonPanel.ts" />
/// <reference path="controls/baseJsonControl.ts" /> 
/// <reference path="controls/numAdjustDial.ts" /> 
/// <reference path="controls/numAdjustSlider.ts" /> 
/// <reference path="controls/popupMenu.ts" />
/// <reference path="classes/app.ts" /> 
/// <reference path="panelMgrs/attrMgr.ts" /> 
/// <reference path="panelMgrs/lineMgr.ts" />
//---- panels ----
/// <reference path="panels/aboutPanel.ts" /> 
/// <reference path="panels/renamePanel.ts" /> 
/// <reference path="panels/themesPanel.ts" /> 
///-----------------------------------------------------------------------------------------------------------------
/// dataEngine.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - manages data access for BeachParty.
///----------------------------------------------------------------------------------------------------------------- 
var beachParty;
(function (beachParty) {
    var dataEngineClass = (function (_super) {
        __extends(dataEngineClass, _super);
        function dataEngineClass(app, isCachingWebFiles) {
            _super.call(this);
            this._dataCacheParams = new beachParty.DataCacheParams();
            this._app = app;
            this._preloadMgr = new beachParty.preloadMgrClass();
            this._relationMgr = new beachParty.relationMgrClass(app);
            this._dataCacheParams.cacheWebFiles = isCachingWebFiles;
        }
        dataEngineClass.prototype.getRelationMgr = function () {
            return this._relationMgr;
        };
        dataEngineClass.prototype.createDataMgr = function () {
            var dataMgr = new beachParty.dataMgrClassEx(this._app, this, this._preloadMgr, this._dataCacheParams.cacheWebFiles);
            return dataMgr;
        };
        dataEngineClass.prototype.getKnownPreloads = function (callback) {
            var preloads = this._preloadMgr.getPreloads();
            callback(preloads);
        };
        dataEngineClass.prototype.dataCacheParams = function (value) {
            if (arguments.length == 0) {
                return this._dataCacheParams;
            }
            this._dataCacheParams = value;
            this.onDataChanged("dataCacheParams");
        };
        dataEngineClass.prototype.isCacheWebFiles = function (value) {
            return (this._dataCacheParams != null && this._dataCacheParams.cacheWebFiles);
        };
        return dataEngineClass;
    }(beachParty.dataChangerClass));
    beachParty.dataEngineClass = dataEngineClass;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// dataMgrEx.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - this class adds data loading to the dataMgr class it extends.
///     - most (or all?) of the methods on this class should be asynch, accepting a callback as their last param.
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var dataMgrClassEx = (function (_super) {
        __extends(dataMgrClassEx, _super);
        function dataMgrClassEx(app, dataEngine, preloadMgr, isCachingWebFiles) {
            var _this = this;
            _super.call(this, preloadMgr, true, isCachingWebFiles);
            this._loadedFileOpenText = null;
            this._pendingChangeFlags = 0;
            this._changeTimer = null;
            this._app = app;
            this._dataEngine = dataEngine;
            //---- hook internal events to gather flags and trigger onDataChange event ----
            //---- DON"T PROCESS SELECTION/FILTER FOR NOW (THEY ORIGINATE IN PLOT ENGINE) ----
            //this.registerForChange("selection", (e) =>
            //{
            //    this.queueDataChangeFlag(DataChangeFlag.selectionChange);
            //});
            //this.registerForChange("filtered", (e) =>
            //{
            //    this.queueDataChangeFlag(DataChangeFlag.filterChange);
            //});
            //this.registerForChange("dataFrame", (e) =>
            //{
            //    this.queueDataChangeFlag(DataChangeFlags.dataSetChange);
            //});
            this.registerForChange("sortOrder", function (e) {
                _this.queueDataChangeFlag(beachParty.DataChangeFlags.sortOrder);
            });
            this.registerForChange("colMappings", function (e) {
                _this.queueDataChangeFlag(beachParty.DataChangeFlags.columnsChange);
            });
        }
        dataMgrClassEx.prototype.queueDataChangeFlag = function (flag) {
            this._pendingChangeFlags |= flag;
            //if (!this._changeTimer)
            //{
            //    this._changeTimer = setTimeout((e) =>
            //    {
            //        this.triggerDataChange();
            //    }, 1);
            //}
            this.triggerDataChange();
        };
        dataMgrClassEx.prototype.triggerDataChange = function () {
            this.onDataChange.trigger({ sender: this, changeFlags: this._pendingChangeFlags });
            this._pendingChangeFlags = 0;
            this._changeTimer = null;
        };
        dataMgrClassEx.prototype.loadFileFromRelationMgr = function (name, callback) {
            var _this = this;
            var relationMgr = this._dataEngine.getRelationMgr();
            relationMgr.getFileText(name, function (text, fn) {
                _this._loadedFileOpenText = text;
                callback();
            });
        };
        dataMgrClassEx.prototype.getWdParams = function (url, fileType, scrubberTemplate, fileHasHeader) {
            var wdParams = null;
            var fn = beachParty.appUtils.getLastNodeOfUrl(url);
            if (scrubberTemplate) {
                wdParams = this.getPreloadFromLocalStorage(scrubberTemplate); // fn, "local");
            }
            if (!wdParams) {
                wdParams = new beachParty.WorkingDataParams(fn, url);
                wdParams.hasHeader = fileHasHeader;
                wdParams.separator = (fileType == "tab") ? "\t" : ",";
                wdParams.fileType = (fileType == "json") ? beachParty.FileType.json : beachParty.FileType.delimited;
                wdParams.fileSource = "local";
            }
            return wdParams;
        };
        dataMgrClassEx.prototype.loadLocalFile = function (url, fileType, dataScrubberName, fileHasHeader, callback) {
            if (url) {
                var parts = url.split(" "); // get first file
                url = parts[0].trim(); // remove leading/tailing spaces
                var isLocal = true;
                var fn = beachParty.appUtils.getLastNodeOfUrl(url);
                var wdParams = this.getWdParams(url, fileType, dataScrubberName, fileHasHeader);
                var relationMgr = this._dataEngine.getRelationMgr();
                //---- TODO: present user with a dialog for each file opened and allow him to set the wdParams for each ----
                relationMgr.setFileObjs(this._fileOpenObjs, wdParams);
                var text = this._loadedFileOpenText;
                var length = (text) ? text.length : 0;
                this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.button, beachParty.Action.load, beachParty.Target.data, true, { source: "local", length: length, fileType: fileType, hasHeader: fileHasHeader, usingScrubber: (dataScrubberName != null) });
                var dcp = this._dataEngine.dataCacheParams();
                if (dcp.cacheLocalFiles) {
                    var obj = { data: text, wdParams: wdParams };
                    var value = JSON.stringify(obj);
                    beachParty.localStorageMgr.save(beachParty.StorageType.dataFile, beachParty.StorageSubType.local, url, value);
                }
                this.loadFrom(text, fn, wdParams, callback);
            }
        };
        dataMgrClassEx.prototype.reloadDataPerScrubbing = function (editInfos, preload, callback) {
            //---- build fieldlist for preload ----
            var fieldList = [];
            for (var i = 0; i < editInfos.length; i++) {
                var ei = editInfos[i];
                if (ei.isVisible) {
                    var cfExpress = (ei.name == ei.displayName) ? null : ei.name;
                    var pf = new beachParty.PreloadField(ei.displayName, ei.desc, cfExpress, ei.colType, ei.stats.sortedKeys);
                    pf.valueMap = ei.valueMap;
                    fieldList.push(pf);
                }
            }
            preload.fieldList = fieldList;
            var strValue = JSON.stringify(preload);
            beachParty.localStorageMgr.save(beachParty.StorageType.preload, beachParty.StorageSubType.local, preload.filePath, strValue);
            //this._app.showMsg("Reloadng data", preload.filePath, "Please wait...");
            this.onDataLoadStart.trigger({ sender: this, fn: preload.filePath });
            this.setDataDirect(this._loadedFileOpenText, preload);
            if (callback) {
                callback(this.getDataFrame(), this, preload);
            }
        };
        dataMgrClassEx.prototype.getDataFrameMin = function () {
            return _super.prototype.getDataFrame.call(this);
        };
        dataMgrClassEx.prototype.loadedFileOpenText = function (value) {
            if (arguments.length == 0) {
                return this._loadedFileOpenText;
            }
            this._loadedFileOpenText = value;
            this.onDataChanged("loadedFileOpenText");
        };
        dataMgrClassEx.prototype.loadData = function (wdParams, callback) {
            this.loadDataFromServer(wdParams, callback);
        };
        dataMgrClassEx.prototype.loadDataFromServer = function (wdParams, callback) {
            var _this = this;
            var requestId = 0;
            if (!wdParams || this.isFileLoaded(wdParams)) {
                //---- file is already loaded; process the properties sync ----
                callback(this.getDataFrame(), this, wdParams);
            }
            else {
                //---- load file and then process the properties ----
                this.openPreloadAsync(wdParams, function (df) {
                    //---- don't draw twice; let client request the only draw in this sequence ----
                    //view.cancelRquestedDraw();
                    callback(_this.getDataFrame(), _this, wdParams);
                });
            }
        };
        dataMgrClassEx.prototype.setFileOpenObjects = function (objs) {
            this._fileOpenObjs = objs;
        };
        dataMgrClassEx.prototype.loadKnownDataFromServer = function (name, callback) {
            var _this = this;
            this.loadKnownAsync(name, null, function (dataFrame, preload) {
                callback(dataFrame, _this, preload);
            });
        };
        /** load the file from cache or as known file. */
        dataMgrClassEx.prototype.autoloadFile = function (wdParams, callback) {
            /// Note: the app client loads LOCAL files from cache and sends to engine, but
            /// WEB ("url") files should be loaded directly by the engine (to save large file memeory usage and
            /// transfer time.
            wdParams.canLoadFromCache = true;
            var filename = wdParams.dataName;
            var foundData = true;
            if (wdParams.fileSource == "known" || wdParams.fileSource == null) {
                //---- openKnownFile ignores wdParams, so use loadData instead ----
                this.openKnownFile(filename, false, callback);
            }
            else if (wdParams.fileSource == "url" || wdParams.fileSource == "sql") {
                if ((window.external && window.external.isHosted)) {
                    //---- ask our hosting app to open the file for us ----
                    window.external.requestFile(wdParams.fileSource, wdParams.dataName, wdParams.filePath, wdParams.separator);
                }
                else {
                    this.loadData(wdParams, callback);
                }
            }
            else {
                var text = this.getLocalFileFromCache(wdParams);
                if (text) {
                    this.loadFrom(text, filename, wdParams, callback);
                }
                else {
                    foundData = false;
                }
            }
            return foundData;
        };
        dataMgrClassEx.prototype.loadFrom = function (data, fn, wdParams, callback) {
            //this._app.showMsg("Loading data", fn, "Please wait...");
            this.onDataLoadStart.trigger({ sender: this, fn: fn });
            if (!wdParams) {
                var wdParams = new beachParty.WorkingDataParams(fn);
                wdParams.fileType = beachParty.FileType.json;
            }
            //---- supply a dataName so we can refer to this open data source when needed ----
            if (!wdParams.dataName) {
                wdParams.dataName = fn;
            }
            this._loadedFileOpenText = data;
            //this._currentChart.setData(data, wdParams, callback);
            this.setDataDirect(data, wdParams);
            if (callback) {
                callback(this.getDataFrame(), this, this.getPreload());
            }
        };
        dataMgrClassEx.prototype.getLocalFileFromCache = function (wdParams, reportError) {
            var text = null;
            //---- autoload LOCAL file ----
            var filename = wdParams.dataName;
            var isCached = beachParty.localStorageMgr.isPresent(beachParty.StorageType.dataFile, beachParty.StorageSubType.local, filename);
            if (isCached) {
                var strEntry = beachParty.localStorageMgr.get(beachParty.StorageType.dataFile, beachParty.StorageSubType.local, filename);
                var entry = JSON.parse(strEntry);
                var text = entry.data;
                this.onDataLoadStart.trigger({ sender: this, fn: filename });
            }
            else {
                if (reportError) {
                    throw "Cannot load file from cache: " + wdParams.filePath;
                }
            }
            return text;
        };
        dataMgrClassEx.prototype.isHosted = function () {
            return (window.external && window.external.isHosted);
        };
        /**
         * This is the normal start of loading a known data file. It supports just closing the current file,
         * loading a file via a hosting app, loading from local storage/cache, and calling our beachParty server
         * to load the file.
         * @param name
         * @param fromUI
         * @param callback
         */
        dataMgrClassEx.prototype.openKnownFile = function (name, fromUI, callback) {
            var _this = this;
            //---- clear local file data from last load ----
            this._loadedFileOpenText = null;
            if (name.toLowerCase() == "none") {
                if (fromUI) {
                    this._app.logAction(beachParty.Gesture.select, null, beachParty.ElementType.picklist, beachParty.Action.load, beachParty.Target.data, true, { fileName: name, source: "known" });
                }
                this.loadFrom("", name, null, callback);
            }
            else {
                vp.select("#filenameText")
                    .text("[loading file: " + name + "]");
                this.onDataLoadStart.trigger({ sender: this, fn: name });
                if (this.isHosted()) {
                    //---- ask host to load ----
                    var anyExt = window.external;
                    anyExt.requestFile("known", name, name, "");
                }
                else {
                    var preload = this.getPreloadFromLocalStorage(name, "known");
                    if (preload) {
                        this.loadData(preload, function (dataFrame, dataMgr) {
                            if (fromUI) {
                                _this._app.logAction(beachParty.Gesture.select, null, beachParty.ElementType.picklist, beachParty.Action.load, beachParty.Target.data, true, { fileName: name, source: "known" });
                            }
                            if (callback) {
                                callback(dataFrame, dataMgr, preload);
                            }
                        });
                    }
                    else {
                        //vp.utils.debug("requesting known file=" + name);
                        this.loadKnownDataFromServer(name, function (dataFrame, dataMgr, preload) {
                            if (fromUI) {
                                _this._app.logAction(beachParty.Gesture.select, null, beachParty.ElementType.picklist, beachParty.Action.load, beachParty.Target.data, true, { fileName: name, source: "known" });
                            }
                            if (callback) {
                                callback(dataFrame, dataMgr, preload);
                            }
                        });
                    }
                }
            }
        };
        dataMgrClassEx.prototype.getPreloadFromLocalStorage = function (fn, fileSource, tableName) {
            var preload = null;
            var subtype = beachParty.StorageSubType[fileSource];
            var str = beachParty.localStorageMgr.get(beachParty.StorageType.preload, subtype, fn, tableName);
            if (str && str.length) {
                preload = JSON.parse(str);
            }
            return preload;
        };
        return dataMgrClassEx;
    }(beachParty.dataMgrClass));
    beachParty.dataMgrClassEx = dataMgrClassEx;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    localFileHelper.ts - helps open and save to local files.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var localFileHelper = (function () {
        function localFileHelper() {
        }
        localFileHelper.loadFile = function (settings, fileExts, callback) {
            //---- click on the hidden FILE button to invoke the brower's FILE OPEN dialog ----
            var button = document.getElementById("inputFileOpen");
            button.setAttribute("accept", fileExts);
            //---- MUST clear out previous contents of button (or onchange may not work) ----
            button.onchange = null;
            vp.dom.value(button, "");
            var anyButton = button;
            button.onchange = function (e) {
                var file = anyButton.files[0];
                localFileHelper.loadFileFromFileObj(settings, file, callback);
            };
            button.click();
        };
        localFileHelper.isZipFile = function (fn) {
            var isZip = false;
            if (fn) {
                isZip = fn.endsWith(beachParty.insightMgrClass.fileExt);
            }
            return isZip;
        };
        localFileHelper.loadFileFromFileObj = function (settings, file, callback) {
            var million = 1000 * 1000;
            var maxSize = (false) /*vp.utils.isIE*/ ? 20 * million : 40 * million;
            if (file.size > maxSize) {
                throw "File too large: " + vp.formatters.comma(file.size);
            }
            if (beachParty.cbUtils.isImageFile(file.name)) {
                localFileHelper.loadImgFileFromFileObj(file, function (url, fn) {
                    //---- load IMAGE file ----
                    localFileHelper.loadImageFromUrl(url, function (df, colCount) {
                        var preload = new beachParty.Preload(fn);
                        var cm = new beachParty.ColorMappingData();
                        preload.colMappings.color = cm;
                        cm.colName = "red";
                        callback(df, fn, preload);
                    });
                });
            }
            else if (this.isZipFile(file.name)) {
                localFileHelper.loadBlobFileFromFileObj(file, callback);
            }
            else {
                localFileHelper.loadTextFileFromFileObj(settings, file, callback);
            }
        };
        /** loads image as 1 pixel per row, with columns: x, y, r, g, b, a. */
        localFileHelper.loadImageFromUrl = function (url, callback) {
            var img = new Image();
            img.onload = function (e) {
                var width = img.width;
                var height = img.height;
                var canvas = document.createElement("canvas");
                canvas.width = width;
                canvas.height = height;
                var ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0);
                var imgData = ctx.getImageData(0, 0, width, height);
                var xVector = [];
                var yVector = [];
                var rVector = [];
                var gVector = [];
                var bVector = [];
                var aVector = [];
                var index = 0;
                for (var r = 0; r < height; r++) {
                    for (var c = 0; c < width; c++) {
                        xVector.push(c);
                        yVector.push((height - 1) - r); // correct image flip (for scatter layout)
                        rVector.push(imgData.data[index++]);
                        gVector.push(imgData.data[index++]);
                        bVector.push(imgData.data[index++]);
                        aVector.push(imgData.data[index++]);
                    }
                }
                var result = { x: xVector, y: yVector, red: rVector, green: gVector, blue: bVector, alpha: aVector };
                callback(result, width);
            };
            img.src = url;
        };
        localFileHelper.getFileOpenSelections = function (fileExts, callback) {
            //---- click on the hidden FILE button to invoke the brower's FILE OPEN dialog ----
            var button = document.getElementById("inputFileOpen");
            button.setAttribute("accept", fileExts);
            //---- MUST clear out previous contents of button (or onchange may not work) ----
            button.onchange = null;
            vp.dom.value(button, "");
            button.onchange = function (e) {
                var anyButton = button;
                var files = anyButton.files;
                //---- these are reversed and not in a true array; fix. */
                var fileObjArray = [];
                for (var i = files.length - 1; i >= 0; i--) {
                    fileObjArray.push(files[i]);
                }
                callback(fileObjArray);
            };
            button.click();
        };
        /**
         * Truncate text after seeing (1 + sampleCount) newline chars.
         * @param text
         * @param sampleCount
         */
        localFileHelper.truncateRecords = function (text, sampleCount) {
            var offset = 0;
            var count = 0;
            while (offset < text.length) {
                var index = text.indexOf("\n", offset);
                if (index == -1) {
                    break;
                }
                count++;
                offset = index + 1;
                if (count == sampleCount + 1) {
                    text = text.substr(0, offset);
                }
            }
            return text;
        };
        localFileHelper.countLinesInText = function (text) {
            var offset = 0;
            var count = 0;
            while (offset < text.length) {
                var index = text.indexOf("\n", offset);
                if (index == -1) {
                    break;
                }
                count++;
                offset = index + 1;
            }
            return count;
        };
        /**
         *  For now, only "First" sampling is supported for local text files.
         * @param fileToLoad
         * @param callback
         */
        localFileHelper.sampleLargeTextFile = function (settings, firstText, bytesPerRecord, fileToLoad, callback) {
            var sampleCount = settings.autoSamplingSampleCount();
            var totalByteCount = sampleCount * bytesPerRecord;
            if (totalByteCount > firstText.length) {
                //---- request needed text ----
                var offset = firstText.length;
                var blob = fileToLoad.slice(offset, totalByteCount);
                var fileReader = new FileReader();
                fileReader.onload = function (fileLoadedEvent) {
                    var text = fileLoadedEvent.target.result;
                    var totalText = firstText + text;
                    totalText = localFileHelper.truncateRecords(totalText, sampleCount);
                    callback(totalText, fileToLoad.name);
                };
                fileReader.readAsText(blob);
            }
            else {
                //---- don't need any more text ----
                var text = localFileHelper.truncateRecords(firstText, sampleCount);
                callback(text, fileToLoad.name);
            }
        };
        localFileHelper.loadTextFileFromFileObj = function (settings, fileToLoad, callback) {
            if (!settings.isAutoSamplingEnabled()) {
                this.loadTextFileWithoutSampling(null, fileToLoad, callback);
            }
            else {
                //---- sample a block of the text to determine if file contains enough records ----
                var fileReader = new FileReader();
                fileReader.onload = function (fileLoadedEvent) {
                    var text = fileLoadedEvent.target.result;
                    localFileHelper.loadTextFileWithSampledChunk(settings, text, fileToLoad, callback);
                };
                var blockSize = 100 * 1000; // approx 100 records
                var blob = fileToLoad.slice(0, blockSize);
                fileReader.readAsText(blob);
            }
        };
        localFileHelper.loadTextFileWithoutSampling = function (firstText, fileToLoad, callback) {
            var fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
                var text = fileLoadedEvent.target.result;
                if (firstText) {
                    text = firstText + text;
                }
                callback(text, fileToLoad.name);
            };
            if (firstText) {
                var blob = fileToLoad.slice(firstText.length, fileToLoad.size);
                fileReader.readAsText(blob);
            }
            else {
                fileReader.readAsText(fileToLoad);
            }
        };
        localFileHelper.loadTextFileWithSampledChunk = function (settings, sampledTextChunk, fileToLoad, callback) {
            //var fileToLoad = button.files[0];
            var recordsInChunk = this.countLinesInText(sampledTextChunk);
            var estBytesPerRecord = Math.floor(sampledTextChunk.length / recordsInChunk);
            var recordThreshold = settings.samplingThreshold();
            var sizeThreshold = estBytesPerRecord * recordThreshold;
            if (fileToLoad.size > sizeThreshold) {
                localFileHelper.sampleLargeTextFile(settings, sampledTextChunk, estBytesPerRecord, fileToLoad, callback);
            }
            else {
                this.loadTextFileWithoutSampling(sampledTextChunk, fileToLoad, callback);
            }
        };
        localFileHelper.loadImgFileFromFileObj = function (fileToLoad, callback) {
            //var fileToLoad = button.files[0];
            var fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
                var imgUrl = fileLoadedEvent.target.result;
                callback(imgUrl, fileToLoad.name);
            };
            fileReader.readAsDataURL(fileToLoad);
        };
        localFileHelper.loadBlobFileFromFileObj = function (fileToLoad, callback) {
            //var fileToLoad = button.files[0];
            var fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
                var arrayBuff = fileLoadedEvent.target.result;
                callback(arrayBuff, fileToLoad.name);
            };
            //fileReader.readAsDataURL(fileToLoad);
            fileReader.readAsArrayBuffer(fileToLoad);
        };
        localFileHelper.saveToLocalFile = function (fn, value, blobType) {
            if (blobType === void 0) { blobType = "text/plain"; }
            var blobObject = new Blob([value], { type: blobType });
            this.saveBlobToLocalFile(fn, blobObject, blobType);
        };
        localFileHelper.saveBlobToLocalFile = function (fn, blobObject, blobType) {
            //blobObject.type = blobType;
            if (blobType === void 0) { blobType = "text/plain"; }
            if (vp.utils.isIE) {
                window.navigator.msSaveOrOpenBlob(blobObject, fn);
            }
            else {
                var downloadLink = document.getElementById("helperAnchor");
                var anyWindow = window;
                downloadLink.download = fn;
                downloadLink.innerHTML = "Download File";
                downloadLink.href = anyWindow.URL.createObjectURL(blobObject);
                downloadLink.click();
            }
        };
        return localFileHelper;
    }());
    beachParty.localFileHelper = localFileHelper;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    relationMgr.ts - manages multiple files (tables) and the relations between them.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var relationMgrClass = (function (_super) {
        __extends(relationMgrClass, _super);
        function relationMgrClass(app) {
            _super.call(this);
            this._tableInfos = [];
            this._relationMap = {};
            this._app = app;
        }
        relationMgrClass.prototype.getFileObjs = function () {
            return this._fileObjs;
        };
        relationMgrClass.prototype.setFileObjs = function (value, preload) {
            this._preload = preload;
            this._fileObjs = (value) ? value : [];
            this.buildRelations();
        };
        relationMgrClass.prototype.buildRelations = function () {
            var relMap = {};
            this._relationMap = relMap;
            this.buildTableInfos(0);
            //---- TODO: build relMap when all of the async buildColInfos() calls complete ----
        };
        relationMgrClass.prototype.buildTableInfos = function (index) {
            var tableInfos = [];
            for (var i = 0; i < this._fileObjs.length; i++) {
                var fileObj = this._fileObjs[i];
                var tableInfo = new TableInfo();
                tableInfo.name = fileObj.name;
                tableInfo.fileObj = fileObj;
                //---- don't use as is (causes 2 extra files loads) ----
                //this.buildColInfos(tableInfo, fileObj);
                tableInfos.push(tableInfo);
            }
            this._tableInfos = tableInfos;
        };
        relationMgrClass.prototype.buildColInfos = function (tableInfo, fileObj) {
            var _this = this;
            var settings = this._app._appSettingsMgr;
            beachParty.localFileHelper.loadFileFromFileObj(settings, fileObj, function (data, fn, preload) {
                if (!preload) {
                    preload = _this._preload;
                }
                if (vp.utils.isString(data)) {
                    if (preload) {
                        var hasHeader = preload.hasHeader;
                        var separator = preload.separator;
                    }
                    var csv = new beachParty.csvColLoaderClass(data, hasHeader, separator, true, false);
                    var df = csv.buildDataFrameWithEmptyVectors();
                }
                else {
                    var df = new beachParty.dataFrameClass(data);
                }
                var colInfos = [];
                var names = df.getColumnNames();
                for (var i = 0; i < names.length; i++) {
                    var colType = df.getColType(name);
                    var colInfo = new beachParty.ColInfo(name, null, colType, null);
                    colInfos.push(colInfo);
                }
                tableInfo.colInfos = colInfos;
            });
        };
        relationMgrClass.prototype.getFileObj = function (name) {
            var fileObj = null;
            if (this._fileObjs) {
                for (var i = 0; i < this._fileObjs.length; i++) {
                    var obj = this._fileObjs[i];
                    if (obj.name == name) {
                        fileObj = obj;
                        break;
                    }
                }
            }
            return fileObj;
        };
        relationMgrClass.prototype.getFileText = function (name, callback) {
            var fileObj = this.getFileObj(name);
            if (!fileObj) {
                throw "Fileset doesn't contain named file=" + name;
            }
            var settings = this._app._appSettingsMgr;
            beachParty.localFileHelper.loadFileFromFileObj(settings, fileObj, callback);
        };
        relationMgrClass.prototype.getFileCount = function () {
            return (this._fileObjs) ? this._fileObjs.length : 0;
        };
        relationMgrClass.prototype.getFileNames = function () {
            var list = [];
            if (this._fileObjs) {
                list = this._fileObjs.map(function (fileObj) {
                    return fileObj.name;
                });
            }
            return list;
        };
        return relationMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.relationMgrClass = relationMgrClass;
    (function (RelType) {
        RelType[RelType["oneToOne"] = 0] = "oneToOne";
        RelType[RelType["oneToMany"] = 1] = "oneToMany";
        RelType[RelType["manyToOne"] = 2] = "manyToOne";
    })(beachParty.RelType || (beachParty.RelType = {}));
    var RelType = beachParty.RelType;
    var Relation = (function () {
        function Relation() {
        }
        return Relation;
    }());
    beachParty.Relation = Relation;
    var TableInfo = (function () {
        function TableInfo() {
        }
        return TableInfo;
    }());
    beachParty.TableInfo = TableInfo;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    appPreLoad.ts - pre-app code to load our HTML dynamically and run theme-related initialization.
//-------------------------------------------------------------------------------------
// Design of z-index for SandDance UI:
//  - old browser msg:  9999
//  - logo:             5001 during load, 1 after load
//  - Shape tooltips:   2005
//  - Popup menus:      2001
//  - Number slider:    1999
//  - Panels:           1005
//  - z-stuff:           999
//  - right panel:         1
//-------------------------------------------------------------------------------------
function loadHtmlAndCreateApp(appDiv, iconPath, scriptCmds) {
    //---- first code of app ----
    loadAppStyle();
    loadAppHtml(appDiv);
    //---- early theme loading ----
    //---- create early theme so that page color and SANDDANCE logo match the correct theme ----
    //---- NOTE: we don't have any of our script libraries loaded yet, so use standalone javascript ----
    //---- find current theme name from: cmdline, localStorage, or default ----
    var anyWin = window;
    anyWin.themeName = "blacksBeach"; // our default
    //---- check cmd line ----
    var url = window.location.href;
    var index = url.indexOf("?");
    var foundInCmdLine = false;
    if (index > -1) {
        var params = url.substr(index + 1);
        index = params.indexOf("theme=");
        if (index > 0) {
            anyWin.themeName = params.substr(index + 6).trim();
            foundInCmdLine = true;
            index = anyWin.themeName.indexOf("&");
            if (index > -1) {
                anyWin.themeName = anyWin.themeName.substr(0, index);
            }
        }
    }
    if (!foundInCmdLine) {
        //---- check localstorage ----
        if (localStorage) {
            var strSettings = localStorage["appSettings"];
            if (strSettings) {
                var settings = JSON.parse(strSettings);
                anyWin.themeName = settings.themeName;
            }
        }
    }
    //---- extract hideLogo, iconPath, and appBgColor from theme ----
    var hideLogo = false;
    var appBgColor = "black";
    var strTheme = window["userResources"]["themes"][anyWin.themeName.toLowerCase()];
    hideLogo = (getSymbolValue(strTheme, "hideLogo") == "true");
    appBgColor = getSymbolValue(strTheme, "appBgColor");
    if (!iconPath) {
        //iconPath = "images/onDark";
        iconPath = getSymbolValue(strTheme, "iconPath");
    }
    //---- apply 3 loading params ----
    document.body.style.background = appBgColor;
    var btLogo = document.getElementById("btLogo");
    if (!hideLogo) {
        btLogo.setAttribute("src", iconPath + "/SandDanceLogoTransparent.png");
        //btLogo.style.display = "";      // show it now
        btLogo.style.animation = "fadeIn ease-in .35s"; //.5s";
        btLogo.style.animationFillMode = "forwards";
    }
}
function getSymbolValue(str, name) {
    //---- find an "@name" type symbol in the .less file str ----
    var value = null;
    var index = str.indexOf("@" + name + ":");
    if (index > -1) {
        value = str.substr(index + name.length + 2).trim();
        index = value.indexOf(";");
        if (index > -1) {
            value = value.substr(0, index).trim();
        }
    }
    //---- remove surrounds quotes, if any ----
    if (value && value.length && value[0] === "\"") {
        value = value.substr(1, value.length - 2);
    }
    return value;
}
function loadAppHtml(appDiv) {
    /// layout overview:
    ///     - appDiv  (holds rows)
    ///         - topPanel    
    ///         - bigBarTop
    ///         - clientPanel (holds columns)
    ///             - insightPanel
    ///             - fullChartPanel (holds columns)
    ///                 - leftPanel
    ///                 - midPanel (holds rows)
    ///                     - chart1
    ///                     - bottomPanel
    ///                 - rightPanel
    var html = "\n\n        <div id=\"hiddenControls\" style=\"display: none\">\n            <input type=\"file\" id=\"inputFileOpen\" multiple=\"multiple\" class=\"filebrowse\" />\n            <a id=\"helperAnchor\"></a>\n        </div>\n\n        <div id=\"topPanel\" class=\"flexAuto flexColumns\" style=\"border: 0px solid red; margin-bottom: 10px;\">\n\n            <!-- give logo a large z-index so that it stays on top of everything during page load -->\n            <!-- include style here, so logo is stable during page load (since theme is loaded in middle of init process) -->\n            <img id=\"btLogo\"  class=\"flexAuto logo clickIcon\" src=\"Images/onDark/SandDanceLogoTransparent.png\" onclick=\"app.toggleAboutPanel(event, 'btLogo')\"\n                 title=\"Open the About SandDance Panel\"\n                 style=\"opacity: 0; height: 45px; z-index: 5001; margin: 2px; margin-left: 10px; margin-top: 10px; width: auto; border: 1px solid transparent; padding: 4px;\" />\n\n            <div id=\"oldBrowse\" class=\"oldBrowserMsg\"\n                 title=\"SandDance requires a browser with WebGL support\"\n                 style=\"position: absolute; margin: auto; top: 120px; z-index: 9999; text-align: center; display: none\">\n                SandDance cannot run on this browser<br />\n                Please try on a browser that supports WebGL.\n            </div>\n\n            <div id=\"playAndIconBar\" class=\"flexAuto flexGrow flexColumns flexOtherAuto\" style=\"border: 0 solid green; position: relative;\">\n\n                <div id=\"playPanel\" class=\"flexAuto\" style=\"display: none; border: 0 solid red; white-space: nowrap; margin: 15px 0 15px 0; \">\n\n                    <span id=\"playExButton\" class=\"textOnly\" onclick=\"app.onPlayExClick(event)\"\n                          style=\"margin-left: 10px; min-width: 40px; position: relative; display: inline-block; \">Pause</span>\n\n                    <span id=\"prevButton\" class=\"textOnly\" onclick=\"app.onNextInsight(-1)\"\n                          style=\"margin-left: 10px; min-width: 40px; position: relative; display: none; \">Previous</span>\n\n                    <span id=\"nextButton\" class=\"textOnly\" onclick=\"app.onNextInsight(1)\"\n                          style=\"margin-left: 10px; min-width: 40px; position: relative;  display: none;\">Next</span>\n\n                    <span id=\"stopButton\" class=\"textOnly\" onclick=\"app.stopPlayback()\"\n                          style=\"margin-left: 10px; min-width: 40px; position: relative;  display: inline-block; \">Stop</span>\n\n                    <span  class=\"textOnly\"\n                          style=\"margin-left: 10px; min-width: 40px; position: relative;  display: inline-block; \">\n                        <input id=\"cbLockSelection\" type=\"checkbox\" onclick=\"app.onLockSelection(event)\" />Lock selection</span>\n\n                    <span id=\"insightProgress\" class=\"plainText\"\n                          style=\"margin-left: 10px; position: relative;  display: inline-block; margin-right: 30px;\"></span>\n                </div>\n\n                <div id=\"barHolder1\" class=\"flexGrow flexColumns\">\n                    <div id=\"iconBar\" class=\"flexGrow flexColumns flexWrap iconBar\" style=\"display: none; visibility: hidden; opacity: 0\"></div>\n                </div>\n            </div>\n        </div>      <!-- end of topPanel -->\n\n        <div id=\"barHolder2\" class=\"flexColumns flexOtherAuto\">\n            <div id=\"bigBarTop\" class=\"flexGrow flexColumns flexWrap bigBar\" style=\"display: none;\"></div>\n        </div>\n\n        <div id=\"clientPanel\" class=\"flexGrow flexColumns\" style=\"\">\n\n            <div id=\"insightPanel\" class=\"flexAuto flexRows insightPanel\" style=\"display: none; margin: 20px 0 20px 10px;\">\n\n                <div id=\"insightTitleBar\" class=\"flexAuto flexColumns flexSpace insightTitleBar\" style=\"\">\n\n                    <span id=\"barTitle\" class=\"flexAuto plainText\" style=\"margin-top: -3px;\">Insights</span>\n\n                    <div id=\"menuAndCloseHolder\" class=\"flexAuto flexColumns\" style=\"\">\n                        <img id=\"insightMenuButton\" class=\"flexAuto clickIcon insightBg\" style=\"height: 20px; width: 20px; margin-top: -2px\" onclick=\"app.showInsightMenu(event)\" src=\"\" />\n                        <img id=\"insightCloseButton\" class=\"flexAuto clickIcon insightBg\" style=\"margin-left: 4px; width: 12px; height: 12px;\" onclick=\"app.toggleInsightPanel(event)\" src=\"\" />\n                    </div>\n\n                </div>       <!-- end of insight title bar -->\n\n                <div id=\"insightBar\" class=\"flexAuto flexColumns flexSpace insightBg\" style=\"margin: 4px 6px 10px 4px;\"></div>\n\n                <div id=\"insightList\" class=\"flexGrow flexRows insightList customScrollbar\" style=\"justify-content: flex-start; overflow-y: auto; overflow-x: hidden;\"></div>\n            </div>      <!-- end of insightPanel -->\n\n            <div id=\"fullChartPanel\" class=\"flexGrow flexColumns\">\n\n                <div id=\"leftPanel\" class=\"flexAuto flexRows flexCenter\" \n                    style=\"left: 0; display: none;  width: 80px; position: relative; border: 0;\">\n\n                    <!-- Y mapping/facets -->\n                    <div id=\"yStuff\" class=\"flexRows\" style=\"display: block; margin-left: 20px; border: 0; \">\n\n                        <!-- NOTE: position of yButton and yBins are manually adjusted in app.manualLayoutForYStuff() -->\n                        <div id=\"yButtonOuter\" style=\"display: none; border: 0 solid red; \"\n                             onclick=\"app.toggleYPanel(event, true)\"></div>\n\n                        <!-- NOTE: position of yButton and yBins are manually adjusted in app.manualLayoutForYStuff() -->\n                        <div id=\"yBins\" style=\"border: 1px solid none; display: none\"></div>\n                    </div>\n\n                    <!-- Z mapping/facets -->\n                    <div id=\"zStuff\" class=\"flexRows\" style=\"z-index: 999; border: 0px solid red; position: absolute;\n                    bottom: 20px; left: 20px\">\n                        <div id=\"zButtonOuter\" onclick=\"app.toggleZPanel(event, true)\" style=\"display: none\"></div>\n                        <div id=\"zBins\" style=\"display: none\"></div>\n                    </div>\n                </div>          <!-- end of leftPanel -->\n\n            <div id=\"midPanel\" class=\"flexAuto flexGrow flexRows\" style=\"\">\n\n                <div id=\"chart1\" class=\"flexGrow flexRows\" style=\"display: none\"></div>\n\n                <div id=\"bottomPanel\" class=\"flexAuto flexColumns\" \n                    style=\"justify-content: center; display: none; margin: 20px 20px 20px 70px; border: 0px solid red\">\n\n                    <!-- X mapping/facets -->\n                    <div id=\"xStuff\" class=\"flexColumns flexOtherAutoCenter\" style=\"max-height: 40px; border: 0;\">\n                            <div id=\"xButtonOuter\" class=\"flexAuto\" style=\"display: none;\" onclick=\"app.toggleXPanel(event, true)\"></div>\n                            <div id=\"xBins\" class=\"flexAuto\" style=\"display: none; margin-left: 14px;\"></div>\n                        </tr>\n                    </div>\n                </div>      <!-- end of bottom panel -->\n            </div>      <!-- end of midPanel -->\n\n            <div id=\"rightPanel\" class=\"flexAuto\" style=\"top: 2px; width: 160px;\n                 overflow-y: auto; overflow-x:hidden; z-index: 1; display: none\">\n\n                <!-- COLOR button / legend -->\n                <table style=\"margin-top: 1px;\" class=\"buttonLegendCombo\">\n\n                    <tr style=\"padding-bottom: 10px; display: none\">\n                        <td id=\"colorButton\" onclick=\"app.onColorPanelClick(event, true)\"></td>\n                        <td id=\"opacityAdj\" style=\"position: relative; top: 0\"></td>\n                    </tr>\n                    <tr>\n                        <td colspan=\"2\">\n                            <div id=\"colorLegend\" class=\"legend\" style=\"display: none; \"></div>\n                        </td>\n                    </tr>\n                </table>\n\n                <!-- SIZE button / legend -->\n                <table style=\"position: relative;\" class=\"buttonLegendCombo\">\n                    <tr style=\"padding-bottom: 10px;  display: none\">\n                        <td id=\"sizeButton\" onclick=\"app.onSizeClick(event, true)\" style=\"\"></td>\n                        <td id=\"sizeFactorAdj\" style=\"position: relative; top: 0px\"></td>\n                    </tr>\n                    <tr>\n                        <td colspan=\"2\">\n                            <div id=\"sizeLegend\" class=\"legend\" style=\"display: none\"></div>\n                        </td>\n                    </tr>\n                </table>\n\n                <!-- IMAGE button / legend -->\n                <table style=\"position: relative;\" class=\"buttonLegendCombo\">\n\n                    <tr id=\"imageMapper\" style=\"padding-bottom: 10px; display: none\">\n                        <td id=\"imageButton\" onclick=\"app.onImageClick(event, true)\" style=\"\"></td>\n                        <td id=\"imageAdj\" style=\"display: none\"></td>\n                    </tr>\n                    <tr>\n                        <td colspan=\"2\">\n                            <div id=\"shapeLegend\" class=\"legend\" style=\"display: none\"></div>\n                        </td>\n                    </tr>\n                </table>\n\n                <!-- FACET button / legend -->\n                <table style=\"position: relative;\" class=\"buttonLegendCombo\">\n                    <tr style=\"padding-bottom: 10px;  display: none\">\n                        <td id=\"facetButton\" onclick=\"app.onFacetClick(event, true)\" style=\"\"></td>\n                        <td id=\"facetBins\" style=\"display: none\"></td>\n                    </tr>\n                    <tr>\n                        <td colspan=\"2\">\n                            <div id=\"facetLegend\" class=\"legend\" style=\"display: none\"></div>\n                        </td>\n                    </tr>\n                </table>\n            </div>  <!-- end of right panel -->\n        </div>      <!-- end of fullChart panel -->\n    </div>      <!-- end of client panel -->\n\n    <!-- floating panels -->\n\n    <div id=\"infoMsgBox\" class=\"infoMsgBox\" style=\"position: absolute; left: 20px; top: 150px; display: none;\">\n\n        <img id=\"infoMsgCloseButton\" class=\"clickIcon insightBg\" style=\"position: absolute; right: 4px; top: 4px; width: 12px; height: 12px\"\n                onclick=\"app.hideInfoMsg()\" src=\"images/ondark/panel_close.svg\" />\n\n        <!--\n        <img id=\"insightCloseButton\" class=\"clickIcon insightBg\" style=\"float: right; margin-right: 4px;\n                    position: relative; top: 5px; text-align: right; width: 12px; height: 12px; padding: 4px; display: block;\"\n                onclick=\"app.toggleInsightPanel(event)\" src=\"\" />\n            -->\n\n        <div id=\"infoMsgTitle\" class=\"infoMsgTitle\" style=\"margin-top: 1px; margin-right: 25px; overflow: hidden; \"></div>\n        <div id=\"infoMsgText\" class=\"infoMsgText\" style=\"overflow: hidden;\"></div>\n    </div>\n\n    <div id=\"dataTipsRoot\"></div>\n\n    <div id=\"toolTipDiv\" class=\"toolTipText\" style=\"position: absolute; z-index: 2005; display: none;\"></div>\n\n    <!-- SEARCH panel \n    <table id=\"searchPanel\" class=\"noSpaceTable searchPanel\" data-disabled=\"false\" style=\"width: 180px;\n    position: absolute; white-space: nowrap; top: 80px; right: 20px; display: none; border: 0 solid red;\"></table>\n    -->\n";
    appDiv.innerHTML = html; // add a whole bunch of child HTML 
}
function loadAppStyle() {
    /// flexBox cheat sheet:
    ///     center content horizontally:  justify-content: center (use "margin-xxx: auto" to override on a child - e.g., margin-left)
    ///     center content vertically:    align-items: center     (use "align-self" to override on a child)
    //---- our standard style sheet, designed to work across different themes ----
    /// design goals:
    ///     - try not to use opacity (use corrected color instead)
    ///     - try not to include font-family and font-size here (put them into theme and appSettingsMgr)
    var style = "\n.infoMsgBox { padding: 8px; padding-right: 30px; z-index: 9999; }\n#infoMsgCloseButton { }\n#infoMsgCloseButton:hover { background: #777;  }\n#infoMsgCloseButton:active { background: #aaa;  }\n\n/* prevent double tap on touch screen from zooming */\nhtml { -ms-content-zooming: none; touch-action: none; }\n\n@keyframes fadeIn { from { opacity:0; } to { opacity:1; } }\n@keyframes fadeOut { from { opacity:1; } to { opacity:0; } }\n\n/*--- FlexBox classes ----*/\n.flexColumns { display: flex; flex-direction: row; border: 0px solid blue; flex-wrap: nowrap; justify-content: flex-start; }\n.flexRows    { display: flex; flex-direction: column; border: 0px solid blue; flex-wrap: nowrap; justify-content: flex-start; min-height: .01px;}\n.flexWrap    { flex-wrap: wrap; }\n.flexPack    { justify-content: flex-start }\n.flexCenter  { justify-content: center }\n.flexSpace    { justify-content: space-between}\n\n.flexAuto     {  }\n.flexGrow     { flex-grow: 1; }\n\n.flexOtherAuto   {align-items: flex-start;}\n.flexOtherAutoCenter   {align-items: center;}\n\n//---- CSS begins here ----\n.appBody {-ms-content-zooming: none; overflow: hidden;}\n\n/*---- add this to elements that should not be UI-selectable by browser selection mechanism ----*/\n.unselectable { -moz-user-select: -moz-none; -webkit-user-select: none; -ms-user-select: none; user-select: none; }\nspan, td, div, img { -moz-user-select: -moz-none; -webkit-user-select: none; -ms-user-select: none; user-select: none; }\n\n/* hide selection of HTML elements (since we cannot always prevent it). */\n::selection {  background: transparent;  color: inherit; }\n::-moz-selection {  background: transparent; color: inherit; }\n\n/*--- hide all focus rectangles ----*/\n*:focus { outline: 0; } \ntd { outline: 0; } \n\n/*---- for debugging table layouts ----*/\ntd {border: 0px solid red; }\ntable { border: 0px solid blue; }\n\n/*---- add this to elements whose text should be clipped ----*/\n.clipText { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: pointer;  }\n\n#chartUxDiv { outline: 0; } \n\n/*---- alternate background (for bigBar, insights panel, docked panels) ----*/\n.altBg {background: transparent; border-color: #555;}\n.altBg:hover { background: #555; }\n.altBg:active { background: #bbb;}\n\n/*---- SELECTION RUBBER BAND ----*/\n.rubberBand { border: 3px dashed yellow; }\n.zoomRubberBand {border: 3px double white;}\n\n/*---- CHART TITLE ----*/\n.titlePanel {color: #aaa; font-weight: 500; }\n.chartTitleText { margin: 0 0 -4px -4px; padding: 0 4px 0 4px; cursor: pointer; align-self: flex-start}\n.chartTitleText[data-selected=true] { background: rgb(56, 56, 56);}\n.chartTitleItems {padding: 5px 5px 5px 0; cursor: default;}\n.chartTitleStats {padding: 5px 5px 5px 15px; cursor: pointer;}\n\n/*--- ICON (ICON BUTTON) ----*/\n/*---- use \"display: block\" on   to remote extra spacing (at least when in a TD) ----*/\n.clickIcon { border: 1px solid transparent; padding: 0; background: none; }\n.clickIcon:hover { background: #555; cursor: pointer; }\n.clickIcon:active { background: #333;  }\n.clickIcon[data-selected=true] { background: white;  }     /* icon will be inverted */\n.clickIcon[data-disabled=true] { opacity: .5; cursor: default; border: 1px solid transparent; background: transparent; }\n\n.openSlider { padding: 2px;}\n.openSlider:hover {  background: #333;}\n.openSlider:active { }\n\n/*---- NEW COMBO BUTTONS (for iconbar buttons) ----*/\n.textOnly {display: inline-block; min-width: 44px; text-align: center; border: 1px solid #555; \n           vertical-align: middle; cursor: pointer; padding: 2px 6px 2px 6px; }\n.textOnly:hover{ background: #333;}\n.textOnlyText {white-space: nowrap; }\n\n.chevron { opacity: .5;  }\n.chevron:hover {opacity: 1}\n\n/*--- TEXT BUTTONS (just text without icons) ----*/\n.textButton { cursor: pointer; border: 1px solid none; background: none; padding: 4px 8px 4px 8px;}\n.textButton:hover { background: #333;  }\n.textButton:active { opacity: .8;  }\n.textButton[data-selected=true] { border: 1px solid white;}\n.textButton[data-disabled=true] { opacity: .5; cursor: default; background: transparent; }\n\n.dataTipContainer{  }\n.dataTipDragger {border: 0; background: none; width: 40px;  padding: 0; cursor: grab}\n.dataTipDragger:hover { background: none;  }\n.dataTipDragger:active { background: none; }\n.dataTipText {max-width: 400px; white-space: pre-wrap; border: 1px solid gray; background: white; color: blue; \n              padding-left: 2px; padding-right: 2px; cursor: pointer; min-height: 10px; }\n\n.dataTipTitle { font-weight: bold; }\n.dataTipTable { }\n.dataTipName { font-weight: bold; margin-right: 8px; }\n.dataTipValue { }\n\n.toolTipText {max-width: 400px; white-space: pre-wrap; border: 1px solid gray; background: white; color: blue; \n              padding-left: 2px; padding-right: 2px; cursor: pointer; max-height: 600px; overflow-y: auto; line-height: 14px;}\n.toolTipTable { }\n.toolTipName { font-weight: bold; margin-right: 16px; }\n.toolTipValue { }\n\n.logo { }\n.logo:hover {background: none; border: 1px solid #aaa;}\n.logo:active {background: none; border: 1px solid #333;}\n.logo[data-selected=true] { background: none;  }     /* icon will be inverted */\n\n/*---- BIG BAR ----*/\n.bigBar { background: rgb(28, 26, 24); width: 100%; border-top: 1px solid gray; border-bottom: 1px solid gray; }\n\n/*---- remove unwanted spaces from tables ----*/\n.noSpaceTable {border-collapse: collapse; border-spacing: 0;  }\n\n/*--- LEGEND ----*/\n.legend { padding: 6px; display: inline-block; border: 0px solid #555; \n          width: 210px; margin-left: 0px; margin-top: 0px; margin-bottom: -10px;\n}\n\n.legendHolder { margin-bottom: 6px; border-collapse: collapse; border-spacing: 0; border: 0;  }\n.legendTitle {  cursor: pointer; color: #aaa;  border: 0px; background: none; display: inline-block;}\n.legendTitle[data-selected=true] {background:  rgb(56, 56, 56); border: 0 !important;}\n\n.legendTick {width: 8px; border: 1px solid transparent; border-top: 1px solid #777;  }\n\n.legendLabel {color: #aaa; cursor: pointer; white-space: nowrap; overflow: hidden; margin-top: 0px; \n              max-width: 155px;}\n.legendLabel:hover { opacity: .6; }\n.legendLabel:active { opacity: .3; }\n\n.legendTicks { }\n.legendLabels {  }\n\n/*---- PANES ----*/\n.paneDiv { border: 1px solid #555; padding: 8px; }\n.paneTopRow {}\n\n\n/*---- PANELS ----*/\n\n/*---- removed \"display: inline-block\" on PANEL and UNDOCKEDPANEL - was preventing details panel from resizing correctly */\n.panel {  background: rgb(56, 56, 56); z-index: 1005; border: 1px solid gray; }\n.undockedPanel { position: absolute; border: 1px solid #777; background:  black; z-index: 1005;}\n\n.panelTitle { height: 25px; border-bottom: 1px solid white; padding: 6px; cursor: pointer; opacity: .86; }\n.panelContent {padding: 6px; padding-top: 0; padding-bottom: 10px;  padding-right: 6px; }\n.panelSeparator { border-bottom: 1px solid white; opacity: .85;  }\n\n/*---- minHeight=20px causes problems for powerBI theme, so it has been removed ----*/\n.panelButton { background-color: none; border: 1px solid #777;  cursor: pointer; padding: 0px 8px 2px 8px; min-width: 20px; \n  text-align: center; display: inline-block; outline: 0; }\n.panelButton:hover { background: #555555; }\n.panelButton:active { color: #aaaaaa; background: #777777;}\n.panelButton[data-disabled=true] { color: #999999; background: none; cursor: default; font-style: italic;\n       border: 1px solid #777; cursor: default; }\n.panelButton[data-selected=true] { border: 1px solid #ffffff; }\n.panelButtonText:hover { background: none; }\n.panelButtonText:active { background: none; }\n\n.checkboxAssembly { cursor: pointer;}\n.checkboxAssembly[data-disabled=true] {opacity: .5;}\n.panelCheckbox { width: 14px;  height: 14px; opacity: .86; }\n.panelCheckboxContainer { background: black; opacity: .1; }\n\n.radioAssembly {cursor: pointer }\n.panelRadio { width: 14px; height: 14px; opacity: .86; }\n\n.panelDisplay { background: none; opacity: .85; padding: 4px; margin-top: -5px; }\n.panelPrompt { opacity: .86; white-space: nowrap; cursor: default;}\n.panelLongPrompt { opacity: .86; padding-right: 10px;}\n\n.panelRowEmpty { display: inline-block; height: 18px; }\n\n.panelLink { text-decoration: none; color: #0cf; cursor: pointer}\n.panelLink:hover { text-decoration: underline; }\n.panelLink:link { color: #0cf; }\n.panelLink:visited { color: #0cf; }\n.panelLink:active { color: #0cf; }\n\n.panePrompt { font-style: italic; text-align: center;}\n\n/*---- FOOTER ----*/\n.footerLink { margin: 8px;}\n\n/*---- TEXTBOX PLACEHOLDER ----*/\ninput::-webkit-input-placeholder  { font-style: italic; color: #777; }\ninput:-moz-placeholder  { font-style: italic; color: #777; }\ninput:-ms-input-placeholder  { font-style: italic; color: #777; }\n\n/*--- for textbox on black desktop ----*/\n.deskText { padding: 0; background: none;  border: 1px solid #333; }\n\n/*--- for textbox on gray panel ----*/\n.panelText {  background: none;  border: 1px solid #777; padding: 0 4px 0 4px;  }\n.panelTextArea::selection { }\n\n.panelTextArea { color: white; background: none; opacity: .85; padding: 4px; }\n.panelTextArea::selection { }\n\n/*---- TEXTAREA PLACEHOLDER ----*/\n.panelTextArea::-moz-placeholder  { font-style: italic; color: #777; }\n.panelTextArea::-webkit-input-placeholder  { font-style: italic; color: #777; }\n.panelTextArea:-ms-input-placeholder  { font-style: italic; color: #777; }\n\n/*--- for text without any border or interaction ----*/\n.plainText {  background: none;  cursor: default; padding: 4px 4px 2px 4px;  }\n\n.bgText {opacity: .5; }\n\n.footerLink {font-size: 12px; margin: 8px; text-decoration: none;}\n.footerLink:hover {text-decoration: underline}\n\n/* note: some padding on listbox is required to correctly draw a border around the selected row. */\n.listBox {border: 1px solid #555; padding: 6px; }\n.listBoxItems { padding-right: 8px;}\n\n/*---- COLOR PALETTE ----*/\n.colorPaletteEntry { border: 1px solid transparent;  cursor: pointer }\n.colorPaletteEntry:hover {  border: 1px solid white;   }\n.colorPaletteEntry:active {  border: 1px solid gray;   }\n\n/*---- COLOR PALETTE LIST ----*/\n.listColorPaletteItem { white-space: nowrap; cursor: pointer;}\n.listColorPaletteEntry {  border-right: 0px solid yellow; display: inline-block; }\n\n/*---- font size is set here because code has to set it = 0 on parent element to layout correctly ----*/\n.listColorPaletteName { background: none; opacity: .85; margin-left: 16px; font-size: 16px;\n    padding: 0px; max-width: 150px; margin-right: 35px; display: inline-block;}\n.listColorPaletteName:hover {opacity: 1; }\n.listColorPaletteNameSelected { background: white; color: black; }\n\n.listColorPalette { border: 1px solid black; }\n.listColorPaletteGradient { border: 0px solid black; display: inline-block;}\n.customList { margin: 10px; }\n\n/*---- TOUR PANEL ----*/\n.tourPanel {background: rgb(91, 155, 213); border-radius: 0px; }\n.tourTitle { color: white; padding: 6px 10px 10px 10px;}\n.tourClientArea { background: rgb(222, 235, 247);}\n.tourContent { color: black; padding: 10px 20px 10px 20px;}\n.tourButton {background: rgb(91, 155, 213); color: white; padding: 4px 6px 4px 6px; min-width: 50px; \n             cursor: pointer; text-align: center; border-radius: 4px;}\n.tourButton:hover {  text-decoration: underline;}\n.tourButton:active { color: #aaa;}\n.tourButton[data-disabled=true]   { opacity: .5; cursor: default; text-decoration: none}\n\n.activeTourElement {border: 4px solid green !important;}\n\n/*----  SHAPE LEGEND ----*/\n.imagePaletteEntry { cursor: pointer; border: 1px solid #555;}\n.imagePaletteEntry:hover { background: #333; border: 1px solid white;}\n\n/*----  SIZE LEGEND ----*/\n.sizePaletteEntry { cursor: pointer; border: 1px solid #555;}\n.sizePaletteEntry:hover { background: #333; border: 1px solid white;}\n\n/*---- CHART PICKER ----*/\n.chartPicker{ padding: 6px; }\n.chartPickerEntry{ padding: 6px; cursor: pointer; border: 2px solid none;   }\n.chartPickerEntry:hover{ background: rgb(87, 87, 87);  }\n.chartPickerEntry:active{ opacity: .7; }\n.chartPickerEntry[data-selected=true] { border: 2px solid #555; background: rgb(69, 69, 69); }\n.chartPickerImage {  }\n.chartPickerTitle { padding: 0;  text-align: center; padding-bottom: 4px; position: relative; top: 0; }\n\n/*---- this doesn't work for IE11 ----*/\n.inverted { filter: invert(100%); }\n\n.invertImg {\n    filter: invert(100%);    /*---- Edge supports this ----*/\n    -webkit-filter:invert(100%);\n     filter:progid:DXImageTransform.Microsoft.BasicImage(invert='1');\n}\n/*---- SEARCH / SLICING PANEL -----*/\n.doubleSliderBaseBar {background: gray; height: 20px; width: 100%; cursor: default}\n.doubleSliderRangeBar {background: #0cf; border: 1px solid black; height: 18px; width: 50%; cursor: pointer;}\n.doubleSliderHandle {background: #0cf; height: 20px; border: 1px solid white; cursor: ew-resize;}\n\n.searchNodeShell { border: 1px solid none; margin: 6px; min-width: 300px;  }\n.searchNodeTitleRow {background: #333; }\n.searchNodeTitle {color: #0cf;   }\n.searchNodeContent { }\n.searchColKey {cursor: pointer;}\n.searchColKey[data-selected='true'] {color: #0cf; }\n\n.searchColCounts { opacity: .5; cursor: pointer;}\n.searchColCounts[data-selected='true'] {color: #0cf; }\n\n.searchHistoBar {background: gray; cursor: pointer;}\n.searchHistoBar[data-selected='true'] {background: #0cf; }\n.searchCheckboxRow {cursor: pointer; }\n\n/*---- PANEL TAB BUTTONS ----*/\n.tabButtonContainer { margin-top: 4px; border-bottom: 1px solid #c8c8c8; }\n.tabButton { cursor: pointer;  min-width: 15px;   display: inline-block; padding: 2px; \n             border-bottom: 2px solid transparent; margin-left: 8px; padding-bottom: -2px;\n             padding-top: 1px;  text-align: center;    }\n.tabButton:hover{ }\n.tabButtonOpen { border-bottom-color: black; font-weight: 600; }\n.undockedPanel .tabButtonOpen { border-bottom-color: black; }\n\n/*---- SLIDER ----*/\n.sliderAssembly { background: white; border: 1px solid #333;}\n.sliderAssemblyInPanel {border: none; background: none !important;}\n\n/* new slider to replace browser built-in */\n.circleSliderTrack {background: #212121;}\n.tinyButton { width: 12px; height: 12px; cursor: pointer; }\n\n/*---- POPUP MENU ----*/\n.popupMenu { background: black; border: 1px solid #555; padding-top: 3px; padding-bottom: 3px; z-index: 2001; \n             border-top: 1px solid #aaa; border-bottom: 1px solid #aaa; }\n\n/*---- this is for popup menus on the DOCKED (vs. APP) background color ----*/\n.onDocked {background: rgb(69,69,69); border: 1px solid white;}\n\n/*---- POPUP MENU ITEM ----*/\n/* note: use \"none\" vs. \"transparent\" to get border around selected row to draw correctly. */\n.popupMenuItemHolder {  border: 1px solid none; background: transparent;  cursor: pointer;  min-height: 25px; }\n.popupMenuItemHolder:hover { background: #555;  }\n.popupMenuItemHolder:active { background: #333;  }\n.popupMenuItemHolder[data-selected=true] { background: #555; border: 1px solid #aaa;  } \n.popupMenuItemHolder[data-disabled=true] { opacity: .5; cursor: default; border: 1px solid transparent; background: transparent; }\n\n.popupMenuItem { padding: 6px; border: 0; background: none;  vertical-align: middle;}\n.popupMenuIcon { margin: 0; vertical-align: middle; border: 0; width: 22px;  height: 22px; padding-bottom: 3px;}\n.popupMenuIconColPicker { margin: 0; vertical-align: middle; border: 0; width: 14px;  height: 14px; opacity: .7 ; padding-bottom: 3px;}\n\n.popupMenuPretext { border: 0; background: none; display: inline-block; color: #777; padding-right: 6px; vertical-align: middle; \n                    position: relative; top: -1px; left: 2px; margin-right: 10px;}\n\n.popupMenuHR { height: 1px; margin: 3px 0 3px 0; background: gray; }\n.panelHR {border: 0; background-color: #777; height: 1px;}\n\n/*--- themed SCROLL BAR ---*/\n.customScrollbar { scrollbar-face-color: #444; scrollbar-arrow-color: #444; scrollbar-track-color: #222;\n                     overflow-y: auto; overflow-x: hidden; white-space: nowrap;  }\n\n/*---- INSIGHT PANEL ----*/\n.insightPanel { background: rgb(28, 26, 24); border: 1px solid gray; }\n.insightTitleBar { border: 0px solid #555; padding: 6px; }\n.insightCreateBar { border-bottom: 2px solid black;   padding: 10px 10px 10px 20px; cursor: pointer; }\n.insightCreateBar:hover { color: #aaa; }\n.insightCreateBar:active { color: #333; }\n.insightList { overflow-y: auto; overflow-x: hidden; white-space: nowrap;  }\n.insightEntry {  border: 1px solid #555; margin: 20px 30px 10px 10px; }\n.insightEntry:hover {  border: 1px solid #999 }\n.currentEntry { border: 1px solid #ddd; }\n.insightImage { cursor: pointer; }\n.insightText {  text-align: left; position: relative; cursor: pointer;  margin: 4px 8px 4px 8px;  cursor: pointer; }\n\n/*---- ROTATED Y LABEL ----*/\n#yText { position: absolute; top: 50%; left: 50%;  transform:  translateX(-50%) translateY(-50%) rotate(-90deg);  opacity: 1; }\n\n/*---- RESIZER ----*/\n.panelResizer { }\n.panelResizer:hover { cursor: se-resize; }\n.panelResizer:active { cursor: default; }\n\n/*---- DETAILS ----*/\n.recordView {}\n.recordViewRow[data-selected=true] {  }\n.rvColName { color: gray; text-align: right; padding-left: 6px; padding-right: 4px; cursor: pointer; }\n.rvColName:hover { opacity: .7; }\n.rvValue { text-align: left; padding-left: 4px; padding-right: 6px;  cursor: pointer; padding-right: 10px; }\n.rvValue:hover { opacity: .7; }\n.rvControlBar { margin-bottom: -20px; padding: 0px; padding-bottom: 4px;  }\n.rvRecordText {      color: GrayText; }\n.rvImgButton { cursor: pointer; opacity: .7; }\n.rvImgButton:hover { opacity: .3; }\n.bingImg { cursor: pointer; padding-right: 0px; margin-left: -5px; }\n\n/*--- INFO MSG BOX (currently has colors that are the opposite of the theme----*/\n.infoMsgBox { font-size: 20px; background: rgb(56, 56, 56); border: 1px solid #aaa; padding: 8px;  padding-right: 30px; z-index: 5999; }\n#infoMsgCloseButton { }\n#infoMsgCloseButton:hover { background: #777;  }\n#infoMsgCloseButton:active { background: #aaa;  }\n\n/*--- CHAT BOT ---*/\n#stChatHistory {border: 1px solid #333; max-height: 300px; overflow-y: auto; overflow-x: hidden;}\n\n/*---- COL TABLE ----*/\n.colTable {border-collapse: collapse; margin-bottom: 20px; }\n.colHdr {color: gray; padding: 2px; border: 1px solid #333; border-collapse: collapse; text-align: left; font-weight: normal;}\n.colHdr:hover {}\n.colValue {padding: 2px; border: 1px solid #333; border-collapse: collapse; text-align: left;}\n.colValue:hover {}\n\n/*---- DOCKED PANEL ----*/\n.dockedPanel { /*border: 1px solid #333; border-top: none;*/ }\n.suggestionList {}\n.suggestionItem { padding: 0 4px 0 4px; color: #aaa; }\n\n/*---- new toolbar styles */\n.iconButton { border: 1px solid #555; padding: 2px; margin: 2px 0 2px -1px; cursor: pointer;}\n.iconButton:hover { background: #555; }\n.iconButton[data-disabled=true] {background: none !important; cursor: default;}\n.iconButtonInner[data-disabled=true] { opacity: .5; }   /* keep the borders at opacity=1 but dim all else */\n.buttonIcon {padding: 2px 7px 2px 7px; }    /* keep it from being too skinny on bigBar */\n\n.textOnly:hover{ background: #ccc;}\n.buttonTextHolder {padding: 0 6px 0 6px;}\n\n.bigButton { padding: 3px 0 6px 0; border-right: 1px solid gray; cursor: pointer;}\n.bigButton:hover {background: #333;}\n.bigButton[data-selected=true] {background: rgb(56, 56, 56);}\n.buttonPrompt {width: 10ch; margin: 1px 5px 0 10px;  white-space: nowrap; ;}\n.buttonValue { margin: -2px 4px 3px 10px; }\n.noneValue {  }\n\n.iconBar {margin: 16px 20px 0px 20px; align-self: flex-start;}\n.iconBarSpacer {margin: 0 7px 0 7px; background: green; height: 50%; width: 1px;}\n.bigBar {}\n.bigBarSpacer {width: 1px; background: #333; margin: 0 8px 0 8px;}\n\n .playPanelButton {width: 45px;}\n\n.textPanelItem:hover {background: #333;}\n\n.panelProgressBar {width: 100px; border: 1px solid white; }\n.panelInnerProgressBar {background: white; height: 100%;}\n\n.colorSampleButton {width: 16px; height: 16px; cursor: pointer; border: 1px solid white;}\n.colorText {  color: white; background: none;  border: 1px solid #777; padding: -4px 2px -4px 2px;  }\n.colorText:hover {border: 1px solid white; }\n.colorPaletteCell {width: 24px; height: 24px; cursor: pointer; border: 1px solid white;}\n.colorPalettePopup {border: 1px solid white;}\n";
    var ss = vp.dom.createStyleSheet(style);
    ss.id("sandDanceStyleSheet");
}
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    appInterfaces.ts - specify the API for customizing the SandDance app;
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    (function (FontWeight) {
        FontWeight[FontWeight["lighter"] = 0] = "lighter";
        FontWeight[FontWeight["normal"] = 1] = "normal";
        FontWeight[FontWeight["bold"] = 2] = "bold";
        FontWeight[FontWeight["bolder"] = 3] = "bolder";
    })(beachParty.FontWeight || (beachParty.FontWeight = {}));
    var FontWeight = beachParty.FontWeight;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    toolbar.ts - holds big buttons and icon buttons (using flexgrid)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var toolbarClass = (function () {
        function toolbarClass(app, toolbarDiv, callbackInstances) {
            //---- app settings properties ----
            this._textSize = 0;
            this._valueSize = 0;
            this._iconSize = 0;
            this._showIcon = false;
            this._showText = false;
            this._showChevron = false;
            this._app = app;
            this._root = toolbarDiv;
            this._cbInstances = callbackInstances;
        }
        toolbarClass.prototype.startBuild = function (forceTextVisible) {
            vp.select(this._root).clear();
            var settings = this._app._appSettingsMgr;
            this._iconSize = settings.iconWidth();
            this._textSize = settings.menuTextSize();
            this._valueSize = settings.menuValueSize();
            this._showIcon = settings.isMenuIconVisible();
            this._showText = (forceTextVisible || settings.isMenuTextVisible());
            this._showChevron = settings.isMenuChevronVisible();
        };
        toolbarClass.prototype.callMethod = function (methodName, e) {
            var instances = this._cbInstances;
            for (var i = 0; i < instances.length; i++) {
                var inst = instances[i];
                var cb = inst[methodName];
                if (cb) {
                    cb.apply(inst, [e]);
                    break;
                }
            }
        };
        toolbarClass.prototype.addBigButton = function (button) {
            var _this = this;
            if (button.value === undefined) {
                button.value = "None";
            }
            var holderW = vp.select(this._root).append("div")
                .addClass("flexRows bigButton")
                .title(button.tip)
                .id(button.btName)
                .attach("click", function (e) {
                beachParty.chartUtils.callPanelOpen(e, function (e) {
                    _this.callMethod(button.cb, e);
                });
            });
            holderW[0]._title = button.tip; // preserve for later restoring title
            var promptW = holderW.append("div")
                .id(button.btName + "Prompt")
                .addClass("buttonPrompt")
                .text(button.prompt);
            var valueW = holderW.append("div")
                .id(button.btName + "Value")
                .addClass("buttonValue")
                .text(button.value);
            if (button.value == "None") {
                valueW.addClass("noneValue");
            }
            return holderW[0];
        };
        toolbarClass.prototype.addIconButton = function (button) {
            var _this = this;
            var outerW = vp.select(this._root).append("div")
                .addClass("flexAuto iconButton")
                .id(button.root + "Button");
            if (button.inToolbar) {
                outerW.addClass("iconToolButton");
            }
            if (button.cbName) {
                outerW.attach("click", function (e) {
                    beachParty.chartUtils.callPanelOpen(e, function (e) {
                        _this.callMethod(button.cbName, e);
                    });
                });
            }
            var holderW = outerW.append("div")
                .addClass("flexRows iconButtonInner")
                .id(button.root + "ButtonInner")
                .title(button.tip)
                .css("align-items", "center");
            //.css("cursor", "pointer");
            if (button.disabled) {
                this._app.disableIconButton(button.root, true);
            }
            if (this._showIcon && button.icon) {
                var imgW = holderW.append("img")
                    .addClass("themeIcon buttonIcon")
                    .css("width", this._iconSize + "px")
                    .css("height", this._iconSize + "px");
                //.attr("src", button.icon)
                beachParty.setIconName(this._app._themeMgr, imgW[0], button.icon, "toolbar", true);
            }
            if (this._showText) {
                //---- make all buttons the size of the maximum text ----
                if (button.textForWidth) {
                    var szText = vp.utils.measureText(button.textForWidth, "buttonText");
                    var minWidth = 12 + szText.width; // allow for paddings
                    outerW
                        .css((button.rotated) ? "min-height" : "min-width", minWidth + "px");
                }
                if (button.chevron && this._showChevron) {
                    var rowW = holderW.append("div")
                        .css("align-items", "center")
                        .addClass("flexColumns buttonTextHolder");
                    rowW.append("div")
                        .addClass("flexAuto buttonText")
                        .css("font-size", this._textSize + "px")
                        .id(button.root + "Text")
                        .text(button.prompt);
                    //---- chevron ----
                    var imgW = rowW.append("img")
                        .addClass("flexAuto themeIcon")
                        .id(button.root + "Chevron")
                        .css("width", "6px")
                        .css("height", "5px")
                        .css("margin", "12px 0 0 6px");
                    beachParty.setIconName(this._app._themeMgr, imgW[0], beachParty.fnChevron, "iconBarPanel", true);
                }
                else {
                    holderW.append("div")
                        .addClass("buttonText buttonTextHolder")
                        .id(button.root + "Text")
                        .css("text-align", "center")
                        .css("font-size", this._textSize + "px")
                        .text(button.prompt);
                }
            }
            return outerW[0];
        };
        toolbarClass.prototype.addBigSpacer = function () {
            var vertW = vp.select(this._root).append("div")
                .css("align-self", "stretch") // full height
                .addClass("bigBarSpacer");
        };
        toolbarClass.prototype.addIconSpacer = function () {
            var vertW = vp.select(this._root).append("div")
                .addClass("iconBarSpacer");
        };
        return toolbarClass;
    }());
    beachParty.toolbarClass = toolbarClass;
    var IconButtonData = (function () {
        function IconButtonData() {
        }
        ;
        return IconButtonData;
    }());
    beachParty.IconButtonData = IconButtonData;
    var BigButtonData = (function () {
        function BigButtonData() {
        }
        ;
        return BigButtonData;
    }());
    beachParty.BigButtonData = BigButtonData;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    dataTip.ts - control that displays text from record that is positioned over.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var dataTipClass = (function (_super) {
        __extends(dataTipClass, _super);
        /// dataTip is always assigned to a chart, but can be dragged into another chart (changing its assignment).
        function dataTipClass(app, parentElem, chart) {
            var _this = this;
            _super.call(this);
            this._dataTipOffset = null; // where mouse/pointer clicked on the datatip
            this._onMouseMoveFunc = null;
            this._onMouseUpFunc = null;
            this._isRealDrag = false; // true if datatip has been dragged more than just accidental movement during a click
            this._szIcon = null;
            this._app = app;
            this._chart = chart;
            //---- build control ----
            var rootW = vp.select(parentElem).append("div")
                .addClass("dataTipContainer")
                .css("position", "absolute")
                .css("z-index", "1999")
                .css("pointer-events", "none");
            //---- create image to drag with mouse movements ----
            var imgW = rootW.append("img")
                .addClass("clickIcon dataTipDragger")
                .attr("src", beachParty.fnDragDataTip)
                .css("width", "20px")
                .css("pointer-events", "auto")
                .attach("mousedown", function (e) { return _this.onMouseDown(e); })
                .attach("contextmenu", function (e) {
                _this.showContextMenu(e);
            });
            //---- create associated TEXT window ----
            var textW = rootW.append("div")
                .addClass("dataTipText")
                .css("position", "relative")
                .css("left", "-1px")
                .attach("mousedown", function (e) {
            });
            this._root = rootW[0];
            this._img = imgW[0];
            this._text = textW[0];
            this._onMouseMoveFunc = function (e) { return _this.onMouseMove(e); };
            this._onMouseUpFunc = function (e) { return _this.onMouseUp(e); };
            //---- save pointer this dataTip instance ----
            rootW[0].control = this;
            beachParty.matchIconsToTheme(this._app._themeMgr, rootW[0]);
            //---- save size of icon ----
            var rc = vp.select(this._img).getBounds();
            this._szIcon = { width: rc.width, height: rc.height };
        }
        dataTipClass.prototype.showContextMenu = function (e) {
            var _this = this;
            var items = [
                //new MenuItemData("Properties", "Open the properties panel for this data tip"),
                new beachParty.MenuItemData("Delete", "Delete this data tip"),
            ];
            var pm = new beachParty.popupMenuClass(this._app, null, "pmInsights", items, function (e, menu, textIndex, menuIndex) {
                var name = items[menuIndex].text;
                if (name == "Delete") {
                    var dataTipMgr = _this._app._dataTipMgr;
                    dataTipMgr.closeDataTip(_this);
                }
                //else if (name == "Properties")
                //{
                //    this._dataTipPanel = new dataTipPanelClass(this);
                //    var rc = vp.select(this._img).getBounds(false);
                //    this._dataTipPanel.show(rc.right, rc.bottom);
                //}
            }, true);
            var pt = vp.events.mousePosition(e);
            pm.showAt(pt.x, pt.y);
        };
        dataTipClass.prototype.onMouseDown = function (e) {
            if (e.which == 1) {
                //---- LEFT CLICK ----
                var offset = vp.events.mousePosition(e, this._img);
                //---- adjust for some offset around icon ----
                //offset.x -= 4;
                offset.y -= 0;
                this.startDrag(e, offset);
                vp.events.cancelEventBubble(e);
                vp.events.cancelEventDefault(e);
            }
            //else if (e.which == 3)
            //{
            //    //---- RIGHT CLICK ----
            //    this.close();           
            //}
        };
        dataTipClass.prototype.getIconBounds = function () {
            return this._rcImgInPlot;
        };
        dataTipClass.prototype.getDataTipData = function () {
            var dtd = new beachParty.DataTipData();
            dtd.text = vp.select(this._text).text();
            dtd.primaryKey = this._primaryKey;
            var rc = vp.select(this._root).getBounds(true);
            dtd.offset = { left: rc.left, top: rc.top };
            dtd.title = this._title;
            dtd.colNames = this._columnNames;
            dtd.includeNames = this._includeNames;
            return dtd;
        };
        dataTipClass.prototype.setDataTipData = function (dtd) {
            //---- OFFSET and TEXT will be updated again if recordIndex is set ----
            //---- but we do it now for the case when the data is not bound to a record ----
            //---- and in case the record binding fails ----
            vp.select(this._root)
                .css("left", dtd.offset.left + "px")
                .css("top", dtd.offset.top + "px");
            vp.select(this._text)
                .text(dtd.text);
            this._primaryKey = dtd.primaryKey;
            this._title = dtd.title;
            this._columnNames = dtd.colNames;
            this._includeNames = dtd.includeNames;
            if (dtd.primaryKey !== null && dtd.primaryKey !== undefined) {
                this.updateTextAndOffset();
            }
        };
        dataTipClass.prototype.setParams = function (title, colNames, includeNames) {
            this._title = title;
            this._columnNames = colNames;
            this._includeNames = includeNames;
            this.updateTextAndOffset();
        };
        dataTipClass.prototype.show = function (value) {
            vp.select(this._root)
                .css("display", (value) ? "" : "none");
            if (!value) {
                vp.utils.debug("tooltip hidden");
            }
        };
        dataTipClass.prototype.getDefaultColumns = function () {
            var colNames = this._chart.getMappedColumns();
            if (colNames == null || colNames.length == 0) {
                colNames = this._app.colNames(false);
                if (colNames.length > 10) {
                    //---- first 10 columns ----
                    colNames = colNames.slice(0, 10);
                }
            }
            return colNames;
        };
        /**
         * The dataTip normally shows the information for the shape that it is closest to.  When the data tip is locked, it is bound to
         * a particular shape and will follow the shape as the view changes.  The data tip becomes locked to a shape when it finds a shape that is within its radius.
         * @param unlock - when true, unlock the primary key binding for this shape.
         */
        dataTipClass.prototype.updateTextAndOffset = function (unlock) {
            var _this = this;
            if (unlock) {
                this._primaryKey = null;
            }
            var primaryKey = this._primaryKey;
            var colNames = this._columnNames;
            if (!colNames || colNames.length == 0) {
                colNames = this.getDefaultColumns();
            }
            if (primaryKey) {
                vp.utils.debug("updateTextAndOffset: bound to primaryKey=" + primaryKey);
                //---- get information about bound shape's data record: column values and rcShape ----
                this._chart.getShapeBoundsAndRecord(primaryKey, colNames, function (msgBlock) {
                    //---- move dataTip to center of shape ----
                    var rcShape = msgBlock.rcShape; // relative to PLOT
                    if (rcShape) {
                        //---- calculate middle of shape ----
                        var x = (rcShape.left + rcShape.right) / 2;
                        var y = (rcShape.top + rcShape.bottom) / 2;
                        //---- offset by half dataTip icon size ----
                        var szIcon = _this._szIcon;
                        x -= szIcon.width / 2;
                        y -= szIcon.height / 2;
                        //---- offset by rcPlot (make it relative to screen) ----
                        var rcPlot = msgBlock.rcPlot;
                        x += rcPlot.left;
                        y += rcPlot.top;
                        //---- move the dataTip ----
                        vp.select(_this._root)
                            .css("left", x + "px")
                            .css("top", y + "px")
                            .css("display", "");
                        _this.buildTextFromColumnValues(colNames, msgBlock.colValues);
                    }
                    else {
                        //---- shape is not currently available (usually this happens when shape is filtered out of view) ----
                        //---- hide it until we have a place to put it ----
                        vp.select(_this._root)
                            .css("display", "none");
                        vp.utils.debug("updateTextAndOffset: primaryKey shape not found, so hiding datatip");
                    }
                });
            }
            else {
                var rc = vp.dom.getBounds(this._img);
                var result = this._chart.getChartUx().screenToPlotCoordinates(rc.left, rc.top);
                var rcImg = vp.geom.createRect(result.x, result.y, rc.width, rc.height);
                this._rcImgInPlot = rcImg;
                var xMid = (rcImg.left + rcImg.right) / 2;
                var yMid = (rcImg.top + rcImg.bottom) / 2;
                vp.utils.debug("updateTextAndOffset: IMG rc=" + rcImg.left + ", " + rcImg.top + ", xMid=" + xMid + ", yMid=" + yMid);
                this._chart.getMostCentralRecord(rcImg, colNames, function (msgBlock) {
                    if (msgBlock.primaryKey) {
                        vp.utils.debug("updateTextAndOffset: found nearby shape, so binding to primaryKey=" + msgBlock.primaryKey);
                    }
                    else {
                        vp.utils.debug("updateTextAndOffset: no nearby shape found");
                    }
                    //---- if primaryKey is set, we lock this dataTip to the shape's primary key ----
                    _this._primaryKey = msgBlock.primaryKey;
                    _this.buildTextFromColumnValues(colNames, msgBlock.colValues);
                });
            }
        };
        dataTipClass.prototype.buildTextFromColumnValues = function (colNames, colValues) {
            var html = "";
            var colCount = (colValues) ? colValues.length : 0;
            if (this._title && this._title != "") {
                var cls = (colCount > 0) ? "dataTipTitle" : "datatipText";
                html += "<div class='" + cls + "'>" + this._title + "</div>";
            }
            html += "<table class='dataTipTable'>";
            if (colCount > 0) {
                var firstSystemName = true;
                for (var i = 0; i < colCount; i++) {
                    var colName = colNames[i];
                    var colType = this._app.getColType(colName);
                    var value = colValues[i];
                    var strValue = vp.formatters.formatByType(value, colType);
                    if (i > 0) {
                        if (colName.startsWith("_") && firstSystemName) {
                            //---- skip a row ----
                            firstSystemName = false;
                            html += "<tr><td>&nbsp;</td></tr>";
                        }
                    }
                    //html += "<tr style='white-space: nowrap'>";
                    html += "<tr >";
                    if (this._includeNames) {
                        html += "<td class='dataTipName'>" + colName + ":</td>";
                    }
                    html += "<td class='dataTipValue'>" + value + "</td></tr>";
                }
                html += "</table>";
            }
            //---- set text / HTML ----
            var textW = vp.select(this._text);
            textW.html(html);
            //---- position bottom of text 40 pixels above img ----
            var rc = textW.getBounds(false);
            textW
                .css("top", -(rc.height + 40) + "px");
        };
        dataTipClass.prototype.startDrag = function (e, offset) {
            vp.utils.debug("dataTip: startDrag()");
            this._ptMouseDown = vp.events.mousePosition(e);
            this._isRealDrag = false;
            this._dataTipOffset = offset;
            //---- capture mouse ----
            vp.events.setCaptureWindow(this._onMouseMoveFunc, this._onMouseUpFunc);
            //---- draw first image ----
            this.onMouseMove(e);
            vp.events.cancelEventDefault(e);
        };
        dataTipClass.prototype.onMouseMove = function (e) {
            vp.utils.debug("dataTip: onMouseMove()");
            var pt = vp.events.mousePosition(e);
            pt.x -= this._dataTipOffset.x;
            pt.y -= this._dataTipOffset.y;
            if (!this._isRealDrag) {
                var xdiff = Math.abs(pt.x - this._ptMouseDown.x);
                var ydiff = Math.abs(pt.x - this._ptMouseDown.x);
                if (xdiff > 3 || ydiff > 3) {
                    this._isRealDrag = true;
                }
            }
            if (this._isRealDrag) {
                this.moveToPoint(pt.x, pt.y, false);
            }
        };
        dataTipClass.prototype.moveToPoint = function (x, y, centerRelative) {
            if (centerRelative) {
                var rc = vp.select(this._root).getBounds(false);
                x -= rc.width / 2;
                y -= rc.height / 2;
            }
            vp.select(this._root)
                .css("left", x + "px")
                .css("top", y + "px");
            this.onDataChanged("position");
            this.updateTextAndOffset(true);
        };
        dataTipClass.prototype.onMouseUp = function (e) {
            vp.utils.debug("dataTip: onMouseUp()");
            vp.events.releaseCaptureWindow();
            vp.events.cancelEventDefault(e);
            var closeMe = (!this._isRealDrag);
            if (!closeMe) {
                //---- if outside of plot, remove ----
                var rcImg = vp.dom.getBounds(this._img);
                var rcPlot = this._chart.getBounds();
                if (!vp.geom.rectIntersectsRect(rcImg, rcPlot)) {
                    closeMe = true;
                }
            }
            if (closeMe) {
                this.close();
            }
        };
        return dataTipClass;
    }(beachParty.baseAppControlClass));
    beachParty.dataTipClass = dataTipClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    dataTipMgr.ts - manages the data tips on the client.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var dataTipMgrClass = (function (_super) {
        __extends(dataTipMgrClass, _super);
        function dataTipMgrClass(app) {
            _super.call(this);
            this._dataTips = [];
            this._app = app;
        }
        dataTipMgrClass.prototype.addDataTip = function (chart, title, colNames, includeNames, pt) {
            var _this = this;
            var rootW = vp.select("#dataTipsRoot");
            //var bpsHelper = this._app._currentChart;
            var dataTip = new beachParty.dataTipClass(this._app, rootW[0], chart);
            this._dataTips.push(dataTip);
            dataTip.setParams(title, colNames, includeNames);
            dataTip.registerForChange("position", function (e) {
                var rc = dataTip.getIconBounds();
                var msg = "dataTip: " + vp.geom.rectToString(rc);
                _this._app.quickStats(msg);
            });
            if (pt) {
                dataTip.moveToPoint(pt.x, pt.y, true);
            }
            return dataTip;
        };
        dataTipMgrClass.prototype.getDataTip = function (primaryKey) {
            var dataTip = null;
            vp.utils.debug("getDataTip: primaryKey=" + primaryKey + ", dataTips.length=" + this._dataTips.length);
            for (var i = 0; i < this._dataTips.length; i++) {
                var dt = this._dataTips[i];
                if (dt._primaryKey == primaryKey) {
                    dataTip = dt;
                    break;
                }
            }
            return dataTip;
        };
        dataTipMgrClass.prototype.closeDataTip = function (dataTip) {
            dataTip.close();
            this._dataTips.remove(dataTip);
        };
        dataTipMgrClass.prototype.hideDataTipsBeforeLayout = function () {
            for (var i = 0; i < this._dataTips.length; i++) {
                var dt = this._dataTips[i];
                dt.show(false);
            }
        };
        dataTipMgrClass.prototype.updateDataTipsAfterLayout = function () {
            for (var i = 0; i < this._dataTips.length; i++) {
                var dt = this._dataTips[i];
                dt.updateTextAndOffset();
            }
        };
        dataTipMgrClass.prototype.clearDataTips = function () {
            //---- remove old data tips ----
            var rootW = vp.select("#dataTipsRoot")
                .clear();
            this._dataTips = [];
        };
        dataTipMgrClass.prototype.getDataFromDataTips = function (preload) {
            preload.dataTips = [];
            for (var i = 0; i < this._dataTips.length; i++) {
                var dataTip = this._dataTips[i];
                var dtd = dataTip.getDataTipData();
                preload.dataTips.push(dtd);
            }
        };
        return dataTipMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.dataTipMgrClass = dataTipMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    auxMgr.ts - manages the AUX attribute (for the SIZE BY and LINE BY grouping).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var auxMgrClass = (function (_super) {
        __extends(auxMgrClass, _super);
        function auxMgrClass(app, currentChart) {
            var _this = this;
            _super.call(this, app, currentChart, "aux");
            this._app.registerForChange("chart", function (e) {
                _this.onChartTypeChanged();
            });
        }
        auxMgrClass.prototype.countLayout = function (value) {
            var attribute = this.getAttribute();
            return attribute.countLayout.apply(attribute, arguments);
        };
        auxMgrClass.prototype.sumLayout = function (value) {
            var attribute = this.getAttribute();
            return attribute.sumLayout.apply(attribute, arguments);
        };
        auxMgrClass.prototype.onChartTypeChanged = function () {
            var panel = this._jsonPanel;
            if (panel) {
                var chartType = this._app.currentChart().chartName();
                var isPackingEnabled = (chartType == "Column" || chartType == "Bar");
                var assemW = vp.select(panel.getRootElem(), "#sizePacking");
                beachParty.appUtils.disableEnum(assemW, (!isPackingEnabled));
            }
        };
        return auxMgrClass;
    }(beachParty.attrMgrClass));
    beachParty.auxMgrClass = auxMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    shapeMgr.ts - manages the SHAPE attribute (for the SHAPE BY panel).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var shapeMgrClass = (function (_super) {
        __extends(shapeMgrClass, _super);
        function shapeMgrClass(app, currentChart) {
            _super.call(this, app, currentChart, "shape");
        }
        shapeMgrClass.prototype.onChartTypeChanged = function () {
            var attribute = this.getAttribute();
            return attribute.onChartTypeChanged.apply(attribute, arguments);
        };
        shapeMgrClass.prototype.useExperimentalImages = function (value) {
            var attribute = this.getAttribute();
            return attribute.useExperimentalImages.apply(attribute, arguments);
        };
        shapeMgrClass.prototype.onMappingChanged = function (binCountChanged, omitDataChangedCall, rebindColInfo) {
            var attribute = this.getAttribute();
            return attribute.onMappingChanged.apply(attribute, arguments);
        };
        return shapeMgrClass;
    }(beachParty.attrMgrClass));
    beachParty.shapeMgrClass = shapeMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    sizeMgr.ts - manages the SIZE attribute (for the SIZE BY panel).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var sizeMgrClass = (function (_super) {
        __extends(sizeMgrClass, _super);
        function sizeMgrClass(app, currentChart) {
            _super.call(this, app, currentChart, "size");
        }
        sizeMgrClass.prototype.onChartTypeChanged = function () {
            var attribute = this.getAttribute();
            return attribute.onChartTypeChanged.apply(attribute, arguments);
        };
        sizeMgrClass.prototype.onMappingChanged = function (binCountChanged, omitDataChangedCall) {
            var attribute = this.getAttribute();
            return attribute.onMappingChanged.apply(attribute, arguments);
        };
        return sizeMgrClass;
    }(beachParty.attrMgrClass));
    beachParty.sizeMgrClass = sizeMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    localeMgr.ts - manages the localization of SandDance into the current locale.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var localeMgrClass = (function (_super) {
        __extends(localeMgrClass, _super);
        function localeMgrClass(app, localeName) {
            _super.call(this);
            this.loadLocale(localeName);
        }
        localeMgrClass.prototype.loadLocale = function (name) {
            if (name == "ski") {
                this._locale = this.buildSkiLocale();
            }
            else if (name && name != "" && name != "none") {
                //---- load from cache or server ----
                var locale = beachParty.loadUserResource(name, beachParty.StorageType.locale, "locales");
                if (!locale) {
                    throw "Locale not supported: " + name;
                }
            }
            else {
            }
            return locale;
        };
        localeMgrClass.prototype.getText = function (key) {
            var textArray = null;
            if (this._locale) {
                textArray = this._locale.text[key];
            }
            return textArray;
        };
        localeMgrClass.prototype.buildSkiLocale = function () {
            var skiLocale = this.loadLocale("us");
            var keys = vp.utils.keys(skiLocale.text);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var textArray = skiLocale.text[key];
                if (textArray && textArray.length == 2) {
                    textArray[0] += "-ski";
                    textArray[1] += "-ski";
                }
            }
            return skiLocale;
        };
        return localeMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.localeMgrClass = localeMgrClass;
    /**
     * Information needed to localize SandDance.
     */
    var LocaleData = (function () {
        function LocaleData() {
        }
        return LocaleData;
    }());
    beachParty.LocaleData = LocaleData;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    iconBarMgr.ts - builds and manages the icon bar.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var iconBarMgrClass = (function (_super) {
        __extends(iconBarMgrClass, _super);
        //_buttonBuilder: buttonBuilderClass;
        function iconBarMgrClass(app, panelMgr, chartRouter) {
            _super.call(this);
            this._iconBarBuilt = false;
            this._groupIconBarIcons = true;
            this._app = app;
            this._chartRouter = chartRouter;
            this._panelMaster = panelMgr;
        }
        iconBarMgrClass.prototype.buildButtonTable = function (newGroupForSettings) {
            this._iconButtons = [
                { prompt: "Insights", chevron: false, set: "Insights", root: "insight", tip: "Open the Insights panel", cbName: "toggleInsightPanel", icon: beachParty.fnInsights },
                { prompt: "Nav", chevron: true, set: "Nav", root: "nav", tip: "Open the Navigation panel", cbName: "toggleNavPanel", icon: beachParty.fnNav },
                { prompt: "Wheel", chevron: true, set: "Wheel", root: "wheel", tip: "Show or hide the 3D navigation wheel", cbName: "toggleWheelMode", icon: beachParty.fnNav },
                { prompt: "Selection", chevron: true, set: "SelectMode", root: "select", tip: "Open the Select Mode panel", cbName: "onSelectClick", icon: beachParty.fnSelectionNormal },
                { prompt: "View", chevron: false, set: "NewView", root: "addView", tip: "Open a new SandDance view of the current data", cbName: "onAddView", icon: beachParty.fnNewView },
                { prompt: "Scrubber", chevron: true, set: "Scrubber", root: "scrub", tip: "Open the Data Scrubber dialog", cbName: "openScrubberDialog", icon: beachParty.fnScrubber },
                { prompt: "Undo", chevron: false, set: "Undo", root: "undo", tip: "Undo the last action", cbName: "onUndoClick", icon: beachParty.fnUndo },
                { prompt: "Redo", chevron: false, set: "Redo", root: "redo", tip: "Redo the last undone action", cbName: "onRedoClick", icon: beachParty.fnRedo },
                { prompt: "Cluster", chevron: true, set: "Clustering", root: "cluster", tip: "Open the Clustering panel", cbName: "toggleClusterPanel", icon: beachParty.fnCluster },
                { prompt: "Tips", chevron: true, set: "Tips", root: "tips", tip: "Opens the tooltips/datatips panel", cbName: "toggleTipsPanel", icon: beachParty.fnIconBarDataTip },
                { prompt: "Search", chevron: true, set: "Search", root: "search", tip: "Open the Search panel", cbName: "toggleSearchPanel", icon: beachParty.fnSearch },
                { prompt: "Browse", chevron: true, set: "Browse", root: "browse", tip: "Open the Facet Browser panel", cbName: "toggleBrowsePanel", icon: beachParty.fnFacetBrowse },
                { prompt: "Scripts", chevron: true, set: "Scripts", root: "scripts", tip: "Open the Scripts panel", cbName: "toggleScriptsPanel", icon: beachParty.fnScripts },
                { prompt: "Themes", chevron: true, set: "Themes", root: "themes", tip: "Open the Themes panel", cbName: "toggleThemesPanel", icon: beachParty.fnThemes },
                { prompt: "Palettes", chevron: true, set: "Palettes", root: "palettes", tip: "Open the Palettes panel", cbName: "togglePalettesPanel", icon: beachParty.fnPalettes },
                { prompt: "Isolate", chevron: false, set: "Isolate", root: "isolate", tip: "Isolate the selected items in the view", cbName: "onIsolateClick", icon: beachParty.fnIsolate, groupId: "iconBarMiddle" },
                { prompt: "Exclude", chevron: false, set: "Exclude", root: "exclude", tip: "Exclude the selected items from the view", cbName: "onExcludeClick", icon: beachParty.fnExlude },
                { prompt: "Reset", chevron: false, set: "Reset", root: "reset", tip: "Reset the filter and selection", cbName: "onResetClick", icon: beachParty.fnReset },
                { prompt: "Details", chevron: true, set: "Details", root: "details", tip: "Open the Details Panel (view data records)", cbName: "toggleDetailsPanel", icon: beachParty.fnDetails },
                { prompt: "Help", chevron: true, set: "Help", root: "help", tip: "Open the Help panel", cbName: "toggleHelpPanel", icon: beachParty.fnHelp, groupId: "iconBarRight" },
                { prompt: "Bot", chevron: true, set: "Bot", root: "bot", tip: "Open the Bot panel", cbName: "toggleBotPanel", icon: beachParty.fnBot },
                { prompt: "Tasks", chevron: true, set: "Tasks", root: "tasks", tip: "Open the Tasks panel", cbName: "toggleTasksPanel", icon: beachParty.fnTasks },
                { prompt: "Tours", chevron: true, set: "Tours", root: "tour", tip: "Open the Tours panel", cbName: "toggleTourLoaderPanel", icon: beachParty.fnTours },
                { prompt: "Settings", chevron: true, set: "Settings", root: "settings", tip: "Open the app settings panel", cbName: "toggleSettingsPanel", icon: beachParty.fnSettings },
                { prompt: "About", chevron: true, set: "About", root: "about", tip: "Open the About SandDance panel", cbName: "toggleAboutPanel", icon: beachParty.fnAbout },
            ];
            //---- add common properties ----
            for (var i = 0; i < this._iconButtons.length; i++) {
                var button = this._iconButtons[i];
                button.inToolbar = true;
                button.textForWidth = "Settings";
            }
            //if (newGroupForSettings)
            //{
            //    var count = this._iconButtons.length;
            //    this._iconButtons[count - 2].groupId = "newGroup";
            //    this._iconButtons[count - 1].groupId = null;
            //}
        };
        iconBarMgrClass.prototype.getButtonTable = function () {
            return this._iconButtons;
        };
        iconBarMgrClass.prototype.buildIconBar = function () {
            var bigBarMgr = this._app._bigBarMgr;
            if (bigBarMgr) {
                var settings = this._app._appSettingsMgr;
                var includeIconButtons = settings.isIconButtonsOnBigBar();
                if (!includeIconButtons) {
                    this.buildButtonTable(false);
                    this.buildIconBarFromTable();
                }
                else {
                    this.buildButtonTable(false);
                }
            }
        };
        iconBarMgrClass.prototype.buildIconBarFromTable = function () {
            var app = this._app;
            var settings = this._app._appSettingsMgr;
            var rebuild = this._iconBarBuilt;
            var iconBarElem = vp.select("#iconBar")[0];
            var toolbar = new beachParty.toolbarClass(app, iconBarElem, [app]);
            toolbar.startBuild();
            var iconButtons = this._iconButtons;
            var rightAlign = false;
            var localeMgr = app._localeMgr;
            var trW = null;
            for (var i = 0; i < iconButtons.length; i++) {
                var button = iconButtons[i];
                if (button.groupId !== undefined) {
                    toolbar.addIconSpacer();
                }
                if (settings.isButtonEnabled(button.set)) {
                    var nativePrompt = button.prompt;
                    var prompt = button.prompt;
                    var tip = button.tip;
                    if (nativePrompt == "Help" && !settings.showInProgressUI()) {
                        continue;
                    }
                    //---- use localized strings ----
                    var textInfo = localeMgr.getText("IconBar." + nativePrompt);
                    if (textInfo && textInfo.length == 2) {
                        prompt = textInfo[0];
                        tip = textInfo[1];
                    }
                    toolbar.addIconButton(button);
                }
            }
        };
        return iconBarMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.iconBarMgrClass = iconBarMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    colorMgr.ts - manages a single copy of the COLOR attribute (for the COLOR BY panel).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var colorMgrClass = (function (_super) {
        __extends(colorMgrClass, _super);
        function colorMgrClass(app, currentChart) {
            _super.call(this, app, currentChart, "color");
        }
        colorMgrClass.prototype.paletteMgr = function () {
            var attribute = this.getAttribute();
            return attribute._paletteMgr;
        };
        colorMgrClass.prototype.setCustomPalette = function (palette) {
            var attribute = this.getAttribute();
            return attribute.setCustomPalette.apply(attribute, arguments);
        };
        /**
         * If stepsRequested==0, compute an automatic value that gives nice results for numeric and date values.  For
           category, use 999 to allow all numbers to show
         */
        colorMgrClass.prototype.stepsRequested = function () {
            var attribute = this.getAttribute();
            return attribute.stepsRequested.apply(attribute, arguments);
        };
        colorMgrClass.prototype.onMappingChanged = function (rebuildPalette, rebindColInfo) {
            var attribute = this.getAttribute();
            return attribute.onMappingChanged.apply(attribute, arguments);
        };
        //colorSteps(value?: number, omitLogging?: boolean)
        //{
        //    var attribute = <colorAttrClass>this.getAttribute();
        //    return attribute.colorSteps.apply(attribute, arguments);
        //}
        //onColorStepsChanged()
        //{
        //    this.onDataChanged("rebuildColorPaletteList");
        //}
        colorMgrClass.prototype.getNamedPaletteFromSet = function (setName, name) {
            var attribute = this.getAttribute();
            return attribute.getNamedPaletteFromSet.apply(attribute, arguments);
        };
        colorMgrClass.prototype.setPaletteFromName = function (name, omitOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.setPaletteFromName.apply(attribute, arguments);
        };
        colorMgrClass.prototype.onColNameChanged = function () {
            var attribute = this.getAttribute();
            return attribute.onColNameChanged.apply(attribute, arguments);
        };
        colorMgrClass.prototype.zapColorChannels = function () {
            var attribute = this.getAttribute();
            return attribute.zapColorChannels.apply(attribute, arguments);
        };
        colorMgrClass.prototype.colorPaletteIndex = function (index) {
            var attribute = this.getAttribute();
            return attribute.colorPaletteIndex.apply(attribute, arguments);
        };
        colorMgrClass.prototype.getColorPaletteEntry = function (index) {
            var attribute = this.getAttribute();
            return attribute.getColorPaletteEntry.apply(attribute, arguments);
        };
        colorMgrClass.prototype.remapColorData = function () {
            var attribute = this.getAttribute();
            return attribute.remapColorData.apply(attribute, arguments);
        };
        colorMgrClass.prototype.colorSpread = function (value) {
            var attribute = this.getAttribute();
            return attribute.colorSpread.apply(attribute, arguments);
        };
        colorMgrClass.prototype.colorForceCategory = function (value) {
            var attribute = this.getAttribute();
            return attribute.colorForceCategory.apply(attribute, arguments);
        };
        colorMgrClass.prototype.reverseColorPalette = function (value, omitOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.reverseColorPalette.apply(attribute, arguments);
        };
        colorMgrClass.prototype.invertColorPalette = function (value, omitOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.invertColorPalette.apply(attribute, arguments);
        };
        colorMgrClass.prototype.colorIsContinuous = function (value, omitOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.colorIsContinuous.apply(attribute, arguments);
        };
        colorMgrClass.prototype.colorIsCycling = function (value, omitOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.colorIsCycling.apply(attribute, arguments);
        };
        colorMgrClass.prototype.redColumn = function (value, omitOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.redColumn.apply(attribute, arguments);
        };
        colorMgrClass.prototype.onChannelColumnChanged = function () {
            var attribute = this.getAttribute();
            return attribute.onChannelColumnChanged.apply(attribute, arguments);
        };
        colorMgrClass.prototype.greenColumn = function (value, omitOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.greenColumn.apply(attribute, arguments);
        };
        colorMgrClass.prototype.blueColumn = function (value, omitOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.blueColumn.apply(attribute, arguments);
        };
        colorMgrClass.prototype.rgbColumn = function (value, omitOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.rgbColumn.apply(attribute, arguments);
        };
        //---- supports the palettePicker in the color panel ----
        colorMgrClass.prototype.paletteSetName = function (value, omitOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.paletteSetName.apply(attribute, arguments);
        };
        colorMgrClass.prototype.colorPalette = function (value, omitOptionUpdate) {
            var attribute = this.getAttribute();
            return attribute.colorPalette.apply(attribute, arguments);
        };
        return colorMgrClass;
    }(beachParty.attrMgrClass));
    beachParty.colorMgrClass = colorMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    timeMgr.ts - manages the time panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var timeMgrClass = (function (_super) {
        __extends(timeMgrClass, _super);
        function timeMgrClass(app) {
            _super.call(this);
        }
        timeMgrClass.prototype.isPlaying = function (value, omitLogging) {
            if (arguments.length == 0) {
                return this._isPlaying;
            }
            this._isPlaying = value;
            if (!omitLogging) {
                this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.timePanel, true, { isPlaying: value });
            }
            this.onDataChanged("isPlaying");
        };
        return timeMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.timeMgrClass = timeMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    textMgr.ts - manages the TEXT attribute (for the TEXT BY mapping).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var textMgrClass = (function (_super) {
        __extends(textMgrClass, _super);
        function textMgrClass(app, currentChart) {
            _super.call(this, app, currentChart, "text");
        }
        textMgrClass.prototype.maxTextShapes = function (value, omitLogging) {
            var attribute = this.getAttribute();
            return attribute.maxTextShapes.apply(attribute, arguments);
        };
        textMgrClass.prototype.textColor = function (value, omitLogging) {
            var attribute = this.getAttribute();
            return attribute.textColor.apply(attribute, arguments);
        };
        return textMgrClass;
    }(beachParty.attrMgrClass));
    beachParty.textMgrClass = textMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    checkboxAssembly.ts - popup panel for slider with "-" and "+" buttons.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var nextCheckboxId = 1;
    function createCheckboxAssembly(parent, text, value, callback) {
        var parentW = vp.select(parent);
        //---- CHECKBOX ROW ----
        var divW = parentW.append("div")
            .addClass("searchCheckboxRow")
            .css("white-space", "nowrap")
            .css("min-height", "30px")
            .css("position", "relative")
            .attach("click", function (e) {
            var target = e.target;
            while (target && target.key === undefined) {
                target = target.parentNode;
            }
            var key = target.key;
            var cbElem = (target.tagName == "INPUT") ? target : target.checkbox;
            var isChecked = cbElem.checked;
            if (cbElem != e.target) {
                //---- toggle the checkbox ----
                isChecked = (!isChecked);
                cbElem.checked = isChecked;
            }
            callback(isChecked);
            if (cbElem != e.target) {
                vp.events.cancelEventBubble(e);
                vp.events.cancelEventDefault(e);
            }
        });
        //---- CHECKBOX ----
        var cbW = divW.append("input")
            .attr("type", "checkbox")
            .addClass("panelCheckbox");
        //---- TEXT ----
        var textW = divW.append("span")
            .addClass("panelDisplay searchColKey")
            .text(text)
            .css("position", "relative")
            .css("margin-left", "4px");
        if (value !== undefined) {
            cbW[0].checked = value;
        }
        divW[0].checkbox = cbW[0];
        divW[0].keyElem = textW[0];
        divW[0].key = text;
        return cbW[0];
    }
    beachParty.createCheckboxAssembly = createCheckboxAssembly;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    doubleSlider.ts - a double-ended slider for selecting a range (min and max) from a set of values.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var DoubleSliderControl = (function (_super) {
        __extends(DoubleSliderControl, _super);
        /**
         *
         * @param parentElem - the HTML element we will create our root element under.
         * @param outer - the outermost left/right data values (as shown on the slider axis).
         * @param inner - the current lef/right of data values (as set by the user).
         * @param padding - defines the start and end of the axis (in pixels).
         */
        function DoubleSliderControl(parentElem, outer, inner, padding) {
            var _this = this;
            _super.call(this);
            this._handleWidth = 15;
            //---- mouse ----
            this._ptDown = null;
            this._onMouseMoveFunc = null;
            this._onMouseUpFunc = null;
            this._onMouseMoveFunc = function (e) { return _this.onBarMove(e); };
            this._onMouseUpFunc = function (e) { return _this.onBarUp(e); };
            this._outer = outer;
            this._inner = inner;
            this._padding = padding;
            var formatter = vp.formatters.createNumFormatterFromRange(outer.left, outer.right);
            var strMin = formatter(outer.left);
            var strMax = formatter(outer.right);
            //---- ROOT ----
            var rootW = vp.select(parentElem).append("div")
                .id("DoubleSliderControl")
                .css("position", "relative");
            //---- BAR ROW ----
            var barRowW = rootW.append("div")
                .id("barRow")
                .css("position", "relative")
                .css("height", "30px");
            //---- BASE BAR ----
            var baseBarW = barRowW.append("div")
                .addClass("doubleSliderBaseBar")
                .css("position", "absolute")
                .css("left", padding.left + "px")
                .css("width", (padding.right - padding.left) + "px");
            //---- RANGE BAR ----
            var rangeBarW = barRowW.append("div")
                .addClass("doubleSliderRangeBar")
                .css("position", "absolute")
                .attach("mousedown", function (e) { return _this.onBarDown(e, "range"); });
            //---- LEFT HANDLE ----
            var leftHandleW = barRowW.append("div")
                .addClass("doubleSliderHandle")
                .css("position", "absolute")
                .css("top", "-1px")
                .css("width", this._handleWidth + "px")
                .attach("mousedown", function (e) { return _this.onBarDown(e, "left"); });
            //---- RIGHT HANDLE ----
            var rightHandleW = barRowW.append("div")
                .addClass("doubleSliderHandle")
                .css("position", "absolute")
                .css("left", "50%")
                .css("top", "-1px")
                .css("width", this._handleWidth + "px")
                .attach("mousedown", function (e) { return _this.onBarDown(e, "right"); });
            //---- TEXT ROW ----
            var labelsW = rootW.append("div")
                .id("textRow")
                .css("position", "relative")
                .css("height", "30px")
                .css("left", padding.left + "px")
                .css("width", (padding.right - padding.left) + "px");
            //---- LEFT TEXT ----
            var minText = labelsW.append("div")
                .addClass("panelDisplay")
                .css("position", "absolute")
                .css("left", "-4px")
                .text(strMin);
            //---- RIGHT TEXT ----
            var maxText = labelsW.append("div")
                .addClass("panelDisplay")
                .css("position", "absolute")
                .css("right", "-4px")
                .text(strMax);
            this._leftElem = leftHandleW[0];
            this._rightElem = rightHandleW[0];
            this._rangeElem = rangeBarW[0];
            this.calcHandlesFromInner();
            this.updateRangeElemsFromHandles();
        }
        DoubleSliderControl.prototype.inner = function (value) {
            if (arguments.length == 0) {
                return this._inner;
            }
            this._inner = value;
            this.calcHandlesFromInner();
            this.updateRangeElemsFromHandles();
            this.onDataChanged("inner");
        };
        DoubleSliderControl.prototype.onBarDown = function (e, downLoc) {
            var pt = vp.events.mousePosition(e);
            this._ptDown = pt;
            this._locOnDown = downLoc;
            this._handlesOnDown = new Range(this._handles.left, this._handles.right);
            vp.events.setCaptureWindow(this._onMouseMoveFunc, this._onMouseUpFunc);
        };
        DoubleSliderControl.prototype.onBarUp = function (e) {
            if (this._locOnDown) {
                this._locOnDown = null;
                vp.events.releaseCaptureWindow();
                this.onDataChanged("innerCompleted");
            }
        };
        DoubleSliderControl.prototype.onBarMove = function (e) {
            if (this._locOnDown) {
                var pt = vp.events.mousePosition(e);
                var xdiff = pt.x - this._ptDown.x;
                if (xdiff) {
                    var padding = this._padding;
                    var handles = this._handles;
                    var handlesOnDown = this._handlesOnDown;
                    var locOnDown = this._locOnDown;
                    var handleWidth = this._handleWidth;
                    var minHandleShowing = 4; // 4 pixels must be showing on overlap
                    if (locOnDown == "left") {
                        var firstx = padding.left;
                        var lastx = handles.right - minHandleShowing;
                        var newLeft = handlesOnDown.left + xdiff;
                        if (newLeft < firstx) {
                            newLeft = firstx;
                        }
                        else if (newLeft > lastx) {
                            newLeft = lastx;
                        }
                        handles.left = newLeft;
                    }
                    else if (locOnDown == "right") {
                        var firstx = handles.left + minHandleShowing;
                        var lastx = padding.right;
                        var newRight = handlesOnDown.right + xdiff;
                        if (newRight < firstx) {
                            newRight = firstx;
                        }
                        else if (newRight > lastx) {
                            newRight = lastx;
                        }
                        handles.right = newRight;
                    }
                    else if (locOnDown == "range") {
                        var firstx = padding.left;
                        var lastx = padding.right;
                        var newLeft = handlesOnDown.left + xdiff;
                        var newRight = handlesOnDown.right + xdiff;
                        if (newLeft < firstx) {
                            newLeft = firstx;
                            xdiff = newLeft - handlesOnDown.left;
                        }
                        else if (newRight > lastx) {
                            newRight = lastx;
                            xdiff = newRight - handlesOnDown.right;
                        }
                        //--- now set final values ----
                        handles.left = handlesOnDown.left + xdiff;
                        handles.right = handlesOnDown.right + xdiff;
                    }
                    this.updateRangeElemsFromHandles(locOnDown);
                    this.calcInnerFromHandles();
                    this.onDataChanged("inner");
                }
            }
        };
        /**
         * calculate handle left/right positions from the inner left/right data values.
         */
        DoubleSliderControl.prototype.calcHandlesFromInner = function () {
            var padding = this._padding;
            var outer = this._outer;
            var inner = this._inner;
            var minPos = padding.left;
            var maxPos = padding.right;
            var leftPos = vp.data.mapValue(inner.left, outer.left, outer.right, minPos, maxPos);
            var rightPos = vp.data.mapValue(inner.right, outer.left, outer.right, minPos, maxPos);
            this._handles = new Range(leftPos, rightPos);
        };
        /**
         * calculate the inner left/right data values from the handle left/right positions.
         */
        DoubleSliderControl.prototype.calcInnerFromHandles = function () {
            var padding = this._padding;
            var outer = this._outer;
            var handles = this._handles;
            var minPos = padding.left;
            var maxPos = padding.right;
            var innerLeft = vp.data.mapValue(handles.left, minPos, maxPos, outer.left, outer.right);
            var innerRight = vp.data.mapValue(handles.right, minPos, maxPos, outer.left, outer.right);
            this._inner = new Range(innerLeft, innerRight);
        };
        DoubleSliderControl.prototype.updateRangeElemsFromHandles = function (locOnDown) {
            var padding = this._padding;
            var handles = this._handles;
            var halfHandle = this._handleWidth / 2;
            var leftPos = handles.left - halfHandle;
            var rightPos = handles.right - halfHandle;
            vp.select(this._leftElem).css("left", leftPos + "px");
            vp.select(this._rightElem).css("left", rightPos + "px");
            vp.select(this._rangeElem)
                .css("left", (handles.left) + "px")
                .css("width", (handles.right - handles.left) + "px");
            //---- put last touched handle on top (for overlap cases) ----
            if (locOnDown == "left") {
                vp.select(this._leftElem).css("z-index", "2");
                vp.select(this._rightElem).css("z-index", "1");
            }
            else if (locOnDown == "right") {
                vp.select(this._leftElem).css("z-index", "1");
                vp.select(this._rightElem).css("z-index", "2");
            }
        };
        DoubleSliderControl.prototype.getRootElem = function () {
            return this._root;
        };
        DoubleSliderControl.prototype.close = function () {
            vp.select(this._root)
                .remove();
        };
        return DoubleSliderControl;
    }(beachParty.baseAppControlClass));
    beachParty.DoubleSliderControl = DoubleSliderControl;
    var Range = (function () {
        function Range(left, right) {
            this.left = left;
            this.right = right;
        }
        return Range;
    }());
    beachParty.Range = Range;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    listBox.ts - defines listbox that holds strings or MenuItemData items.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var listBoxClass = (function (_super) {
        __extends(listBoxClass, _super);
        function listBoxClass(app, parent, items, clickCallback, iconWidth, clipText, iconClassName) {
            var _this = this;
            _super.call(this);
            this._selectedElem = null;
            this._clickCallback = null;
            this._iconWidth = 0;
            this._app = app;
            this._items = items;
            this._clickCallback = clickCallback;
            this._iconWidth = iconWidth;
            this._clipText = clipText;
            var rootW = vp.select(parent).append("div")
                .addClass("flexGrow flexRows customScrollbar")
                .css("overflow-y", "auto")
                .css("overflow-x", "hidden");
            this._root = rootW[0];
            this.buildList(items, iconClassName);
            vp.select(window).attach("resize", function (e) { return _this.adjustRightMarginWhenScrolling(); });
        }
        listBoxClass.prototype.buildList = function (items, iconClassName) {
            var _this = this;
            var menuItemIndex = 0;
            var textItemIndex = 0;
            var indexes = { menuItemIndex: menuItemIndex, textItemIndex: textItemIndex };
            var rootW = vp.select(this._root)
                .clear();
            var tableW = rootW.append("table")
                .addClass("noSpaceTable listBox")
                .width("220px");
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                var themeMgr = this._app._themeMgr;
                var elem = beachParty.popupMenuClass.addItem(themeMgr, tableW, item, indexes, false, function (e, menu, textIndex, menuIndex) {
                    var mid = items[menuIndex];
                    _this._clickCallback(mid);
                }, null, this._iconWidth, this._clipText, iconClassName);
            }
            this._tableElem = tableW[0];
            setTimeout(function (e) { return _this.adjustRightMarginWhenScrolling(); }, 1);
        };
        listBoxClass.prototype.adjustRightMarginWhenScrolling = function () {
            var elem = this._tableElem.parentElement;
            if (elem.scrollHeight > elem.offsetHeight) {
                //--- if a scrollbar exists, add space to margin ----
                vp.select(this._tableElem)
                    .css("margin-right", "30px");
            }
        };
        listBoxClass.prototype.selectedValue = function (value) {
            if (arguments.length == 0) {
                return this._selectedValue;
            }
            this.changeSelectedItem(value);
        };
        listBoxClass.prototype.getElemByTextValue = function (value) {
            var newElem = null;
            for (var i = 0; i < this._items.length; i++) {
                var item = this._items[i];
                var itemValue = (item.text !== undefined) ? item.text : item;
                if (itemValue == value || itemValue.toLowerCase() == "none" && value == "") {
                    newElem = vp.select(this._root.firstChild).kids()[i];
                    break;
                }
            }
            return newElem;
        };
        listBoxClass.prototype.changeSelectedItem = function (newValue) {
            //---- remove mark on previous selected item ----
            if (this._selectedElem) {
                vp.select(this._selectedElem)
                    .attr("data-selected", "false");
            }
            //---- find newValue's matching element ----
            var newElem = this.getElemByTextValue(newValue);
            this._selectedElem = newElem;
            //---- add mark to new selected item ----
            if (newElem) {
                vp.select(this._selectedElem)
                    .attr("data-selected", "true");
            }
        };
        return listBoxClass;
    }(beachParty.dataChangerClass));
    beachParty.listBoxClass = listBoxClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    colorPicker.ts - control for displaying/setting a color.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var gaugeCircleRadius = 50;
    var colorPickerClass = (function (_super) {
        __extends(colorPickerClass, _super);
        function colorPickerClass(app, parentElem, initialValue, tooltip, textWidth) {
            var _this = this;
            if (textWidth === void 0) { textWidth = 60; }
            _super.call(this);
            this._app = app;
            this._value = initialValue;
            var rootW = vp.select(parentElem).append("div")
                .addClass("colorPicker flexColumns flexOtherAutoCenter")
                .title(tooltip);
            this._root = rootW[0];
            this._root.control = this;
            this.addTextBox(rootW, initialValue, textWidth);
            //---- SAMPLE ----
            this.addSampleBox(rootW);
            //--- protect our popup from ugly events ----
            vp.events.attach(window, "resize", function (e) { return _this.closePalette(); });
        }
        colorPickerClass.prototype.addSampleBox = function (tdW) {
            var _this = this;
            var sampleW = tdW.append("div")
                .addClass("colorSampleButton")
                .title("Click to open the color palette")
                .css("margin-left", "4px")
                .attach("click", function (e) {
                _this.togglePaletteAssembly();
            });
            this._sampleElem = sampleW[0];
            this.updateSample();
        };
        colorPickerClass.prototype.updateSample = function () {
            var crValue = this._value;
            vp.select(this._sampleElem)
                .css("background", crValue);
        };
        colorPickerClass.prototype.closePalette = function () {
            if (this._paletteAssembly) {
            }
            if (this._popupHost) {
                this._popupHost.close();
            }
        };
        colorPickerClass.prototype.togglePaletteAssembly = function () {
            if (this._paletteAssembly) {
                this.closePalette();
            }
            else {
                this.openPalette();
            }
        };
        colorPickerClass.prototype.createPopupHost = function () {
            var popup = new beachParty.basePopupClass("", this._root);
            this._popupHost = popup;
            var rootW = vp.select(document.body).append("div");
            popup._root = rootW[0];
            //---- point root of popup to its class instance ----
            rootW[0].jsObj = popup;
            popup._autoCloseOnDblClick = false;
            //---- treat mouseDown on owner as an extension of our popup ----
            popup._autoCloseOnOwnerMouseDown = false;
            vp.select(popup.getRootElem())
                .css("z-index", "1999")
                .css("position", "absolute");
            return popup;
        };
        colorPickerClass.prototype.openPalette = function () {
            var _this = this;
            //---- create a popup to hold the palette ----
            var popup = this.createPopupHost();
            var host = popup.getRootElem();
            this._paletteAssembly = new beachParty.paletteAssemblyClass(this._app, host, this._value);
            //vp.utils.debug("palette ASSEMBLY CREATED");
            //---- position popup right aligned with bottom of our sample ----
            var rc = vp.select(this._sampleElem).getBounds(false);
            popup.showAt(undefined, rc.bottom + 3, rc.right, undefined);
            this._paletteAssembly.registerForChange("value", function (e) {
                if (_this._paletteAssembly) {
                    var newValue = _this._paletteAssembly.value();
                    _this.value(newValue);
                    _this.closePalette();
                }
            });
            if (popup) {
                popup.registerForChange("close", function (e) {
                    vp.utils.debug("palette ASSEMBLY CLOSED");
                    _this._paletteAssembly = null;
                });
            }
            //---- give it focus (so when focus is lost, we can auto hide it) ----
            this._paletteAssembly.setFocusToPalette();
        };
        colorPickerClass.prototype.addTextBox = function (rootW, text, textWidth) {
            var _this = this;
            var textW = rootW.append("input")
                .attr("type", "text")
                .addClass("panelText")
                .css("width", textWidth + "px") // as small as possible
                .value(text)
                .attach("focus", function (e) {
                e.target.select();
            })
                .attach("keydown", function (e) {
                _this.onTextKeyDown(e);
            })
                .attach("change", function (e) {
                _this.value(e.target.value, "text");
                //---- keep focus in our text control ----
                vp.events.cancelEventBubble(e);
                vp.events.cancelEventDefault(e);
            });
            this._textElem = textW[0];
        };
        colorPickerClass.prototype.onTextKeyDown = function (e) {
            var _this = this;
            if (e.keyCode == vp.events.keyCodes.escape) {
                setTimeout(function (ee) {
                    _this.updateTextBox();
                    e.target.select();
                }, 10);
            }
        };
        colorPickerClass.prototype.show = function (value) {
            //---- use "inline-block" as workaround for IE and Chrome layout issues ----
            vp.select(this._root).css("display", (value) ? "" : "none");
        };
        colorPickerClass.prototype.isShowing = function () {
            return (vp.select(this._root).css("display") != "none");
        };
        colorPickerClass.prototype.getRoot = function () {
            return this._root;
        };
        colorPickerClass.prototype.value = function (value, source) {
            if (arguments.length === 0) {
                //---- get true color name for this color ----
                value = beachParty.cbUtils.getBeachPartyColor(this._value);
                return value;
            }
            if (value != this._value) {
                this._value = value;
                this.updateTextBox();
                if (source != "palette") {
                    this.updatePaletteValue();
                }
                this.updateSample();
                this.onDataChanged("value");
            }
        };
        colorPickerClass.prototype.updatePaletteValue = function () {
            if (this._paletteAssembly) {
            }
        };
        colorPickerClass.prototype.updateTextBox = function () {
            var strValue = this._value;
            //---- get SandDance-friendly name for this color ----
            strValue = beachParty.cbUtils.getBeachPartyName(strValue);
            vp.select(this._textElem)
                .value(strValue);
        };
        return colorPickerClass;
    }(beachParty.dataChangerClass));
    beachParty.colorPickerClass = colorPickerClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    numSpreader.ts - popup panel for adjusting the search spread of a numeric field.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var numSpreaderClass //extends basePanelClass
     = (function () {
        function numSpreaderClass //extends basePanelClass
            (chartRouter, colName, value, minValue, maxValue, parentElem, initialPercent, searchCallback) {
            //super(true, null, null, null, null, false, "Spread the value to search", false, parentElem);
            var _this = this;
            this._colName = colName;
            this._value = value;
            this._minValue = minValue;
            this._maxValue = maxValue;
            this._chartRouter = chartRouter;
            this._searchCallback = searchCallback;
            var rootW = vp.select(parentElem)
                .append("span")
                .addClass("numSpreaderPanel")
                .css("height", "15px");
            ////---- add the PERCENT TEXT ----
            //var sliderTextW = rootW.append("span")
            //    .addClass("numSpreaderPercent")
            //    .css("margin-left", "10px")
            //    .css("min-width", "40px")
            //    .css("display", "inline-block")
            //---- add the SLIDER CONTROL ----
            var sliderW = rootW.append("input")
                .addClass("numSpreaderSlider")
                .attr("type", "range")
                .title("Adjust spread of value to search")
                .attr("min", "0")
                .attr("max", "100")
                .attr("value", initialPercent + "")
                .css("display", "inline-block")
                .css("width", "80px")
                .css("margin-top", "0px")
                .css("margin-left", "10px")
                .css("height", "20px")
                .css("position", "relative")
                .css("top", "3px")
                .attach("change", function (e) { return _this.onSliderChange(); })
                .attach("mouseup", function (e) { return _this.onRangeClick(e); });
            ////---- add the COL NAME ----
            //var colNameW = rootW.append("span")
            //    .addClass("numSpreaderColName")
            //    .css("margin-left", "10px")
            //    .text(colName + ": ")
            //---- add the RANGE BUTTON ----
            var rangeButtonW = rootW.append("span")
                .addClass("numSpreaderRange")
                .addClass("selectedTextButton")
                .css("padding-top", "0px")
                .css("padding-bottom", "2px")
                .css("margin-left", "10px")
                .css("margin-right", "10px")
                .css("height", "20px")
                .css("display", "inline-block")
                .css("position", "relative")
                .css("top", "-2px")
                .title("Search in specified value range")
                .attach("click", function (e) { return _this.onRangeClick(e); });
            this._root = rootW[0];
            //this._colNameElem = colNameW[0];
            this._rangeButton = rangeButtonW[0];
            this._slider = sliderW[0];
            //this._sliderText = sliderTextW[0];
            this._isOpen = true;
            this.onSliderChange();
        }
        numSpreaderClass //extends basePanelClass
        .prototype.onRangeClick = function (e) {
            var percent = this._slider.value;
            this._searchCallback(this._colName, this._minSpread + "", this._maxSpread + "", beachParty.TextSearchType.betweenInclusive, percent);
        };
        numSpreaderClass //extends basePanelClass
        .prototype.isOpen = function () {
            return this._isOpen;
        };
        numSpreaderClass //extends basePanelClass
        .prototype.close = function () {
            vp.select(this._root)
                .remove();
            this._isOpen = false;
        };
        //onSearchClick()
        //{
        //    this._currentChart.search(this._colName, this._minSpread + "", this._maxSpread + "",
        //        TextSearchType.betweenInclusive);
        //}
        numSpreaderClass //extends basePanelClass
        .prototype.format = function (value, decimals) {
            var str = value.toLocaleString(undefined, { maximumFractionDigits: decimals, minimumFractionDigits: decimals });
            return str;
        };
        numSpreaderClass //extends basePanelClass
        .prototype.onSliderChange = function () {
            var slider = this._slider;
            var percent = +slider.value;
            //---- apply "spread low" to lower value ----
            percent /= 100; // convert to range 0..1
            percent = percent * percent;
            percent *= 100; // convert back to original range
            var value = this._value;
            var minValue = this._minValue;
            var maxValue = this._maxValue;
            var valueDelta = maxValue - minValue;
            var delta = percent * valueDelta / 100;
            //---- ensure delta is at least 2*epsilon so we don't unselect our original record's value ----
            var epsilon = .000001;
            delta = Math.max(delta, 2 * epsilon);
            var minSpread = Math.max(minValue, value - delta);
            var maxSpread = Math.min(maxValue, value + delta);
            this._minSpread = minSpread;
            this._maxSpread = maxSpread;
            var spreadText = percent + "%";
            //var vd = valueDelta / 50;
            var vd = (2 * delta) / 50;
            var decimals = (vd >= 1) ? 0 : (-Math.ceil(Math.log10(vd)));
            if (percent == 0) {
                decimals = undefined;
            }
            var rangeText = this.format(minSpread, decimals) + " to " + this.format(maxSpread, decimals);
            if (this._sliderText) {
                this._sliderText.textContent = spreadText;
            }
            this._rangeButton.textContent = rangeText;
        };
        return numSpreaderClass //extends basePanelClass
        ;
    }());
    beachParty.numSpreaderClass //extends basePanelClass
     = numSpreaderClass //extends basePanelClass
    ;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    picker.ts - a BeachParty-style DROPDOWN control (with full control over styling, unlike HTML select control).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var pickerClass = (function (_super) {
        __extends(pickerClass, _super);
        function pickerClass(app, parentElem, prompt, values, initialValue, tooltip, capitalizeFirstValue, iconWidth) {
            var _this = this;
            _super.call(this);
            this._app = app;
            this._parentElem = parentElem;
            this._values = values;
            this._iconWidth = iconWidth;
            //---- create prompt ----
            if (prompt) {
                var spanW = vp.select(parentElem).append("span");
                //---- prompt: TYPE ----
                var promptW = spanW.append("span")
                    .addClass("panelPrompt")
                    .text(prompt)
                    .css("margin-right", "4px");
                parentElem = spanW[0];
            }
            //---- create DROPDOWN BUTTON to hold text and chevron ----
            var ddButtonW = vp.select(parentElem).append("span")
                .addClass("panelButton")
                .title(tooltip)
                .css("cursor", "pointer")
                .css("white-space", "nowrap")
                .id("ddButton" + pickerClass.nextPickerClassButtonId++);
            this._openerIds = ddButtonW.id();
            // ----create TEXT part of button ----
            var ddTextW = ddButtonW.append("span")
                .addClass("panelButtonText")
                .css("vertical-align", "middle")
                .css("text-align", "left");
            //---- to workaround issue of mouse "dead zones" around img, try embedding it inside a in-line block span ----
            var divW = ddButtonW.append("span")
                .addClass("panelButtonChevron")
                .css("display", "inline-block")
                .css("cursor", "pointer");
            //---- add dropdown CHEVRON icon ----
            var chevronW = divW.append("img")
                .addClass("clickIcon")
                .css("margin-left", "4px")
                .css("margin-bottom", "2px")
                .css("vertical-align", "bottom")
                .attach("dragstart", function (e) {
                //---- prevent drag of icon ----
                e.preventDefault();
            });
            //---- todo: what about undocked? ----
            beachParty.setIconName(this._app._themeMgr, chevronW[0], beachParty.fnChevron, "dockedPanel", true);
            ddButtonW
                .attach("click", function (e) {
                beachParty.chartUtils.callPanelOpen(e, function (ee) {
                    _this.onPickerClick(e); // //onOpenCallback(row.dataName, ddText, chevronW, e);
                });
            });
            //---- set initial value ----
            var value = initialValue;
            if (capitalizeFirstValue) {
                //---- change all enum values to start with a capital letter ----
                value = beachParty.chartUtils.capitalizeFirstLetter(value);
            }
            this._textElem = ddTextW[0];
            this._chevronElem = chevronW[0];
            if (prompt) {
                this._root = spanW[0];
            }
            else {
                this._root = ddButtonW[0];
            }
            this.value(value);
        }
        pickerClass.prototype.getRoot = function () {
            return this._root;
        };
        pickerClass.prototype.value = function (value) {
            if (arguments.length == 0) {
                return this._value;
            }
            if (value != this._value) {
                this._value = value;
                this.onDataChanged("value");
                this._textElem.textContent = value;
            }
        };
        pickerClass.prototype.values = function (value) {
            if (arguments.length == 0) {
                return this._values;
            }
            this._values = value;
            this.onDataChanged("values");
        };
        pickerClass.buildStringsFromEnum = function (enumType, capitalizeFirstLetter) {
            if (capitalizeFirstLetter === void 0) { capitalizeFirstLetter = true; }
            var pickerItems = vp.utils.keys(enumType);
            //---- capitalize the first letter of each enum name ----
            if (capitalizeFirstLetter) {
                pickerItems = pickerItems.map(function (name) { return beachParty.chartUtils.capitalizeFirstLetter(name); });
            }
            //---- todo: what does this filter out? ----
            var pickerItems = pickerItems.filter(function (k) {
                return (isNaN(+k));
            });
            //---- some long list of enum values have separators in them; substitute a menu line marker ----
            var pickerItems = pickerItems.map(function (val) {
                return (val == "separator") ? "-" : val;
            });
            return pickerItems;
        };
        pickerClass.prototype.onPickerClick = function (e) {
            var _this = this;
            var picker = null;
            var colItems = this._values;
            var verticalMargin = null;
            var iconWidth = this._iconWidth;
            if (colItems) {
                picker = new beachParty.popupMenuClass(this._app, this._openerIds, "generalColPicker", colItems, function (e, menu, textIndex, menuIndex) {
                    var value = colItems[menuIndex];
                    if (value instanceof beachParty.MenuItemData) {
                        value = value.text;
                    }
                    _this.value(value);
                }, undefined, undefined, verticalMargin, iconWidth, this._parentElem);
            }
            //---- open popup menu relative to chevron ----
            var chevronW = vp.select(this._chevronElem);
            var rcChevron = chevronW.getBounds(false);
            var pickerElem = picker.getRootElem();
            var rcPicker = vp.select(pickerElem).getBounds(false);
            //---- right align picker with right of text/chevon box ----
            var x = rcChevron.right + 4 - rcPicker.width;
            //---- ENUM PICKERS seem to need this adjustment - does this break anything else? ----
            picker.openWithoutOverlap(x + 2, rcChevron.bottom + 12, null, null);
        };
        pickerClass.nextPickerClassButtonId = 1;
        return pickerClass;
    }(beachParty.dataChangerClass));
    beachParty.pickerClass = pickerClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    searchNode.ts - control for a single search node.  
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var searchNodeClass = (function (_super) {
        __extends(searchNodeClass, _super);
        function searchNodeClass(app, parentElem, name, includeTitleRow) {
            var _this = this;
            _super.call(this);
            this._isOpen = true;
            this._allName = "( All )";
            this._isSortByCount = true;
            this._isDescendingSort = true;
            this._maxKeys = 100;
            this._app = app;
            this._nodeData = new beachParty.SearchNodeData(name, "number");
            //---- ROOTl ----
            var rootW = vp.select(parentElem).append("div")
                .addClass("flexAuto flexRows searchNodeShell");
            if (includeTitleRow) {
                //---- TITLE ----
                var titleRowW = rootW.append("div")
                    .addClass("flexAuto flexColumns searchNodeTitleRow")
                    .css("position", "relative")
                    .css("height", "24px")
                    .attach("click", function (e) {
                    _this.toggleOpen();
                    vp.events.cancelEventBubble(e);
                    vp.events.cancelEventDefault(e);
                });
                var titleW = titleRowW.append("div")
                    .addClass("flexAuto panelDisplay searchNodeTitle")
                    .css("margin", "6px")
                    .css("width", "260px");
                //.css("border", "1px solid green")
                //---- CLOSE button----
                var imgCloseW = titleRowW.append("img")
                    .addClass("flexAuto clickIcon")
                    .attr("src", beachParty.fnClose)
                    .css("width", "20px")
                    .css("margin-left", "4px")
                    .css("position", "absolute")
                    .css("top", "0px")
                    .css("right", "4px")
                    .attach("click", function (e) { return _this.onDataChanged("closeRequest"); });
                this._titleElem = titleW[0];
                this._titleRowElem = titleRowW[0];
            }
            //---- CONTENT ----
            var contentW = rootW.append("div")
                .addClass("flexAuto searchNodeContent");
            this._root = rootW[0];
            this._contentElem = contentW[0];
            this.buildShellContent(contentW);
            this.updateTitle();
            beachParty.matchIconsToTheme(this._app._themeMgr, rootW[0]);
        }
        searchNodeClass.prototype.getNodeData = function () {
            return this._nodeData;
        };
        searchNodeClass.prototype.toggleOpen = function () {
            this._isOpen = (!this._isOpen);
            vp.select(this._contentElem).css("display", (this._isOpen) ? "" : "none");
        };
        searchNodeClass.prototype.colName = function (value) {
            if (arguments.length == 0) {
                return this._nodeData.colName;
            }
            if (value == this._allName) {
                value = null;
            }
            if (this._nodeData.colName != value) {
                this._nodeData.colName = value;
                this.onColNameChanged();
            }
        };
        searchNodeClass.prototype.onColNameChanged = function () {
            var colType = this._app.getColType(this.colName());
            var nodeData = this._nodeData;
            nodeData.colType = colType;
            //---- clear out previous nodeData selected by user ----
            nodeData.min = undefined;
            nodeData.max = undefined;
            nodeData.valueList = null;
            this.rebuildLowerContent();
            this.onDataChanged("colName");
            this.updateTitle();
        };
        searchNodeClass.prototype.values = function (value, isIncremental) {
            if (arguments.length == 0) {
                return this._nodeData.valueList;
            }
            if (this._nodeData.valueList != value || !isIncremental) {
                this._nodeData.valueList = value;
                this.onValuesChanged(isIncremental);
            }
        };
        searchNodeClass.prototype.updateTitle = function () {
            var values = this.values();
            var nodeData = this._nodeData;
            var colName = this.colName();
            var title = (colName) ? (colName + ": ") : ("All: ");
            if (values && values.length) {
                for (var i = 0; i < values.length; i++) {
                    if (i > 0) {
                        title += ", ";
                    }
                    title += values[i];
                }
            }
            else if (nodeData.min !== undefined) {
                var formatter = vp.formatters.createNumFormatterFromRange(nodeData.min, nodeData.max);
                title += formatter(nodeData.min) + "-" + formatter(nodeData.max);
            }
            else {
                title = "";
            }
            vp.select(this._titleElem)
                .text(title)
                .title(title);
            //---- collapse title if this is initial/empty node ----
            //vp.select(this._titleRowElem)
            //    .css("height", (title=="") ? "0px" : "20px")
        };
        searchNodeClass.prototype.buildShellContent = function (contentW) {
            var _this = this;
            var colSearchW = contentW.append("div")
                .css("white-space", "nowrap");
            //---- COLUMN PICKER ----
            var colPickerValues = this._app.getMappingCols(false, this._allName);
            var colPickerStrings = colPickerValues.map(function (md) { return md.text; });
            var firstValue = colPickerStrings[0];
            var colPicker = new beachParty.pickerClass(this._app, colSearchW[0], null, colPickerStrings, firstValue, "Select a column for this search node", true, 20);
            var colPickerW = vp.select(colPicker.getRoot())
                .css("margin", "10px");
            colPicker.registerForChange("value", function (e) {
                var itemText = colPicker.value();
                _this.colName(itemText);
            });
            var lowerContentW = contentW.append("div");
            this._lowerContentElem = lowerContentW[0];
            //---- SEARCH BOX ----
            var searchW = colSearchW.append("input")
                .addClass("searchText")
                .attr("type", "text")
                .css("width", "150px")
                .css("margin", "0 10px 10px 10px")
                .attr("placeholder", "Search")
                .css("position", "relative")
                .attach("focus", function (e) {
                e.target.select();
            })
                .attach("keydown", function (e) {
                _this.onTextKeyDown(e);
            })
                .attach("keyup", function (e) {
                var text = e.target.value;
                _this._nodeData.textSearchType = beachParty.TextSearchType.contains;
                _this._nodeData.textCaseSensitive = false;
                _this.values([text], true);
            })
                .attach("change", function (e) {
                var text = e.target.value;
                _this._nodeData.textSearchType = beachParty.TextSearchType.contains;
                _this._nodeData.textCaseSensitive = false;
                _this.values([text]);
            });
            //---- trigger build of lower context for first item ----
            var itemText = colPicker.value();
            this.colName(itemText);
            //this.rebuildLowerContent();
        };
        searchNodeClass.prototype.onTextKeyDown = function (e) {
            var _this = this;
            if (e.keyCode == vp.events.keyCodes.enter) {
                //---- this select will trigger a "change" event ----
                e.target.select();
            }
            else if (e.keyCode == vp.events.keyCodes.escape) {
                setTimeout(function (ee) {
                    e.target.select();
                    var newValue = e.target.value;
                    _this._nodeData.textSearchType = beachParty.TextSearchType.contains;
                    _this._nodeData.textCaseSensitive = false;
                    _this.values([newValue]);
                }, 10);
            }
        };
        searchNodeClass.prototype.rebuildLowerContent = function () {
            this._barParent = null;
            if (this._nodeData.colName) {
                if (this._nodeData.colType == "string") {
                    this.rebuildCheckboxes();
                }
                else {
                    this.buildRange();
                }
            }
            this.onNodeDataChanged(true);
        };
        searchNodeClass.prototype.rebuildCheckboxes = function () {
            var _this = this;
            var dataMgr = this._app.currentChart().getDataMgr();
            dataMgr.getColKeyCounts(this.colName(), this._isSortByCount, this._isDescendingSort, this._maxKeys, function (keyCountList) {
                var contentElem = _this.buildCheckBoxesCore(keyCountList);
                //---- after content is completely built, do a quick switch ----
                var lowerContentW = vp.select(_this._lowerContentElem)
                    .clear()
                    .append(contentElem);
            });
        };
        searchNodeClass.prototype.buildCheckBoxesCore = function (keyCountList) {
            var _this = this;
            var contentW = vp.select(document.body).append("div");
            //---- SORT LINE ----
            var sortLineW = contentW.append("div");
            var promptW = sortLineW.append("span")
                .addClass("panelDisplay")
                .text("Sort:")
                .css("margin", "10px")
                .css("margin-right", "0px");
            var sortW = sortLineW.append("a")
                .addClass("panelButton")
                .text((this._isSortByCount) ? "Quanity" : "A-Z")
                .css("margin", "10px")
                .css("margin-left", "4px")
                .attach("click", function (e) { return _this.toggleSortByCount(e); });
            var reverseW = sortLineW.append("a")
                .addClass("panelButton")
                .text((this._isDescendingSort) ? "Descending" : "Ascending")
                .css("margin", "10px")
                .css("margin-left", "30px")
                .attach("click", function (e) { return _this.toggleDescending(e); });
            //---- CHECKBOX TABLE ----
            var tableW = contentW.append("table")
                .css("width", "300px")
                .css("margin", "10px");
            for (var i = 0; i < keyCountList.length; i++) {
                if (i >= this._maxKeys) {
                    break;
                }
                var pair = keyCountList[i];
                //---- CHECKBOX ROW ----
                var rowW = tableW.append("tr")
                    .addClass("searchCheckboxRow")
                    .attach("click", function (e) {
                    _this.onCheckboxClick(e);
                });
                var tdW = rowW.append("td")
                    .css("width", "20px");
                //---- CHECKBOX ----
                var cbW = tdW.append("input")
                    .attr("type", "checkbox")
                    .addClass("panelCheckbox");
                //---- TEXT ----
                var textW = rowW.append("td").append("span")
                    .addClass("panelDisplay searchColKey")
                    .text(pair.key);
                tdW = rowW.append("td")
                    .css("width", "20px");
                //---- COUNT ----
                var countW = tdW.append("span")
                    .addClass("panelDisplay")
                    .addClass("searchColCounts")
                    .text(pair.count + "");
                rowW[0].checkbox = cbW[0];
                rowW[0].keyElem = textW[0];
                rowW[0].countElem = countW[0];
                rowW[0].key = pair.key;
            }
            return contentW[0];
        };
        searchNodeClass.prototype.toggleDescending = function (e) {
            this._isDescendingSort = (!this._isDescendingSort);
            //e.target.textContent = (this._isDescendingSort) ? "Descending" : "Ascending";
            this.rebuildLowerContent();
        };
        searchNodeClass.prototype.toggleSortByCount = function (e) {
            this._isSortByCount = (!this._isSortByCount);
            //e.target.textContent = (this._isSortByCount) ? "Quanity" : "A-Z";
            this.rebuildLowerContent();
        };
        searchNodeClass.prototype.onCheckboxClick = function (e) {
            var target = e.target;
            while (target && target.key === undefined) {
                target = target.parentNode;
            }
            if (target) {
                var key = target.key;
                var cbElem = target.checkbox;
                var isChecked = cbElem.checked;
                if (cbElem != e.target) {
                    //---- toggle the checkbox ----
                    isChecked = (!isChecked);
                    cbElem.checked = isChecked;
                }
                var nodeData = this._nodeData;
                var valueList = nodeData.valueList;
                if (!valueList) {
                    valueList = [];
                    nodeData.valueList = valueList;
                }
                if (isChecked) {
                    //---- ADD KEY ----
                    if (valueList.indexOf(key) == -1) {
                        valueList.push(key);
                    }
                }
                else {
                    //---- REMOVE KEY ----
                    valueList.remove(key);
                }
                this.updateRowColors(target, isChecked);
                this._nodeData.textSearchType = beachParty.TextSearchType.exactMatch;
                this._nodeData.textCaseSensitive = true;
                this.onValuesChanged();
                if (cbElem != e.target) {
                    vp.events.cancelEventBubble(e);
                    vp.events.cancelEventDefault(e);
                }
            }
        };
        searchNodeClass.prototype.onValuesChanged = function (isIncremental) {
            this.onDataChanged("values");
            this.onNodeDataChanged(true, isIncremental);
        };
        searchNodeClass.prototype.onNodeDataChanged = function (notify, isIncremental) {
            this.updateTitle();
            if (notify) {
                this.onDataChanged((isIncremental) ? "incrementalNodeData" : "nodeData");
            }
        };
        searchNodeClass.prototype.updateRowColors = function (rowElem, markAsSelected) {
            //---- update the KEY TEXT ----
            vp.select(rowElem.keyElem).attr("data-selected", (markAsSelected) ? "true" : "false");
            //---- update the COUNT TEXT ----
            vp.select(rowElem.countElem).attr("data-selected", (markAsSelected) ? "true" : "false");
        };
        searchNodeClass.prototype.buildRange = function () {
            var _this = this;
            var contentW = vp.select(document.body).append("div");
            //---- HISTOGRAM BARS ----
            var rc = vp.select(this._lowerContentElem).getBounds(false);
            var padding = new beachParty.Range(30, rc.width - 30);
            var md = new beachParty.MappingData("x", this.colName(), 9);
            this._app.currentChart().getBinData(md, function (msgBlock) {
                var binResults = msgBlock.param; // <BinResult>JSON.parse(msgBlock.param);
                var tableW = contentW.append("table")
                    .addClass("noSpaceTable")
                    .css("margin-left", padding.left + "px")
                    .css("width", (padding.right - padding.left) + "px");
                var rowW = tableW.append("tr")
                    .css("height", "100px");
                _this._barParent = rowW[0];
                var counts = binResults.bins.map(function (b) { return b.count; });
                var maxCount = counts.max();
                var minValue = 0;
                var maxValue = 0;
                for (var i = 0; i < binResults.bins.length; i++) {
                    var tdW = rowW.append("td")
                        .css("vertical-align", "bottom");
                    var bin = binResults.bins[i];
                    var percent = 100 * (bin.count / maxCount);
                    var formatter = vp.formatters.createNumFormatterFromRange(bin.min, bin.max);
                    var min = formatter(bin.min);
                    var max = formatter(bin.max);
                    var barW = tdW.append("div")
                        .addClass("searchHistoBar")
                        .css("height", percent + "px")
                        .css("vertical-align", "bottom")
                        .title(min + "-" + max + ": count=" + bin.count)
                        .attach("click", function (e) {
                        _this.onBarClick(e);
                    });
                    barW[0].bin = bin;
                    if (i == 0) {
                        minValue = bin.min;
                    }
                    else if (i == binResults.bins.length - 1) {
                        maxValue = bin.max;
                    }
                }
                //---- DOUBLE SLIDER ----
                var dsParentW = contentW.append("div")
                    .css("margin-top", "6px");
                var outer = new beachParty.Range(minValue, maxValue);
                var span = outer.right - outer.left;
                var inner = new beachParty.Range(outer.left, outer.right); // outer.left + .25 * span, outer.left + .75 * span);
                var dblSlider = new beachParty.DoubleSliderControl(dsParentW[0], outer, inner, padding);
                _this._dblSlider = dblSlider;
                dblSlider.registerForChange("inner", function (e) {
                    var newInner = dblSlider.inner();
                    _this._nodeData.min = newInner.left;
                    _this._nodeData.max = newInner.right;
                    var fromStr = vp.formatters.comma(newInner.left, 2);
                    var toStr = vp.formatters.comma(newInner.right, 2);
                    vp.select(_this._root, "#queryText")
                        .text(fromStr + "-" + toStr);
                    _this.updateBarColors();
                    _this.onNodeDataChanged(false);
                });
                //---- wait for change to complete (mouse UP event) before telling outside world ----
                dblSlider.registerForChange("innerCompleted", function (e) {
                    _this.onNodeDataChanged(true);
                });
                _this._nodeData.min = inner.left;
                _this._nodeData.max = inner.right;
                _this.updateTitle();
                _this.updateBarColors();
                //---- after content is completely built, do a quick switch ----
                var lowerContentW = vp.select(_this._lowerContentElem)
                    .clear()
                    .append(contentW[0]);
                //---- add text at bottom to reflect query ----
                dsParentW.append("div")
                    .id("queryText")
                    .addClass("plainText bgText")
                    .text("");
            });
        };
        /**
         * Set the bar colors (by setting data-selected true/false) according to the current nodeData
         min/max values;
         */
        searchNodeClass.prototype.updateBarColors = function () {
            if (this._barParent) {
                var nodeData = this._nodeData;
                var min = nodeData.min;
                var max = nodeData.max;
                var kidsW = vp.select(this._barParent).kids();
                for (var i = 0; i < kidsW.length; i++) {
                    var kid = kidsW[i];
                    var barElem = kid.firstChild;
                    var bin = barElem.bin;
                    //---- select the bar if it contains >= 50% of range ----
                    var markBar = false;
                    //--- does bin overlap with range? ----
                    if (bin.min <= max && bin.max >= min) {
                        var overlap = Math.min(bin.max, max) - Math.max(bin.min, min);
                        markBar = overlap >= (bin.max - bin.min) / 2;
                    }
                    vp.select(barElem)
                        .attr("data-selected", (markBar) ? "true" : "false");
                }
            }
        };
        searchNodeClass.prototype.onBarClick = function (e) {
            var bin = e.target.bin;
            this._dblSlider.inner(new beachParty.Range(bin.min, bin.max));
            this.onNodeDataChanged(true);
        };
        searchNodeClass.prototype.getRootElem = function () {
            return this._root;
        };
        searchNodeClass.prototype.close = function () {
            vp.select(this._root)
                .remove();
        };
        return searchNodeClass;
    }(beachParty.baseAppControlClass));
    beachParty.searchNodeClass = searchNodeClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    paletteAssembly.ts - color palette for colorPicker control.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// this is housed in a popup.
    var paletteAssemblyClass = (function (_super) {
        __extends(paletteAssemblyClass, _super);
        function paletteAssemblyClass(app, parentElem, initialValue) {
            _super.call(this);
            //super(null, ownerElem);
            this._app = app;
            this._value = initialValue;
            this.buildAssembly(parentElem);
        }
        paletteAssemblyClass.prototype.buildAssembly = function (parent) {
            var _this = this;
            vp.select(parent)
                .addClass("colorPalettePopup flexRows");
            var rootW = vp.select(parent).append("div")
                .addClass("colorPalette flexRows");
            this._root = rootW[0];
            var colors = [
                "Black", "#333", "#555", "Gray", "Silver", "White",
                "Red", "Blue", "Green", "Purple", "Orange", "Yellow",
                "Brown", "Pink", "Lime", "BeachBlue", "LightBlue", "Salmon"];
            var numRows = 3;
            var numCols = 6;
            var colorIndex = 0;
            for (var i = 0; i < numRows; i++) {
                var rowW = rootW.append("div")
                    .addClass("colorPaletteRow flexColumns");
                for (var j = 0; j < numCols; j++) {
                    var cr = colors[colorIndex++];
                    var trueColor = beachParty.cbUtils.getBeachPartyColor(cr);
                    var cellW = rowW.append("div")
                        .addClass("colorPaletteCell flexAuto")
                        .css("background", trueColor)
                        .title(cr)
                        .attach("click", function (e) {
                        _this.value(e.target.style.background);
                    });
                }
            }
        };
        paletteAssemblyClass.prototype.value = function (value, fromSlider, notifyComplete) {
            if (arguments.length == 0) {
                return this._value;
            }
            if (value != this._value || notifyComplete) {
                this._value = value;
                this.onDataChanged("value");
            }
        };
        paletteAssemblyClass.prototype.setFocusToPalette = function () {
            this._root.focus();
        };
        return paletteAssemblyClass;
    }(beachParty.dataChangerClass));
    beachParty.paletteAssemblyClass = paletteAssemblyClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    sliderAssembly.ts - panel for slider with "-" and "+" buttons.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// this is sometimes hosed in a popup and sometimes directly hosted in a panel.
    var sliderAssemblyClass = (function (_super) {
        __extends(sliderAssemblyClass, _super);
        function sliderAssemblyClass(app, parentElem, initialValue, minValue, maxValue, roundValue, spreadLow, sliderWidth, sliderClass) {
            var _this = this;
            if (sliderWidth === void 0) { sliderWidth = 120; }
            _super.call(this);
            this._onMouseMoveFunc = null;
            this._onMouseUpFunc = null;
            this._mouseDownOffset = 0;
            this._sliderWidth = 10;
            this._percentAtMouseDown = 0;
            this._autoDelayTimer = null;
            this._autoRepeatTimer = null;
            this._autoDelay = 500; // ms
            this._autoRepeat = 1000 / 25; // ms
            //super(null, ownerElem);
            this._app = app;
            this._minValue = minValue;
            this._maxValue = maxValue;
            this._roundValue = roundValue;
            this._spreadLow = spreadLow;
            this._value = initialValue;
            this._sliderWidth = sliderWidth;
            this._onMouseMoveFunc = function (e) { return _this.onMouseMove(e); };
            this._onMouseUpFunc = function (e) { return _this.onMouseUp(e); };
            this.build(parentElem, initialValue, sliderWidth, sliderClass);
        }
        sliderAssemblyClass.prototype.onMouseUp = function (e) {
            this._isDragging = false;
            vp.events.releaseCaptureWindow();
            vp.events.cancelEventDefault(e);
            this.onDataChanged("valueCompleted");
        };
        sliderAssemblyClass.prototype.onMouseMove = function (e) {
            if (this._isDragging) {
                var pt = vp.events.mousePosition(e);
                var deltaAsPixels = pt.x - this._mouseDownOffset;
                var deltaAsPercent = deltaAsPixels / this._sliderWidth;
                var newPercent = deltaAsPercent + this._percentAtMouseDown;
                newPercent = vp.data.clamp(newPercent, 0, 1);
                var value = this.denormalizeValue(newPercent);
                this.value(value);
            }
        };
        sliderAssemblyClass.prototype.value = function (value) {
            if (arguments.length == 0) {
                return this._value;
            }
            if (value != this._value) {
                this._value = value;
                this.updateThumbPosition();
                this.onDataChanged("value");
            }
        };
        sliderAssemblyClass.prototype.updateThumbPosition = function () {
            var normValue = this.normalizeValue(this._value);
            var offset = (normValue * this._sliderWidth);
            vp.utils.debug("updateThumbPosition: value=" + this._value + ", normValue=" + normValue + ", offset=" + offset);
            vp.select(this._thumbElem).css("left", offset + "px");
            //vp.utils.debug("numAdjuster.updateValueText: str=" + str);
        };
        sliderAssemblyClass.prototype.setFocusToSlider = function () {
            this._trackElem.focus();
        };
        sliderAssemblyClass.prototype.build = function (parentElem, initialValue, sliderWidth, sliderClass) {
            //---- remove any previous slider assembly from other panels/bins ----
            //vp.select(document.body, ".sliderAssembly")
            //    .remove();
            var _this = this;
            var normInitValue = this.normalizeValue(initialValue);
            //---- use flexBox for layout ----
            var rootW = vp.select(parentElem).append("div")
                .addClass("sliderAssembly flexColumns flexOtherAutoCenter")
                .css("position", "relative")
                .css("height", "20px");
            if (sliderClass) {
                rootW.addClass(sliderClass);
            }
            //---- set the popup pointer on the parent element ----
            //(<any>parentElem).jsObj = parentElem;
            //---- MINUS ----
            var minusW = rootW.append("img")
                .addClass("clickIcon tinyButton")
                .css("margin", "0 10px 0 10px")
                .css("tabIndex", "1")
                .attach("mousedown", function (e) { return _this.onButtonDown(-1); })
                .attach("mouseup", function (e) { return _this.onButtonUp(-1); })
                .attach("blur", function (e) {
                //this.onAssemblyBlur(e);
            })
                .attach("dragstart", function (e) {
                //---- prevent drag of icon ----
                e.preventDefault();
            });
            beachParty.setIconName(this._app._themeMgr, minusW[0], beachParty.fnSliderMinus, "appPanel", true);
            var progressEvent = (vp.utils.isIE) ? "change" : "input";
            var finalEvent = (vp.utils.isIE) ? "mouseup" : "change";
            //---- thumb ----
            var thumbW = rootW.append("img")
                .addClass("themeIcon circleSliderThumb")
                .css("height", "12px")
                .css("cursor", "pointer")
                .css("position", "relative")
                .css("left", "-22px")
                .attach("mousedown", function (e) {
                _this._isDragging = true;
                var pt = vp.events.mousePosition(e);
                _this._mouseDownOffset = pt.x;
                _this._percentAtMouseDown = _this.normalizeValue(_this._value);
                //---- capture mouse ----
                vp.events.setCaptureWindow(_this._onMouseMoveFunc, _this._onMouseUpFunc);
            })
                .attach("dragstart", function (e) {
                //---- prevent drag of icon ----
                e.preventDefault();
            });
            beachParty.setIconName(this._app._themeMgr, thumbW[0], beachParty.fnSliderCircle, "appPanel", true);
            //---- track ----
            var trackW = rootW.append("div")
                .addClass("circleSliderTrack")
                .css("height", "2px")
                .css("width", sliderWidth + "px");
            //---- PLUS ----
            var plusW = rootW.append("img")
                .addClass("clickIcon tinyButton")
                .css("tabIndex", "3")
                .css("margin", "0 10px 0 10px")
                .attach("mousedown", function (e) { return _this.onButtonDown(1); })
                .attach("mouseup", function (e) { return _this.onButtonUp(1); })
                .attach("blur", function (e) {
                //this.onAssemblyBlur(e);
            })
                .attach("dragstart", function (e) {
                //---- prevent drag of icon ----
                e.preventDefault();
            });
            beachParty.setIconName(this._app._themeMgr, plusW[0], beachParty.fnSliderPlus, "appPanel", true);
            this._trackElem = trackW[0];
            this._thumbElem = thumbW[0];
            this._minusElem = minusW[0];
            this._plusElem = plusW[0];
            this._value = initialValue;
            this.updateThumbPosition();
        };
        sliderAssemblyClass.prototype.onButtonDown = function (delta) {
            var _this = this;
            this.onUpDown(delta, false);
            this.stopTimers();
            this._autoDelayTimer = setTimeout(function (e) {
                _this.stopTimers();
                _this._autoRepeatTimer = setInterval(function (e) {
                    _this.onUpDown(delta, false);
                }, _this._autoRepeat);
            }, this._autoDelay);
        };
        sliderAssemblyClass.prototype.stopTimers = function () {
            if (this._autoDelayTimer) {
                clearTimeout(this._autoDelayTimer);
                this._autoDelayTimer = null;
            }
            if (this._autoRepeatTimer) {
                clearInterval(this._autoRepeatTimer);
                this._autoRepeatTimer = null;
            }
        };
        sliderAssemblyClass.prototype.onButtonUp = function (delta) {
            this.stopTimers();
            this.onUpDown(0, true);
        };
        sliderAssemblyClass.prototype.onUpDown = function (delta, notifyComplete) {
            var changed = false;
            var factor = (this._roundValue) ? 1 : ((this._maxValue - this._minValue) / 100);
            var diffValue = delta * factor;
            if (diffValue >= 0) {
                var newValue = this._value + diffValue;
                if (newValue <= this._maxValue) {
                    this.value(newValue);
                    this.onDataChanged("valueCompleted");
                    changed = true;
                }
            }
            else {
                var newValue = this._value + diffValue;
                if (newValue >= this._minValue) {
                    this.value(newValue);
                    this.onDataChanged("valueCompleted");
                    changed = true;
                }
            }
            return changed;
        };
        sliderAssemblyClass.prototype.normalizeValue = function (value) {
            value = vp.data.clamp(value, this._minValue, this._maxValue);
            if (this._roundValue) {
                value = Math.round(value);
            }
            value = vp.data.mapValue(value, this._minValue, this._maxValue, 0, 1);
            if (this._spreadLow) {
                var range = this._maxValue - this._minValue;
                var goodRange = (range < 10) ? 10 * range : range;
                var maxExponent = Math.log(goodRange) / Math.log(2); // take log base 2 of percent
                //---- reverse of steps in denormalize() ----
                value = vp.data.mapValue(value, 0, 1, 2, goodRange);
                value = Math.log2(value);
                value = vp.data.mapValue(value, 1, maxExponent, 0, 1);
            }
            return value;
        };
        sliderAssemblyClass.prototype.denormalizeValue = function (value) {
            //var result = vp.data.mapValue(value, 0, 1, this._minValue, this._maxValue);
            var percent = value;
            var range = this._maxValue - this._minValue;
            if (this._spreadLow) {
                var goodRange = (range < 10) ? 10 * range : range;
                var maxExponent = Math.log(goodRange) / Math.log(2); // take log base 2 of percent
                var exponent = vp.data.mapValue(percent, 0, 1, 1, maxExponent);
                var result = Math.pow(2, exponent);
                percent = vp.data.mapValue(result, 2, goodRange, 0, 1);
            }
            var value = this._minValue + percent * range;
            if (this._roundValue) {
                value = Math.round(value);
            }
            value = vp.data.clamp(value, this._minValue, this._maxValue);
            return value;
        };
        return sliderAssemblyClass;
    }(beachParty.dataChangerClass));
    beachParty.sliderAssemblyClass = sliderAssemblyClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    botPanelMgr.ts - manages the Bot panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var botPanelMgrClass = (function (_super) {
        __extends(botPanelMgrClass, _super);
        function botPanelMgrClass(app, buttonId) {
            var _this = this;
            _super.call(this);
            this._app = this._app;
            this._botChat = new beachParty.botChatClass(app, this);
            this._suggestions = [];
            this._history = [];
            var jsonPanel = beachParty.buildJsonPanel(app, buttonId, this, "botPanel", true, undefined, undefined, undefined, undefined, undefined, undefined, undefined, "botButton");
            this._jsonPanel = jsonPanel;
            jsonPanel.registerForRemovableChange("close", this, function (e) {
                _this.onDataChanged("close");
            });
            jsonPanel.showTitle(true);
            this._chatResponse = "";
            this._chatInput = "";
            jsonPanel.isFloating(true);
            //---- force creation of all 3 tab pages so we can manipulate content (now and later) ----
            jsonPanel.forceTabBuild(1);
            jsonPanel.forceTabBuild(2);
            //---- add div to hold suggestions ----
            var tabRoot = jsonPanel.getTabContentRoot("tab0");
            var divW = vp.select(tabRoot).append("div")
                .addClass("suggestionList")
                .css("overflow-x", "hidden")
                .css("overflow-y", "auto")
                .css("margin-top", "-13px");
            this._suggestionDiv = divW[0];
            //---- add div to hold history ----
            var tabRoot = jsonPanel.getTabContentRoot("tab2");
            var divW = vp.select(tabRoot).append("div")
                .addClass("historyList")
                .css("overflow-x", "hidden")
                .css("overflow-y", "auto")
                .css("margin-top", "-13px");
            this._historyDiv = divW[0];
            this.addSuggestion("Take build53 tour");
            this.addSuggestion("map color to age");
            this.addSuggestion("clear color mapping");
        }
        botPanelMgrClass.prototype.addSuggestion = function (text) {
            this._suggestions.insert(0, text);
            this.rebuildSuggestionsList();
        };
        botPanelMgrClass.prototype.addToHistory = function (text) {
            this._history.push(text);
            this.rebuildHistory();
        };
        botPanelMgrClass.prototype.rebuildSuggestionsList = function () {
            var _this = this;
            var divW = vp.select(this._suggestionDiv)
                .clear();
            for (var i = 0; i < this._suggestions.length; i++) {
                var text = this._suggestions[i];
                var anchorW = divW.append("div")
                    .text(text)
                    .addClass("panelLink suggestionItem")
                    .attach("click", function (e) { return _this.onSuggestion(e); });
            }
        };
        botPanelMgrClass.prototype.rebuildHistory = function () {
            var _this = this;
            var divW = vp.select(this._historyDiv)
                .clear();
            for (var i = 0; i < this._history.length; i++) {
                var text = this._history[i];
                var anchorW = divW.append("div")
                    .text(text)
                    .addClass("panelLink suggestionItem")
                    .attach("click", function (e) { return _this.onSuggestion(e, true); });
            }
        };
        botPanelMgrClass.prototype.onSuggestion = function (e, isFromHistory) {
            var text = e.target.innerText;
            //this.chatInput(text);
            this._botChat.parseChatInput(text);
            ////---- remove the suggestion we just ran ----
            //this._suggestions.remove(text);
            //this.rebuildSuggestionsList();
            this.addToHistory(text);
        };
        botPanelMgrClass.prototype.chatResponse = function (value) {
            if (arguments.length == 0) {
                return this._chatResponse;
            }
            this._chatResponse = value;
            this.onDataChanged("chatResponse");
        };
        botPanelMgrClass.prototype.chatInput = function (value) {
            if (arguments.length == 0) {
                return this._chatInput;
            }
            this._chatInput = value;
            vp.utils.debug("botMgr.chatInput: value set=" + value);
            this.onDataChanged("chatInput");
            if (value) {
                this._botChat.parseChatInput(value);
            }
        };
        botPanelMgrClass.prototype.setFocusToTextbox = function () {
            var elemW = vp.select(this._jsonPanel.getRootElem(), "#tbChatInput");
            elemW[0].focus();
        };
        botPanelMgrClass.prototype.setInputText = function (text) {
            //---- insert cmd into textbox ----
            var elemW = vp.select(this._jsonPanel.getRootElem(), "#tbChatInput");
            //vp.utils.debug("setInputText: before=" + elemW.value());
            elemW.value(text);
            //vp.utils.debug("setInputText: after=" + elemW.value());
        };
        return botPanelMgrClass;
    }(beachParty.baseJsonControlClass));
    beachParty.botPanelMgrClass = botPanelMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    layersMgr.ts - manages the layers panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var layersMgrClass = (function (_super) {
        __extends(layersMgrClass, _super);
        function layersMgrClass(app, currentChart, textMgr, lineMgr) {
            _super.call(this);
            this._app = app;
            this._currentChart = currentChart;
            this._textMgr = textMgr;
            this._lineMgr = lineMgr;
            this._showShapes = true;
            this._showText = false;
            this._showLines = false;
            this._showOverlays = false;
            this._showMaps = false;
        }
        layersMgrClass.prototype.showShapes = function (value, omitLogging) {
            if (arguments.length == 0) {
                return this._showShapes;
            }
            this._showShapes = value;
            if (!omitLogging) {
                this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.layersPanel, true, { showShapes: value });
            }
            this.onDataChanged("showShapes");
        };
        layersMgrClass.prototype.showText = function (value, omitLogging) {
            if (arguments.length == 0) {
                return this._showText;
            }
            this._showText = value;
            if (!omitLogging) {
                this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.layersPanel, true, { showText: value });
            }
            this.onDataChanged("showText");
        };
        layersMgrClass.prototype.showLines = function (value, omitLogging) {
            if (arguments.length == 0) {
                return this._showLines;
            }
            this._showLines = value;
            if (!omitLogging) {
                this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.layersPanel, true, { showLines: value });
            }
            this.onDataChanged("showLines");
        };
        layersMgrClass.prototype.showOverlays = function (value, omitLogging) {
            if (arguments.length == 0) {
                return this._showOverlays;
            }
            this._showOverlays = value;
            if (!omitLogging) {
                this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.layersPanel, true, { showOverlays: value });
            }
            this.onDataChanged("showOverlays");
        };
        layersMgrClass.prototype.showMaps = function (value, omitLogging) {
            if (arguments.length == 0) {
                return this._showMaps;
            }
            this._showMaps = value;
            if (!omitLogging) {
                this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.layersPanel, true, { showMaps: value });
            }
            this.onDataChanged("showMaps");
        };
        return layersMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.layersMgrClass = layersMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    bigBarMgr.ts - builds and manages the bigBar panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var bigBarMgrClass = (function (_super) {
        __extends(bigBarMgrClass, _super);
        function bigBarMgrClass(app, panelMgr, chartRouter) {
            _super.call(this);
            this._isVertical = false;
            this._bigBarLoc = "top";
            this._doubleEntryMode = false; // when true, add 2 entries side by side in vertical bar
            this._lastElemIsDivider = false;
            this._app = app;
            this._panelMaster = panelMgr;
            this._chartRouter = chartRouter;
            var themeMgr = this._app._themeMgr;
            var theme = themeMgr.getTheme();
            //this._bigBarLoc = theme.propMap.bigBarLoc;
            this._useBigGroups = theme.propMap.groupBigButton;
            //this._dividerHeight = theme.propMap.bigBarDividerHeight;
            this._isVertical = (this._bigBarLoc == "left" || this._bigBarLoc == "right");
            this.buildButtonsTable();
        }
        bigBarMgrClass.prototype.buildButtonsTable = function () {
            this._bigButtonsTable = [
                { name: "ViewAs", btName: "bbView", prompt: "View as", tip: "Select a chart type for viewing the data", cb: "toggleViewAsPanel", newGroup: false },
                { name: "FacetBy", btName: "bbFacet", prompt: "Facet by", tip: "Create multiple charts based on a column", cb: "toggleFacetPanel" },
                { name: "Layers", btName: "bbLayers", prompt: "Layers", tip: "Control the various layers of the chart (like Text, Line, Shape, ...)", cb: "toggleLayersPanel" },
                { name: "SortBy", btName: "bbSort", prompt: "Sort by", tip: "Control the layout order of the shapes", cb: "toggleSortPanel" },
                //{ name: "Wheel", btName: "bbWheel", prompt: "Wheel", tip: "Show or hide the 3D navigation wheel", cb: "toggleWheelMode"  },
                { name: "XAxis", btName: "bbX", prompt: "X", tip: "Specify the column mapped to the X axis", cb: "toggleXPanel", newGroup: true },
                { name: "YAxis", btName: "bbY", prompt: "Y", tip: "Specify the column mapped to the Y axis", cb: "toggleYPanel" },
                { name: "ZAxis", btName: "bbZ", prompt: "Z", tip: "Specify the column mapped to the Z axis", cb: "toggleZPanel" },
                { name: "SumBy", btName: "bbSum", prompt: "Sum by", tip: "Specify the column used for Summing", cb: "toggleSumPanel" },
                { name: "ColorBy", btName: "bbColor", prompt: "Color by", tip: "Specify the column that defines the shape colors", cb: "toggleColorPanel", newGroup: true },
                { name: "SizeBy", btName: "bbSize", prompt: "Size by", tip: "Specify the column that defines shape sizes", cb: "toggleSizePanel" },
                { name: "ShapeBy", btName: "bbShape", prompt: "Shape by", tip: "Specify the column that defines the shape shapes", cb: "toggleShapePanel" },
                { name: "ImageBy", btName: "bbImage", prompt: "Image by", tip: "Specify the column that defines the shape images", cb: "toggleImagePanel" },
                { name: "Dataset", btName: "bbData", prompt: "Data", tip: "Open a new data set", cb: "toggleDataPanel", newGroup: true },
                { name: "Items", btName: "bbItems", prompt: "Items", tip: "Displays the number of items in the dataset", cb: "toggleItemsPanel" },
                { name: "Time", btName: "bbTime", prompt: "Time by", tip: "Open the Time panel", cb: "toggleTimePanel", newGroup: true },
                { name: "Filtered", btName: "bbFiltered", prompt: "Filtered", tip: "Reset the filter", cb: "toggleFilterPanel" },
                { name: "Selected", btName: "bbSelected", prompt: "Selected", tip: "Reset the selection", cb: "toggleSelectionPanel" },
            ];
        };
        bigBarMgrClass.prototype.appendRow = function () {
            var trW = vp.select(this._tableElem)
                .append("tr");
            return trW;
        };
        bigBarMgrClass.prototype.buildButtonsFromTable = function () {
            var settings = this._app._appSettingsMgr;
            var includeIconButtons = settings.isIconButtonsOnBigBar();
            var app = this._app;
            var settings = app._appSettingsMgr;
            var localeMgr = app._localeMgr;
            var bigButtons = this._bigButtonsTable;
            var themeMgr = app._themeMgr;
            /// NOTE: we add all buttons and then hide those not enabled in markBigBarBuildNeeded(). 
            var isVerticalLayout = this._isVertical;
            this._doubleEntryMode = false;
            this._lastElemIsDivider = false;
            var rootName = this.getRootName();
            var rootW = vp.select("#" + rootName)
                .clear();
            //---- BIG BAR element ----
            var holderW = rootW.append("div")
                .id("bigBar")
                .addClass("flexColumns flexWrap")
                .css("align-items", "center")
                .css("margin", "-1px 0 -1px 0")
                .css("overflow-y", "visible");
            //.css("height", "37px")
            var bigBarElem = holderW[0];
            var toolbar = new beachParty.toolbarClass(app, bigBarElem, [this, app]);
            toolbar.startBuild();
            var needNewGroup = false;
            //---- add each button in the table to the big bar ----
            for (var i = 0; i < bigButtons.length; i++) {
                var button = bigButtons[i];
                if (button.newGroup) {
                    needNewGroup = true;
                }
                if (settings.isButtonEnabled(button.name)) {
                    var nativePrompt = button.prompt;
                    var prompt = button.prompt;
                    var tip = button.tip;
                    if (nativePrompt == "Time by" && !settings.showInProgressUI()) {
                        continue;
                    }
                    if (nativePrompt == "Image by" && !settings.showInProgressUI()) {
                        continue;
                    }
                    if (nativePrompt == "Layers" && !settings.showInProgressUI()) {
                        continue;
                    }
                    //---- use localized strings ----
                    var textInfo = localeMgr.getText("BigBar." + nativePrompt);
                    if (textInfo && textInfo.length == 2) {
                        prompt = textInfo[0];
                        tip = textInfo[1];
                    }
                    if (needNewGroup && themeMgr._newTheme.propMap.groupBigButton) {
                        //---- SPACER ----
                        //trW = this.addBigBarSpacer(trW);
                        toolbar.addBigSpacer();
                        needNewGroup = false;
                    }
                    var newButton = vp.utils.copyMap(button);
                    newButton.prompt = prompt;
                    newButton.tip = tip;
                    toolbar.addBigButton(newButton);
                }
            }
            this._app.setBigValue("Layers", "Shapes", "The layer(s) currently being displayed");
            if (includeIconButtons) {
                this.addIconButtons(toolbar); //trW);
            }
        };
        bigBarMgrClass.prototype.buildBigBar = function () {
            this.buildButtonsFromTable();
        };
        bigBarMgrClass.prototype.addIconButtons = function (toolbar) {
            var app = this._app;
            //---- start adding entries side-by-side ----
            this._doubleEntryMode = true;
            var iconButtons = this._app._iconBarMgr.getButtonTable();
            var needSpacer = false; // spacer between last big button and first icon button
            var isFirstIconButton = true;
            this._lastElemIsDivider = false;
            for (var i = 0; i < iconButtons.length; i++) {
                var iconButton = iconButtons[i];
                var anyIb = iconButton;
                if (anyIb.groupId) {
                    needSpacer = true;
                }
                var settings = this._app._appSettingsMgr;
                if (settings.isButtonEnabled(iconButton.set)) {
                    if (needSpacer) {
                        //toolbar.addBigSpacer();
                        toolbar.addIconSpacer();
                        needSpacer = false;
                    }
                    var elem = toolbar.addIconButton(iconButton);
                    if (isFirstIconButton) {
                        //---- add a small space between big and small buttons ----
                        vp.select(elem).css("margin-left", "5px");
                        isFirstIconButton = false;
                    }
                    this._lastElemIsDivider = false;
                }
            }
        };
        bigBarMgrClass.prototype.getRootName = function () {
            var rootName = "bigBarTop";
            if (this._bigBarLoc == "left") {
                rootName = "bigBarLeft";
            }
            else if (this._bigBarLoc == "right") {
                rootName = "bigBarRight";
            }
            return rootName;
        };
        bigBarMgrClass.prototype.show = function (value) {
            var display = (value) ? "" : "none";
            var rootName = this.getRootName();
            vp.select("#" + rootName)
                .css("display", display)
                .css("visibility", "");
            this._app.layoutScreen("bigBar.show");
        };
        bigBarMgrClass.prototype.hideInPlace = function () {
            var rootName = this.getRootName();
            vp.select("#" + rootName)
                .css("visibility", "hidden");
        };
        bigBarMgrClass.prototype.getLoc = function () {
            return this._bigBarLoc;
        };
        bigBarMgrClass.prototype.toggleDataPanel = function (e, isFromLegend) {
            this._app._fileOpenMgr.toggleDatasetPanel(e, isFromLegend);
        };
        //---- this toggles the Items panel ----
        bigBarMgrClass.prototype.toggleItemsPanel = function (e, isFromLegend) {
            //this._panelMaster.togglePanel("itemsPanel", e);
        };
        bigBarMgrClass.prototype.toggleFilterPanel = function (e) {
            if (this._app._appSettingsMgr.showInProgressUI()) {
                this._panelMaster.togglePanel("filterPanel", e);
            }
            else {
                this.onFilteredInCountClick(e);
            }
        };
        bigBarMgrClass.prototype.onFilteredInCountClick = function (e) {
            this._app.currentChart().resetFilter();
            this._app.logAction(beachParty.Gesture.click, e.target.id, beachParty.ElementType.button, beachParty.Action.clear, beachParty.Target.filterAndSelection, true);
        };
        bigBarMgrClass.prototype.toggleSelectionPanel = function (e) {
            if (this._app._appSettingsMgr.showInProgressUI()) {
                this._panelMaster.togglePanel("selectionPanel", e);
            }
            else {
                this.onSelectedCountClick(e);
            }
        };
        bigBarMgrClass.prototype.onSelectedCountClick = function (e) {
            this._app.currentChart().clearSelection();
            this._app.logAction(beachParty.Gesture.click, e.target.id, beachParty.ElementType.button, beachParty.Action.clear, beachParty.Target.selection, true);
        };
        bigBarMgrClass.prototype.toggleViewAsPanel = function (e) {
            this._panelMaster.togglePanel("viewAsPanel", e);
        };
        bigBarMgrClass.prototype.onChartPicked = function (uiName) {
            var isCustom = false;
            var chart = this._app.currentChart();
            if (uiName == "Custom") {
                var settings = this._app._appSettingsMgr;
                uiName = settings.predefinedCustomChart();
                //var result = chart.getCorrectChartAndLayout(chartName, null);
                isCustom = true;
                this.openChartPanel(true, true);
            }
            var layoutType = beachParty.LayoutType.Default;
            var chartType = beachParty.chartClass.getChartTypeFromName(uiName, layoutType);
            chart.changeToChart(chartType, layoutType, beachParty.Gesture.click, uiName, isCustom);
            this._app.logAction(beachParty.Gesture.select, null, beachParty.ElementType.picklist, beachParty.Action.adjust, beachParty.Target.chartType, true, { name: beachParty.ChartType[chartType] });
        };
        bigBarMgrClass.prototype.toggleXPanel = function (e, isFromLegend) {
            var chart = this._app.currentChart();
            var chartName = chart.chartName();
            var align = (isFromLegend) ? beachParty.ButtonAlign.aboveButton : beachParty.ButtonAlign.belowButton;
            //---- if we are using X as a count or sum (Bar view), show the "sum" picker ----
            var isCountOrSum = chart.isCountOrSumOrGrid("x");
            var panelName = (isCountOrSum) ? "sumPanel" : "xPanel";
            this._panelMaster.togglePanel(panelName, e, align, isFromLegend);
            //this._panelMaster.togglePanel("xPanel", e, align, isFromLegend);
        };
        bigBarMgrClass.prototype.toggleYPanel = function (e, isFromLegend) {
            var chart = this._app.currentChart();
            var chartName = chart.chartName();
            //---- if we are using Y as a count or sum (Column or Grid view), show the "sum" picker ----
            var align = (isFromLegend) ? beachParty.ButtonAlign.rightOfButton : beachParty.ButtonAlign.belowButton;
            var isCountOrSum = chart.isCountOrSumOrGrid("y");
            var panelName = (isCountOrSum) ? "sumPanel" : "yPanel";
            this._panelMaster.togglePanel(panelName, e, align, isFromLegend);
        };
        bigBarMgrClass.prototype.toggleZPanel = function (e, isFromLegend) {
            var align = (isFromLegend) ? beachParty.ButtonAlign.aboveButton : beachParty.ButtonAlign.belowButton;
            this._panelMaster.togglePanel("zPanel", e, align, isFromLegend);
        };
        bigBarMgrClass.prototype.toggleFacetPanel = function (e) {
            this._panelMaster.togglePanel("facetPanel", e, beachParty.ButtonAlign.belowButton);
        };
        bigBarMgrClass.prototype.togglImagePanel = function (e) {
            this._panelMaster.togglePanel("imagePanel", e, beachParty.ButtonAlign.belowButton);
        };
        bigBarMgrClass.prototype.toggleColorPanel = function (e, isFromLegend) {
            var align = (isFromLegend) ? beachParty.ButtonAlign.leftOfButton : beachParty.ButtonAlign.belowButton;
            this._panelMaster.togglePanel("colorPanel", e, align, isFromLegend);
        };
        /** Show color panel. */
        bigBarMgrClass.prototype.onColorPanelOpened = function (panel, isFromLegend) {
            //---- hide "Channels" tab if option is not enabled ----
            var settings = this._app._appSettingsMgr;
            if (!settings.mapByColorChannels()) {
                panel.showTab("tab2", false);
            }
            vp.select(panel.getRootElem())
                .css("overflow-x", "hidden")
                .css("overflow-y", "hidden"); // list already does needed scrolling
        };
        bigBarMgrClass.prototype.toggleSizePanel = function (e, isFromLegend) {
            var align = (isFromLegend) ? beachParty.ButtonAlign.leftOfButton : beachParty.ButtonAlign.belowButton;
            this._panelMaster.togglePanel("sizePanel", e, align, isFromLegend);
        };
        bigBarMgrClass.prototype.toggleSumPanel = function (e) {
            this._panelMaster.togglePanel("sumPanel", e, beachParty.ButtonAlign.belowButton);
        };
        bigBarMgrClass.prototype.toggleTextPanel = function (e, isFromLegend) {
            var align = (isFromLegend) ? beachParty.ButtonAlign.leftOfButton : beachParty.ButtonAlign.belowButton;
            this._panelMaster.togglePanel("textPanel", e, align, isFromLegend);
        };
        bigBarMgrClass.prototype.toggleImagePanel = function (e, isFromLegend) {
            var align = (isFromLegend) ? beachParty.ButtonAlign.leftOfButton : beachParty.ButtonAlign.belowButton;
            this._panelMaster.togglePanel("imagePanel", e, align, isFromLegend);
        };
        bigBarMgrClass.prototype.onLineClick = function (e, isFromLegend) {
            var align = (isFromLegend) ? beachParty.ButtonAlign.leftOfButton : beachParty.ButtonAlign.belowButton;
            this._panelMaster.togglePanel("lineByPanel", e, align, isFromLegend);
        };
        bigBarMgrClass.prototype.toggleShapePanel = function (e, isFromLegend) {
            var align = (isFromLegend) ? beachParty.ButtonAlign.leftOfButton : beachParty.ButtonAlign.belowButton;
            this._panelMaster.togglePanel("shapePanel", e, align, isFromLegend);
        };
        bigBarMgrClass.prototype.toggleSortPanel = function (e) {
            this._panelMaster.togglePanel("sortPanel", e, beachParty.ButtonAlign.belowButton);
        };
        bigBarMgrClass.prototype.toggleTimePanel = function (e) {
            this._panelMaster.togglePanel("timePanel", e);
        };
        bigBarMgrClass.prototype.toggleLayersPanel = function (e) {
            this._panelMaster.togglePanel("layersPanel", e);
        };
        bigBarMgrClass.prototype.openChartPanel = function (forCustom, onRight) {
            var cop = this._panelMaster.showPanel("viewAsPanel");
            //cop.isFloating(true);
            if (forCustom) {
                cop.openCustomTab();
            }
        };
        return bigBarMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.bigBarMgrClass = bigBarMgrClass;
})(beachParty || (beachParty = {}));
///-----------------------------------------------------------------------------------------------------------------
/// bigDataMgr.ts.  Copyright (c) 2016 Microsoft Corporation.
///     - maintains the all/sample/aggregation state on the client and sends new "loadData" requests to the
///       the engine as appropriate.
///-----------------------------------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// Note: dataFrame does NOT change the original data, but it cache numeric vectors on-demand for each column. 
    var bigDataMgrClass = (function (_super) {
        __extends(bigDataMgrClass, _super);
        function bigDataMgrClass(app) {
            var _this = this;
            _super.call(this);
            this._itemViewType = ItemViewType.allUnits;
            //---- sampling ----
            this._isSampEnabled = false;
            this._sampType = beachParty.SampleType.first;
            this._sampleCount = 0;
            //---- aggregation ----
            this._aggType = beachParty.AggType.count;
            this._aggFilters = [];
            this._isAggChart = false;
            this._isResetting = false;
            this._app = app;
            app._xMgr.registerForChange("mappingData", function (e) { return _this.updateAggData(); });
            app._yMgr.registerForChange("mappingData", function (e) { return _this.updateAggData(); });
            app._colorMgr.registerForChange("mappingData", function (e) { return _this.updateAggData(); });
            app.registerForChange("chart", function (e) { return _this.processChartChange(); });
            app.registerForChange("fileName", function (e) { return _this.processDataSetChange(); });
            app.registerForChange("resetButton", function (e) { return _this.processResetPressed(); });
            app.registerForChange("excludeButton", function (e) { return _this.processExcludePressed(); });
            app.registerForChange("isolateButton", function (e) { return _this.processIsolatePressed(); });
            this.reset();
        }
        bigDataMgrClass.prototype.processDataSetChange = function () {
            this.reset();
        };
        bigDataMgrClass.prototype.isSampEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isSampEnabled;
            }
            this._isSampEnabled = value;
            this.onDataChanged("isSampEnabled");
        };
        bigDataMgrClass.prototype.sampType = function (value) {
            if (arguments.length == 0) {
                return beachParty.SampleType[this._sampType];
            }
            this._sampType = beachParty.SampleType[value];
            this.onDataChanged("sampType");
        };
        bigDataMgrClass.prototype.aggType = function (value) {
            if (arguments.length == 0) {
                return beachParty.AggType[this._aggType];
            }
            this._aggType = beachParty.AggType[value];
            this.onDataChanged("aggType");
            this.requestNewData();
        };
        bigDataMgrClass.prototype.sampleCount = function (value) {
            if (arguments.length == 0) {
                return this._sampleCount;
            }
            this._sampleCount = value;
            this.onDataChanged("sampleCount");
        };
        bigDataMgrClass.prototype.itemViewType = function (value) {
            if (arguments.length == 0) {
                return ItemViewType[this._itemViewType];
            }
            this._itemViewType = ItemViewType[value];
            this.onDataChanged("itemViewType");
            this.requestNewData();
        };
        bigDataMgrClass.prototype.reset = function () {
            var app = this._app;
            this._isResetting = true;
            try {
                //this._trueRecordCount = app._trueRecordCount;
                //this._serverFilteredRecordCount = app._trueRecordCount;
                //---- SAMPLING ----
                var settings = this._app._appSettingsMgr;
                if (settings.isAutoSamplingEnabled()) {
                    this.sampleCount(settings.autoSamplingSampleCount());
                    this.sampType(settings.autoSamplingSampleType());
                    this.itemViewType("sampling");
                }
                else {
                    //---- give sampling some reasonable defaults ---
                    this.sampleCount(1000);
                    this.sampType("first");
                    this.itemViewType("allUnits");
                }
                //---- AGGREGATION ----
                this.aggType("count");
                this._aggFilters = [];
            }
            finally {
                this._isResetting = false;
            }
        };
        bigDataMgrClass.prototype.processResetPressed = function () {
            if (this._isAggChart) {
                this._aggFilters = [];
                this.requestNewData();
            }
        };
        bigDataMgrClass.prototype.addToFilter = function (colName, colValues, isMember) {
            var af = new beachParty.AggFilter(colName, isMember, colValues);
            this._aggFilters.push(af);
        };
        bigDataMgrClass.prototype.trueRecordCount = function () {
            if (arguments.length == 0) {
                var trueRecordCount = this._app._trueRecordCount;
                return vp.formatters.comma(trueRecordCount);
            }
        };
        bigDataMgrClass.prototype.serverFilteredRecordCount = function () {
            if (arguments.length == 0) {
                var count = this._app._aggFilteredRecordCount;
                return vp.formatters.comma(count);
            }
        };
        bigDataMgrClass.prototype.processIsolatePressed = function () {
            var _this = this;
            if (this._isAggChart) {
                var app = this._app;
                //var xCol = app.xColumn();
                var xCol = app._xMgr.colName();
                //---- get selected records ----
                var dataMgr = app.currentChart().getDataMgr();
                dataMgr.getSelectedRowsMultiCol([xCol], false, function (data) {
                    //---- add to agg filter[] ----
                    var xColValues = data[xCol];
                    _this.addToFilter(xCol, xColValues, true);
                    //---- finally, request new data ----
                    _this.requestNewData();
                });
            }
        };
        bigDataMgrClass.prototype.processExcludePressed = function () {
            var _this = this;
            if (this._isAggChart) {
                var app = this._app;
                //var xCol = app.xColumn();
                var xCol = app._xMgr.colName();
                //---- get selected records ----
                var dataMgr = app.currentChart().getDataMgr();
                dataMgr.getSelectedRowsMultiCol([xCol], false, function (data) {
                    //---- add to agg filter[] ----
                    var xColValues = data[xCol];
                    _this.addToFilter(xCol, xColValues, false);
                    //---- finally, request new data ----
                    _this.requestNewData();
                });
            }
        };
        bigDataMgrClass.prototype.canViewDirect = function () {
            var trueRecordCount = this._app._trueRecordCount;
            var aggFilteredRecordCount = this._app._aggFilteredRecordCount;
            var direct = true;
            var settings = this._app._appSettingsMgr;
            var maxDirect = (settings.isAutoSamplingEnabled()) ? settings._autoSampling.samplingThreshold : 100000;
            if (aggFilteredRecordCount > maxDirect) {
                direct = false;
            }
            return direct;
        };
        bigDataMgrClass.prototype.processChartChange = function () {
            var chart = this._app.currentChart();
            var chartName = chart.getUiChartName();
            if (chartName != chart.chartName()) {
                this._chartName = chartName;
                var isAgg = (chartName.toLowerCase().startsWith("agg"));
                this._isAggChart = isAgg;
                if (isAgg) {
                    this.itemViewType("aggregation");
                }
                else if (this._itemViewType == ItemViewType.aggregation) {
                    if (this.canViewDirect()) {
                        this.itemViewType("allUnits");
                    }
                    else {
                        this.itemViewType("sampling");
                    }
                }
            }
        };
        bigDataMgrClass.prototype.updateAggData = function () {
            if (this._isAggChart) {
                //---- its an aggregated chart ----
                this.requestNewData();
            }
        };
        bigDataMgrClass.prototype.requestNewData = function () {
            /// use: 
            ///     - x, y, color column mappings
            ///     - this._itemViewType
            ///     - this._aggFilter
            if (!this._isResetting) {
                var app = this._app;
                var chart = app._chartRouter.getChart();
                var preload = chart.getPreload();
                if (preload) {
                    preload.dataSampling = null;
                    preload.dataAggregation = null;
                    if (this._itemViewType == ItemViewType.aggregation) {
                        //---- process AGGREGATION ----
                        var groupCols = [];
                        //var xCol = app.xColumn();
                        var xCol = app._xMgr.colName();
                        var yCol = app._yMgr.colName();
                        var sumCol = app._sizeMgr.colName();
                        var aggCol = yCol; //(this._isAggChart) ? yCol : sumCol;
                        var colorCol = app.colorColumn();
                        groupCols.push(xCol);
                        if (colorCol) {
                            groupCols.push(colorCol);
                        }
                        var agg = new beachParty.DataAggregation(this._aggType, aggCol, groupCols);
                        preload.dataAggregation = agg;
                        preload.dataChangeType = beachParty.DataChangeType.sampleResults;
                    }
                    else if (this._itemViewType == ItemViewType.sampling) {
                        //---- process SAMPLING ----
                        var samp = new beachParty.DataSampling(true, this._sampType, this._sampleCount, 1);
                        preload.dataSampling = samp;
                        preload.dataChangeType = beachParty.DataChangeType.queryResults;
                    }
                    var dataMgr = this._app.getChartDataMgr();
                    dataMgr.autoloadFile(preload);
                }
            }
        };
        return bigDataMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.bigDataMgrClass = bigDataMgrClass;
    (function (ItemViewType) {
        ItemViewType[ItemViewType["allUnits"] = 0] = "allUnits";
        ItemViewType[ItemViewType["sampling"] = 1] = "sampling";
        ItemViewType[ItemViewType["aggregation"] = 2] = "aggregation";
    })(beachParty.ItemViewType || (beachParty.ItemViewType = {}));
    var ItemViewType = beachParty.ItemViewType;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    botChat.ts - translate bot chat input into commands or return information.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// BeachParty language is centered on the following (approx 30) varbs:
    ///
    /// set/clear/?    (set includes "random" for selected properties, as random choice)
    ///     shape color
    ///     shape color palette (to <name> or <color array>)
    ///     shape opacity
    ///     shape size factor
    ///     random seed
    ///     columns  (?columns)
    ///     view (current chart name)
    ///     <attribute> bins  <number or auto>
    ///     color reverse
    ///     color inverted
    ///     color continuous
    ///     color cycling
    ///     color spread
    ///     <attribute> force category
    ///     column type count|percent|sum by
    ///     bar type count|percent|sum by
    ///
    /// sort by <column> | <attribute> [ascending/descending]
    ///
    /// show/hide/?  
    ///         <panel name> [pinned | unpinned]
    ///         <button bars>
    ///         insight panel    /// sum by <column>/clear sum by/? sum by
    ///     
    /// select <target> [only|toggle|add|subtract|intersect]
    ///     <value from legend or facet entry>
    ///     tick box first|last|<1-N>|second|third|...|twelveth
    /// 
    /// search
    ///     value
    ///     <expression> value
    ///
    /// isolate 
    /// exclude
    /// undo
    /// redo
    /// map <column> to <attribute>/clear <attribute> mapping/?<attribute> mapping
    /// remap (color | percent)
    /// reset [selection / filter]
    ///
    /// add insight <name>
    /// publish insights
    /// load insight <name>
    ///
    /// start|play|run|load|open tour < tour name>
    /// stop|cancel|close
    ///
    /// start|play|run insights
    /// stop|cancel|close
    /// previous|next
    ///
    /// open known <name>  (open known data file)
    /// clear sort
    ///
    /// zoom in|out|<absolute percent>; zoom by <relative percent>; reset zoom
    /// pan left|right|up|down; reset pan
    /// rotate x|y|z <degrees> [continuous]; reset|stop rotation
    ///
    /// take snapshot
    /// reload last session
    ///
    var botChatClass = (function (_super) {
        __extends(botChatClass, _super);
        function botChatClass(app, botMgr) {
            var _this = this;
            _super.call(this);
            this._apis = [];
            this._botMgr = botMgr;
            this._app = app;
            this._context = new ChatContext();
            this.buildKnownValues();
            this.buildOtherApis();
            this.buildSetApis();
            this.buildProperties();
            this.buildRoles();
            //-- colNames to roles ----
            this.onDataLoaded();
            //---- register for data file changes so colNames can be updated ----
            app.registerForChange("dataFrame", function (e) { return _this.onDataLoaded(); });
        }
        botChatClass.prototype.onDataLoaded = function () {
            //---- remove old colNames from roles ----
            this.removeRoleType("valueColName");
            //---- fetch a fresh copy of the column names ----
            this._colNames = this._app.colNames();
            this.addRolesFromValues(this._roles, this._colNames, "valueColName");
        };
        botChatClass.prototype.removeRoleType = function (roleType) {
            if (this._roles) {
                var keys = vp.utils.keys(this._roles);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var kr = this._roles[key];
                    for (var k = kr.length - 1; k >= 0; k--) {
                        var role = kr[k];
                        if (role.roleType == roleType) {
                            kr.removeAt(k);
                        }
                    }
                }
            }
        };
        botChatClass.prototype.buildFeaturesFromInput = function (str) {
            //---- build features from tokens and roles ----
            var scanner = new vp.utils.scannerClass(str);
            scanner.scan(); // first token
            var features = {};
            while (scanner.tokenType() != vp.utils.TokenType.eof) {
                var word = scanner.token();
                var tokenType = scanner.tokenType();
                if (word == ",") {
                    scanner.scan();
                    continue;
                }
                var lowerWord = word.toLowerCase();
                var roles = this._roles[lowerWord];
                if (roles) {
                    for (var r = 0; r < roles.length; r++) {
                        var role = roles[r];
                        if (role.roleClass == RoleClass.hintName) {
                            //---- for hints, pass along the token name ----
                            features[role.roleType] = role.token; // the token that trigger this hint
                        }
                        else {
                            features[role.roleType] = role.name;
                        }
                    }
                }
                else {
                    var beforeFeatures = vp.utils.copyMap(features);
                    //---- for now, a PROPERTY READ modifier is handled here ----
                    this.isQueryNoun(features, lowerWord);
                    this.getRelationalOp(features, lowerWord);
                    this.getNumberValueOrString(features, lowerWord);
                    if (tokenType == vp.utils.TokenType.string) {
                        var str = word.substr(1, word.length - 2); // remove quotes
                        features.string = str;
                    }
                    if (vp.utils.mapEquals(features, beforeFeatures)) {
                        features.unknownWord = word;
                    }
                }
                scanner.scan();
            }
            return features;
        };
        botChatClass.prototype.scoreApisByFeatures = function (features) {
            function exists(prop) {
                return (prop === undefined) ? 0 : 1;
            }
            //---- the feature weights associated with each action/property can be in a table, or in-line code ----
            //---- min score to be successful is .7.  standard "full specified" score is 1.0, but higher scores ----
            //---- are possible due to bias words ----
            var scores = {};
            var queryTerm = .5 * exists(features.queryNoun);
            var apis = this._apis;
            var apisByRoleType = [];
            //---- call each API to compute its score ----
            for (var i = 0; i < apis.length; i++) {
                var api = apis[i];
                api._scoringCallback(scores, features, queryTerm);
                apisByRoleType[api._roleType] = api;
            }
            //---- find highest score ----
            var keys = vp.utils.keys(scores);
            var highScore = 0;
            var highKey = null;
            var highApi = null;
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var score = scores[key];
                if (score > highScore) {
                    highScore = score;
                    highKey = key;
                }
            }
            vp.utils.debug("botChat: highScore=" + highScore + ", highKey=" + highKey);
            if (highScore >= .7) {
                //---- find API with highKey ----
                var isQuery = false;
                if (highKey.startsWith("get")) {
                    highKey = highKey[3].toLowerCase() + highKey.substr(4);
                    isQuery = true;
                }
                highApi = apisByRoleType[highKey];
            }
            return { api: highApi, isQuery: isQuery };
        };
        botChatClass.prototype.parseChatInput = function (text) {
            var processed = false;
            vp.utils.debug("botChat: text=" + text);
            var features = this.buildFeaturesFromInput(text);
            var result = this.scoreApisByFeatures(features);
            if (result.api) {
                //---- execute api ----
                processed = this.runChatApi(result.api, result.isQuery, features);
            }
            //---- post processing ----
            if (processed) {
                if (this._botMgr) {
                    //---- clear the textbox ----
                    this._botMgr.setInputText("");
                    //---- set focus back to textbox ----
                    this._botMgr.setFocusToTextbox();
                }
                //---- set context for next cmd ----
                var context = this._context;
                if (features.valueAttrName) {
                    context.attrName = features.valueAttrName;
                }
                if (features.number !== undefined) {
                    context.number = features.number;
                }
                if (features.valueColName !== undefined) {
                    context.colName = features.valueColName;
                }
                if (features.valuePanelName) {
                    context.panelName = features.valuePanelName;
                }
            }
        };
        botChatClass.prototype.buildKnownValues = function () {
            //---- some known values are just strings; those with aliases are KnowValue objects ----
            this._knownFiles = ["BabyNames", "CoffeeSales", "Colleges", "DemoVote", "MPG", "Sales", "Titanic"];
            this._testFiles = ["AMZN", "APPL", "Adult Census", "AthensCa", "DemoVoteOrig", "FaceBook", "Google",
                "HalfMillionRows", "Headtrax", "IBM", "KnownData", "MSFT", "McDonalds", "MgxSmall", "MillionRows",
                "Network", "Pitches", "RainFall", "Salaries", "Salaries20", "ServiceArea", "TrainInst"];
            this._panelNames = ["data", "items", "filter", "selection", "tasks", "view", "options", "wheel",
                "x", "sum", "facet", "color", "size", "shape", "sort", "about", "insights", "nav", "tips", "search",
                "details", "bot", "tour", "settings", "icon bar", "big bar", "bars"];
            //---- build SORT ORDERS (with aliases) ----
            var sortOrders = [];
            this._sortOrders = sortOrders;
            sortOrders.push(new KnownValue("ascending", ["increasing", "going up", "rising", "forward", "natural"]));
            sortOrders.push(new KnownValue("descending", ["decreasing", "going down", "falling", "backwards", "reverse"]));
            //---- build views (with aliases) ----
            var views = [];
            this._views = views;
            views.push(new KnownValue("grid", ["matrix"]));
            views.push(new KnownValue("column", ["columns", "histogram", "vertical"]));
            views.push(new KnownValue("scatter", ["map", "scatterplot", "xy", "xyplot"]));
            views.push(new KnownValue("density", ["histogram2d"]));
            views.push(new KnownValue("stacks", ["stack", "towers"]));
            views.push(new KnownValue("squarify", ["tree", "treemap", "sizemap"]));
            views.push(new KnownValue("random", ["stochastic", "scrambled"]));
            views.push(new KnownValue("poisson", ["equal space", "equal spacing", "equal spaced"]));
            views.push(new KnownValue("spiral", ["flower"]));
            views.push(new KnownValue("line", ["lineplot"]));
            views.push(new KnownValue("links", []));
            views.push(new KnownValue("radial", ["circular"]));
            views.push(new KnownValue("xband", ["xplot"]));
            views.push(new KnownValue("yband", ["yplot"]));
            views.push(new KnownValue("Scatter3D", ["3d", "threed"]));
            views.push(new KnownValue("bar", ["bars", "horizontal"]));
            views.push(new KnownValue("violin", ["violinplot"]));
            this._colors = vp.utils.keys(vp.color.colors);
            this._paletteSetNames = beachParty.palettesPanelMgr.getPaletteItems();
            //---- build PALETTE NAMES ----
            this._paletteNames = [];
            var app = this._app;
            for (var i = 0; i < this._paletteSetNames.length; i++) {
                var psName = this._paletteSetNames[i];
                var pa = app._colorMgr.paletteMgr().getPaletteArray(psName, 2, false, false);
                for (var i = 0; i < pa.palettes.length; i++) {
                    var pal = pa.palettes[i];
                    var paletteName = pal.name.toLowerCase();
                    this._paletteNames.push(paletteName);
                }
            }
            //---- build attrNames ----
            this._attrNames = ["x", "y", "z", "aux", "color", "size", "shape", "facet"];
            //---- build tour names ----
            this._tourNames = app.getTourItems();
            //---- build theme names ----
        };
        botChatClass.prototype.addRole = function (roles, token, name, roleType, roleClass) {
            token = token.toLowerCase();
            var role = new Role(token, name, roleType, roleClass);
            var entry = roles[token];
            if (!entry) {
                entry = [];
                roles[token] = entry;
            }
            entry.push(role);
        };
        botChatClass.prototype.addRolesFromValues = function (roles, values, roleType) {
            for (var i = 0; i < values.length; i++) {
                var valueName = values[i];
                this.addRole(roles, valueName, valueName, roleType, RoleClass.knownValue);
            }
        };
        botChatClass.prototype.addRolesFromKnownValues = function (roles, values, roleType) {
            for (var i = 0; i < values.length; i++) {
                var kv = values[i];
                //---- add primary name ----
                this.addRole(roles, kv._name, kv._name, roleType, RoleClass.knownValue);
                //---- add aliases ----
                for (var a = 0; a < kv._aliases.length; a++) {
                    var alias = kv._aliases[a];
                    this.addRole(roles, alias, kv._name, roleType, RoleClass.knownValue);
                }
            }
        };
        botChatClass.prototype.buildRoles = function () {
            var _this = this;
            //---- "roles" is a map from word to an array of roles the word plays in inputs to our bot ----
            var roles = {};
            this._roles = roles;
            //---- known values ----
            this.addRolesFromValues(roles, this._knownFiles, "valueKnownFile");
            this.addRolesFromValues(roles, this._testFiles, "valueTestFile");
            this.addRolesFromKnownValues(roles, this._views, "valueView");
            this.addRolesFromKnownValues(roles, this._sortOrders, "valueSortOrder");
            this.addRolesFromValues(roles, this._colors, "valueColor");
            this.addRolesFromValues(roles, this._panelNames, "valuePanelName");
            this.addRolesFromValues(roles, this._attrNames, "valueAttrName");
            this.addRolesFromValues(roles, this._tourNames, "valueTourName");
            //this.addRolesFromValues(roles, this._colNames, "valueColName");
            //---- api's ----
            for (var i = 0; i < this._apis.length; i++) {
                var api = this._apis[i];
                var apiName = api._name.name;
                var aliases = api._name.aliases;
                var roleClass = (api._isProperty) ? RoleClass.propertyName : RoleClass.actionName;
                //---- add name (and its aliases) to roles ----
                api._name.enumNames(function (alias, name) {
                    _this.addRole(roles, alias, name, api._roleType, roleClass);
                });
                //---- add hints (and their aliases) to roles ----
                var hints = api._hints;
                if (hints) {
                    for (var h = 0; h < hints.length; h++) {
                        var hint = hints[h];
                        var roleType = "hint" + beachParty.chartUtils.capitalizeFirstLetter(hint.name);
                        hint.enumNames(function (alias, name) {
                            _this.addRole(roles, alias, name, roleType, RoleClass.hintName);
                        });
                    }
                }
            }
        };
        botChatClass.prototype.buildSetApis = function () {
            var app = this._app;
            var chart = app.currentChart();
            var apis = this._apis;
            var settings = this._app._appSettingsMgr;
            function exists(prop) {
                return (prop === undefined) ? 0 : 1;
            }
            //---- SIZE FACTOR ----
            var property = new ChatProperty("size", "propSize", "sets the sizing factor for the shapes");
            apis.push(property);
            property._values = [new ChatParamValue("number", "the value of the sizing factor")];
            property._name.aliases = ["factor", "sizing"];
            property._runner = function (e, value) {
                chart.sizeFactor(value);
            };
            property._getter = function () {
                return chart.sizeFactor();
            };
            property._scoringCallback = function (scores, features, queryTerm) {
                scores.getPropSize = queryTerm + .5 * exists(features.propSize);
                scores.propSize = .5 * exists(features.number) + .5 * exists(features.propSize);
            };
            //---- OPACITY ----
            var property = new ChatProperty("opacity", "propOpacity", "sets the opacity of the shapes");
            apis.push(property);
            property._values = [new ChatParamValue("number", "the opacity value used to draw shapes")];
            property._name.aliases = ["solidity"];
            property._runner = function (e, value) {
                settings.shapeOpacity(value);
            };
            property._getter = function () {
                return settings.shapeOpacity();
            };
            property._scoringCallback = function (scores, features, queryTerm) {
                scores.getPropOpacity = queryTerm + .5 * exists(features.propOpacity);
                scores.propOpacity = .5 * exists(features.number) + .5 * exists(features.propOpacity);
            };
            //---- COLOR ----
            var property = new ChatProperty("color", "propColor", "sets the color of shapes");
            apis.push(property);
            property._values = [new ChatParamValue("color", "the color value")];
            property._name.aliases = ["colour"];
            property._runner = function (e, value) {
                settings.shapeColor(value);
            };
            property._getter = function () {
                return settings.shapeColor();
            };
            property._scoringCallback = function (scores, features, queryTerm) {
                scores.getPropColor = queryTerm + .5 * exists(features.propColor);
                scores.propColor = .5 * exists(features.propColor) + .25 * (exists(features.valueColor) | exists(features.unknownWord) | exists(features.string));
            };
            //---- VIEW ----
            var property = new ChatProperty("view", "propView", "sets the current view (chart type)");
            apis.push(property);
            property._values = [new ChatParamValue("view", "the type of view")];
            property._name.aliases = ["chart", "chartType", "plot", "layout"];
            property._runner = function (e, value) {
                var chartType = beachParty.chartClass.getChartTypeFromName(value, beachParty.LayoutType.Default);
                chart.changeToChart(chartType, null, beachParty.Gesture.chatBot);
            };
            property._getter = function () {
                return chart.chartName();
            };
            property._scoringCallback = function (scores, features, queryTerm) {
                scores.getPropView = queryTerm + .5 * exists(features.propView);
                scores.propView = .7 * exists(features.valueView) + .3 * exists(features.propView);
            };
        };
        botChatClass.prototype.buildOtherApis = function () {
            var _this = this;
            var app = this._app;
            var apis = this._apis;
            function exists(prop) {
                return (prop === undefined) ? 0 : 1;
            }
            //---- ISOLATE ----
            var action = new ChatAction("isolate", "actIsolate", "isolates the selected shapes");
            apis.push(action);
            action._name.aliases = ["focus", "filter in", "filter", "keep", "only"];
            action._runner = function (e, fileName) {
                app.onIsolateClick();
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                scores.actIsolate = 1 * exists(features.actIsolate);
            };
            //---- EXCLUDE ----
            var action = new ChatAction("exclude", "actExclude", "excludes the selected shapes");
            apis.push(action);
            action._name.aliases = ["remove", "hide", "disappear", "away"];
            action._runner = function (e, fileName) {
                app.onExcludeClick();
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                //---- guard against conflicts with "hide panel xxx"
                scores.actExclude = .75 * exists(features.actExclude) - .25 * exists(features.valuePanelName) - .25 * exists(features.hintPanel);
            };
            //---- LOAD DATA ----
            var action = new ChatAction("loadData", "actLoadData", "loads the specified CSV file as the current dataset");
            apis.push(action);
            action._values = [new ChatParamValue("fileName", "the name or URL of the CSV file to be loaded")];
            action._name.aliases = ["load", "open", "use"];
            action._hints = [new AliasedName("data", ["file", "dataset"])];
            action._runner = function (e, fileName) {
                var chart = _this._app._chartRouter.getChart();
                chart.openKnownFile(fileName);
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                scores.actLoadData = .25 * exists(features.hintData) + .25 * exists(features.actLoadData) + .5 * exists(features.valueKnownFile);
            };
            //---- START TOUR ----
            var action = new ChatAction("startTour", "actStartTour", "loads and starts the specified tour");
            apis.push(action);
            action._values = [new ChatParamValue("tourName", "the name of the tour to be loaded")];
            action._name.aliases = ["start", "play", "run", "load", "open", "take"];
            action._hints = [new AliasedName("tour", ["lesson", "guide"])];
            action._runner = function (e, tourName) {
                app.startTourName(tourName);
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                scores.actStartTour = .25 * exists(features.actStartTour) + .5 * exists(features.valueTourName) + .25 * exists(features.hintTour);
            };
            //---- UNDO ----
            var action = new ChatAction("undo", "actUndo", "undo the last view change");
            apis.push(action);
            action._values = [];
            action._name.aliases = ["goback", "cancel", "don't"];
            action._runner = function (e) {
                app.onUndoClick();
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                scores.actUndo = .75 * exists(features.actUndo);
            };
            //---- SEARCH (SELECT) ----
            var action = new ChatAction("search", "actSearch", "search a column for specified value(s)");
            apis.push(action);
            var value0 = new ChatParamValue("colName", "the name of a column to search", null, true);
            var value1 = new ChatParamValue("columnExpression", "a value or expression to search for");
            action._values = [value0, value1];
            action._name.aliases = ["find", "highlight", "highlite", "mark", "select"];
            action._runner = function (e, colName, colExp) {
                app.applySearchPanelParams({}, colName, colExp);
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                scores.actSearch = .35 * exists(features.actSearch) + .15 * exists(features.relationalOperator)
                    + .20 * (exists(features.valueColumnExpression) | exists(features.valueColName))
                    + .20 * (exists(features.unknownWord) | exists(features.string));
            };
            //---- CLICK (SELECT) ----
            var action = new ChatAction("click", "actClick", "click on a UI element to select the associated shapes");
            apis.push(action);
            //var value0 = new ChatParamValue("axisName", "the name of an axis (or its mapped column name)");
            var value0 = new ChatParamValue("attrName", "the attribute to be mapped");
            //var value1 = new ChatParamValue("colName", "the column name that specifies the data for the mapping");
            var value1 = new ChatParamValue("boxId", "the axis/legend box to click, by index or label", null, true);
            action._values = [value0, value1];
            action._name.aliases = ["select"];
            action._runner = function (e, attrName, boxNumber) {
                _this.selectBox(attrName, boxNumber);
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                scores.actClick = .25 * exists(features.actClick) + .25 * exists(features.valueAttrName) + .25 * exists(features.valueColName);
            };
            //---- SELECT TAB ----
            var action = new ChatAction("select tab", "actSelectTab", "click on a tab within a panel");
            apis.push(action);
            var value0 = new ChatParamValue("tabName", "the tab to be selected");
            var value1 = new ChatParamValue("panelName", "the name of a SandDance panel", undefined, true);
            action._values = [value0, value1];
            action._name.aliases = ["tab", "click tab", "open tab"];
            action._runner = function (e, tabName, panelName) {
                if (!panelName) {
                    panelName = e.context.panelName;
                }
                if (panelName) {
                    _this.selectTab(panelName, tabName);
                }
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                scores.actSelectTab = .5 * exists(features.actSelectTab) + .25 * exists(features.valuePanelName) + .25 *
                    (exists(features.unknownWord) | exists(features.string));
            };
            //---- ENABLE ----
            var action = new ChatAction("enable", "actEnable", "turn on an option");
            apis.push(action);
            var value0 = new ChatParamValue("optionName", "the name of a SandDance option");
            action._values = [value0];
            action._name.aliases = ["on", "use", "apply"];
            action._runner = function (e, optionName) {
                _this.enableOption(optionName, true);
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                scores.actEnable = .45 * exists(features.actEnable) + .35 * exists(features.valueOptionName);
            };
            //---- DISABLE ----
            var action = new ChatAction("disable", "actDisable", "turn off an option");
            apis.push(action);
            var value0 = new ChatParamValue("optionName", "the name of a SandDance option");
            action._values = [value0];
            action._name.aliases = ["off", "stop"];
            action._runner = function (e, optionName) {
                _this.enableOption(optionName, false);
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                scores.actDisable = .4 * exists(features.actDisable) + .35 * exists(features.valueAttrName) + .35 * exists(features.valueColName);
            };
            //---- SHOW ----
            var action = new ChatAction("show", "actShow", "show a panel");
            apis.push(action);
            var value0 = new ChatParamValue("panelName", "the name of a SandDance panel");
            action._values = [value0];
            action._name.aliases = ["open", "unhide", "create"];
            action._hints = [new AliasedName("panel", ["window", "dialog"]), new AliasedName("pin", ["pinned", "unpinned"])];
            action._runner = function (e, panelName) {
                _this.showPanel(e, panelName, true);
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                scores.actShow = .5 * exists(features.actShow) + .25 * exists(features.valuePanelName) + .25 * exists(features.hintPanel) + .25 * exists(features.hintPin);
            };
            //---- HIDE ----
            var action = new ChatAction("hide", "actHide", "hide a panel");
            apis.push(action);
            var value0 = new ChatParamValue("panelName", "the name of a SandDance panel");
            action._values = [value0];
            action._name.aliases = ["close", "away", "remove"];
            action._hints = [new AliasedName("panel", ["window", "dialog"])];
            action._runner = function (e, panelName) {
                _this.showPanel(e, panelName, false);
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                scores.actHide = .5 * exists(features.actHide) + .25 * exists(features.valuePanelName) + .25 * exists(features.hintPanel);
            };
            //---- MAP ----
            var action = new ChatAction("map", "actMap", "map an attribute to a column name");
            apis.push(action);
            var value0 = new ChatParamValue("attrName", "the attribute to be mapped");
            var value1 = new ChatParamValue("colName", "the column name that specifies the data for the mapping");
            action._values = [value0, value1];
            action._name.aliases = ["associate", "bind"];
            action._runner = function (e, attrName, colName) {
                _this.mapColumn(attrName, colName);
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                scores.actMap = .1 * exists(features.actMap) + .45 * exists(features.valueAttrName) + .45 * exists(features.valueColName);
            };
            //---- SORT ----
            var action = new ChatAction("sort", "actSort", "sort records by a column name or mapped attribute");
            apis.push(action);
            var value0 = new ChatParamValue("attrName", "the mapped attribute used to determine the sorting column", "", true);
            var value1 = new ChatParamValue("colName", "the column name that determines the sorting order", "", true);
            var value2 = new ChatParamValue("sortOrder", "the direction to order column values", "ascending", true);
            action._values = [value0, value1, value2];
            action._name.aliases = ["order", "arrange", "reorder", "sequence"];
            action._runner = function (e, attrName, colName, sortOrder) {
                _this.sortBy(attrName, colName, sortOrder);
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                scores.actSort = .4 * exists(features.actSort) + .35 * exists(features.valueAttrName) + .35 * exists(features.valueColName)
                    + .25 * exists(features.valueSortOrder);
            };
            //---- CLEAR ----
            var action = new ChatAction("clear", "actClear", "clear a attribute mapping");
            apis.push(action);
            var value0 = new ChatParamValue("attrName", "the attribute to be mapped", "all", true);
            action._values = [value0];
            action._name.aliases = ["reset", "unmap", "none", "remove", "erase", "empty"];
            action._runner = function (e, attrName) {
                if (attrName && attrName != "all") {
                    _this.mapColumn(attrName, null);
                }
                else {
                    _this._app.onResetClick();
                }
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                scores.actClear = .75 * exists(features.actClear) + .25 * exists(features.valueAttrName) + .25 * exists(features.valueColName);
            };
            //---- STOP ----
            var action = new ChatAction("stop", "actStop", "stop the current tour or playing of insights");
            apis.push(action);
            action._name.aliases = ["cancel", "close"];
            action._hints = [new AliasedName("tour", ["guide", "lesson"]), new AliasedName("insights", ["animation", "show"])];
            action._runner = function (e, attrName) {
                _this.stopTourOrInsights();
            };
            action._scoringCallback = function (scores, features, queryTerm) {
                //---- guard against conflicts with "hide panel xxx"
                scores.actStop = .75 * exists(features.actStop) + .25 * exists(features.hintTour) + .25 * exists(features.hintInsights)
                    - .25 * exists(features.valuePanelName) - .25 * exists(features.hintPanel);
            };
        };
        botChatClass.prototype.stopTourOrInsights = function () {
            if (!this._app.stopTour()) {
                this._app.stopPlayback();
            }
        };
        botChatClass.prototype.selectTab = function (panelName, tabName) {
            if (!panelName.endsWith("Panel")) {
                panelName += "Panel";
            }
            var panel = this._app._panelMaster.getJsonPanel(panelName);
            if (panel) {
                panel.selectTab(tabName);
            }
        };
        botChatClass.prototype.buildProperties = function () {
        };
        botChatClass.prototype.sortBy = function (attrName, colName, sortOrder) {
            var chart = this._app.currentChart();
            if (!colName) {
                if (!attrName) {
                    vp.utils.error("sortBy cmd: attrName or colName must be specified");
                }
                var attr = chart.getAttribute(attrName);
                colName = attr.colName;
            }
            if (!colName) {
                vp.utils.error("sortBy: attr=" + attrName + " is not a mapped attribute and so cannot be used to specified a sort column");
            }
            chart.sortIfNeeded(colName, sortOrder == "descending");
        };
        botChatClass.prototype.showBars = function (name, value) {
            var app = this._app;
            var chart = app.currentChart();
            var iconBar = (name == "bars" || name.contains("icon"));
            var bigBar = (name == "bars" || name.contains("big"));
            var theme = app._themeMgr.getTheme();
            var title = false;
            //---- show BIG BAR and ICON BAR if not playing ----
            if (bigBar) {
                app._bigBarMgr.show(value);
            }
            if (iconBar) {
                vp.select("#playAndIconBar").css("display", (value ? "" : "none"));
                this._app.showLogo(value);
                vp.select("#iconBar").css("display", (value) ? "" : "none");
            }
            if (title) {
                chart.showTitleText(value);
                chart.showItemCounts(value);
            }
            this.chatHistory("Toolbars " + ((value) ? "shown" : "hidden"));
        };
        botChatClass.prototype.showPanel = function (e, name, value) {
            var app = this._app;
            if (name == "data") {
                name = "dataSet";
            }
            if (name.contains("bar")) {
                this.showBars(name, value);
            }
            else if (name == "insights") {
                this._app.showInsightsPanel(value);
            }
            else {
                name += "Panel";
                if (value) {
                    var fromLegend = (name == "xPanel" || name == "yPanel");
                    app._panelMaster.showPanel(name, undefined, undefined, fromLegend);
                    if (e.features.hintPin) {
                        //---- apply "pin" hint ----
                        var panel = app._panelMaster.getJsonPanel(name);
                        var isPinned = (e.features.hintPin == "pinned");
                        panel.isFloating(isPinned);
                    }
                }
                else {
                    app._panelMaster.hidePanel(name);
                }
            }
            //if (name == "details")
            //{
            //    app.toggleDetailsPanel(null);
            //}
        };
        botChatClass.prototype.enableOption = function (name, value) {
            var app = this._app;
            var settings = app._appSettingsMgr;
            var colorMgr = this._app._colorMgr;
            if (name == "nice") {
                settings.useNiceNumbers(value);
            }
            else if (name == "reverse") {
                colorMgr.reverseColorPalette(value);
            }
            else if (name == "continuous") {
                colorMgr.colorIsContinuous(value);
            }
            else if (name == "invert") {
                colorMgr.invertColorPalette(value);
            }
        };
        botChatClass.prototype.getBoxIndex = function (axisName, label) {
            var app = this._app;
            var index = undefined;
            if (axisName == "x") {
            }
            else if (axisName == "y") {
            }
            else if (axisName == "facet") {
                index = app.getIndexOfFacetLabel(label);
            }
            else if (axisName == "color") {
            }
            else if (axisName == "size") {
            }
            else if (axisName == "shape") {
            }
            return index;
        };
        botChatClass.prototype.selectBox = function (axisName, boxId) {
            var boxIndex = +boxId;
            if (isNaN(boxIndex)) {
                //---- get index of label = boxId ----
                boxIndex = this.getBoxIndex(axisName, boxId);
            }
            else {
                if (boxIndex >= 1) {
                    //---- make it 0-relative for API's ----
                    boxIndex--;
                }
            }
            var app = this._app;
            if (axisName == "x") {
                app.selectXBox(boxIndex);
            }
            else if (axisName == "y") {
                app.selectYBox(boxIndex);
            }
            else if (axisName == "facet") {
                app.selectFacetBox(boxIndex);
            }
            else if (axisName == "color") {
                app.selectColorBox(boxIndex);
            }
            else if (axisName == "size") {
                app.selectSizeBox(boxIndex);
            }
            else if (axisName == "shape") {
                app.selectShapeBox(boxIndex);
            }
        };
        botChatClass.prototype.isClearVerb = function (features, str) {
            var isClear = (str == "clear" || str == "remove" || str == "reset" || str == "erase" ||
                str == "none" || str == "empty" || str == "null");
            if (isClear) {
                features.clearVerb = true;
            }
        };
        botChatClass.prototype.isPaletteNoun = function (features, str) {
            var isPal = (str == "palette" || str == "paletteName");
            if (isPal) {
                features.paletteNoun = true;
            }
        };
        botChatClass.prototype.isSelectionNoun = function (features, str) {
            var isSel = (str == "selection" || str == "select" || str == "shapes" || str == "highlight");
            if (isSel) {
                features.selectionNoun = true;
            }
        };
        botChatClass.prototype.isFilterNoun = function (features, str) {
            var isFil = (str == "filter" || str == "filtered");
            if (isFil) {
                features.filterNoun = true;
            }
        };
        botChatClass.prototype.isTourVerb = function (features, str) {
            var isTour = (str == "tour" || str == "teach" || str == "lesson" || str == "learn");
            if (isTour) {
                features.tourVerb = true;
            }
        };
        botChatClass.prototype.isRandomPick = function (features, str) {
            var isRand = (str == "random" || str == "pick" || str == "change");
            if (isRand) {
                features.randomPickVerb = true;
            }
        };
        botChatClass.prototype.isHideVerb = function (features, str) {
            var isHide = (str == "hide" || str == "close" || str == "remove");
            if (isHide) {
                features.hideVerb = true;
            }
        };
        botChatClass.prototype.isShowVerb = function (features, str) {
            var isShow = (str == "show" || str == "open" || str == "add");
            if (isShow) {
                features.isShow = true;
            }
        };
        botChatClass.prototype.getMapableAttribute = function (features, str) {
            var attrName = null;
            if (str == "color" || str == "colors") {
                attrName = "color";
            }
            else if (str == "x" || str == "xaxis" || str == "x-axis") {
                attrName = "x";
            }
            else if (str == "y" || str == "yaxis" || str == "y-axis") {
                attrName = "y";
            }
            else if (str == "z" || str == "zaxis" || str == "z-axis") {
                attrName = "z";
            }
            else if (str == "sum" || str == "square" || str == "aux") {
                attrName = "aux";
            }
            else if (str == "facet" || str == "trellis" || str == "facets") {
                attrName = "facet";
            }
            else if (str == "size" || str == "sizes") {
                attrName = "size";
            }
            else if (str == "shape" || str == "shapes" || str == "images") {
                attrName = "shape";
            }
            if (attrName) {
                features.attrName = attrName;
            }
            return attrName;
        };
        botChatClass.prototype.isSizeFactorNoun = function (features, str) {
            var isSf = (str == "factor" || str == "sizefactor" || str == "size" || str == "shapesize");
            if (isSf) {
                features.sizeFactorNoun = true;
            }
        };
        botChatClass.prototype.isOpacityNoun = function (features, str) {
            var isSf = (str == "opacity" || str == "transparency" || str == "alpha");
            if (isSf) {
                features.opacityNoun = true;
            }
        };
        botChatClass.prototype.isQueryNoun = function (features, str) {
            var isQuery = (str == "?" || str == "value" || str == "tell" || str == "report" ||
                str == "show" || str == "display" || str == "list" || str == "print");
            if (isQuery) {
                features.queryNoun = true;
            }
        };
        botChatClass.prototype.isColorNoun = function (features, str) {
            var isColor = (str == "color" || str == "cr" || str == "colour");
            return isColor;
        };
        botChatClass.prototype.getKnownFiles = function (features, str) {
            for (var i = 0; i < this._knownFiles.length; i++) {
                var known = this._knownFiles[i];
                if (str == known.toLowerCase()) {
                    features.knownFile = known;
                    break;
                }
            }
        };
        botChatClass.prototype.getTestFiles = function (features, str) {
            for (var i = 0; i < this._testFiles.length; i++) {
                var test = this._testFiles[i];
                if (str == test.toLowerCase()) {
                    features.testFile = test;
                    break;
                }
            }
        };
        botChatClass.prototype.isStepsNoun = function (features, str) {
            var isSteps = (str == "step" || str == "steps" || str == "divisions" || str == "pieces" || str == "blocks" ||
                str == "bins");
            if (isSteps) {
                features.stepsNoun = true;
            }
        };
        botChatClass.prototype.isBars = function (features, str) {
            var isb = (str == "bars" || str == "toolbars" || str == "tools");
            if (isb) {
                features.isBars = true;
            }
            return isb;
        };
        botChatClass.prototype.isMappingNoun = function (features, str) {
            var isMap = (str == "mapping" || str == "map" || str == "by");
            if (isMap) {
                features.mappingNoun = true;
            }
        };
        botChatClass.prototype.isSeedNoun = function (features, str) {
            var isSeed = (str == "seed" || str == "randomseed" || str == "spiralseed");
            if (isSeed) {
                features.isSeedNoun = true;
            }
        };
        botChatClass.prototype.isColumnNoun = function (features, str) {
            var isCN = (str == "columns" || str == "names" || str == "colnames");
            if (isCN) {
                features.isColumnNoun = true;
            }
        };
        botChatClass.prototype.chartName = function (features, str) {
            var chartName = null;
            if (str == "scatter" || str == "scatterplot" || str == "xy" || str == "xyplot") {
                chartName = "Scatter";
            }
            else if (str == "col" || str == "column" || str == "columns" || str == "histogram" || str == "vertical") {
                chartName = "Column";
            }
            else if (str == "3d" || str == "scatter3d" || str == "scatter-3d") {
                chartName = "Scatter-3D";
            }
            else if (str == "grid" || str == "matrix") {
                chartName = "Grid";
            }
            else if (str == "density" || str == "histogram2d") {
                chartName = "Density";
            }
            else if (str == "stack" || str == "stacks" || str == "towers") {
                chartName = "Stacks";
            }
            else if (str == "squarify" || str == "tree" || str == "treemap" || str == "sizemap") {
                chartName = "Squarify";
            }
            else if (str == "random" || str == "stochastic" || str == "scrambled") {
                chartName = "Random";
            }
            else if (str == "poisson") {
                chartName = "Poisson";
            }
            else if (str == "flower" || str == "spiral") {
                chartName = "Spiral";
            }
            else if (str == "line" || str == "lines") {
                chartName = "Line";
            }
            else if (str == "link" || str == "links") {
                chartName = "Links";
            }
            else if (str == "radial" || str == "polar") {
                chartName = "Radial";
            }
            else if (str == "xband") {
                chartName = "Xband";
            }
            else if (str == "yband") {
                chartName = "YBand";
            }
            else if (str == "bar" || str == "bars" || str == "horizontal") {
                chartName = "Bar";
            }
            else if (str == "violin" || str == "violinplot") {
                chartName = "Violin";
            }
            if (chartName) {
                features.chartName = chartName;
            }
        };
        botChatClass.prototype.getColName = function (features, str) {
            var ci = this._app.getColInfo(str);
            if (!ci) {
                //--- try ignoring the case ----
                ci = this._app.getColInfo(str, true);
            }
            if (ci) {
                features.colName = ci.name;
            }
        };
        botChatClass.prototype.getChatAction = function (features, str) {
            var chatAction = null;
            for (var i = 0; i < this._apis.length; i++) {
                var action = this._apis[i];
                //---- check NAME ----
                var actionName = action._name.name;
                var aliases = action._name.aliases;
                if (actionName.toLowerCase() == str) {
                    chatAction = action;
                    break;
                }
                //---- check ALIASES ----
                for (var a = 0; a < aliases.length; a++) {
                    if (aliases[a] == str) {
                        chatAction = action;
                        break;
                    }
                }
                if (chatAction) {
                    break;
                }
            }
            if (chatAction) {
                features.chatAction = chatAction;
            }
        };
        botChatClass.prototype.getRelationalOp = function (features, str) {
            var isOp = (str == "<" || str == "<=" || str == "=" || str == "==" || str == ">" ||
                str == ">=" || str == "!=" || str == "<>");
            if (isOp) {
                features.relationalOperator = str;
            }
        };
        botChatClass.prototype.setNumberFeature = function (features, value) {
            if (features.number === undefined) {
                features.number = value;
            }
            else {
                features.number2 = value;
            }
        };
        botChatClass.prototype.getNumberValueOrString = function (features, str) {
            var numberNames = ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve"];
            var thNames = ["last", "first", "second", "third", "forth", "fifth", "sixth", "seventh", "eighth", "nineth", "tenth", "eleventh", "twelveth"];
            var index = numberNames.indexOf(str);
            if (index > -1) {
                this.setNumberFeature(features, 1 + index);
            }
            else {
                index = thNames.indexOf(str);
                if (index > -1) {
                    if (index == 0) {
                        this.setNumberFeature(features, -1);
                    }
                    else {
                        this.setNumberFeature(features, index);
                    }
                }
                else {
                    if (str != "" && !isNaN(+str)) {
                        this.setNumberFeature(features, +str);
                    }
                }
            }
        };
        botChatClass.prototype.chatHistory = function (str) {
            if (this._botMgr) {
                this._botMgr.chatResponse(str);
            }
        };
        botChatClass.prototype.getParamValue = function (features, chatValue) {
            var value = undefined;
            var chatName = chatValue._name.name;
            if (chatName == "fileName") {
                value = features.valueTestFile || features.valueKnownFile;
            }
            else if (chatName == "tourName") {
                value = features.valueTourName;
            }
            else if (chatName == "panelName") {
                value = features.valuePanelName;
            }
            else if (chatName == "sortOrder") {
                value = features.valueSortOrder;
            }
            else if (chatName == "tabName") {
                if (features.string !== undefined) {
                    value = features.string;
                }
                else if (features.unknownWord !== null) {
                    value = features.unknownWord;
                }
            }
            else if (chatName == "color") {
                value = features.valueColor;
                if (!value) {
                    if (features.string !== undefined) {
                        value = features.string;
                    }
                    else if (features.unknownWord !== null) {
                        value = features.unknownWord;
                    }
                }
            }
            else if (chatName == "number") {
                value = features.number;
            }
            else if (chatName == "view") {
                value = features.valueView;
            }
            else if (chatName == "colName") {
                value = features.valueColName;
                if (!value) {
                    //---- try an axis/legend name that has a colName mapping ----
                    var attrName = features.valueAttrName;
                    if (attrName) {
                        value = this.getAttributeMapping(attrName);
                    }
                }
            }
            else if (chatName == "attrName") {
                value = features.valueAttrName;
                if (!value) {
                    //---- try an colName that is mapped to a legend or axis ----
                    if (features.valueColName) {
                        value = this.findAxisMappedToColumn(features.valueColName);
                    }
                }
            }
            else if (chatName == "optionName") {
                if (features.string !== undefined) {
                    value = features.string;
                }
                else if (features.unknownWord !== null) {
                    value = features.unknownWord;
                }
            }
            else if (chatName == "boxId") {
                if (features.number !== undefined) {
                    value = features.number;
                }
                else if (features.string !== undefined) {
                    value = features.string;
                }
                else if (features.unknownWord !== null) {
                    value = features.unknownWord;
                }
            }
            else if (chatName == "columnExpression") {
                value = features.string;
                if (!value) {
                    if (features.number === undefined) {
                        value = features.unknownWord;
                    }
                    else {
                        value = "" + features.number;
                        if (features.number2) {
                            value = value + " - " + features.number2;
                        }
                        else {
                            //---- add relational operator, if exists ----
                            var op = features.relationalOperator;
                            if (op) {
                                value = op + " " + value;
                            }
                        }
                    }
                }
            }
            if (!value) {
                value = chatValue._defaultValue;
            }
            return value;
        };
        botChatClass.prototype.findAxisMappedToColumn = function (colName) {
            var app = this._app;
            var value = undefined;
            var xCol = app._xMgr.colName();
            var yCol = app._yMgr.colName();
            var zCol = app._zMgr.colName();
            if (colName == xCol) {
                value = "x";
            }
            else if (colName == yCol) {
                value = "y";
            }
            else if (colName == zCol) {
                value = "z";
            }
            else if (colName == app._auxMgr.colName()) {
                value = "aux";
            }
            else if (colName == app._facetMgr.colName()) {
                value = "facet";
            }
            else if (colName == app.colorColumn()) {
                value = "color";
            }
            else if (colName == app._sizeMgr.colName()) {
                value = "size";
            }
            else if (colName == app._shapeMgr.colName()) {
                value = "shape";
            }
            return value;
        };
        botChatClass.prototype.getAttributeMapping = function (attrName) {
            var app = this._app;
            var value = undefined;
            if (attrName == "x") {
                value = app._xMgr.colName();
            }
            else if (attrName == "y") {
                value = app._yMgr.colName();
            }
            else if (attrName == "z") {
                value = app._zMgr.colName();
            }
            else if (attrName == "aux") {
                value = app._auxMgr.colName();
            }
            else if (attrName == "color") {
                value = app.colorColumn();
            }
            else if (attrName == "size") {
                value = app._sizeMgr.colName();
            }
            else if (attrName == "shape") {
                value = app._shapeMgr.colName();
            }
            else if (attrName == "facet") {
                value = app._facetMgr.colName();
            }
            return value;
        };
        botChatClass.prototype.runChatApi = function (chatAction, isQuery, features) {
            var processed = false;
            var values = chatAction._values;
            var e = { features: features, isQuery: isQuery, context: this._context };
            if (isQuery && chatAction._isProperty) {
                //---- property read ----
                var value = chatAction._getter();
                this.chatHistory("Value is: " + value);
                processed = true;
            }
            else if (!values || values.length == 0) {
                //---- process actions with ZERO parameters ----
                chatAction._runner(e);
                this.chatHistory("action: " + chatAction._name.name);
                processed = true;
            }
            else if (values.length == 1) {
                //---- process actions with ONE parameter ----
                var value = this.getParamValue(features, values[0]);
                if (value !== undefined || values[0]._isOptional) {
                    chatAction._runner(e, value);
                    this.chatHistory(chatAction._name.name + " set to " + value);
                    processed = true;
                }
            }
            else if (values.length == 2) {
                var value0 = this.getParamValue(features, values[0]);
                var value1 = this.getParamValue(features, values[1]);
                if ((value0 !== undefined || values[0]._isOptional) && (value1 !== undefined || values[1]._isOptional)) {
                    chatAction._runner(e, value0, value1);
                    this.chatHistory("Action: " + chatAction._name.name + "(" + value0 + ", " + value1 + ")");
                    processed = true;
                }
            }
            else if (values.length == 3) {
                var value0 = this.getParamValue(features, values[0]);
                var value1 = this.getParamValue(features, values[1]);
                var value2 = this.getParamValue(features, values[2]);
                if ((value0 !== undefined || values[0]._isOptional) && (value1 !== undefined || values[1]._isOptional)
                    && (value2 !== undefined || values[2]._isOptional)) {
                    chatAction._runner(e, value0, value1, value2);
                    this.chatHistory("Action: " + chatAction._name.name + "(" + value0 + ", " + value1 + ", " + value2 + ")");
                    processed = true;
                }
            }
            else {
                vp.utils.error("Bot cmd with > 3 parameters not currently supported");
            }
            return processed;
        };
        botChatClass.prototype.setBinCount = function (attrName, count) {
            count = Math.round(+count);
            var app = this._app;
            if (attrName == "x") {
                //app.xBins(count);
                app._xMgr.binCount(count);
                this.chatHistory("X bins set to: " + count);
            }
            else if (attrName == "y") {
                app._yMgr.binCount(count);
                this.chatHistory("Y bins set to: " + count);
            }
            else if (attrName == "z") {
                app._zMgr.binCount(count);
                this.chatHistory("Z bins set to: " + count);
            }
            else if (attrName == "aux") {
                app._auxMgr.binCount(count);
                this.chatHistory("Aux bins set to: " + count);
            }
            else if (attrName == "facet") {
                app._facetMgr.binCount(count);
                this.chatHistory("Facet bins set to: " + count);
            }
            else if (attrName == "color") {
                var colorMgr = app._colorMgr;
                colorMgr.binCount(count);
                this.chatHistory("Color steps set to: " + count);
            }
            else if (attrName == "shape") {
                app._shapeMgr.binCount(count);
                this.chatHistory("Shape steps set to: " + count);
            }
            else if (attrName == "size") {
                app._sizeMgr.binCount(count);
                this.chatHistory("Size steps set to: " + count);
            }
        };
        botChatClass.prototype.reportAttrValue = function (attrName) {
            var app = this._app;
            var chart = app.currentChart();
            var settings = app._appSettingsMgr;
            if (attrName == "color") {
                if (app.colorColumn()) {
                    var crCol = app.colorColumn();
                    this.chatHistory("Shape color is mapped to: " + crCol);
                }
                else {
                    var value = settings.shapeColor();
                    this.chatHistory("Shape color is: " + value);
                }
            }
            else if (attrName == "size") {
                if (app._sizeMgr.isSet()) {
                    var szCol = app._sizeMgr.colName();
                    this.chatHistory("Shape size is mapped to: " + szCol);
                }
                else {
                    var sf = chart.sizeFactor();
                    this.chatHistory("Shape size factor is: " + sf);
                }
            }
        };
        botChatClass.prototype.pickAttrValue = function (attrName) {
            var app = this._app;
            if (attrName == "color") {
                if (app.colorColumn()) {
                    var colNames = app.colNames();
                    var i = Math.round(colNames.length * Math.random());
                    var colName = colNames[i];
                    this.mapColumn(attrName, colName);
                }
                else {
                    //var value = vp.color.getRandomColor();
                    var colorNames = vp.utils.keys(vp.color.colors);
                    var i = Math.round(colorNames.length * Math.random());
                    var color = colorNames[i];
                    var settings = this._app._appSettingsMgr;
                    settings.shapeColor(color);
                    this.chatHistory("Shape color is: " + color);
                }
            }
        };
        botChatClass.prototype.mapColumn = function (attrName, colName) {
            var app = this._app;
            var msg = (colName) ? (" mapped to: " + colName) : (" mapping removed");
            if (attrName == "x") {
                //app.xColumn(colName);
                app._xMgr.colName(colName);
                this.chatHistory("X" + msg);
            }
            else if (attrName == "y") {
                app._yMgr.colName(colName);
                this.chatHistory("Y" + msg);
            }
            else if (attrName == "z") {
                app._zMgr.colName(colName);
                this.chatHistory("Z" + msg);
            }
            else if (attrName == "aux") {
                app._auxMgr.colName(colName);
                this.chatHistory("Aux" + msg);
            }
            else if (attrName == "facet") {
                app._facetMgr.colName(colName);
                this.chatHistory("Facet" + msg);
            }
            else if (attrName == "color") {
                app._colorMgr.colName(colName);
                this.chatHistory("Color" + msg);
            }
            else if (attrName == "shape") {
                app._shapeMgr.colName(colName);
                this.chatHistory("Shape" + msg);
            }
            else if (attrName == "size") {
                app._sizeMgr.colName(colName);
                this.chatHistory("Size" + msg);
            }
        };
        return botChatClass;
    }(beachParty.dataChangerClass));
    beachParty.botChatClass = botChatClass;
    var ChatContext = (function () {
        function ChatContext() {
        }
        return ChatContext;
    }());
    beachParty.ChatContext = ChatContext;
    var ChatAction = (function () {
        function ChatAction(name, roleType, description) {
            this._name = new AliasedName(name);
            this._roleType = roleType;
            this._description = description;
            this._isProperty = false;
        }
        return ChatAction;
    }());
    beachParty.ChatAction = ChatAction;
    var AliasedName = (function () {
        function AliasedName(name, aliases) {
            this.name = name;
            this.aliases = aliases;
        }
        AliasedName.prototype.enumNames = function (callback) {
            callback(this.name, this.name);
            //---- enum each alias for this name ----
            for (var a = 0; a < this.aliases.length; a++) {
                var alias = this.aliases[a];
                callback(alias, this.name);
            }
        };
        return AliasedName;
    }());
    beachParty.AliasedName = AliasedName;
    var ChatProperty = (function (_super) {
        __extends(ChatProperty, _super);
        function ChatProperty(name, roleType, description) {
            _super.call(this, name, roleType, description);
            this._isProperty = true;
        }
        return ChatProperty;
    }(ChatAction));
    beachParty.ChatProperty = ChatProperty;
    var ChatApi = (function (_super) {
        __extends(ChatApi, _super);
        function ChatApi() {
            _super.apply(this, arguments);
        }
        return ChatApi;
    }(ChatProperty));
    beachParty.ChatApi = ChatApi;
    var KnownValue = (function () {
        function KnownValue(name, aliases, description) {
            this._name = name;
            this._aliases = aliases;
            this._description = description;
        }
        return KnownValue;
    }());
    beachParty.KnownValue = KnownValue;
    var ChatParamValue = (function () {
        function ChatParamValue(name, description, defaultValue, isOptional) {
            this._name = new AliasedName(name);
            this._description = description;
            this._defaultValue = defaultValue;
            this._isOptional = isOptional;
        }
        return ChatParamValue;
    }());
    beachParty.ChatParamValue = ChatParamValue;
    (function (RoleClass) {
        RoleClass[RoleClass["knownValue"] = 0] = "knownValue";
        RoleClass[RoleClass["propertyName"] = 1] = "propertyName";
        RoleClass[RoleClass["actionName"] = 2] = "actionName";
        RoleClass[RoleClass["hintName"] = 3] = "hintName";
    })(beachParty.RoleClass || (beachParty.RoleClass = {}));
    var RoleClass = beachParty.RoleClass;
    var Role = (function () {
        function Role(token, name, roleType, roleClass) {
            this.token = token;
            this.name = name;
            this.roleType = roleType;
            this.roleClass = roleClass;
        }
        return Role;
    }());
    beachParty.Role = Role;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    gridLayout.ts - does a row & column grid layout of controls.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var gridLayoutClass = (function (_super) {
        __extends(gridLayoutClass, _super);
        function gridLayoutClass(parent, colFill, cellPadding) {
            _super.call(this);
            this._parent = parent;
            this._cellPadding = cellPadding;
            var tableW = vp.select(parent).append("table")
                .addClass("flexAuto");
            var rowW = tableW.append("tr");
            this._tableElem = tableW[0];
            this._rowElem = rowW[0];
            this._tdElem = null;
            this._colFill = colFill;
        }
        gridLayoutClass.prototype.getParent = function () {
            return this._parent;
        };
        gridLayoutClass.prototype.deleteCurrentRowIfEmpty = function () {
            var rowElem = this._rowElem;
            if (rowElem && rowElem.childElementCount < 2) {
                var deleteElem = true;
                if (rowElem.childElementCount == 1) {
                    var tdElem = rowElem.childNodes[0];
                    if (tdElem.childElementCount > 0) {
                        deleteElem = false;
                    }
                }
                if (deleteElem) {
                    var rowCount = this._tableElem.rows.length;
                    this._tableElem.deleteRow(rowCount - 1);
                }
            }
        };
        gridLayoutClass.prototype.setRowHeight = function (height, rowId) {
            if (this._rowElem && (height !== undefined || rowId)) {
                var prevW = vp.select(this._rowElem)
                    .css("font-size", "0") // make the row height adjustable
                    .css("height", height + "px");
                if (rowId) {
                    prevW
                        .id(rowId);
                }
            }
        };
        gridLayoutClass.prototype.getNextHolder = function (sameCell, newRow, currentRowHeight, rowId) {
            if (newRow) {
                var rowW = vp.select(this._tableElem).append("tr");
                this._rowElem = rowW[0];
                this._tdElem = null;
            }
            else if (sameCell) {
                if (this._tdElem) {
                    var tdW = vp.select(this._tdElem);
                }
            }
            if (!tdW) {
                var tdW = vp.select(this._rowElem).append("td");
                this._tdElem = tdW[0];
            }
            else if (sameCell) {
            }
            if (!this._colFill) {
                tdW
                    .css("display", "inline-block");
            }
            if (this._cellPadding) {
                //tdW.css("padding-left", this._cellPadding)
                tdW.css("padding-right", this._cellPadding);
            }
            this._tdElem = tdW[0];
            return tdW;
        };
        gridLayoutClass.prototype.getCurrentTable = function () {
            return vp.select(this._tableElem);
        };
        gridLayoutClass.prototype.getCurrentHolder = function () {
            if (!this._tdElem) {
                throw "gridLayout.getCurrentHolder: holder is empty";
            }
            return vp.select(this._tdElem);
        };
        gridLayoutClass.prototype.getPreviousHolder = function () {
            if (!this._rowElem) {
                throw "gridLayout.getPreviousHolder: row is empty";
            }
            var rowElem = this._rowElem;
            var count = rowElem.cells.length;
            var prevElem = rowElem.cells[count - 2];
            var prevW = vp.select(prevElem);
            return prevW;
        };
        gridLayoutClass.prototype.getCurrentRow = function () {
            if (!this._rowElem) {
                throw "gridLayout.getCurrentRow: row is empty";
            }
            return vp.select(this._rowElem);
        };
        gridLayoutClass.prototype.getCurrentElement = function (omitEmptyError) {
            if (!this._tdElem) {
                throw "gridLayout.getCurrentElement: holder is empty";
            }
            var elem = this._tdElem.firstElementChild;
            if (!elem && !omitEmptyError) {
                throw "gridLayout.getCurrentElement: holder child is empty";
            }
            return vp.select(elem);
        };
        gridLayoutClass.prototype.addElemToHolder = function (elem) {
            if (!this._tdElem) {
                throw "gridLayout.addElemToHolder: holder is empty";
            }
            vp.select(this._tdElem).append(elem);
        };
        return gridLayoutClass;
    }(beachParty.dataChangerClass));
    beachParty.gridLayoutClass = gridLayoutClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    paletteMgr.ts - manages the standard and cached 3rd pary color palettes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var paletteMgrClass = (function (_super) {
        __extends(paletteMgrClass, _super);
        //_paletteSetName = "Sequential";
        function paletteMgrClass(app) {
            _super.call(this);
            this._app = app;
        }
        paletteMgrClass.prototype.getPaletteItems = function () {
            return beachParty.palettesPanelMgr.getPaletteItems();
        };
        paletteMgrClass.prototype.getPaletteFromStepMap = function (stepMap, steps) {
            //---- find palette whose steps mostly closely match "steps" ----
            var keys = vp.utils.keys(stepMap);
            var palette = null;
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (+key >= steps || i == (keys.length - 1)) {
                    palette = stepMap[key];
                    if (palette.length < +key) {
                        palette = vp.colorPalettes.interpolate(palette, +key);
                    }
                    break;
                }
            }
            return palette;
        };
        paletteMgrClass.prototype.getPaletteArrayFromStepMap = function (ps, steps) {
            //---- extract the entires that match "steps" (or closest to it) ----
            var psm = ps.paletteStepMap;
            var keys = vp.utils.keys(psm);
            var stepArray = keys.map(function (key) { return psm[key]; });
            var array = [];
            //---- process each stepMap ----
            for (var i = 0; i < stepArray.length; i++) {
                var stepMap = stepArray[i];
                var palette = this.getPaletteFromStepMap(stepMap, steps);
                //---- ensure we are not returning more than "steps" entries ----
                if (palette.length > steps) {
                    palette = palette.slice(0, steps);
                }
                else {
                    //---- make a copy of values that is safe to change ----
                    palette = vp.utils.copyArray(palette);
                }
                var np = new beachParty.NamedPalette(keys[i], palette);
                array.push(np);
            }
            return array;
        };
        paletteMgrClass.prototype.getPaletteFromSettings = function (psName, paletteName, steps, isReversed, isInverted) {
            var pa = this.getPaletteArray(psName, steps, isReversed, isInverted);
            var palette = null;
            for (var i = 0; i < pa.palettes.length; i++) {
                if (pa.palettes[i].name == paletteName) {
                    palette = pa.palettes[i];
                    break;
                }
            }
            return palette;
        };
        paletteMgrClass.prototype.getPaletteArray = function (name, steps, isReversed, isInverted) {
            if (!name) {
                name = "sequential"; // default
            }
            //---- load from cache or server ----
            var ps = beachParty.loadUserResource(name, beachParty.StorageType.palette, "palettes");
            //if (ps.paletteMap)
            //{
            //    var array = this.getPaletteArrayFromMap(ps, steps);
            //}
            //else
            {
                var array = this.getPaletteArrayFromStepMap(ps, steps);
            }
            if (isReversed || isInverted) {
                for (var i = 0; i < array.length; i++) {
                    var palette = array[i];
                    //---- process REVERSED ----
                    if (isReversed) {
                        palette.values = palette.values.reverse();
                    }
                    //---- process INVERT ----
                    if (isInverted) {
                        this.invertPalette(palette);
                    }
                }
            }
            var pa = new NamedPaletteArray(ps.paletteSetName, array);
            return pa;
        };
        paletteMgrClass.prototype.invertPalette = function (palette) {
            for (var i = 0; i < palette.values.length; i++) {
                palette.values[i] = this.invertThisColor(palette.values[i]);
            }
        };
        paletteMgrClass.prototype.invertThisColor = function (cr) {
            var rgbArray = vp.color.getColorFromString(cr);
            //---- invert the color components for this color ----
            for (var c = 0; c < 3; c++) {
                rgbArray[c] = 255 - rgbArray[c];
            }
            //---- convert back to color string ----
            var newCr = vp.color.toColor(rgbArray);
            return newCr;
        };
        paletteMgrClass.prototype.buildPaletteDiv = function (colorAttr, palette, showSteps) {
            var entryHeight = 18;
            var cm = colorAttr.mappingData();
            var itemW = vp.select(document.createElement("div"))
                .addClass("listColorPaletteItem")
                .css("font-size", "0");
            var divW = itemW.append("span")
                .addClass("listColorPalette")
                .css("width", "200px")
                .css("display", "inline-block")
                .css("height", entryHeight + "px");
            var textW = itemW.append("span")
                .addClass("clipText listColorPaletteName")
                .text(palette.name)
                .css("position", "relative")
                .css("height", "18px");
            //textW
            //    .css("font-size", "16px")
            if (palette.name == cm.paletteName) {
                textW
                    .addClass("listColorPaletteNameSelected");
            }
            var paletteCount = colorAttr.stepsRequested();
            var entryWidth = (200 / paletteCount); // - 1;
            if (showSteps) {
                for (var i = 0; i < palette.values.length; i++) {
                    var bgColor = vp.color.colorFromPalette(palette.values, i);
                    var entryW = divW.append("span")
                        .addClass("listColorPaletteEntry")
                        .css("width", entryWidth + "px")
                        .css("height", entryHeight + "px")
                        .css("margin", "0px")
                        .css("padding", "0px")
                        .css("background", bgColor);
                }
            }
            else {
                //---- linear gradient, from left to right ----
                var str = "";
                for (var i = 0; i < palette.values.length; i++) {
                    var bgColor = vp.color.colorFromPalette(palette.values, i);
                    str += ", " + bgColor;
                }
                var width = palette.values.length * entryWidth;
                var entryW = divW.append("span")
                    .addClass("listColorPaletteGradient")
                    .css("height", entryHeight + "px")
                    .css("width", width + "px")
                    .css("background", "linear-gradient(to right" + str + ")");
            }
            return itemW[0];
        };
        /** used to build palette list in colorPanel. */
        paletteMgrClass.prototype.getColorPaletteEntry = function (colorAttr, index) {
            var entryElem = null;
            var cm = colorAttr.mappingData();
            if (cm) {
                var showSteps = (!cm.isContinuous);
                //---- return HTML for custom list item ----
                if (index == 0) {
                    //---- go extract it on the first item ----
                    var paletteArray = this.getColorPalettes(colorAttr);
                    this._cachedPaletteArray = paletteArray;
                }
                else {
                    //---- use cached copy for subsequent items ----
                    var paletteArray = this._cachedPaletteArray;
                }
                var palettes = paletteArray.palettes;
                var palette = (index >= palettes.length) ? null : palettes[index];
                if (palette) {
                    entryElem = this.buildPaletteDiv(colorAttr, palette, showSteps);
                }
            }
            return entryElem;
        };
        paletteMgrClass.prototype.getColorPalettes = function (colorAttr) {
            var cm = colorAttr.mappingData();
            var stepsRequested = colorAttr.stepsRequested();
            var pa = this.getPaletteArray(cm.paletteSetName, stepsRequested, cm.isReversed, cm.isInverted);
            return pa;
        };
        paletteMgrClass.prototype.colorPaletteIndex = function (colorAttr, index) {
            var cm = colorAttr.mappingData();
            if (arguments.length == 0) {
                return 0; // not known
            }
            var paletteArray = this.getColorPalettes(colorAttr);
            var palette = paletteArray.palettes[index];
            //---- avoid 2 passes thru all color calculations by setting these properties directly ----
            cm.paletteSetName = paletteArray.paletteSetName;
            cm.paletteName = palette.name;
            colorAttr.colorPalette(palette); //.values);
            //---- tell the color panel that a user action just happened ----
            //---- so that it can dismiss the panel, if appropriate ----
            var pm = this._app.getPanelMaster();
            var panel = pm.getPanelMgr("colorPanel").getJsonPanel();
            panel.onUserAction(null, false, beachParty.Gesture.notAvailable, beachParty.ElementType.notAvailable, "colorPaletteIndex");
            this.onDataChanged("colorPaletteIndex");
        };
        return paletteMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.paletteMgrClass = paletteMgrClass;
    //---- an internal form of a palette set ----
    var NamedPaletteArray = (function () {
        function NamedPaletteArray(name, palettes) {
            this.paletteSetName = name;
            this.palettes = palettes;
        }
        return NamedPaletteArray;
    }());
    beachParty.NamedPaletteArray = NamedPaletteArray;
    var PaletteSet = (function () {
        function PaletteSet() {
        }
        return PaletteSet;
    }());
    beachParty.PaletteSet = PaletteSet;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    themeMgr.ts - manages the loading and application of UI themes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var themeMgrClass = (function (_super) {
        __extends(themeMgrClass, _super);
        function themeMgrClass(app) {
            _super.call(this);
            this._app = app;
            //---- create an initial theme, so that early init code works correctly ----
            var themeName = window.themeName; // set by HTML loading code
            this.onThemeChanged(themeName, false);
            //this._theme = loadUserResource("BlacksBeach", StorageType.theme, "themes");
        }
        themeMgrClass.prototype.parseLessFile = function (strLess) {
            var propMap = {};
            var css = "";
            var firstRuleSeen = false;
            //---- fixup comment markers (used to embed our file in a javascript string) ----
            strLess = strLess.replace(/@\*/g, "/*");
            strLess = strLess.replace(/\*@/g, "*/");
            //---- split into lines ----
            if (strLess.contains("\r\n")) {
                var lines = strLess.split("\r\n");
            }
            else {
                var lines = strLess.split("\n");
            }
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                if (line.startsWith("@")) {
                    //---- process variable declaration ----
                    var index = line.indexOf(":");
                    if (index == -1) {
                        throw "missing ':' in THEME variable declaration";
                    }
                    var name = line.substr(1, index - 1);
                    var strValue = line.substr(index + 1).trim();
                    var value = null;
                    var index = strValue.indexOf(";");
                    if (index == -1) {
                        throw "missing ';' at end of variable declaration";
                    }
                    strValue = strValue.substr(0, index).trim();
                    //---- BOOLEAN ----
                    if (strValue == "true" || strValue == "false") {
                        value = (strValue == "true");
                    }
                    else if (strValue == "null") {
                        value = null;
                    }
                    else {
                        //---- NUMBER ----
                        var num = +strValue;
                        if (!isNaN(num)) {
                            value = num;
                        }
                        else {
                            //---- must be a string ----
                            if (strValue.startsWith("\"")) {
                                value = strValue.substr(1, strValue.length - 2);
                            }
                            else {
                                value = strValue;
                            }
                        }
                    }
                    propMap[name] = value;
                }
                else {
                    if (!firstRuleSeen && line.contains("{")) {
                        firstRuleSeen = true;
                    }
                    if (firstRuleSeen) {
                        css += line + "\r\n";
                    }
                }
            }
            return { propMap: propMap, css: css };
        };
        //---- used to have an initial theme loaded so early init code works correctly ---
        themeMgrClass.prototype.loadCachedCurrentTheme = function () {
            //var strLess = localStorageMgr.get(StorageType.currentTheme,
            //    StorageSubType.local, null);
            //if (!strLess)
            //{
            //    //---- fallback to default theme ----
            //    strTheme = loadUserResource("BlacksBeach", StorageType.theme, "themes");
            //}
            //if (strLess)
            //{
            //    //var theme = JSON.parse(strTheme);
            //    this._theme = this.parseLessFile(strLess);
            //}
            //this.expandThemePanels(theme);
            //this._theme = theme;
        };
        //processThemeString(str: string)
        //{
        //    //---- new theme system ----
        //    var strLess = loadUserResourceAsString(fn, StorageType.theme, "themes");
        //}
        themeMgrClass.prototype.onThemeChanged = function (value, overwriteAppSettings) {
            //---- system theme ----
            var strLess = beachParty.loadUserResourceAsString(value, beachParty.StorageType.theme, "themes", ".less");
            if (strLess) {
                var theme = this.parseLessFile(strLess);
                this.applyTheme(theme, overwriteAppSettings);
            }
        };
        themeMgrClass.prototype.startNewStyleSheet = function () {
            if (this._appStyleSheet) {
                this._appStyleSheet.remove();
            }
            this._appStyleSheet = new vp.dom.styleSheetClass()
                .id("appStyleSheet");
        };
        themeMgrClass.prototype.getTheme = function () {
            return this._newTheme;
        };
        themeMgrClass.prototype.getIconPath = function (panelName) {
            //var panel = <ThemePanel>this._theme[panelName];
            //return panel.iconPath;
            return this._newTheme.propMap.iconPath;
        };
        themeMgrClass.prototype.applyCss = function (css) {
            var oldTheme = document.getElementById("themeCssFile");
            if (oldTheme) {
                oldTheme.innerHTML = css;
            }
            else {
                var styleElem = document.createElement("style");
                styleElem.innerHTML = css;
                styleElem.id = "themeCssFile";
                document.getElementsByTagName("head")[0].appendChild(styleElem);
            }
            //---- someone is writing body.background - clear it here ----
            vp.select(document.body).css("background", "");
        };
        themeMgrClass.prototype.applyTheme = function (theme, overwriteAppSettings) {
            //this._theme = theme;
            this._newTheme = theme;
            if (overwriteAppSettings) {
                this._app._appSettingsMgr.overwriteAppSettings(theme.propMap);
            }
            this.applyCss(theme.css);
            this._app.updateIconNames();
            //---- layout screen for logo and potentially other theme-related reasons ----
            this._app.layoutScreen("themeMgr.applyTheme");
        };
        themeMgrClass.prototype.matchPanelIcons = function (selector, panelName) {
            var _this = this;
            vp.select(selector).each(function (index, elem) {
                if (elem.length) {
                    elem = elem[0];
                }
                beachParty.matchIconsToTheme(_this._app._themeMgr, elem, panelName);
            });
        };
        themeMgrClass.prototype.onThemeLoaded = function (theme) {
            //---- cache this theme for early-loading purposes ----
            var strTheme = JSON.stringify(theme);
            beachParty.localStorageMgr.save(beachParty.StorageType.currentTheme, beachParty.StorageSubType.local, null, strTheme);
            this.onDataChanged("theme");
        };
        return themeMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.themeMgrClass = themeMgrClass;
    var ThemePanel = (function () {
        function ThemePanel() {
        }
        return ThemePanel;
    }());
    beachParty.ThemePanel = ThemePanel;
    var PaletteData = (function () {
        function PaletteData(set, name, isInverted, isReversed) {
            this.set = set;
            this.name = name;
            this.isInverted = isInverted;
            this.isReversed = isReversed;
        }
        return PaletteData;
    }());
    beachParty.PaletteData = PaletteData;
    var PropMap = (function () {
        function PropMap() {
        }
        return PropMap;
    }());
    beachParty.PropMap = PropMap;
    var NewThemeData = (function () {
        function NewThemeData() {
        }
        return NewThemeData;
    }());
    beachParty.NewThemeData = NewThemeData;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    scriptRecorder.ts - manages the logging of user commands.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var scriptRecorderClass = (function (_super) {
        __extends(scriptRecorderClass, _super);
        function scriptRecorderClass(settings) {
            _super.call(this);
            this._isRecording = false;
            var value = settings.recordNextSession();
            if (value) {
                this.startNewSession();
            }
        }
        scriptRecorderClass.prototype.isRecording = function () {
            return this._isRecording;
        };
        scriptRecorderClass.prototype.startNewSession = function () {
            var sd = new ScriptData();
            this._sd = sd;
            var now = new Date();
            var fnNow = vp.formatters.formatDateTime(now, "mmm-dd-yyyy_hh:mm:ss");
            var strNow = vp.formatters.formatDateTime(now, "mmm-dd-yyyy hh:mm:ss");
            sd.scriptName = "Session_" + fnNow + ".json";
            sd.writtenBy = "(recorded by SandDance)";
            sd.dateWritten = strNow;
            sd.repeatCount = 1;
            sd.plotResults = false;
            sd.description = "Recording of commands run in the SandDance session that started at: " + strNow;
            sd.cmdDelay = 1500;
            sd.stopOnError = true;
            sd.cmds = [];
            this._cmds = sd.cmds;
            this._isRecording = true;
            this.onDataChanged("isRecording");
        };
        scriptRecorderClass.prototype.endSession = function () {
            this.save();
            this._sd = null;
            this._cmds = null;
            this._isRecording = false;
            this.onDataChanged("isRecording");
        };
        scriptRecorderClass.prototype.log = function (cmd) {
            if (this._isRecording) {
                this._cmds.push(cmd);
                vp.utils.debug("userLogMgr.log: cmd=" + JSON.stringify(cmd));
            }
        };
        scriptRecorderClass.prototype.addLine = function (str, sd, propName) {
            var valueStr = JSON.stringify(sd[propName]);
            str += "  \"" + propName + "\": " + valueStr + ",\r\n";
            return str;
        };
        scriptRecorderClass.prototype.cmdToJson = function (cmdObj) {
            var str = "{";
            var keys = vp.utils.keys(cmdObj);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                str += "\"" + key + "\": ";
                //---- the value ----
                str += JSON.stringify(cmdObj[key]);
                if (i < keys.length - 1) {
                    str += ", ";
                }
            }
            str += "}";
            return str;
        };
        /**
         *  use our own JSON formatting so user can more easily read and edit the resulting file.
         */
        scriptRecorderClass.prototype.scriptDataToJson = function () {
            var sd = this._sd;
            var str = "{ \r\n";
            str = this.addLine(str, sd, "scriptName");
            str = this.addLine(str, sd, "writtenBy");
            str = this.addLine(str, sd, "dateWritten");
            str = this.addLine(str, sd, "description");
            str += "\r\n";
            str = this.addLine(str, sd, "repeatCount");
            str = this.addLine(str, sd, "plotResults");
            str = this.addLine(str, sd, "cmdDelay");
            str = this.addLine(str, sd, "stopOnError");
            str += "\r\n";
            str += "  \"cmds\":\r\n";
            str += "  [\r\n";
            //---- process CMDS ----
            for (var i = 0; i < sd.cmds.length; i++) {
                var cmd = sd.cmds[i];
                str += "    " + this.cmdToJson(cmd);
                if (i == sd.cmds.length - 1) {
                    str += "\r\n";
                }
                else {
                    str += ",\r\n";
                }
            }
            str += "  ]\r\n";
            str += "}\r\n";
            return str;
        };
        scriptRecorderClass.prototype.save = function () {
            //---- use our own JSON formatting so user can more easily read and edit the resulting file ----
            var strJson = this.scriptDataToJson();
            beachParty.localStorageMgr.save(beachParty.StorageType.script, beachParty.StorageSubType.local, this._sd.scriptName, strJson);
        };
        return scriptRecorderClass;
    }(beachParty.dataChangerClass));
    beachParty.scriptRecorderClass = scriptRecorderClass;
    var ScriptData = (function () {
        function ScriptData() {
            this.cmds = [];
        }
        return ScriptData;
    }());
    beachParty.ScriptData = ScriptData;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    cmdHistory.ts - manages a stack of cmds for an associated textbox control.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var cmdHistoryClass = (function (_super) {
        __extends(cmdHistoryClass, _super);
        function cmdHistoryClass() {
            _super.call(this);
            this._stack = [];
            this._index = -.5; // normally points to top entry on stack (which UP ARROW will select)
            this._maxLevels = 25;
        }
        cmdHistoryClass.prototype.getCmd = function (dir) {
            //---- move index onto a valid integer ----
            var index = this._index + dir / 2;
            var cmd = null;
            if (index > -1 && index < this._stack.length) {
                cmd = this._stack[index];
                //---- update index ----
                this._index = Math.max(.5, Math.min(this._stack.length - 1.5, index + dir / 2));
                vp.utils.debug("getCmd: index=" + this._index);
            }
            return cmd;
        };
        cmdHistoryClass.prototype.pushCmd = function (cmd) {
            var stack = this._stack;
            var index = this._index;
            var isInMiddle = false;
            if (index < stack.length - 1) {
                //---- running new cmd in middle of a "back" sequence ----
                //---- we allow this, but will copy the cmd to the top of the stack ----
                isInMiddle = true;
            }
            if (stack.length + 1 > this._maxLevels) {
                //---- too many cmds; must remove oldest entry in stack ----
                stack = stack.slice(1);
            }
            stack.push(cmd);
            this._index = stack.length - .5; // top of stack
            this._stack = stack;
            this.onDataChanged("cmdHistory");
            vp.utils.debug("pushCmd: index=" + this._index);
        };
        return cmdHistoryClass;
    }(beachParty.dataChangerClass));
    beachParty.cmdHistoryClass = cmdHistoryClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    selectionMgr.ts - manages the selection history and shortcuts.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var selectionMgrClass = (function (_super) {
        __extends(selectionMgrClass, _super);
        function selectionMgrClass(app) {
            _super.call(this);
            this._app = app;
        }
        return selectionMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.selectionMgrClass = selectionMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    filterMgr.ts - manages the filter history and shortcuts.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var filterMgrClass = (function (_super) {
        __extends(filterMgrClass, _super);
        function filterMgrClass(app) {
            _super.call(this);
            this._app = app;
        }
        return filterMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.filterMgrClass = filterMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    itemsPanelMgr.ts - manages the SandDance aggregation panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var itemsPanelMgr = (function (_super) {
        __extends(itemsPanelMgr, _super);
        function itemsPanelMgr(app, buttonId) {
            var _this = this;
            _super.call(this);
            this._app = app;
            var rc = this.getButtonRect(buttonId);
            var x = rc.left;
            var y = rc.bottom;
            var chart = this._app.currentChart();
            var preload = chart.getPreload();
            //if (preload.dataSampling)
            //{
            //    this._sampleCount = settings.autoSamplingSampleCount();
            //    this._isSampEnabled = (app._trueRecordCount != app._recordCount);
            //    this._itemType = "sampling";
            //}
            //else if (preload.dataAggregation)
            //{
            //    this._aggType = preload.dataAggregation.aggType;
            //    this._itemType = "aggregation";
            //}
            //else
            //{
            //    this._itemType = "allUnits";
            //}
            //---- bigDataMgr handles all of the panel-bound properties and methods ----
            var propMgr = [this, this._app._bigDataMgr];
            var jsonPanel = beachParty.buildJsonPanel(this._app, buttonId, propMgr, "itemsPanel", true, x, y, undefined, undefined, undefined, undefined, undefined, "bbItems");
            this._jsonPanel = jsonPanel;
            jsonPanel.registerForChange("close", function (e) {
                _this.onDataChanged("close");
            });
            this.applyTransform();
            //jsonPanel.isFloating(false);
            var showTabs = this._app._appSettingsMgr.showInProgressUI();
            for (var i = 1; i < 8; i++) {
                jsonPanel.showTab("tab" + i, showTabs);
            }
        }
        itemsPanelMgr.prototype.applyTransform = function () {
            var chart = this._app.currentChart();
            var itemCount = chart.getFilteredInCount();
            this.fileItemCount(itemCount);
            this.transformItemCount(itemCount);
        };
        itemsPanelMgr.prototype.fileItemCount = function (value) {
            if (arguments.length == 0) {
                return this._fileItemCount;
            }
            this._fileItemCount = value;
            this.onDataChanged("fileItemCount");
        };
        itemsPanelMgr.prototype.transformItemCount = function (value) {
            if (arguments.length == 0) {
                return this._transformItemCount;
            }
            this._transformItemCount = value;
            this.onDataChanged("transformItemCount");
        };
        return itemsPanelMgr;
    }(beachParty.baseJsonControlClass));
    beachParty.itemsPanelMgr = itemsPanelMgr;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    baseResourcePanelMgr.ts - base class for resource-style panel mgrs (e.g., scripts, themes, tours,palettes).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var baseResourcePanelMgr = (function (_super) {
        __extends(baseResourcePanelMgr, _super);
        function baseResourcePanelMgr(app, buttonId, panelName, resourceType, defaultResourceName, knownResourceFolder) {
            _super.call(this);
            this._contextMenu = null;
            this._app = app;
            if (arguments.length > 0) {
                this.init(buttonId, panelName, resourceType, defaultResourceName, knownResourceFolder);
            }
        }
        baseResourcePanelMgr.addHostResource = function (fullName, value) {
            fullName = fullName.toLowerCase();
            //alert("adding host resource inner: " + fullName);
            baseResourcePanelMgr.hostResources[fullName] = value;
        };
        baseResourcePanelMgr.prototype.init = function (buttonId, panelName, resourceType, defaultResourceName, knownResourceFolder) {
            var _this = this;
            this._currentResourceName = defaultResourceName;
            this._defaultResourceName = defaultResourceName;
            this._resourceType = resourceType;
            this._knownResourceFolder = knownResourceFolder;
            //---- some classes use this only as a resource loader ----
            if (panelName) {
                var jsonPanel = beachParty.buildJsonPanel(this._app, buttonId, this, panelName, true, undefined, undefined, undefined, undefined, undefined, undefined, undefined, buttonId);
                this._jsonPanel = jsonPanel;
                jsonPanel.registerForChange("close", function (e) {
                    _this.onDataChanged("close");
                });
                //---- hook selection of menu item ----
                var menuW = vp.select(jsonPanel.getRootElem(), "#btMenu")
                    .attach("click", function (e) {
                    _this.showResourceMenu(e);
                });
                var rcPanel = vp.select(jsonPanel.getRootElem()).getBounds();
                var ptx = this._app._panelMaster.getBestPanelLocation(rcPanel, buttonId, beachParty.ButtonAlign.belowButton);
                //---- show our panel now ----
                this.showAt(ptx.x, ptx.y, ptx.x2, ptx.y2);
            }
        };
        //---- subclass should OVERRIDE this function ----
        baseResourcePanelMgr.prototype.setResourceName = function (value) {
            this._currentResourceName = value;
        };
        //---- subclass should OVERRIDE this function ----
        baseResourcePanelMgr.prototype.getResourceItems = function () {
            var resources = [];
            return resources;
        };
        baseResourcePanelMgr.prototype.editItemName = function (value) {
            if (arguments.length == 0) {
                return this._editItemName;
            }
            this._editItemName = value;
            this.onDataChanged("editItemName");
        };
        baseResourcePanelMgr.prototype.getMenuItems = function () {
            var resource = beachParty.StorageType[this._resourceType];
            var items = [
                new beachParty.MenuItemData("Import...", "Load a " + resource + " file from your local machine"),
                new beachParty.MenuItemData("Export...", "Save the current " + resource + " file to your local machine"),
                new beachParty.MenuItemData("-"),
                new beachParty.MenuItemData("Rename...", "Rename the current " + resource + " file"),
                new beachParty.MenuItemData("Delete", "Delete the currrent " + resource + " file"),
            ];
            return items;
        };
        baseResourcePanelMgr.prototype.onRenameOK = function () {
            var newFn = this._editItemName;
            if (!newFn.contains(".")) {
                newFn += ".json";
            }
            beachParty.localStorageMgr.rename(this._resourceType, beachParty.StorageSubType.local, this._currentResourceName, newFn);
            this._app.logAction(beachParty.Gesture.click, "rename", beachParty.ElementType.menuItem, beachParty.Action.rename, beachParty.Target.userResource, false, { resourceType: beachParty.StorageType[this._resourceType] });
            this.setResourceName(newFn);
        };
        baseResourcePanelMgr.prototype.showResourceMenu = function (e) {
            var _this = this;
            //---- invoke the SCRIPT CONTEXT MENU ----
            var menuItems = this.getMenuItems();
            var pm = new beachParty.popupMenuClass(this._app, null, "pmResource", menuItems, function (e, menu, textIndex, menuIndex) {
                var name = menuItems[menuIndex].text;
                if (name.startsWith("Import")) {
                    _this.loadResourceFromFile(e);
                }
                else if (name.startsWith("Export")) {
                    _this.saveResourceToFile(e);
                }
                else if (name.startsWith("Rename")) {
                    _this.renameResourceFile(e);
                }
                else if (name.startsWith("Delete")) {
                    _this.deleteResourceFile(e);
                }
            }, true);
            var rc = vp.select(this._jsonPanel.getRootElem(), "#btMenu").getBounds(false);
            pm.showAt(rc.left + 8, rc.bottom);
            this._contextMenu = pm;
            return pm;
        };
        baseResourcePanelMgr.prototype.loadResourceFromFile = function (e) {
            var _this = this;
            var settings = this._app._appSettingsMgr;
            beachParty.localFileHelper.loadFile(settings, ".json", function (text, fn) {
                var tour = JSON.parse(text);
                //---- cache it for later use-of-picking ----
                beachParty.localStorageMgr.save(_this._resourceType, beachParty.StorageSubType.local, fn, text);
                _this._app.logAction(beachParty.Gesture.click, "import", beachParty.ElementType.menuItem, beachParty.Action.import, beachParty.Target.userResource, false, { resourceType: beachParty.StorageType[_this._resourceType] });
                //---- set the new current resource ----
                _this.setResourceName(fn);
            });
        };
        baseResourcePanelMgr.prototype.saveResourceToFile = function (e) {
            //---- TODO: make "loadCurrentResourceAsString" consistenly return a string ----
            var strJson = this.loadCurrentResourceAsString();
            if (!vp.utils.isString(strJson)) {
                strJson = JSON.stringify(strJson);
            }
            var fn = this._currentResourceName;
            if (!fn.contains(".")) {
                fn += ".json";
            }
            beachParty.localFileHelper.saveToLocalFile(fn, strJson);
            this._app.logAction(beachParty.Gesture.click, "export", beachParty.ElementType.menuItem, beachParty.Action.export, beachParty.Target.userResource, false, { resourceType: beachParty.StorageType[this._resourceType] });
        };
        baseResourcePanelMgr.prototype.deleteResourceFile = function (e) {
            var fn = this._currentResourceName;
            //---- delete this file from cache or list of "standard resources" ----
            beachParty.localStorageMgr.delete(this._resourceType, beachParty.StorageSubType.local, fn);
            this._app.logAction(beachParty.Gesture.click, "delete", beachParty.ElementType.menuItem, beachParty.Action.delete, beachParty.Target.userResource, false, { name: fn, resourceType: beachParty.StorageType[this._resourceType] });
            //---- set the new current resource ----
            this.setResourceName(this._defaultResourceName);
        };
        baseResourcePanelMgr.prototype.renameResourceFile = function (e) {
            this._editItemName = this._currentResourceName;
            var renamePanel = beachParty.buildJsonPanel(this._app, null, this, "renamePanel", true);
        };
        baseResourcePanelMgr.prototype.rebuildResourceList = function () {
            var items = this.getResourceItems();
            //---- set the new current resource ----
            if (items.length) {
                this.setResourceName(items[items.length - 1]);
            }
            else {
                this.setResourceName("");
            }
        };
        baseResourcePanelMgr.prototype.loadCurrentResourceAsString = function () {
            return loadUserResourceAsString(this._currentResourceName, this._resourceType, this._knownResourceFolder);
        };
        baseResourcePanelMgr.prototype.loadCurrentResource = function () {
            return loadUserResource(this._currentResourceName, this._resourceType, this._knownResourceFolder);
        };
        //---- resources loaded by the host of our app (WinSandDance or Power BI) ----
        baseResourcePanelMgr.hostResources = {};
        return baseResourcePanelMgr;
    }(beachParty.baseJsonControlClass));
    beachParty.baseResourcePanelMgr = baseResourcePanelMgr;
    /**
     * This loads a user resource from memory (if it was present in the userResources.js file), or
     * from our localStorage (via localStorageMgr).
     * @param fn
     * @param resType
     * @param resFolder
     * @param fileExt
     */
    function loadUserResourceAsString(fn, resType, resFolder, fileExt) {
        if (fn.contains(".")) {
            var strJson = beachParty.localStorageMgr.get(resType, beachParty.StorageSubType.local, fn);
        }
        else {
            if (!fileExt) {
                fileExt = ".json";
            }
            var fullName = resFolder + "/" + fn + fileExt;
            fullName = fullName.toLowerCase();
            resFolder = resFolder.toLowerCase();
            fn = fn.toLowerCase();
            var strJson = window["userResources"][resFolder][fn];
            if (!strJson) {
                strJson = baseResourcePanelMgr.hostResources[fullName];
            }
            if (window.external && window.external.isHosted) {
            }
            else if (!strJson) {
                strJson = beachParty.fileAccess.readServerTextFile("UserResources/" + fullName);
            }
        }
        return strJson;
    }
    beachParty.loadUserResourceAsString = loadUserResourceAsString;
    function loadUserResource(fn, resType, resFolder, fileExt) {
        var strJson = loadUserResourceAsString(fn, resType, resFolder, fileExt);
        if (vp.utils.isString(strJson)) {
            var resObj = JSON.parse(strJson);
        }
        else if (vp.utils.isObject(strJson)) {
            var resObj = strJson;
        }
        return resObj;
        //var strLess = loadUserResourceAsString(fn, resType, resFolder, ".less");
        //var result = this.parseLessFile(strLess);
        //return result;
    }
    beachParty.loadUserResource = loadUserResource;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    tasksPaneMgr.ts - manages the tasks panel data binding.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var tasksPanelMgrClass = (function (_super) {
        __extends(tasksPanelMgrClass, _super);
        function tasksPanelMgrClass(app, buttonId) {
            var _this = this;
            _super.call(this);
            this._app = app;
            var rc = vp.select("#" + buttonId).getBounds(false);
            var x = rc.left;
            var y = rc.bottom;
            var jsonPanel = beachParty.buildJsonPanel(app, buttonId, this, "tasksPanel", true, x, y, undefined, undefined, undefined, undefined, undefined, "tasksButton");
            this._jsonPanel = jsonPanel;
            jsonPanel.registerForChange("close", function (e) {
                _this.onDataChanged("close");
            });
        }
        tasksPanelMgrClass.prototype.selectView = function (chartType, layoutType, mapColor) {
            var chart = this._app.currentChart();
            chart.changeToChart(chartType, layoutType, beachParty.Gesture.click);
            if (mapColor) {
                var colName = this._app.colorColumn();
                if (!colName) {
                    colName = this._app.pickGoodColorColumn();
                    this._app._colorMgr.colName(colName);
                }
            }
        };
        tasksPanelMgrClass.prototype.selectColumnView = function () {
            this.selectView(beachParty.ChartType.Column);
        };
        tasksPanelMgrClass.prototype.selectBarView = function () {
            this.selectView(beachParty.ChartType.Bar);
        };
        tasksPanelMgrClass.prototype.selectDensityView = function () {
            this.selectView(beachParty.ChartType.Density);
        };
        tasksPanelMgrClass.prototype.selectViolinView = function () {
            this.selectView(beachParty.ChartType.Violin);
        };
        tasksPanelMgrClass.prototype.selectScatterView = function () {
            this.selectView(beachParty.ChartType.Scatter);
        };
        tasksPanelMgrClass.prototype.selectScatter3DView = function () {
            this.selectView(beachParty.ChartType.Scatter3D);
        };
        tasksPanelMgrClass.prototype.selectScatterViewColor = function () {
            this.selectView(beachParty.ChartType.Scatter, undefined, true);
        };
        tasksPanelMgrClass.prototype.selectSquarifyViewColor = function () {
            //---- ensure AUX column is set ----
            var app = this._app;
            if (!app._auxMgr.isSet()) {
                app._auxMgr.colName(app._yMgr.colName());
            }
            this.selectView(beachParty.ChartType.Grid, beachParty.LayoutType.Squarify, true);
        };
        return tasksPanelMgrClass;
    }(beachParty.baseJsonControlClass));
    beachParty.tasksPanelMgrClass = tasksPanelMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    searchPanelMgr.ts - manages the "searchPanel.js" floating panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var searchPanelMgr = (function (_super) {
        __extends(searchPanelMgr, _super);
        function searchPanelMgr(app, buttonId, colName, value) {
            var _this = this;
            if (value === void 0) { value = ""; }
            _super.call(this);
            this._allName = "( All )";
            this._searchType = "startsWith";
            this._isIncrementalSearch = true;
            this._app = app;
            this._searchCol = ""; //colName;
            this._searchValue = value;
            var rc = vp.select("#" + buttonId).getBounds(false);
            var x = rc.left;
            var y = rc.bottom;
            var jsonPanel = beachParty.buildJsonPanel(app, buttonId, this, "searchPanel", true, x, y, undefined, undefined, undefined, undefined, undefined, "searchButton");
            this._jsonPanel = jsonPanel;
            jsonPanel.registerForChange("close", function (e) {
                _this.onDataChanged("close");
            });
        }
        searchPanelMgr.prototype.isIncrementalSearch = function (value) {
            if (arguments.length == 0) {
                return this._isIncrementalSearch;
            }
            this._isIncrementalSearch = value;
            this.onDataChanged("isIncrementalSearch");
            this.applySearchQuery();
        };
        searchPanelMgr.prototype.searchType = function (value) {
            if (arguments.length == 0) {
                return this._searchType;
            }
            this._searchType = value;
            this.onDataChanged("searchType");
            this.applySearchQuery();
        };
        searchPanelMgr.prototype.applySearchQuery = function () {
            var searchCol = this._searchCol;
            var selectMode = beachParty.SelectMode.normal; // for all searches, we just select by match only (no boolean operations)
            if (this._searchType == "startsWith") {
                var searchType = beachParty.TextSearchType.startsWith;
            }
            else if (this._searchType == "exact") {
                var searchType = beachParty.TextSearchType.exactMatch;
            }
            else {
                var searchType = beachParty.TextSearchType.contains;
            }
            var colType = this._app.getColType(searchCol);
            if (colType == "number") {
                this._app.applySearchPanelParams(event, searchCol, this._searchValue, selectMode, searchType);
            }
            else {
                var sp = new beachParty.SearchParams();
                sp.colName = searchCol;
                sp.minValue = this._searchValue;
                sp.caseSensitiveSearch = false;
                sp.searchAction = beachParty.SearchAction.selectMatches;
                sp.selectMode = selectMode;
                sp.searchType = searchType;
                if (this._searchValue.length > 0) {
                    this._app.currentChart().searchEx([sp]);
                }
                else {
                    this._app.currentChart().clearSelection();
                }
            }
        };
        searchPanelMgr.prototype.searchCol = function (value) {
            if (arguments.length == 0) {
                return this._searchCol;
            }
            if (value == this._allName) {
                value = null;
            }
            this._searchCol = value;
            this.onDataChanged("searchCol");
            this.applySearchQuery();
        };
        searchPanelMgr.prototype.searchValue = function (value, incremental) {
            if (arguments.length == 0) {
                return this._searchValue;
            }
            if (!incremental || this._isIncrementalSearch) {
                this._searchValue = value;
                this.onDataChanged("searchValue");
                this.applySearchQuery();
            }
        };
        return searchPanelMgr;
    }(beachParty.baseJsonControlClass));
    beachParty.searchPanelMgr = searchPanelMgr;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    themesPanelMgr.ts - manages the Themes panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var themesPanelMgr = (function (_super) {
        __extends(themesPanelMgr, _super);
        function themesPanelMgr(app, buttonId) {
            _super.call(this, app, buttonId, "themesPanel", beachParty.StorageType.theme, "BlacksBeach", "themes");
        }
        themesPanelMgr.prototype.themeName = function (value) {
            if (arguments.length == 0) {
                return this._currentResourceName;
            }
            this._currentResourceName = value;
            this.onDataChanged("themeName");
        };
        themesPanelMgr.prototype.setResourceName = function (value) {
            this.themeName(value);
        };
        themesPanelMgr.prototype.getResourceItems = function () {
            return themesPanelMgr.getThemeItems();
        };
        themesPanelMgr.getThemeItems = function () {
            //---- start with standard THEMES ----
            var themes = ["BlacksBeach", "PowerBI", "DemoTheme"]; //"BBOneText", "BBOneIcon", "DemoTheme", "PowerBITop", "PowerBIRight"];
            var cachedThemes = beachParty.localStorageMgr.enumerate(beachParty.StorageType.theme, beachParty.StorageSubType.local, true);
            themes = themes.concat(cachedThemes);
            return themes;
        };
        //---- called from themesPanel.ts ----
        themesPanelMgr.prototype.onLoadTheme = function () {
            var settings = this._app._appSettingsMgr;
            settings.themeName(this._currentResourceName, true);
        };
        return themesPanelMgr;
    }(beachParty.baseResourcePanelMgr));
    beachParty.themesPanelMgr = themesPanelMgr;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    browsePanelMgr.ts - manages the facet browser panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var browsePanelMgr = (function (_super) {
        __extends(browsePanelMgr, _super);
        function browsePanelMgr(app, buttonId, colName, value) {
            var _this = this;
            if (value === void 0) { value = ""; }
            _super.call(this);
            this._nextNodeId = 1;
            this._searchNodes = [];
            this._isIncrementalSearch = false;
            this._isMultiSearchPanes = false;
            this._isolateMatches = false;
            this._app = app;
            this._searchCol = colName;
            this._searchValue = value;
            var rc = vp.select("#" + buttonId).getBounds(false);
            var x = rc.left;
            var y = rc.bottom;
            var jsonPanel = beachParty.buildJsonPanel(this._app, buttonId, this, "browsePanel", true, x, y, null, null, null, null, false, "browseButton");
            this._jsonPanel = jsonPanel;
            jsonPanel.registerForChange("close", function (e) {
                _this.onDataChanged("close");
            });
            jsonPanel.isFloating(true);
            var tabRoot = jsonPanel.getTabContentRoot("tab0");
            var tabRootW = vp.select(tabRoot);
            var nodesW = tabRootW.append("div")
                .addClass("flexAuto flexRows")
                .css("overflow-x", "hide")
                .css("overflow-y", "auto")
                .id("searchNodes");
            this._myRoot = tabRootW[0];
            this._nodesElem = nodesW[0];
            //vp.select(jsonPanel.getRootElem())
            //    .attach("dblclick", (e) =>
            //    {
            //        this.addSearchNode();
            //        vp.events.cancelEventBubble(e);
            //        vp.events.cancelEventDefault(e);
            //    })
            //---- add initial NODE ----
            this.addSearchNode();
            //---- set focus to first search box ----
            vp.select(this._myRoot, ".searchText")[0].focus();
            this.onMultiSearchChanged();
        }
        browsePanelMgr.prototype.isIncrementalSearch = function (value) {
            if (arguments.length == 0) {
                return this._isIncrementalSearch;
            }
            this._isIncrementalSearch = value;
            this.onDataChanged("isIncrementalSearch");
            //this.applySearchQuery();
        };
        browsePanelMgr.prototype.isMultiSearchPanes = function (value) {
            if (arguments.length == 0) {
                return this._isMultiSearchPanes;
            }
            this._isMultiSearchPanes = value;
            this.onDataChanged("isMultiSearchPanes");
            this.onMultiSearchChanged();
        };
        browsePanelMgr.prototype.isolateMatches = function (value) {
            if (arguments.length == 0) {
                return this._isolateMatches;
            }
            this._isolateMatches = value;
            this.onDataChanged("isolateMatches");
        };
        browsePanelMgr.prototype.onMultiSearchChanged = function () {
            var root = this._jsonPanel.getRootElem();
            var value = this._isMultiSearchPanes;
            vp.select(root, "#btAddNode")
                .css("display", (value) ? "" : "none");
        };
        browsePanelMgr.prototype.addSearchNode = function () {
            var _this = this;
            var nodesW = vp.select(this._nodesElem);
            var name = "node" + this._nextNodeId++;
            var node = new beachParty.searchNodeClass(this._app, nodesW[0], name, this._isMultiSearchPanes);
            node.registerForChange("nodeData", function (e) {
                _this.applySearchQuery();
            });
            node.registerForChange("incrementalNodeData", function (e) {
                if (_this._isIncrementalSearch) {
                    _this.applySearchQuery();
                }
            });
            node.registerForChange("closeRequest", function (e) {
                _this._searchNodes.remove(node);
                node.close();
                _this.applySearchQuery();
            });
            this._searchNodes.push(node);
            //this.applySearchQuery();
        };
        browsePanelMgr.prototype.applySearchQuery = function () {
            var spList = [];
            //---- build up a list of search params to apply to selection ----
            for (var i = 0; i < this._searchNodes.length; i++) {
                var node = this._searchNodes[i];
                var nd = node.getNodeData();
                var sp = new beachParty.SearchParams();
                sp.colName = nd.colName;
                if (nd.min !== undefined) {
                    sp.minValue = nd.min;
                    sp.maxValue = nd.max;
                    sp.searchType = beachParty.TextSearchType.betweenInclusive;
                }
                else if (nd.valueList && nd.valueList.length) {
                    sp.minValue = nd.valueList;
                    sp.maxValue = null;
                    sp.searchType = nd.textSearchType;
                    sp.caseSensitiveSearch = nd.textCaseSensitive;
                    if (nd.textSearchType == beachParty.TextSearchType.contains) {
                        //---- passing an array forces an exact match, so pass our single value as such ----
                        sp.minValue = nd.valueList[0];
                        if (this._isIncrementalSearch) {
                            sp.searchType = beachParty.TextSearchType.startsWith;
                        }
                    }
                }
                else {
                    continue;
                }
                sp.searchAction = (this._isolateMatches) ? beachParty.SearchAction.isolateMatches : beachParty.SearchAction.selectMatches;
                sp.selectMode = beachParty.SelectMode.normal;
                spList.push(sp);
            }
            if (spList.length > 0) {
                this._app.currentChart().searchEx(spList);
            }
            else {
                this._app.currentChart().clearSelection();
            }
        };
        browsePanelMgr.prototype.searchCol = function (value) {
            if (arguments.length == 0) {
                return this._searchCol;
            }
            this._searchCol = value;
            this.onDataChanged("searchCol");
        };
        browsePanelMgr.prototype.searchValue = function (value) {
            if (arguments.length == 0) {
                return this._searchValue;
            }
            this._searchValue = value;
            this.onDataChanged("searchValue");
        };
        //showAt(left: number, top: number, right?: number, bottom?: number)
        //{
        //    this._jsonPanel.showAt(left, top, right, bottom);
        //}
        browsePanelMgr.prototype.getJsonPanel = function () {
            return this._jsonPanel;
        };
        browsePanelMgr.prototype.close = function () {
            this._jsonPanel.close();
        };
        return browsePanelMgr;
    }(beachParty.baseJsonControlClass));
    beachParty.browsePanelMgr = browsePanelMgr;
    var SearchNodeData = (function () {
        function SearchNodeData(name, type) {
            this.name = name;
            this.colType = type;
            this.textSearchType = beachParty.TextSearchType.exactMatch;
        }
        return SearchNodeData;
    }());
    beachParty.SearchNodeData = SearchNodeData;
    var SearchQuery = (function () {
        function SearchQuery() {
        }
        return SearchQuery;
    }());
    beachParty.SearchQuery = SearchQuery;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    scriptsPanelMgr.ts - manages the Scripts panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    function declareProp(thisObj, name, setterCallback) {
        var body = "if (arguments.length == 0){return this._" + name + ";} this._" + name + " = value;";
        var func = new Function("value", body);
        thisObj[name] = func;
    }
    beachParty.declareProp = declareProp;
    var scriptsPanelMgr = (function (_super) {
        __extends(scriptsPanelMgr, _super);
        function scriptsPanelMgr(app, buttonId) {
            var _this = this;
            _super.call(this, app);
            this._isRecording = false;
            this._runCount = 1;
            this._runStatus = "Stopped";
            this._app = app;
            declareProp(this, "runCount");
            _super.prototype.init.call(this, buttonId, "scriptsPanel", beachParty.StorageType.script, "AllChartTypes", "tests");
            this._jsonPanel.isFloating(true);
            var recorder = this._app._scriptRecorder;
            recorder.registerForChange("isRecording", function (e) {
                _this.onRecordStatusChanged();
            });
            this.onRecordStatusChanged();
        }
        scriptsPanelMgr.prototype.onRecordStatusChanged = function () {
            this._isRecording = this._app._scriptRecorder.isRecording();
            vp.select(this.getRootElem(), "#labRecordStatus")
                .css("color", (this._isRecording) ? "#f22" : "");
            this.onDataChanged("recordStatus");
        };
        scriptsPanelMgr.prototype.runStatus = function (value) {
            return this._runStatus;
        };
        scriptsPanelMgr.prototype.recordStatus = function (value) {
            return (this._isRecording) ? "Recording" : "Stopped";
        };
        scriptsPanelMgr.prototype.onStartRecording = function () {
            this._isRecording = true;
            var recorder = this._app._scriptRecorder;
            recorder.startNewSession();
            this.refreshStartNewSessionProp();
        };
        scriptsPanelMgr.prototype.onStopRecording = function () {
            this._isRecording = true;
            var recorder = this._app._scriptRecorder;
            recorder.endSession();
            this.refreshStartNewSessionProp();
        };
        scriptsPanelMgr.prototype.refreshStartNewSessionProp = function () {
            var settings = this._app._appSettingsMgr;
            if (this._isRecording) {
                var recordAcross = settings.recordAcrossSessions();
                settings.recordNextSession(recordAcross);
            }
            else {
                settings.recordNextSession(false);
            }
        };
        scriptsPanelMgr.prototype.recordAcrossSessions = function (value) {
            var settings = this._app._appSettingsMgr;
            var retValue = settings.recordAcrossSessions.apply(settings, arguments);
            if (arguments.length) {
                this.refreshStartNewSessionProp();
                this.onDataChanged("recordAcrossSessions");
            }
            return retValue;
        };
        scriptsPanelMgr.prototype.scriptName = function (value) {
            if (arguments.length == 0) {
                return this._currentResourceName;
            }
            this._currentResourceName = value;
            this.onDataChanged("scriptName");
        };
        scriptsPanelMgr.prototype.setResourceName = function (value) {
            this.scriptName(value);
        };
        scriptsPanelMgr.prototype.getResourceItems = function () {
            return scriptsPanelMgr.getScriptItems();
        };
        //isUserLoggingEnabled(value?: boolean)
        //{
        //    //---- let appSettingsMgr handle the property get/set ----
        //    var retValue = settings.isUserLoggingEnabled.apply(settings, arguments);
        //    if (value !== undefined)
        //    {
        //        if (!value)
        //        {
        //            //---- schedule a refresh of our script list ----
        //            setTimeout((e) => this.rebuildResourceList(), 100);
        //        }
        //    }
        //    return retValue;
        //}
        scriptsPanelMgr.prototype.isPanelNavRecorded = function (value) {
            //---- let appSettingsMgr handle the property get/set ----
            var settings = this._app._appSettingsMgr;
            var retValue = settings.isPanelNavRecorded.apply(settings, arguments);
            return retValue;
        };
        scriptsPanelMgr.getScriptItems = function () {
            //---- start with standard tours ----
            var scripts = ["StevesDemo1", "StevesDemo2", "AllChartTypes", "AllKnownData", "AllColMappings", "AllPanels"];
            var cachedScripts = beachParty.localStorageMgr.enumerate(beachParty.StorageType.script, beachParty.StorageSubType.local, true);
            scripts = scripts.concat(cachedScripts);
            return scripts;
        };
        scriptsPanelMgr.prototype.onStartPlayback = function () {
            var _this = this;
            //---- if this a standard script (automated test)? ----
            var scriptData = this.loadCurrentResourceAsString();
            if (vp.utils.isString(scriptData)) {
                scriptData = JSON.parse(scriptData);
            }
            this._app.startAutomatedTest(scriptData, this._currentResourceName, this._runCount);
            this._app._scriptRunner.registerForChange("runStatus", function (e) {
                _this.refreshRunStatus();
            });
            this.refreshRunStatus();
        };
        scriptsPanelMgr.prototype.refreshRunStatus = function () {
            var runStatus = this._app._scriptRunner.runStatus();
            this._runStatus = runStatus;
            vp.select(this.getRootElem(), "#labRunStatus")
                .css("color", (runStatus == "Running") ? "#2f2" : "");
            this.onDataChanged("runStatus");
        };
        scriptsPanelMgr.prototype.onStopPlayback = function () {
            this._app.stopAutomatedTest();
        };
        scriptsPanelMgr.prototype.onPlotResults = function () {
            this._app.plotTestResults();
        };
        return scriptsPanelMgr;
    }(beachParty.baseResourcePanelMgr));
    beachParty.scriptsPanelMgr = scriptsPanelMgr;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    palettesPanelMgr.ts - manages the Color Palettes panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var palettesPanelMgr = (function (_super) {
        __extends(palettesPanelMgr, _super);
        function palettesPanelMgr(app, buttonId) {
            _super.call(this, app, buttonId, "palettesPanel", beachParty.StorageType.palette, "Sequential", "palettes");
        }
        palettesPanelMgr.prototype.paletteSetName = function (value) {
            if (arguments.length == 0) {
                return this._currentResourceName;
            }
            this._currentResourceName = value;
            this.onDataChanged("paletteSetName");
        };
        palettesPanelMgr.prototype.setResourceName = function (value) {
            this.paletteSetName(value);
        };
        palettesPanelMgr.prototype.getResourceItems = function () {
            return palettesPanelMgr.getPaletteItems();
        };
        palettesPanelMgr.getPaletteItems = function () {
            //---- start with standard palette sets ----
            var items = ["Sequential", "Diverging", "Qualitative", "PowerBI", "Excel", "Custom"];
            var cachedItems = beachParty.localStorageMgr.enumerate(beachParty.StorageType.palette, beachParty.StorageSubType.local, true);
            items = items.concat(cachedItems);
            return items;
        };
        return palettesPanelMgr;
    }(beachParty.baseResourcePanelMgr));
    beachParty.palettesPanelMgr = palettesPanelMgr;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    helpPanelMgr.ts - manages the Help panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var helpPanelMgrClass = (function (_super) {
        __extends(helpPanelMgrClass, _super);
        //_chatHistory: string;
        //_chatInput: string;
        //_botChat: botChatClass;
        function helpPanelMgrClass(app, buttonId) {
            var _this = this;
            _super.call(this, app, buttonId, "helpPanel", beachParty.StorageType.tour, "FirstTour", "tours");
            this._app = this._app;
            //this._botChat = new botChatClass(app, this);
            this._jsonPanel.showTitle(true);
            //---- hook the "something changed" event to update our description ----
            this._app.registerForChange("dataFrame", function (e) { return _this.buildDataDescription(); });
            this._app.registerForChange("lastCycleInfo", function (e) { return _this.buildChartDescription(); });
            //this._chatHistory = "";
            //this._chatInput = "";
            this.buildChartDescription();
            this.buildDataDescription();
            this._jsonPanel.isFloating(true);
        }
        //chatHistory(value?: string)
        //{
        //    if (arguments.length == 0)
        //    {
        //        return this._chatHistory;
        //    }
        //    this._chatHistory = value;
        //    this.onDataChanged("chatHistory");
        //}
        //chatInput(value?: string)
        //{
        //    if (arguments.length == 0)
        //    {
        //        return this._chatInput;
        //    }
        //    this._chatInput = value;
        //    vp.utils.debug("botMgr.chatInput: value set=" + value);
        //    this.onDataChanged("chatInput");
        //    if (value)
        //    {
        //        this._botChat.parseChatInput(value);
        //    }
        //}
        //setInputText(text: string)
        //{
        //    //---- insert cmd into textbox ----
        //    var elemW = vp.select(this._jsonPanel.getRootElem(), "#tbChatInput");
        //    //vp.utils.debug("setInputText: before=" + elemW.value());
        //    elemW.value(text);
        //    //vp.utils.debug("setInputText: after=" + elemW.value());
        //}
        helpPanelMgrClass.prototype.dataDescription = function (value) {
            if (arguments.length == 0) {
                return this._dataDesc;
            }
            this._dataDesc = value;
            this.onDataChanged("dataDescription");
        };
        helpPanelMgrClass.prototype.chartDescription = function (value) {
            if (arguments.length == 0) {
                return this._chartDesc;
            }
            this._chartDesc = value;
            this.onDataChanged("chartDescription");
        };
        helpPanelMgrClass.prototype.buildDataDescription = function () {
            //---- build new description for data ----
            var desc = "<description not yet available for this dataset>";
            var chart = this._app.currentChart();
            var preload = chart.getPreload();
            if (preload && preload.description) {
                desc = preload.description;
            }
            this.dataDescription(desc);
        };
        helpPanelMgrClass.prototype.buildChartDescription = function () {
            //---- build new description for chart ----
            var chart = this._app.currentChart();
            var chartName = chart.chartName();
            var desc = "This is a " + chartName + " of income vs. profit, with size mapped to color";
            this.chartDescription(desc);
        };
        return helpPanelMgrClass;
    }(beachParty.baseResourcePanelMgr));
    beachParty.helpPanelMgrClass = helpPanelMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    tourLoaderMgr.ts - manages the Tour Loader panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var tourLoaderMgr = (function (_super) {
        __extends(tourLoaderMgr, _super);
        function tourLoaderMgr(app, buttonId) {
            _super.call(this, app, buttonId, "tourLoaderPanel", beachParty.StorageType.tour, "FirstTour", "tours");
        }
        tourLoaderMgr.prototype.tourName = function (value) {
            if (arguments.length == 0) {
                return this._currentResourceName;
            }
            this._currentResourceName = value;
            this.onDataChanged("tourName");
        };
        tourLoaderMgr.prototype.setResourceName = function (value) {
            this.tourName(value);
        };
        tourLoaderMgr.prototype.getResourceItems = function () {
            return tourLoaderMgr.getThemeItems();
        };
        tourLoaderMgr.getThemeItems = function () {
            //---- start with standard THEMES ----
            var themes = ["BlacksBeach", "PowerBIWhite", "WhiteSands"];
            var cachedThemes = beachParty.localStorageMgr.enumerate(beachParty.StorageType.theme, beachParty.StorageSubType.local, true);
            themes = themes.concat(cachedThemes);
            return themes;
        };
        tourLoaderMgr.prototype.onStartTour = function () {
            var strJson = this.loadCurrentResourceAsString();
            this._app.startTourFromJson(name, strJson, 1);
        };
        tourLoaderMgr.loadKnownTourFile = function (name) {
            var strTour = beachParty.loadUserResourceAsString(name, beachParty.StorageType.tour, "tours");
            return strTour;
        };
        return tourLoaderMgr;
    }(beachParty.baseResourcePanelMgr));
    beachParty.tourLoaderMgr = tourLoaderMgr;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    aggPanelMgr.ts - manages the SandDance aggregation/sampling panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var aggPanelMgr = (function (_super) {
        __extends(aggPanelMgr, _super);
        function aggPanelMgr(app, buttonId) {
            var _this = this;
            _super.call(this);
            this._isAggEnabled = false;
            this._aggType = beachParty.AggType.sum;
            this._isSampEnabled = false;
            this._sampType = beachParty.SampleType.first;
            this._sampleCount = 100;
            this._app = app;
            var rc = vp.select("#" + buttonId).getBounds(false);
            var x = rc.left;
            var y = rc.bottom;
            var jsonPanel = beachParty.buildJsonPanel(app, buttonId, this, "aggPanel", true, x, y);
            this._jsonPanel = jsonPanel;
            jsonPanel.registerForChange("close", function (e) {
                _this.onDataChanged("close");
            });
            jsonPanel.isFloating(true);
        }
        aggPanelMgr.prototype.addCol = function (colList, colName) {
            if (colName && colList.indexOf(colName) == -1) {
                colList.push(colName);
            }
        };
        /**
         * gather columns being mapping in current view and include them in the grouping columns list.
         */
        aggPanelMgr.prototype.buildGroupingCols = function () {
            var groupCols = [];
            this.addCol(groupCols, this._aggGroup);
            var colorCol = this._app.colorColumn();
            this.addCol(groupCols, colorCol);
            var facetCol = this._app._facetMgr.colName();
            this.addCol(groupCols, facetCol);
            return groupCols;
        };
        aggPanelMgr.prototype.onParamsChanged = function () {
            var bdp = null; // new BigDataParams();
            if (this._isAggEnabled) {
                var groupCols = this.buildGroupingCols();
                bdp.aggregation = new beachParty.DataAggregation(beachParty.AggType.count, this._aggTarget, groupCols);
            }
            if (this._isSampEnabled) {
                bdp.sampling = new beachParty.DataSampling(true, this._sampType, this._sampleCount);
            }
            //this._app._currentChart.setBigDataParams(bdp);
        };
        aggPanelMgr.prototype.isAggEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isAggEnabled;
            }
            this._isAggEnabled = value;
            this.onParamsChanged();
            this.onDataChanged("isAggEnabled");
        };
        aggPanelMgr.prototype.isSampEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isSampEnabled;
            }
            this._isSampEnabled = value;
            this.onParamsChanged();
            this.onDataChanged("isSampEnabled");
        };
        aggPanelMgr.prototype.aggTarget = function (value) {
            if (arguments.length == 0) {
                return this._aggTarget;
            }
            this._aggTarget = value;
            this.onParamsChanged();
            this.onDataChanged("aggTarget");
        };
        aggPanelMgr.prototype.aggGroup = function (value) {
            if (arguments.length == 0) {
                return this._aggGroup;
            }
            this._aggGroup = value;
            this.onParamsChanged();
            this.onDataChanged("aggGroup");
        };
        aggPanelMgr.prototype.aggType = function (value) {
            if (arguments.length == 0) {
                return beachParty.AggType[this._aggType];
            }
            this._aggType = beachParty.AggType[value];
            this.onParamsChanged();
            this.onDataChanged("aggType");
        };
        aggPanelMgr.prototype.sampType = function (value) {
            if (arguments.length == 0) {
                return beachParty.SampleType[this._sampType];
            }
            this._sampType = beachParty.SampleType[value];
            this.onParamsChanged();
            this.onDataChanged("sampType");
        };
        aggPanelMgr.prototype.sampleCount = function (value) {
            if (arguments.length == 0) {
                return this._sampleCount;
            }
            this._sampleCount = value;
            this.onParamsChanged();
            this.onDataChanged("sampleCount");
        };
        return aggPanelMgr;
    }(beachParty.baseJsonControlClass));
    beachParty.aggPanelMgr = aggPanelMgr;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    tourPanelMgr.ts - manages the SandDance tour panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var tourPanelMgr = (function (_super) {
        __extends(tourPanelMgr, _super);
        function tourPanelMgr(app, buttonId, tour) {
            var _this = this;
            _super.call(this, app, "tourPanel", false, null, null, 380, undefined, false, null, true, false, undefined, true);
            this._index = -1;
            //---- adjustable parameters for best look ----
            this._useOuterForOutlining = true;
            this._outerPadding = 20;
            if (this._useOuterForOutlining) {
                var topW = vp.select(this._root)
                    .id("tourPanelOuter")
                    .css("background", "transparent")
                    .css("border", "2px solid transparent");
                //---- space between our green outline and normal edges of panel ----
                var rootW = topW.append("div")
                    .css("margin", this._outerPadding + "px");
            }
            else {
                var topW = vp.select(this._root);
                var rootW = topW;
            }
            var myWidth = 380;
            var left = innerWidth / 2 - myWidth / 2;
            topW
                .css("overflow-y", "hidden")
                .css("z-index", "2000")
                .css("top", "-100px") // above the screen
                .css("left", left + "px") // centered horizontally
                .css("transition", "all .5s ease"); // this seem to work here (.css was inconsistent)
            rootW
                .addClass("tourPanel");
            //---- TITLE ----
            rootW.append("div")
                .addClass("tourTitle")
                .css("cursor", "pointer")
                .attach("mousedown", function (e) {
                _this.onDragMouseDown(e);
                _this.onFocus(e);
                _this.showOurOutline(false);
                topW
                    .css("transition", "none"); // turn off animation during drag
            })
                .attach("dblclick", function (e) {
            });
            //---- CLIENT AREA ----
            var clientW = rootW.append("div")
                .addClass("tourClientArea");
            //.css("margin", "2px")
            //---- CONTENT ----
            clientW.append("div")
                .id("tourPanelContent")
                .addClass("tourContent");
            //---- BUTTON ROW ----
            var buttonsW = clientW.append("div")
                .addClass("tourClientArea")
                .css("height", "32px");
            //.css("border", "1px solid red")
            //.css("margin", "10px 0px 30px 8px")
            //.css("height", "4px")
            //.css("border", "1px solid red")
            //var extraRow = clientW.append("div")
            //    .css("height", "40px")
            //    .css("border", "1px solid green")
            //---- PREV ----
            buttonsW.append("span")
                .addClass("tourButton")
                .text("Prev")
                .id("btPrev")
                .css("margin-left", "18px")
                .css("float", "left")
                .attach("click", function (e) { return _this.gotoStep(_this._index - 1, "prev"); });
            //---- NEXT ----
            buttonsW.append("span")
                .addClass("tourButton")
                .text("Next")
                .id("btNext")
                .css("margin-left", "10px")
                .css("float", "left")
                .attach("click", function (e) { return _this.gotoStep(_this._index + 1, "next"); });
            //---- END TOUR ----
            buttonsW.append("span")
                .addClass("tourButton")
                .text("End Tour")
                .css("margin-right", "18px")
                .css("float", "right")
                .attach("click", function (e) { return _this.endTour(); });
            if (tour) {
                this.tour(tour);
            }
        }
        tourPanelMgr.prototype.getJsonPanel = function () {
            //---- not supported for this panel ----
            return null;
        };
        tourPanelMgr.prototype.tour = function (value) {
            if (arguments.length == 0) {
                return this._tour;
            }
            this._tour = value;
            this.gotoStep(0, "start");
        };
        tourPanelMgr.prototype.onMouseUp = function (e) {
            _super.prototype.onDragMouseUp.call(this, e);
            var topW = vp.select(this._root);
            topW
                .css("transition", "all .5s ease"); // turn animation back on after drag
            vp.utils.debug("tourPanelMgr.onMouseUp: animation restored for elem=" + topW[0].class);
        };
        tourPanelMgr.prototype.endTour = function () {
            var _this = this;
            this.clearActiveElement();
            var settings = this._app._appSettingsMgr;
            settings.runTourOnStartUp(false);
            this.runPostCommands(function (e) {
                _this.close();
            });
        };
        tourPanelMgr.prototype.runPostCommands = function (callback) {
            var currentIndex = this._index;
            var runCallback = true;
            if (currentIndex > -1) {
                var currentStep = this._tour.steps[currentIndex];
                if (currentStep.postCommands) {
                    this.runCommands(currentStep.postCommands, callback);
                    runCallback = false;
                }
            }
            if (runCallback) {
                callback();
            }
        };
        tourPanelMgr.prototype.gotoStep = function (index, stepName) {
            var _this = this;
            var steps = this._tour.steps;
            if (index >= 0 && index < steps.length) {
                //---- previous step ----
                this.clearActiveElement();
                this.runPostCommands(function (e) {
                    var step = steps[index];
                    _this._index = index;
                    _this.loadStep(step);
                    _this._app.logAction(beachParty.Gesture.click, stepName, beachParty.ElementType.button, beachParty.Action.load, beachParty.Target.tourStep, false, { tourStep: index });
                    _this.onIndexChanged();
                });
            }
        };
        tourPanelMgr.prototype.onIndexChanged = function () {
            var index = this._index;
            var steps = this._tour.steps;
            //---- enable/disable buttons to match position ----
            vp.select(this._root, "#btPrev").attr("data-disabled", (index == 0) ? "true" : "false");
            vp.select(this._root, "#btNext").attr("data-disabled", (index == steps.length - 1) ? "true" : "false");
        };
        tourPanelMgr.prototype.clearActiveElement = function () {
            if (this._activeEleme) {
                vp.select(this._activeEleme).removeClass("activeTourElement");
                this._activeEleme = null;
            }
        };
        tourPanelMgr.prototype.setElementActive = function (index) {
            var steps = this._tour.steps;
            var element = null;
            if (index >= 0 && index < steps.length) {
                var step = steps[index];
                if (step.element) {
                    var ids = step.element.split(",");
                    for (var i = 0; i < ids.length; i++) {
                        var id = ids[i];
                        //---- use the "Holder" version, if available ----
                        var elemW = vp.select(id + "Holder");
                        if (elemW.length == 0) {
                            elemW = vp.select(id);
                        }
                        if (elemW.length) {
                            vp.utils.debug("setElementActive: index=" + index + ", elem.id=" + elemW[0].id);
                            elemW.addClass("activeTourElement");
                            //elemW.css("border", "4px solid green");
                            element = elemW[0];
                            break;
                        }
                    }
                }
            }
            return element;
        };
        tourPanelMgr.prototype.runCommands = function (cmds, callback, index) {
            var _this = this;
            var commands = cmds.split(";");
            var i = (index === undefined) ? 0 : index;
            var normalFinish = true;
            while (i < commands.length) {
                var command = commands[i++].trim();
                if (command.startsWith("delay ")) {
                    var ms = +command.substr(6).trim();
                    setTimeout(function (e) { return _this.runCommands(cmds, callback, i); }, ms);
                    normalFinish = false;
                    break;
                }
                else {
                    this._app.runBotCommand(command);
                }
            }
            if (normalFinish) {
                callback();
            }
        };
        tourPanelMgr.prototype.loadStep = function (step) {
            var _this = this;
            //---- commands are run first ----
            if (step.preCommands) {
                this.runCommands(step.preCommands, function (e) { return _this.loadStepEx(step); });
            }
            else {
                this.loadStepEx(step);
            }
        };
        tourPanelMgr.prototype.loadStepEx = function (step) {
            var target = this.setElementActive(this._index);
            vp.select(this._root, ".tourTitle")
                .text(step.title);
            vp.select(this._root, ".tourContent")
                .html(step.content);
            this._activeEleme = target;
            //---- move our panel close to the target ----
            if (target) {
                this.positionPanelNextToElem(target);
            }
            else {
                this.centerPanel();
            }
            //---- update our outline ----
            var showOutline = (target && !step.hidePanelOutline);
            this.showOurOutline(showOutline);
            //---- workaround IE bug ----
            if (vp.utils.isIE) {
                window.scrollTo(0, 0);
            }
        };
        tourPanelMgr.prototype.showOurOutline = function (value) {
            if (this._useOuterForOutlining) {
                vp.select(this._root)
                    .css("background", (value) ? "black" : "transparent")
                    .css("border", (value) ? "4px solid green" : "4px solid transparent");
            }
        };
        tourPanelMgr.prototype.positionPanelNextToElem = function (target) {
            var rc = vp.select(this._root).getBounds(false);
            var rcElem = vp.select(target).getBounds(false);
            var borderSize = 4;
            //---- calc space on left if we move to target's LEFT ----
            var leftSpace = (rcElem.left - rc.width);
            //---- calc space on right if we move to target's RIGHT ----
            var rightSpace = innerWidth - (rcElem.right + rc.width);
            if (leftSpace > rightSpace) {
                //---- put on LEFT ----
                var x = leftSpace + borderSize;
            }
            else {
                //---- put on RIGHT ----
                var x = +rcElem.right - (borderSize + 0);
            }
            //---- calc space on top if we move to target's TOP ----
            var topSpace = (rcElem.top - rc.height);
            //---- calc space on bottom if we move to target's BOTTOM ----
            var bottomSpace = innerHeight - (rcElem.bottom + rc.height);
            if (topSpace > bottomSpace) {
                //---- put on TOP ----
                var y = topSpace + borderSize;
            }
            else {
                //---- put on BOTTOM ----
                var y = +rcElem.bottom - (borderSize + 0);
            }
            this.showAt(x, y, undefined, undefined);
        };
        return tourPanelMgr;
    }(beachParty.basePanelClass));
    beachParty.tourPanelMgr = tourPanelMgr;
    var TourStep = (function () {
        function TourStep() {
        }
        return TourStep;
    }());
    beachParty.TourStep = TourStep;
    var TourData = (function () {
        function TourData() {
        }
        return TourData;
    }());
    beachParty.TourData = TourData;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    tipsPanelMgr.ts - manages the tooltips/datatip floating panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var tipsPanelMgr = (function (_super) {
        __extends(tipsPanelMgr, _super);
        function tipsPanelMgr(app, buttonId) {
            var _this = this;
            _super.call(this);
            this._dataTipTitle = "";
            this._app = app;
            this._includeNamesInDatatip = true;
            var rc = vp.select("#" + buttonId).getBounds(false);
            var x = rc.left;
            var y = rc.bottom;
            var jsonPanel = beachParty.buildJsonPanel(app, buttonId, this, "tipsPanel", false, x, y, undefined, undefined, undefined, undefined, undefined, "tipsButton");
            this._jsonPanel = jsonPanel;
            jsonPanel.show(false); // hide while building variable parts of panel 
            jsonPanel.registerForRemovableChange("close", this, function (e) {
                _this.onDataChanged("close");
            });
            var rootElem = jsonPanel.getRootElem();
            jsonPanel.forceTabBuild(0);
            jsonPanel.forceTabBuild(1);
            var tabZeroW = vp.select(rootElem, "#tab0Content");
            this._datatipListElem = this.createCheckboxColumnList("datatips", tabZeroW);
            var tabOneW = vp.select(rootElem, "#tab1Content");
            this._tooltipListElem = this.createCheckboxColumnList("tooltips", tabOneW);
            //---- add CREATE button (at end of datatips panel) ----
            var buttonW = tabZeroW.append("span")
                .addClass("panelButton")
                .text("Create")
                .css("width", "60px")
                .css("margin", "6px")
                .attach("click", function (e) { return _this.createDataTip(); });
        }
        tipsPanelMgr.prototype.tooltipColumns = function (value) {
            if (arguments.length == 0) {
                return this._tooltipColumns;
            }
            this._tooltipColumns = value;
            this.onDataChanged("tooltipColumns", true);
            //---- rebuild checkbox list of columns ----
            this.rebuildCheckboxList(this._tooltipListElem, "tooltips");
        };
        tipsPanelMgr.prototype.dataTipTitle = function (value) {
            if (arguments.length == 0) {
                return this._dataTipTitle;
            }
            this._dataTipTitle = value;
            this.onDataChanged("dataTipTitle", true);
        };
        tipsPanelMgr.prototype.includeNamesInDatatip = function (value) {
            if (arguments.length == 0) {
                return this._includeNamesInDatatip;
            }
            this._includeNamesInDatatip = value;
            this.onDataChanged("includeNamesInDatatip", true);
        };
        tipsPanelMgr.prototype.createCheckboxColumnList = function (panelName, parentW) {
            var divW = parentW.append("div")
                .addClass("panelDisplay")
                .text("Choose column(s) for " + panelName + ":")
                .css("margin", "6px")
                .css("margin-top", "20px");
            var listW = parentW.append("div")
                .addClass("customScrollbar")
                .css("border", "1px solid #333")
                .css("margin", "6px")
                .css("max-height", "150px")
                .css("overflow-y", "auto")
                .css("overflow-x", "hidden");
            return this.rebuildCheckboxList(listW[0], panelName);
        };
        tipsPanelMgr.prototype.rebuildCheckboxList = function (listElem, panelName) {
            var _this = this;
            var chart = this._app.currentChart();
            var colInfos = chart.getColInfos();
            var listW = vp.select(listElem)
                .clear();
            for (var i = 0; i < colInfos.length; i++) {
                var ci = colInfos[i];
                var colName = ci.name;
                var value = (this._tooltipColumns && this._tooltipColumns.indexOf(colName) > -1);
                if (panelName == "tooltips") {
                    beachParty.createCheckboxAssembly(listW[0], colName, value, function (e) {
                        _this.onTooltipCheckboxesChanged(listW);
                    });
                }
                else {
                    beachParty.createCheckboxAssembly(listW[0], colName, value, function (e) {
                        _this.onDatatipCheckboxesChanged(listW);
                    });
                }
            }
            return listW[0];
        };
        tipsPanelMgr.prototype.onTooltipCheckboxesChanged = function (listW) {
            var cols = [];
            vp.select(listW[0], ".searchCheckboxRow").each(function (index, elem) {
                if (elem.checkbox.checked) {
                    cols.push(elem.key);
                }
            });
            this._tooltipColumns = cols;
            this.onDataChanged("tooltipColumns", true);
        };
        tipsPanelMgr.prototype.onDatatipCheckboxesChanged = function (listW) {
            var cols = [];
            vp.select(listW[0], ".searchCheckboxRow").each(function (index, elem) {
                if (elem.checkbox.checked) {
                    cols.push(elem.key);
                }
            });
            this._datatipColumns = cols;
            this.onDataChanged("datatipParams", true);
        };
        tipsPanelMgr.prototype.includeNamesInTooltip = function (value) {
            var settings = this._app._appSettingsMgr;
            return settings.includeNamesInTooltip.apply(settings, arguments);
        };
        tipsPanelMgr.prototype.hoverOnMouseMove = function (value) {
            var settings = this._app._appSettingsMgr;
            return settings.hoverOnMouseMove.apply(settings, arguments);
        };
        tipsPanelMgr.prototype.isTooltipsEnabled = function (value) {
            var settings = this._app._appSettingsMgr;
            return settings.isTooltipsEnabled.apply(settings, arguments);
        };
        tipsPanelMgr.prototype.createDataTip = function () {
            this._app.createDataTip(this._dataTipTitle, this._datatipColumns, this._includeNamesInDatatip);
            var colCount = (this._datatipColumns) ? this._datatipColumns.length : 0; //this._app._colInfos.length;
            var useTitle = (this._dataTipTitle != null && this._dataTipTitle != "");
            this._app.logAction(beachParty.Gesture.click, "createDataTip", beachParty.ElementType.button, beachParty.Action.create, beachParty.Target.dataTip, false, { useTitle: useTitle, useColNames: this._includeNamesInDatatip, colCount: colCount });
        };
        tipsPanelMgr.prototype.getJsonPanel = function () {
            return this._jsonPanel;
        };
        return tipsPanelMgr;
    }(beachParty.baseJsonControlClass));
    beachParty.tipsPanelMgr = tipsPanelMgr;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    panelMaster.ts - manages the SandDance panels (toggling of open/close of each panel).  
//
//  There are two register API's: 
//      registerPanel() - used to register a JSON panel that doesn't have its own panelMgr.  In this case, we create
//                        an instance of "simplePanelMgr" to be its panelMgr.
//
//      registerPanelMgr() - used for panels that have their own panelMgr.  This call registers
//                           a "create" callback and an "onClose" callback.  The create callback creates
//                           the panelMgr instance, when creates its associated panel (the panel is usually based on jsonPanelClass).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var panelMasterClass = (function (_super) {
        __extends(panelMasterClass, _super);
        function panelMasterClass(app) {
            _super.call(this);
            this._panels = {}; // our map of PanelInfo instances
            this._app = app;
        }
        panelMasterClass.prototype.getPanelInfo = function (name) {
            var pi = this._panels[name];
            return pi;
        };
        panelMasterClass.prototype.registerPanel = function (name, buttonName, buttonAlign, isFloating, panelTarget, isFromLegend, openCallback, closeCallback, dataOwner, fadeInOpts) {
            var _this = this;
            if (dataOwner === void 0) { dataOwner = null; }
            if (fadeInOpts === void 0) { fadeInOpts = null; }
            if (dataOwner === undefined) {
                dataOwner = this._app._appSettingsMgr;
            }
            if (buttonAlign === null || buttonAlign === undefined) {
                buttonAlign = ButtonAlign.belowButton;
            }
            //---- create a simplePanelMgr to manage this panel (doesn't need its own mgr class) ----
            this.registerPanelMgr(name, buttonName, buttonAlign, isFloating, panelTarget, isFromLegend, function (isClickedFromLegend) {
                ////---- create callback ----
                var panelMgr = new simplePanelMgrClass(_this._app, buttonName, dataOwner, name, isFloating, isClickedFromLegend);
                return panelMgr;
            }, function (closeEvent) {
                //---- close callback ----
                if (closeCallback) {
                    closeCallback();
                }
            }, openCallback, fadeInOpts);
        };
        /**
         * used to register panels (created outside of panelMgr) with panelMgr so we can use its "getPanel()" to
        get the open instance of the named panel.  PanelMgr will take care of logging the open and close actions once registered.
         * @param panelName
         * @param panelObj
         */
        panelMasterClass.prototype.registerCustomPanel = function (target, panelObj) {
            var _this = this;
            var panelName = beachParty.Target[target];
            var pi = new PanelInfo(panelName, null, null, this._app, null, null, null, null, target);
            pi.jsonPanel = panelObj;
            pi.panelMgr = null;
            this._panels[panelName] = pi;
            this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.button, beachParty.Action.show, target, false);
            panelObj.registerForChange("close", function (e) {
                _this._panels[panelName] = null; // custom panels get removed each time
                _this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.button, beachParty.Action.close, target, false);
            });
        };
        panelMasterClass.prototype.togglePanel = function (name, e, btAlign, isFromLegend) {
            var pi = this.getPanelInfo(name);
            var isOpen = false;
            if (pi && pi.panelMgr) {
                this.hidePanel(name, e);
            }
            else {
                this.showPanel(name, e, btAlign, isFromLegend);
                isOpen = true;
            }
            //---- stop event propagation ----
            if (e) {
                vp.events.cancelEventBubble(e);
                vp.events.cancelEventDefault(e);
            }
            return isOpen;
        };
        panelMasterClass.prototype.showPanelNow = function (panelMgr, buttonName, btAlign, isFromLegend, fadeInOpts) {
            //---- find where to put panel ----
            if (buttonName.contains(" ")) {
                var buttons = buttonName.split(" ");
                buttonName = (isFromLegend) ? buttons[1] : buttons[0];
            }
            var rcPanel = vp.select(panelMgr.getRootElem()).getBounds(false);
            var ptx = this.getBestPanelLocation(rcPanel, buttonName, btAlign);
            //---- don't show until openCallback has been run - allows callback to build dynamic parts of panel & showAt will get accurate size of panel ----
            panelMgr.showAt(ptx.x, ptx.y, ptx.x2, ptx.y2, fadeInOpts);
        };
        panelMasterClass.prototype.showPanel = function (name, e, btAlign, isFromLegend) {
            var pi = this.getPanelInfo(name);
            if (!pi) {
                throw "Cannot show unregistered panel: " + name;
            }
            if (isFromLegend === undefined) {
                isFromLegend = pi.isFromLegend;
            }
            if (btAlign === undefined) {
                btAlign = pi.buttonAlign;
            }
            var panelMgr = this.createPanelMgr(name, pi.buttonName, btAlign, pi.isFloating, pi.panelTarget, isFromLegend);
            if (pi.openCallback) {
                var openEvent = { panelMgr: panelMgr, panel: panelMgr.getJsonPanel() };
                pi.openCallback(openEvent);
            }
            //---- don't show until openCallback has been run - allows callback to build dynamic parts of panel & showAt will get accurate size of panel ----
            this.showPanelNow(panelMgr, pi.buttonName, btAlign, isFromLegend, pi.fadeInOpts);
            //---- LOG this action ----
            var targetId = (e) ? e.target.id : "";
            var isUndoable = false;
            this._app.logAction(beachParty.Gesture.click, targetId, beachParty.ElementType.button, beachParty.Action.show, pi.panelTarget, isUndoable);
            return pi.panelMgr;
        };
        panelMasterClass.prototype.hidePanel = function (name, e) {
            var pi = this.getPanelInfo(name);
            if (!pi) {
                throw "Cannot hide unregistered panel: " + name;
            }
            this.closePanelMgr(name);
            //---- LOG this action ----
            var targetId = (e) ? e.target.id : "";
            var isUndoable = false;
            this._app.logAction(beachParty.Gesture.click, targetId, beachParty.ElementType.button, beachParty.Action.hide, pi.panelTarget, isUndoable);
        };
        panelMasterClass.prototype.registerPanelMgr = function (name, buttonName, buttonAlign, isFloating, panelTarget, isFromLegned, createCallback, closeCallback, openCallback, fadeInOpts) {
            var pi = this.getPanelInfo(name);
            if (pi) {
                throw "panel already registered: " + name;
            }
            var panelInfo = new PanelInfo(name, openCallback, closeCallback, null, buttonName, buttonAlign, isFloating, null, panelTarget, fadeInOpts);
            panelInfo.createCallback = createCallback;
            this._panels[name] = panelInfo;
        };
        /**
         *  Closes the specified xxxPanelMgr object (e.g., clusterPanelMgr).
         * @param name
         */
        panelMasterClass.prototype.closePanelMgr = function (name) {
            var pi = this.getPanelInfo(name);
            if (pi) {
                var panelMgr = pi.panelMgr;
                if (panelMgr) {
                    panelMgr.close();
                }
            }
        };
        panelMasterClass.prototype.getJsonPanel = function (name) {
            var pi = this.getPanelInfo(name);
            return (pi) ? pi.panelMgr.getJsonPanel() : null;
        };
        panelMasterClass.prototype.getPanelMgr = function (name) {
            var pi = this.getPanelInfo(name);
            return (pi) ? pi.panelMgr : null;
        };
        panelMasterClass.prototype.onPanelClose = function (name) {
            var pi = this.getPanelInfo(name);
            pi.jsonPanel = null;
            if (pi.panelMgr) {
                pi.panelMgr = null;
                pi.dataOwner = null;
            }
            var closeCallback = pi.closeCallback;
            if (closeCallback) {
                closeCallback(null);
            }
        };
        panelMasterClass.prototype.matchButtonTopBottom = function (ptx, toTopSpace, toBottomSpace, rcButton) {
            if (toTopSpace < 0 && toBottomSpace < 0) {
                //---- if it doesn't fit either way, fit it to top ----
                ptx.y = rcButton.top + toBottomSpace;
            }
            else if (toTopSpace > toBottomSpace) {
                //---- match BOTTOM ----
                ptx.y2 = rcButton.bottom;
            }
            else {
                //---- match TOP ----
                ptx.y = rcButton.top;
            }
        };
        panelMasterClass.prototype.matchButtonLeftRight = function (ptx, toLeftSpace, toRightSpace, rcButton) {
            if (toLeftSpace > toRightSpace) {
                //---- match RIGHT ----
                ptx.x2 = rcButton.right;
            }
            else {
                //---- match LEFT ----
                ptx.x = rcButton.left;
            }
        };
        panelMasterClass.prototype.getBestPanelLocation = function (rcPanel, buttonName, btAlign) {
            var pt = {};
            //---- currently supports only buttons from HORIZONTAL toolbars ----
            var buttonW = vp.select("#" + buttonName);
            var rcButton = buttonW.getBounds();
            if (rcButton) {
                var buttonBottom = rcButton.bottom;
                var buttonLeft = rcButton.left;
                //---- horizontal ----
                if ((btAlign & ButtonAlign.matchLeft) != 0) {
                    //---- align LEFT of panel with BUTTON LEFT ----
                    pt.x = buttonLeft;
                }
                else if ((btAlign & ButtonAlign.matchRight) != 0) {
                    //---- align RIGHT of panel with BUTTON RIGHT ----
                    pt.x2 = rcButton.right;
                }
                else if ((btAlign & ButtonAlign.leftOfButton) != 0) {
                    //---- align RIGHT of panel with BUTTON LEFT ----
                    pt.x2 = buttonLeft;
                }
                else if ((btAlign & ButtonAlign.rightOfButton) != 0) {
                    //---- align LEFT of panel with BUTTON RIGHT ----
                    pt.x = rcButton.right;
                }
                else {
                    var toLeftSpace = rcButton.right - rcPanel.width;
                    var toRightSpace = innerWidth - (rcButton.left + rcPanel.width);
                    this.matchButtonLeftRight(pt, toLeftSpace, toRightSpace, rcButton);
                    if (buttonName.startsWith("bb")) {
                        pt.x -= 1; // nudge into correct position
                    }
                }
                //---- vertical ----
                if ((btAlign & ButtonAlign.matchTop) != 0) {
                    //---- align TOP of panel with BUTTON TOP ----
                    pt.y = rcButton.top;
                }
                else if ((btAlign & ButtonAlign.matchBottom) != 0) {
                    //---- align BOTTOM of panel with BUTTON BOTTOM ----
                    pt.y2 = buttonBottom;
                }
                else if ((btAlign & ButtonAlign.aboveButton) != 0) {
                    //---- align BOTTOM of panel with BUTTON TOP ----
                    pt.y2 = rcButton.top;
                }
                else if ((btAlign & ButtonAlign.belowButton) != 0) {
                    //---- align TOP of panel with BUTTON BOTTOM ----
                    pt.y = buttonBottom;
                }
                else {
                    var toTopSpace = rcButton.top - rcPanel.height;
                    var toBottomSpace = innerHeight - (buttonBottom + rcPanel.height);
                    this.matchButtonTopBottom(pt, toTopSpace, toBottomSpace, rcButton);
                }
            }
            else {
                //---- no visible button supplied ----
                pt.x = 0;
                pt.y = 0;
            }
            return pt;
        };
        panelMasterClass.prototype.createPanelMgr = function (name, buttonName, btAlign, isFloating, target, isFromLegend) {
            var _this = this;
            var pi = this.getPanelInfo(name);
            if (pi && !pi.panelMgr) {
                var panelMgr = pi.createCallback(isFromLegend);
                pi.panelMgr = panelMgr;
                pi.jsonPanel = panelMgr.getJsonPanel();
                pi.dataOwner = panelMgr;
                //this.showPanelNow(panelMgr, pi.buttonName, btAlign, isFromLegend, pi.fadeInOpts);
                //---- register for this on each new panel ----
                panelMgr.registerForChange("close", function (e) {
                    _this.onPanelClose(name);
                    _this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.button, beachParty.Action.close, target, false);
                });
                return panelMgr;
            }
        };
        return panelMasterClass;
    }(beachParty.dataChangerClass));
    beachParty.panelMasterClass = panelMasterClass;
    /** how panel aligns with button that invoked it. */
    (function (ButtonAlign) {
        //---- vertical ----
        ButtonAlign[ButtonAlign["aboveButton"] = 1] = "aboveButton";
        ButtonAlign[ButtonAlign["belowButton"] = 2] = "belowButton";
        ButtonAlign[ButtonAlign["matchTop"] = 4] = "matchTop";
        ButtonAlign[ButtonAlign["matchBottom"] = 8] = "matchBottom";
        ButtonAlign[ButtonAlign["bestTopBot"] = 16] = "bestTopBot";
        //---- horizontal ----
        ButtonAlign[ButtonAlign["leftOfButton"] = 32] = "leftOfButton";
        ButtonAlign[ButtonAlign["rightOfButton"] = 64] = "rightOfButton";
        ButtonAlign[ButtonAlign["matchLeft"] = 128] = "matchLeft";
        ButtonAlign[ButtonAlign["matchRight"] = 256] = "matchRight";
        ButtonAlign[ButtonAlign["bestLeftRight"] = 512] = "bestLeftRight";
    })(beachParty.ButtonAlign || (beachParty.ButtonAlign = {}));
    var ButtonAlign = beachParty.ButtonAlign;
    var PanelInfo = (function () {
        function PanelInfo(name, openCallback, closeCallback, dataOwner, buttonName, buttonAlign, isFloating, isFromLegend, panelTarget, fadeInOpts) {
            this.name = name;
            this.openCallback = openCallback;
            this.closeCallback = closeCallback;
            this.dataOwner = dataOwner;
            this.buttonName = buttonName;
            this.buttonAlign = buttonAlign;
            this.isFloating = isFloating;
            this.isFromLegend = isFromLegend;
            this.panelTarget = panelTarget;
            this.fadeInOpts = fadeInOpts;
        }
        return PanelInfo;
    }());
    beachParty.PanelInfo = PanelInfo;
    var simplePanelMgrClass = (function (_super) {
        __extends(simplePanelMgrClass, _super);
        function simplePanelMgrClass(app, buttonName, dataOwner, name, isFloating, isFromLegend) {
            var _this = this;
            _super.call(this);
            var uiOpenName = this.getUiOpenName(buttonName, isFromLegend);
            var jsonPanel = beachParty.buildJsonPanel(app, buttonName, dataOwner, name, false, undefined, undefined, undefined, undefined, undefined, undefined, undefined, uiOpenName);
            this._jsonPanel = jsonPanel;
            jsonPanel.isFloating(isFloating);
            jsonPanel.registerForRemovableChange("close", this, function (e) {
                _this.onClose();
            });
        }
        simplePanelMgrClass.prototype.getUiOpenName = function (buttonName, isFromLegend) {
            var uiName = buttonName;
            var names = buttonName.split(" ");
            if (names.length > 1) {
                uiName = (isFromLegend) ? names[1] : names[0];
            }
            return uiName;
        };
        simplePanelMgrClass.prototype.onClose = function () {
            //---- unregister with other data objects to avoid leaking memory ----
            this._jsonPanel.unregisterForChanges(this, "close");
            this.onDataChanged("close");
        };
        return simplePanelMgrClass;
    }(beachParty.baseJsonControlClass));
    beachParty.simplePanelMgrClass = simplePanelMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    detailsPanel.ts - describes the details panel (record, grid, overview, annotations)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.detailsPanel =
        {
            title: "Details",
            autoClose: true,
            resizable: true,
            minWidth: 400,
            tabs: [
                //---- COLUMN tab ----
                {
                    tabName: "Record", tip: "View the data one record at a time",
                    rows: []
                },
                //---- DATAGRID tab ----
                {
                    tabName: "Grid", tip: "View the data as a data grid", rows: []
                },
                //---- OVERVIEW tab ----
                {
                    tabName: "Overview", tip: "Get an overview of the columns in the dataset", rows: []
                },
                //---- ANNOTATIONS tab ----
                {
                    tabName: "Annotations", tip: "Manage the user annotations in the dataset", rows: []
                },
                //---- OPTIONS tab ----
                {
                    tabName: "Options", tip: "Options for the details panel", rows: [
                        {
                            prompt: "Record view", tip: "options for the record view tab"
                        },
                        //{
                        //    newRowIndent: true, checkbox: "Selected records only", tip: "When set, only selected records are displayed", dataName: "isOnlySelectedRecords"
                        //},
                        {
                            newRowIndent: true, checkbox: "Sort columns", tip: "When set, columns are sorted by name", dataName: "isColDetailsSorted",
                        },
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    botPanel.ts - describes the bot panel (suggestions and bot chat).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.botPanel =
        {
            title: "Bot",
            width: 200,
            height: 175,
            resizable: false,
            tabs: [
                {
                    tabName: "Hints", tip: "View or select bot suggestions", rows: []
                },
                {
                    tabName: "Chat",
                    tip: "Ask questions, issue commands, learn about things",
                    cellPadding: 3,
                    colFill: true,
                    rows: [
                        {
                            display: "Bot:", tip: "The bot's responses show here", dataName: "chatResponse",
                            id: "stChatResponse", width: 120,
                        },
                        {
                            textBox: "Me:", tip: "Enter your questions and commands here", dataName: "chatInput",
                            noSelectOnFocus: true, colSpan: 99, id: "tbChatInput", width: 120, tabIndex: 1,
                            ignoreBlur: true, cmdHistory: true,
                        },
                    ]
                },
                {
                    tabName: "History", tip: "View or select previous actions", rows: []
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    testPanel.ts - used to test memory leakage for panels.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.testPanel =
        {
            title: "Memory Panel Test", tip: "Used to test/debug memory leakage in panels.",
            rows: [
                { button: "Show alert", tip: "will invoke a simple alert", dataName: "showTestAlert" },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    imapePanel.ts - describes the panel for IMAGE by data mapping
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.imagePanel =
        {
            title: "Image by",
            autoClose: true,
            tabs: [
                //---- COLUMN tab ----
                {
                    tabName: "Column", tip: "Specifies which column is used for Image mapping",
                    rows: [
                        {
                            numAdjuster: "Images:", tip: "Specifies the number of Image bins to create", min: 0, max: 999,
                            roundValues: true, spreadLow: true, dataName: "sliderBinCount",
                        },
                        {
                            colPickerList: "", tip: "Sets column used to map the Image axis", dataName: "colName",
                            closeAction: true, mapToDefaultCol: true, minWidth: 250, includeNone: true,
                        },
                    ]
                },
                //---- VALUES tab ----
                {
                    tabName: "Breaks", tip: "Adjust the settings for column breaks", rows: [
                        {
                            //---- MAPPING OPTIONS pane ----
                            pane: "Break Options", hideToggle: true, minWidth: 250, colSpan: 99, id: "mappingOptionsPane", rows: [
                                // { colSpan: 2, checkbox: "Use nice numbers", tip: "Use nice numbers and auto select steps", dataName: "useNiceNumbers" },
                                { checkbox: "Custom break values:", tip: "Use custom break values for the Image axis", dataName: "useCustomBreaks" },
                                {
                                    newRowIndent: true, textBox: "", tip: "Specify comma separated break values of Image axis (for bins/ticks)",
                                    dataName: "customBreaks", width: 150, noSelectOnFocus: true, colSpan: 99
                                },
                                { checkbox: "Custom labels:", tip: "Use custom labels for the Image axis", dataName: "useCustomLabels" },
                                {
                                    newRowIndent: true, textBox: "", tip: "Specify comma separated labels for break values of Image axis (for bins/ticks)",
                                    dataName: "customLabels", width: 150, noSelectOnFocus: true, colSpan: 99
                                },
                            ]
                        },
                        {
                            //---- OTHER pane ----
                            pane: "Other", hideToggle: true, minWidth: 250, colSpan: 99, id: "binOptionsPane", rows: [
                                {
                                    colSpan: 2, checkbox: "Force category", tip: "Treat numeric and data values as strings",
                                    dataName: "forceCategory", id: "cbForceCategory"
                                },
                                //{
                                //    enumPicker: "Value spread:", tip: "Controls how values are mapped",
                                //    dataName: "valueSpread", enumType: MappingSpread, id: "ddValueSpread"
                                //},
                                {
                                    enumPicker: "Bin sort:", tip: "Controls how Image bins are sorted",
                                    dataName: "binSorting", enumType: beachParty.BinSorting, id: "ddBinSort"
                                },
                            ]
                        },
                    ] // end of rows
                },
                //---- PICKER OPTIONS tab ----
                {
                    tabName: "Options", tip: "Adjust the column picker options", rows: [
                        {
                            //---- MAPPING OPTIONS pane ----
                            pane: "Picker Options", hideToggle: true, colSpan: 99,
                            minWidth: 250, id: "mappingOptionsPane", rows: [
                                { colSpan: 2, checkbox: "Sort column names", tip: "Sort the column names in the column picker", dataName: "isColPickerSorted" },
                                { colSpan: 2, checkbox: "Show column types", tip: "Show the type of each column in the column picker", dataName: "showTypesInColPicker" },
                                { colSpan: 2, checkbox: "Show unique value counts", tip: "Show the count of unique strings for each column in the column picker", dataName: "showCountsInColPicker" },
                                { colSpan: 2, checkbox: "Show system columns", tip: "Include the names of the system columns in the column picker", dataName: "showSysColsInColPicker" },
                            ]
                        }
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    timePanel.ts - describes the time panel (for animating shapes over time or other dimension)
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.timePanel =
        {
            title: "Time",
            tip: "Animates shapes as data plays back over time",
            colFill: true,
            cellPadding: 4,
            tabs: [
                //---- PLAY tab ----
                {
                    tabName: "Play", tip: "Control the time playback of data", rows: []
                },
                //---- OPTIONS tab ----
                {
                    tabName: "Options", tip: "Configure time playback options", rows: []
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    layersPanel.ts - describes the panel for configuring the layers of the current view.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.layersPanel =
        {
            title: "Layers",
            tip: "Specify parameters for configuring the layers of the current view",
            colFill: true,
            cellPadding: 4,
            tabs: [
                //---- SHOW tab ----
                {
                    tabName: "Show", tip: "Specifies the layer visibility", rows: [
                        { checkbox: "Shapes", tip: "When checked, the shapes layer is shown", dataName: "showShapes" },
                        { checkbox: "Text", tip: "When checked, the text layer is shown", dataName: "showText" },
                        { checkbox: "Lines", tip: "When checked, the lines layer is shown", dataName: "showLines" },
                        { checkbox: "Overlays", tip: "When checked, the overlays layer is shown", dataName: "showOverlays" },
                        { checkbox: "Maps", tip: "When checked, the maps layer is shown", dataName: "showMaps" },
                    ]
                },
                //---- SHAPES tab ----
                {
                    tabName: "Shapes", tip: "Configure the shapes layer",
                    colFill: true,
                    cellPadding: 4,
                    rows: [
                        {
                            numAdjuster: "Shape size:", tip: "Adjust the size factor applied to all shapes",
                            min: 0, max: 10, dataName: "sizeFactor", newCol: true, syncChanges: true, dataCompletedName: "sizeFactorCompleted",
                        },
                        {
                            numAdjuster: "Shape opacity:", tip: "Adjust the opacity applied to all shapes", min: 0, max: 1,
                            dataName: "shapeOpacity", dataCompletedName: "shapeOpacityCompleted", newCol: true, syncChanges: true
                        },
                        { colorPicker: "Shape color:", tip: "Sets the shape color (used when color is not mapped to a column) ", dataName: "shapeColor" },
                        { shapePicker: "Shape image: ", tip: "Sets the image used to draw shapes for the current view", dataName: "shapeImage" },
                    ]
                },
                //---- TEXT tab ----
                {
                    tabName: "Text", tip: "Configure the text layer", rows: []
                },
                //---- LINES tab ----
                {
                    tabName: "Lines", tip: "Configure the lines layer", rows: []
                },
                //---- OVERLAYS tab ----
                {
                    tabName: "Overlays", tip: "Configure the overlays layer", rows: []
                },
                //---- MAPS tab ----
                {
                    tabName: "Maps", tip: "Configure the maps layer", rows: []
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    selectionPanel.ts - describes the panel for managing the selection shortcuts and history.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.selectionPanel =
        {
            title: "Selection",
            tip: "Manage the selection shortcuts and history",
            colFill: true,
            cellPadding: 4,
            tabs: [
                //---- SHORTCUTS tab ----
                {
                    tabName: "Shortcuts", tip: "Invoke and manage the selection shortcuts", rows: []
                },
                //---- HISTORY tab ----
                {
                    tabName: "History", tip: "Invoke and manage the selection history", rows: []
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    filterPanel.ts - describes the panel for managing the filter shortcuts and history.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.filterPanel =
        {
            title: "Filter",
            tip: "Manage the filter shortcuts and history",
            colFill: true,
            cellPadding: 4,
            tabs: [
                //---- SHORTCUTS tab ----
                {
                    tabName: "Shortcuts", tip: "Invoke and manage the filter shortcuts", rows: []
                },
                //---- HISTORY tab ----
                {
                    tabName: "History", tip: "Invoke and manage the filter history", rows: []
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    tasksPanel.ts - describes the panel for helping the user find actions for certain tasks.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.tasksPanel =
        {
            title: "Tasks",
            autoClose: true,
            width: 500,
            omitLongList: true,
            isFloating: true,
            tabs: [
                {
                    //---- OVERVIEW tab ----
                    tabName: "Overview", tip: "Shortcuts for getting an overview of the current dataset", rows: [
                        {
                            longPrompt: "The best way to start looking at data is with a high level overview that shows the columns that are available and how values are distributed within each column.",
                            tip: "From Ben Schneiderman's Visual Information Seeking Mantra"
                        },
                        { emptyRow: true },
                        { prompt: "Recommended:", tip: "Recommended shortcuts for an overview" },
                        { newRowIndent: true, longPrompt: "The column view is currently the best way to get an overview of the data:" },
                        {
                            newRowIndent: true, button: "Column", dataName: "selectColumnView", width: 80,
                            tip: "The column view is currently the best way to get an overview of the data",
                        },
                    ]
                },
                {
                    //---- DISTRIBUTION tab ----
                    tabName: "Distribution", tip: "Shortcuts for view how values are distributed in each column", rows: [
                        {
                            longPrompt: "Its often helpful to look at how values are distributed within a column.",
                        },
                        { emptyRow: true },
                        { prompt: "Recommended:", tip: "Recommended shortcuts for looking at data distribution" },
                        {
                            newRowIndent: true, button: "Column", dataName: "selectColumnView", width: 80,
                            tip: "The column view is currently the best way to see the distribution of data",
                        },
                        {
                            newRowIndent: true, button: "Bar", dataName: "selectBarView", width: 80,
                            tip: "The Bar view is a horizontal version of the Column view.  Axis labels are more readable in the Bar view if a lot of bins are being used",
                        },
                        { emptyRow: true },
                        { prompt: "Experimental:", tip: "Experimental shortcuts for an overview" },
                        {
                            newRowIndent: true, button: "Density", dataName: "selectDensityView", width: 80,
                            tip: "The Density view can be used to view the distribution of two columns at once",
                        },
                        {
                            newRowIndent: true, button: "Violin", dataName: "selectViolinView", width: 80,
                            tip: "The Violin view is an alternate to the Density view, for viewing the distirubtion of two columns at once",
                        },
                    ]
                },
                {
                    //---- OUTLIERS tab ----
                    tabName: "Outliers", tip: "Shortcuts for viewing outliers in the data", rows: [
                        {
                            longPrompt: "Outliers are records whose values don't match the patterns of other records.  A record can be an outlier based on 1 or more columns.",
                        },
                        { emptyRow: true },
                        { prompt: "Recommended:", tip: "Recommended shortcuts for viewing outliers" },
                        {
                            newRowIndent: true, button: "Scatter w/color", dataName: "selectScatterViewColor", width: 100,
                            tip: "The Scatter view with color mapping is a good way to spot outliers",
                        },
                        {
                            newRowIndent: true, button: "Squarify w/color", dataName: "selectSquarifyViewColor", width: 100,
                            tip: "The Squarify view with color mapping is another good way to spot outliers",
                        },
                    ]
                },
                {
                    //---- RELATIONSHIP tab ----
                    tabName: "Relationships", tip: "Shortcuts for viewing the relationship between columns", rows: [
                        {
                            longPrompt: "To find relationships (aka correlations) between columns, a mapping of the columns is normally used.",
                        },
                        { emptyRow: true },
                        { prompt: "Recommended:", tip: "Recommended shortcuts for viewing relationships" },
                        {
                            newRowIndent: true, button: "Scatter", dataName: "selectScatterView", width: 80,
                            tip: "The Scatter view is currently the best way to see relations between 2 columns",
                        },
                        {
                            newRowIndent: true, button: "Scatter3D", dataName: "selectScatter3DView", width: 80,
                            tip: "The Scatter3D allows you to explore relations between 3 columns at once",
                        },
                        { emptyRow: true },
                        { prompt: "Experimental:", tip: "Experimental shortcuts for an overview" },
                        {
                            newRowIndent: true, button: "Density", dataName: "selectDensityView", width: 80,
                            tip: "The Density view can be used to view the distribution of two columns at once",
                        },
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    publishPanel.ts - for publishing insights to a web page on the SandDance (BeachParty) server.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.publishPanel =
        {
            title: "Publish Insights",
            tip: "Information about publishing insights to a web page on the SandDance server",
            isDialog: true,
            isFloating: true,
            //maxWidth: 400,
            rows: [
                { prompt: "You are about to publish your insights to a SandDance-hosted web page.  The following conditions will apply to the webpage:" },
                { emptyRow: true, height: 20 },
                { prompt: "1. PUBLIC - The webpage will be visible to anyone who knows its address (URL)." },
                { prompt: "2. TEMPORARY: The webpage should be considered temporary, subject to removal 7 days after publication." },
                { prompt: "3. ANONYMOUS: Since user accounts are not currently supported, the publication will be anonymous." },
                { prompt: "4. UNDELETABLE: Since the publication is annonymous, you will not be able to delete the webpage once it is published." },
                { prompt: "5. INSIGHTS ONLY: Your data is not published; only the images and metadata that comprise the insights are published." },
                { prompt: "6. WEB DATA: Local data files referenced by insights will be inaccessible to others; you should only use WEB data files. " },
                { emptyRow: true, height: 20 },
                {
                    button: "Cancel", tip: "Cancel the poublish process for my insights", width: 80,
                    cancelButton: true, tabIndex: 6, marginLeft: 10, float: "right",
                },
                {
                    sameRow: true, button: "Publish", tip: "Continue with the publish process for my insights", width: 80,
                    acceptButton: true, defaultButton: true, tabIndex: 5, float: "right",
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    itemsPanel.ts - describes the panel for item sampling and aggregation.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.itemsPanel =
        {
            title: "Items",
            tip: "Specify parameters for sampling and aggregating items in the current dataset",
            colFill: true,
            cellPadding: 4,
            tabs: [
                //---- SUMMARY tab ----
                {
                    tabName: "Summary", tip: "Summarizes the data operations to create the SandDance working dataset", rows: [
                        {
                            display: "File items: ", dataName: "fileItemCount",
                            tip: "The number of records read from the file"
                        },
                        {
                            display: "Transformed items: ", dataName: "transformItemCount",
                            tip: "The number of records after the item transformations have been applied"
                        },
                    ]
                },
                //---- COLUMNS tab ----
                {
                    tabName: "Columns", tip: "Manage the active columns", rows: []
                },
                //---- AGGREGATION tab ----
                {
                    tabName: "Agg", tip: "Set hard and soft aggregation fields", rows: []
                },
                //---- JOIN tab ----
                {
                    tabName: "Join", tip: "Manage joins between tables", rows: []
                },
                //---- CALC FIELDS tab ----
                {
                    tabName: "Calc", tip: "Create and manage calculated fields", rows: []
                },
                //---- MACHINE LEARNING tab ----
                {
                    tabName: "ML", tip: "Create and manage machine learning fields", rows: []
                },
                //---- FILTER tab ----
                {
                    tabName: "Filter", tip: "Filter the records", rows: []
                },
                //---- SAMPLING tab ----
                {
                    tabName: "Sample", tip: "Sample and limit the dataset records", rows: []
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    aggPanel.ts - describes the panel for controlling aggregation and sampling.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.aggPanel =
        {
            title: "Agg Panel",
            tip: "Specify data reduction parameters (sampling and aggregation)",
            colFill: true,
            rows: [
                {
                    checkbox: "Sampling: ", tip: "Enables the specified sampling function", dataName: "isSampEnabled",
                    marginTop: 10, marginRight: 14,
                },
                {
                    newRowIndent: true, enumPicker: null, tip: "Specifies the function to use to sample the data",
                    dataName: "sampType", enumType: beachParty.SampleType
                },
                {
                    sameRow: true, numAdjuster: "Count:", tip: "Specifies the number of record to return after sampling",
                    min: 1, max: 100000, dataName: "sampleCount", roundValues: true, spreadLow: true, textWidth: 60
                },
                {
                    checkbox: "Aggregation: ", tip: "Enables the specified aggregation function",
                    dataName: "isAggEnabled", marginTop: 14, marginRight: 14,
                },
                {
                    newRowIndent: true, enumPicker: null, tip: "Specifies the function to use to aggregate the Y column data",
                    dataName: "aggType", enumType: beachParty.AggType
                },
                { sameRow: true, colPicker: "Column:", tip: "Sets the column whose value will be aggregated", dataName: "aggTarget" },
                { sameRow: true, colPicker: "By:", tip: "Sets the grouping column for the aggregation", dataName: "aggGroup" },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    searchPanel.ts - describes the panel for doing a simple search.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.searchPanel =
        {
            title: "Search",
            tip: "Search for values using in all or specific columns",
            isFloating: true,
            tabs: [
                //---- SEARCH tab ----
                {
                    tabName: "Search", tip: "Search for values",
                    isFloating: true,
                    cellPadding: 2,
                    colFill: true,
                    //maxWidth: 300,
                    rows: [
                        {
                            textBox: "Search for:", tip: "The name of the insight", dataName: "searchValue",
                            fillParent: true, tabIndex: 5, incremental: true, width: 100
                        },
                        {
                            sameRow: true, button: null, img: "iconbar_search.png", width: 24,
                            tip: "Search for the value", marginLeft: -4, dataName: "applySearchQuery"
                        },
                        {
                            colPicker: "In column:", tip: "Select a specific column to be searched",
                            dataName: "searchCol", tabIndex: 6, noneName: "( All )", colSpan: 99, minWidth: 80
                        },
                    ]
                },
                //---- OPTIONS tab ----
                {
                    tabName: "Options", tip: "View or change the search options",
                    rows: [
                        { prompt: "Matching:", tip: "These options specify how search matches the target to values" },
                        {
                            newRowIndent: true, radio: "Starts with", dataName: "searchType", value: "startsWith", tabIndex: 1,
                            tip: "When checked, search matches are formed when data values start with the search value",
                        },
                        {
                            newRowIndent: true, radio: "Contains", dataName: "searchType", value: "contains", tabIndex: 2,
                            tip: "When checked, search matches are formed when data values start with the search value",
                        },
                        {
                            newRowIndent: true, radio: "Exact match", dataName: "searchType", value: "exact", tabIndex: 3,
                            tip: "When checked, search matches are formed when data values start with the search value",
                        },
                        { prompt: "Other options:", tip: "These options specify how search operates" },
                        {
                            newRowIndent: true, checkbox: "Incremental",
                            tip: "Performs a search as each character is typed in the search box",
                            dataName: "isIncrementalSearch", tabIndex: 4, colSpan: 2
                        },
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    linePanel.ts - describes the panel for setting LINE BY mapping options
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.lineByPanel =
        {
            title: "Line by",
            autoClose: true,
            tabs: [
                //---- COLUMN tab ----
                {
                    tabName: "Column", tip: "Specifies which column is used for Line mapping",
                    width: 200,
                    rows: [
                        {
                            numAdjuster: "Maximum:", tip: "Specifies the maximum number of lines to create", min: 1, max: 99999,
                            roundValues: true, spreadLow: true, dataName: "maxLineShapes", textWidth: 40,
                            synchChanges: true,
                        },
                        {
                            newRowIndent: true, lineColorPicker: "Color:", tip: "Sets the color of the lines", dataName: "lineColor",
                            includeShapeColor: true
                        },
                        {
                            longPrompt: "This column defines the line drawing groups."
                        },
                        {
                            colPickerList: "", tip: "Sets column used to map the Line axis", dataName: "colName",
                            closeAction: true, mapToDefaultCol: true, minWidth: 250, includeNone: true,
                        },
                    ]
                },
                ////---- BREAKS tab ----
                //{
                //    tabName: "Breaks", tip: "Adjust the settings for column breaks", rows:
                //    [
                //        {
                //            //---- MAPPING OPTIONS pane ----
                //            pane: "Break Options", hideToggle: true, minWidth: 250, colSpan: 99, id: "mappingOptionsPane", rows: [
                //                {
                //                    numAdjuster: "Lines:", tip: "Specifies the number of Line bins to create", min: 0, max: 999,
                //                    roundValues: true, spreadLow: true, dataName: "sliderBinCount",
                //                },
                //                // { colSpan: 2, checkbox: "Use nice numbers", tip: "Use nice numbers and auto select steps", dataName: "useNiceNumbers" },
                //                { checkbox: "Custom break values:", tip: "Use custom break values for the Line axis", dataName: "useCustomBreaks" },
                //                {
                //                    newRowIndent: true, textBox: "", tip: "Specify comma separated break values of Line axis (for bins/ticks)",
                //                    dataName: "customBreaks", width: 150, noSelectOnFocus: true, colSpan: 99
                //                },
                //                { checkbox: "Custom labels:", tip: "Use custom labels for the Line axis", dataName: "useCustomLabels" },
                //                {
                //                    newRowIndent: true, textBox: "", tip: "Specify comma separated labels for break values of Line axis (for bins/ticks)",
                //                    dataName: "customLabels", width: 150, noSelectOnFocus: true, colSpan: 99
                //                },
                //            ]
                //        },
                //        {
                //            //---- OTHER pane ----
                //            pane: "Other", hideToggle: true, minWidth: 250, colSpan: 99, id: "binOptionsPane", rows: [
                //                {
                //                    colSpan: 2, checkbox: "Force category", tip: "Treat numeric and data values as strings",
                //                    dataName: "forceCategory", id: "cbForceCategory"
                //                },
                //                //{
                //                //    enumPicker: "Value spread:", tip: "Controls how values are mapped",
                //                //    dataName: "valueSpread", enumType: MappingSpread, id: "ddValueSpread"
                //                //},
                //                {
                //                    enumPicker: "Bin sort:", tip: "Controls how Line bins are sorted",
                //                    dataName: "binSorting", enumType: BinSorting, id: "ddBinSort"
                //                },
                //            ]
                //        },
                //    ]   // end of rows
                //},
                //---- PICKER OPTIONS tab ----
                {
                    tabName: "Options", tip: "Adjust the column picker options", rows: [
                        {
                            //---- MAPPING OPTIONS pane ----
                            pane: "Picker Options", hideToggle: true, colSpan: 99,
                            minWidth: 250, id: "mappingOptionsPane", rows: [
                                { colSpan: 2, checkbox: "Sort column names", tip: "Sort the column names in the column picker", dataName: "isColPickerSorted" },
                                { colSpan: 2, checkbox: "Show column types", tip: "Show the type of each column in the column picker", dataName: "showTypesInColPicker" },
                                { colSpan: 2, checkbox: "Show unique value counts", tip: "Show the count of unique strings for each column in the column picker", dataName: "showCountsInColPicker" },
                                { colSpan: 2, checkbox: "Show system columns", tip: "Include the names of the system columns in the column picker", dataName: "showSysColsInColPicker" },
                            ]
                        }
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    browsePanel.ts - describes the panel for facet browsing.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.browsePanel =
        {
            title: "Browse", tip: "Search for values using text and slicer controls",
            tabs: [
                //---- BROWSE tab ----
                {
                    tabName: "Browse", tip: "Browse the data using facet-type filtering", rows: [
                        {
                            sameRow: true, button: "Add node", id: "btAddNode", tip: "Add another search node to the list", dataName: "addSearchNode",
                            topMargin: 6, bottomMargin: -16, leftMargin: 20, textAlign: "right"
                        },
                    ]
                },
                //---- OPTIONS tab ----
                {
                    tabName: "Options", tip: "Configure time playback options", rows: [
                        //{ prompt: "Options:", tip: "These options specify how search operates" },
                        //{ newRowIndent: true, checkbox: "Starts with", tip: "When checked, search matches are formed when data values start with the search value", dataName: "isStartsWith" },
                        {
                            col: 0, checkbox: "Incremental search", tip: "Performs a search as each character is typed in the search box",
                            dataName: "isIncrementalSearch", topMargin: 16,
                        },
                        {
                            col: 0, checkbox: "Multiple search panes", tip: "Enable more than search pane to be created and combined",
                            dataName: "isMultiSearchPanes", topMargin: 16,
                        },
                        {
                            col: 0, checkbox: "Isolate matches", tip: "When set, the non-matching items will be filtered out of the view, leaving only the matching items",
                            dataName: "isolateMatches", topMargin: 16,
                        },
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    dataTipPanel.ts - describes the panel for creating a Data Tip.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    if (!anyWindow.panelDescriptions) {
        anyWindow.panelDescriptions = {};
    }
    anyWindow.panelDescriptions.tipsPanel =
        {
            title: "Tips",
            tip: "Settings for Tooltips and Data Tips",
            maxWidth: 400,
            isFloating: true,
            tabs: [
                {
                    tabName: "Datatips", tip: "Panel for creating data tips",
                    cellPadding: 3,
                    rows: [
                        { colSpan: 99, prompt: "Creates a draggable datatip at the center of the plot." },
                        { emptyRow: true },
                        {
                            textBox: "Title:", tip: "Optional title for the datatip", dataName: "dataTipTitle",
                            width: 280, noSelectOnFocus: true, sameCol: true, colSpan: 99,
                            placeHolder: "optional title", leftMargin: 10,
                        },
                        {
                            checkbox: "Include column names", tip: "When true, column names are included in the datatip",
                            dataName: "includeNamesInDatatip", sameCol: true
                        },
                    ]
                },
                {
                    tabName: "Tooltips", tip: "Configuration of tooltips",
                    cellPadding: 3,
                    rows: [
                        { checkbox: "Show tooltips", tip: "When true, mouse tooltips are enabled", dataName: "isTooltipsEnabled" },
                        {
                            checkbox: "Draw hover on mouse move", tip: "When true, hover affect is drawn on shape under mouse",
                            dataName: "hoverOnMouseMove"
                        },
                        {
                            checkbox: "Include column names", tip: "When true, column names are included in the tooltip",
                            dataName: "includeNamesInTooltip"
                        },
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    aboutPanel.ts - describes the panel for displaying About, Debug, Test informaton.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    if (!anyWindow.panelDescriptions) {
        anyWindow.panelDescriptions = {};
    }
    anyWindow.panelDescriptions.navPanel =
        {
            title: "Nav Panel", tip: "Specify what dragging with mouse and touch should do", isDialog: true,
            rows: [
                { prompt: "Drag Action:", tip: "Specify the action for mouse/touch dragging", dataName: "dragAction" },
                { radio: "Select shapes (rectangle)", leftMargin: 15, tip: "Select the shapes within the rectangle", value: "select", dataName: "dragAction", },
                { radio: "Zoom in (rectangle)", leftMargin: 15, tip: "Zoom in on the specified rectangle", value: "zoomIn", dataName: "dragAction", checked: true },
                { radio: "3D rotate (drag)", leftMargin: 15, tip: "Rotate the camera in 3D space", value: "rotate", dataName: "dragAction", },
                { radio: "Move (drag)", leftMargin: 15, tip: "Move (pan) the camera", value: "move", dataName: "dragAction", },
                { radio: "Wheel (drag)", leftMargin: 15, tip: "Navigate using the displayed Nav Wheel", value: "wheel", dataName: "dragAction", },
                { emptyRow: true },
                { newRowIndent: true, button: "Reset navigation", tip: "Reset to the normal zoom, rotation, and placement", textAlign: "right", dataName: "onResetTransforms", width: 120 },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    clusterPanel.ts - describes the panel for performing clustering operations.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.clusterPanel =
        {
            title: "Cluster Panel",
            hideTitle: true,
            minWidth: 350,
            cellPadding: 0,
            colFill: true,
            rows: [
                {
                    col: 0, numAdjuster: "Clusters:", tip: "Set the number of clusters to be discovered", min: 1, max: 25,
                    dataName: "numClusters", newCol: true, roundValues: true,
                },
                {
                    sameRow: false, numAdjuster: "Runs:", tip: "Set the number of runs to find the best clustering", min: 1, max: 99,
                    dataName: "numRuns", newCol: true, roundValues: true,
                },
                { col: 0, display: "From:", tip: "Displays the columns that will be used in the clustering", dataName: "columns", readonly: true, noSelectOnFocus: true, },
                { col: 0, textBox: "To:", tip: "Specifies the output column where the coluster ID should be written", dataName: "outputColumn", noSelectOnFocus: false, },
                { emptyRow: true },
                { col: 0, enumPicker: "Map results: ", tip: "Specify how to apply the results", dataName: "mapResults", enumType: beachParty.ClusterResultMapping },
                { col: 0, checkbox: "Clusters overlay", tip: "Specify if cluster drawings should be overlayed on plot", dataName: "isClusterOverlay" },
                //{ col: 0, checkbox: "Auto clustering", tip: "Automatically recluster when x, y, or z column mappings change and this panel is open", dataName: "isAutoClustering" },
                { emptyRow: true },
                { emptyRow: true },
                {
                    col: 0, button: "Start", tip: "Start the cluster discovery computation", dataName: "onStartButton", id: "start",
                },
                {
                    sameRow: true, progress: null, tip: "Displays the progress of the cluster discovery", dataName: "clusterProgress",
                    value: 0, max: 100, width: 150, height: 12, marginLeft: 10, marginTop: -12, id: "progress", colSpan: 99
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    viewAsPanel.ts - describes the panel for changing charts and chart properties.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.viewAsPanel =
        {
            title: "View",
            hideTitle: true,
            tabs: [
                //---- VIEW TAB ----
                {
                    tabName: "View", tip: "Select a chart type",
                    cellPadding: 3,
                    colFill: true,
                    rows: []
                },
                //---- SHAPES tab ----
                {
                    tabName: "Shapes", tip: "Configure the shapes layer",
                    colFill: true,
                    cellPadding: 4,
                    rows: [
                        {
                            numAdjuster: "Shape size:", tip: "Adjust the size factor applied to all shapes",
                            min: 0, max: 5, dataName: "sizeFactor", newCol: true, syncChanges: true, dataCompletedName: "sizeFactorCompleted",
                            spreadLow: true,
                        },
                        {
                            numAdjuster: "Shape separation:", tip: "Adjust the separation factor used in layout-style views",
                            min: 0, max: 5, dataName: "separationFactor", newCol: true, id: "separation"
                        },
                        {
                            numAdjuster: "Shape opacity:", tip: "Adjust the opacity applied to all shapes", min: 0, max: 1,
                            dataName: "shapeOpacity", dataCompletedName: "shapeOpacityCompleted", newCol: true, syncChanges: true
                        },
                        { colorPicker: "Shape color:", tip: "Sets the shape color (used when color is not mapped to a column) ", dataName: "shapeColor" },
                        { shapePicker: "Shape image: ", tip: "Sets the image used to draw shapes for the current view", dataName: "shapeImage" },
                    ]
                },
                //---- OPTIONS TAB ----
                {
                    tabName: "Options", tip: "Settings for the current chart type", id: "chartName",
                    cellPadding: 3,
                    colFill: true,
                    rows: [
                        { prompt: "Chart title:", tip: "Title options" },
                        {
                            newRowIndent: true, checkbox: "Title:", tip: "Show the chart title",
                            dataName: "isTitleTextVisible"
                        },
                        {
                            sameRow: true, textBox: null, tip: "The text to display as the chart title",
                            dataName: "titleText", width: 200, noSelectOnFocus: true, colSpan: 99, marginLeft: 4
                        },
                        {
                            newRowIndent: true, checkbox: "Item counts", tip: "Show the Item, Filtered in, and Selected counts below the title",
                            dataName: "isItemCountsVisible"
                        },
                        { prompt: "Chart:", tip: "Change chart-specific settings", id: "chartType", rowMarginTop: 20, },
                        //{ emptyRow: true, id: "emptyRow2" },
                        {
                            newRowIndent: true, checkbox: "X gridlines", tip: "Show the vertical gridlines associated with the X axis",
                            dataName: "showXGridLines", id: "xGridLines"
                        },
                        {
                            newRowIndent: true, checkbox: "Y gridlines", tip: "Show the vertical gridlines associated with the Y axis",
                            dataName: "showYGridLines", id: "yGridLines"
                        },
                        {
                            newRowIndent: true, numAdjuster: "Stacking columns:", tip: "Adjust the number of columns used in the Stacks layout", min: 1, max: 10,
                            dataName: "zBins", newCol: true, roundValues: true, id: "stackingCols"
                        },
                        {
                            newRowIndent: true, numAdjuster: "Columns:", tip: "Adjust the number of columns in a Flat layout", min: 0, max: 999,
                            dataName: "numColumns", newCol: true, roundValues: true, id: "numCols"
                        },
                        {
                            newRowIndent: true, checkbox: "Build from top", tip: "Start the layout at the top of the plot", dataName: "buildFromTop",
                            id: "buildFromTop"
                        },
                        {
                            newRowIndent: true, button: "Next spiral", tip: "Pick a new seed for the spiral layout", dataName: "nextSpiral",
                            id: "nextSpiral"
                        }
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    sumPanel.ts - describes the panel for setting SUM BY mapping options (using the AUX mapping).
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.sumPanel =
        {
            title: "Sum by",
            autoClose: true,
            tabs: [
                //---- COLUMN tab ----
                {
                    tabName: "Mapping", tip: "Specifies which column is used for Sum mapping",
                    rows: [
                        { enumPicker: "Count layout:", tip: "Controls layout used for counting units", dataName: "countLayout", enumType: beachParty.CountLayoutType },
                        { enumPicker: "Sum layout:", tip: "Controls layout used for summing units", dataName: "sumLayout", enumType: beachParty.SumLayoutType },
                        { emptyRow: true },
                        { prompt: "Sum by:" },
                        {
                            colPickerList: "", tip: "Sets column used to map the Sum axis", dataName: "colName",
                            closeAction: true, mapToDefaultCol: true, minWidth: 250, includeNone: true,
                        },
                    ]
                },
                //---- PICKER OPTIONS tab ----
                {
                    tabName: "Options", tip: "Adjust the column picker options", rows: [
                        {
                            //---- MAPPING OPTIONS pane ----
                            pane: "Picker Options", hideToggle: true, colSpan: 99,
                            minWidth: 250, id: "mappingOptionsPane", rows: [
                                { colSpan: 2, checkbox: "Sort column names", tip: "Sort the column names in the column picker", dataName: "isColPickerSorted" },
                                { colSpan: 2, checkbox: "Show column types", tip: "Show the type of each column in the column picker", dataName: "showTypesInColPicker" },
                                { colSpan: 2, checkbox: "Show unique value counts", tip: "Show the count of unique strings for each column in the column picker", dataName: "showCountsInColPicker" },
                                { colSpan: 2, checkbox: "Show system columns", tip: "Include the names of the system columns in the column picker", dataName: "showSysColsInColPicker" },
                            ]
                        }
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    textPanel.ts - describes the panel for setting text mapping options
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.textPanel =
        {
            title: "Text by",
            autoClose: true,
            rows: [
                {
                    numAdjuster: "Maximum:", tip: "Specifies the maximum number of shapes to create", min: 1, max: 999,
                    roundValues: true, spreadLow: true, dataName: "maxTextShapes"
                },
                //---- note: marginBottom is not effective here; go to app.openSizePanelCore() to adjust ----
                { colPickerList: "", tip: "Sets column used to map text", includeNone: true, dataName: "textColumn" },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    shapePanel.ts - describes the panel for setting SHAPE BY mapping options
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.shapePanel =
        {
            title: "Shape by",
            autoClose: true,
            tabs: [
                //---- COLUMN tab ----
                {
                    tabName: "Column", tip: "Specifies which column is used for shape mapping",
                    rows: [
                        {
                            numAdjuster: "Shapes:", tip: "Specifies the number of shape bins to create", min: 1, max: 6,
                            roundValues: true, spreadLow: true, dataName: "sliderBinCount",
                        },
                        {
                            colPickerList: "", tip: "Sets column used to map the shape axis", dataName: "colName",
                            closeAction: true, mapToDefaultCol: true, minWidth: 250, includeNone: true,
                        },
                    ]
                },
                //---- VALUES tab ----
                {
                    tabName: "Breaks", tip: "Adjust the settings for column breaks", rows: [
                        {
                            //---- MAPPING OPTIONS pane ----
                            pane: "Break Options", hideToggle: true, minWidth: 250, colSpan: 99, id: "mappingOptionsPane", rows: [
                                // { colSpan: 2, checkbox: "Use nice numbers", tip: "Use nice numbers and auto select steps", dataName: "useNiceNumbers" },
                                { checkbox: "Custom break values:", tip: "Use custom break values for the shape axis", dataName: "useCustomBreaks" },
                                {
                                    newRowIndent: true, textBox: "", tip: "Specify comma separated break values of shape axis (for bins/ticks)",
                                    dataName: "customBreaks", width: 150, noSelectOnFocus: true, colSpan: 99
                                },
                                { checkbox: "Custom labels:", tip: "Use custom labels for the shape axis", dataName: "useCustomLabels" },
                                {
                                    newRowIndent: true, textBox: "", tip: "Specify comma separated labels for break values of shape axis (for bins/ticks)",
                                    dataName: "customLabels", width: 150, noSelectOnFocus: true, colSpan: 99
                                },
                            ]
                        },
                        {
                            //---- OTHER pane ----
                            pane: "Other", hideToggle: true, minWidth: 250, colSpan: 99, id: "binOptionsPane", rows: [
                                {
                                    colSpan: 2, checkbox: "Force category", tip: "Treat numeric and data values as strings",
                                    dataName: "forceCategory", id: "cbForceCategory"
                                },
                                //{
                                //    enumPicker: "Value spread:", tip: "Controls how values are mapped",
                                //    dataName: "valueSpread", enumType: MappingSpread, id: "ddValueSpread"
                                //},
                                {
                                    enumPicker: "Bin sort:", tip: "Controls how shape bins are sorted",
                                    dataName: "binSorting", enumType: beachParty.BinSorting, id: "ddBinSort"
                                },
                            ]
                        },
                    ] // end of rows
                },
                //---- PICKER OPTIONS tab ----
                {
                    tabName: "Options", tip: "Adjust the column picker options", rows: [
                        {
                            //---- SHAPE OPTIONS pane ----
                            pane: "Shape Options", hideToggle: true, colSpan: 99,
                            minWidth: 250, id: "mappingOptionsPane", rows: [
                                { colSpan: 2, checkbox: "Use experimental images", tip: "Replace the standard shapes with a set of experimental images", dataName: "useExperimentalImages" },
                            ]
                        },
                        {
                            //---- COLUMN PICKER OPTIONS pane ----
                            pane: "Picker Options", hideToggle: true, colSpan: 99,
                            minWidth: 250, id: "mappingOptionsPane", rows: [
                                { colSpan: 2, checkbox: "Sort column names", tip: "Sort the column names in the column picker", dataName: "isColPickerSorted" },
                                { colSpan: 2, checkbox: "Show column types", tip: "Show the type of each column in the column picker", dataName: "showTypesInColPicker" },
                                { colSpan: 2, checkbox: "Show unique value counts", tip: "Show the count of unique strings for each column in the column picker", dataName: "showCountsInColPicker" },
                                { colSpan: 2, checkbox: "Show system columns", tip: "Include the names of the system columns in the column picker", dataName: "showSysColsInColPicker" },
                            ]
                        }
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    sizePanel.ts - describes the panel for setting SIZE BY mapping options
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.sizePanel =
        {
            title: "Size by",
            autoClose: true,
            tabs: [
                //---- COLUMN tab ----
                {
                    tabName: "Column", tip: "Specifies which column is used for size mapping",
                    rows: [
                        {
                            numAdjuster: "Steps:", tip: "Specifies the number of size bins to create", min: 0, max: 999,
                            roundValues: true, spreadLow: true, dataName: "sliderBinCount",
                        },
                        //{
                        //    enumPicker: "Size packing:", dataName: "sizePacking",
                        //    tip: "Controls how size by affects how shapes are packed",
                        //    enumType: SizePacking, id: "sizePacking"
                        //},
                        { prompt: "Mapping:", tip: "Select a column for size mapping" },
                        {
                            colPickerList: "", tip: "Sets column used to map the size axis", dataName: "colName",
                            closeAction: true, mapToDefaultCol: true, minWidth: 250, includeNone: true,
                        },
                    ]
                },
                //---- VALUES tab ----
                {
                    tabName: "Breaks", tip: "Adjust the settings for column breaks", rows: [
                        {
                            //---- MAPPING OPTIONS pane ----
                            pane: "Break Options", hideToggle: true, minWidth: 250, colSpan: 99, id: "mappingOptionsPane", rows: [
                                // { colSpan: 2, checkbox: "Use nice numbers", tip: "Use nice numbers and auto select steps", dataName: "useNiceNumbers" },
                                { checkbox: "Custom break values:", tip: "Use custom break values for the size axis", dataName: "useCustomBreaks" },
                                {
                                    newRowIndent: true, textBox: "", tip: "Specify comma separated break values of size axis (for bins/ticks)",
                                    dataName: "customBreaks", width: 150, noSelectOnFocus: true, colSpan: 99
                                },
                                { checkbox: "Custom labels:", tip: "Use custom labels for the size axis", dataName: "useCustomLabels" },
                                {
                                    newRowIndent: true, textBox: "", tip: "Specify comma separated labels for break values of size axis (for bins/ticks)",
                                    dataName: "customLabels", width: 150, noSelectOnFocus: true, colSpan: 99
                                },
                            ]
                        },
                        {
                            //---- OTHER pane ----
                            pane: "Other", hideToggle: true, minWidth: 250, colSpan: 99, id: "binOptionsPane", rows: [
                                {
                                    colSpan: 2, checkbox: "Force category", tip: "Treat numeric and data values as strings",
                                    dataName: "forceCategory", id: "cbForceCategory"
                                },
                                //{
                                //    enumPicker: "Value spread:", tip: "Controls how values are mapped",
                                //    dataName: "valueSpread", enumType: MappingSpread, id: "ddValueSpread"
                                //},
                                {
                                    enumPicker: "Bin sort:", tip: "Controls how size bins are sorted",
                                    dataName: "binSorting", enumType: beachParty.BinSorting, id: "ddBinSort"
                                },
                            ]
                        },
                    ] // end of rows
                },
                //---- PICKER OPTIONS tab ----
                {
                    tabName: "Options", tip: "Adjust the column picker options", rows: [
                        {
                            //---- MAPPING OPTIONS pane ----
                            pane: "Picker Options", hideToggle: true, colSpan: 99,
                            minWidth: 250, id: "mappingOptionsPane", rows: [
                                { colSpan: 2, checkbox: "Sort column names", tip: "Sort the column names in the column picker", dataName: "isColPickerSorted" },
                                { colSpan: 2, checkbox: "Show column types", tip: "Show the type of each column in the column picker", dataName: "showTypesInColPicker" },
                                { colSpan: 2, checkbox: "Show unique value counts", tip: "Show the count of unique strings for each column in the column picker", dataName: "showCountsInColPicker" },
                                { colSpan: 2, checkbox: "Show system columns", tip: "Include the names of the system columns in the column picker", dataName: "showSysColsInColPicker" },
                            ]
                        }
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    feedback.ts - dialog panel to collect feedback from the user.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.feedbackPanel =
        {
            title: "Feedback",
            isDialog: false,
            autoClose: true,
            //width: 500,
            rows: [
                { prompt: "Provide feedback on SandDance:", leftMargin: 10, tip: "Specify the type of feedback you want to provide", dataName: "feedbackType" },
                { radio: "Ideas", leftMargin: 15, tip: "An idea about a new feature or a way to improve an existing feature", value: "Ideas", dataName: "feedbackType", userAction: false },
                { radio: "Likes", leftMargin: 15, tip: "A comment about something you like in SandDance", value: "Likes", dataName: "feedbackType", userAction: false },
                { radio: "Dislikes", leftMargin: 15, tip: "A comment about something you don't like in SandDance", value: "Dislikes", dataName: "feedbackType", userAction: false },
                {
                    textArea: null, tip: "Your feedback.", dataName: "feedbackText", width: "400px", height: "100px", topMargin: 10,
                    placeholder: "Enter your feedback here."
                },
                { emptyRow: true },
                {
                    newRowIndent: true, button: "OK", tip: "Submit this feedback and close the panel", width: 80, textAlign: "right",
                    acceptButton: true, dataName: "submitFeedback", tabIndex: 100, closeAction: true,
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    scriptsPanel.ts - describes the panel for loading and lauching scripts
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.scriptsPanel =
        {
            title: "Scripts",
            tabs: [
                {
                    tabName: "Recording",
                    tip: "Control script recording",
                    cellPadding: 3,
                    colFill: true,
                    marginBottom: 0,
                    rows: [
                        { prompt: "Options:", tip: "Options for how scripts are recorded", topMargin: 6 },
                        {
                            newRowIndent: true, checkbox: "Record all sessions",
                            tip: "Should script recording continue in new sessions",
                            dataName: "recordAcrossSessions", colSpan: 99
                        },
                        {
                            newRowIndent: true, checkbox: "Include panel navigation",
                            tip: "Specifes that panel navigation actions should be included in recorded actions",
                            dataName: "isPanelNavRecorded", colSpan: 99
                        },
                        { newRow: true, topMargin: 10, bottomMargin: 10 },
                        {
                            button: "Start", tip: "Start recording", dataName: "onStartRecording",
                            tabIndex: 100, width: 60
                        },
                        {
                            sameRow: true, button: "Stop", tip: "Stop recordingt",
                            dataName: "onStopRecording", tabIndex: 101, width: 60
                        },
                        {
                            sameRow: true, display: null, tip: "Recording status", dataName: "recordStatus",
                            id: "labRecordStatus"
                        },
                    ]
                },
                {
                    tabName: "Playback",
                    tip: "Settings that control script recording",
                    cellPadding: 3,
                    //colFill: true,
                    marginBottom: 0,
                    loadOnInit: true,
                    rows: [
                        { prompt: "Script:", tip: "options for script playback" },
                        {
                            newRowIndent: true, scriptPicker: null, tip: "Select a standard or cached script", dataName: "scriptName",
                        },
                        {
                            sameRow: true, button: null, img: "menuBars.png", width: 24,
                            tip: "Select an action for the specified script", leftMargin: 4, id: "btMenu"
                        },
                        {
                            newRowIndent: true, numAdjuster: "Run count:", tip: "The number of times the script should be run",
                            min: 1, max: 99, dataName: "runCount", roundValues: true, syncChanges: true,
                        },
                        {
                            button: "Start", tip: "Start the specified script",
                            acceptButton: false, dataName: "onStartPlayback", tabIndex: 100, closeAction: false,
                            width: 60, topMargin: 0, rowMarginTop: 14
                        },
                        {
                            sameRow: true, button: "Stop", tip: "Stop the current script",
                            acceptButton: false, dataName: "onStopPlayback", tabIndex: 101, closeAction: false,
                            width: 60, topMargin: 0,
                        },
                        { sameRow: true, display: null, tip: "Playback status", dataName: "runStatus", id: "labRunStatus" },
                    ]
                }
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    palettesPanel.ts - describes the panel for managing color palettes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.palettesPanel =
        {
            title: "Palettes",
            isFloating: true,
            rows: [
                { prompt: "Select color palette set:", tip: "Select the current palette to manage", topMargin: 6 },
                {
                    newRowIndent: true, palettePicker: "Palette set:", tip: "Select a standard or cached palette set", dataName: "paletteSetName",
                },
                {
                    sameRow: true, button: null, img: "menuBars.png", width: 24,
                    tip: "Select an action for the specified Palette", leftMargin: 4, id: "btMenu"
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    helpPanel.ts - describes the help panel, including the chat bot.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.helpPanel =
        {
            title: "Help",
            width: 300,
            resizable: false,
            tabs: [
                {
                    tabName: "Data", tip: "Describe the current dataset", rows: [
                        {
                            display: null, marginRight: 20, dataName: "dataDescription", marginLeft: -4,
                        },
                    ]
                },
                {
                    tabName: "Chart", tip: "Describe the current chart", rows: [
                        {
                            display: null, marginRight: 20, dataName: "chartDescription", marginLeft: -4,
                        },
                    ]
                },
                {
                    tabName: "Concept Map", tip: "View the SandDance concept map", rows: []
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    yPanel.ts - describes the panel for setting Y axis mapping options
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.yPanel =
        {
            title: "Y axis",
            autoClose: true,
            tabs: [
                //---- COLUMN tab ----
                {
                    tabName: "Column", tip: "Specifies which column is used for Y mapping",
                    rows: [
                        {
                            colPickerList: "", tip: "Sets column used to map the Y axis", dataName: "colName",
                            closeAction: true, mapToDefaultCol: true, minWidth: 250,
                        },
                    ]
                },
                //---- VALUES tab ----
                {
                    tabName: "Breaks", tip: "Adjust the settings for column breaks", rows: [
                        {
                            //---- MAPPING OPTIONS pane ----
                            pane: "Break Options", hideToggle: true, minWidth: 250, colSpan: 99, id: "mappingOptionsPane", rows: [
                                //{
                                //    numAdjuster: "Breaks:", tip: "Specifies the number of Y steps/bins to create", min: 2, max: 999,
                                //    roundValues: true, spreadLow: true, dataName: "sliderBinCount",
                                //},
                                // { colSpan: 2, checkbox: "Use nice numbers", tip: "Use nice numbers and auto select steps", dataName: "useNiceNumbers" },
                                { checkbox: "Custom break values:", tip: "Use custom break values for the Y axis", dataName: "useCustomBreaks" },
                                {
                                    newRowIndent: true, textBox: "", tip: "Specify comma separated break values of Y axis (for bins/ticks)",
                                    dataName: "customBreaks", width: 150, noSelectOnFocus: true, colSpan: 99
                                },
                                { checkbox: "Custom labels:", tip: "Use custom labels for the Y axis", dataName: "useCustomLabels" },
                                {
                                    newRowIndent: true, textBox: "", tip: "Specify comma separated labels for break values of Y axis (for bins/ticks)",
                                    dataName: "customLabels", width: 150, noSelectOnFocus: true, colSpan: 99
                                },
                            ]
                        },
                        {
                            //---- OTHER pane ----
                            pane: "Other", hideToggle: true, minWidth: 250, colSpan: 99, id: "binOptionsPane", rows: [
                                {
                                    colSpan: 2, checkbox: "Force category", tip: "Treat numeric and data values as strings",
                                    dataName: "forceCategory", id: "cbForceCategory"
                                },
                                {
                                    enumPicker: "Value spread:", tip: "Controls how values are mapped",
                                    dataName: "valueSpread", enumType: beachParty.MappingSpread, id: "ddValueSpread"
                                },
                                {
                                    enumPicker: "Bin sort:", tip: "Controls how Y bins are sorted",
                                    dataName: "binSorting", enumType: beachParty.BinSorting, id: "ddBinSort"
                                },
                            ]
                        },
                    ] // end of rows
                },
                //---- PICKER OPTIONS tab ----
                {
                    tabName: "Options", tip: "Adjust the column picker options", rows: [
                        {
                            //---- MAPPING OPTIONS pane ----
                            pane: "Picker Options", hideToggle: true, colSpan: 99,
                            minWidth: 250, id: "mappingOptionsPane", rows: [
                                { colSpan: 2, checkbox: "Sort column names", tip: "Sort the column names in the column picker", dataName: "isColPickerSorted" },
                                { colSpan: 2, checkbox: "Show column types", tip: "Show the type of each column in the column picker", dataName: "showTypesInColPicker" },
                                { colSpan: 2, checkbox: "Show unique value counts", tip: "Show the count of unique strings for each column in the column picker", dataName: "showCountsInColPicker" },
                                { colSpan: 2, checkbox: "Show system columns", tip: "Include the names of the system columns in the column picker", dataName: "showSysColsInColPicker" },
                            ]
                        }
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    tourLoader.ts - describes the panel for loading and launching tours
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.tourLoaderPanel =
        {
            title: "Tour Loader",
            cellPadding: "8px 2px 0px 2px",
            isFloating: true,
            rows: [
                { prompt: "Select tour:", tip: "Select the current tour", marginTop: 0 },
                {
                    newRowIndent: true, tourPicker: "Tour:", tip: "Select a standard or cached tour", dataName: "tourName",
                },
                {
                    sameRow: true, button: null, img: "menuBars.png", width: 24,
                    tip: "Select an action for the specified Tour", marginLeft: 4, id: "btMenu"
                },
                {
                    button: "Start", tip: "Launch the specified tour",
                    acceptButton: true, dataName: "onStartTour", tabIndex: 100, closeAction: true,
                    textAlign: "center", colSpan: 99, width: 80, marginTop: 20,
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    zPanel.ts - describes the panel for setting Z axis mapping options
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.zPanel =
        {
            title: "Z axis",
            autoClose: true,
            tabs: [
                //---- COLUMN tab ----
                {
                    tabName: "Column", tip: "Specifies which column is used for Z mapping",
                    rows: [
                        {
                            colPickerList: "", tip: "Sets column used to map the Z axis", dataName: "colName",
                            closeAction: true, mapToDefaultCol: true, minWidth: 250,
                        },
                    ]
                },
                //---- VALUES tab ----
                {
                    tabName: "Breaks", tip: "Adjust the settings for column breaks", rows: [
                        //    {
                        //        //---- MAPPING OPTIONS pane ----
                        //        pane: "Break Options", hideToggle: true, minWidth: 250, colSpan: 99, id: "mappingOptionsPane", rows: [
                        //            //{
                        //            //    numAdjuster: "Breaks:", tip: "Specifies the number of Z steps/bins to create", min: 2, max: 999,
                        //            //    roundValues: true, spreadLow: true, dataName: "sliderBinCount",
                        //            //},
                        //            // { colSpan: 2, checkbox: "Use nice numbers", tip: "Use nice numbers and auto select steps", dataName: "useNiceNumbers" },
                        //            { checkbox: "Custom break values:", tip: "Use custom break values for the Z axis", dataName: "useCustomBreaks" },
                        //            {
                        //                newRowIndent: true, textBox: "", tip: "Specify comma separated break values of Z axis (for bins/ticks)",
                        //                dataName: "customBreaks", width: 150, noSelectOnFocus: true, colSpan: 99
                        //            },
                        //            { checkbox: "Custom labels:", tip: "Use custom labels for the Z axis", dataName: "useCustomLabels" },
                        //            {
                        //                newRowIndent: true, textBox: "", tip: "Specify comma separated labels for break values of Z axis (for bins/ticks)",
                        //                dataName: "customLabels", width: 150, noSelectOnFocus: true, colSpan: 99
                        //            },
                        //        ]
                        //    },
                        {
                            //---- OTHER pane ----
                            pane: "Other", hideToggle: true, minWidth: 250, colSpan: 99, id: "binOptionsPane", rows: [
                                {
                                    colSpan: 2, checkbox: "Force category", tip: "Treat numeric and data values as strings",
                                    dataName: "forceCategory", id: "cbForceCategory"
                                },
                                {
                                    enumPicker: "Value spread:", tip: "Controls how values are mapped",
                                    dataName: "valueSpread", enumType: beachParty.MappingSpread, id: "ddValueSpread"
                                },
                            ]
                        },
                    ] // end of rows
                },
                //---- PICKER OPTIONS tab ----
                {
                    tabName: "Options", tip: "Adjust the column picker options", rows: [
                        {
                            //---- MAPPING OPTIONS pane ----
                            pane: "Picker Options", hideToggle: true, colSpan: 99,
                            minWidth: 250, id: "mappingOptionsPane", rows: [
                                { colSpan: 2, checkbox: "Sort column names", tip: "Sort the column names in the column picker", dataName: "isColPickerSorted" },
                                { colSpan: 2, checkbox: "Show column types", tip: "Show the type of each column in the column picker", dataName: "showTypesInColPicker" },
                                { colSpan: 2, checkbox: "Show unique value counts", tip: "Show the count of unique strings for each column in the column picker", dataName: "showCountsInColPicker" },
                                { colSpan: 2, checkbox: "Show system columns", tip: "Include the names of the system columns in the column picker", dataName: "showSysColsInColPicker" },
                            ]
                        }
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    xPanel.ts - describes the panel for setting X axis mapping options
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.xPanel =
        {
            title: "X axis",
            autoClose: true,
            tabs: [
                //---- COLUMN tab ----
                {
                    tabName: "Column", tip: "Specifies which column is used for X mapping",
                    rows: [
                        {
                            colPickerList: "", tip: "Sets column used to map the X axis", dataName: "colName",
                            closeAction: true, mapToDefaultCol: true, minWidth: 250,
                        },
                    ]
                },
                //---- VALUES tab ----
                {
                    tabName: "Breaks", tip: "Adjust the settings for column breaks", rows: [
                        {
                            //---- MAPPING OPTIONS pane ----
                            pane: "Break Options", hideToggle: true, minWidth: 250, colSpan: 99, id: "mappingOptionsPane", rows: [
                                //{
                                //    numAdjuster: "Breaks:", tip: "Specifies the number of X steps/bins to create", min: 2, max: 999,
                                //    roundValues: true, spreadLow: true, dataName: "sliderBinCount",
                                //},
                                // { colSpan: 2, checkbox: "Use nice numbers", tip: "Use nice numbers and auto select steps", dataName: "useNiceNumbers" },
                                { checkbox: "Custom break values:", tip: "Use custom break values for the X axis", dataName: "useCustomBreaks" },
                                {
                                    newRowIndent: true, textBox: "", tip: "Specify comma separated break values of X axis (for bins/ticks)",
                                    dataName: "customBreaks", width: 150, noSelectOnFocus: true, colSpan: 99
                                },
                                { checkbox: "Custom labels:", tip: "Use custom labels for the X axis", dataName: "useCustomLabels" },
                                {
                                    newRowIndent: true, textBox: "", tip: "Specify comma separated labels for break values of X axis (for bins/ticks)",
                                    dataName: "customLabels", width: 150, noSelectOnFocus: true, colSpan: 99
                                },
                            ]
                        },
                        {
                            //---- OTHER pane ----
                            pane: "Other", hideToggle: true, minWidth: 250, colSpan: 99, id: "binOptionsPane", rows: [
                                {
                                    colSpan: 2, checkbox: "Force category", tip: "Treat numeric and data values as strings",
                                    dataName: "forceCategory", id: "cbForceCategory"
                                },
                                {
                                    enumPicker: "Value spread:", tip: "Controls how values are mapped",
                                    dataName: "valueSpread", enumType: beachParty.MappingSpread, id: "ddValueSpread"
                                },
                                {
                                    enumPicker: "Bin sort:", tip: "Controls how X bins are sorted",
                                    dataName: "binSorting", enumType: beachParty.BinSorting, id: "ddBinSort"
                                },
                            ]
                        },
                    ] // end of rows
                },
                //---- PICKER OPTIONS tab ----
                {
                    tabName: "Options", tip: "Adjust the column picker options", rows: [
                        {
                            //---- MAPPING OPTIONS pane ----
                            pane: "Picker Options", hideToggle: true, colSpan: 99,
                            minWidth: 250, id: "mappingOptionsPane", rows: [
                                { colSpan: 2, checkbox: "Sort column names", tip: "Sort the column names in the column picker", dataName: "isColPickerSorted" },
                                { colSpan: 2, checkbox: "Show column types", tip: "Show the type of each column in the column picker", dataName: "showTypesInColPicker" },
                                { colSpan: 2, checkbox: "Show unique value counts", tip: "Show the count of unique strings for each column in the column picker", dataName: "showCountsInColPicker" },
                                { colSpan: 2, checkbox: "Show system columns", tip: "Include the names of the system columns in the column picker", dataName: "showSysColsInColPicker" },
                            ]
                        }
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    facetPanel.ts - describes the panel for setting FACET mapping options
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.facetPanel =
        {
            title: "Facet by",
            autoClose: true,
            tabs: [
                //---- COLUMN tab ----
                {
                    tabName: "Column", tip: "Specifies which column is used for Facet mapping",
                    rows: [
                        {
                            numAdjuster: "Facets:", tip: "Specifies the number of Facet bins to create", min: 0, max: 999,
                            roundValues: true, spreadLow: true, dataName: "sliderBinCount", nameValueMap: { Auto: 0 }, hostInPanel: true
                        },
                        {
                            colPickerList: "", tip: "Sets column used to map the Facet axis", dataName: "colName",
                            closeAction: true, mapToDefaultCol: true, minWidth: 250, includeNone: true,
                        },
                    ]
                },
                //---- VALUES tab ----
                {
                    tabName: "Breaks", tip: "Adjust the settings for column breaks", rows: [
                        {
                            //---- MAPPING OPTIONS pane ----
                            pane: "Break Options", hideToggle: true, minWidth: 250, colSpan: 99, id: "mappingOptionsPane", rows: [
                                // { colSpan: 2, checkbox: "Use nice numbers", tip: "Use nice numbers and auto select steps", dataName: "useNiceNumbers" },
                                { checkbox: "Custom break values:", tip: "Use custom break values for the Facet axis", dataName: "useCustomBreaks" },
                                {
                                    newRowIndent: true, textBox: "", tip: "Specify comma separated break values of Facet axis (for bins/ticks)",
                                    dataName: "customBreaks", width: 150, noSelectOnFocus: true, colSpan: 99
                                },
                                { checkbox: "Custom labels:", tip: "Use custom labels for the Facet axis", dataName: "useCustomLabels" },
                                {
                                    newRowIndent: true, textBox: "", tip: "Specify comma separated labels for break values of Facet axis (for bins/ticks)",
                                    dataName: "customLabels", width: 150, noSelectOnFocus: true, colSpan: 99
                                },
                            ]
                        },
                        {
                            //---- OTHER pane ----
                            pane: "Other", hideToggle: true, minWidth: 250, colSpan: 99, id: "binOptionsPane", rows: [
                                {
                                    colSpan: 2, checkbox: "Force category", tip: "Treat numeric and data values as strings",
                                    dataName: "forceCategory", id: "cbForceCategory"
                                },
                                //{
                                //    enumPicker: "Value spread:", tip: "Controls how values are mapped",
                                //    dataName: "valueSpread", enumType: MappingSpread, id: "ddValueSpread"
                                //},
                                {
                                    enumPicker: "Bin sort:", tip: "Controls how Facet bins are sorted",
                                    dataName: "binSorting", enumType: beachParty.BinSorting, id: "ddBinSort"
                                },
                            ]
                        },
                    ] // end of rows
                },
                //---- PICKER OPTIONS tab ----
                {
                    tabName: "Options", tip: "Adjust the column picker options", rows: [
                        {
                            //---- MAPPING OPTIONS pane ----
                            pane: "Picker Options", hideToggle: true, colSpan: 99,
                            minWidth: 250, id: "mappingOptionsPane", rows: [
                                { colSpan: 2, checkbox: "Sort column names", tip: "Sort the column names in the column picker", dataName: "isColPickerSorted" },
                                { colSpan: 2, checkbox: "Show column types", tip: "Show the type of each column in the column picker", dataName: "showTypesInColPicker" },
                                { colSpan: 2, checkbox: "Show unique value counts", tip: "Show the count of unique strings for each column in the column picker", dataName: "showCountsInColPicker" },
                                { colSpan: 2, checkbox: "Show system columns", tip: "Include the names of the system columns in the column picker", dataName: "showSysColsInColPicker" },
                            ]
                        }
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    editSessionName.ts - dialog panel to edit name of session being saved.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.editSessionName =
        {
            title: "Export Insights", tip: "Change the name of the session being saved to local file system", rowSpacing: "6px", isDialog: true,
            cellPadding: 3,
            rows: [
                { textBox: "Name:", tip: "The name of the sessioh file being saved", dataName: "editSessionName", width: 150, tabIndex: 1, },
                { emptyRow: true, height: 15 },
                {
                    newRowIndent: true, button: "OK", tip: "Close the panel and save the session with the specified name",
                    acceptButton: true, defaultButton: true, tabIndex: 2, width: 60, textAlign: "right",
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    addInsight.ts - dialog panel for adding an insight object.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.addInsight =
        {
            title: "Add Insight", tip: "Add the name and notes for an insight", rowSpacing: "6px", isDialog: true,
            rows: [
                { textBox: "Name:", tip: "The name of the insight", dataName: "editInsightName", width: "300px" },
                { textArea: "Notes:", tip: "Your notes about the insight", dataName: "editInsightNotes", width: "300px", height: "60px" },
                { newRowIndent: true, button: "OK", tip: "Close the panel and create the insight", textAlign: "right", acceptButton: true },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    editInsight.ts - dialog panel for editing an insight object.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.editInsight =
        {
            title: "Edit Insight", tip: "View and change the name and notes for an insight", rowSpacing: "6px", isDialog: true,
            isFloating: true,
            cellPadding: 3,
            colFill: true,
            width: 300,
            rows: [
                {
                    textBox: "Name:", tip: "The name of the insight", dataName: "editInsightName", tabIndex: 1,
                    fillParent: true,
                },
                { prompt: "Notes:" },
                {
                    textArea: "", tip: "Your notes about the insight", dataName: "editInsightNotes", height: "100px",
                    placeHolder: "Your notes about this insight.", colSpan: 99, fillParent: true, tabIndex: 2,
                },
                //{ checkbox: "Notes in markdown format", tip: "When true, markdown formatting are recognized in the notes", dataName: "isNotesMarkDown" },
                {
                    enumPicker: "Load action:", tip: "What should be loaded when this insight is selected", width: 60,
                    dataName: "loadAction", enumType: beachParty.LoadAction, tabIndex: 3
                },
                {
                    enumPicker: "Chart title: ", tip: "Specifies the source of the text for the chart title box", width: 60,
                    dataName: "notesSource", enumType: beachParty.NotesSource, tabIndex: 4,
                },
                {
                    skipCol: 1, button: "OK", tip: "Apply these changes and close the panel", textAlign: "right", width: 80,
                    acceptButton: true, defaultButton: true, tabIndex: 5, marginTop: 12, marginBottom: -8
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    dataPanel.ts - describes the panel loading known, local, and web datasets.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.dataPanel =
        {
            title: "Data",
            autoClose: true,
            //minWidth: 100,
            //minHeight: 300,
            tabs: [
                {
                    //---- SWITCH tab (tab0) ----
                    tabName: "Fileset", tip: "Switch to another file from the current fileset", rows: [
                        { openDataPickerList: ":", tip: "Select a file from the current fileset", dataName: "selectedOpenFile", width: 230 },
                    ]
                },
                {
                    //---- SAMPLE tab (tab1) ----
                    tabName: "Sample", tip: "Open one of the BeachParty sample data files", rows: [
                        { knownDataPickerList: ":", tip: "Select a sample file", dataName: "selectedSampleName", width: 230 },
                    ]
                },
                /// warning: don't use "acceptButton: true" on the "Load" buttons - we don't currently do the right thing when there is more than 1 accept button 
                /// spread over multiple tabs.
                {
                    //---- LOCAL tab (tab2) ----
                    tabName: "Local", tip: "Open a local data file", rows: [
                        {
                            button: "Select File(s)...",
                            tip: "Invokes the brower's File Open dialog and select one or more files to open",
                            dataName: "onOpenFileClicked", marginBottom: -10,
                        },
                        { newRowIndent: true, textBox: "", tip: "Selected filename", dataName: "selectedFileName", readOnly: true, width: "200px", marginTop: "6px" },
                        { prompt: "File type:", tip: "Select the type of file to be opened", dataName: "openFileTypeLocal" },
                        { newRowIndent: true, radio: "Tab-delimited (.txt)", tip: "Open as a tab-delimited file", value: "tab" },
                        { newRowIndent: true, radio: "Comma-delimited (.csv)", tip: "Open as a comma-delimited file", value: "comma" },
                        { newRowIndent: true, radio: "JSON data (.json)", tip: "Open as JSON file", value: "json" },
                        { checkbox: "First line is header", tip: "When set, treats first line of delimited file as a header", dataName: "fileHasHeader", disabled: "isFirstLineDisabledLocal" },
                        { emptyRow: true, height: 10 },
                        { prompt: "Data scrubber:", tip: "Select a Data Scrubber template to apply to file", },
                        { newRowIndent: true, scrubberPicker: "", tip: "Select a Data Scrubber template to apply to file", dataName: "dataScrubberName" },
                        { emptyRow: true },
                        { newRowIndent: true, button: "Load", tip: "Load the selected file (and close this panel)", textAlign: "right", acceptButton: false, dataName: "loadFileOpenLocal" },
                    ]
                },
                {
                    //---- WEB tab (tab3) ----
                    tabName: "Web", tip: "Open a local data file", rows: [
                        { prompt: "URL:", tip: "Enter the Web URL of the file to be opened" },
                        {
                            newRowIndent: true, textBox: "", tip: "Enter the Web URL of the file to be opened",
                            dataName: "fileOpenURL", width: "200px", sampleText: "getUrlSample"
                        },
                        { prompt: "File type:", tip: "Select the type of file to be opened", dataName: "openFileTypeWeb" },
                        { newRowIndent: true, radio: "Tab-delimited (.txt)", tip: "Open as a tab-delimited file", value: "tab" },
                        { newRowIndent: true, radio: "Comma-delimited (.csv)", tip: "Open as a comma-delimited file", value: "comma" },
                        { newRowIndent: true, radio: "JSON data (.json)", tip: "Open as JSON file", value: "json" },
                        { checkbox: "First line is header", tip: "When set, treats first line of delimited file as a header", dataName: "fileHasHeader", disabled: "isFirstLineDisabledWeb" },
                        { emptyRow: true, height: 10 },
                        { prompt: "Data scrubber:", tip: "Select a Data Scrubber template to apply to file", },
                        { newRowIndent: true, scrubberPicker: "", tip: "Select a Data Scrubber template to apply to file", dataName: "dataScrubberName" },
                        { emptyRow: true },
                        { newRowIndent: true, button: "Load", tip: "Load the specified file (and close this panel)", textAlign: "right", acceptButton: false, dataName: "loadFileOpenWeb" },
                    ]
                },
                {
                    //---- SQL tab (tab4) ----
                    tabName: "SQL", tip: "Open a SQL table", rows: [
                        { prompt: "Connection string:", tip: "Enter the SQL connection string" },
                        {
                            newRowIndent: true, textBox: "", tip: "Enter the SQL connection string of the file to be opened",
                            dataName: "fileOpenCs", width: "200px", sampleText: "getSqlCsSample"
                        },
                        { prompt: "Table name (or query):", tip: "Enter the table to open or query to run" },
                        {
                            newRowIndent: true, textBox: "", tip: "Enter the table to open or query to run", dataName: "sqlTableName",
                            width: "200px", sampleText: "getSqlTableSample"
                        },
                        { emptyRow: true },
                        { prompt: "Data scrubber:", tip: "Select a Data Scrubber template to apply to file", },
                        { newRowIndent: true, scrubberPicker: "", tip: "Select a Data Scrubber template to apply to file", dataName: "dataScrubberName" },
                        { emptyRow: true },
                        {
                            newRowIndent: true, button: "Load", tip: "Load the specified file (and close this panel)",
                            textAlign: "right", acceptButton: false, dataName: "loadFileOpenSql"
                        },
                    ]
                },
                {
                    //---- TEST tab (tab5) ----
                    tabName: "Test", tip: "Open of the predefined testing tables", rows: [
                        { testDataPickerList: ":", tip: "Select a test file", dataName: "selectedSampleName", width: 230 },
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    colorPanel.ts - describes the panel for setting color mapping options
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.colorPanel =
        {
            title: "Color by",
            autoClose: true,
            width: 330,
            tabs: [
                {
                    //---- COLUMN tab ----
                    tabName: "Column", tip: "Specifies which column is used for color mapping", rows: [
                        {
                            colPickerList: "", tip: "Sets column used to map color", dataName: "colName",
                            includeNone: true, width: 250, closeAction: true,
                        },
                    ]
                },
                {
                    //---- PALETTE tab ----
                    tabName: "Palette",
                    tip: "Color palette",
                    rows: [
                        {
                            numAdjuster: "", tip: "Specifies the number of steps in the color palette", min: 1, max: 12, roundValues: true,
                            dataName: "sliderBinCount", syncChanges: false, hostInPanel: true
                        },
                        {
                            col: 0, palettePicker: "Set:", tip: "Select a standard or cached palette set",
                            dataName: "paletteSetName", closeAction: false, marginBottom: 10, marginTop: 10,
                            marginRight: 20, minWidth: 80
                        },
                        { marginLeft: 0, checkbox: "Reversed", tip: "Reverses the order of the colors in the palette set", dataName: "reverseColorPalette" },
                        { sameRow: true, marginLeft: 40, checkbox: "Inverted", tip: "Inverts the colors of the palette set", dataName: "invertColorPalette" },
                        { marginLeft: 0, checkbox: "Continuous", tip: "Specifies that the color palette should be a continuous blend of its colors", dataName: "colorIsContinuous" },
                        {
                            sameRow: true, marginLeft: 25, checkbox: "Cycling", id: "btCycling",
                            tip: "Specifies that the values will cycle thru the available colors", dataName: "colorIsCycling"
                        },
                        {
                            //rowSpan: "right",
                            colSpan: 99,
                            customList: "", tip: "Sets current color palette", itemGetter: "getColorPaletteEntry", dataName: "colorPaletteIndex",
                            refreshEvent: "rebuildColorPaletteList"
                        },
                        //{ newRowIndent: true, textBox: "Data type:", tip: "Type of data being mapped to color", dataName: "colorDataType", readOnly: true, capitalize: true },
                        {
                            button: "Map with filter", tip: "Remap the current FILTERED-IN data to the specified color palette",
                            dataName: "remapColorData", marginRight: 12
                        },
                        {
                            sameRow: true, enumPicker: "Spread:", tip: "Sets how the data is mapped to the color palette",
                            dataName: "colorSpread", enumType: beachParty.MappingSpread, sameCol: true
                        },
                    ]
                },
                {
                    //---- DIRECT tab ----
                    tabName: "Direct",
                    tip: "Specifies direct channel mapping, as alternative to palette mapping",
                    colFill: true,
                    rows: [
                        { prompt: "Numeric values:", colSpan: 99 },
                        { newRowIndent: true, colPicker: "Red: ", tip: "Sets column for mapping data to the Red color channel", dataName: "redColumn" },
                        { newRowIndent: true, colPicker: "Green: ", tip: "Sets column for mapping data to the Green color channel", dataName: "greenColumn" },
                        { newRowIndent: true, colPicker: "Blue: ", tip: "Sets column for mapping data to the Blue color channel", dataName: "blueColumn" },
                        { emptyRow: true, height: 20 },
                        { prompt: "Color strings:", colSpan: 99 },
                        { newRowIndent: true, colPicker: "RGB: ", tip: "Sets column for setting color directly from color string values", dataName: "rgbColumn" },
                    ]
                },
                //---- PICKER OPTIONS tab ----
                {
                    tabName: "Options", tip: "Adjust the column picker options", rows: [
                        {
                            //----COLOR OPTIONS pane ----
                            pane: "Color options", hideToggle: true, colSpan: 99,
                            minWidth: 250, id: "colorOptionsPane", rows: [
                                { colSpan: 2, checkbox: "Fill legend from bottom", tip: "When checked, legend entries are increase from the bottom", dataName: "isLegendBottomUp" },
                            ]
                        },
                        {
                            //----PICKER OPTIONS pane ----
                            pane: "Column picker options", hideToggle: true, colSpan: 99,
                            minWidth: 250, id: "pickerOptionsPane", rows: [
                                { colSpan: 2, checkbox: "Sort column names", tip: "Sort the column names in the column picker", dataName: "isColPickerSorted" },
                                { colSpan: 2, checkbox: "Show column types", tip: "Show the type of each column in the column picker", dataName: "showTypesInColPicker" },
                                { colSpan: 2, checkbox: "Show unique value counts", tip: "Show the count of unique strings for each column in the column picker", dataName: "showCountsInColPicker" },
                                { colSpan: 2, checkbox: "Show system columns", tip: "Include the names of the system columns in the column picker", dataName: "showSysColsInColPicker" },
                            ]
                        }
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    slicer.ts - describes the column slicer (interactive histogram) panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.slicerPanel =
        {
            title: "Slicer",
            tip: "View and select values of a column",
            sizeable: true,
            //autoClose: true,
            rows: [
                { fillClient: true, id: "slicer", control: "createSlicer", dataName: "slicerData" },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    appSettings.ts - describes the panel for changing application settings
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /// NOTE about SandDance panels:
    ///     - This is a description of how to build our (very regular and simple) panels.  This is not a general panel building system;
    ///       it will only work for our specific style of panels.
    ///     - Being a JSON description, we can make panel easier to write, read, and maintain.  We also add our own very 
    ///       specific kind of data binding.
    ///     - The hope is by keeping things simple and limited, we can make this easy to build.
    var anyWindow = window;
    anyWindow.panelDescriptions.settingsPanel =
        {
            title: "SandDance Settings", tip: "change the SandDance application settings", isDialog: true,
            tabs: [
                {
                    tabName: "Icon bar", tip: "Controls for adding/removing buttons on the icon bar", rows: [
                        //{ prompt: "In-progress:", tip: "Enable or disable in-progress UI (throughout SandDance)" },
                        //{ newRowIndent: true, checkbox: "Show in-progress UI", tip: "When checked, the UI being implemented in shown", dataName: "showInProgressUI" },
                        { prompt: "Icon bar core features:", tip: "Enable or disable core features on the Icon bar" },
                        { newRowIndent: true, checkbox: "Insights", tip: "Adds an icon for showing the Insight panel", dataName: "isInsightsEnabled" },
                        { newRowIndent: true, checkbox: "Wheel", tip: "Adds an icon that toggles the 3D transform wheel on/off", dataName: "isWheelEnabled" },
                        { newRowIndent: true, checkbox: "Undo", tip: "Adds the Undo button to the icon bar", dataName: "isUndoEnabled" },
                        { newRowIndent: true, checkbox: "Redo", tip: "Adds the Redo button to the icon bar", dataName: "isRedoEnabled" },
                        { newRowIndent: true, checkbox: "Tips", tip: "Adds the Tips button to the icon bar", dataName: "isTipsEnabled" },
                        { newRowIndent: true, checkbox: "Search", tip: "Adds the Search button to the icon bar", dataName: "isSearchEnabled" },
                        { newRowIndent: true, checkbox: "Isolate", tip: "Adds the Isolate button to the icon bar", dataName: "isIsolateEnabled" },
                        { newRowIndent: true, checkbox: "Exclude", tip: "Adds the Exclude button to the icon bar", dataName: "isExcludeEnabled" },
                        { newRowIndent: true, checkbox: "Reset", tip: "Adds the Reset button to the icon bar", dataName: "isResetEnabled" },
                        { newRowIndent: true, checkbox: "Details", tip: "Adds the Details button to the icon bar", dataName: "isDetailsEnabled" },
                        { newRowIndent: true, checkbox: "Tours", tip: "Adds an icon for opening the Tours panel", dataName: "isToursEnabled" },
                        { newRowIndent: true, checkbox: "Settings", tip: "Adds the Settings button to the icon bar", dataName: "isSettingsEnabled" },
                        //{ newRowIndent: true, checkbox: "Feedback", tip: "Adds the feedback button to the icon bar", dataName: "isFeedbackEnabled" },
                        { newRowIndent: true, checkbox: "About", tip: "Adds the about button to the icon bar", dataName: "isAboutEnabled" },
                        { prompt: "Icon bar experimental features:", tip: "Enable or disable experimental features on the Icon bar" },
                        //{ newRowIndent: true, checkbox: "Help", tip: "Adds an icon for opening the Help panel", dataName: "isHelpEnabled" },
                        { newRowIndent: true, checkbox: "3D navigation", tip: "Adds an icon that toggles 3D navigation mode on/off", dataName: "isNavEnabled" },
                        { newRowIndent: true, checkbox: "Bot", tip: "Adds an icon for opening the Bot panel", dataName: "isBotEnabled" },
                        { newRowIndent: true, checkbox: "Browse", tip: "Adds the Browse button to the icon bar", dataName: "isBrowseEnabled" },
                        { newRowIndent: true, checkbox: "Clustering", tip: "Adds an icon that opens the Clustering panel", dataName: "isClusteringEnabled" },
                        { newRowIndent: true, checkbox: "Data scrubber", tip: "Adds an icon that opens the Data Scrubber dialog", dataName: "isScrubberEnabled" },
                        { newRowIndent: true, checkbox: "New view", tip: "Adds an icon that opens a new SandDance instance", dataName: "isNewViewEnabled" },
                        { newRowIndent: true, checkbox: "Palettes", tip: "Show the Palettes button in the icon bar", dataName: "isPalettesEnabled" },
                        { newRowIndent: true, checkbox: "Scripts", tip: "Show the Scripts button in the icon bar", dataName: "isScriptsEnabled" },
                        { newRowIndent: true, checkbox: "Select mode", tip: "Adds an icon that opens the selection mode panel", dataName: "isSelectModeEnabled" },
                        { newRowIndent: true, checkbox: "Tasks", tip: "Adds an icon for opening the Tasks panel", dataName: "isTasksEnabled" },
                        { newRowIndent: true, checkbox: "Themes", tip: "Show the Themes button in the icon bar", dataName: "isThemesEnabled" },
                        //{ newRowIndent: true, checkbox: "Agg", tip: "Show the Agg button in the icon bar", dataName: "isAggEnabled" },
                        //{ newRowIndent: true, checkbox: "Data slicer", tip: "Adds a button on the icon bar for opening a Data Slicer panel", dataName: "isSlicerEnabled" },
                        { emptyRow: true }
                    ]
                },
                {
                    tabName: "Big bar", tip: "Controls for adding/removing buttons on the Big bar", rows: [
                        { prompt: "Big bar core features:", tip: "Enable or disable core features on the Big bar" },
                        { newRowIndent: true, checkbox: "Dataset", tip: "Adds the Dataset button to the big bar", dataName: "isDatasetEnabled" },
                        { newRowIndent: true, checkbox: "Items", tip: "Adds the Items button to the big bar", dataName: "isItemsEnabled" },
                        { newRowIndent: true, checkbox: "Filtered", tip: "Adds the Filtered button to the big bar", dataName: "isFilteredEnabled" },
                        { newRowIndent: true, checkbox: "Selected", tip: "Adds the Selected button to the big bar", dataName: "isSelectedEnabled" },
                        { newRowIndent: true, checkbox: "View as", tip: "Adds the View As button to the big bar", dataName: "isViewAsEnabled" },
                        { newRowIndent: true, checkbox: "X axis", tip: "Adds the X axis button to the big bar", dataName: "isXAxisEnabled" },
                        { newRowIndent: true, checkbox: "Y axis", tip: "Adds the Y axis button to the big bar", dataName: "isYAxisEnabled" },
                        { newRowIndent: true, checkbox: "Z axis", tip: "Adds the Z axis button to the big bar", dataName: "isZAxisEnabled" },
                        { newRowIndent: true, checkbox: "Sum by", tip: "Adds the Sum by button to the big bar", dataName: "isSumByEnabled" },
                        { newRowIndent: true, checkbox: "Facet by", tip: "Adds the Facet by button to the big bar", dataName: "isFacetByEnabled" },
                        { newRowIndent: true, checkbox: "Color by", tip: "Adds the Color by button to the big bar", dataName: "isColorByEnabled" },
                        { newRowIndent: true, checkbox: "Sort by", tip: "Adds the Sort by button to the big bar", dataName: "isSortByEnabled" },
                        //{ newRowIndent: true, checkbox: "Chart options", tip: "Adds the Chart options button to the big bar", dataName: "isChartOptionsEnabled" },
                        { prompt: "Big bar experimental features:", tip: "Enable or disable experimental features on the Big bar" },
                        { newRowIndent: true, checkbox: "Size by", tip: "Adds a button for mapping data to the size attribute (on the big bar)", dataName: "isSizeByEnabled" },
                        { newRowIndent: true, checkbox: "Shape by", tip: "Adds a button for mapping data to the different shapes (on the big bar)", dataName: "isShapeByEnabled" },
                        //{ newRowIndent: true, checkbox: "Text by", tip: "Adds a button for drawing Text beside each shape (on the big bar)", dataName: "isTextByEnabled" },
                        //{ newRowIndent: true, checkbox: "Line by", tip: "Adds a button for lines between shapes based on common values (on the big bar)", dataName: "isLineByEnabled" },
                        { emptyRow: true },
                        { prompt: "Other experimental features:", tip: "Enable or disable other experimental features" },
                        { newRowIndent: true, checkbox: "SQL Datasets", tip: "Show the 'SQL' tab in the Datasets Panel", dataName: "isSqlEnabled", isDevMode: true },
                        { newRowIndent: true, checkbox: "Color Channels", tip: "Show the 'Channels' tab in the Color Panel", dataName: "mapByColorChannels" },
                    ]
                },
                {
                    tabName: "Views", tip: "Controls for enabling and disabling view types", rows: [
                        { prompt: "Core views:", tip: "Enable or disable core view types" },
                        { newRowIndent: true, checkbox: "Grid", tip: "Adds the Grid view type to the View panel", dataName: "isGridEnabled" },
                        { newRowIndent: true, checkbox: "Column", tip: "Adds the Column view type to the View panel", dataName: "isColumnEnabled" },
                        { newRowIndent: true, checkbox: "Scatter", tip: "Adds the Scatter view type to the View panel", dataName: "isScatterEnabled" },
                        { newRowIndent: true, checkbox: "Density", tip: "Adds the Density view type to the View panel", dataName: "isDensityEnabled" },
                        { newRowIndent: true, checkbox: "Stacks", tip: "Adds the Stacks view type to the View panel", dataName: "isStacksEnabled" },
                        //{ newRowIndent: true, checkbox: "Squarify", tip: "Adds the Squarify view type to the View panel", dataName: "isSquarifyEnabled" },
                        { emptyRow: true },
                        { prompt: "Experimental views:", tip: "Enable or disable experimental view types" },
                        { newRowIndent: true, checkbox: "Random", tip: "Adds the Random view type to the View panel", dataName: "isRandomEnabled" },
                        { newRowIndent: true, checkbox: "Poisson", tip: "Adds the Poisson view type to the View panel", dataName: "isPoissonEnabled" },
                        { newRowIndent: true, checkbox: "Spiral", tip: "Adds the Spiral view type to the View panel", dataName: "isSpiralEnabled" },
                        //{ newRowIndent: true, checkbox: "Line", tip: "Adds the Line view type to the View panel", dataName: "isLineEnabled", isDevMode: true },
                        //{ newRowIndent: true, checkbox: "Links", tip: "Adds the Links view type to the View panel", dataName: "isLinksEnabled", isDevMode: true },
                        { newRowIndent: true, checkbox: "Radial", tip: "Adds the Radial view type to the View panel", dataName: "isRadialEnabled" },
                        { newRowIndent: true, checkbox: "Xband", tip: "Adds the Xband view type to the View panel", dataName: "isXbandEnabled" },
                        { newRowIndent: true, checkbox: "Yband", tip: "Adds the Yband view type to the View panel", dataName: "isYbandEnabled" },
                        { newRowIndent: true, checkbox: "Scatter-3D", tip: "Adds the Scatter3D view type to the View panel", dataName: "isScatter3DEnabled" },
                        { newRowIndent: true, checkbox: "Bar", tip: "Adds the Bar view type to the View panel", dataName: "isBarEnabled" },
                        { newRowIndent: true, checkbox: "Violin", tip: "Adds the Violin view type to the View panel", dataName: "isViolinEnabled" },
                    ]
                },
                {
                    tabName: "UI", tip: "Settings to control SandDance appearance",
                    cellPadding: 10,
                    colFill: true,
                    rows: [
                        //---- APP tab: FONT section ----
                        { prompt: "Font:", tip: "Control the fonts used in SandDance" },
                        { newRowIndent: true, textBox: "App:", tip: "Specify the app font family", dataName: "normalFontFamily", width: "124px" },
                        { emptyRow: true },
                        //---- APP tab: FONT-WEIGHT section ----
                        { prompt: "Font weight:", tip: "Control the font weight used in various controls" },
                        { newRowIndent: true, enumPicker: "Prompt text:", tip: "Specify the font weight for the prompt text of a big button", dataName: "promptWeight", enumType: beachParty.FontWeight },
                        { sameRow: true, enumPicker: "Value text:", tip: "Specify the font weight for the value text of a big button", dataName: "valueWeight", enumType: beachParty.FontWeight },
                        { newRowIndent: true, enumPicker: "Selected tab:", tip: "Specify the font weight for the currently selected tab in a tabset", dataName: "selectedTabWeight", enumType: beachParty.FontWeight },
                        { sameRow: true, enumPicker: "Title pane:", tip: "Specify the font weight for the text in the title panel (at top of chart)", dataName: "titlePaneWeight", enumType: beachParty.FontWeight },
                        { newRowIndent: true, enumPicker: "Tip names:", tip: "Specify the font weight for the tooltip and datatip names", dataName: "tipNameWeight", enumType: beachParty.FontWeight },
                        { sameRow: true, enumPicker: "Table headers", tip: "Specify the font weight for the headers of a table", dataName: "tableHeaderWeight", enumType: beachParty.FontWeight },
                        { emptyRow: true },
                        //---- APP tab: BACKGROUND section ----
                        { prompt: "Background:", tip: "Control the background colors" },
                        { newRowIndent: true, colorPicker: "App:", tip: "The color of the app background", dataName: "appBgColor", },
                        { sameRow: true, colorPicker: "Bars:", tip: "The background color of bars", dataName: "barBgColor" },
                        { newRowIndent: true, colorPicker: "Panel:", tip: "The background color of floating panels", dataName: "panelBgColor" },
                        { sameRow: true, colorPicker: "Docked:", tip: "The background color of docked panels", dataName: "dockedBgColor" },
                        { newRowIndent: true, colorPicker: "Hover:", tip: "The background color of items when mouse hovers over them", dataName: "hoverBgColor" },
                        { sameRow: true, colorPicker: "Selected:", tip: "The background color of selected items", dataName: "selectedBgColor" },
                        { emptyRow: true },
                        //---- APP tab: BORDER section ----
                        { prompt: "Border:", tip: "Control the border colors" },
                        { newRowIndent: true, colorPicker: "List:", tip: "The color of separation lines in lists", dataName: "listBorderColor" },
                        { sameRow: true, colorPicker: "Bars:", tip: "The color of bar borders", dataName: "barBorderColor" },
                        { newRowIndent: true, colorPicker: "Panel:", tip: "The color of panel borders", dataName: "panelBorderColor", },
                        { sameRow: true, colorPicker: "Docked:", tip: "The color of docked panel borders", dataName: "dockedBorderColor" },
                        { newRowIndent: true, colorPicker: "Button:", tip: "The color of borders around buttons", dataName: "buttonBorderColor" },
                        { sameRow: true, colorPicker: "Guide:", tip: "The color of the lines/borders in guides", dataName: "guideBorderColor", top: "0px" },
                    ]
                },
                {
                    tabName: "UI-2", tip: "Additional Settings to control SandDance appearance",
                    cellPadding: 10,
                    colFill: true,
                    rows: [
                        //---- BUTTONS: TEXT COLOR section ----
                        { prompt: "Text color:", tip: "Control the color of text" },
                        { newRowIndent: true, colorPicker: "App:", tip: "The color of text in the app", dataName: "appTextColor", top: "0" },
                        { sameRow: true, colorPicker: "Guide:", tip: "The color of the text in the Guide controls", dataName: "guideTextColor", top: "0px" },
                        { newRowIndent: true, colorPicker: "Prompt:", tip: "The color of the Prompt text within the value button", dataName: "promptTextColor", top: "0px" },
                        { sameRow: true, colorPicker: "Value:", tip: "The color of the value Value within the value button", dataName: "valueTextColor", top: "0px" },
                        { emptyRow: true },
                        //---- BUTTONS: TEXT SIZES section ----
                        { prompt: "Text size:", tip: "Control the size of text (in pixels)" },
                        { newRowIndent: true, numAdjuster: "App:", tip: "The size of App text", min: 4, max: 40, roundValues: true, dataName: "appTextSize", promptTop: "2px" },
                        { sameRow: true, numAdjuster: "Guide:", tip: "The size of the Auide text", min: 4, max: 40, roundValues: true, dataName: "guideTextSize", top: "0" },
                        { newRowIndent: true, numAdjuster: "Prompt:", tip: "Set the size of Prompt text for the value buttons", min: 4, max: 50, dataName: "promptTextSize", roundValues: true, newCol: true, syncChanges: false, promptTop: "2px" },
                        { sameRow: true, numAdjuster: "Value:", tip: "Set the size of Value text for the value buttons", min: 4, max: 50, dataName: "valueTextSize", roundValues: true, newCol: true, syncChanges: false, promptTop: "2px" },
                        { newRowIndent: true, numAdjuster: "Title:", tip: "The font size of chart title", min: 4, max: 40, roundValues: true, dataName: "titleTextSize", top: "0" },
                        { emptyRow: true },
                        //---- BUTTONS: ICON BUTTONS section ----
                        { prompt: "Icon Buttons:", tip: "Control the appearance of the Icon Bar and its buttons" },
                        { newRowIndent: true, colSpan: 2, checkbox: "Show icons", tip: "Show the icons associated with each menu item", dataName: "isMenuIconVisible" },
                        { sameRow: true, colSpan: 2, checkbox: "Show text", tip: "Show the text associated with each menu item", dataName: "isMenuTextVisible" },
                        { newRowIndent: true, colSpan: 2, checkbox: "Show chevrons", tip: "Show the chevrons associated with each menu item", dataName: "isMenuChevronVisible", syncChanges: true },
                        { sameRow: true, numAdjuster: "Icon size:", tip: "Set the size of icons shown in the icon bar", min: 10, max: 100, dataName: "buttonIconWidth", roundValues: true, newCol: true, syncChanges: true, promptTop: "2px" },
                        { emptyRow: true },
                        //---- BUTTONS: OTHER OPTIONS section ----
                        { prompt: "Other Options:", tip: "Control various other UI options" },
                        { newRowIndent: true, colSpan: 2, checkbox: "Icon buttons on big bar", tip: "Remove the icon bar and put its buttons on the big bar", dataName: "isIconButtonsOnBigBar" },
                        { sameRow: true, colSpan: 2, checkbox: "Big bar next to logo", tip: "Put the big bar next to the SandDance logo", dataName: "isBigBarNextToLogo" },
                        { newRowIndent: true, colSpan: 2, checkbox: "Hide SandDance logo", tip: "Show the SandDance logo in the upper left corner of the screen", dataName: "isLogoHidden" },
                        { sameRow: true, enumPicker: "Title align:", tip: "The alignment of the title panel", dataName: "titlePanelAlignment", enumType: beachParty.TextAlign, },
                    ]
                },
                {
                    tabName: "Animation", tip: "Settings for chart animation and staggering",
                    cellPadding: 2,
                    colFill: true,
                    rows: [
                        { prompt: "Animaton:", tip: "Change animaton settings" },
                        { newRowIndent: true, checkbox: "Enabled", tip: "When true, changes to the shapes or charts are animated", dataName: "isAnimationEnabled" },
                        { newRowIndent: true, numAdjuster: "Duration:", tip: "Specifies how long an animation lasts (in seconds)", min: 0, max: 10, dataName: "animationDuration" },
                        { prompt: "Staggering:", tip: "Change staggered animmation settings" },
                        { newRowIndent: true, checkbox: "Enabled", tip: "When true, changes to the shapes are staggered in time, so they don't all change at once", dataName: "isStaggeringEnabled" },
                        { newRowIndent: true, numAdjuster: "Maximum:", tip: "Specifies the maximum delay for a stagger shape's animation (in seconds)", min: 0, max: 10, dataName: "maxStaggerTime" },
                        { prompt: "Easing:", tip: "Change the ease in/out parameters" },
                        { newRowIndent: true, enumPicker: "Ease function:", tip: "Sets the ease function", dataName: "easeFunction", enumType: beachParty.EaseFunction },
                        { newRowIndent: true, enumPicker: "Ease type:", tip: "Sets the type of easing to be used", dataName: "easeType", enumType: beachParty.EaseType },
                    ]
                },
                {
                    tabName: "3D",
                    tip: "Setting for 3D",
                    rows: [
                        { prompt: "3D Transform:", tip: "Change options for the 3D transform mode" },
                        { newRowIndent: true, checkbox: "3D grid always on", tip: "Use 3D grid on all views", dataName: "is3dGridAlwaysOn" },
                        { newRowIndent: true, checkbox: "Rotation inertia", tip: "Use inertial of touch on wheel to keep it rotating", dataName: "isWheelInertia" },
                        { newRowIndent: true, checkbox: "Show transform wheel", tip: "Show the transform wheel during 3D transform mode ", dataName: "showWheelDuringTransformMode" },
                        { prompt: "3D lighting:", tip: "Change options for 3D lighting" },
                        { newRowIndent: true, checkbox: "Lighting always on", tip: "Use 3D lighting on all views", dataName: "isLightingAlwaysOn" },
                        {
                            newRowIndent: true, numAdjuster: "Ambient level:", tip: "The ambient lighting level (0-1)", min: 0, max: 1, dataName: "ambientLightLevel",
                            sameCellAsPrompt: true, marginRight: "4px",
                        },
                    ]
                },
                {
                    tabName: "Hover", tip: "Settings for hover-related action",
                    cellPadding: 2,
                    colFill: true,
                    rows: [
                        { prompt: "Hover:", tip: "Change the mouse hover settings" },
                        { newRowIndent: true, enumPicker: "Hover match:", tip: "Sets the type of hover testing to match mouse position to shapes", dataName: "hoverMatch", enumType: beachParty.HoverMatch },
                        { newRowIndent: true, enumPicker: "Hover effect:", tip: "Sets how the hovered-over shape is drawn", dataName: "hoverEffect", enumType: beachParty.HoverEffect },
                        { newRowIndent: true, numAdjuster: "Match size:", tip: "Specifies the size of the hover testing area under the mouse, when hoverMatch=square)", min: 0, max: 100, roundValues: true, dataName: "hoverSize", newCol: true },
                        { newRowIndent: true, colorPicker: "Hover color:", tip: "Sets the color of the hovered-over shape ", dataName: "hoverColor", includeTransparent: true },
                        { newRowIndent: true, colSpan: 2, checkbox: "Hover on mouse move", tip: "When true, apply hover rendering on shape under mouse", dataName: "hoverOnMouseMove" },
                        { newRowIndent: true, colSpan: 2, checkbox: "Hover on detail view", tip: "When true, shape being viewed in details panel will have hover rendering applied", dataName: "hoverOnDetailView" },
                        { prompt: "Other:", tip: "Other settings" },
                        { newRowIndent: true, colSpan: 2, checkbox: "Show tooltips", tip: "When true, hoving over a shape displays a tooltip", dataName: "isTooltipsEnabled" },
                    ]
                },
                {
                    tabName: "Selection", tip: "Control drawing of shapes when a selection is active",
                    cellPadding: 2,
                    colFill: true,
                    rows: [
                        { prompt: "Selected:", tip: "Controls how selected shapes are drawn" },
                        { newRowIndent: true, enumPicker: "Effect:", tip: "How the shape color should be effected", dataName: "selectedColorEffect", enumType: beachParty.ColorEffect },
                        { newRowIndent: true, colorPicker: "Color:", tip: "The color, when Effect = SetColor", dataName: "selectedColor" },
                        { newRowIndent: true, numAdjuster: "Factor:", tip: "The color factor used by the effect)", min: 0, max: 2, dataName: "selectedColorFactor", newCol: true },
                        { prompt: "Unselected:", tip: "Controls how unselected shapes are drawn" },
                        { newRowIndent: true, enumPicker: "Effect:", tip: "How the shape color should be effected", dataName: "unselectedColorEffect", enumType: beachParty.ColorEffect },
                        { newRowIndent: true, colorPicker: "Color:", tip: "The color, when Effect = SetColor", dataName: "unselectedColor" },
                        { newRowIndent: true, numAdjuster: "Factor:", tip: "The color factor used by the effect)", min: 0, max: 2, dataName: "unselectedColorFactor", newCol: true },
                    ]
                },
                {
                    tabName: "Chart", tip: "Settings for drawing the chart and its shapes",
                    cellPadding: 2,
                    colFill: true,
                    rows: [
                        { newRowIndent: true, numAdjuster: "Shape opacity:", tip: "Sets the opacity of all shapes", min: 0, max: 1, dataName: "shapeOpacity", newCol: true },
                        { newRowIndent: true, colorPicker: "Canvas:", tip: "Sets the plot background color", dataName: "canvasColor", includeNone: true },
                        { newRowIndent: true, numAdjuster: "Frame opacity:", tip: "Sets the chart frame opacity", min: 0, max: 1, dataName: "chartFrameOpacity", newCol: true },
                        { prompt: "Advanced:", tip: "Advanced shape properties" },
                        { newRowIndent: true, enumPicker: "Primitive:", tip: "Sets the drawing primitive used to draw shapes", dataName: "drawingPrimitive", enumType: beachParty.DrawPrimitive },
                        { newRowIndent: true, colSpan: 2, checkbox: "Instancing drawing", tip: "When true, will use WebGL instancing to draw shapes", dataName: "isInstancingEnabled" },
                        { newRowIndent: true, colSpan: 2, checkbox: "Continuous drawing", tip: "When true, drawing of frames will continue have plot has been completed", dataName: "isContinuousDrawing" },
                    ]
                },
                {
                    tabName: "Data", tip: "Options for data",
                    cellPadding: 2,
                    colFill: true,
                    rows: [
                        { prompt: "File loading:", tip: "Parameters for loading data files" },
                        { newRowIndent: true, checkbox: "Cache local files", tip: "When user loads a local file, cache it in localstroage", dataName: "cacheLocalFiles" },
                        { newRowIndent: true, checkbox: "Cache web files", tip: "When user loads a web file, cache it in localstroage", dataName: "cacheWebFiles" },
                        { prompt: "Auto sampling:", tip: "Options for automatic data sampling" },
                        { newRowIndent: true, checkbox: "Use auto sampling", tip: "Specifies that auto sampling is enabled", dataName: "isAutoSamplingEnabled" },
                        {
                            newRowIndent: true, numAdjuster: "Sample threshold:", tip: "Sets the record count at which auto sampling is triggered", min: 1, max: 200 * 1000, roundValues: true,
                            spreadLow: true, dataName: "samplingThreshold", textWidth: " 100,000",
                        },
                        {
                            newRowIndent: true, numAdjuster: "Sample size:", tip: "Sets the number of samples to be generated", min: 1, max: 50 * 1000, roundValues: true,
                            spreadLow: true, dataName: "autoSamplingSampleCount", textWidth: " 100,000",
                        },
                        { newRowIndent: true, enumPicker: "Sample type:", tip: "Specifies the type of sampling to be used", dataName: "autoSamplingSampleType", enumType: beachParty.SampleType },
                        { prompt: "Mapping:", tip: "Options for attribute mapping (Color, Size, Facets, X-Bins, Y-Bins)" },
                        //{ newRowIndent: true, checkbox: "Nice numbers", tip: "Adjust min/max/increment to use nice numbers", dataName: "useNiceNumbers" },
                        { newRowIndent: true, numAdjuster: "Default bins:", tip: "Set the default number of bins", min: 1, max: 99, roundValues: true, dataName: "defaultBins" },
                    ]
                },
                {
                    tabName: "Insights", tip: "Inight playback and other insight-related options", rows: [
                        { prompt: "Insight playback:", tip: "Insight playback options" },
                        {
                            newRowIndent: true, numAdjuster: "Duration:", tip: "Sets the duration of each insight during playback, in seconds", min: 0, max: 99, roundValues: false, dataName: "playbackDuration",
                            sameCellAsPrompt: true, marginRight: "4px",
                        },
                        { newRowIndent: true, checkbox: "Loop", tip: "When set to true, playback restarts after playing the last insight", dataName: "isPlaybackLooping" },
                    ]
                },
                {
                    tabName: "Startup", tip: "Controls initial settings for SandDance",
                    cellPadding: 2,
                    colFill: true,
                    rows: [
                        { newRowIndent: true, checkbox: "Remember last file", tip: "Start with the last-used data file from the most recent SandDance session", dataName: "rememberLastFile" },
                        { newRowIndent: true, checkbox: "Remember last insights", tip: "Start with the insights from most recent SandDance session", dataName: "rememberLastInsights" },
                        { newRowIndent: true, checkbox: "Remember last session", tip: "Start new SandDance sessions using the state from the previous session", dataName: "rememberLastSession" },
                        { newRowIndent: true, enumPicker: "Initial chart:", tip: "Sets the initial view type to be used", dataName: "initialChartType", enumType: beachParty.ChartType, isEnumUppercase: true },
                        //{ newRowIndent: true, enumPicker: "Initial layout:", tip: "Sets the initial laytout to be used", dataName: "initialLayout", enumType: Layout },
                        { newRowIndent: true, checkbox: "Open chart panel", tip: "When true, will start with Chart Panel open and draggable", dataName: "isChartPanelOpen" },
                    ]
                },
                {
                    tabName: "Reset", tip: "Reset all application settings", rows: [
                        { newRowIndent: true, button: "Reset app settings", tip: "Reset all application settings for current user", dataName: "resetSettingsAndReloadData" },
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    errorPanel.ts - shows error message in a panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.errorPanel =
        {
            title: "BeachParty Error", tip: "Displays most recent error message from BeachParty to user.",
            rows: [
                { textBox: "", tip: "The error message", dataName: "currentErrorMsg", width: "300px", readOnly: true },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    sorting.ts - describes the panel to set sorting options
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var anyWindow = window;
    anyWindow.panelDescriptions.sortPanel =
        {
            title: "Sort by",
            autoClose: true,
            minWidth: 230,
            tabs: [
                {
                    tabName: "Items", tip: "Specify how the record items/shapes are sorted",
                    rows: [
                        { checkbox: "Ascending", tip: "Sort items in ascending order (smallest to largest)", dataName: "isItemSortAscending", marginBottom: 6 },
                        { button: "Sort by color", tip: "Sets the item sort column to the color mapping column", dataName: "onItemsByColorClick", marginBottom: 6 },
                        {
                            colPickerList: "", tip: "Sets column used to map facet", includeNone: true,
                            dataName: "sortItemColumn", marginRight: 0, closeAction: true,
                        },
                    ]
                },
            ]
        };
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    viewPanelMgr.ts - manages the "viewAsPanel.ts" floating panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var viewPanelMgrClass = (function (_super) {
        __extends(viewPanelMgrClass, _super);
        function viewPanelMgrClass(app, buttons, uiName, isChartCustom, callback) {
            var _this = this;
            _super.call(this);
            this._app = app;
            this._currentView = uiName;
            this._callback = callback;
            var buttonNames = buttons.split(" ");
            for (var i = 0; i < buttonNames.length; i++) {
                var bname = buttonNames[i];
                var buttonW = vp.select("#" + bname);
                if (buttonW.length) {
                    break;
                }
            }
            var rc = buttonW.getBounds(false);
            var settings = this._app._appSettingsMgr;
            var anyOwner = [settings, app._chartRouter];
            var jsonPanel = beachParty.buildJsonPanel(app, buttons, anyOwner, "viewAsPanel", false, rc.left, rc.bottom, undefined, undefined, undefined, undefined, undefined, "bbView");
            this._jsonPanel = jsonPanel;
            this.buildChartPicker();
            jsonPanel.registerForRemovableChange("close", this, function (e) {
                _this.onClose();
            });
            jsonPanel.forceTabBuild(2); // options
            //---- hide CUSTOM tab if a real user ----
            if (!this._app.isInternalSession()) {
                jsonPanel.showTab("customTab", false);
            }
            this.updateControlsToMatchChart(uiName, isChartCustom);
        }
        viewPanelMgrClass.prototype.buildChartPicker = function () {
            var _this = this;
            var tabRoot = this._jsonPanel.getTabContentRoot("tab0");
            this._contentRow = tabRoot;
            //---- create the table ----
            var tableW = vp.select(this._contentRow).append("table")
                .addClass("chartPicker");
            //---- first row of CHARTS ----
            var rowW = tableW.append("tr");
            var useCustomChart = true;
            //---- CORE charts ----
            rowW = this.addChart(rowW, "Grid", beachParty.fnChartPickerGrid, "View the shapes in a single level grid");
            rowW = this.addChart(rowW, "Column", beachParty.fnChartPickerCol, "Organize shapes into verticalcolumns");
            rowW = this.addChart(rowW, "Scatter", beachParty.fnChartPickerScatter, "Plot data in X and Y");
            rowW = this.addChart(rowW, "Density", beachParty.fnChartPickerDensity, "Organize shapes into X and Y bins");
            rowW = this.addChart(rowW, "Stacks", beachParty.fnChartPickerStacks, "Organize shapes into X and Y bins, stacked in Z");
            rowW = this.addChart(rowW, "Squarify", beachParty.fnChartPickerSquarify, "Draw shapes from largest to smallest arranged in a rectangle");
            //---- EXPERIMENTAL charts ----
            rowW = this.addChart(rowW, "Random", beachParty.fnChartPickerRandom, "Arrange the shapes at random withing the plot");
            rowW = this.addChart(rowW, "Poisson", beachParty.fnChartPickerPoisson, "Arrange the shapes using poisson spacing");
            rowW = this.addChart(rowW, "Spiral", beachParty.fnChartPickerSpiral, "Arrange the shapes in a spiral layout");
            rowW = this.addChart(rowW, "Line", beachParty.fnChartPickerLine, "View the shapes as line across the horizontal axis");
            rowW = this.addChart(rowW, "Links", beachParty.fnChartPickerLinks, "View the shapes as line between sequential pairs of points");
            rowW = this.addChart(rowW, "Radial", beachParty.fnChartPickerRadial, "Plot data with X as the angle and Y as the radius");
            rowW = this.addChart(rowW, "Xband", beachParty.fnChartPickerHRug, "Plot the shapes along the horizontal axis");
            rowW = this.addChart(rowW, "Yband", beachParty.fnChartPickerVRug, "Plot the shapes along the vertical axis");
            rowW = this.addChart(rowW, "Scatter3D", beachParty.fnChartPickerScatter3d, "Plot data in X, Y, and Z", "Scatter-3D");
            rowW = this.addChart(rowW, "Bar", beachParty.fnChartPickerBar, "Organize shapes into horizontal bars");
            rowW = this.addChart(rowW, "Violin", beachParty.fnChartPickerViolin, "Organize shapes into X and Y bins, with width of bins representing the count");
            rowW = this.addChart(rowW, "AggColumn", beachParty.fnChartPickerAggColumn, "View data in an aggregated form");
            rowW = this.addChart(rowW, "Custom", beachParty.fnChartPickerCustom, "Build a custom chart");
            this._app.registerForRemovableChange("chartName", this, function (e) {
                _this.changeSelectedChart();
            });
            beachParty.matchIconsToTheme(this._app._themeMgr, this._jsonPanel.getRootElem());
        };
        //isFloating(value?: boolean)
        //{
        //    return this._jsonPanel.isFloating(value);
        //}
        viewPanelMgrClass.prototype.openCustomTab = function () {
            var tabW = vp.select(this._jsonPanel.getRootElem(), "#customTab");
            this._jsonPanel.onTabSelected(tabW[0]);
        };
        //hideRow(firstRowElem: HTMLTableRowElement, row: number)
        //{
        //    var tableElem = <HTMLTableElement>firstRowElem.parentNode;
        //    var rowElem = <HTMLElement>tableElem.rows[7 + row];
        //    rowElem.style.display = "none";
        //    return rowElem;
        //}
        viewPanelMgrClass.prototype.hideRowByElem = function (root, elemName) {
            var foundElem = vp.select(root, "#" + elemName)[0];
            var parent = foundElem;
            while (parent && parent.tagName != "TR") {
                parent = parent.parentNode;
            }
            if (!parent || parent.tagName != "TR") {
                throw "Internal error: could not find element in View panel: " + elemName;
            }
            parent.style.display = "none";
            return parent;
        };
        viewPanelMgrClass.prototype.showRow = function (rowElem) {
            rowElem.style.display = "";
        };
        //showAt(left: number, top: number, right?: number, bottom?: number)
        //{
        //    this._jsonPanel.showAt(left, top, right, bottom);
        //}
        viewPanelMgrClass.prototype.updateControlsToMatchChart = function (uiName, isChartCustom) {
            //---- start by hidding all chart-specific controls ----
            var root = this._jsonPanel.getRootElem();
            //vp.select(root, "#chartName").text(uiName);
            vp.select(root, "#chartType").text(uiName + " chart: ");
            var xGrid = this.hideRowByElem(root, "xGridLines");
            var yGrid = this.hideRowByElem(root, "yGridLines");
            //var separator = this.hideRowByElem(root, "separation");
            var stackingCols = this.hideRowByElem(root, "stackingCols");
            var numCols = this.hideRowByElem(root, "numCols");
            var buildFromTop = this.hideRowByElem(root, "buildFromTop");
            var nextSpiral = this.hideRowByElem(root, "nextSpiral");
            //var sizePacking = this.hideRowByElem(root, "sizePacking");
            //---- charts from ROW #1 ----
            if (uiName == "Grid") {
                //this.showRow(separator);
                this.showRow(numCols);
                this.showRow(buildFromTop);
            }
            else if (uiName == "Squarify") {
            }
            else if (uiName == "Spiral") {
                this.showRow(nextSpiral);
            }
            else if (uiName == "Random") {
            }
            else if (uiName == "Radial") {
            }
            //else if (isChartCustom)
            //{
            //    this.showRow(customPicker);
            //}
            //---- charts from ROW #2 ----
            if (uiName == "Column" || uiName == "Bar") {
            }
            if (uiName == "Column" || uiName == "Bar" || uiName == "Density" || uiName == "Violin") {
                this.showRow(xGrid);
                this.showRow(yGrid);
            }
            else if (uiName == "Stacks") {
                this.showRow(stackingCols);
            }
            //---- charts from ROW #3 ----
            if (uiName == "Scatter") {
                this.showRow(xGrid);
                this.showRow(yGrid);
            }
            else if (uiName == "Line") {
                this.showRow(xGrid);
                this.showRow(yGrid);
            }
            else if (uiName == "X-Band") {
                this.showRow(xGrid);
            }
            else if (uiName == "Y-Band") {
                this.showRow(yGrid);
            }
            else if (uiName == "Line") {
                this.showRow(xGrid);
                this.showRow(yGrid);
            }
            else if (uiName == "Scatter-3D") {
            }
        };
        viewPanelMgrClass.prototype.getChartElemByName = function (name) {
            var elemX = null;
            var elemsW = vp.select(".chartPickerEntry");
            elemsW.each(function (index, elem) {
                if (elem.returnName == name) {
                    elemX = elem;
                    return false;
                }
            });
            return elemX;
        };
        viewPanelMgrClass.prototype.changeSelectedChart = function () {
            var chart = this._app.currentChart();
            var value = chart.getUiChartName();
            if (this._selectedChartElem) {
                vp.select(this._selectedChartElem)
                    .attr("data-selected", "false");
            }
            this._selectedChartElem = this.getChartElemByName(value);
            if (this._selectedChartElem) {
                vp.select(this._selectedChartElem)
                    .attr("data-selected", "true");
                this.updateControlsToMatchChart(value, false);
            }
        };
        viewPanelMgrClass.prototype.addChart = function (rowW, title, imgSrc, tooltip, valueText) {
            var _this = this;
            var propName = "is" + title + "Enabled";
            var settings = this._app._appSettingsMgr;
            var chartsPerRow = 6;
            var isEnabled = settings[propName]();
            if (isEnabled) {
                var startNewRow = (rowW[0].children.length >= chartsPerRow);
                if (startNewRow) {
                    var tableW = vp.select(rowW[0].parentNode);
                    //---- spacing row ----
                    var rowW = tableW.append("tr")
                        .css("height", "10px");
                    rowW = tableW.append("tr");
                }
                if (!valueText) {
                    valueText = title;
                }
                var tdW = rowW.append("td")
                    .addClass("chartPickerEntry")
                    .title(tooltip)
                    .attach("click", function (e) {
                    _this.onClick(e);
                });
                var imgW = tdW.append("img")
                    .addClass("clickIcon chartPickerImage")
                    .css("width", "80px")
                    .css("pointer-events", "none")
                    .attach("dragstart", function (e) {
                    //---- prevent drag of icon ----
                    e.preventDefault();
                });
                beachParty.setIconName(this._app._themeMgr, imgW[0], imgSrc, "bigBarPanel");
                var titleW = tdW.append("div")
                    .addClass("chartPickerTitle")
                    .text(title);
                if (this._currentView == title) {
                    tdW.attr("data-selected", "true");
                    this._selectedChartElem = tdW[0];
                }
                tdW[0].returnName = valueText;
            }
            return rowW;
        };
        viewPanelMgrClass.prototype.onClick = function (e) {
            var elem = e.target;
            if (!elem.returnName) {
                elem = elem.parentNode;
            }
            this._callback(elem.returnName);
            this._jsonPanel.onUserAction(null, true, beachParty.Gesture.select, beachParty.ElementType.picklist, "chartType");
        };
        viewPanelMgrClass.prototype.onClose = function () {
            //---- unregister with other data objects to avoid leaking memory ----
            this._app.unregisterForChanges(this, "chartName");
            this._jsonPanel.unregisterForChanges(this, "close");
            this.onDataChanged("close");
        };
        return viewPanelMgrClass;
    }(beachParty.baseJsonControlClass));
    beachParty.viewPanelMgrClass = viewPanelMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    workerMgr.ts - manages a pool of web worker objects using a queue of work items.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var workerMgrClass = (function (_super) {
        __extends(workerMgrClass, _super);
        function workerMgrClass(workerScriptName, maxWorkers) {
            if (maxWorkers === void 0) { maxWorkers = 5; }
            _super.call(this);
            //_isRunning = false;
            this._workItems = [];
            this._totalWork = 0;
            this._workDone = 0;
            this._startTime = 0;
            this._elapsed = 0;
            this._progress = 0;
            this._callback = null;
            this._workers = [];
            this._workerScriptName = workerScriptName;
            this._maxWorkers = maxWorkers;
            this.resetAll();
        }
        //start()
        //{
        //    this._isRunning = true;
        //    this.buildWork();
        //}
        workerMgrClass.prototype.isRunning = function () {
            return this.getActiveWorkers() > 0;
        };
        workerMgrClass.prototype.stopWorkers = function () {
            for (var i = 0; i < this._workers.length; i++) {
                var w = this._workers[i];
                if (w != null) {
                    this._workers[i] = null;
                    w.terminate();
                }
            }
            this._workItems = [];
            this.resetAll();
            //this._isRunning = false;
            this._elapsed = +Date.now() - this._startTime;
            //document.getElementById("timing").textContent = "elapsed: " + elapsed + " ms";
        };
        workerMgrClass.prototype.getActiveWorkers = function () {
            var count = 0;
            for (var i = 0; i < this._workers.length; i++) {
                if (this._workers[i] != null) {
                    count++;
                }
            }
            return count;
        };
        workerMgrClass.prototype.startMoreWorkersIfNeeded = function () {
            var _this = this;
            var activeCount = this.getActiveWorkers();
            var workers = this._workers;
            var workItems = this._workItems;
            if (workItems.length == 0 && activeCount == 0) {
                this.stopWorkers();
            }
            while (workItems.length && this.getActiveWorkers() < this._maxWorkers) {
                var work = workItems.pop();
                var worker = new Worker(this._workerScriptName);
                var workerId = workers.indexOf(null);
                work.workerId = workerId;
                workers[workerId] = worker;
                if (this._callback) {
                    var msgBlock = { event: "workItemStarted", workerId: workerId, workDone: this._workDone, progress: this._progress };
                    this._callback(msgBlock);
                }
                worker.onmessage = function (e) {
                    var data = e.data;
                    if (data.status == "done") {
                        var workerId = data.workerId;
                        var workAmt = (data.workAmt !== undefined) ? data.workAmt : 1;
                        _this._workDone += workAmt;
                        _this._progress = Math.round((_this._workDone / _this._totalWork) * 100);
                        if (_this._callback) {
                            var msgBlock = {
                                event: "workItemCompleted", workerId: workerId, workDone: _this._workDone,
                                progress: _this._progress, result: data.result
                            };
                            _this._callback(msgBlock);
                        }
                        workers[workerId] = null;
                        _this.startMoreWorkersIfNeeded();
                    }
                };
                worker.postMessage(work); // start the worker
            }
        };
        workerMgrClass.prototype.resetAll = function () {
            this._workItems = [];
            this._totalWork = 0;
            this._workDone = 0;
            this._progress = 0;
            for (var i = 0; i < this._maxWorkers; i++) {
                this._workers[i] = null;
            }
        };
        workerMgrClass.prototype.queueWork = function (work, workAmt) {
            if (this._workItems.length == 0) {
                this._startTime = +Date.now();
            }
            work.workAmt = workAmt;
            this._workItems.push(work);
            this._totalWork += workAmt;
            //this.startMoreWorkersIfNeeded();
        };
        workerMgrClass.prototype.start = function (callback) {
            this._callback = callback;
            this.startMoreWorkersIfNeeded();
        };
        workerMgrClass.prototype.buildWork = function () {
            //---- client code looks like this ----
            this.resetAll();
            //---- queue up 20 tasks ----
            for (var i = 0; i < 20; i++) {
                var n = Math.round(1000 * Math.random());
                this.queueWork({ count: n }, n);
            }
        };
        return workerMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.workerMgrClass = workerMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    clusterPanelMgr.ts - manages the "clusterPanel.js" floating panel.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var clusterPanelMgrClass = (function (_super) {
        __extends(clusterPanelMgrClass, _super);
        function clusterPanelMgrClass(app, buttonId, columns, maxWorkers) {
            var _this = this;
            _super.call(this);
            this._numClusters = 3;
            this._numRuns = 4;
            this._outputColumn = "ClusterId";
            this._isClusterOverlay = false;
            this._isAutoClustering = false;
            this._mapResults = beachParty.ClusterResultMapping.color;
            this._minResult = null;
            this._app = app;
            this._columns = columns;
            var rc = vp.select("#" + buttonId).getBounds(false);
            var x = rc.left;
            var y = rc.bottom;
            var jsonPanel = beachParty.buildJsonPanel(app, buttonId, this, "clusterPanel", false, x, y, undefined, undefined, undefined, undefined, undefined, "clusterButton");
            this._jsonPanel = jsonPanel;
            jsonPanel.registerForChange("close", function (e) {
                _this.onDataChanged("close");
            });
            jsonPanel.togglePin(null); // unpin the panel
            this.showProgress(false);
            this._workerMgr = new beachParty.workerMgrClass("scripts/kMeansWorker.js?foo=1", maxWorkers);
            //---- add "score" display as peer to "progress" ----
            var progressW = vp.select(this._jsonPanel.getRootElem(), "#progress")
                .css("margin", "6px 0 4px -6px");
            var parentElem = progressW[0].parentNode;
            var scoreW = vp.select(parentElem).append("div")
                .addClass("panelDisplay")
                .id("score");
            this.showScore(false);
        }
        clusterPanelMgrClass.prototype.getJsonPanel = function () {
            return this._jsonPanel;
        };
        clusterPanelMgrClass.prototype.showScore = function (value) {
            vp.select(this._jsonPanel.getRootElem(), "#score")
                .css("display", (value) ? "" : "none");
        };
        clusterPanelMgrClass.prototype.showProgress = function (value) {
            if (value) {
                vp.select(this._jsonPanel.getRootElem(), "#progress")
                    .css("display", "");
            }
            else {
            }
        };
        clusterPanelMgrClass.prototype.updateProgress = function (value) {
            this.showProgress(true);
            vp.select(this._jsonPanel.getRootElem(), ".panelInnerProgressBar")
                .css("width", value + "%");
            if (true) {
                //this.showProgress(false);
                var dist = vp.formatters.comma(this._minDistance);
                this.updateScore("Best distance: " + dist);
            }
        };
        clusterPanelMgrClass.prototype.updateScore = function (value) {
            this.showScore(true);
            vp.select(this._jsonPanel.getRootElem(), "#score")
                .text(value);
        };
        clusterPanelMgrClass.prototype.updateStartButton = function (value) {
            vp.select(this._jsonPanel.getRootElem(), "#start")
                .text(value);
        };
        clusterPanelMgrClass.prototype.close = function () {
            this._jsonPanel.close();
        };
        clusterPanelMgrClass.prototype.numRuns = function (value) {
            if (arguments.length == 0) {
                return this._numRuns;
            }
            this._numRuns = value;
            this.onDataChanged("numRuns");
        };
        clusterPanelMgrClass.prototype.outputColumn = function (value) {
            if (arguments.length == 0) {
                return this._outputColumn;
            }
            this._outputColumn = value;
            this.onDataChanged("outputColumn");
        };
        clusterPanelMgrClass.prototype.columns = function (value) {
            if (arguments.length == 0) {
                var colStr = beachParty.cbUtils.arrayToString(this._columns, ", ");
                return colStr;
            }
            this._columns = beachParty.cbUtils.stringToArray(value, ", ");
            this.onDataChanged("columns");
            if (this._isAutoClustering) {
                this.startClustering();
            }
            else {
                this._workerMgr.resetAll();
                this._minDistance = Number.MAX_VALUE;
                this._minResult = null;
                this.updateProgress(0);
                this.updateScore("Stopped");
            }
        };
        clusterPanelMgrClass.prototype.numClusters = function (value) {
            if (arguments.length == 0) {
                return this._numClusters;
            }
            this._numClusters = value;
            this.onDataChanged("numClusters");
        };
        clusterPanelMgrClass.prototype.isClusterOverlay = function (value) {
            if (arguments.length == 0) {
                return this._isClusterOverlay;
            }
            this._isClusterOverlay = value;
            this.onDataChanged("isClusterOverlay");
        };
        clusterPanelMgrClass.prototype.isAutoClustering = function (value) {
            if (arguments.length == 0) {
                return this._isAutoClustering;
            }
            this._isAutoClustering = value;
            this.onDataChanged("isAutoClustering");
        };
        clusterPanelMgrClass.prototype.mapResults = function (value) {
            if (arguments.length == 0) {
                return beachParty.ClusterResultMapping[this._mapResults];
            }
            this._mapResults = beachParty.ClusterResultMapping[value];
            this.onDataChanged("mapResults");
        };
        clusterPanelMgrClass.prototype.addToRecords = function (records, data) {
            for (var i = 0; i < data.length; i++) {
                var dataItem = data[i];
                var record = records[i];
                if (!record) {
                    record = [];
                    records[i] = record;
                }
                record.push(dataItem);
            }
        };
        clusterPanelMgrClass.prototype.onStartButton = function () {
            if (this._workerMgr.isRunning()) {
                this._workerMgr.stopWorkers();
                this.onClusteringStopped();
                this.updateProgress(0);
            }
            else {
                this.startClustering();
            }
        };
        clusterPanelMgrClass.prototype.startClustering = function () {
            if (!this._columns || this._columns.length == 0) {
                throw "Cannot cluster - no columns defined in current chart";
            }
            this.startClusteringCore();
        };
        clusterPanelMgrClass.prototype.startClusteringCore = function () {
            var _this = this;
            this._minDistance = Number.MAX_VALUE;
            this._minResult = null;
            //---- update UI ----
            this.updateProgress(0);
            this.updateScore("Starting...");
            this.updateStartButton("Stop");
            //---- prep data ----
            var dataMgr = this._app.currentChart().getDataMgr();
            dataMgr.getDataVectors(this._columns, true, function (nv) {
                var records = [];
                //---- normalize data ----
                for (var i = 0; i < _this._columns.length; i++) {
                    var colName = _this._columns[i];
                    var data = nv[colName];
                    var nData = vp.data.normalize(data);
                    _this.addToRecords(records, nData);
                }
                //---- queue up each run ----
                var wm = _this._workerMgr;
                wm.resetAll();
                var kd = _this._numClusters * _this._columns.length;
                for (var i = 0; i < _this._numRuns; i++) {
                    //---- update random numbers used for this work item ----
                    var kdRandomNumbers = [];
                    for (var k = 0; k < kd; k++) {
                        kdRandomNumbers[k] = Math.random();
                    }
                    var jsonObj = { columns: records, K: _this._numClusters, kdRandomNumbers: kdRandomNumbers };
                    vp.utils.debug("work item: " + i + ", kd.length=" + kdRandomNumbers.length + ", first=" +
                        kdRandomNumbers[0]);
                    wm.queueWork(jsonObj, 1);
                }
                wm.start(function (msgBlock) {
                    var eventName = msgBlock.event;
                    if (eventName == "workItemCompleted") {
                        var result = msgBlock.result;
                        vp.utils.debug("workerId=" + msgBlock.workerId + ", epoc=" + result.epoc
                            + ", distance=" + result.totalDistance);
                        if (result.totalDistance < _this._minDistance) {
                            _this._minDistance = result.totalDistance;
                            _this._minResult = result;
                        }
                        _this.updateProgress(msgBlock.progress);
                        if (msgBlock.progress == 100) {
                            _this.onClusteringStopped();
                        }
                    }
                });
            });
        };
        clusterPanelMgrClass.prototype.buildSortedKeys = function (clusters) {
            var sortedKeys = [];
            for (var i = 0; i < clusters.length; i++) {
                var cluster = clusters[i];
                if (cluster.counts > 0) {
                    sortedKeys.push(i + "");
                }
            }
            return sortedKeys;
        };
        clusterPanelMgrClass.prototype.onClusteringStopped = function () {
            var _this = this;
            this.updateStartButton("Start");
            if (this._minResult) {
                //---- upload new ClusterId column to engine ----
                var colStr = beachParty.cbUtils.arrayToString(this._columns, ", ");
                var colData = this._minResult.clusterAssignments;
                var sortedKeys = this.buildSortedKeys(this._minResult.clusters);
                var keyCount = sortedKeys.length;
                var stats = new beachParty.ColStats(0, keyCount - 1, 0, keyCount, sortedKeys);
                var colInfo = new beachParty.ColInfo(this._outputColumn, "Created from columns: " + colStr, "string", undefined, stats);
                var dataMgr = this._app.currentChart().getDataMgr();
                var dataFrame = dataMgr.getDataFrame();
                var colInfos = [colInfo];
                dataFrame.addColsToData(colInfos, [colData], function (newColInfos) {
                    _this._app.onClusterIdCreated(newColInfos, _this._mapResults, _this._outputColumn, _this._numClusters);
                });
            }
        };
        return clusterPanelMgrClass;
    }(beachParty.baseJsonControlClass));
    beachParty.clusterPanelMgrClass = clusterPanelMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    fileOpenMgr.ts - manages the dataPanel, where files are opened.  This mgr is responsible
//                     for staring async load of data files thru the dataMgr.  All charts have hooked
//                     the dataMgr's dataLoad event, so they will process the completed operation.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var dataPanelMgr = (function (_super) {
        __extends(dataPanelMgr, _super);
        function dataPanelMgr(app, chartRouter) {
            _super.call(this);
            this._dataPanel = null;
            this._fileOpenUrl = "";
            this._fileOpenCs = "";
            this._fileOpenSource = null;
            this._selectedSampleName = "";
            this._selectedFileName = "<none>";
            this._sqlTableName = "";
            //_workingDataMaxRecords = 25 * 1000;
            this._openFileTypeLocal = "tab";
            this._openFileTypeWeb = "json";
            this._fileHasHeader = true;
            this._dataScrubberName = "None";
            this._app = app;
            this._dataEngine = app._dataEngine;
            this._chartRouter = chartRouter;
        }
        dataPanelMgr.prototype.preload = function (value) {
            if (arguments.length == 0) {
                return this._preload;
            }
            this._preload = value;
            this.onDataChanged("preload");
        };
        dataPanelMgr.prototype.selectedOpenFile = function (value) {
            var _this = this;
            if (arguments.length == 0) {
                return this._selectedOpenFile;
            }
            this._selectedOpenFile = value;
            if (value) {
                var dataMgr = this._app.getChartDataMgr();
                dataMgr.loadFileFromRelationMgr(value, function (e) {
                    _this._selectedFileName = value;
                    _this.loadFileOpenLocal();
                });
            }
            this.onDataChanged("selectedOpenFile");
        };
        /** Show FILE OPEN panel. */
        dataPanelMgr.prototype.openFileOpenPanel = function (e, isFromLegend) {
            var _this = this;
            var uiOpenName = (isFromLegend) ? "titleText" : "bbData";
            var buttonW = vp.select("#" + uiOpenName);
            if (buttonW.length) {
                var rc = buttonW.getBounds(false);
            }
            else {
                var rc = vp.geom.createRect(0, 0, 100, 100);
            }
            var left = rc.left;
            var top = rc.bottom;
            if (!isFromLegend) {
                //---- use parent of button for button bottom value ----
                var parent = buttonW[0].parentNode;
                var rcParent = vp.select(parent).getBounds();
                top = rcParent.bottom - 1;
            }
            this._dataPanel = beachParty.buildJsonPanel(this._app, uiOpenName, this, "dataPanel", true, left, top, undefined, undefined, undefined, undefined, undefined, uiOpenName);
            this._dataPanel.registerForChange("close", function (e) {
                _this._dataPanel = null;
            });
            //---- make sure actions don't auto-close (except for "load" button) ----
            this._dataPanel._closeOnAction = false;
            var elem = this._dataPanel.getRootElem();
            this._app._panelMaster.registerCustomPanel(beachParty.Target.datasetPanel, this._dataPanel);
            /// sample SQL connection string: 
            ///     Data Source=localhost;Initial Catalog=BeachParty;Integrated Security=True
            /// sample SQL query:
            ///     select * top 100 from TeraVis;
            //---- hide SQL for the client edition ----
            var settings = this._app._appSettingsMgr;
            if (!settings.isSqlEnabled()) {
                vp.select(elem, "#tab4").css("display", "none");
            }
            //---- hide SWITCH tab if < 2 files are open ----
            var relationMgr = this._dataEngine.getRelationMgr();
            if (relationMgr.getFileCount() < 2) {
                //vp.select(elem, "#tab0").css("display", "none");
                this._dataPanel.showTab("tab0", false);
                var newFirstTab = vp.select(elem, "#tab1")[0];
                this._dataPanel.onTabSelected(newFirstTab);
            }
            if (!this._app.isInternalSession()) {
                //---- hide the SQL and TEST tabs ----
                this._dataPanel.showTab("tab4", false);
                this._dataPanel.showTab("tab5", false);
            }
            //---- adjust length of knownDataPickerList ----
            var panelHeight = vp.select(elem).height();
            //vp.select(elem, "#knownDataPickerList") 
            //    .css("max-height", (panelHeight - 65) + "px");
        };
        dataPanelMgr.prototype.getUrlSample = function () {
            return "http://localhost/vuebigdata/datafiles/iris.txt";
        };
        dataPanelMgr.prototype.getSqlCsSample = function () {
            //---- connection string for localhost ----
            var cs = "Server=localhost;Database=BeachParty;User ID=vibedemo;Password=vibedemo;Trusted_Connection=False";
            return cs;
        };
        dataPanelMgr.prototype.getSqlTableSample = function () {
            //---- connection string for localhost ----
            return "TeravisContosco";
        };
        dataPanelMgr.prototype.processDroppedTextOrFile = function (e) {
            e.preventDefault();
            var dt = e.dataTransfer;
            var files = dt.files;
            if (files && files.length) {
                var file = files[0];
                var reader = new FileReader();
                var name = file.name;
                var dataMgr = this._app.getChartDataMgr();
                //---- avoid processing image files (especially if its an accidental drag of our of 1 of our icons) ----
                if (!beachParty.cbUtils.isImageFile(name)) {
                    var fileType = file.type;
                    var size = file.size;
                    var reader = new FileReader();
                    reader.onload = function (e) {
                        // get file content
                        var text = e.target.result;
                        var wdParams = new beachParty.WorkingDataParams(file.name, file.name);
                        wdParams.hasHeader = true;
                        wdParams.separator = (file.name.endsWith(".txt")) ? "\t" : ",";
                        wdParams.fileType = beachParty.FileType.delimited;
                        dataMgr.loadFrom(text, file.name, wdParams); //, this._onLoadCallback);
                    };
                    //---- start the ASYNC read of the dropped file ----
                    reader.readAsText(file);
                }
            }
            else {
                //---- process the dropped TEXT ----
                var text = dt.getData("text");
                if (text) {
                    if (text.contains("\t")) {
                        var fn = "dragAndDrop.txt";
                        var wdParams = new beachParty.WorkingDataParams(fn);
                        wdParams.hasHeader = true;
                        wdParams.separator = "\t";
                        wdParams.fileType = beachParty.FileType.delimited;
                        dataMgr.loadFrom(text, fn, wdParams); //, this._onLoadCallback);
                    }
                    else {
                        //---- ignore accidental drop of text from a SandDance text box, etc. ----
                        if (text.startsWith("http")) {
                            this._app._insightMgr.processDroppedText(text);
                        }
                    }
                }
            }
        };
        dataPanelMgr.prototype.selectedSampleName = function (value) {
            if (arguments.length === 0) {
                return this._selectedSampleName;
            }
            this._selectedSampleName = value;
            this._fileOpenSource = "sample";
            var dataMgr = this._app.getChartDataMgr();
            dataMgr.openKnownFile(value, true); //, this._onLoadCallback);
            this.closeFileOpenPanel();
            this.onDataChanged("selectedSampleName");
        };
        dataPanelMgr.prototype.closeFileOpenPanel = function (forceClose) {
            if (this._dataPanel) {
                //---- don't close if panel is draggable (user must close explictly) ----
                if (forceClose || !this._dataPanel.isShowingTitle()) {
                    this._dataPanel.close();
                }
            }
        };
        dataPanelMgr.prototype.close = function () {
            this.closeFileOpenPanel();
        };
        dataPanelMgr.prototype.selectedFileName = function (value) {
            if (arguments.length === 0) {
                return this._selectedFileName;
            }
            this._selectedFileName = value;
            this._fileOpenSource = "local";
            this.onDataChanged("selectedFileName");
        };
        dataPanelMgr.prototype.openFileTypeLocal = function (value) {
            if (arguments.length === 0) {
                return this._openFileTypeLocal;
            }
            this._openFileTypeLocal = value;
            this.onDataChanged("openFileTypeLocal");
            this.onDataChanged("isFirstLineDisabledLocal");
        };
        dataPanelMgr.prototype.openFileTypeWeb = function (value) {
            if (arguments.length === 0) {
                return this._openFileTypeWeb;
            }
            this._openFileTypeWeb = value;
            this.onDataChanged("openFileTypeWeb");
            this.onDataChanged("isFirstLineDisabledWeb");
        };
        dataPanelMgr.prototype.fileOpenURL = function (value) {
            if (arguments.length === 0) {
                return this._fileOpenUrl;
            }
            this._fileOpenUrl = value;
            this._fileOpenSource = "web";
            this.setFileTypeFromNameWeb(value);
            this.onDataChanged("fileOpenURL");
        };
        dataPanelMgr.prototype.fileOpenCs = function (value) {
            if (arguments.length === 0) {
                return this._fileOpenCs;
            }
            this._fileOpenCs = value;
            this._fileOpenSource = "sql";
            this.setFileTypeFromNameWeb(value);
            this.onDataChanged("fileOpenCs");
        };
        dataPanelMgr.prototype.sqlTableName = function (value) {
            if (arguments.length === 0) {
                return this._sqlTableName;
            }
            this._sqlTableName = value;
            this.onDataChanged("sqlTableName");
        };
        dataPanelMgr.prototype.fileHasHeader = function (value) {
            if (arguments.length === 0) {
                return this._fileHasHeader;
            }
            this._fileHasHeader = value;
            this.onDataChanged("fileHasHeader");
        };
        dataPanelMgr.prototype.toggleDatasetPanel = function (e, isFromLegend) {
            //---- reset results from last file load ----
            this._selectedFileName = "";
            //this._fileOpenUrl = "";
            this._fileOpenSource = null;
            var buttonId = (e) ? e.target.id : "";
            if (this._dataPanel) {
                this.closeFileOpenPanel(true);
            }
            else {
                this.openFileOpenPanel(e, isFromLegend);
            }
        };
        dataPanelMgr.prototype.setLocalFileType = function (fn) {
            var fileType = null;
            if (fn.endsWith(".txt")) {
                fileType = "tab";
            }
            else if (fn.endsWith(".csv")) {
                fileType = "comma";
            }
            else if (fn.endsWith(".json")) {
                fileType = "json";
            }
            if (fileType) {
                this.openFileTypeLocal(fileType);
            }
        };
        dataPanelMgr.prototype.setFileTypeFromNameWeb = function (fn) {
            if (fn.endsWith(".txt")) {
                this.openFileTypeWeb("tab");
            }
            else if (fn.endsWith(".csv")) {
                this.openFileTypeWeb("comma");
            }
            else if (fn.endsWith(".json")) {
                this.openFileTypeWeb("json");
            }
        };
        dataPanelMgr.prototype.isFirstLineDisabledLocal = function () {
            var ft = this._openFileTypeLocal;
            return (ft == "json");
        };
        dataPanelMgr.prototype.isFirstLineDisabledWeb = function () {
            var ft = this._openFileTypeWeb;
            return (ft == "json");
        };
        dataPanelMgr.prototype.onOpenFileClicked = function () {
            var fileExts = ".csv,.txt,.json";
            if (true) {
                fileExts += ",.png,.jpg,.bmp";
            }
            this.selectedFileName(null);
            this.openLocalFile(fileExts);
        };
        /** used to open Web URL files and SQL files. */
        dataPanelMgr.prototype.loadFileFromPanel = function (url, sqlTableName) {
            /// some test URL's:
            ///     http://localhost/vuebigdata/datafiles/iris.txt
            ///     http://vibe10/vuebigdata/datafiles/loanData.csv
            ///     http://vibe10/vuebigdata/datafiles/mediumSales.json
            if (url) {
                var fileType = this._openFileTypeWeb;
                // var text = this._loadedFileOpenText;
                if (sqlTableName) {
                    var fn = sqlTableName;
                }
                else {
                    var fn = beachParty.appUtils.getLastNodeOfUrl(url);
                }
                var fileSource = (sqlTableName) ? "sql" : "url";
                var dataMgr = this._app.getChartDataMgr();
                var scrubberTemplate = this._dataScrubberName;
                if (scrubberTemplate) {
                    var wdParams = dataMgr.getPreloadFromLocalStorage(scrubberTemplate, null, sqlTableName);
                }
                if (!wdParams) {
                    wdParams = new beachParty.WorkingDataParams(fn, url);
                    wdParams.hasHeader = this._fileHasHeader;
                    wdParams.separator = (fileType == "tab") ? "\t" : ",";
                    wdParams.fileType = (fileType == "json") ? beachParty.FileType.json : beachParty.FileType.delimited;
                    wdParams.fileSource = fileSource;
                }
                wdParams.forceDataLoad = true; // don't use existing open data
                if (sqlTableName) {
                    if (sqlTableName.contains(" ") || sqlTableName.contains(";")) {
                        wdParams.queryString = sqlTableName;
                        var name = sqlTableName;
                    }
                    else {
                        wdParams.tableName = sqlTableName;
                        var name = sqlTableName;
                    }
                    wdParams.fileType = beachParty.FileType.sql;
                }
                //wdParams.maxRecords = maxRecords;
                var settings = this._app._appSettingsMgr;
                wdParams.dataSampling = settings.autoSampling();
                //---- supply a dataName so we can refer to this open data source when needed ----
                wdParams.dataName = fn;
                dataMgr.setFileOpenObjects(null);
                this._app.showMsg("Loading data", fn, "Please wait...");
                if ((window.external && window.external.isHosted)) {
                    window.external.requestFile(wdParams.fileSource, fn, url, wdParams.separator);
                }
                else {
                    dataMgr.loadData(wdParams); //, this._onLoadCallback);
                }
                this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.button, beachParty.Action.load, beachParty.Target.data, true, { source: wdParams.fileSource, length: null, fileType: fileType, hasHeader: this._fileHasHeader, usingScrubber: (this._dataScrubberName != null) });
            }
            this.closeFileOpenPanel();
        };
        dataPanelMgr.prototype.loadFileOpenWeb = function () {
            /// some test URL's:
            ///     http://localhost/vuebigdata/datafiles/iris.txt
            ///     http://vibe10/vuebigdata/datafiles/loanData.csv
            ///     http://vibe10/vuebigdata/datafiles/mediumSales.json
            this.loadFileFromPanel(this._fileOpenUrl);
        };
        /** local a local file using our properties (include this._loadedFileOpenText). */
        dataPanelMgr.prototype.loadFileOpenLocal = function () {
            this.closeFileOpenPanel();
            var dataMgr = this._app.getChartDataMgr();
            dataMgr.loadLocalFile(this._selectedFileName, this._openFileTypeLocal, this._dataScrubberName, this._fileHasHeader); //, this._onLoadCallback);
        };
        dataPanelMgr.prototype.loadFileOpenSql = function () {
            this.loadFileFromPanel(this._fileOpenCs, this._sqlTableName);
        };
        dataPanelMgr.prototype.getApp = function () {
            return this._app;
        };
        dataPanelMgr.prototype.openLocalFile = function (fileExts) {
            var _this = this;
            //---- support for multiple files ----
            beachParty.localFileHelper.getFileOpenSelections(fileExts, function (files) {
                //---- "files" in array of local file objects (files that user selected in File Open) ----
                var dataMgr = _this._app.getChartDataMgr();
                dataMgr.setFileOpenObjects(files);
                var fileList = "";
                for (var i = 0; i < files.length; i++) {
                    var file = files[i];
                    var fn = file.name;
                    if (fileList != "") {
                        fileList += " ";
                    }
                    fileList += fn;
                }
                _this.selectedFileName(fileList);
                var settings = _this._app._appSettingsMgr;
                //---- read first file ----
                beachParty.localFileHelper.loadFileFromFileObj(settings, files[0], function (text, fn, preload) {
                    try {
                        //---- NOTE: file is actually uploaded via "loadFileOpenLocal()", called from fileOpenPanel OK button handler ----
                        _this._preload = preload;
                        var dataMgr = _this._app.getChartDataMgr();
                        //dataMgr.loadFrom(text, fn, preload);
                        dataMgr.loadedFileOpenText(text);
                        //this.selectedFileName(fn);
                        _this.setLocalFileType(fn);
                    }
                    catch (ex) {
                        throw "Error parsing session file: " + ex;
                    }
                });
            });
        };
        dataPanelMgr.prototype.reloadDataPerScrubbing = function (editInfos, callback) {
            var dataMgr = this._app.getChartDataMgr();
            dataMgr.reloadDataPerScrubbing(editInfos, this._preload, callback);
        };
        dataPanelMgr.prototype.dataScrubberName = function (value) {
            if (arguments.length == 0) {
                return this._dataScrubberName;
            }
            this._dataScrubberName = value;
            this.onDataChanged("dataScrubberName");
        };
        return dataPanelMgr;
    }(beachParty.dataChangerClass));
    beachParty.dataPanelMgr = dataPanelMgr;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    appUtils.ts - utility functions for BeachPartyApp.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var appUtils = (function () {
        function appUtils() {
        }
        appUtils.clipTextForTitle = function (str, maxChars) {
            if (maxChars === void 0) { maxChars = 256; }
            if (!str) {
                str = "";
            }
            else if (str.length > maxChars) {
                str = str.substr(0, maxChars) + "...";
            }
            return str;
        };
        appUtils.getLastNodeOfUrl = function (url) {
            var index = url.lastIndexOf("/");
            if (index == -1) {
                var index = url.lastIndexOf("\\");
            }
            if (index > -1) {
                url = url.substr(index + 1);
            }
            return url;
        };
        appUtils.lowerCaseFirstLetter = function (value) {
            if (value.length) {
                value = value[0].toLowerCase() + value.substr(1);
            }
            return value;
        };
        appUtils.setButtonSelectedState = function (themeMgr, baseName, value, fnNorm, fnSelect) {
            var buttonName = "#" + baseName + "Button";
            var imgName = "#" + baseName + "Icon";
            var imgW = vp.select(imgName);
            if (value) {
                //---- mark as SELECTED and change images, if needed ----
                vp.select(buttonName).attr("data-selected", "true");
                vp.select(imgName).attr("data-selected", "true");
                //imgW.attr("src", fnSelect);
                if (imgW.length) {
                    beachParty.setIconName(themeMgr, imgW[0], fnSelect, "iconBarPanel", true);
                }
            }
            else {
                //---- mark as NOT SELECTED and change images, if needed ----
                vp.select(buttonName).attr("data-selected", "false");
                vp.select(imgName).attr("data-selected", "false");
                //imgW.attr("src", fnNorm);
                if (imgW.length) {
                    beachParty.setIconName(themeMgr, imgW[0], fnNorm, "iconBarPanel", true);
                }
            }
        };
        appUtils.disableCheckbox = function (assemblyW, isDisabled) {
            //---- mark the assembly as data-disabled so theme (.less file) can draw as disabled ----
            assemblyW.attr("data-disabled", isDisabled + "");
            //---- mark actual checkbox as "disabled" ----
            var cbW = vp.select(assemblyW, "input");
            if (isDisabled) {
                cbW.attr("disabled", "true");
            }
            else {
                cbW[0].removeAttribute("disabled");
            }
        };
        appUtils.disableEnum = function (assemblyW, isDisabled) {
            //---- mark the assembly as data-disabled so theme (.less file) can draw as disabled ----
            assemblyW.attr("data-disabled", isDisabled + "");
        };
        return appUtils;
    }());
    beachParty.appUtils = appUtils;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    appSettingsMgr.ts - manages the application setting parameters.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    //---- all possible icon buttons ----
    var iconButtons = ["Insights", "Nav", "Undo", "Tips", "Search", "Browse", "Isolate", "Exclude",
        "Reset", "Details", "Tasks", "Bot", "Tours", "Help", "Settings", "Feedback", "About", "Redo", "SelectMode",
        "NewView", "Scrubber", "Clustering", "Redo", "Scripts", "Themes", "Palettes", "Options"];
    //---- all possible big buttons ----
    var bigButtons = ["Dataset", "Items", "Filtered", "Selected", "ViewAs", "Layers", "Wheel",
        "Time", "XAxis", "YAxis", "YAxis", "ZAxis", "SumBy", "FacetBy", "ColorBy", "SortBy", "SizeBy",
        "ShapeBy", "ImageBy", "TextBy", "LineBy"];
    var allButtons = iconButtons.concat(bigButtons);
    /**
     * This classes manages the persistable properties of SandDance.  The implementation of these properties follows a strong pattern
     * which is tedious to maintain, given the large amount of SandDance properties. Therefore, some of the more recently defined
     * properties are defined dynamically, to make them easier to add and maintain.  See "buildProperties()" to see how this is done.
     *
     * NOTE: ALL NEW PROPERTIES should be added used using the buildProperties() mechanism.
     *
     * TODO: convert old style properties to use the buildProperties() mechanism.
     */
    var appSettingsMgr = (function (_super) {
        __extends(appSettingsMgr, _super);
        //---- new ----
        //_axisLabelSize: number;
        //_legendLabelSize: number;
        //_titleLabelSize: number;
        //_axisLabelColor: string;
        //_legendLabelColor: string;
        //_titleLabelColor: string;
        function appSettingsMgr(app, chartRouter) {
            var _this = this;
            _super.call(this);
            this._isSavingSettingsDisabled = true;
            this._persistChangesDisabledFromUrlParams = false;
            //_initialLayout = Layout.Random;
            this._isChartPanelOpen = false;
            this._showInProgressUI = false;
            this._rememberLastFile = true; // on startup, load file from last session
            this._rememberLastSession = true; // on startup, restore last session
            this._rememberLastInsights = false; // on startup, load insights from last session
            this._isShowingDrawStats = false;
            this._isShowingLastCycle = false;
            this._isShowingEventStats = false;
            this._isErrorReportingDisabled = false;
            this._automatedTestName = "demoVoteTest.js";
            this._predefinedCustomChart = "Squarify";
            this._shapesByChartType = {};
            //---- CHART settings ----
            this._shapeOpacity = beachParty.chartClass.defaultOpacity;
            this._canvasColor = "none";
            this._chartColor = "none";
            this._drawingPrimitive = beachParty.DrawPrimitive.cube;
            this._instancingParams = new beachParty.InstancingParams();
            this._isContinuousDrawing = false;
            this._chartFrameData = new beachParty.ChartFrameData(); // early init timing
            this._animationData = new beachParty.AnimationData(); // early init timing 
            this._isTooltipsEnabled = false;
            this._is3dGridAlwaysOn = false;
            this._isWheelInertia = true;
            this._showWheelDuringTransformMode = false;
            this._isLightingAlwaysOn = false;
            this._lightingParams = new beachParty.Lighting();
            this._defaultBins = 9;
            this._useNiceNumbers = false;
            this._app = app;
            this._chartRouter = chartRouter;
            this.buildProperties();
            for (var i = 0; i < this._properties.length; i++) {
                var prop = this._properties[i];
                this.addPropertyToClass(prop);
            }
            this._dataCacheParams = new beachParty.DataCacheParams();
            this._appStyleSheet = new vp.dom.styleSheetClass()
                .id("appStyleSheet");
            this._hoverParams = new beachParty.HoverParams();
            this._selectionParams = new beachParty.SelectionParams();
            //---- declare button getter/setter functions ---
            this.createButtonProps(allButtons);
            this.registerForAnyChange(function (name) {
                if (name && name != "colPickerSettings") {
                    var value = _this[name]();
                    if (name == "initialThemeName" && value && vp.utils.isString(value) && value.contains(".json")) {
                        value = ""; // hide user's custom theme name
                    }
                    else if (name == "initDataParams") {
                        value = ""; // hide user's data name
                    }
                    var options = {};
                    options[name] = value;
                    _this._app.logAction(beachParty.Gesture.notAvailable, name, beachParty.ElementType.notAvailable, beachParty.Action.adjust, beachParty.Target.appSettings, true, options); // not safe to log any see, name, value);
                }
            });
        }
        appSettingsMgr.prototype.buildProperties = function () {
            this.addNamesToMethods();
            //---- build list of persistable properties ----
            var properties = [
                //---- APP tab: FONT section ----
                new PropertyInfo("normalFontFamily", null, "Calibri", this.onNormalFontFamilyChanged),
                //---- APP tab: FONT WEIGHT section ----
                new PropertyInfo("promptWeight", null, "normal", this.onPromptWeightChanged),
                new PropertyInfo("valueWeight", null, "normal", this.onValueWeightChanged),
                new PropertyInfo("selectedTabWeight", null, "normal", this.onSelectedTabWeightChanged),
                new PropertyInfo("titlePaneWeight", null, "normal", this.onTitlePaneWeightChanged),
                new PropertyInfo("tipNameWeight", null, "normal", this.onTipNameWeightChanged),
                new PropertyInfo("tableHeaderWeight", null, "normal", this.onTableHeaderWeightChanged),
                //---- APP tab: BACKGROUNDS section ----
                new PropertyInfo("appBgColor", null, "black", this.onAppBgColorChanged),
                new PropertyInfo("barBgColor", null, "rgb(28, 26, 24)", this.onBarBgColorChanged),
                new PropertyInfo("panelBgColor", null, "rgb(22, 22, 22)", this.onPanelBgColorChanged),
                new PropertyInfo("dockedBgColor", null, "rgb(22, 22, 22)", this.onDockedBgColorChanged),
                new PropertyInfo("hoverBgColor", null, "rgb(22, 22, 22)", this.onHoverBgColorChanged),
                new PropertyInfo("selectedBgColor", null, "rgb(22, 22, 22)", this.onSelectedBgColorChanged),
                //---- APP tab: BORDERS section ----
                new PropertyInfo("listBorderColor", null, "rgb(28, 26, 24)", this.onListBorderColorChanged),
                new PropertyInfo("buttonBorderColor", null, "gray", this.onButtonBorderColorChanged),
                new PropertyInfo("panelBorderColor", null, "rbg(119, 119, 119)", this.onPanelBorderColorChanged),
                new PropertyInfo("guideBorderColor", null, "gray", this.onGuideBorderColorChanged),
                new PropertyInfo("barBorderColor", null, "gray", this.onBarBorderColorChanged),
                new PropertyInfo("dockedBorderColor", null, "gray", this.onDockedBorderColorChanged),
                //---- BUTTONS: TEXT COLOR section ----
                new PropertyInfo("appTextColor", null, "white", this.onAppTextColorChanged),
                new PropertyInfo("buttonTextColor", null, "gray", this.onButtonTextColorChanged),
                new PropertyInfo("guideTextColor", null, "gray", this.onGuideTextColorChanged),
                new PropertyInfo("promptTextColor", null, "gray", this.onPromptTextColorChanged),
                new PropertyInfo("valueTextColor", null, "gray", this.onValueTextColorChanged),
                //---- BUTTONS: TEXT SIZES section ----
                new PropertyInfo("appTextSize", null, 16, this.onAppTextSizeChanged),
                new PropertyInfo("guideTextSize", null, 16, this.onGuideTextSizeChanged),
                new PropertyInfo("promptTextSize", null, 16, this.onPromptTextSizeChanged),
                new PropertyInfo("valueTextSize", null, 16, this.onValueTextSizeChanged),
                new PropertyInfo("titleTextSize", null, 16, this.onTitleTextSizeChanged),
                //---- BUTTONS: ICON BUTTONS section ----
                new PropertyInfo("isMenuIconVisible", null, false, this.onIsMenuIconVisibleChanged),
                new PropertyInfo("isMenuTextVisible", null, true, this.onIsMenuTextVisibleChanged),
                new PropertyInfo("isMenuChevronVisible", null, false, this.onIsMenuChevronVisibleChanged),
                new PropertyInfo("buttonIconWidth", null, 32, this.onButtonIconWidthChanged),
                //---- BUTTONS: OTHER OPTIONS section ----
                new PropertyInfo("isIconButtonsOnBigBar", null, false, this.onIconButtonsOnBigBarChanged),
                new PropertyInfo("isBigBarNextToLogo", null, false, this.onBigBarNextToLogoChanged),
                new PropertyInfo("isLogoHidden", null, true, this.onLogoHiddenChanged),
                new PropertyInfo("titlePanelAlignment", null, "left", this.onTitlePanelAlignmentChanged),
                //---- MISC ----
                new PropertyInfo("shapeColor", null, "beachBlue", this.onShapeColorChanged),
            ];
            this._properties = properties;
        };
        appSettingsMgr.prototype.stringToArray = function (str) {
            var aray = str.split(",");
            for (var i = 0; i < aray.length; i++) {
                aray[i] = aray[i].trim();
            }
            return aray;
        };
        /**
         * Overwrite the app settings with the specified theme data.
         */
        appSettingsMgr.prototype.overwriteAppSettings = function (propMap) {
            var bigButtons = this.stringToArray(propMap.bigButtons);
            var iconButtons = this.stringToArray(propMap.iconButtons);
            //----- handle all automatic properties with matching names ----
            for (var i = 0; i < this._properties.length; i++) {
                var prop = this._properties[i];
                var propValue = propMap[prop.name];
                if (propValue !== undefined) {
                    //---- call the property setter to apply the theme value to the currrent settings ----
                    this[prop.name](propValue);
                }
            }
            //---- apply changes for explict propties (not in this._properties) ----
            //---- BUTTONS from icon bar & big bar ----
            var bothBars = iconButtons.concat(bigButtons);
            this.applyButtonProps(bothBars);
            //---- CANVAS COLOR ----
            this.canvasColor(propMap.plotBackground);
            //---- CHART ----
            this.chartColor(propMap.chartBackground);
            this.selectedColor(propMap.selectedColor);
            //---- SELECTION RECTANGLE ----
            this._appStyleSheet.addRule(".rubberBand", "border-color: " + propMap.selectionRectangleColor + " !important");
            //---- ANCHOR LINKS ----
            this._appStyleSheet.addRule(".panelLink", "color: " + propMap.linkColor + " !important");
        };
        //---- declare DYNAMIC PROPERTY PLACEHOLDER methods (for methods called by code other than JsonPanel controls) ----
        appSettingsMgr.prototype.isLogoHidden = function (value) { return null; };
        appSettingsMgr.prototype.appBgColor = function (value) { return null; };
        appSettingsMgr.prototype.isMenuIconVisible = function (value) { return null; };
        appSettingsMgr.prototype.isMenuTextVisible = function (value) { return null; };
        appSettingsMgr.prototype.isMenuChevronVisible = function (value) { return null; };
        appSettingsMgr.prototype.iconWidth = function (value) { return null; };
        appSettingsMgr.prototype.isIconButtonsOnBigBar = function (value) { return null; };
        appSettingsMgr.prototype.shapeColor = function (value) { return null; };
        appSettingsMgr.prototype.addPropertyToClass = function (prop) {
            //---- create a property on our instance ----
            var propName = "_" + prop.name;
            this[propName] = prop.defaultValueForCtr;
            //---- create a getter/setter method on our instance ----
            var funcName = prop.name;
            var body = "if (arguments.length == 0)\r\n\t{return this." + propName + ";}\r\nthis." + propName + " = value;\r\n";
            if (prop.onChangedMethod) {
                var methodName = prop.onChangedMethod._name;
                body += "this." + methodName + "(value);\r\n";
            }
            body += "this.saveAppSettings();\r\nthis.onDataChanged('" + prop.name + "');\r\n";
            //---- create a function with a "value" parameter ----
            var func = new Function("value", body);
            this[funcName] = func;
        };
        appSettingsMgr.prototype.addNamesToMethods = function () {
            var anyThis = this;
            var proto = anyThis.__proto__;
            var names = vp.utils.keys(proto);
            for (var i = 0; i < names.length; i++) {
                var name = names[i];
                if (name != "constructor") {
                    var method = this[name];
                    method._name = name;
                }
            }
        };
        appSettingsMgr.prototype.setShapeForChart = function (chartName, layout, shapeType) {
            var key = chartName + "." + layout;
            this._shapesByChartType[key] = shapeType;
            //---- push change to all charts ----
            //this._app.setAllChartsProperty("shapesByChartType", this._shapesByChartType);
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isButtonEnabled = function (name) {
            var funcName = "is" + name + "Enabled";
            var result = this[funcName]();
            return result;
        };
        appSettingsMgr.prototype.getEnabledButons = function (names) {
            var enabledButtons = [];
            for (var i = 0; i < names.length; i++) {
                var name = names[i];
                var funcName = "is" + name + "Enabled";
                var propName = "_" + funcName;
                if (this[propName]) {
                    enabledButtons.push(name);
                }
            }
            return enabledButtons;
        };
        appSettingsMgr.prototype.clearAllButtons = function () {
            for (var i = 0; i < allButtons.length; i++) {
                var name = allButtons[i];
                var funcName = "is" + name + "Enabled";
                var propName = "_" + funcName;
                this[propName] = false;
            }
        };
        appSettingsMgr.prototype.applyButtonProps = function (names) {
            //---- first, clear all buttons enabled props ----
            this.clearAllButtons();
            for (var i = 0; i < names.length; i++) {
                var name = names[i];
                var funcName = "is" + name + "Enabled";
                var propName = "_" + funcName;
                this[propName] = true;
            }
            this.onDataChanged(null); // mark all properties changed
            //---- now, rebuild icon bar & big bar ----
            this.onButtonChanged();
        };
        appSettingsMgr.prototype.createButtonProps = function (names) {
            for (var i = 0; i < names.length; i++) {
                var name = names[i];
                this.declareButtonProp(name);
            }
        };
        /**
         * This is called when one of our dynamically constructed button property getter/setter methods has been called.
         * @param name
         */
        appSettingsMgr.prototype.onButtonChanged = function (name) {
            if (name) {
                this.onDataChanged(name);
            }
            this._app.markIconBarBuildNeeded();
            this.markBigBarBuildNeeded();
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.declareButtonProp = function (name, setterCallback) {
            var funcName = "is" + name + "Enabled";
            var propName = "_" + funcName;
            var body = "if (arguments.length == 0){return this." + propName + ";} this." + propName + " = value;";
            body += "this.onButtonChanged('" + funcName + "');";
            var func = new Function("value", body);
            this[propName] = false;
            this[funcName] = func;
        };
        /** apply default values to all persisted app properties. Note that many of these default values are
        overwritten by the default theme. */
        appSettingsMgr.prototype.resetAppSettings = function () {
            this._isSavingSettingsDisabled = true;
            //---- set initial shape options - must be done early (default = no shape) ----
            this._shapesByChartType = {};
            //---- don't do this automatically (but user can apply it if he wants) ----
            //this.setShapeForChart("Scatter", "*", "circle");
            //---- process properties ----
            var props = this._properties;
            for (var i = 0; i < props.length; i++) {
                var prop = props[i];
                this[prop.name](prop.initialValueForReset);
            }
            //---- CHART tab ----
            this.shapeImage("none");
            this.canvasColor("black");
            this.chartColor("black");
            this.drawingPrimitive("cube"); // "auto");
            this.isContinuousDrawing(false);
            this.isChartPanelOpen(false);
            this.isInstancingEnabled(true);
            this._chartFrameData.padding = { left: 1, top: 1, right: 15, bottom: 1 };
            this.chartFrameOpacity(1);
            //---- ICON BAR tab ----
            this.clearAllButtons();
            //---- the current theme will set these; just use the minimum of "settings" for init purposes ----
            this["_Settings"] = true;
            //---- BIG BAR tab ----
            this._mapByColorChannels = true;
            this._recordAcrossSessions = false;
            this._recordNextSession = false;
            this._isPanelNavRecorded = false;
            this._isSqlEnabled = false;
            this._isAggEnabled = false;
            this._openBotOnStartUp = false;
            this._themeName = "BlacksBeach";
            //---- CHARTS tab ----
            this._isGridEnabled = true;
            this._isColumnEnabled = true;
            this._isScatterEnabled = true;
            this._isDensityEnabled = true;
            this._isStacksEnabled = true;
            this._isScatter3DEnabled = true;
            this._isSquarifyEnabled = false;
            this._isLineEnabled = false;
            this._isRandomEnabled = false;
            this._isPoissonEnabled = false;
            this._isSpiralEnabled = false;
            this._isLinksEnabled = false;
            this._isRadialEnabled = false;
            this._isXbandEnabled = false;
            this._isYbandEnabled = false;
            this._isBarEnabled = false;
            this._isViolinEnabled = false;
            this._isAggColumnEnabled = false;
            this._isCustomEnabled = false;
            //---- ANIMATION tab ----
            var ad = new beachParty.AnimationData();
            this._animationData = ad;
            //---- HOVER tab ----
            this._hoverParams = new beachParty.HoverParams(beachParty.HoverMatch.square, 3);
            this.isTooltipsEnabled(true);
            this.includeNamesInTooltip(true);
            this.hoverOnDetailView(true);
            this.hoverOnMouseMove(false);
            //---- SELECTION tab ----
            this._selectionParams = new beachParty.SelectionParams();
            //---- UI tab ----
            this.menuTextSize(14);
            this.menuValueSize(14);
            this.iconOpacity(1);
            this.isTitleTextVisible(true); //false);
            this.isItemCountsVisible(true); // false);
            //this.axisLabelSize(14);
            //this.legendLabelSize(16);
            //this.titleLabelSize(16);
            //this.axisLabelColor("gray");  // initial value is set by theme
            //this.legendLabelColor("white");
            //this.titleLabelColor("white");
            this.isColPickerSorted(true);
            this.isColDetailsSorted(true);
            this.showCountsInColPicker(false);
            this.showSysColsInColPicker(false);
            this.showTypesInColPicker(true);
            //---- 3D tab ----
            this.is3dGridAlwaysOn(false);
            this.isWheelInertia(true);
            this.showWheelDuringTransformMode(false);
            this.showInProgressUI(false);
            this.isLightingAlwaysOn(false);
            this.ambientLightLevel(.25);
            //---- DATA tab ----
            this._dataCacheParams = new beachParty.DataCacheParams();
            this._dataCacheParams.cacheLocalFiles = true;
            this._dataCacheParams.cacheWebFiles = true;
            this.useNiceNumbers(false);
            this.defaultBins(9);
            this._autoSampling = new beachParty.DataSampling(false);
            //---- INSIGHT tab ----
            this.playbackDuration(3);
            this.isPlaybackLooping(true);
            //---- STARTUP tab ----
            this.rememberLastFile(true);
            this.rememberLastSession(false); // turn OFF until it gets more stable
            this.rememberLastInsights(false);
            this.initialDataParams(this.getDefaultInitFile());
            this.initialChartType("Column");
            //this.initialLayout("Grid");
            this._runTourOnStartUp = true; // not surfaced on tab
            //---- DEBUG tab ----
            this.isShowingDrawStats(false);
            this.isShowingLastCycle(false);
            this.isShowingEventStats(false);
            this.isErrorReportingDisabled(false);
            //---- CHART OPTIONS panel ----
            this.predefinedCustomChart("Squarify");
            this._isSavingSettingsDisabled = false;
        };
        appSettingsMgr.prototype.getDefaultInitFile = function () {
            var wdp = new beachParty.WorkingDataParams("Titanic", null, "known");
            return wdp;
        };
        appSettingsMgr.prototype.saveAppSettings = function () {
            if (!this._isSavingSettingsDisabled && !this._persistChangesDisabledFromUrlParams) {
                var appSettings = new AppSettings(beachParty.appClass.buildId, this._properties);
                //---- ICON BAR buttons ----
                appSettings.enabledIconButtons = this.getEnabledButons(iconButtons);
                //---- BIG BAR buttons ----
                appSettings.enabledBigButtons = this.getEnabledButons(bigButtons);
                //---- process properties ----
                var props = this._properties;
                for (var i = 0; i < props.length; i++) {
                    var prop = props[i];
                    appSettings[prop.name] = this["_" + prop.name];
                }
                appSettings.runTourOnStartUp = this._runTourOnStartUp;
                appSettings.mapByColorChannels = this._mapByColorChannels;
                //appSettings.isScriptsEnabled = this._isScriptsEnabled;
                //appSettings.isThemesEnabled = this._isThemesEnabled;
                appSettings.recordAcrossSessions = this._recordAcrossSessions;
                appSettings.recordNextSession = this._recordNextSession;
                appSettings.isPanelNavRecorded = this._isPanelNavRecorded;
                appSettings.isSqlEnabled = this._isSqlEnabled;
                appSettings.isAggEnabled = this._isAggEnabled;
                appSettings.openBotOnStartUp = this._openBotOnStartUp;
                appSettings.themeName = this._themeName;
                appSettings.shapesByChartType = this._shapesByChartType;
                //---- CHARTS tab----
                appSettings.isGridEnabled = this._isGridEnabled;
                appSettings.isColumnEnabled = this._isColumnEnabled;
                appSettings.isScatterEnabled = this._isScatterEnabled;
                appSettings.isDensityEnabled = this._isDensityEnabled;
                appSettings.isStacksEnabled = this._isStacksEnabled;
                appSettings.isSquarifyEnabled = this._isSquarifyEnabled;
                appSettings.isRandomEnabled = this._isRandomEnabled;
                appSettings.isPoissonEnabled = this._isPoissonEnabled;
                appSettings.isSpiralEnabled = this._isSpiralEnabled;
                appSettings.isLineEnabled = this._isLineEnabled;
                appSettings.isLinksEnabled = this._isLinksEnabled;
                appSettings.isRadialEnabled = this._isRadialEnabled;
                appSettings.isXbandEnabled = this._isXbandEnabled;
                appSettings.isYbandEnabled = this._isYbandEnabled;
                appSettings.isScatter3DEnabled = this._isScatter3DEnabled;
                appSettings.isBarEnabled = this._isBarEnabled;
                appSettings.isViolinEnabled = this._isViolinEnabled;
                appSettings.isAggColumnEnabled = this._isAggColumnEnabled;
                appSettings.isCustomEnabled = this._isCustomEnabled;
                appSettings.isShowingDrawStats = this._isShowingDrawStats;
                appSettings.isShowingLastCycle = this._isShowingLastCycle;
                appSettings.isShowingEventStats = this._isShowingEventStats;
                appSettings.isErrorReportingDisabled = this._isErrorReportingDisabled;
                appSettings.canvasColor = this._canvasColor;
                appSettings.chartColor = this._chartColor;
                //---- startup settings ----
                appSettings.rememberLastFile = this._rememberLastFile;
                appSettings.rememberLastSession = this._rememberLastSession;
                appSettings.rememberLastInsights = this._rememberLastInsights;
                //if (this._rememberLastFile)
                //{
                //    appSettings.lastFileParams = this._app.getCurrentFileParams();
                //}
                appSettings.initialChartType = this._initialChartType;
                appSettings.initialDataParams = this._initialDataParams;
                //---- UI ----
                appSettings.isColPickerSorted = this._isColPickerSorted;
                appSettings.isColDetailsSorted = this._isColDetailsSorted;
                appSettings.showCountsInColPicker = this._showCountsInColPicker;
                appSettings.showSysColsInColPicker = this._showSysColsInColPicker;
                appSettings.showTypesInColPicker = this._showTypesInColPicker;
                appSettings.playbackDuration = this._playbackDuration;
                appSettings.isPlaybackLooping = this._isPlaybackLooping;
                appSettings.isWheelInertia = this._isWheelInertia;
                appSettings.isLightingAlwaysOn = this._isLightingAlwaysOn;
                appSettings.ambientLightLevel = this.ambientLightLevel();
                appSettings.isContinuousDrawing = this._isContinuousDrawing;
                appSettings.isChartPanelOpen = this._isChartPanelOpen;
                appSettings.isInstancingEnabled = this._instancingParams.isInstancingEnabled;
                appSettings.isTooltipsEnabled = this._isTooltipsEnabled;
                appSettings.includeNamesInTooltip = this._includeNamesInTooltip;
                appSettings.hoverOnDetailView = this._hoverOnDetailView;
                appSettings.hoverOnMouseMove = this._hoverOnMouseMove;
                appSettings.is3dGridAlwaysOn = this._is3dGridAlwaysOn;
                appSettings.showWheelDuringTransformMode = this._showWheelDuringTransformMode;
                appSettings.showInProgressUI = this._showInProgressUI;
                appSettings.menuTextSize = this._menuTextSize;
                appSettings.menuValueSize = this._menuValueSize;
                appSettings.iconOpacity = this._iconOpacity;
                appSettings.isTitleTextVisible = this._isTitleTextVisible;
                appSettings.isItemCountsVisible = this._isItemCountsVisible;
                //appSettings.axisLabelSize = this._axisLabelSize;
                //appSettings.legendLabelSize = this._legendLabelSize;
                //appSettings.titleLabelSize = this._titleLabelSize;
                //appSettings.axisLabelColor = this._axisLabelColor;
                //appSettings.legendLabelColor = this._legendLabelColor;
                //appSettings.titleLabelColor = this._titleLabelColor;
                appSettings.predefinedCustomChart = this._predefinedCustomChart;
                appSettings.drawingPrimitive = this.drawingPrimitive();
                appSettings.dataCacheParams = this._dataCacheParams;
                appSettings.useNiceNumbers = this.useNiceNumbers();
                appSettings.hoverParams = this._hoverParams;
                appSettings.selectionParams = this._selectionParams;
                appSettings.defaultBins = this.defaultBins();
                appSettings.autoSampling = this._autoSampling;
                appSettings.animationData = this._animationData;
                appSettings.chartFrameData = this._chartFrameData;
                var str = JSON.stringify(appSettings);
                beachParty.localStorageMgr.save(beachParty.StorageType.appSettings, null, null, str);
            }
        };
        appSettingsMgr.prototype.saveSessionToLocalStorage = function () {
            var undoMgr = this._app._undoMgr;
            var preload = undoMgr.getCurrentInsight();
            if (preload) {
                preload.name = "$lastSession";
                var strPreload = JSON.stringify(preload);
                beachParty.localStorageMgr.save(beachParty.StorageType.sessionShare, beachParty.StorageSubType.lastSessionState, null, strPreload);
            }
        };
        appSettingsMgr.prototype.loadSettingUndef = function (appSettings, name) {
            var setting = appSettings[name];
            if (setting !== undefined) {
                this[name](setting);
            }
        };
        appSettingsMgr.prototype.loadSettingGetter = function (appSettings, name) {
            var setting = appSettings[name];
            if (setting !== undefined && setting != this[name]()) {
                this[name](setting);
            }
        };
        appSettingsMgr.prototype.loadSettingDirect = function (appSettings, name) {
            var setting = appSettings[name];
            if (setting !== undefined && setting != this["_" + name]) {
                this[name](setting);
            }
        };
        appSettingsMgr.prototype.getAppSettingsObj = function () {
            var str = beachParty.localStorageMgr.get(beachParty.StorageType.appSettings, null, null);
            if (str) {
                try {
                    var appSettings = JSON.parse(str);
                    //---- if version number is wrong, reset all info ----
                    if (appSettings.versionNum != beachParty.appClass.buildId) {
                        appSettings = null;
                        this._app.deleteLocalStorageInfo(true);
                    }
                }
                catch (ex) {
                    appSettings = null;
                }
            }
            return appSettings;
        };
        appSettingsMgr.prototype.loadAppSettings = function () {
            var appSettings = this.getAppSettingsObj();
            if (!appSettings) {
                //---- first run (or first after reset) - just apply the default theme ----
                var themeName = (this._initialTheme) ? this._initialTheme : this._themeName;
                var themeMgr = this._app._themeMgr;
                themeMgr.onThemeChanged(themeName, true);
            }
            else {
                this._isSavingSettingsDisabled = true;
                try {
                    this.loadAppSettingsFromObj(appSettings);
                    if (this._initialTheme) {
                        //---- cmd line theme load - make sure to overwrite app settings for common properties ----
                        this.themeName(this._initialTheme, true);
                    }
                    else {
                        //---- normal load of previously specified theme ----
                        this.themeName(appSettings.themeName);
                    }
                }
                finally {
                    this._isSavingSettingsDisabled = false;
                }
            }
        };
        appSettingsMgr.prototype.loadAppSettingsFromObj = function (appSettings) {
            var both = appSettings.enabledIconButtons.concat(appSettings.enabledBigButtons);
            this.applyButtonProps(both);
            //---- process properties ----
            var props = this._properties;
            for (var i = 0; i < props.length; i++) {
                var prop = props[i];
                this.loadSettingDirect(appSettings, prop.name);
            }
            //---- FEATURES TAB ----
            this.loadSettingDirect(appSettings, "runTourOnStartUp");
            this.loadSettingDirect(appSettings, "mapByColorChannels");
            this.loadSettingDirect(appSettings, "recordAcrossSessions");
            this.loadSettingDirect(appSettings, "recordNextSession");
            this.loadSettingDirect(appSettings, "isPanelNavRecorded");
            this.loadSettingDirect(appSettings, "isSqlEnabled");
            this.loadSettingDirect(appSettings, "isAggEnabled");
            //---- CHARTS tab ----
            this.loadSettingDirect(appSettings, "isGridEnabled");
            this.loadSettingDirect(appSettings, "isColumnEnabled");
            this.loadSettingDirect(appSettings, "isScatterEnabled");
            this.loadSettingDirect(appSettings, "isDensityEnabled");
            this.loadSettingDirect(appSettings, "isStacksEnabled");
            this.loadSettingDirect(appSettings, "isSquarifyEnabled");
            this.loadSettingDirect(appSettings, "isRandomEnabled");
            this.loadSettingDirect(appSettings, "isPoissonEnabled");
            this.loadSettingDirect(appSettings, "isSpiralEnabled");
            this.loadSettingDirect(appSettings, "isLineEnabled");
            this.loadSettingDirect(appSettings, "isLinksEnabled");
            this.loadSettingDirect(appSettings, "isRadialEnabled");
            this.loadSettingDirect(appSettings, "isXbandEnabled");
            this.loadSettingDirect(appSettings, "isYbandEnabled");
            this.loadSettingDirect(appSettings, "isScatter3DEnabled");
            this.loadSettingDirect(appSettings, "isBarEnabled");
            this.loadSettingDirect(appSettings, "isViolinEnabled");
            this.loadSettingDirect(appSettings, "isAggColumnEnabled");
            this.loadSettingDirect(appSettings, "isCustomEnabled");
            //---- animation properties ----
            this.loadSettingDirect(appSettings, "animationData");
            this.loadSettingDirect(appSettings, "isShowingDrawStats");
            this.loadSettingDirect(appSettings, "isShowingLastCycle");
            this.loadSettingDirect(appSettings, "isShowingEventStats");
            this.loadSettingDirect(appSettings, "isErrorReportingDisabled");
            this.loadSettingDirect(appSettings, "canvasColor");
            this.loadSettingDirect(appSettings, "chartColor");
            this.loadSettingDirect(appSettings, "isColPickerSorted");
            this.loadSettingDirect(appSettings, "isColDetailsSorted");
            this.loadSettingDirect(appSettings, "showCountsInColPicker");
            this.loadSettingDirect(appSettings, "showSysColsInColPicker");
            this.loadSettingDirect(appSettings, "showTypesInColPicker");
            this.loadSettingDirect(appSettings, "playbackDuration");
            this.loadSettingDirect(appSettings, "isPlaybackLooping");
            this.loadSettingDirect(appSettings, "rememberLastFile");
            this.loadSettingDirect(appSettings, "rememberLastSession");
            this.loadSettingDirect(appSettings, "rememberLastInsights");
            this.loadSettingDirect(appSettings, "cacheLocalFiles");
            this.loadSettingDirect(appSettings, "cacheWebFiles");
            this.loadSettingDirect(appSettings, "initialChartType");
            this.loadSettingDirect(appSettings, "initialDataParams");
            this.loadSettingDirect(appSettings, "isWheelInertia");
            this.loadSettingDirect(appSettings, "isLightingAlwaysOn");
            this.loadSettingDirect(appSettings, "ambientLightLevel");
            this.loadSettingDirect(appSettings, "isContinuousDrawing");
            this.loadSettingDirect(appSettings, "isChartPanelOpen");
            this.loadSettingDirect(appSettings, "isInstancingEnabled");
            this.loadSettingDirect(appSettings, "showWheelDuringTransformMode");
            this.loadSettingDirect(appSettings, "showInProgressUI");
            this.loadSettingDirect(appSettings, "drawingPrimitive");
            this.loadSettingDirect(appSettings, "isTitleTextVisible");
            this.loadSettingDirect(appSettings, "isItemCountsVisible");
            this.loadSettingDirect(appSettings, "menuTextSize");
            this.loadSettingDirect(appSettings, "menuValueSize");
            this.loadSettingDirect(appSettings, "iconOpacity");
            this.loadSettingDirect(appSettings, "predefinedCustomChart");
            this.loadSettingDirect(appSettings, "isTooltipsEnabled");
            this.loadSettingDirect(appSettings, "includeNamesInTooltip");
            this.loadSettingDirect(appSettings, "hoverOnDetailView");
            this.loadSettingDirect(appSettings, "hoverOnMouseMove");
            this.loadSettingDirect(appSettings, "is3dGridAlwaysOn");
            this.loadSettingDirect(appSettings, "shapesByChartType");
            this.loadSettingDirect(appSettings, "shapeImage");
            this.loadSettingDirect(appSettings, "defaultBins");
            this.loadSettingDirect(appSettings, "autoSampling");
            this.loadSettingDirect(appSettings, "useNiceNumbers");
            this.loadSettingDirect(appSettings, "openBotOnStartUp");
            //---- PARAM loading ----
            if (appSettings.hoverParams !== undefined && appSettings.hoverParams != this._hoverParams) {
                this._hoverParams = appSettings.hoverParams;
                this.onHoverParamsChanged();
            }
            if (appSettings.selectionParams !== undefined && appSettings.selectionParams != this._selectionParams) {
                this._selectionParams = appSettings.selectionParams;
                this.onSelectionParamsChanged();
            }
            if (appSettings.animationData) {
                this._animationData = appSettings.animationData;
                this.onAnimationDataChanged();
            }
            if (appSettings.chartFrameData) {
                this._chartFrameData = appSettings.chartFrameData;
                this.onChartFrameDataChanged();
            }
        };
        appSettingsMgr.prototype.setAllChartsProperty = function (propName, value) {
            this._app.setAllChartsProperty(propName, value);
        };
        appSettingsMgr.prototype.onShapeColorChanged = function (value) {
            this.setAllChartsProperty("shapeColor", value);
        };
        appSettingsMgr.prototype.shapeImage = function (value) {
            if (arguments.length === 0) {
                return this._shapeImage;
            }
            if (value != this._shapeImage) {
                this._shapeImage = value;
                this.setAllChartsProperty("shapeImage", value);
                this.onDataChanged("shapeImage");
                this.setShapeForChart(this._chartRouter.chartName(), this._chartRouter.getLayoutName(), value);
                this.saveAppSettings();
            }
        };
        appSettingsMgr.prototype.chartColor = function (value) {
            if (arguments.length === 0) {
                return this._chartColor;
            }
            this._chartColor = value;
            this.setAllChartsProperty("chartColor", value);
            this.onChartColorChanged();
        };
        appSettingsMgr.prototype.onChartColorChanged = function () {
            this.saveAppSettings();
            this.onDataChanged("chartColor");
        };
        appSettingsMgr.prototype.canvasColor = function (value) {
            if (arguments.length === 0) {
                return this._canvasColor;
            }
            this._canvasColor = value;
            this.setAllChartsProperty("canvasColor", value);
            this.onCanvasColorChanged();
        };
        appSettingsMgr.prototype.onCanvasColorChanged = function () {
            this.saveAppSettings();
            this.onDataChanged("canvasColor");
        };
        appSettingsMgr.prototype.drawingPrimitive = function (value) {
            if (arguments.length === 0) {
                return beachParty.DrawPrimitive[this._drawingPrimitive];
            }
            var dpValue = beachParty.DrawPrimitive[value];
            if (dpValue != this._drawingPrimitive) {
                this._drawingPrimitive = dpValue;
                this.setAllChartsProperty("drawingPrimitive", value);
                this.saveAppSettings();
                this.onDataChanged("drawingPrimitive");
            }
        };
        appSettingsMgr.prototype.isContinuousDrawing = function (value) {
            if (arguments.length == 0) {
                return this._isContinuousDrawing;
            }
            this._isContinuousDrawing = value;
            this.setAllChartsProperty("isContinuousDrawing", value);
            this.onDataChanged("isContinuousDrawing");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isChartPanelOpen = function (value) {
            if (arguments.length == 0) {
                return this._isChartPanelOpen;
            }
            this._isChartPanelOpen = value;
            this.onDataChanged("isChartPanelOpen");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.showSysColsInColPicker = function (value) {
            if (arguments.length == 0) {
                return this._showSysColsInColPicker;
            }
            this._showSysColsInColPicker = value;
            this.onDataChanged("showSysColsInColPicker");
            this.saveAppSettings();
            this.rebuildOpenPickers();
        };
        appSettingsMgr.prototype.showCountsInColPicker = function (value) {
            if (arguments.length == 0) {
                return this._showCountsInColPicker;
            }
            this._showCountsInColPicker = value;
            this.onDataChanged("showCountsInColPicker");
            this.saveAppSettings();
            this.rebuildOpenPickers();
        };
        appSettingsMgr.prototype.showTypesInColPicker = function (value) {
            if (arguments.length == 0) {
                return this._showTypesInColPicker;
            }
            this._showTypesInColPicker = value;
            this.onDataChanged("showTypesInColPicker");
            this.saveAppSettings();
            this.rebuildOpenPickers();
        };
        appSettingsMgr.prototype.mapByColorChannels = function (value) {
            if (arguments.length == 0) {
                return this._mapByColorChannels;
            }
            this._mapByColorChannels = value;
            this.setAllChartsProperty("mapByColorChannels", value);
            this.onDataChanged("mapByColorChannels");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.recordAcrossSessions = function (value) {
            if (arguments.length == 0) {
                return this._recordAcrossSessions;
            }
            this._recordAcrossSessions = value;
            this.onDataChanged("recordAcrossSessions");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.recordNextSession = function (value) {
            if (arguments.length == 0) {
                return this._recordNextSession;
            }
            this._recordNextSession = value;
            this.onDataChanged("recordNextSession");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isPanelNavRecorded = function (value) {
            if (arguments.length == 0) {
                return this._isPanelNavRecorded;
            }
            this._isPanelNavRecorded = value;
            this.onDataChanged("isPanelNavRecorded");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isSqlEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isSqlEnabled;
            }
            this._isSqlEnabled = value;
            this.onDataChanged("isSqlEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isAggEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isAggEnabled;
            }
            this._isAggEnabled = value;
            this.onDataChanged("isAggEnabled");
            this._app.markIconBarBuildNeeded();
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.openBotOnStartUp = function (value) {
            if (arguments.length == 0) {
                return this._openBotOnStartUp;
            }
            this._openBotOnStartUp = value;
            this.onDataChanged("openBotOnStartUp");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.themeName = function (value, overwriteAppSettings) {
            if (arguments.length == 0) {
                return this._themeName;
            }
            this._themeName = value;
            this.onDataChanged("themeName");
            var themeMgr = this._app._themeMgr;
            themeMgr.onThemeChanged(value, overwriteAppSettings);
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.shapesByChartType = function (value) {
            if (arguments.length == 0) {
                return this._shapesByChartType;
            }
            this._shapesByChartType = value;
            this.onDataChanged("shapesByChartType");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.markBigBarBuildNeeded = function () {
            var bigBarMgr = this._app._bigBarMgr;
            if (bigBarMgr) {
                bigBarMgr.buildBigBar();
            }
            this._app.onBigBarChanged();
        };
        appSettingsMgr.prototype.markIconBarBuildNeeded = function () {
            var iconBarMgr = this._app._iconBarMgr;
            if (iconBarMgr) {
                iconBarMgr.buildIconBar();
            }
        };
        appSettingsMgr.prototype.runTourOnStartUp = function (value) {
            if (arguments.length == 0) {
                return this._runTourOnStartUp;
            }
            this._runTourOnStartUp = value;
            this.onDataChanged("runTourOnStartUp");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isGridEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isGridEnabled;
            }
            this._isGridEnabled = value;
            this.onDataChanged("isGridEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isColumnEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isColumnEnabled;
            }
            this._isColumnEnabled = value;
            this.onDataChanged("isColumnEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isScatterEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isScatterEnabled;
            }
            this._isScatterEnabled = value;
            this.onDataChanged("isScatterEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isDensityEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isDensityEnabled;
            }
            this._isDensityEnabled = value;
            this.onDataChanged("isDensityEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isStacksEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isStacksEnabled;
            }
            this._isStacksEnabled = value;
            this.onDataChanged("isStacksEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isSquarifyEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isSquarifyEnabled;
            }
            this._isSquarifyEnabled = value;
            this.onDataChanged("isSquarifyEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isRandomEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isRandomEnabled;
            }
            this._isRandomEnabled = value;
            this.onDataChanged("isRandomEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isPoissonEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isPoissonEnabled;
            }
            this._isPoissonEnabled = value;
            this.onDataChanged("isPoissonEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isSpiralEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isSpiralEnabled;
            }
            this._isSpiralEnabled = value;
            this.onDataChanged("isSpiralEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isLineEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isLineEnabled;
            }
            this._isLineEnabled = value;
            this.onDataChanged("isLineEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isLinksEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isLinksEnabled;
            }
            this._isLinksEnabled = value;
            this.onDataChanged("isLinksEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isRadialEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isRadialEnabled;
            }
            this._isRadialEnabled = value;
            this.onDataChanged("isRadialEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isXbandEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isXbandEnabled;
            }
            this._isXbandEnabled = value;
            this.onDataChanged("isXbandEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isYbandEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isYbandEnabled;
            }
            this._isYbandEnabled = value;
            this.onDataChanged("isYbandEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isScatter3DEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isScatter3DEnabled;
            }
            this._isScatter3DEnabled = value;
            this.onDataChanged("isScatter3DEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isBarEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isBarEnabled;
            }
            this._isBarEnabled = value;
            this.onDataChanged("isBarEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isViolinEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isViolinEnabled;
            }
            this._isViolinEnabled = value;
            this.onDataChanged("isViolinEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isCustomEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isCustomEnabled;
            }
            this._isCustomEnabled = value;
            this.onDataChanged("isCustomEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isAggColumnEnabled = function (value) {
            if (arguments.length == 0) {
                return this._isAggColumnEnabled;
            }
            this._isAggColumnEnabled = value;
            this.onDataChanged("isAggColumnEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isInstancingEnabled = function (value) {
            if (arguments.length == 0) {
                return this._instancingParams.isInstancingEnabled;
            }
            this._instancingParams.isInstancingEnabled = value;
            this.setAllChartsProperty("isInstancingEnabled", value);
            this.onDataChanged("isInstancingEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.chartFrameOpacity = function (value) {
            if (arguments.length === 0) {
                return this._chartFrameData.opacity;
            }
            this._chartFrameData.opacity = value;
            this.setAllChartsProperty("chartFrameOpacity", value);
            this.onDataChanged("chartFrameOpacity");
            this.onChartFrameDataChanged();
        };
        appSettingsMgr.prototype.onChartFrameDataChanged = function () {
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.animationData = function (value) {
            if (arguments.length == 0) {
                return this._animationData;
            }
            this._animationData = value;
            this.setAllChartsProperty("animationData", value);
        };
        appSettingsMgr.prototype.getChartFrameData = function () {
            return this._chartFrameData;
        };
        appSettingsMgr.prototype.getHoverParams = function () {
            return this._hoverParams;
        };
        appSettingsMgr.prototype.getSelectionParams = function () {
            return this._selectionParams;
        };
        appSettingsMgr.prototype.getInstancingParams = function () {
            return this._instancingParams;
        };
        appSettingsMgr.prototype.isAnimationEnabled = function (value) {
            if (arguments.length === 0) {
                return this._animationData.isAnimationEnabled;
            }
            this._animationData.isAnimationEnabled = value;
            this.setAllChartsProperty("isAnimationEnabled", value);
            this.onAnimationDataChanged();
            this.onDataChanged("isAnimationEnabled");
        };
        appSettingsMgr.prototype.isStaggeringEnabled = function (value) {
            if (arguments.length === 0) {
                return this._animationData.isStaggeringEnabled;
            }
            this._animationData.isStaggeringEnabled = value;
            this.setAllChartsProperty("isStaggeringEnabled", value);
            this.onAnimationDataChanged();
            this.onDataChanged("isStaggeringEnabled");
        };
        appSettingsMgr.prototype.easeFunction = function (value) {
            if (arguments.length == 0) {
                return beachParty.EaseFunction[this._animationData.easeFunction];
            }
            this._animationData.easeFunction = beachParty.EaseFunction[value];
            this.setAllChartsProperty("easeFunction", value);
            this.onAnimationDataChanged();
            this.onDataChanged("easeFunction");
        };
        appSettingsMgr.prototype.easeType = function (value) {
            if (arguments.length == 0) {
                return beachParty.EaseType[this._animationData.easeType];
            }
            this._animationData.easeType = beachParty.EaseType[value];
            this.setAllChartsProperty("easeType", value);
            this.onAnimationDataChanged();
            this.onDataChanged("easeType");
        };
        appSettingsMgr.prototype.animationDuration = function (value) {
            if (arguments.length === 0) {
                return this._animationData.animationDuration;
            }
            this._animationData.animationDuration = value;
            this.setAllChartsProperty("animationDuration", value);
            this.onAnimationDataChanged();
            this.onDataChanged("animationDuration");
        };
        appSettingsMgr.prototype.maxStaggerTime = function (value) {
            if (arguments.length === 0) {
                return this._animationData.maxStaggerTime;
            }
            this._animationData.maxStaggerTime = value;
            this.setAllChartsProperty("maxStaggerTime", value);
            this.onAnimationDataChanged();
            this.onDataChanged("maxStaggerTime");
        };
        appSettingsMgr.prototype.onAnimationDataChanged = function () {
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.hoverMatch = function (value) {
            if (arguments.length == 0) {
                return beachParty.HoverMatch[this._hoverParams.hoverMatch];
            }
            this._hoverParams.hoverMatch = beachParty.HoverMatch[value];
            this.setAllChartsProperty("hoverMatch", value);
            this.onDataChanged("hoverMatch");
            this.onHoverParamsChanged();
        };
        appSettingsMgr.prototype.hoverEffect = function (value) {
            if (arguments.length == 0) {
                return beachParty.HoverEffect[this._hoverParams.hoverEffect];
            }
            this._hoverParams.hoverEffect = beachParty.HoverEffect[value];
            this.setAllChartsProperty("hoverEffect", value);
            this.onDataChanged("hoverEffect");
            this.onHoverParamsChanged();
        };
        appSettingsMgr.prototype.hoverColor = function (value) {
            if (arguments.length == 0) {
                return this._hoverParams.hoverColor;
            }
            this._hoverParams.hoverColor = value;
            this.setAllChartsProperty("hoverColor", value);
            this.onDataChanged("hoverColor");
            this.onHoverParamsChanged();
        };
        appSettingsMgr.prototype.hoverSize = function (value) {
            if (arguments.length == 0) {
                return this._hoverParams.squareSize;
            }
            this._hoverParams.squareSize = value;
            this.setAllChartsProperty("hoverSize", value);
            this.onDataChanged("hoverSize");
            this.onHoverParamsChanged();
        };
        appSettingsMgr.prototype.onHoverParamsChanged = function () {
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.predefinedCustomChart = function (value) {
            if (arguments.length == 0) {
                return this._predefinedCustomChart;
            }
            var layoutType = beachParty.LayoutType.Default;
            var chartType = beachParty.chartClass.getChartTypeFromName(value, layoutType);
            this._predefinedCustomChart = value;
            if (this._app._chartIsLoaded) {
                this._chartRouter.changeToChart(chartType, layoutType, beachParty.Gesture.click, null, true);
            }
            this.onDataChanged("predefinedCustomChart");
        };
        appSettingsMgr.prototype.isTooltipsEnabled = function (value) {
            if (arguments.length == 0) {
                var enabled = (this._isTooltipsEnabled && !this._chartRouter.isEngineDrawing());
                return enabled;
            }
            this._isTooltipsEnabled = value;
            this.setAllChartsProperty("isTooltipsEnabled", value);
            this.onDataChanged("isTooltipsEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.includeNamesInTooltip = function (value) {
            if (arguments.length == 0) {
                return this._includeNamesInTooltip;
            }
            this._includeNamesInTooltip = value;
            this.setAllChartsProperty("includeNamesInTooltip", value);
            this.onDataChanged("includeNamesInTooltip");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.hoverOnDetailView = function (value) {
            if (arguments.length == 0) {
                return this._hoverOnDetailView;
            }
            this._hoverOnDetailView = value;
            this.setAllChartsProperty("hoverOnDetailView", value);
            this.onDataChanged("hoverOnDetailView");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.hoverOnMouseMove = function (value) {
            if (arguments.length == 0) {
                return this._hoverOnMouseMove;
            }
            this._hoverOnMouseMove = value;
            this.setAllChartsProperty("hoverOnMouseMove", value);
            this.onDataChanged("hoverOnMouseMove");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.selectedColorEffect = function (value) {
            if (arguments.length == 0) {
                return beachParty.ColorEffect[this._selectionParams.selectedParams.colorEffect];
            }
            this._selectionParams.selectedParams.colorEffect = beachParty.ColorEffect[value];
            this.setAllChartsProperty("selectedColorEffect", value);
            this.onDataChanged("selectedColorEffect");
            this.onSelectionParamsChanged();
        };
        appSettingsMgr.prototype.unselectedColorEffect = function (value) {
            if (arguments.length == 0) {
                return beachParty.ColorEffect[this._selectionParams.unselectedParams.colorEffect];
            }
            this._selectionParams.unselectedParams.colorEffect = beachParty.ColorEffect[value];
            this.setAllChartsProperty("unselectedColorEffect", value);
            this.onDataChanged("unselectedColorEffect");
            this.onSelectionParamsChanged();
        };
        appSettingsMgr.prototype.selectedColor = function (value) {
            if (arguments.length == 0) {
                return this._selectionParams.selectedParams.color;
            }
            this._selectionParams.selectedParams.color = value;
            this.setAllChartsProperty("selectedColor", value);
            this.onDataChanged("selectedColor");
            this.onSelectionParamsChanged();
        };
        appSettingsMgr.prototype.unselectedColor = function (value) {
            if (arguments.length == 0) {
                return this._selectionParams.unselectedParams.color;
            }
            this._selectionParams.unselectedParams.color = value;
            this.setAllChartsProperty("unselectedColor", value);
            this.onDataChanged("unselectedColor");
            this.onSelectionParamsChanged();
        };
        appSettingsMgr.prototype.selectedColorFactor = function (value) {
            if (arguments.length == 0) {
                return this._selectionParams.selectedParams.colorFactor;
            }
            this._selectionParams.selectedParams.colorFactor = value;
            this.setAllChartsProperty("selectedColorFactor", value);
            this.onDataChanged("selectedColorFactor");
            this.onSelectionParamsChanged();
        };
        appSettingsMgr.prototype.unselectedColorFactor = function (value) {
            if (arguments.length == 0) {
                return this._selectionParams.unselectedParams.colorFactor;
            }
            this._selectionParams.unselectedParams.colorFactor = value;
            this.setAllChartsProperty("unselectedColorFactor", value);
            this.onDataChanged("unselectedColorFactor");
            this.onSelectionParamsChanged();
        };
        appSettingsMgr.prototype.onSelectionParamsChanged = function () {
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.onAppBgColorChanged = function (value) {
            this._appStyleSheet.addRule(".appBody", "background: " + value + " !important");
            //this._appStyleSheet.addRule(".panelText", "background: " + value + " !important");
            //this._appStyleSheet.addRule(".panelTextArea", "background: " + value + " !important");
            //this._appStyleSheet.addRule(".deskText", "background: " + value + " !important");
            this._appStyleSheet.addRule(".sliderAssembly", "background: " + value); // + " !important");
            this._appStyleSheet.addRule(".deskText::selection", "color: " + value + " !important");
            this._appStyleSheet.addRule(".panelText::selection", "color: " + value + " !important");
            this._appStyleSheet.addRule(".panelTextArea::selection", "color: " + value + " !important");
        };
        appSettingsMgr.prototype.onAppTextSizeChanged = function (value) {
            this._appStyleSheet.addRule(".appBody", "font-size: " + value + "px !important");
            this._appStyleSheet.addRule("input", "font-size: " + value + "px !important");
            this._appStyleSheet.addRule("textarea", "font-size: " + value + "px !important");
            this._appStyleSheet.addRule(".buttonText", "font-size: " + value + "px !important");
            this.resizeNumAdjustersToNewFont();
        };
        appSettingsMgr.prototype.resizeNumAdjustersToNewFont = function () {
            vp.select(".numAdjusterText").each(function (index, elem) {
                var numAdjustSlider = elem._numAdjustSliderInst;
                numAdjustSlider.setWidthForFont();
            });
        };
        appSettingsMgr.prototype.onAppTextColorChanged = function (value) {
            this._appStyleSheet.addRule(".appBody", "color: " + value + " !important");
            this._appStyleSheet.addRule(".tabButtonOpen", "color: " + value + " !important");
            this._appStyleSheet.addRule("input", "color: " + value + " !important");
            this._appStyleSheet.addRule("textarea", "color: " + value + " !important");
        };
        appSettingsMgr.prototype.onPanelBgColorChanged = function (value) {
            this._appStyleSheet.addRule(".undockedPanel", "background: " + value + " !important");
            this._appStyleSheet.addRule(".infoMsgBox", "background: " + value + " !important");
        };
        appSettingsMgr.prototype.onDockedBgColorChanged = function (value) {
            this._appStyleSheet.addRule(".dockedPanel", "background: " + value + " !important");
        };
        appSettingsMgr.prototype.onSelectedBgColorChanged = function (value) {
            this._appStyleSheet.addRule("*[data-selected=true]", "background: " + value + " !important");
        };
        appSettingsMgr.prototype.onHoverBgColorChanged = function (value) {
            this._appStyleSheet.addRule(".panelButton:hover", "background: " + value + " !important");
            this._appStyleSheet.addRule(".iconButton:hover", "background: " + value); // + " !important");
            this._appStyleSheet.addRule(".bigButton:hover", "background: " + value + " !important");
            this._appStyleSheet.addRule(".bigButton:hover", "background: " + value + " !important");
            this._appStyleSheet.addRule(".clickIcon:hover", "background: " + value + " !important");
            this._appStyleSheet.addRule(".chartTitleText:hover", "background: " + value + " !important");
            this._appStyleSheet.addRule(".popupMenuItemHolder:hover", "background: " + value + " !important");
            this._appStyleSheet.addRule(".chartPickerEntry:hover", "background: " + value + " !important");
            this._appStyleSheet.addRule(".checkboxAssembly:hover", "background: " + value + " !important");
            this._appStyleSheet.addRule(".radioAssembly:hover", "background: " + value + " !important");
            //this._appStyleSheet.addRule(".panelText:hover", "background: " + value + " !important");
            //this._appStyleSheet.addRule(".panelText:focus", "background: " + value + " !important");
            this._appStyleSheet.addRule(".panelTextArea:hover", "background: " + value + " !important");
            this._appStyleSheet.addRule(".panelTextArea:focus", "background: " + value + " !important");
            this._appStyleSheet.addRule(".vpxAxisTickBox:hover", "fill: " + value + " !important");
            this._appStyleSheet.addRule(".panelInnerProgressBar", "background: " + value + " !important");
        };
        appSettingsMgr.prototype.onPanelBorderColorChanged = function (value) {
            this._appStyleSheet.addRule(".panel", "border-color: " + value + " !important");
            this._appStyleSheet.addRule(".popupMenu", "border-color: " + value + " !important");
            this._appStyleSheet.addRule(".infoMsgBox", "border-color: " + value + " !important");
        };
        appSettingsMgr.prototype.onPanelOpacityChanged = function (value) {
            this._appStyleSheet.addRule(".panel", "opacity: " + value + "");
        };
        appSettingsMgr.prototype.onGuideTextSizeChanged = function (value) {
            this._appStyleSheet.addRule(".vpxAxisLabel", "font-size: " + value + "px");
            this._appStyleSheet.addRule(".titlePanel", "font-size: " + value + "px !important");
            this._appStyleSheet.addRule(".legendLabel", "font-size: " + value + "px");
            this._appStyleSheet.addRule(".legendTitle", "font-size: " + value + "px");
        };
        appSettingsMgr.prototype.onTitleTextSizeChanged = function (value) {
            this._appStyleSheet.addRule(".chartTitleText", "font-size: " + value + "px !important");
        };
        appSettingsMgr.prototype.onButtonTextColorChanged = function (value) {
            this._appStyleSheet.addRule(".buttonText", "color: " + value + " !important");
            this._appStyleSheet.addRule(".tabButton", "color: " + value); // + " !important");
            this._appStyleSheet.addRule(".circleSliderTrack", "background: " + value + " !important");
        };
        appSettingsMgr.prototype.onGuideTextColorChanged = function (value) {
            this._appStyleSheet.addRule(".vpxAxisLabel", "fill: " + value + " !important");
            this._appStyleSheet.addRule(".titlePanel", "color: " + value + " !important");
            this._appStyleSheet.addRule(".legendLabel", "color: " + value + " !important");
            this._appStyleSheet.addRule(".legendTitle", "color: " + value + " !important");
        };
        appSettingsMgr.prototype.onValueTextColorChanged = function (value) {
            this._appStyleSheet.addRule(".buttonValue", "color: " + value + " !important");
            this._appStyleSheet.addRule(".tabButtonOpen", "border-color: " + value + " !important");
            this._appStyleSheet.addRule(".deskText::selection", "background: " + value + " !important");
            this._appStyleSheet.addRule(".panelText::selection", "background: " + value + " !important");
            this._appStyleSheet.addRule(".panelTextArea::selection", "background: " + value + " !important");
        };
        appSettingsMgr.prototype.onPromptTextColorChanged = function (value) {
            this._appStyleSheet.addRule(".buttonPrompt", "color: " + value + " !important");
        };
        appSettingsMgr.prototype.onGuideBorderColorChanged = function (value) {
            this._appStyleSheet.addRule(".vpxAxisTick", "stroke: " + value + " !important");
            this._appStyleSheet.addRule(".vpxAxisTickBox", "stroke: " + value + " !important");
            this._appStyleSheet.addRule(".legendTick", "border-top-color: " + value + " !important");
        };
        appSettingsMgr.prototype.onBarBorderColorChanged = function (value) {
            this._appStyleSheet.addRule(".bigBar", "border-color: " + value + " !important");
            this._appStyleSheet.addRule(".insightPanel", "border-color: " + value + " !important");
        };
        appSettingsMgr.prototype.onDockedBorderColorChanged = function (value) {
            this._appStyleSheet.addRule(".dockedPanel", "border-color: " + value + " !important");
        };
        appSettingsMgr.prototype.onBarBgColorChanged = function (value) {
            this._appStyleSheet.addRule(".bigBar", "background: " + value + " !important");
            this._appStyleSheet.addRule(".insightPanel", "background: " + value + " !important");
        };
        appSettingsMgr.prototype.onListBorderColorChanged = function (value) {
            this._appStyleSheet.addRule(".popupMenuItem", "border-bottom-color: " + value + " !important");
        };
        appSettingsMgr.prototype.onAppBorderColorChanged = function (value) {
            this._appStyleSheet.addRule(".colorSampleButton", "border-color: " + value + " !important");
            this._appStyleSheet.addRule(".colorPalette", "border-color: " + value + " !important");
        };
        appSettingsMgr.prototype.onButtonBorderColorChanged = function (value) {
            this._appStyleSheet.addRule(".iconButton", "border-color: " + value + " !important");
            this._appStyleSheet.addRule(".bigBarSpacer", "border-color: " + value + " !important");
            this._appStyleSheet.addRule(".bigButton", "border-color: " + value + " !important");
            this._appStyleSheet.addRule(".iconBarSpacer", "background: " + value + " !important");
            this._appStyleSheet.addRule(".deskText", "border-color: " + value + " !important");
            this._appStyleSheet.addRule(".sliderAssembly", "border-color: " + value + " !important");
            this._appStyleSheet.addRule(".panelProgressBar", "border-color: " + value + " !important");
            this._appStyleSheet.addRule(".popupMenuHR", "background: " + value + " !important");
            this._appStyleSheet.addRule(".tabButtonContainer", "border-bottom-color: " + value + " !important");
        };
        appSettingsMgr.prototype.onBigBarOpenColorChanged = function (value) {
            this._appStyleSheet.addRule(".bigButton[data-selected=true]", "background: " + value + " !important");
        };
        appSettingsMgr.prototype.onNormalFontFamilyChanged = function (value) {
            this._appStyleSheet.addRule(".appBody", "font-family: " + value + " !important");
            this._appStyleSheet.addRule(".vpxAxisLabel", "font-family: " + value + " !important");
            this._appStyleSheet.addRule("input", "font-family: " + value + " !important");
            this._appStyleSheet.addRule("textarea", "font-family: " + value + " !important");
            this.resizeNumAdjustersToNewFont();
        };
        appSettingsMgr.prototype.onLogoHiddenChanged = function (value) {
            var elemW = vp.select("#btLogo");
            if (value) {
                elemW.css("display", "none");
            }
            else {
                elemW.css("display", "");
                beachParty.chartUtils.fadeIn(elemW[0]);
            }
        };
        appSettingsMgr.prototype.onPromptWeightChanged = function (value) {
            this._appStyleSheet.addRule(".buttonPrompt", "font-weight: " + value + " !important");
        };
        appSettingsMgr.prototype.onValueWeightChanged = function (value) {
            this._appStyleSheet.addRule(".buttonValue", "font-weight: " + value + " !important");
        };
        appSettingsMgr.prototype.onSelectedTabWeightChanged = function (value) {
            this._appStyleSheet.addRule(".tabButtonOpen", "font-weight: " + value + " !important");
        };
        appSettingsMgr.prototype.onTitlePaneWeightChanged = function (value) {
            this._appStyleSheet.addRule(".titlePanel", "font-weight: " + value + " !important");
        };
        appSettingsMgr.prototype.onTipNameWeightChanged = function (value) {
            this._appStyleSheet.addRule(".dataTipTitle", "font-weight: " + value + " !important");
            this._appStyleSheet.addRule(".dataTipName", "font-weight: " + value + " !important");
            this._appStyleSheet.addRule(".toolTipName", "font-weight: " + value + " !important");
        };
        appSettingsMgr.prototype.onTableHeaderWeightChanged = function (value) {
            this._appStyleSheet.addRule(".colHdr", "font-weight: " + value + " !important");
        };
        appSettingsMgr.prototype.onBigBarNextToLogoChanged = function (value) {
            var bigBar = vp.select("#bigBarTop")[0];
            var iconBar = vp.select("#iconBar")[0];
            var bar1 = vp.select("#barHolder1")[0];
            var bar2 = vp.select("#barHolder2")[0];
            if (value) {
                //---- BIG BAR ON 1st LINE ----
                bar1.appendChild(bigBar);
                bar2.appendChild(iconBar);
                vp.select(bigBar)
                    .css("margin", "8px 0 0 16px");
                vp.select(iconBar)
                    .css("margin", "-6px 0 0 20px");
            }
            else {
                //---- BIG BAR ON 2nd LINE ----
                bar1.appendChild(iconBar);
                bar2.appendChild(bigBar);
                vp.select(iconBar)
                    .css("margin", "10px 0 0 20px");
                vp.select(bigBar)
                    .css("padding", "0");
            }
        };
        appSettingsMgr.prototype.onIconButtonsOnBigBarChanged = function (value) {
            if (value) {
                this._appStyleSheet.addRule(".iconToolButton", "border-width: 0 !important");
            }
            else {
                this._appStyleSheet.addRule(".iconToolButton", "border-width: 1px !important");
            }
            this._app.rebuildBothToolBars();
            this._app.markLayoutNeeded("isIconButtonsOnBigBar"); // make sure everything lines up after change
        };
        appSettingsMgr.prototype.onIsMenuTextVisibleChanged = function (value) {
            this.adjustMenuButtonRules();
            this._app.markLayoutNeeded("isMenuTextVisible"); // make sure everything lines up after change
        };
        appSettingsMgr.prototype.adjustMenuButtonRules = function () {
            var showText = this["_isMenuTextVisible"];
            var showChevron = this["_isMenuChevronVisible"];
            var showIcon = this["_isMenuIconVisible"];
            //---- nudge down iconbar 10 pixels when icons are not showing ----
            //vp.select("#iconBar").css("margin-top", (showIcon) ? "0px" : "5px");
            if (showText) {
                this._appStyleSheet.addRule(".toolBar .comboTextRow", (showIcon) ? "display: block" : "display: table-cell");
            }
            else {
                //vp.select("#iconBarRow")
                this._appStyleSheet.addRule(".toolBar .comboTextRow", "display: none");
            }
            if (showIcon) {
                this._appStyleSheet.addRule(".comboIconHolder", "display: block");
            }
            else {
                this._appStyleSheet.addRule(".comboIconHolder", "display: none");
            }
            if (showChevron) {
                this._appStyleSheet.addRule(".comboChevron", "display: inline-block");
            }
            else {
                this._appStyleSheet.addRule(".comboChevron", "display: none");
            }
            if (this["_isIconButtonsOnBigBar"]) {
                this._app.rebuildBothToolBars();
            }
            else {
                //---- icon buttons must be rebuilt ----
                this._app.markIconBarBuildNeeded();
            }
        };
        appSettingsMgr.prototype.onIsMenuIconVisibleChanged = function (value) {
            this.adjustMenuButtonRules();
            this._app.markLayoutNeeded("isMenuIconVisible"); // make sure everything lines up after change
        };
        appSettingsMgr.prototype.onIsMenuChevronVisibleChanged = function (value) {
            this.adjustMenuButtonRules();
        };
        appSettingsMgr.prototype.isTitleTextVisible = function (value) {
            if (arguments.length == 0) {
                return this._isTitleTextVisible;
            }
            this._isTitleTextVisible = value;
            this.saveAppSettings();
            //---- apply to current chart ----
            var chart = this._chartRouter;
            chart.showTitleText(value);
            this.onDataChanged("isTitleTextVisible");
        };
        appSettingsMgr.prototype.isItemCountsVisible = function (value) {
            if (arguments.length == 0) {
                return this._isItemCountsVisible;
            }
            this._isItemCountsVisible = value;
            this.saveAppSettings();
            //---- apply to current chart ----
            var chart = this._chartRouter;
            chart.showItemCounts(value);
            this.onDataChanged("isItemCountsVisible");
        };
        appSettingsMgr.prototype.onTitlePanelAlignmentChanged = function (value) {
            var align = "flex-start";
            if (value == "center") {
                align = "center";
            }
            else if (value == "right") {
                align = "flex-end";
            }
            this._appStyleSheet.addRule(".titlePanel", "align-self: " + align + " !important;");
        };
        appSettingsMgr.prototype.menuTextSize = function (value) {
            if (arguments.length === 0) {
                return this._menuTextSize;
            }
            this._menuTextSize = value;
            var strValue = value + "px !important";
            this._appStyleSheet.addRule(".buttonText", "font-size: " + strValue);
            this._appStyleSheet.addRule(".bigButtonText", "font-size: " + strValue);
            this.onIconButtonPropertyChanged();
            this.onDataChanged("menuTextSize");
        };
        appSettingsMgr.prototype.onIconButtonPropertyChanged = function () {
            if (this["_isIconButtonsOnBigBar"]) {
                this._app.rebuildBothToolBars();
            }
            else {
                this._app.markIconBarBuildNeeded();
            }
        };
        appSettingsMgr.prototype.menuValueSize = function (value) {
            if (arguments.length === 0) {
                return this._menuValueSize;
            }
            this._menuValueSize = value;
            var strValue = value + "px !important";
            this.onDataChanged("menuValueSize");
        };
        appSettingsMgr.prototype.onPromptTextSizeChanged = function (value) {
            var strValue = value + "px !important";
            this._appStyleSheet.addRule(".buttonPrompt", "font-size: " + strValue);
        };
        appSettingsMgr.prototype.onValueTextSizeChanged = function (value) {
            this._appStyleSheet.addRule(".buttonValue", "font-size: " + value + "px !important");
        };
        appSettingsMgr.prototype.onButtonIconWidthChanged = function (value) {
            var strValue = value + "px !important";
            this._appStyleSheet.addRule(".buttonIcon", "width: " + strValue + "; height: " + strValue + ";");
        };
        appSettingsMgr.prototype.iconOpacity = function (value) {
            if (arguments.length === 0) {
                return this._iconOpacity;
            }
            this._iconOpacity = value;
            this._appStyleSheet.addRule(".buttonIcon", "opacity: " + value);
            this._appStyleSheet.addRule(".iconOfCombo", "opacity: " + value);
            this.onDataChanged("iconOpacity");
        };
        appSettingsMgr.prototype.isColPickerSorted = function (value) {
            if (arguments.length === 0) {
                return this._isColPickerSorted;
            }
            this._isColPickerSorted = value;
            this.onDataChanged("isColPickerSorted");
            this.saveAppSettings();
            this.rebuildOpenPickers();
        };
        appSettingsMgr.prototype.isColDetailsSorted = function (value) {
            if (arguments.length === 0) {
                return this._isColDetailsSorted;
            }
            this._isColDetailsSorted = value;
            this.onDataChanged("isColDetailsSorted");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.rebuildOpenPickers = function () {
            this.onDataChanged("colPickerSettings");
        };
        appSettingsMgr.prototype.is3dGridAlwaysOn = function (value) {
            if (arguments.length === 0) {
                return this._is3dGridAlwaysOn;
            }
            this._is3dGridAlwaysOn = value;
            this.onDataChanged("is3dGridAlwaysOn");
            this.saveAppSettings();
            //this.on3dViewChanged();
        };
        appSettingsMgr.prototype.isWheelInertia = function (value) {
            if (arguments.length === 0) {
                return this._isWheelInertia;
            }
            this._isWheelInertia = value;
            this.setAllChartsProperty("isWheelInertia", value);
            this.saveAppSettings();
            this.onDataChanged("isWheelInertia");
        };
        appSettingsMgr.prototype.showWheelDuringTransformMode = function (value) {
            if (arguments.length == 0) {
                return this._showWheelDuringTransformMode;
            }
            this._showWheelDuringTransformMode = value;
            this.setAllChartsProperty("showWheelDuringTransformMode", value);
            this.onDataChanged("showWheelDuringTransformMode");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.showInProgressUI = function (value) {
            if (arguments.length == 0) {
                return this._showInProgressUI;
            }
            this._showInProgressUI = value;
            //---- now, rebuild icon bar & big bar ----
            this.onButtonChanged();
            this.onDataChanged("showInProgressUI");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isLightingAlwaysOn = function (value) {
            if (arguments.length === 0) {
                return this._isLightingAlwaysOn;
            }
            this._isLightingAlwaysOn = value;
            this.setAllChartsProperty("isLightingAlwaysOn", value);
            this.onDataChanged("isLightingAlwaysOn");
            //this.on3dViewChanged();
        };
        appSettingsMgr.prototype.ambientLightLevel = function (value) {
            if (arguments.length === 0) {
                return this._lightingParams.ambientLight.lightFactor;
            }
            this._lightingParams.ambientLight.lightFactor = value;
            this.setAllChartsProperty("ambientLightLevel", value);
            this.onDataChanged("ambientLightLevel");
        };
        appSettingsMgr.prototype.cacheLocalFiles = function (value) {
            if (arguments.length == 0) {
                return this._dataCacheParams.cacheLocalFiles;
            }
            this._dataCacheParams.cacheLocalFiles = value;
            this.onDataChanged("cacheLocalFiles");
            this.onDataCacheChanged();
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.cacheWebFiles = function (value) {
            if (arguments.length == 0) {
                return this._dataCacheParams.cacheWebFiles;
            }
            this._dataCacheParams.cacheWebFiles = value;
            this.onDataChanged("cacheWebFiles");
            this.onDataCacheChanged();
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.onDataCacheChanged = function () {
            this._app._dataEngine.dataCacheParams(this._dataCacheParams);
        };
        appSettingsMgr.prototype.useNiceNumbers = function (value) {
            if (arguments.length == 0) {
                return this._useNiceNumbers;
            }
            this._useNiceNumbers = value;
            this.setAllChartsProperty("useNiceNumbers", value);
            this.onDataChanged("useNiceNumbers");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.defaultBins = function (value) {
            if (arguments.length == 0) {
                return this._defaultBins;
            }
            this._defaultBins = value;
            this.onDataChanged("defaultBins");
            this.saveAppSettings();
            this._app.applyDefaultBins();
        };
        appSettingsMgr.prototype.autoSampling = function (value) {
            if (arguments.length == 0) {
                return this._autoSampling;
            }
            this._autoSampling = value;
            this.onDataChanged("autoSampling");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isAutoSamplingEnabled = function (value) {
            if (arguments.length == 0) {
                return this._autoSampling.isEnabled;
            }
            this._autoSampling.isEnabled = value;
            this.onDataChanged("isAutoSamplingEnabled");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.samplingThreshold = function (value) {
            if (arguments.length == 0) {
                return this._autoSampling.samplingThreshold;
            }
            this._autoSampling.samplingThreshold = value;
            this.onDataChanged("samplingThreshold");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.autoSamplingSampleCount = function (value) {
            if (arguments.length == 0) {
                return this._autoSampling.sampleCount;
            }
            this._autoSampling.sampleCount = value;
            this.onDataChanged("autoSamplingSampleCount");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.autoSamplingSampleType = function (value) {
            if (arguments.length == 0) {
                return beachParty.SampleType[this._autoSampling.sampleType];
            }
            this._autoSampling.sampleType = beachParty.SampleType[value];
            this.onDataChanged("autoSamplingSampleType");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.playbackDuration = function (value) {
            if (arguments.length === 0) {
                return this._playbackDuration;
            }
            this._playbackDuration = value;
            this.saveAppSettings();
            this._app.onAppPlaybackDurationChanged();
            this.onDataChanged("playbackDuration");
        };
        appSettingsMgr.prototype.isPlaybackLooping = function (value) {
            if (arguments.length === 0) {
                return this._isPlaybackLooping;
            }
            this._isPlaybackLooping = value;
            this.saveAppSettings();
            this._app.onAppPlaybackLoopngChanged();
            this.onDataChanged("isPlaybackLooping");
        };
        appSettingsMgr.prototype.rememberLastFile = function (value) {
            if (arguments.length == 0) {
                return this._rememberLastFile;
            }
            this._rememberLastFile = value;
            this.onDataChanged("rememberLastFile");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.rememberLastSession = function (value) {
            if (arguments.length == 0) {
                return this._rememberLastSession;
            }
            this._rememberLastSession = value;
            this.onDataChanged("rememberLastSession");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.rememberLastInsights = function (value) {
            if (arguments.length == 0) {
                return this._rememberLastInsights;
            }
            this._rememberLastInsights = value;
            this.onDataChanged("rememberLastInsights");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.initialChartType = function (value) {
            if (arguments.length === 0) {
                //---- legacy values stored as enum ----
                var ct = this._initialChartType;
                var val = (vp.utils.isString(ct)) ? ct : beachParty.ChartType[ct];
                return val;
            }
            //---- keep as string ----
            this._initialChartType = value;
            this.onDataChanged("initialChartType");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.initialDataParams = function (value) {
            if (arguments.length === 0) {
                return this._initialDataParams;
            }
            //---- keep as string ----
            this._initialDataParams = value;
            this.onDataChanged("initialDataParams");
            this.saveAppSettings();
        };
        appSettingsMgr.prototype.isShowingDrawStats = function (value) {
            if (arguments.length === 0) {
                return this._isShowingDrawStats;
            }
            this._isShowingDrawStats = value;
            this._chartRouter.setChartDebugInfo(value);
            this.saveAppSettings();
            this.onDataChanged("isShowingDrawStats");
        };
        appSettingsMgr.prototype.isShowingLastCycle = function (value) {
            if (arguments.length === 0) {
                return this._isShowingLastCycle;
            }
            this._isShowingLastCycle = value;
            vp.select("#lastCycleFPS").css("display", (value) ? "" : "none");
            this.saveAppSettings();
            this.onDataChanged("isShowingLastCycle");
        };
        appSettingsMgr.prototype.isShowingEventStats = function (value) {
            if (arguments.length === 0) {
                return this._isShowingEventStats;
            }
            this._isShowingEventStats = value;
            vp.select("#eventStats").css("display", (value) ? "" : "none");
            this.saveAppSettings();
            this.onDataChanged("isShowingEventStats");
        };
        appSettingsMgr.prototype.isErrorReportingDisabled = function (value) {
            if (arguments.length === 0) {
                return this._isErrorReportingDisabled;
            }
            this._isErrorReportingDisabled = value;
            this.saveAppSettings();
            this.onDataChanged("isErrorReportingDisabled");
        };
        appSettingsMgr.prototype.showXGridLines = function (value) {
            if (arguments.length === 0) {
                return this._chartFrameData.xAxis.drawGridLines;
            }
            this._chartFrameData.xAxis.drawGridLines = value;
            this.onDataChanged("showXGridLines");
            this.setAllChartsProperty("showXGridLines", value);
            this.onChartFrameDataChanged();
            this._app.logAction(beachParty.Gesture.click, "xGridLines", beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { xGridLines: value });
        };
        appSettingsMgr.prototype.showYGridLines = function (value) {
            if (arguments.length === 0) {
                return this._chartFrameData.yAxis.drawGridLines;
            }
            this._chartFrameData.yAxis.drawGridLines = value;
            this.onDataChanged("showYGridLines");
            this.setAllChartsProperty("showYGridLines", value);
            this.onChartFrameDataChanged();
            this._app.logAction(beachParty.Gesture.click, "yGridLines", beachParty.ElementType.checkbox, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { yGridLines: value });
        };
        appSettingsMgr.prototype.shapeOpacity = function (value) {
            if (arguments.length === 0) {
                return this._shapeOpacity;
            }
            this._shapeOpacity = value;
            this.setAllChartsProperty("shapeOpacity", value);
            this.onDataChanged("shapeOpacity");
        };
        appSettingsMgr.prototype.shapeOpacityCompleted = function (value) {
            this._app.logAction(beachParty.Gesture.select, "shapeOpacity", beachParty.ElementType.numAdjuster, beachParty.Action.adjust, beachParty.Target.chartOptions, true, { shapeOpacity: value });
        };
        appSettingsMgr.prototype.automatedTestName = function (value) {
            if (arguments.length == 0) {
                return this._automatedTestName;
            }
            this._automatedTestName = value;
            this.onDataChanged("automatedTestName");
        };
        /** Reset all persisted app settings. */
        appSettingsMgr.prototype.resetSettingsAndReloadData = function () {
            beachParty.localStorageMgr.clearAll();
            this._app.logAction(beachParty.Gesture.click, "reset", beachParty.ElementType.button, beachParty.Action.clear, beachParty.Target.appSettings, false);
            //---- refresh the page ----
            location.reload();
        };
        return appSettingsMgr;
    }(beachParty.dataChangerClass));
    beachParty.appSettingsMgr = appSettingsMgr;
    var AppSettings = (function () {
        function AppSettings(versionNum, properties) {
            this.versionNum = versionNum;
            //---- process properties ----
            for (var i = 0; i < properties.length; i++) {
                var prop = properties[i];
                this[prop.name] = null;
            }
        }
        return AppSettings;
    }());
    beachParty.AppSettings = AppSettings;
    var PropertyInfo = (function () {
        function PropertyInfo(name, defaultValue, initValue, onChangedMethod) {
            this.name = name;
            this.defaultValueForCtr = defaultValue;
            this.initialValueForReset = initValue;
            this.onChangedMethod = onChangedMethod;
        }
        return PropertyInfo;
    }());
    beachParty.PropertyInfo = PropertyInfo;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    scriptRunner.ts - controls the running of an automated BeachParty test.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var scriptRunnerClass = (function (_super) {
        __extends(scriptRunnerClass, _super);
        function scriptRunnerClass(app) {
            _super.call(this);
            this.testResultsKey = "testResults";
            //---- test PARAMS ----
            this._repeatCount = 1;
            this._maxBuildTime = undefined;
            this._minFPS = undefined;
            this._cmdDelay = undefined;
            this._stopOnError = true;
            this._collectPerfData = true;
            this._runCount = 0;
            this._isRunning = false;
            this._waitingForCycleNum = undefined;
            this._currentViewName = "Scatter";
            this._isCompleted = false;
            this._cmdTimer = null;
            this._errorCountAtStart = 0;
            this._timeStarted = 0;
            this._app = app;
        }
        scriptRunnerClass.prototype.currentCmd = function () {
            return this._currentCmd;
        };
        scriptRunnerClass.prototype.runStatus = function () {
            var status = "Running";
            if (!this._isRunning) {
                status = (this._isCompleted) ? "Completed" : "Stopped";
            }
            return status;
        };
        scriptRunnerClass.prototype.start = function (scriptData, fn, runCount) {
            this._repeatCount = (runCount) ? runCount : scriptData.repeatCount;
            this._plotResults = scriptData.plotResults;
            this._name = (fn) ? fn : scriptData.scriptName;
            this._cmds = scriptData.cmds;
            this._cmdDelay = (scriptData.cmdDelay !== undefined) ? scriptData.cmdDelay : 1000;
            this._stopOnError = (scriptData.stopOnError !== undefined) ? scriptData.stopOnError : true;
            this.onDataChanged("runStatus");
            this._errorCountAtStart = this._app._errorCount;
            this._timeStarted = +Date.now();
            this.restart(true);
        };
        scriptRunnerClass.prototype.restart = function (firstPass) {
            if (firstPass) {
                this._runCount = 0;
                this._isRunning = true;
                this._perfRecords = [];
            }
            this._cmdIndex = 0;
            this._runCount++;
            this.statusMsg();
            this.startNextCmd();
        };
        scriptRunnerClass.prototype.statusMsg = function (msg) {
            var fullMsg = "";
            if (this._name) {
                fullMsg = this._name + ": run #" + this._runCount;
                if (msg) {
                    fullMsg += "\r\n" + msg;
                }
            }
            else {
                fullMsg = "remote cmd: ";
                if (msg) {
                    fullMsg += msg;
                }
            }
            this._app.infoMsg(fullMsg);
        };
        scriptRunnerClass.prototype.startNextCmd = function (delay) {
            var _this = this;
            if (this._isRunning) {
                if (this._cmdIndex < this._cmds.length) {
                    if (delay === undefined) {
                        delay = (this._cmdDelay !== undefined) ? this._cmdDelay : 1;
                    }
                    this.cancelCmdTimer();
                    this._cmdTimer = setTimeout(function (e) {
                        //this._cmdTimer = null;
                        var cmd = _this._cmds[_this._cmdIndex];
                        _this._cmdIndex++;
                        _this.runCmd(cmd);
                    }, delay);
                }
                else {
                    this.onEndReached();
                }
            }
        };
        scriptRunnerClass.prototype.cancelCmdTimer = function () {
            if (this._cmdTimer) {
                clearTimeout(this._cmdTimer);
                this._cmdTimer = null;
            }
        };
        scriptRunnerClass.prototype.reportFrameStats = function (cmdTime, buildChartElapsed, frameRate, frameCount, cycleNum, cmdId) {
            if (this._isRunning) {
                if (this._maxBuildTime !== undefined && buildChartElapsed > this._maxBuildTime) {
                    this.error("maxBuildTime=" + this._maxBuildTime + " exceeded");
                }
                if (this._minFPS !== undefined && frameRate < this._minFPS) {
                    this.error("minFPS=" + this._minFPS + " not met");
                }
                if (this._collectPerfData) {
                    //---- add perf record ----
                    var pr = new PerfRecord();
                    var chart = this._app._chartRouter.getChart();
                    pr.time = vp.utils.now();
                    pr.cmdTime = cmdTime;
                    pr.fps = frameRate;
                    pr.frameCount = frameCount;
                    pr.buildTime = buildChartElapsed;
                    pr.dataName = chart.getFileName();
                    pr.cycleNum = cycleNum;
                    pr.recordCount = chart.getRecordCount();
                    pr.view = this._currentViewName;
                    pr.cmd = this._currentCmd;
                    this._perfRecords.push(pr);
                }
                if (this._cmdId == cmdId) {
                    this._waitingForCycleNum = undefined;
                    this._currentCmd = null;
                    this.startNextCmd();
                }
            }
        };
        scriptRunnerClass.prototype.error = function (msg) {
            this.stop();
            msg = "Error during automated test: " + msg;
            this._app.showError(msg);
        };
        scriptRunnerClass.prototype.getParam = function (cmd, paramName) {
            var value = (vp.utils.isObject(cmd)) ? cmd[paramName] : cmd;
            if (value === undefined) {
                this.error("cmd=" + cmd + " is missing parameter=" + paramName);
            }
            return value;
        };
        scriptRunnerClass.prototype.runCmd = function (cmd) {
            var nextCmdDelay = undefined;
            var colorMgr = this._app._colorMgr;
            var chart = this._app.currentChart();
            //---- remove this so cmd can be easily compared ----
            delete cmd["fromClient"];
            this._currentCmd = JSON.stringify(cmd);
            vp.utils.debug("testMgr.runCmd: " + JSON.stringify(cmd));
            //---- store the cmdID with bpsHelper ----
            this._cmdId = (5000 + this._cmdIndex) + "";
            this._app.setHelperCmdId(this._cmdId);
            var action = beachParty.Action[cmd.action];
            var target = beachParty.Target[cmd.target];
            var cmdNeedsRendering = true;
            if (action == beachParty.Action.load && target == beachParty.Target.data) {
                //---- LOAD DATA ----
                var dataName = cmd.fileName;
                var source = cmd.source;
                var fileParams = new beachParty.WorkingDataParams(dataName, null, source);
                chart.autoLoadFile(fileParams);
                this._currentViewName = "Scatter";
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.chartType) {
                //---- SET CHARTTYPE ----
                var layoutName = cmd.layoutName;
                var layoutType = beachParty.LayoutType[layoutName];
                var chartName = cmd.name;
                var chartType = beachParty.chartClass.getChartTypeFromName(chartName, layoutType);
                chart.changeToChart(chartType, layoutType, beachParty.Gesture.automatedTest);
                this._currentViewName = chartName;
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.chartTitle) {
                if (cmd.value != undefined) {
                    //--- CHART TITLE ----
                    chart.titleText(cmd.value);
                }
                else if (cmd.showTitleText != undefined) {
                    //--- SHOW TITLE TEXT ----
                    chart.showTitleText(cmd.showTitleText);
                }
                else if (cmd.showItemCounts != undefined) {
                    //--- SHOW ITEM COUNTS ----
                    chart.showItemCounts(cmd.showItemCounts);
                }
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.sortItemColumn) {
                chart.sortItemColumn(cmd.value);
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.chartOptions) {
                if (cmd.sizeFactor !== undefined) {
                    //---- SIZE FACTOR ----
                    chart.sizeFactor(cmd.sizeFactor);
                }
                else if (cmd.shapeSeparation !== undefined) {
                    //---- SEPARATION FACTOR ----
                    chart.separationFactor(cmd.shapeSeparation);
                }
                else if (cmd.shapeOpacity !== undefined) {
                    //---- SHAPE OPACITY ----
                    chart.shapeOpacity(cmd.shapeOpacity);
                }
                else if (cmd.xGridLines !== undefined) {
                    //---- X GRIDLINES ----
                    chart.showXGridLines(cmd.xGridLines);
                }
                else if (cmd.yGridLines !== undefined) {
                    //---- Y GRIDLINES ----
                    chart.showYGridLines(cmd.yGridLines);
                }
                else if (cmd.shapeColor !== undefined) {
                    //---- SHAPE COLOR ----
                    chart.shapeColor(cmd.shapeColor);
                }
                else if (cmd.shapeImage !== undefined) {
                    //---- SHAPE IMAGE ----
                    chart.shapeImage(cmd.shapeImage);
                }
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.facetMapping) {
                //---- FACET COLUMN ----
                this._app._facetMgr.colName(cmd.colName);
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.sizeMapping) {
                //---- SIZE COLUMN ----
                this._app._sizeMgr.colName(cmd.colName);
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.shapeMapping) {
                //---- SHAPE COLUMN ----
                this._app._shapeMgr.colName(cmd.colName);
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.textMapping) {
                //---- TEXT COLUMN ----
                this._app._textMgr.colName(cmd.colName);
            }
            else if (action == beachParty.Action.remap && target == beachParty.Target.colorMapping) {
                //---- COLOR REMAP ----
                this._app._colorMgr.remapColorData();
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.colorSpread) {
                //---- COLOR SPREAD ----
                colorMgr.colorSpread(cmd.value);
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.paletteSetPickList) {
                //---- COLOR PALETTE SET ----
                colorMgr.paletteSetName(cmd.value);
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.colorPalette) {
                if (cmd.paletteName) {
                    //---- COLOR PALETTE ----
                    colorMgr.paletteSetName(cmd.setName);
                    colorMgr.setPaletteFromName(cmd.paletteName);
                }
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.colorReverse) {
                //---- COLOR REVERSE ----
                colorMgr.reverseColorPalette(toBool(cmd.value));
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.colorContinuous) {
                //---- COLOR CONTINUOUS ----
                colorMgr.colorIsContinuous(toBool(cmd.value));
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.colorMapping) {
                //---- COLOR MAPPING ----
                if (cmd.colName !== undefined) {
                    colorMgr.colName(cmd.colName);
                }
                else if (cmd.binCount !== undefined) {
                    colorMgr.sliderBinCount(+cmd.binCount);
                }
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.selection) {
                if (cmd.selectedKeys) {
                    //---- RECT SELECTION (using selected keys - very reliable) ----
                    chart.setSelectionWithKeys(cmd.selectedKeys);
                }
                else {
                }
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.xMapping) {
                if (cmd.binCount !== undefined) {
                    //---- X BINS ----
                    //this._app.xBins(cmd.binCount);
                    this._app._xMgr.sliderBinCount(cmd.binCount);
                }
                else if (cmd.colName !== undefined) {
                    //---- X COLNAME ----
                    //this._app.xColumn(cmd.colName);
                    this._app._xMgr.colName(cmd.colName);
                }
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.yMapping) {
                if (cmd.binCount !== undefined) {
                    //---- Y BINS ----
                    this._app._yMgr.sliderBinCount(cmd.binCount);
                }
                else if (cmd.colName !== undefined) {
                    //---- Y COLNAME ----
                    this._app._yMgr.colName(cmd.colName);
                }
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.zMapping) {
                if (cmd.binCount !== undefined) {
                    //---- STACKS COUNT ----
                    this._app._zMgr.sliderBinCount(cmd.binCount);
                }
                else if (cmd.colName !== undefined) {
                    //---- Z COLNAME ----
                    this._app._zMgr.colName(cmd.colName);
                }
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.filter && cmd.type == "Isolate") {
                //---- ISOLATE ----
                if (chart.getSelectedCount()) {
                    this._app.onIsolateClick(null);
                }
                else {
                    cmdNeedsRendering = false;
                }
            }
            else if (action == beachParty.Action.adjust && target == beachParty.Target.filter && cmd.type == "Exclude") {
                //---- EXCLUDE ----
                if (chart.getSelectedCount()) {
                    this._app.onExcludeClick(null);
                }
                else {
                    cmdNeedsRendering = false;
                }
            }
            else if (action == beachParty.Action.clear && target == beachParty.Target.filterAndSelection) {
                //---- RESET ----
                this._app.onResetClick(null);
            }
            else if (action == beachParty.Action.select && target == beachParty.Target.panelTab) {
                //---- SELECT PANEL TAB ----
                var panelMaster = this._app._panelMaster;
                var panelx = panelMaster.getJsonPanel(cmd.panelName);
                if (panelx instanceof beachParty.jsonPanelClass) {
                    var pj = panelx;
                    pj.selectTab(cmd.tabIndex);
                }
                cmdNeedsRendering = false;
            }
            else if (this.isTogglePanel(target) && (action == beachParty.Action.show || action == beachParty.Action.close)) {
                var panelName = beachParty.Target[target];
                var panelxx = this._app._panelMaster.getJsonPanel(panelName);
                if (action == beachParty.Action.show) {
                    //---- OPEN PANEL ----
                    if (!panelxx) {
                        var funcName = "toggle" + beachParty.chartUtils.capitalizeFirstLetter(panelName);
                        this._app[funcName]();
                    }
                }
                else {
                    //---- CLOSE PANEL ----
                    if (panelxx) {
                        panelxx.close();
                    }
                }
                cmdNeedsRendering = false;
            }
            else {
                //---- UNKNOWN CMD ----
                cmdNeedsRendering = false;
            }
            var strIndex = (this._cmdIndex === undefined) ? "" : (this._cmdIndex + ".");
            var strCmd = strIndex + this.cmdToString(cmd);
            if (!cmdNeedsRendering) {
                this._currentCmd = null;
                this._waitingForCycleNum = undefined;
                this.statusMsg(strCmd + " (completed)");
                this.startNextCmd();
            }
            else {
                this._waitingForCycleNum = 1 + this._app._chartCycleNum;
                this.statusMsg(strCmd + " (#" + this._waitingForCycleNum + ")");
            }
        };
        scriptRunnerClass.prototype.isTogglePanel = function (target) {
            var toggles = [beachParty.Target.tourLoaderPanel, beachParty.Target.navPanel, beachParty.Target.aboutPanel, beachParty.Target.selectionPanel, beachParty.Target.clusterPanel,
                beachParty.Target.tipsPanel, beachParty.Target.searchPanel, beachParty.Target.scriptsPanel, beachParty.Target.themesPanel, beachParty.Target.palettesPanel,
                beachParty.Target.detailsPanel, beachParty.Target.tourLoaderPanel, beachParty.Target.settingsPanel, beachParty.Target.aboutPanel,
                beachParty.Target.sortPanel, beachParty.Target.textPanel, beachParty.Target.shapePanel, beachParty.Target.sizePanel,
                beachParty.Target.colorPanel, beachParty.Target.facetPanel, beachParty.Target.sumPanel, beachParty.Target.xPanel, beachParty.Target.yPanel, beachParty.Target.zPanel,
                beachParty.Target.chartPicker, beachParty.Target.itemsPanel, beachParty.Target.datasetPanel, beachParty.Target.datasetPanel];
            return (toggles.indexOf(target) > -1);
        };
        scriptRunnerClass.prototype.onEndReached = function () {
            if ((!this._repeatCount) || (this._runCount < this._repeatCount)) {
                this.restart(false);
            }
            else {
                this.onStopped(true);
            }
        };
        scriptRunnerClass.prototype.onStopped = function (testCompleted) {
            this._isRunning = false;
            this._isCompleted = testCompleted;
            var elapsed = +Date.now() - this._timeStarted;
            var errorsEncountered = this._app._errorCount - this._errorCountAtStart;
            var status = (testCompleted) ? "completed" : "stopped";
            this.statusMsg("test " + status + ": errors encountered=" + errorsEncountered + ", elapsed time=" +
                (elapsed / 1000) + " ms");
            this.cancelCmdTimer();
            this.onDataChanged("runStatus");
            //---- write perf results to local storage ----
            if (this._collectPerfData) {
                this.savePerfResults();
                if (this._plotResults) {
                    this.plotPerfResults();
                }
            }
        };
        scriptRunnerClass.prototype.plotPerfResults = function () {
            var _this = this;
            var perfResults = this.loadPerfResultsFromLocalStorage();
            if (perfResults) {
                var dataMgr = this._app.getChartDataMgr();
                dataMgr.loadFrom(perfResults, "testResults", undefined, function (e) {
                    var chart = _this._app.currentChart();
                    chart.changeToChart(beachParty.ChartType.Scatter, null, beachParty.Gesture.automatedTest);
                    //this._app.xColumn("time");
                    _this._app._xMgr.colName("time");
                    _this._app._yMgr.colName("fps");
                    _this._app._colorMgr.colName("cmd");
                });
            }
        };
        scriptRunnerClass.prototype.loadPerfResultsFromLocalStorage = function () {
            var perfResults = null;
            var str = beachParty.localStorageMgr.get(beachParty.StorageType.sessionShare, beachParty.StorageSubType.testResults, null);
            perfResults = JSON.parse(str);
            //---- change "time" to a "date" ----
            perfResults.forEach(function (pr) {
                pr.time = new Date(pr.time);
            });
            return perfResults;
        };
        scriptRunnerClass.prototype.savePerfResults = function () {
            var str = JSON.stringify(this._perfRecords);
            beachParty.localStorageMgr.save(beachParty.StorageType.sessionShare, beachParty.StorageSubType.testResults, null, str);
        };
        scriptRunnerClass.prototype.cmdToString = function (cmd) {
            var str = JSON.stringify(cmd);
            return str;
        };
        scriptRunnerClass.prototype.stop = function () {
            this._app.infoMsg("Test stopped");
            this.onStopped();
        };
        return scriptRunnerClass;
    }(beachParty.dataChangerClass));
    beachParty.scriptRunnerClass = scriptRunnerClass;
    function toBool(value) {
        return (value == "true");
    }
    var PerfRecord = (function () {
        function PerfRecord() {
        }
        return PerfRecord;
    }());
    beachParty.PerfRecord = PerfRecord;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    iconNames.ts - maps icon names used in code to their actual files.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    //---- GENERAL icons ----
    beachParty.fnSandDanceLogo = "sandDanceLogoTransparent.png";
    beachParty.fnPinDown = "pinDown.png";
    beachParty.fnPinLeft = "panel_pin.svg"; //"pinLeft.png";
    beachParty.fnDetailsNext = "detailsNext.png";
    beachParty.fnDetailsPrev = "detailsPrev.png";
    beachParty.fnResizer = "resizerIcon.png";
    beachParty.fnMenuBars = "menuBars.png";
    beachParty.fnClose = "panel_close.svg"; // "close.png";
    beachParty.fnChevron = "smallChevron3.png";
    //---- SLIDER ----
    beachParty.fnOpenSlider = "slider_open_close.svg";
    beachParty.fnCloseSlider = "slider_open_close.svg";
    //---- PANE OPEN/CLOSE ----
    beachParty.fnOpenPane = "dropDown.png";
    beachParty.fnClosePane = "dropUp.png";
    //---- CHART PICKER ----
    beachParty.fnChartPickerBar = "chartPicker_bar.png";
    beachParty.fnChartPickerCol = "chartPicker_columns.png";
    beachParty.fnChartPickerDensity = "chartPicker_density.png";
    beachParty.fnChartPickerGrid = "chartPicker_flat.png";
    beachParty.fnChartPickerCustom = "chartPicker_custom.png";
    beachParty.fnChartPickerSpiral = "chartPicker_spiral.png";
    beachParty.fnChartPickerRandom = "chartPicker_random.png";
    beachParty.fnChartPickerPoisson = "chartPicker_poisson.png";
    beachParty.fnChartPickerRadial = "chartPicker_radial.png";
    beachParty.fnChartPickerScatter3d = "chartPicker_scatter3D.png";
    beachParty.fnChartPickerScatter = "chartPicker_scatterplot.png";
    beachParty.fnChartPickerLine = "chartPicker_line.png";
    beachParty.fnChartPickerLinks = "chartPicker_links.png";
    beachParty.fnChartPickerCluster = "chartPicker_cluster.png";
    beachParty.fnChartPickerSquarify = "chartPicker_squarify.png";
    beachParty.fnChartPickerStacks = "chartPicker_stacks.png";
    beachParty.fnChartPickerViolin = "chartPicker_violin.png";
    beachParty.fnChartPickerAggColumn = "chartPicker_columns.png";
    beachParty.fnChartPickerHRug = "chartPicker_hrug.png";
    beachParty.fnChartPickerVRug = "chartPicker_vrug.png";
    //---- ICON BAR icons ----
    beachParty.fnFeedback = "feedback.svg";
    beachParty.fnScrubber = "scrubber.svg";
    beachParty.fnScripts = "scripts.svg";
    beachParty.fnCluster = "cluster.svg";
    beachParty.fnThemes = "themes.svg";
    beachParty.fnPalettes = "palettes.svg";
    beachParty.fnDetails = "details.svg";
    beachParty.fnSnapshot = "iconBar_snapshot2.png";
    beachParty.fnExlude = "exclude.svg";
    beachParty.fnIsolate = "isolate.svg";
    beachParty.fnNewView = "view.svg";
    beachParty.fnUndo = "undo.svg";
    beachParty.fnRedo = "redo.svg";
    beachParty.fnReset = "reset.svg";
    //export var fnChartOptions = "chartOptions.svg";   
    beachParty.fnSettings = "settings.svg";
    beachParty.fnAbout = "about.svg";
    beachParty.fnSearch = "search.svg";
    beachParty.fnFacetBrowse = "facet.svg";
    beachParty.fnBot = "bot.svg";
    beachParty.fnTours = "tours.svg";
    beachParty.fnTasks = "tasks.svg";
    beachParty.fnHelp = "tour.svg";
    //export var fnIconBarViewRelated = "iconBar_viewRelated.png";
    beachParty.fnSlicer = "iconBar_dataSlicer.png";
    beachParty.fnNav = "nav.svg";
    beachParty.fnNavSelected = "navOpen.svg";
    beachParty.fnInsights = "insight.svg";
    beachParty.fnInsightsSelected = "insightOpen.svg";
    beachParty.fnIconBarDataTip = "tips.svg";
    beachParty.fnDragDataTip = "iconBar_dataTip.png"; // for dataTip control
    beachParty.fnIconBarPause = "iconBar_pause.png";
    beachParty.fnIconBarPlay = "iconBar_play.png";
    beachParty.fnIconBarStop = "iconBar_stop.png";
    beachParty.fnIconBarResume = "iconBar_play.png";
    beachParty.fnIconBarAdd = "iconBar_add.png";
    //---- SLIDER icons ----
    beachParty.fnSliderPlus = "slider_plus.svg";
    beachParty.fnSliderMinus = "slider_minus.svg";
    beachParty.fnSliderCircle = "slider_button.svg";
    //---- COLUMN PICKER icons ----
    beachParty.fnColPickerNone = "column_none.svg";
    beachParty.fnColPickerNumber = "column_number.svg";
    beachParty.fnColPickerString = "column_text.svg";
    beachParty.fnColPickerDate = "column_date.svg";
    //---- ADJUSTER DIAL icons ----
    beachParty.fnAdjustDialBottom = "general_adjusterDial_bottom.svg";
    beachParty.fnAdjustDialTop = "general_adjusterDial_top.svg";
    beachParty.fnAdjustDialLeft = "general_adjusterDial_left.svg";
    beachParty.fnAdjustDialRight = "general_adjusterDial_right.svg";
    //---- SELECTION MODE icons ----
    //export var fnSelectionReset     = "selectionModePanel_reset_white.png";
    beachParty.fnSelectionToggle = "selectionModePanel_normal_white.png";
    beachParty.fnSelectionNormal = "selectionModePanel_normal_white.png";
    beachParty.fnSelectionExcept = "selectionModePanel_except_white.png";
    beachParty.fnSelectionSubtract = "selectModeSubtract.png";
    beachParty.fnSelectionUnite = "selectModeUnite.png";
    beachParty.fnSelectionIntersect = "selectModeIntersect.png";
    //---- "SELECTED" selection mode icons ----
    beachParty.fnSelectionExceptSelected = "selectionModePanel_except__black.png";
    beachParty.fnSelectionSubtractSelected = "selectionModePanel_subtract__black.png";
    beachParty.fnSelectionUniteSelected = "selectionModePanel_unite__black.png";
    beachParty.fnSelectionIntersectSelected = "selectionModePanel_intersect__black.png";
    //---- INSIGHT PANEL icons ----
    beachParty.fnInsightData = "insightPanel_dataOnly.png";
    beachParty.fnInsightFilter = "insightPanel_filterOnly.png";
    beachParty.fnInsightFull = "insightPanel_fullInsight.png";
    beachParty.fnInsightSelection = "insightPanel_selectionOnly.png";
    beachParty.fnInsightView = "insightPanel_viewOnly.png";
    beachParty.fnInsightCreate = "insightPanel_createNewInsight.png";
    beachParty.fnInsightNext = "insightPanel_next.png";
    beachParty.fnInsightPrevious = "insightPanel_previous.png";
    beachParty.appIconPath = null;
    function iconPath(themeMgr, panelName, iconName) {
        var path = beachParty.appIconPath;
        if (!path) {
            if (themeMgr) {
                path = themeMgr.getIconPath(panelName);
            }
            else {
                path = "images";
            }
        }
        path += "/" + iconName;
        return path;
    }
    beachParty.iconPath = iconPath;
    function setIconName(themeMgr, elem, iconName, panelName, applyNow) {
        elem.setAttribute("data-iconName", iconName);
        elem.setAttribute("data-panelName", (panelName) ? panelName : "appPanel");
        if (applyNow) {
            matchIconsToTheme(themeMgr, elem.parentElement, panelName);
        }
    }
    beachParty.setIconName = setIconName;
    function matchIconsToTheme(themeMgr, rootElem, panelName) {
        //---- we accept both ".themeIcon" and ".clickIcon" ----
        vp.select(rootElem, ".themeIcon").each(function (index, elemW) {
            processImgElem(themeMgr, panelName, index, elemW);
        });
        vp.select(rootElem, ".clickIcon").each(function (index, elemW) {
            processImgElem(themeMgr, panelName, index, elemW);
        });
    }
    beachParty.matchIconsToTheme = matchIconsToTheme;
    function processImgElem(themeMgr, panelName, index, elemW) {
        var elem = (elemW.length) ? elemW[0] : elemW;
        var iconName = elem.getAttribute("data-iconName");
        if (!panelName) {
            panelName = elem.getAttribute("data-panelName");
        }
        if (!iconName) {
            //---- this icon didn't use "setIconName()" - extract info now ----
            var iconName = elem.getAttribute("src");
            var index = iconName.lastIndexOf("/");
            if (index > -1) {
                iconName = iconName.substr(index + 1);
            }
            if (!panelName) {
                panelName = "appPanel";
            }
            //---- set value for next time ----
            setIconName(themeMgr, elem, iconName, panelName);
        }
        if (themeMgr) {
            var path = iconPath(themeMgr, panelName, iconName);
            elem.setAttribute("src", path);
        }
    }
    beachParty.processImgElem = processImgElem;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    notesPanel.ts - popup panel for displaying INSIGHT title and notes.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var notesPanelClass = (function (_super) {
        __extends(notesPanelClass, _super);
        function notesPanelClass(app, title, notes, bounds, rcPlot, inPresentMode) {
            var _this = this;
            _super.call(this, app, "notesPanel", false, null, title, null, null, true, "Notes for this insight", false);
            var rootW = vp.select(this._root)
                .css("opacity", ".7");
            //---- add class to text and move it up a bit ----
            vp.select(this._root, ".panelPrompt")
                .addClass("insightNotes")
                .css("position", "relative")
                .css("top", "-5px");
            if (inPresentMode) {
                //---- hide the close button and resize icon ----
                vp.select(this._root, ".clickIcon")
                    .css("display", "none");
            }
            if (notes && notes.length) {
                //---- create the notes holder DIV ----
                var notesHolderW = vp.select(this._root).append("div")
                    .addClass("insightNotesHolder");
                //---- TODO: create a "span" for each section of text/URL ----
                //---- for now, just replace NEWLNE with <br> ----
                notes = notes.replace(/\n/g, "<br />");
                var notesW = notesHolderW.append("span")
                    .addClass("insightNotesSpan")
                    .html(notes);
                this._notesElem = notesHolderW[0];
            }
            //---- figure out bounds of panel ----
            if (bounds) {
                rootW
                    .width(bounds.width)
                    .height(bounds.height);
                var left = bounds.left;
                var top = bounds.top;
            }
            else {
                //---- center at top of plot ----
                var xMiddle = (rcPlot.left + rcPlot.right) / 2;
                var myWidth = vp.select(this._root).width();
                left = xMiddle - myWidth / 2;
                top = rcPlot.top;
            }
            //---- track sizing for relayout ----
            this.registerForChange("size", function (e) { return _this.onPanelSizeChanged(); });
            //---- find the correct resize icon for current theme ----
            beachParty.matchIconsToTheme(this._app._themeMgr, this._root);
            this.open(left, top);
        }
        notesPanelClass.prototype.onPanelSizeChanged = function () {
            var rcPanel = vp.select(this._root).getBounds(false);
            var rcTitle = vp.select(this._root, ".panelTitle").getBounds(false);
            var paddingEtc = 12 + 20 + 4; // 4 for spacing
            var notesHeight = rcPanel.height - (rcTitle.height + paddingEtc);
            vp.select(this._notesElem).height(notesHeight);
        };
        return notesPanelClass;
    }(beachParty.basePanelClass));
    beachParty.notesPanelClass = notesPanelClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    chartPicker.ts - popup panel for selecting the current chart type.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var chartPickerClass = (function (_super) {
        __extends(chartPickerClass, _super);
        function chartPickerClass(app, currentChart, callback) {
            var _this = this;
            _super.call(this, app, "bbView", false, undefined, "View as", undefined, undefined, undefined, undefined, undefined, true);
            this._callback = null;
            this._currentChart = null;
            this._app = app;
            this.showTitle(false); // initially hidden
            this._callback = callback;
            this._currentChart = currentChart;
            //---- create the table ----
            var tableW = vp.select(this._contentRow).append("table")
                .addClass("chartPicker");
            //---- first row of CHARTS ----
            var rowW = tableW.append("tr");
            var useCustomChart = true;
            //---- CORE charts ----
            rowW = this.addChart(rowW, "Grid", beachParty.fnChartPickerGrid, "View the shapes in a single level grid");
            rowW = this.addChart(rowW, "Column", beachParty.fnChartPickerCol, "Organize shapes into verticalcolumns");
            rowW = this.addChart(rowW, "Scatter", beachParty.fnChartPickerScatter, "Plot data in X and Y");
            rowW = this.addChart(rowW, "Density", beachParty.fnChartPickerDensity, "Organize shapes into X and Y bins");
            rowW = this.addChart(rowW, "Stacks", beachParty.fnChartPickerStacks, "Organize shapes into X and Y bins, stacked in Z");
            rowW = this.addChart(rowW, "Squarify", beachParty.fnChartPickerSquarify, "Draw shapes from largest to smallest arranged in a rectangle");
            //---- EXPERIMENTAL charts ----
            rowW = this.addChart(rowW, "Random", beachParty.fnChartPickerRandom, "Arrange the shapes at random withing the plot");
            rowW = this.addChart(rowW, "Poisson", beachParty.fnChartPickerPoisson, "Arrange the shapes using poisson spacing");
            rowW = this.addChart(rowW, "Spiral", beachParty.fnChartPickerSpiral, "Arrange the shapes in a spiral layout");
            rowW = this.addChart(rowW, "Line", beachParty.fnChartPickerLine, "View the shapes as line across the horizontal axis");
            rowW = this.addChart(rowW, "Links", beachParty.fnChartPickerLinks, "View the shapes as line between sequential pairs of points");
            rowW = this.addChart(rowW, "Radial", beachParty.fnChartPickerRadial, "Plot data with X as the angle and Y as the radius");
            rowW = this.addChart(rowW, "Xband", beachParty.fnChartPickerHRug, "Plot the shapes along the horizontal axis");
            rowW = this.addChart(rowW, "Yband", beachParty.fnChartPickerVRug, "Plot the shapes along the vertical axis");
            rowW = this.addChart(rowW, "Scatter3D", beachParty.fnChartPickerScatter3d, "Plot data in X, Y, and Z", "Scatter-3D");
            rowW = this.addChart(rowW, "Bar", beachParty.fnChartPickerBar, "Organize shapes into horizontal bars");
            rowW = this.addChart(rowW, "Violin", beachParty.fnChartPickerViolin, "Organize shapes into X and Y bins, with width of bins representing the count");
            rowW = this.addChart(rowW, "AggColumn", beachParty.fnChartPickerAggColumn, "View data in an ggregated form");
            rowW = this.addChart(rowW, "Custom", beachParty.fnChartPickerCustom, "Build a custom chart");
            this._app.registerForChange("chart", function (e) {
                _this.changeSelectedChart();
            });
            beachParty.matchIconsToTheme(this._app._themeMgr, this._root);
        }
        chartPickerClass.prototype.getChartElemByName = function (name) {
            var elemX = null;
            var elemsW = vp.select(".chartPickerEntry");
            elemsW.each(function (index, elem) {
                if (elem.returnName == name) {
                    elemX = elem;
                    return false;
                }
            });
            return elemX;
        };
        chartPickerClass.prototype.changeSelectedChart = function () {
            var chart = this._app.currentChart();
            var value = chart.getUiChartName();
            if (this._selectedChartElem) {
                vp.select(this._selectedChartElem)
                    .attr("data-selected", "false");
            }
            this._selectedChartElem = this.getChartElemByName(value);
            if (this._selectedChartElem) {
                vp.select(this._selectedChartElem)
                    .attr("data-selected", "true");
            }
        };
        chartPickerClass.prototype.addChart = function (rowW, title, imgSrc, tooltip, valueText) {
            var _this = this;
            var propName = "is" + title + "Enabled";
            var settings = this._app._appSettingsMgr;
            var chartsPerRow = 4;
            var isEnabled = settings[propName]();
            if (isEnabled) {
                var startNewRow = (rowW[0].children.length >= chartsPerRow);
                if (startNewRow) {
                    var tableW = vp.select(rowW[0].parentNode);
                    //---- spacing row ----
                    var rowW = tableW.append("tr")
                        .css("height", "10px");
                    rowW = tableW.append("tr");
                }
                if (!valueText) {
                    valueText = title;
                }
                var tdW = rowW.append("td")
                    .addClass("chartPickerEntry")
                    .title(tooltip)
                    .attach("click", function (e) {
                    _this.onClick(e);
                });
                var imgW = tdW.append("img")
                    .addClass("clickIcon chartPickerImage")
                    .css("width", "80px")
                    .css("pointer-events", "none")
                    .attach("dragstart", function (e) {
                    //---- prevent drag of icon ----
                    e.preventDefault();
                });
                beachParty.setIconName(this._app._themeMgr, imgW[0], imgSrc, "bigBarPanel");
                var titleW = tdW.append("div")
                    .addClass("chartPickerTitle")
                    .text(title);
                if (this._currentChart == title) {
                    tdW.attr("data-selected", "true");
                    this._selectedChartElem = tdW[0];
                }
                tdW[0].returnName = valueText;
            }
            return rowW;
        };
        chartPickerClass.prototype.onClick = function (e) {
            var elem = e.target;
            if (!elem.returnName) {
                elem = elem.parentNode;
            }
            this._callback(elem.returnName);
            this.onUserAction(null, true, beachParty.Gesture.select, beachParty.ElementType.picklist, "chartType");
        };
        chartPickerClass.prototype.close = function () {
            this._callback = null;
            this._currentChart = null;
            _super.prototype.close.call(this);
        };
        return chartPickerClass;
    }(beachParty.basePanelClass));
    beachParty.chartPickerClass = chartPickerClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    scrubberDialog.ts - popup panel for data scrubbing.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var scrubberDialogClass = (function (_super) {
        __extends(scrubberDialogClass, _super);
        function scrubberDialogClass(app, origColInfos, colInfos) {
            var _this = this;
            _super.call(this, app, "scrubberDialog", true, null, "Data Scrubber", null, null);
            this._showOnlyVisible = false;
            this._searchText = null;
            this._selectedEditItem = null;
            this._listItemElems = [];
            this._resetValueMapsWhenLoaded = false;
            this._selectedValueIndex = -1;
            //---- hide panel while we build it's controls ----
            this.show(false);
            //---- reset "display" so layout calculations can take take place (visibility=hidden) ----
            vp.select(this.getRootElem()).css("display", "");
            this._app = app;
            this._origColInfos = origColInfos;
            this._startingColInfos = colInfos;
            var rootW = vp.select(this._contentRow);
            var maxHeight = 125;
            var panelTableW = rootW.append("table")
                .css("border-bottom", "1px solid gray");
            var panelRow = panelTableW.append("tr");
            //---- add LEFT PANEL ----
            var leftPanelW = panelRow.append("td")
                .css("border-right", "1px solid gray");
            //---- add RIGHT PANEL ----
            var rightPanelW = panelRow.append("td")
                .css("width", "200px")
                .attr("valign", "top");
            //---- add TABS to right panel ----
            var tabsHolderW = rightPanelW.append("div")
                .addClass("tabButtonContainer");
            //---- PROPERTIES tab ----
            var propsW = tabsHolderW.append("span")
                .addClass("tabButton")
                .text("Properties")
                .id("properties")
                .title("View or Edit the properties of the column")
                .attach("click", function (e) {
                _this.onTabSelected(e.target);
            });
            //---- VALUES tab ----
            var valuesW = tabsHolderW.append("span")
                .addClass("tabButton")
                .text("Values")
                .id("values")
                .title("View or Edit the values of the column")
                .attach("click", function (e) {
                _this.onTabSelected(e.target);
            });
            var divW = rightPanelW.append("div")
                .css("height", "254px") // keep constant height (as content height changes)
                .css("width", "290px");
            this.addPropertyControls(divW, "propertiesContent");
            this.addValueControls(divW, "valuesContent");
            //---- RESET button ----
            var resetW = rightPanelW.append("td").append("span")
                .addClass("panelButton")
                .text("Reset column")
                .title("Remove all scrubbing for this column")
                .css("float", "right")
                .attach("click", function (e) {
                _this.resetColumn(_this._selectedEditItem);
            });
            //---- make the first tab active ----
            this.onTabSelected(propsW[0]);
            this.buildLeftPanel(leftPanelW);
            this.addOkCancelButtons(rootW);
            this.isFloating(true);
            this.centerPanel();
            this.show(true);
        }
        scrubberDialogClass.prototype.buildLeftPanel = function (leftPanelW) {
            this.addSearchBox(leftPanelW);
            this.addShowOnlyCheckbox(leftPanelW);
            //---- add LISTBOX ----
            var listW = leftPanelW.append("div")
                .addClass("listBox")
                .attr("size", "5")
                .css("overflow-y", "auto")
                .css("overflow-x", "none")
                .css("width", "220px")
                .css("border", "1px solid gray")
                .css("margin", "6px")
                .css("height", "200px"); // fix height to avoid resizing dialog when toggle VISIBLE filter
            //var listW = listW.append("div")
            //    .addClass("listBoxList")
            this._listElem = listW[0];
            this.buildEditColInfos(false);
            this.buildListBoxItems();
            this.addBottomButtons(leftPanelW);
        };
        scrubberDialogClass.prototype.onTabSelected = function (tabButton) {
            //---- hide current tab content ----
            if (this._currentTabContentElem) {
                vp.select(this._currentTabContentElem)
                    .css("display", "none");
                vp.select(this._currentTabButtonElem)
                    .removeClass("tabButtonOpen");
                this._currentTabContentElem = null;
                this._currentTabButtonElem = null;
            }
            //---- make new tab content visible ----
            var buttonId = tabButton.id;
            var contentId = buttonId + "Content";
            var tabContentW = vp.select("#" + contentId);
            if (tabContentW.length) {
                tabContentW
                    .css("display", ""); // makes it default to visible
                var tabButtonW = vp.select("#" + buttonId)
                    .addClass("tabButtonOpen");
                this._currentTabContentElem = tabContentW[0];
                this._currentTabButtonElem = tabButtonW[0];
            }
        };
        scrubberDialogClass.prototype.addValueControls = function (rootW, id) {
            var _this = this;
            var divW = rootW.append("div")
                .css("margin", "10px")
                .attr("id", id)
                .css("max-height", "254px")
                .css("overflow-y", "auto")
                .css("display", "none") // hide initially
                .css("white-space", "nowrap");
            //---- up/down holder ----
            var upDownW = divW.append("div");
            //---- add DOWN button ----
            var upW = upDownW.append("span")
                .addClass("panelButton")
                .id("downButton")
                .css("float", "right")
                .css("margin-right", "10px")
                .css("margin-bottom", "5px")
                .html("&#8595;") // down arrow
                .title("Move the selected value down")
                .attach("click", function (e) {
                _this.moveSelectedValue(1);
            });
            //---- add UP button ----
            var upW = upDownW.append("span")
                .addClass("panelButton")
                .id("upButton")
                .css("float", "right")
                .html("&#8593;") // up arrow
                .title("Move the selected value up")
                .attach("click", function (e) {
                _this.moveSelectedValue(-1);
            });
            var tableW = divW.append("table")
                .css("border-collapse", "collapse");
            this._valuesTableElem = tableW[0];
        };
        scrubberDialogClass.prototype.onSelectedValueChanged = function () {
            var upDisabled = (this._selectedValueIndex <= 0);
            var downDisabled = (this._selectedValueIndex == -1);
            if ((!downDisabled) && this._selectedEditItem && this._selectedEditItem.stats.sortedKeys) {
                downDisabled = (this._selectedValueIndex >= this._selectedEditItem.stats.sortedKeys.length - 1);
            }
            vp.select(this._root, "#upButton")
                .attr("data-disabled", upDisabled ? "true" : "false");
            vp.select(this._root, "#downButton")
                .attr("data-disabled", downDisabled ? "true" : "false");
        };
        scrubberDialogClass.prototype.moveSelectedValue = function (delta) {
            if (this._selectedValueIndex != -1) {
                var fromIndex = this._selectedValueIndex;
                var sortedKeys = this._selectedEditItem.stats.sortedKeys;
                var toIndex = this._selectedValueIndex + delta;
                if (toIndex >= 0 && toIndex < sortedKeys.length) {
                    var value = sortedKeys[fromIndex];
                    sortedKeys.removeAt(fromIndex);
                    //if (delta < 0)
                    //{
                    //    toIndex--;
                    //}
                    sortedKeys.insert(toIndex, value);
                    this._selectedValueIndex = toIndex;
                    this.loadColumnValues(this._selectedEditItem, false);
                    this.onSelectedValueChanged();
                }
            }
        };
        scrubberDialogClass.prototype.addPropertyControls = function (rootW, id) {
            var _this = this;
            var tableW = rootW.append("table")
                .css("margin", "10px")
                .attr("id", id);
            //---- 2nd row ----
            var nextRowW = tableW.append("tr")
                .css("height", "30px");
            //---- prompt: DISPLAY ----
            var promptW = nextRowW.append("td")
                .addClass("panelPrompt")
                .text("Display:");
            //---- TEXT ----
            var displayW = nextRowW.append("td").append("input")
                .addClass("panelText")
                .attr("type", "text")
                .css("width", "100px")
                .attach("keyup", function (e) {
                _this._selectedEditItem.displayName = e.target.value;
            });
            this._displayElem = displayW[0];
            //---- 3nd row ----
            var nextRowW = tableW.append("tr");
            //---- prompt: TYPE ----
            var promptW = nextRowW.append("td")
                .addClass("panelPrompt")
                .text("Type:");
            //---- don't use HTML SELECT elements - they don't style well on Windows ----
            var tdW = nextRowW.append("td");
            var picker = new beachParty.pickerClass(this._app, tdW[0], null, ["string", "number", "date"], "string", "set how this column's values are recognized", false);
            picker.registerForChange("value", function (e) {
                var newType = picker.value();
                var selectedItem = _this._selectedEditItem;
                selectedItem.colType = newType;
                if (newType == "string") {
                    selectedItem.stats.min = null;
                    selectedItem.stats.max = null;
                }
                else {
                    selectedItem.stats.min = selectedItem.origCol.stats.min;
                    selectedItem.stats.max = selectedItem.origCol.stats.max;
                }
            });
            this._typeCombo = picker;
            //---- 4nd row ----
            var nextRowW = tableW.append("tr");
            //---- prompt: DESC ----
            var promptW = nextRowW.append("td")
                .addClass("panelPrompt")
                .text("Desc:")
                .attr("valign", "top");
            //---- TEXTAREA ----
            var textAreaW = nextRowW.append("td").append("textarea")
                .addClass("panelTextArea")
                .css("height", "80px")
                .attach("keyup", function (e) {
                _this._selectedEditItem.desc = e.target.value;
            });
            this._descElem = textAreaW[0];
            //---- 5nd row ----
            var nextRowW = tableW.append("tr")
                .css("height", "15px");
            var nextRowW = tableW.append("tr");
            var promptW = nextRowW.append("td");
        };
        scrubberDialogClass.prototype.resetColumn = function (ei) {
            //---- copy info from matching entry in colInfos ----
            var ci = ei.origCol;
            ei.displayName = ci.name;
            ei.colType = ci.colType;
            ei.desc = ci.desc;
            ei.stats.sortedKeys = vp.utils.copyArray(ci.stats.sortedKeys);
            this.resetValueMap(ei.valueMap);
            //ei.isVisible = true;
            this.loadColumnProps(ei);
            this.loadColumnValues(ei);
        };
        scrubberDialogClass.prototype.resetValueMap = function (vm) {
            //---- reset values in valueMap ----
            for (var i = 0; i < vm.length; i++) {
                var entry = vm[i];
                entry.newValue = entry.originalValue;
            }
        };
        scrubberDialogClass.prototype.addSearchBox = function (rootW) {
            var _this = this;
            //---- start new row ----
            var nextRowW = rootW.append("div")
                .css("margin-top", "10px")
                .css("margin-bottom", "10px")
                .css("margin-left", "10px");
            //---- SEARCH prompt ----
            var promptW = nextRowW.append("span")
                .addClass("panelPrompt")
                .text("Search:");
            //---- TEXTBOX ----
            var cbW = nextRowW.append("input")
                .attr("type", "text")
                .addClass("panelText")
                .title("Search for columns containing this text")
                .css("margin-left", "10px")
                .css("margin-right", "10px")
                .attach("focus", function (e) {
                //---- select all text on focus ----
                e.target.select();
            })
                .attach("keyup", function (e) {
                _this.doSearch(e);
            });
        };
        scrubberDialogClass.prototype.doSearch = function (e) {
            this._searchText = e.target.value.toLowerCase();
            this.buildListBoxItems();
        };
        scrubberDialogClass.prototype.addShowOnlyCheckbox = function (rootW) {
            var _this = this;
            //---- start new row ----
            var nextRowW = rootW.append("div")
                .css("margin-top", "10px")
                .css("margin-bottom", "10px")
                .title("when checked, only visible columns are shown in the list below")
                .attach("click", function (e) {
                _this.toggleShowFilter(e);
            });
            //---- add "show only visible columns" CHECKBOX ----
            var cbW = nextRowW.append("input")
                .attr("type", "checkbox")
                .addClass("panelCheckbox")
                .css("margin-left", "10px");
            var cbTextW = nextRowW.append("span")
                .addClass("panelPrompt")
                .text("Show only visible columns");
            nextRowW[0].checkBox = cbW[0];
        };
        scrubberDialogClass.prototype.addBottomButtons = function (rootW) {
            var _this = this;
            //---- start new row ----
            var nextRowW = rootW.append("div")
                .css("margin-top", "10px")
                .css("margin-bottom", "20px");
            //---- add SHOW ALL button ----
            var showAllW = nextRowW.append("span")
                .addClass("panelButton")
                .css("margin-left", "10px")
                .css("width", "55px")
                .text("Show All")
                .css("white-space", "nowrap")
                .title("Make all columns visible")
                .attach("click", function (e) {
                _this.showAllColumns(true);
            });
            //---- add HIDE ALL button ----
            var showAllW = nextRowW.append("span")
                .addClass("panelButton")
                .css("margin-left", "10px")
                .css("width", "55px")
                .text("Hide All")
                .title("Make all columns hidden")
                .attach("click", function (e) {
                _this.showAllColumns(false);
            });
            //---- add RESET button ----
            var resetW = nextRowW.append("span")
                .addClass("panelButton")
                .css("margin-left", "10px")
                .css("width", "55px")
                .text("Reset")
                .title("Remove all scrubbing and restore all columns to their original values")
                .attach("click", function (e) {
                _this.resetAllColumns();
            });
        };
        scrubberDialogClass.prototype.addOkCancelButtons = function (rootW) {
            var _this = this;
            //---- start dialog button row ----
            var buttonRowW = rootW.append("div")
                .css("margin-top", "10px")
                .css("margin-bottom", "10px");
            //---- add CANCEL button ----
            var okW = buttonRowW.append("span")
                .addClass("panelButton")
                .text("Cancel")
                .css("width", "55px")
                .css("margin-right", "10px")
                .css("margin-bottom", "10px")
                .css("float", "right")
                .attach("click", function (e) {
                _this.closeDialog(false);
            });
            //---- add OK button ----
            var okW = buttonRowW.append("span")
                .addClass("panelButton")
                .css("width", "55px")
                .css("margin-right", "10px")
                .text("OK")
                .css("float", "right")
                .attach("click", function (e) {
                _this.closeDialog(true);
            });
        };
        scrubberDialogClass.prototype.resetAllColumns = function () {
            this._selectedEditItem = null; // will select the first item when listBox is rebuilt
            this._resetValueMapsWhenLoaded = true;
            this.buildEditColInfos(true);
            this.buildListBoxItems();
        };
        scrubberDialogClass.prototype.showAllColumns = function (show) {
            var editInfos = this._editColInfos;
            for (var i = 0; i < editInfos.length; i++) {
                var ei = editInfos[i];
                ei.isVisible = show;
            }
            this.buildListBoxItems();
        };
        scrubberDialogClass.prototype.buildEditColInfos = function (resetColumns) {
            //---- we need to start with origColInfos, and then apply any changes from SCRUBBED input=colInfos ----
            var newInfos = [];
            var editMap = {};
            //---- first, build list using origColInfos ----
            for (var i = 0; i < this._origColInfos.length; i++) {
                var gi = this._origColInfos[i];
                var stats = gi.stats;
                var newCi = new editColInfo(gi.name, gi.desc, gi.colType, vp.utils.copyArray(stats.sortedKeys), stats.min, stats.max);
                newCi.isVisible = resetColumns;
                newCi.origCol = gi;
                newInfos.push(newCi);
                editMap[gi.name] = i;
            }
            if (!resetColumns) {
                //---- now, update the list using colInfos ----
                for (var i = 0; i < this._startingColInfos.length; i++) {
                    var si = this._startingColInfos[i];
                    //---- find matching item in our list ----
                    var index = editMap[si.name];
                    if (index === undefined) {
                        //---- if this a renamed field? ----
                        index = editMap[si.calcFieldExp];
                    }
                    if (index !== undefined) {
                        var newCi = newInfos[index];
                        newCi.isVisible = true;
                        newCi.colType = si.colType;
                        if (si.calcFieldExp) {
                            newCi.displayName = si.name;
                        }
                        /// during initialization, we set this "sortedKeysNeedsOrigValues" flag to true
                        /// so that we can update the values when the valueMap for this column has been loaded.
                        newCi.stats.sortedKeys = si.stats.sortedKeys;
                        newCi.sortedKeysNeedsOrigValues = (si.stats.sortedKeys != null);
                    }
                }
            }
            this._editColInfos = newInfos;
        };
        scrubberDialogClass.prototype.closeDialog = function (keepChanges) {
            if (keepChanges) {
                this.onDataChanged("ok");
            }
            this.close();
        };
        scrubberDialogClass.prototype.buildListBoxItems = function () {
            var _this = this;
            var cbList = [];
            var editInfos = this._editColInfos;
            var listW = vp.select(this._listElem);
            var foundSelectedItem = false;
            var eiFirstAdded = null;
            listW.clear();
            for (var i = 0; i < editInfos.length; i++) {
                var ei = editInfos[i];
                //---- apply showOnly filter ----
                var add = (ei.isVisible || !this._showOnlyVisible);
                //---- apply search filter ----
                if (add && this._searchText) {
                    var name = ei.name.toLowerCase();
                    add = name.contains(this._searchText);
                }
                if (add) {
                    if (!eiFirstAdded) {
                        eiFirstAdded = ei;
                    }
                    var itemW = listW.append("div")
                        .addClass("checkboxItem")
                        .attach("click", function (e) {
                        _this.toggleItem(e);
                    });
                    var checkboxW = itemW.append("input")
                        .attr("type", "checkbox")
                        .addClass("panelCheckbox");
                    if (ei.isVisible) {
                        checkboxW
                            .attr("checked", "true");
                    }
                    var promptW = itemW.append("span")
                        .addClass("checkboxText")
                        .text(ei.name)
                        .css("position", "relative")
                        .css("top", "-2px");
                    cbList.push(itemW[0]);
                    itemW[0].checkBox = checkboxW[0];
                    itemW[0].prompt = promptW[0];
                    itemW[0].editInfo = ei;
                    if (ei == this._selectedEditItem) {
                        this.markItemSelected(itemW[0], true);
                        this.loadColumnProps(ei);
                        this.loadColumnValues(ei);
                        foundSelectedItem = true;
                    }
                }
            }
            this._listItemElems = cbList;
            //--- make sure something is always selected ----
            if (!foundSelectedItem) {
                if (eiFirstAdded) {
                    this.selectItem(eiFirstAdded);
                }
                else {
                    this.loadColumnProps(null);
                    this.loadColumnValues(null);
                }
            }
        };
        scrubberDialogClass.prototype.toggleShowFilter = function (e) {
            var elem = e.target;
            var isCheckbox = (elem.tagName == "INPUT");
            if (!elem.checkBox) {
                //---- try parent ----
                elem = elem.parentNode;
            }
            //---- ignore event from checkbox ----
            if (!isCheckbox) {
                if (elem.checkBox) {
                    elem.checkBox.checked = (!elem.checkBox.checked);
                }
                vp.events.cancelEventBubble(e);
                vp.events.cancelEventDefault(e);
            }
            this._showOnlyVisible = elem.checkBox.checked;
            this.buildListBoxItems();
        };
        scrubberDialogClass.prototype.markItemSelected = function (itemElem, isSelected) {
            //---- mark parent ----
            itemElem.setAttribute("data-isSelected", (isSelected) ? "true" : "false");
            //---- mark prompt ----
            itemElem.prompt.setAttribute("data-isSelected", (isSelected) ? "true" : "false");
        };
        /** find the HTML elem (div) that represents the specified ei. */
        scrubberDialogClass.prototype.getItemElem = function (ei) {
            var elem = null;
            for (var i = 0; i < this._listItemElems.length; i++) {
                var itemElem = this._listItemElems[i];
                if (itemElem.editInfo == ei) {
                    elem = itemElem;
                    break;
                }
            }
            return elem;
        };
        scrubberDialogClass.prototype.selectItem = function (editItem) {
            //---- turn off selection on current item ----
            if (this._selectedEditItem) {
                var item = this.getItemElem(this._selectedEditItem);
                if (item) {
                    this.markItemSelected(item, false);
                }
            }
            this._selectedEditItem = editItem;
            //---- turn on selection on new item ----
            if (editItem) {
                var item = this.getItemElem(editItem);
                this.markItemSelected(item, true);
            }
            this.loadColumnProps(editItem);
            this.loadColumnValues(editItem);
        };
        scrubberDialogClass.prototype.loadColumnProps = function (ei) {
            if (ei == null) {
                vp.select(this._displayElem).value("");
                this._typeCombo.value("string");
                vp.select(this._descElem).value("");
            }
            else {
                var colTypes = ["string", "number", "date"];
                vp.select(this._displayElem).value(ei.displayName);
                this._typeCombo.value(ei.colType);
                vp.select(this._descElem).value(ei.desc);
            }
        };
        scrubberDialogClass.prototype.loadColumnValues = function (ei, resetSelection) {
            var _this = this;
            if (resetSelection === void 0) { resetSelection = true; }
            var table = this._valuesTableElem;
            if (resetSelection) {
                this._selectedValueIndex = 0;
                this.onSelectedValueChanged();
            }
            //---- delete previous rows (except for header row) ----
            while (table.rows.length > 0) {
                table.deleteRow(table.rows.length - 1);
            }
            if (ei) {
                var valueMap = this._selectedEditItem.valueMap;
                if (valueMap) {
                    this.loadColumValuesFromValueMapInSortedKeysOrder(valueMap, table);
                }
                else {
                    //---- request valueMap from engine ----
                    var dataMgr = this._app.currentChart().getDataMgr();
                    var dataFrame = dataMgr.getDataFrame();
                    dataFrame.getValueMap(ei.name, scrubberDialogClass.maxRows, function (valueMap) {
                        if (_this._resetValueMapsWhenLoaded) {
                            _this.resetValueMap(valueMap);
                        }
                        _this.loadColumValuesFromValueMapInSortedKeysOrder(valueMap, table);
                    });
                }
            }
        };
        /** "keys" should be in "originalValue" value set. */
        scrubberDialogClass.prototype.sortValueMap = function (valueMap, keys) {
            var newMap = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                for (var j = 0; j < valueMap.length; j++) {
                    var entry = valueMap[j];
                    if (entry.originalValue == key) {
                        newMap.push(entry);
                        break;
                    }
                }
            }
            return newMap;
        };
        scrubberDialogClass.prototype.loadColumValuesFromValueMapInSortedKeysOrder = function (valueMap, table) {
            var _this = this;
            var selectedItem = this._selectedEditItem;
            if (selectedItem.sortedKeysNeedsOrigValues) {
                //---- set "valueMap" to unsorted values (will sort in code below) ----
                selectedItem.valueMap = valueMap;
                //---- this means we need to load them from startingCol
                var sortedKeys = selectedItem.stats.sortedKeys;
                for (var i = 0; i < sortedKeys.length; i++) {
                    var currKey = sortedKeys[i];
                    var origKey = this.getValueMapEntry(selectedItem, currKey, false);
                    if (origKey) {
                        sortedKeys[i] = origKey.originalValue;
                    }
                }
                selectedItem.sortedKeysNeedsOrigValues = false;
            }
            //---- always re-sort the value map (in case sortedKeys has changed) ----
            if (selectedItem.stats.sortedKeys) {
                //---- match order to sortedValues ----
                valueMap = this.sortValueMap(valueMap, selectedItem.stats.sortedKeys);
            }
            else {
                //---- build sortedKeys from valueMap ----
                selectedItem.stats.sortedKeys = valueMap.map(function (e) { return e.originalValue; });
            }
            selectedItem.valueMap = valueMap;
            var maxRows = scrubberDialogClass.maxRows;
            var tableW = vp.select(table);
            maxRows = Math.min(maxRows, valueMap.length);
            var valueRows = [];
            for (var i = 0; i < maxRows; i++) {
                var vme = valueMap[i];
                var trW = tableW.append("tr")
                    .addClass("listItem")
                    .attach("click", function (e) { return _this.onValueRowClick(e); });
                if (this._selectedValueIndex == i) {
                    trW.attr("data-selected", "true");
                }
                else {
                    trW.attr("data-selected", "false");
                }
                //---- add COLUMN VALUES ----
                trW.append("td")
                    .addClass("tableValue")
                    .text(vme.originalValue)
                    .css("text-align", "right");
                trW.append("td")
                    .addClass("tableValue")
                    .text("(" + vme.valueCount + ")")
                    .css("padding-left", "4px")
                    .css("padding-right", "4px");
                var newValueW = trW.append("td")
                    .addClass("tableValue")
                    .css("padding-left", "4px");
                //.css("padding-right", "4px")
                var newValue = (vme.newValue) ? vme.newValue : vme.originalValue;
                var textboxW = newValueW.append("input")
                    .attr("type", "text")
                    .addClass("panelText")
                    .value(newValue)
                    .attach("focus", function (e) {
                    //---- select all text on focus ----
                    e.target.select();
                    //this.selectValue(e.target.valueIndex);
                })
                    .attach("keyup", function (e) {
                    _this.onValueEdited(e);
                });
                textboxW[0].valueIndex = i;
                trW[0].valueIndex = i;
                valueRows.push(trW[0]);
            }
            this._valueRows = valueRows;
        };
        scrubberDialogClass.prototype.onValueRowClick = function (e) {
            var elem = e.target;
            while (elem && elem.valueIndex === undefined) {
                elem = elem.parentNode;
            }
            this.selectValue(elem.valueIndex);
        };
        scrubberDialogClass.prototype.selectValue = function (index) {
            if (this._selectedValueIndex != -1) {
                vp.select(this._valueRows[this._selectedValueIndex])
                    .attr("data-selected", "false");
            }
            this._selectedValueIndex = index;
            if (index > -1) {
                vp.select(this._valueRows[index])
                    .attr("data-selected", "true");
            }
            this.onSelectedValueChanged();
        };
        scrubberDialogClass.prototype.onValueEdited = function (e) {
            var valueMap = this._selectedEditItem.valueMap;
            if (valueMap) {
                var valueIndex = e.target.valueIndex;
                var entry = valueMap[valueIndex];
                if (entry) {
                    entry.newValue = e.target.value;
                }
            }
        };
        scrubberDialogClass.prototype.toggleItem = function (e) {
            var elem = e.target;
            var isCheckbox = (elem.tagName == "INPUT");
            if (!elem.checkBox) {
                //---- try parent ----
                elem = elem.parentNode;
            }
            this.selectItem(elem.editInfo);
            var isVisible = elem.checkBox.checked;
            elem.editInfo.isVisible = isVisible;
        };
        scrubberDialogClass.prototype.getEditInfos = function () {
            this.updatedAllSortedKeysToNewValues();
            return this._editColInfos;
        };
        scrubberDialogClass.prototype.updatedAllSortedKeysToNewValues = function () {
            for (var i = 0; i < this._editColInfos.length; i++) {
                var ei = this._editColInfos[i];
                this.updateColSortedKeysToNewValues(ei);
            }
        };
        scrubberDialogClass.prototype.updateColSortedKeysToNewValues = function (ei) {
            if (ei.stats.sortedKeys) {
                for (var i = 0; i < ei.stats.sortedKeys.length; i++) {
                    var mapEntry = this.getValueMapEntry(ei, ei.stats.sortedKeys[i]);
                    if (mapEntry && mapEntry.newValue) {
                        ei.stats.sortedKeys[i] = mapEntry.newValue;
                    }
                }
            }
        };
        scrubberDialogClass.prototype.getValueMapEntry = function (ei, value, matchOrig) {
            if (matchOrig === void 0) { matchOrig = true; }
            var mapEntry = null;
            if (ei.valueMap) {
                for (var i = 0; i < ei.valueMap.length; i++) {
                    var entry = ei.valueMap[i];
                    var matchValue = (matchOrig || entry.newValue === undefined) ? entry.originalValue : entry.newValue;
                    if (matchValue == value) {
                        mapEntry = ei.valueMap[i];
                        break;
                    }
                }
            }
            return mapEntry;
        };
        scrubberDialogClass.maxRows = 9;
        return scrubberDialogClass;
    }(beachParty.basePanelClass));
    beachParty.scrubberDialogClass = scrubberDialogClass;
    /** these fields represent the column properties and values that can be changed in this dialog. */
    var editColInfo = (function (_super) {
        __extends(editColInfo, _super);
        function editColInfo(name, desc, colType, sortedKeys, min, max) {
            _super.call(this, name, desc, colType);
            this.stats = new beachParty.ColStats(min, max);
            this.isVisible = true;
            this.displayName = name;
            this.valueMap = null;
            this.sortedKeysNeedsOrigValues = false;
        }
        return editColInfo;
    }(beachParty.ColInfo));
    beachParty.editColInfo = editColInfo;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    insightMgr.ts - manages the insight instances & UI for the BeachParty app.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var nextInsightId = 1;
    var insightMgrClass = (function (_super) {
        __extends(insightMgrClass, _super);
        function insightMgrClass(app) {
            _super.call(this);
            this._isShowingInsightsPanel = false;
            this._currentInsight = null;
            this._currentInsightIndex = -1;
            this._currentInsightReason = null;
            this._currentPanel = null;
            this._editInsight = null; // the insight being edited
            this._contextMenu = null;
            this._rebuildTimer = null;
            this._forceShow = false;
            //_currentInsightElem = null;
            this._insightEntryElems = [];
            this._editSessionName = null;
            this._sessionName = "untitled";
            this._pendingDropText = null;
            this._playWithAnimation = true;
            this._wasPaused = false;
            //---- auto playback ----
            this._playbackIndex = -1;
            this._playbackTimer = null;
            this._isPlayingBack = false;
            this._isPaused = false;
            this._playbackDuration = 3; // 3 seconds
            this._isLooping = true; // should playback restart once end is reached
            this._app = app;
            this._session = new InsightSession();
            this.adjustPanelWidth();
        }
        insightMgrClass.prototype.adjustPanelWidth = function () {
            var theme = this._app._themeMgr.getTheme();
            var panelWidth = theme.propMap.insightPanelWidth;
            vp.select("#insightPanel").css("width", panelWidth + "px");
            this._panelWidth = panelWidth;
            this._insightWidth = Math.max(1, panelWidth - 23);
            this._insightHeight = Math.max(1, Math.round(.65 * this._insightWidth));
        };
        insightMgrClass.prototype.closeMenus = function () {
            if (this._contextMenu) {
                this._contextMenu.close();
                this._contextMenu = null;
            }
        };
        insightMgrClass.prototype.createEnumPicker = function (enumType, callback) {
            var picker = null;
            if (enumType == beachParty.LoadAction) {
                picker = this.createLoadActionMenu(callback);
            }
            else {
                picker = this._app.createEnumPicker(null, enumType, callback);
            }
            return picker;
        };
        insightMgrClass.prototype.playbackDuration = function (value) {
            if (arguments.length === 0) {
                return this._playbackDuration;
            }
            this._playbackDuration = value;
            this.onDataChanged("playbackDuration");
        };
        insightMgrClass.prototype.isPlaybackLooping = function (value) {
            if (arguments.length === 0) {
                return this._isLooping;
            }
            this._isLooping = value;
            this.onDataChanged("isPlaybackLooping");
        };
        insightMgrClass.prototype.getCurrentInsightReason = function () {
            return this._currentInsightReason;
        };
        insightMgrClass.prototype.currentInsight = function (value, reason) {
            if (arguments.length == 0) {
                return this._currentInsight;
            }
            //---- this is quicker than rebuilding insight bar, and preserves insight elements for consistent event handling ("click"). ----
            if (this._currentInsight) {
                this.setInsightAsCurrent(this._currentInsight, false);
            }
            this._currentInsight = value;
            this._currentInsightIndex = this._session.insights.indexOf(value);
            this._currentInsightReason = reason;
            if (this._currentInsight) {
                this.setInsightAsCurrent(this._currentInsight, true);
            }
            this.onDataChanged("currentInsight");
        };
        insightMgrClass.prototype.setInsightAsCurrent = function (insight, value) {
            for (var i = 0; i < this._insightEntryElems.length; i++) {
                var elem = this._insightEntryElems[i];
                if (elem && elem.insightObj == insight) {
                    if (value) {
                        vp.dom.addClass(elem, "currentEntry");
                    }
                    else {
                        vp.dom.removeClass(elem, "currentEntry");
                    }
                }
            }
        };
        insightMgrClass.prototype.editSessionName = function (value) {
            if (arguments.length == 0) {
                return this._editSessionName;
            }
            this._editSessionName = value;
            this.onDataChanged("editSessionName");
        };
        insightMgrClass.prototype.editInsightName = function (value) {
            if (arguments.length == 0) {
                return (this._editInsight) ? this._editInsight.name : "";
            }
            if (this._editInsight) {
                this._editInsight.name = value;
                this.onDataChanged("editInsightName");
            }
        };
        insightMgrClass.prototype.editInsightNotes = function (value) {
            if (arguments.length == 0) {
                return (this._editInsight) ? this._editInsight.notes : "";
            }
            if (this._editInsight && this._editInsight.notes != value) {
                this._editInsight.notes = value;
                this.onDataChanged("editInsightNotes");
            }
        };
        insightMgrClass.prototype.loadAction = function (value) {
            if (arguments.length == 0) {
                var action = (this._editInsight) ? beachParty.LoadAction[this._editInsight.loadAction] : "";
                action = action || "none";
                return action;
            }
            if (this._editInsight) {
                this._editInsight.loadAction = beachParty.LoadAction[value];
                this.onDataChanged("loadAction");
            }
        };
        insightMgrClass.prototype.notesSource = function (value) {
            if (arguments.length == 0) {
                return (this._editInsight) ? beachParty.NotesSource[this._editInsight.notesSource] : "";
            }
            if (this._editInsight) {
                this._editInsight.notesSource = beachParty.NotesSource[value];
                this.onDataChanged("notesSource");
            }
        };
        //isNotesMarkDown(value?: boolean)
        //{
        //    if (arguments.length == 0)
        //    {
        //        return (this._editInsight) ? this._editInsight.isNotesMarkDown : null;
        //    }
        //    if (this._editInsight)
        //    {
        //        this._editInsight.isNotesMarkDown = value;
        //        this.onDataChanged("isNotesMarkDown");
        //    }
        //}
        insightMgrClass.prototype.addNewInsight = function (insight) {
            //---- defaults ----
            var text = "Insight-" + nextInsightId++;
            //---- name has been captured already as chartTitle ----
            //insight.name = text;         
            insight.notes = "";
            if (this._pendingDropText) {
                insight.notes = this._pendingDropText;
                this._pendingDropText = null;
            }
            //---- invoke "Insight Panel" here to supply text/notes ----
            //this.openAddInsightPanel(insight, (insight) => 
            //{
            //    this.addInsight(insight);
            //});
            //---- let user create these without interruption ----
            this.addInsight(insight);
        };
        insightMgrClass.prototype.showInsightButtonContextMenu = function (e) {
            var _this = this;
            //---- invoke the INSIGHTS CONTEXT MENU ----
            var menuItems = this.getInsightsMenuItems();
            var pm = new beachParty.popupMenuClass(this._app, null, "pmInsights", menuItems, function (e, menu, textIndex, menuIndex) {
                var name = menuItems[menuIndex].text;
                if (name.startsWith("Add insight")) {
                    _this.onDataChanged("onAddInsightRequest", undefined, e);
                }
                else if (name.startsWith("Toggle")) {
                    _this.toggleInsightsPanel();
                }
                else if (name.startsWith("Play")) {
                    _this.startPlayback(true);
                }
                else if (name.startsWith("Stop")) {
                    _this.stopPlayback();
                }
                else if (name == "Delete all insights") {
                    _this.deleteAllInsights();
                    _this._app.logAction(beachParty.Gesture.click, "deleteAll", beachParty.ElementType.menuItem, beachParty.Action.delete, beachParty.Target.insights, false, null, true);
                }
                else if (name.startsWith("Export insights")) {
                    _this.saveInsights();
                    _this._app.logAction(beachParty.Gesture.click, "export", beachParty.ElementType.menuItem, beachParty.Action.export, beachParty.Target.insights, false, null, true);
                }
                else if (name.startsWith("Email insights")) {
                    _this.emailInsights();
                    _this._app.logAction(beachParty.Gesture.click, "email", beachParty.ElementType.menuItem, beachParty.Action.email, beachParty.Target.insights, false, null, true);
                }
                else if (name.startsWith("Publish insights")) {
                    _this.publishInsights();
                    _this._app.logAction(beachParty.Gesture.click, "publish", beachParty.ElementType.menuItem, beachParty.Action.publish, beachParty.Target.insights, false, null, true);
                }
                else if (name.startsWith("Import insights")) {
                    _this.loadInsights();
                    _this._app.logAction(beachParty.Gesture.click, "import", beachParty.ElementType.menuItem, beachParty.Action.import, beachParty.Target.insights, false, null, true);
                }
                else if (name.startsWith("Load QuickTest")) {
                    _this.loadQuickTest();
                }
                else if (name.startsWith("Take snapshot")) {
                    _this._app.onSnapshotClick(e);
                    _this._app.logAction(beachParty.Gesture.click, "snapshot", beachParty.ElementType.menuItem, beachParty.Action.capture, beachParty.Target.snapshot, false, null, true);
                }
                else if (name.startsWith("Export data")) {
                    _this._app.onExportData(e);
                    _this._app.logAction(beachParty.Gesture.click, "export", beachParty.ElementType.menuItem, beachParty.Action.export, beachParty.Target.data, false, null, true);
                }
            }, true);
            var rc = vp.select("#insightMenuButton").getBounds(false);
            pm.setDockedTheme(true);
            pm.showAt(rc.left + 8, rc.bottom);
            this._contextMenu = pm;
            return pm;
        };
        insightMgrClass.prototype.onInsightEntryClick = function (e) {
            var insight = e.target.insightObj;
            if (!insight) {
                insight = e.target.parentElement.insightObj;
            }
            this.loadInsight(insight, "load");
            this._app.logAction(beachParty.Gesture.click, "insightEntry", beachParty.ElementType.insightEntry, beachParty.Action.load, beachParty.Target.insight, false, null, true);
        };
        insightMgrClass.prototype.markRebuildNeeded = function (forceShow) {
            var _this = this;
            var isBarVisible = this._app.isVisible("insightPanel");
            var isPlaying = this._isPlayingBack;
            //---- avoid rebuilds during presentation mode ----
            if (!isPlaying && !this._rebuildTimer) {
                if (forceShow) {
                    this._forceShow = true;
                }
                this._rebuildTimer = setTimeout(function (e) {
                    _this._rebuildTimer = null;
                    _this.rebuildInsightBar();
                }, 100);
            }
        };
        insightMgrClass.prototype.showInsightContextMenu = function (e) {
            var _this = this;
            var insight = e.target.insightObj;
            if (!insight) {
                insight = e.target.parentElement.insightObj;
            }
            //---- invoke the INSIGHTS CONTEXT MENU ----
            var menuItems = this.getInsightEntryMenuItems();
            var pm = new beachParty.popupMenuClass(this._app, null, "pmEntryInsights", menuItems, function (e, menu, textIndex, menuIndex) {
                var name = menuItems[menuIndex].text;
                if (name == "Load") {
                    _this.loadInsight(insight, "load");
                    _this._app.logAction(beachParty.Gesture.click, "load", beachParty.ElementType.menuItem, beachParty.Action.load, beachParty.Target.insight, false, null, true);
                }
                else if (name == "Delete") {
                    _this.deleteInsight(insight);
                    _this._app.logAction(beachParty.Gesture.click, "delete", beachParty.ElementType.menuItem, beachParty.Action.delete, beachParty.Target.insight, false, null, true);
                }
                else if (name == "Recapture") {
                    _this.captureInsightEx(insight);
                    _this._app.logAction(beachParty.Gesture.click, "recapture", beachParty.ElementType.menuItem, beachParty.Action.capture, beachParty.Target.insight, false, { name: insight.name }, true);
                }
                else if (name == "Edit") {
                    _this.openEditInsightPanel(e, insight);
                    _this._app.logAction(beachParty.Gesture.click, "edit", beachParty.ElementType.menuItem, beachParty.Action.edit, beachParty.Target.insight, false, null, true);
                }
            }, true);
            var pt = vp.events.mousePosition(e);
            pm.setDockedTheme(true);
            //this.setContextMenu(pm);
            pm.showAt(pt.x, pt.y + 10);
            this._contextMenu = pm;
            //---- cancel event to prevent insight from being loaded ----
            vp.events.cancelEventBubble(e);
            vp.events.cancelEventDefault(e);
            return pm;
        };
        insightMgrClass.prototype.openEditInsightPanel = function (e, insight) {
            var _this = this;
            var pt = vp.events.mousePosition(e);
            //---- make a copy of the specified insight for editing (in case we cancel, this makes it easy to reverse the changes) ----
            this._editInsight = vp.utils.copyMap(insight);
            this._currentPanel = beachParty.buildJsonPanel(this._app, null, this, "editInsight", true, pt.x, pt.y, undefined, undefined, undefined, false);
            //---- support CLOSE of dialog as a cancel, so none of the properties changed are retained ----
            this._currentPanel.registerForChange("onAccept", function (e) {
                _this.updateInsightFromEditProps(insight);
                _this.markRebuildNeeded();
            });
        };
        insightMgrClass.prototype.captureInsightEx = function (insight) {
            var _this = this;
            var sessionIndex = this._session.insights.indexOf(insight);
            this._app.createInsight(beachParty.SnapshotType.chart, true, function (captInsight) {
                //---- transfer user properties from "insight" ----
                //captInsight.name = insight.name;
                captInsight.notes = insight.notes;
                captInsight.loadAction = insight.loadAction;
                captInsight.notesSource = insight.notesSource;
                //captInsight.isNotesMarkDown = insight.isNotesMarkDown;
                //---- replace "insight" with "captInsight" ----
                _this._session.insights[sessionIndex] = captInsight;
                _this.rebuildInsightBar();
            });
        };
        insightMgrClass.prototype.updateInsightFromEditProps = function (insight) {
            insight.name = this._editInsight.name;
            insight.notes = this._editInsight.notes;
            insight.loadAction = this._editInsight.loadAction;
            insight.notesSource = this._editInsight.notesSource;
            //insight.isNotesMarkDown = this._editInsight.isNotesMarkDown;
        };
        insightMgrClass.prototype.openAddInsightPanel = function (insight, callback) {
            //var pt = vp.events.mousePosition(e);
            var _this = this;
            //---- center panel horizontally ----
            var left = undefined; //window.innerWidth / 2 - xxx / 2;
            var top = 200;
            this._editInsight = insight;
            this._currentPanel = beachParty.buildJsonPanel(this._app, null, this, "addInsight", true, left, top, undefined, undefined, undefined, false);
            this._currentPanel.registerForChange("onAccept", function (e) {
                callback(_this._editInsight);
            });
            this._currentPanel.getRootElem().focus();
        };
        insightMgrClass.prototype.closeEditInsight = function () {
            if (this._currentPanel) {
                this._currentPanel.close();
                this._currentPanel = null;
            }
        };
        insightMgrClass.prototype.deleteInsight = function (insight) {
            this._session.insights.remove(insight);
            if (this._currentInsight == insight) {
                this.currentInsight(null, "deleted");
            }
            this.markRebuildNeeded();
        };
        insightMgrClass.prototype.loadInsight = function (insight, reason) {
            this.currentInsight(insight, reason);
            //---- change the outline ----
            this.markRebuildNeeded();
            this.onDataChanged("insightLoaded");
        };
        insightMgrClass.prototype.removeExt = function (fn) {
            var index = fn.indexOf(".");
            if (index > -1) {
                fn = fn.substr(0, index);
            }
            return fn;
        };
        insightMgrClass.prototype.loadInsights = function () {
            var _this = this;
            var settings = this._app._appSettingsMgr;
            beachParty.localFileHelper.loadFile(settings, insightMgrClass.fileExt, function (arrayBuff, fn) {
                var zip = new JSZip();
                zip.load(arrayBuff, undefined);
                _this.loadInsightsFromZipFile(zip, fn);
            });
        };
        insightMgrClass.prototype.loadSessionFromServer = function (sessionUrl, callback) {
            //var fn = this.getSharedServerRoot() + sessionId;
            var _this = this;
            beachParty.readSessionFile(sessionUrl, function (text) {
                var fn = beachParty.appUtils.getLastNodeOfUrl(sessionUrl);
                _this.loadInsightsFromText(text, fn);
                if (callback) {
                    callback();
                }
            });
        };
        insightMgrClass.prototype.loadInsightsFromText = function (text, fn) {
            try {
                var anyObj = JSON.parse(text);
                if (vp.utils.isArray(anyObj)) {
                    var session = new InsightSession();
                    session.version = .9;
                    session.insights = anyObj;
                }
                else {
                    var session = anyObj;
                    if (session.version < .9) {
                        throw "Error: invalid session file";
                    }
                }
                this._session = session;
                this._sessionName = this.removeExt(fn);
                this.markRebuildNeeded(true);
            }
            catch (ex) {
                alert("Error parsing session file: " + ex);
            }
        };
        insightMgrClass.prototype.loadInsightsFromZipFile = function (zip, fn) {
            try {
                var session = new InsightSession();
                session.version = .92;
                zip.filter(function (path, file) {
                    // relativePath == "readme.txt"
                    // file = {name:"dir/readme.txt",options:{...},asText:function}
                    vp.utils.debug("read zip: file=" + path);
                    if (path.endsWith(".json")) {
                        var jsonStr = file.asText();
                        var insightObj = JSON.parse(jsonStr);
                        var imgFilename = path.replace("views", "images");
                        imgFilename = imgFilename.replace(".json", ".png");
                        var imgFile = zip.file(imgFilename);
                        if (imgFile) {
                            var byteArray = imgFile.asUint8Array();
                            if (byteArray) {
                                //---- CAUTION: the timing here is a bit sketchy; may cause problems ----
                                var blobObject = new Blob([byteArray], { type: "image/png" });
                                var reader = new FileReader();
                                reader.onload = function (event) {
                                    var str = event.target.result;
                                    insightObj.imageAsUrl = str;
                                };
                                reader.readAsDataURL(blobObject);
                            }
                        }
                        session.insights.push(insightObj);
                    }
                    return false;
                });
                this._session = session;
                this._sessionName = this.removeExt(fn);
                this.markRebuildNeeded(true);
            }
            catch (ex) {
                alert("Error parsing insights file: " + fn);
            }
        };
        insightMgrClass.prototype.loadQuickTest = function () {
            var fn = "quickTest.insights";
            var arrayBuff = beachParty.fileAccess.readServerFileIntoArrayBuff("userResources/Tests/" + fn);
            var zip = new JSZip();
            zip.load(arrayBuff, undefined);
            this.loadInsightsFromZipFile(zip, fn);
        };
        insightMgrClass.prototype.saveInsights = function () {
            var _this = this;
            var zip = new JSZip();
            for (var i = 0; i < this._session.insights.length; i++) {
                var insight = this._session.insights[i];
                var name = insight.name;
                var imgUrl = insight.imageAsUrl;
                //---- for now, use a simple, unique name ----
                name = "i" + (1 + i);
                //---- remove image for this step ----
                insight.imageAsUrl = null;
                var jsonInsight = JSON.stringify(insight);
                insight.imageAsUrl = imgUrl;
                imgUrl = imgUrl.substr(imgUrl.indexOf(',') + 1);
                zip.file("views/" + name + ".json", jsonInsight);
                zip.file("images/" + name + ".png", imgUrl, { base64: true });
            }
            this.openSessionNamePanel(this._sessionName, function (sessionName) {
                _this._sessionName = sessionName;
                var blob = zip.generate({ type: "blob" });
                beachParty.localFileHelper.saveBlobToLocalFile(sessionName + insightMgrClass.fileExt, blob);
                //window.navigator.msSaveBlob(blob, "hello.zip");
                _this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.button, beachParty.Action.export, beachParty.Target.insights, false, { acceptedRename: true });
            });
        };
        insightMgrClass.prototype.emailInsights = function () {
            var contents = JSON.stringify(this._session);
            //---- save "str" to server and get back its URL ----
            //var fnBase = "@sr@" + Date.now();
            //var fn = this.getSharedServerRoot() + fnBase;
            var userName = "";
            var fn = "";
            beachParty.writeSessionFile(userName, fn, contents, function (sessionUrl) {
                var sessionId = sessionUrl;
                var aPath = beachParty.appPath();
                var url = "mailto:?" +
                    "subject=my insights" +
                    "&body=Here's a link to my SandDance insights: %0D%0A" + "%0D%0A" + "%09" +
                    aPath + "/BeachPartyApp.html?session=" + sessionId + "%0D%0A" + "%0D%0A";
                vp.select("#helperAnchor").attr("href", url);
                vp.select("#helperAnchor")[0].click();
            });
        };
        insightMgrClass.prototype.publishInsights = function () {
            var _this = this;
            var contents = JSON.stringify(this._session);
            //---- publish insights as webpage on server and get back its URL ----
            var userName = "";
            var fn = "";
            //---- show the PUBLISH panel ----
            var panel = beachParty.buildJsonPanel(this._app, null, this, "publishPanel", true, null, null, undefined, undefined, undefined, false);
            //---- support CLOSE of dialog as a cancel, so none of the properties changed are retained ----
            panel.registerForChange("onAccept", function (e) {
                beachParty.publishSessionToWebPage(userName, fn, contents, function (sessionUrl) {
                    var sessionId = sessionUrl;
                    //var aPath = appPath();
                    vp.utils.debug("publishInsights: new URL=" + sessionUrl);
                    window.open(sessionUrl, "_blank");
                    //---- log as not-undoable ----
                    _this._app.logAction(beachParty.Gesture.click, null, beachParty.ElementType.button, beachParty.Action.publish, beachParty.Target.insights, false, { acceptedNotice: true });
                });
            });
        };
        insightMgrClass.prototype.openSessionNamePanel = function (name, callback) {
            var _this = this;
            this.editSessionName(name);
            this._currentPanel = beachParty.buildJsonPanel(this._app, null, this, "editSessionName", true);
            this._currentPanel.registerForChange("onAccept", function (e) {
                callback(_this._editSessionName);
            });
        };
        insightMgrClass.prototype.processDroppedText = function (text) {
            if (!this._currentInsight) {
                this._pendingDropText = text;
                this.onDataChanged("onAddInsightRequest", undefined, null);
            }
            else {
                this._currentInsight.notes = this._currentInsight.notes + "\r\n" + text;
            }
        };
        insightMgrClass.prototype.deleteAllInsights = function () {
            this._session.insights = [];
            this._sessionName = "untitled";
            vp.select("#insightList")
                .clear();
            //this.showInsightBar(false);
            this.currentInsight(null, "new session");
        };
        insightMgrClass.prototype.startPlayback = function (useAnimation) {
            this._playWithAnimation = useAnimation;
            //---- do we have any insights to play? ----
            if (this._session.insights.length == 0) {
                //---- special case - just treat current view as the insight we are looping on ----
                this._isPlayingBack = true;
                this._playbackIndex = -1;
            }
            else {
                this.loadTimedInsight(0);
            }
            this._app.logAction(beachParty.Gesture.click, "play", beachParty.ElementType.button, beachParty.Action.play, beachParty.Target.insights, false, null, true);
            this.onPlayingChanged();
        };
        insightMgrClass.prototype.syncPlaybackWithCurrentInsight = function () {
            this._playbackIndex = this._currentInsightIndex;
        };
        insightMgrClass.prototype.isPlaying = function () {
            return this._isPlayingBack;
        };
        insightMgrClass.prototype.isPaused = function () {
            return (this._isPlayingBack && this._isPaused);
        };
        insightMgrClass.prototype.pausePlayback = function () {
            this._isPaused = true;
            if (this._playbackTimer) {
                clearTimeout(this._playbackTimer);
                this._playbackTimer = null;
            }
            this._app.logAction(beachParty.Gesture.click, "pause", beachParty.ElementType.button, beachParty.Action.pause, beachParty.Target.insights, false);
            this.onPlayingChanged(true);
        };
        insightMgrClass.prototype.resumePlayback = function () {
            this._isPaused = false;
            this._playWithAnimation = true;
            if (this._playbackIndex > -1) {
                this.loadTimedInsight(this._playbackIndex);
            }
            this._app.logAction(beachParty.Gesture.click, "resume", beachParty.ElementType.button, beachParty.Action.resume, beachParty.Target.insights, false, null, true);
            this.onPlayingChanged();
        };
        insightMgrClass.prototype.onPlayingChanged = function (wasPaused) {
            this._wasPaused = wasPaused;
            this.onDataChanged("playing");
        };
        insightMgrClass.prototype.stopPlayback = function (reachedEnd) {
            this._isPlayingBack = false;
            this._isPaused = false;
            if (this._playbackTimer) {
                clearTimeout(this._playbackTimer);
                this._playbackTimer = null;
            }
            if (!reachedEnd) {
                this._app.logAction(beachParty.Gesture.click, "stop", beachParty.ElementType.button, beachParty.Action.stop, beachParty.Target.insights, false, null, true);
            }
            this.onPlayingChanged();
        };
        insightMgrClass.prototype.loadTimedInsight = function (index) {
            var atEnd = (index >= this._session.insights.length);
            if (atEnd && this._isLooping) {
                index = 0;
            }
            if (index < this._session.insights.length) {
                this._isPlayingBack = true;
                this._playbackIndex = index;
                var insight = this._session.insights[index];
                if (insight) {
                    this.loadInsight(insight, "play load");
                }
            }
            else {
                this.stopPlayback(true);
            }
        };
        insightMgrClass.prototype.onInsightLoadCompleted = function () {
            var _this = this;
            if (this._isPlayingBack && this._playWithAnimation) {
                this._playbackTimer = setTimeout(function (e) {
                    _this.loadTimedInsight(_this._playbackIndex + 1);
                }, this._playbackDuration * 1000);
            }
        };
        //---- for playback without animation ----
        insightMgrClass.prototype.showNextInsight = function (delta, preventTimer) {
            var index = this._playbackIndex + delta;
            if (index >= 0 && index < this._session.insights.length) {
                if (preventTimer) {
                    this._playWithAnimation = false;
                }
                this.loadTimedInsight(index);
            }
        };
        insightMgrClass.prototype.toggleInsightsPanel = function () {
            this.adjustPanelWidth();
            this._isShowingInsightsPanel = (!this._isShowingInsightsPanel);
            var action = (this._isShowingInsightsPanel) ? beachParty.Action.open : beachParty.Action.close;
            this._app.logAction(beachParty.Gesture.click, "toggleInsight", beachParty.ElementType.button, action, beachParty.Target.insightPanel, false);
            this.showInsightBar(this._isShowingInsightsPanel);
            beachParty.appUtils.setButtonSelectedState(this._app._themeMgr, "insight", this._isShowingInsightsPanel, beachParty.fnInsights, beachParty.fnInsightsSelected);
        };
        insightMgrClass.prototype.isPanelOpen = function () {
            return this._isShowingInsightsPanel;
        };
        insightMgrClass.prototype.showInsightBar = function (value) {
            if (arguments.length == 0) {
                return this._isShowingInsightsPanel;
            }
            vp.select("#insightPanel").css("display", (value) ? "" : "none");
            //this.layoutScreen();
            this.onDataChanged("layout");
            if (!value) {
                this.currentInsight(null, "hide bar");
            }
            this._isShowingInsightsPanel = value;
            this.onDataChanged("showInsightBar");
        };
        insightMgrClass.prototype.getInsightsMenuItems = function () {
            var items = [
                new beachParty.MenuItemData("Import insights...", "Loads a set of insights from a file on your local machine"),
                //new MenuItemData("Load QuickTest", "Loads the insights used in the BeachParty team QuickTest"),
                new beachParty.MenuItemData("Export insights...", "Saves the current set of insights to a file on your local machine"),
                new beachParty.MenuItemData("-"),
                new beachParty.MenuItemData("Email insights...", "Sends a URL for the current set of insights to an email recepient"),
                new beachParty.MenuItemData("Publish insights", "Publish insights to a public webpage on the SandDance server"),
                new beachParty.MenuItemData("-"),
                new beachParty.MenuItemData("Take snapshot", "Saves a snapshot of the current view as a file on your local machine"),
                new beachParty.MenuItemData("Export data...", "Saves the data for the current view as a file on your local machine"),
                new beachParty.MenuItemData("-"),
                new beachParty.MenuItemData("Delete all insights", "Deletes all of the currently defined insights"),
            ];
            return items;
        };
        insightMgrClass.prototype.getInsightEntryMenuItems = function () {
            var items = [
                new beachParty.MenuItemData("Load", "Make this insight the current view"),
                new beachParty.MenuItemData("-"),
                new beachParty.MenuItemData("Edit", "Edit the name and notes for this insight"),
                new beachParty.MenuItemData("Recapture", "Recapture this insight from current view"),
                new beachParty.MenuItemData("-"),
                new beachParty.MenuItemData("Delete", "Delete this insight"),
            ];
            return items;
        };
        insightMgrClass.prototype.addInsight = function (insight) {
            this._session.insights.push(insight);
            this.currentInsight(insight, "new insight");
            var forceShow = (this._session.insights.length == 1); // first entry
            this.markRebuildNeeded(forceShow);
        };
        insightMgrClass.prototype.getInsightTooltip = function (insight) {
            var insightType = beachParty.LoadAction[insight.loadAction];
            if (insightType == "all" || insightType === undefined) {
                insightType = "full insight";
            }
            var tip = insight.name + " (" + insightType + ")\n" + insight.notes;
            return tip;
        };
        insightMgrClass.prototype.addInsightToBar = function (insight) {
            var _this = this;
            var insightBarW = vp.select("#insightList");
            var tip = this.getInsightTooltip(insight);
            //---- add DIV to hold this insight ---
            var insightW = insightBarW.append("div")
                .addClass("flexAuto insightEntry")
                .css("position", "relative")
                .title(tip)
                .width(this._insightWidth)
                .css("min-height", (this._insightHeight + 30) + "px") // need to use "min-height" here (vs. height) to get flexBox/scrolling to work correctly
                .attach("click", function (e) {
                _this.onInsightEntryClick(e);
            });
            //---- add top row of insight (icon + title + context menu button) ----
            var iconW = this.buildInsightTitleBar(insightW, insight);
            if (insight == this._currentInsight) {
                insightW.addClass("currentEntry");
            }
            var imageAsUrl = insight.imageAsUrl;
            if (!imageAsUrl) {
                //---- check for older version ----
                var anyPreload = insight.preload;
                imageAsUrl = anyPreload.imageAsUrl;
            }
            if (imageAsUrl) {
                var settings = this._app._appSettingsMgr;
                //---- add IMAGE ----
                var imgW = insightW.append("img")
                    .addClass("insightImage")
                    .css("margin-top", "-10px")
                    .attr("src", imageAsUrl)
                    .css("background", settings._canvasColor)
                    .width(this._insightWidth)
                    .height(this._insightHeight)
                    .attach("dragstart", function (e) {
                    //---- prevent drag of icon ----
                    e.preventDefault();
                });
            }
            insightW[0].insightObj = insight;
            iconW[0].entryElem = insightW[0];
            this._insightEntryElems.push(insightW[0]);
            beachParty.matchIconsToTheme(this._app._themeMgr, insightW[0]);
        };
        insightMgrClass.prototype.buildInsightTitleBar = function (parentW, insight) {
            var _this = this;
            var divW = parentW.append("div");
            var rc = divW.getBounds();
            var tableW = divW.append("table")
                .addClass("insightTitleBar")
                .css("width", "100%")
                .css("margin-top", "-10px");
            var rowW = tableW.append("tr");
            var iconUrl = this.getIconUrl(insight.loadAction);
            //---- insight ICON ----
            var tdW = rowW.append("td");
            var iconW = tdW.append("img")
                .id("insightTypeMenuButton")
                .addClass("clickIcon")
                .css("width", "22px")
                .css("height", "22px")
                .css("margin-left", "-6px")
                .css("margin-top", "2px")
                .attach("click", function (e) {
                _this.onIconClick(e);
            });
            beachParty.setIconName(this._app._themeMgr, iconW[0], iconUrl, "insightPanel", true);
            var maxTextWidth = rc.width - 80;
            //---- insight NAME ----
            var textW = rowW.append("td")
                .addClass("clipText insightText")
                .text(insight.name)
                .css("margin-left", "-10px")
                .css("max-width", maxTextWidth + "px")
                .attach("click", function (e) {
                _this.onInsightEntryClick(e);
            });
            iconW[0].insightObj = insight;
            textW[0].insightObj = insight;
            //---- context menu ICON ----
            var tdW = rowW.append("td")
                .css("text-align", "right");
            var icon2W = tdW.append("img")
                .id("insightContextMenuButton")
                .addClass("clickIcon")
                .css("width", "20px")
                .title("open context menu for this insight")
                .attach("click", function (e) {
                _this.showInsightContextMenu(e);
            });
            beachParty.setIconName(this._app._themeMgr, icon2W[0], beachParty.fnMenuBars, "insightPanel", true);
            icon2W[0].insightObj = insight;
            return iconW;
        };
        insightMgrClass.prototype.onIconClick = function (e) {
            var _this = this;
            var iconElem = e.target;
            var rc = vp.select(iconElem).getBounds(false);
            var insight = iconElem.insightObj;
            //---- show insight type menu ----
            var picker = this.createLoadActionMenu(function (mid) {
                //---- set loadAction for insight, based on selected item ----
                var action = mid.text.toLowerCase();
                insight.loadAction = beachParty.LoadAction[action];
                //---- update icon of insight in insight panel ----
                var iconUrl = _this.getIconUrl(insight.loadAction);
                //vp.select(iconElem).attr("src", iconUrl);
                beachParty.setIconName(_this._app._themeMgr, iconElem, iconUrl, "insightPanel", true);
                //---- update tooltip on entryElem ----
                var entryElem = iconElem.entryElem;
                var tip = _this.getInsightTooltip(insight);
                vp.select(entryElem).title(tip);
                _this._app.logAction(beachParty.Gesture.click, "insightActionIcon", beachParty.ElementType.button, beachParty.Action.adjust, beachParty.Target.insight, false, { action: action }, true);
            });
            picker.openWithoutOverlap(rc.left + 15, rc.top + 15, null, null);
            //---- cancel event to prevent LOAD of this icon ----
            vp.events.cancelEventBubble(e);
            vp.events.cancelEventDefault(e);
        };
        insightMgrClass.prototype.createLoadActionMenu = function (callback) {
            var menuItems = [];
            menuItems.push(new beachParty.MenuItemData("All", "Change this into a full (data + view) loading insight", beachParty.fnInsightFull));
            menuItems.push(new beachParty.MenuItemData("Data", "Change this into a data loading insight", beachParty.fnInsightData));
            menuItems.push(new beachParty.MenuItemData("View", "Change this into a view loading insight", beachParty.fnInsightView));
            menuItems.push(new beachParty.MenuItemData("Selection", "Change this into a selection loading insight", beachParty.fnInsightSelection));
            menuItems.push(new beachParty.MenuItemData("Filter", "Change this into a filter loading insight", beachParty.fnInsightFilter));
            var picker = this._app.createGeneralPicker(null, "loadActionPicker", menuItems, callback, undefined, 28);
            return picker;
        };
        insightMgrClass.prototype.getIconUrl = function (loadAction) {
            var url;
            if (loadAction == beachParty.LoadAction.all || loadAction === undefined) {
                url = beachParty.fnInsightFull;
            }
            else if (loadAction == beachParty.LoadAction.data) {
                url = beachParty.fnInsightData;
            }
            else if (loadAction == beachParty.LoadAction.view) {
                url = beachParty.fnInsightView;
            }
            else if (loadAction == beachParty.LoadAction.selection) {
                url = beachParty.fnInsightSelection;
            }
            else if (loadAction == beachParty.LoadAction.filter) {
                url = beachParty.fnInsightFilter;
            }
            return url;
        };
        insightMgrClass.prototype.rebuildInsightBar = function () {
            var forceShow = this._forceShow;
            this._forceShow = false;
            this._insightEntryElems = [];
            var insightBarW = vp.select("#insightList")
                .clear();
            for (var i = 0; i < this._session.insights.length; i++) {
                var insight = this._session.insights[i];
                this.addInsightToBar(insight);
            }
            //---- open the bar, if requested ----
            if (forceShow) {
                vp.select("#insightPanel")
                    .css("display", ""); // show it
                this._isShowingInsightsPanel = true;
            }
            //---- always layout screen, in case the horizontal scrollbar just appeared/disappeared ----
            //this.layoutScreen();
            //this.onDataChanged("layout");
        };
        insightMgrClass.fileExt = ".insights";
        return insightMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.insightMgrClass = insightMgrClass;
    var InsightSession = (function () {
        function InsightSession() {
            this.version = 1.0;
            this.insights = [];
        }
        return InsightSession;
    }());
    beachParty.InsightSession = InsightSession;
})(beachParty || (beachParty = {}));
//function myCustomSetupContent(editor_id, body, doc)
//{
//    vp.select(body).css('background', 'green');
//}
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    slicerControl.ts - control to filter records based on a histogram of a column.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** we are a control created by jsonPanelClass.  we are hosted in a panel. */
    var slicerControlClass = (function (_super) {
        __extends(slicerControlClass, _super);
        function slicerControlClass(app, panel) {
            var _this = this;
            _super.call(this);
            this._buildTimer = null;
            //---- search context ----
            this._minValue = null;
            //_panel: jsonPanelClass;
            this._selectedBinIndex = null;
            this._rowElements = [];
            this._updateRowAfterBuild = false;
            this._tagDelimiter = beachParty.TagDelimiter.none;
            this._app = app;
            //this._panel = panel;
            var root = document.createElement("div");
            this._root = root;
            //panel.applyAppPanelOpacity();
            //---- build slicer control ----
            vp.select(root)
                .addClass("slicerControl");
            var rootW = vp.select(root);
            //---- add control bar at top ----
            this.buildTopBar(rootW);
            var histoHolderW = rootW.append("div")
                .addClass("histogramHolder")
                .css("overflow-y", "auto")
                .css("overflow-x", "hidden")
                .css("padding-right", "20px");
            this._histoHolder = histoHolderW[0];
            //---- add slider root, for when we a hold numeric column ----
            var sliderW = histoHolderW.append("span")
                .addClass("slicerSlider")
                .css("position", "relative");
            this._slider = sliderW[0];
            var histogramW = histoHolderW.append("table")
                .css("width", "100%")
                .attr("cellSpacing", "0")
                .addClass("histogram")
                .attach("mousedown", function (e) {
                //---- pass focus to our root, so keyboard thru records works correctly ----
                setTimeout(function (e) { return _this._root.focus(); }, 100);
            });
            this._histogram = histogramW[0];
            this.markBuildNeeded();
            this.quickLayout();
        }
        slicerControlClass.prototype.tagDelimiter = function (value) {
            if (arguments.length == 0) {
                return this._tagDelimiter;
            }
            if (value != this._tagDelimiter) {
                this._tagDelimiter = value;
                this.onDataChanged("tagDelimiter");
                this._delimiterPicker.value(beachParty.TagDelimiter[value]);
            }
        };
        slicerControlClass.prototype.buildTopBar = function (rootW) {
            var _this = this;
            var barW = rootW.append("div")
                .addClass("slicerControlBar")
                .css("position", "relative")
                .css("top", "0px")
                .css("margin-bottom", "8px");
            //---- add column picker ----
            var colPickerValues = this._app.getMappingCols(false);
            var colPickerStrings = colPickerValues.map(function (md) { return md.text; });
            var colPicker = new beachParty.pickerClass(this._app, barW[0], null, colPickerStrings, "None", "Select a column for populating data slicer bars", true, 20);
            this._colPicker = colPicker;
            vp.select(colPicker.getRoot()).css("margin-right", "20px");
            colPicker.registerForChange("value", function (e) {
                var itemText = colPicker.value();
                _this.colName(itemText);
            });
            //---- add TAG DELIMITER picker ----
            var tdValues = beachParty.pickerClass.buildStringsFromEnum(beachParty.TagDelimiter);
            var tdPicker = new beachParty.pickerClass(this._app, barW[0], "Tag:", tdValues, "None", "For TAG columns, specify the tag delimiter", true);
            this._delimiterPicker = tdPicker;
            vp.select(tdPicker.getRoot()).css("float", "right");
            tdPicker.registerForChange("value", function (e) {
                var itemText = tdPicker.value();
                var td = beachParty.TagDelimiter[itemText.toLowerCase()];
                _this.tagDelimiter(td);
            });
        };
        slicerControlClass.prototype.refreshColPickList = function () {
            var colPickerValues = this._app.getMappingCols(false);
            var colPickerStrings = colPickerValues.map(function (md) { return md.text; });
            this._colPicker.values(colPickerStrings);
        };
        /** property for setting the selected value in the UI when the control is loaded with data. */
        slicerControlClass.prototype.selectedValue = function (value) {
            if (arguments.length == 0) {
                return this._minValue;
            }
            this._minValue = value;
            //---- need to update the selected row ----
            if ((this._binResult) && (this._binResult.colName == this._colName) && (this._rowElements.length)) {
                this.setSelectedBinIndexFromValue(value);
            }
            else {
                this._updateRowAfterBuild = true;
            }
            this.onDataChanged("selectedValue");
        };
        slicerControlClass.prototype.setSelectedBinIndexFromValue = function (value) {
            this.updateSelectedRow(null);
            if (!this._isCategory) {
                var numVal = +value;
            }
            var bins = this._binResult.bins;
            for (var i = 0; i < bins.length; i++) {
                var bin = bins[i];
                if (this._isCategory) {
                    if (bin.name == value) {
                        this.updateSelectedRow(this._rowElements[i]);
                        break;
                    }
                }
                else {
                    var numBin = bin;
                    if (numVal >= numBin.min && numVal <= numBin.max) {
                        this.updateSelectedRow(this._rowElements[i]);
                        break;
                    }
                }
            }
        };
        slicerControlClass.prototype.markBuildNeeded = function () {
            var _this = this;
            if (!this._buildTimer) {
                this._buildTimer = setTimeout(function (e) { return _this.buildHistogram(); }, 100);
            }
        };
        slicerControlClass.prototype.getRootElem = function () {
            return this._root;
        };
        slicerControlClass.prototype.onResize = function (width, height) {
            this.quickLayout();
            //this.markBuildNeeded();
        };
        slicerControlClass.prototype.quickLayout = function () {
            var rc = vp.select(this._root).getBounds(false);
            var height = (rc.height) ? rc.height : 270; // window.innerHeight * .8;
            var hh = Math.max(25, height - 40);
            //---- quick layout ----
            vp.select(this._histoHolder)
                .css("height", hh + "px");
            this._holderHeight = hh;
            vp.utils.debug("quickLayout: height set=" + hh);
        };
        slicerControlClass.prototype.close = function () {
            vp.select(this._root)
                .remove();
        };
        slicerControlClass.prototype.slicerData = function (value) {
            if (arguments.length == 0) {
                return this._binResult;
            }
            this._binResult = value;
            this._isCategory = (value && value.bins.length && value.bins[0].min === undefined);
            this.markBuildNeeded();
            this.refreshColPickList();
            this.onDataChanged("slicerData");
        };
        slicerControlClass.prototype.colName = function (value) {
            if (arguments.length == 0) {
                return this._colName;
            }
            if (this._colName != value) {
                this._colName = value;
                this._selectedBinIndex = null;
                this.markBuildNeeded();
                //---- reset delimiter when column changes ----
                if (this._tagDelimiter != beachParty.TagDelimiter.none) {
                    this.tagDelimiter(beachParty.TagDelimiter.none);
                }
                this.onDataChanged("slicerColName");
            }
        };
        slicerControlClass.prototype.getSearchParams = function () {
            return this._searchParams;
        };
        slicerControlClass.prototype.buildNumericSliders = function () {
            var sliderBoxW = vp.select(this._slider)
                .css("height", this._holderHeight + "px")
                .css("width", "30px")
                .css("background", "green");
            var lineHeight = this._holderHeight - 8;
            var minLineW = sliderBoxW.append("span")
                .css("width", "1px")
                .css("height", lineHeight + "px")
                .css("background", "red")
                .css("margin-left", "8px")
                .css("margin-right", "12px");
            var maxLineW = sliderBoxW.append("span")
                .css("width", "1px")
                .css("height", lineHeight + "Px")
                .css("background", "red")
                .css("margin-right", "8px");
            var minNibW = sliderBoxW.append("span")
                .css("width", "7px")
                .css("height", "7px")
                .css("background", "green")
                .css("position", "absolute")
                .css("left", "5px")
                .css("top", "5px");
            var maxNibW = sliderBoxW.append("span")
                .css("width", "7px")
                .css("height", "7px")
                .css("background", "green")
                .css("position", "absolute")
                .css("left", "16px")
                .css("top", "5px");
        };
        slicerControlClass.prototype.getMaxCount = function (result) {
            var maxCount = 0;
            for (var i = 0; i < result.bins.length; i++) {
                maxCount = Math.max(maxCount, result.bins[i].count);
            }
            return maxCount;
        };
        slicerControlClass.prototype.buildHistogram = function () {
            var _this = this;
            this._buildTimer = null;
            this._rowElements = [];
            //---- update column picker name ----
            this._colPicker.value(this._colName);
            vp.select(this._slider)
                .clear();
            var isCategory = this._isCategory;
            if (!isCategory) {
            }
            var histogramW = vp.select(this._histogram)
                .clear();
            var binResult = this._binResult;
            if (binResult && binResult.bins.length) {
                var binCount = binResult.bins.length;
                var maxCount = this.getMaxCount(binResult);
                var height = vp.select(this._root).height();
                var barHeight = 16; // approx text height of binName
                var width = vp.select(this._root).width();
                if (width == 0) {
                    //---- default width for panels whose size is still floating ----
                    width = 300;
                }
                var maxBarWidth = width / 2;
                var barWidthFactor = maxBarWidth / maxCount;
                for (var c = 0; c < binCount; c++) {
                    var bin = binResult.bins[c];
                    var binName = bin.name;
                    var count = bin.count;
                    var minWidth = 10; // all bars are at least this wide (10%) (so they are clickable)
                    var barWidth = minWidth + count / maxCount * 90;
                    var binValue = binName;
                    var rowW = histogramW.append("tr")
                        .addClass("histogramRow");
                    if (c == this._selectedBinIndex) {
                        rowW.css("background", "#444");
                    }
                    else {
                        rowW.css("background", "none");
                    }
                    var displayName = (binName == "") ? this._app._blankValueStr : binName;
                    //---- bin NAME td ----
                    var binNameW = rowW.append("td")
                        .addClass("histogramBinName")
                        .css("width", "1px") // make name col as small as possible
                        .css("white-space", "nowrap")
                        .text(displayName)
                        .attach("click", function (e) { return _this.selectFromRow(e.target.parentElement); });
                    //---- bin BAR td ----
                    var tdW = rowW.append("td")
                        .css("min-width", "60px");
                    //---- actual bar must be in a separate div ----
                    var valueElemW = tdW.append("div")
                        .addClass("histogramBinBar")
                        .css("height", barHeight + "px")
                        .css("width", barWidth + "%")
                        .title(vp.formatters.comma(count) + " records")
                        .attach("click", function (e) { return _this.selectFromRow(e.target.parentElement.parentElement); });
                    //utils.prepWithBinDirect(rowW[0], this._colName, isCategory, bin, "histoBar");
                    this._rowElements.push(rowW[0]);
                }
            }
            if (this._updateRowAfterBuild) {
                this.setSelectedBinIndexFromValue(this._minValue);
                this._updateRowAfterBuild = false;
            }
        };
        slicerControlClass.prototype.updateSelectedRow = function (rowElem) {
            if (this._selectedBinIndex > -1 && this._selectedRowElem) {
                vp.dom.css(this._selectedRowElem, "background", "none");
            }
            this._selectedBinIndex = (rowElem) ? rowElem.binIndex : -1;
            this._selectedRowElem = (rowElem) ? rowElem : null;
            if (this._selectedBinIndex > -1) {
                vp.dom.css(this._selectedRowElem, "background", "#444");
            }
        };
        slicerControlClass.prototype.selectFromRow = function (rowElem) {
            this._searchParams = rowElem._searchParams;
            this._minValue = this._searchParams.minValue;
            this.updateSelectedRow(rowElem);
            this.onDataChanged("selectedValue");
        };
        return slicerControlClass;
    }(beachParty.baseAppControlClass));
    beachParty.slicerControlClass = slicerControlClass;
    function createSlicer(app, panel) {
        return new slicerControlClass(app, panel);
    }
    beachParty.createSlicer = createSlicer;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    detailsPanelMgr.ts - panel mgr to view records one at a time, and to select the values.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    var detailsPanelMgrClass = (function (_super) {
        __extends(detailsPanelMgrClass, _super);
        function detailsPanelMgrClass(app, buttonName) {
            _super.call(this);
            this._recordCount = 0;
            this._selectedColName = "";
            this._selectedValue = "";
            this._unsortedColInfos = null;
            this._colInfos = null;
            this._rowElemByColName = {};
            this._selectedColIndex = null; // current column name/value selected by user in our displayed list of columns/values
            this._lastPercent = {};
            //_rebuildTimer = null;
            this._isSizeLocked = true;
            this._recordLayoutCount = 0;
            this._isClosing = false;
            this._rebuildTimer = null;
            this._app = app;
        }
        detailsPanelMgrClass.prototype.scheduleRebuild = function () {
            var _this = this;
            if (!this._rebuildTimer) {
                this._rebuildTimer = setTimeout(function (e) { return _this.rebuildPanel(); }, 100);
            }
        };
        detailsPanelMgrClass.prototype.rebuildPanel = function () {
            this.clearRebuldTimer();
            if (this._jsonPanel) {
                this._currentRecordIndex = 0;
                this._primaryKey = -1;
                this.lockCurrentPanelSize(false);
                var chart = this._app.currentChart();
                this.colInfos(chart.getColInfos());
                this.updateAttrPanel(this._jsonPanel);
            }
        };
        detailsPanelMgrClass.prototype.formatValue = function (colInfo, value) {
            var str = "";
            if (colInfo.colType == "date") {
                str = vp.formatters.formatDateTime(value, "m/dd/yyyy");
            }
            else if (colInfo.colType == "number") {
                str = vp.formatters.comma(value);
            }
            else {
                //---- string ----
                str = value + "";
            }
            return str;
        };
        detailsPanelMgrClass.prototype.buildOverview = function (root) {
            //---- create table of column info ----
            var chart = this._app._chartRouter.getChart();
            var colInfos = chart.getColInfos();
            var rootW = vp.select(root).clear();
            var divW = rootW.append("div")
                .css("overflow-y", "auto");
            var tableW = divW.append("table")
                .addClass("colTable");
            var rowW = tableW.append("tr");
            //---- NAME ----
            var tdW = rowW.append("th")
                .addClass("colHdr")
                .text("ColName");
            //---- TYPE ----
            var tdW = rowW.append("th")
                .addClass("colHdr")
                .text("Type");
            //---- MIN ----
            var tdW = rowW.append("th")
                .addClass("colHdr")
                .css("text-align", "right")
                .text("Min");
            //---- MAX ----
            var tdW = rowW.append("th")
                .addClass("colHdr")
                .css("text-align", "right")
                .text("Max");
            //---- KeyCount ----
            var tdW = rowW.append("th")
                .addClass("colHdr")
                .css("text-align", "right")
                .text("KeyCount");
            //---- NAN COUNT ----
            var tdW = rowW.append("th")
                .addClass("colHdr")
                .css("text-align", "right")
                .text("NanCount");
            var includeSys = false;
            for (var i = 0; i < colInfos.length; i++) {
                var colInfo = colInfos[i];
                if (colInfo.name.startsWith("_") && !includeSys) {
                    continue;
                }
                var rowW = tableW.append("tr");
                var stats = colInfo.stats;
                //---- NAME ----
                var tdW = rowW.append("td")
                    .addClass("colValue")
                    .text(colInfo.name);
                //---- TYPE ----
                var tdW = rowW.append("td")
                    .addClass("colValue")
                    .text(colInfo.colType);
                //---- format ROW VALUES ----
                var isString = (stats.sortedKeys != null);
                var minStr = (isString) ? "" : this.formatValue(colInfo, stats.min);
                var maxStr = (isString) ? "" : this.formatValue(colInfo, stats.max);
                var countStr = (isString) ? vp.formatters.comma(stats.sortedKeys.length) : "";
                var nanCountStr = (stats.nanCount == 0) ? "" : vp.formatters.comma(stats.nanCount);
                //---- MIN ----
                var tdW = rowW.append("td")
                    .addClass("colValue")
                    .css("text-align", "right")
                    .text(minStr);
                //---- MAX ----
                var tdW = rowW.append("td")
                    .addClass("colValue")
                    .css("text-align", "right")
                    .text(maxStr);
                //---- KEY COUNT ----
                var tdW = rowW.append("td")
                    .addClass("colValue")
                    .css("text-align", "right")
                    .text(countStr);
                //---- NAN COUNT ----
                var tdW = rowW.append("td")
                    .addClass("colValue")
                    .css("text-align", "right")
                    .text(nanCountStr);
            }
        };
        detailsPanelMgrClass.prototype.buildContent = function (jsonPanel) {
            var _this = this;
            var contentRoot = jsonPanel.getTabContentRoot("tab0");
            this._root = contentRoot;
            this._jsonPanel = jsonPanel;
            this._isClosing = false;
            var rootW = vp.select(contentRoot).clear();
            this.lockCurrentPanelSize(false);
            //---- find out which tabs are OK to show user ----
            var showTabs = this._app._appSettingsMgr.showInProgressUI();
            jsonPanel.showTab("tab1", showTabs); // grid
            //jsonPanel.showTab("tab2", showTabs);      // always show "overview"
            jsonPanel.showTab("tab3", showTabs); // annotations
            var divW = rootW.append("div")
                .addClass("recordView")
                .attr("tabIndex", 0) // allow it to accept focus
                .attach("keydown", function (e) { return _this.onKeyDown(e); })
                .css("min-height", "30px"); // must be able to read "no records selected" at the min
            this._currentRecordIndex = 0;
            this._primaryKey = -1;
            jsonPanel.showTitle(true);
            //---- add control bar at top ----
            this.buildNavPanel(divW);
            var maxPanelHeight = beachParty.appClass.maxPanelHeight;
            var maxListHeight = maxPanelHeight - 96; // for controls above list
            //---- LIST of field/value/search (as table) ----
            var tableHolderW = divW.append("div")
                .css("overflow-x", "hidden")
                .css("overflow-y", "auto");
            var listW = tableHolderW.append("table")
                .addClass("rvList")
                .attr("cellSpacing", "0")
                .css("min-width", "150px") // match min-width of panel, so resizing doesn't look wierd
                .css("padding", "6px")
                .css("margin", "6px")
                .css("margin-right", "30px") // bing icon getting cut off???
                .css("margin-top", "-10px");
            listW
                .attach("mousedown", function (e) {
                //---- pass focus to our root, so keyboard thru records works correctly ----
                setTimeout(function (e) { return _this._root.focus(); }, 100);
            });
            this._listElem = listW[0];
            var app = this._app;
            this.refeshRecordInfo(true);
            //---- set focus to panel so it can immediately respond to pageup, etc. ----
            divW[0].focus();
        };
        detailsPanelMgrClass.prototype.onDataSelectionChanged = function () {
            if (this._jsonPanel) {
                var chart = this._app.currentChart();
                var dataMgr = chart.getDataMgr();
                var selectedCount = dataMgr.getSelectedCount();
                this.refeshRecordInfo(false);
                if (selectedCount > 0) {
                }
                else {
                    //---- jump to first selected record, if any ----
                    if (selectedCount > 0) {
                        var selectedKeys = dataMgr.getPrimaryKeys(true, true);
                        var primaryKey = selectedKeys[0];
                        var recordIndex = this._pkVector.indexOf(primaryKey);
                        this.goto(recordIndex);
                    }
                }
            }
        };
        detailsPanelMgrClass.prototype.refeshRecordInfo = function (refreshColInfo) {
            var chart = this._app.currentChart();
            var dataMgr = chart.getDataMgr();
            var dataFrame = dataMgr.getDataFrame();
            if (refreshColInfo) {
                var colInfos = chart.getColInfos();
                this.colInfos(colInfos);
            }
            var selectionExists = (dataMgr.getSelectedCount() > 0);
            var keys = dataMgr.getPrimaryKeys(selectionExists, true);
            this._dataFrame = dataFrame;
            this.primaryKeys(keys);
            this.rebuildRecordValues();
        };
        detailsPanelMgrClass.prototype.onClose = function () {
            this._jsonPanel = null;
            this._root = null;
            this._isClosing = true;
            var app = this._app;
            app.unregisterForChanges(this, "close");
            app.unregisterForChanges(this, "dataFrame");
            app.unregisterForChanges(this, "selected");
            app.unregisterForChanges(this, "filtered");
            //---- hide hover shape when details is closed ----
            app.currentChart().hoverPrimaryKey(null);
        };
        detailsPanelMgrClass.prototype.buildNavPanel = function (parentW) {
            var _this = this;
            var navW = parentW.append("div")
                .addClass("flexColumns flexSpace rvControlBar")
                .css("margin", "4px 10px 0 10px");
            //---- RECORD TEXT ----
            var recordTextW = navW.append("div")
                .addClass("flexAuto rvRecordText");
            //---- BUTTONS----
            var buttonsW = navW.append("div")
                .addClass("flexAuto");
            //---- LEFT button ----
            var prevW = buttonsW.append("img")
                .addClass("clickIcon rvImgButton")
                .id("btPrev")
                .css("width", "24px")
                .css("height", "24px")
                .title("View the next record")
                .attach("click", function (e) {
                _this.goto(_this._currentRecordIndex - 1);
                vp.events.cancelEventBubble(e);
                vp.events.cancelEventDefault(e);
            });
            beachParty.setIconName(this._app._themeMgr, prevW[0], beachParty.fnDetailsPrev);
            //---- RIGHT button ----
            var nextW = buttonsW.append("img")
                .addClass("clickIcon rvImgButton")
                .id("btNext")
                .css("width", "24px")
                .css("height", "24px")
                .title("View the previous record")
                .attach("click", function (e) {
                _this.goto(_this._currentRecordIndex + 1);
                vp.events.cancelEventBubble(e);
                vp.events.cancelEventDefault(e);
            });
            beachParty.setIconName(this._app._themeMgr, nextW[0], beachParty.fnDetailsNext);
            this._recordText = recordTextW[0];
            this._buttonsElem = buttonsW[0];
            beachParty.matchIconsToTheme(this._app._themeMgr, this._root);
        };
        detailsPanelMgrClass.prototype.getRecordIndex = function (ssIndex) {
            var recordIndex = -1;
            if (this._pkVector && ssIndex >= 0 && ssIndex < this._pkVector.length) {
                recordIndex = +this._pkVector[ssIndex];
            }
            return recordIndex;
        };
        detailsPanelMgrClass.prototype.goto = function (recordIndex) {
            var count = this._recordCount;
            recordIndex = Math.max(0, recordIndex);
            recordIndex = Math.min(count - 1, recordIndex);
            this._currentRecordIndex = recordIndex;
            this._primaryKey = this.getRecordIndex(recordIndex);
            this.rebuildRecordValues();
        };
        detailsPanelMgrClass.prototype.selectedColName = function (value) {
            if (arguments.length == 0) {
                return this._selectedColName;
            }
            this._selectedColName = value;
            this.onDataChanged("selectedColName");
        };
        detailsPanelMgrClass.prototype.onKeyDown = function (e) {
            if (e.keyCode == vp.events.keyCodes.pageDown) {
                this.goto(this._currentRecordIndex + 1);
                vp.events.cancelEventBubble(e);
            }
            else if (e.keyCode == vp.events.keyCodes.pageUp) {
                this.goto(this._currentRecordIndex - 1);
                vp.events.cancelEventBubble(e);
            }
            else if (e.keyCode == vp.events.keyCodes.home) {
                this.goto(0);
                vp.events.cancelEventBubble(e);
            }
            else if (e.keyCode == vp.events.keyCodes.end) {
                var count = this._recordCount;
                this.goto(count);
                vp.events.cancelEventBubble(e);
            }
        };
        detailsPanelMgrClass.prototype.getSelectedIndex = function (ri) {
            var ssIndex = -1;
            if (this._pkVector) {
                for (var i = 0; i < this._pkVector.length; i++) {
                    var riValue = +this._pkVector[i];
                    if (riValue == ri) {
                        ssIndex = i;
                        break;
                    }
                }
            }
            return ssIndex;
        };
        /** this is called (indirectly from app) when app.selectedRecords changes. */
        detailsPanelMgrClass.prototype.primaryKeys = function (value) {
            if (arguments.length == 0) {
                return this._pkVector;
            }
            this._pkVector = value;
            this._recordCount = (value) ? value.length : 0;
            //---- hide hover shape until a new valid key is established ----
            this._app.currentChart().hoverPrimaryKey(null);
            //---- try to maintain the current record (based on _primaryKey column value) ----
            this._currentRecordIndex = this.getSelectedIndex(this._primaryKey);
            if (this._currentRecordIndex == -1) {
                this._currentRecordIndex = 0;
                this._primaryKey = this.getRecordIndex(0);
            }
            var colCount = vp.utils.keys(this._rowElemByColName).length;
            if (colCount > 0) {
                this.rebuildRecordValues();
            }
            else {
                this.rebuildColTable();
            }
            this.onDataChanged("records");
        };
        detailsPanelMgrClass.prototype.colInfos = function (value) {
            if (arguments.length == 0) {
                return this._unsortedColInfos;
            }
            this._unsortedColInfos = value;
            this.onColInfosChanged();
        };
        detailsPanelMgrClass.prototype.onColInfosChanged = function () {
            var value = this._unsortedColInfos;
            var sortCols = this._app._appSettingsMgr.isColDetailsSorted();
            if (sortCols) {
                if (value) {
                    value = value.orderByStr(function (ci) { return ci.name; });
                }
            }
            this._colInfos = value;
            this.rebuildColTable();
            this.onDataChanged("colInfos");
        };
        detailsPanelMgrClass.prototype.selectRowAndSearch = function (e) {
            var valueElem = null;
            var rowElem = null;
            //---- only allow elem with class=rvValue or TD as valid targets for this event ----
            var elem = e.target;
            if (vp.select(elem).hasClass("rvValue")) {
                valueElem = elem;
                rowElem = elem.parentElement.parentElement;
            }
            else if (elem instanceof HTMLTableCellElement) {
                valueElem = elem.firstChild;
                rowElem = elem.parentElement;
            }
            if (valueElem) {
                this.selectRowFromParent(rowElem);
                if (valueElem.rawValue !== undefined) {
                    //---- for numeric values, use the raw (unformatted) value ----
                    this._selectedValue = valueElem.rawValue;
                }
                else {
                    this._selectedValue = vp.select(valueElem).text();
                }
                //this.onDataChanged("selectedValue");
                this._app.doSearch("Details", this._selectedColName, this._selectedValue, null, beachParty.TextSearchType.exactMatch, beachParty.SelectMode.normal);
            }
        };
        detailsPanelMgrClass.prototype.selectRowFromParent = function (elem) {
            this._selectedColIndex = elem.colIndex;
            this.selectedColName(elem.colName);
            this.rebuildRecordValues();
        };
        detailsPanelMgrClass.prototype.getSelectedValue = function () {
            return this._selectedValue;
        };
        detailsPanelMgrClass.prototype.rebuildColTable = function () {
            var _this = this;
            var listW = vp.select(this._listElem)
                .clear();
            this._rowElemByColName = {};
            if (this._recordCount) {
                if (this._colInfos) {
                    var colInfos = this._colInfos;
                    for (var c = 0; c < colInfos.length; c++) {
                        var ci = colInfos[c];
                        //---- add column ----
                        var colName = ci.name;
                        var tip = ci.desc;
                        if (!colName.startsWith("_")) {
                            //var value = "";
                            var rowW = listW.append("tr")
                                .addClass("recordViewRow");
                            //---- limit length of string in tooltip ----
                            var tipText = beachParty.appUtils.clipTextForTitle(colName);
                            //---- COLNAME td ----
                            var colNameW = rowW.append("td")
                                .addClass("rvColName clipText")
                                .text(colName)
                                .title(tipText)
                                .css("width", "5px") // relative width (see value td)
                                .attach("click", function (e) { return _this.selectRowFromParent(e.target.parentElement); });
                            //---- VALUE td ----
                            var valueElemW = rowW.append("td")
                                .css("width", "20px") // relative width (see colName td)
                                .css("white-space", "nowrap")
                                .attach("click", function (e) { return _this.selectRowAndSearch(e); });
                            valueElemW.append("div")
                                .addClass("rvValue clipText");
                            //.text(value)          // text is set in rebuildRecordValues()
                            //---- BING td ----
                            var tdW = rowW.append("td");
                            var bingW = tdW.append("img")
                                .addClass("clickIcon bingImg")
                                .attach("click", function (e) { return _this.selectRowAndBingSearch(e); })
                                .attr("src", "images/bing4.png")
                                .css("display", "none")
                                .css("margin-top", "1px")
                                .css("margin-right", "10px")
                                .title("Search for this value in Bing")
                                .attach("dragstart", function (e) {
                                //---- prevent drag of icon ----
                                e.preventDefault();
                            });
                            rowW[0].colIndex = c;
                            rowW[0].colName = colName;
                            rowW[0].minValue = ci.stats.min;
                            rowW[0].maxValue = ci.stats.max;
                            rowW[0].bingElem = bingW[0];
                            //rowW[0].numSpreadElem = numSpreadW[0];
                            //rowW[0].numSpreadParent = numSpreadParentW[0];
                            rowW[0].valueElem = valueElemW[0];
                            this._rowElemByColName[colName] = rowW[0];
                        }
                    }
                }
            }
            this.rebuildRecordValues();
            beachParty.matchIconsToTheme(this._app._themeMgr, this._root);
        };
        detailsPanelMgrClass.prototype.openNumSpreader = function (rowParent, numSpreadParent) {
            var _this = this;
            var chartRouter = this._app._chartRouter;
            var value = rowParent.valueElem.textContent;
            var initialPercent = this._lastPercent[this._selectedColName];
            if (initialPercent === undefined) {
                initialPercent = 5;
            }
            this._numSpreader = new beachParty.numSpreaderClass(chartRouter, this._selectedColName, +value, rowParent.minValue, rowParent.maxValue, numSpreadParent, initialPercent, function (colName, minValue, maxValue, searchType, percent) {
                //this._isSearchFromNumSpreader = true;
                var selectMode = beachParty.SelectMode.normal;
                _this._app.doSearch("Details", colName, minValue, maxValue, searchType, selectMode);
                //this._isSearchFromNumSpreader = false;
                _this._lastPercent[_this._selectedColName] = percent;
            });
        };
        detailsPanelMgrClass.prototype.closeNumSpreader = function () {
            if (this._numSpreader) {
                this._numSpreader.close();
                this._numSpreader = null;
            }
        };
        detailsPanelMgrClass.prototype.rebuildRecordValues = function () {
            if (true) {
                this.closeNumSpreader();
            }
            var recordCount = this._recordCount;
            var index = this._currentRecordIndex + 1;
            var msg = "Record " + index + " (of " + recordCount + ")";
            var listDisp = "block";
            if (recordCount == 0) {
                msg = "<no records found>";
                listDisp = "none";
            }
            //---- hide left/right buttons if no records are selected ----
            vp.select(this._buttonsElem).css("display", (recordCount == 0) ? "none" : "");
            vp.select(this._recordText)
                .text(msg);
            var listW = vp.select(this._listElem)
                .css("display", listDisp);
            if (this._recordCount) {
                var ri = this._currentRecordIndex;
                if (ri >= 0 && ri < this._recordCount && this._colInfos) {
                    var primaryKey = this._pkVector[ri];
                    var record = this._dataFrame.getRecordByPrimaryKey(primaryKey);
                    var colInfos = this._colInfos;
                    for (var c = 0; c < colInfos.length; c++) {
                        var ci = colInfos[c];
                        var colName = ci.name;
                        var colType = ci.colType;
                        if (!colName.startsWith("_")) {
                            var value = record[colName];
                            var rowElem = this._rowElemByColName[colName];
                            if (rowElem) {
                                var nameElem = rowElem.childNodes[0];
                                var valueElem = rowElem.childNodes[1].firstChild;
                                //var numSpreadParent = rowElem.childNodes[2];
                                //var numSpreadElem = rowElem.childNodes[3].firstChild;
                                var bingElem = rowElem.childNodes[2].firstChild;
                                if (c == this._selectedColIndex) {
                                    vp.dom.attr(rowElem, "data-selected", "true"); // "background", "#444");
                                    //vp.dom.css(numSpreadElem, "display", "none")    //  (colType == "number") ? "" : "none");
                                    //---- show/hide BING element ----
                                    vp.dom.css(bingElem, "display", (colType == "string") ? "" : "none");
                                    if (colType == "number") {
                                        this.openNumSpreader(rowElem, rowElem.childNodes[1]);
                                    }
                                }
                                else {
                                    //vp.dom.css(rowElem, "background", "none")
                                    vp.dom.attr(rowElem, "data-selected", "false");
                                    //vp.dom.css(numSpreadElem, "display", "none");
                                    vp.dom.css(bingElem, "display", "none");
                                }
                                //---- limit length of string in tooltip ----
                                var tipText = beachParty.appUtils.clipTextForTitle(value);
                                //---- VALUE td ----
                                vp.select(valueElem)
                                    .text(value)
                                    .title(tipText);
                            }
                        }
                    }
                    if (!this._isClosing) {
                        //var primaryKey = record["_primaryKey"];
                        this._app.currentChart().hoverPrimaryKey(primaryKey);
                    }
                }
            }
            if (!this._isSizeLocked && recordCount > 0 && this._recordLayoutCount > 0) {
                this.lockCurrentPanelSize(true);
            }
            this._recordLayoutCount++;
        };
        /**
         * Lock down this size so panel doesn't resize with each record.
         */
        detailsPanelMgrClass.prototype.lockCurrentPanelSize = function (value) {
            var jsonPanel = this._jsonPanel;
            var jsonRoot = jsonPanel.getRootElem();
            //---- remove width/height on elements to get true measurements  ----
            vp.select(jsonRoot) // this._root, ".recordView")
                .css("width", "")
                .css("height", "")
                .css("min-width", "")
                .css("min-height", "");
            this._isSizeLocked = value;
            if (value) {
                //vp.select(this._listElem)
                //    .css("width", "")
                //    .css("height", "")
                //    .css("max-width", "")
                //    .css("max-height", "")
                //---- get size of resizeTarget ----
                var rc = vp.dom.getBounds(jsonRoot); // this._listElem);
                ////---- limit it to 75% of available space ----
                //var width = Math.min(.75 * innerWidth, rc.width + 10);
                //var height = Math.min(.75 * innerHeight, rc.height);
                var minWidth = jsonRoot.style.minWidth;
                var minHeight = jsonRoot.style.minHeight;
                var width = (minWidth) ? Math.max(parseFloat(minWidth), rc.width) : rc.width;
                var height = (minHeight) ? Math.max(parseFloat(minHeight), rc.height) : rc.height;
                vp.utils.debug("lockCurrentPanelSize: width=" + width + ", height=" + height);
                jsonPanel.changePanelSize(width, height);
            }
            else {
                vp.utils.debug("lockCurrentPanelSize: value=false");
            }
        };
        detailsPanelMgrClass.prototype.selectRowAndBingSearch = function (e) {
            var parent = e.target.parentElement.parentElement;
            this.selectRowFromParent(parent);
            var searchTerm = parent.valueElem.textContent;
            if (searchTerm.toLowerCase().startsWith("http://")) {
                window.open(searchTerm, "_blank");
            }
            else {
                window.open("http://www.bing.com/search?q=" + searchTerm, "_blank");
            }
        };
        detailsPanelMgrClass.prototype.layoutPanel = function (maxWidth, maxHeight) {
            this.lockInValueWidth();
        };
        /**
         * We do this so that the value text gets clipped (as per clipText class) ----
         */
        detailsPanelMgrClass.prototype.lockInValueWidth = function () {
            var rcList = vp.dom.getBounds(this._listElem);
            var rvW = vp.select(this._listElem, ".rvColName");
            if (rvW.length) {
                var rcName = rvW.getBounds();
                var nameWidth = +rcName.width;
            }
            else {
                var nameWidth = 0;
            }
            var availWidth = rcList.width - (nameWidth + 30); // 30=padding/margin allowances
            //---- LOCK WIDTH for all value elements ----
            vp.select(this._listElem, ".rvValue")
                .css("width", availWidth + "px");
            vp.utils.debug("lockInValueWidth: width set=" + availWidth);
        };
        detailsPanelMgrClass.prototype.clearRebuldTimer = function () {
            if (this._rebuildTimer) {
                clearTimeout(this._rebuildTimer);
                this._rebuildTimer = null;
            }
        };
        /**
         * This is called when a new details Panel is created.
         * @param jsonPanel
         */
        detailsPanelMgrClass.prototype.updateAttrPanel = function (jsonPanel) {
            var _this = this;
            if (!jsonPanel) {
                jsonPanel = this._jsonPanel;
            }
            else {
                this._jsonPanel = jsonPanel;
                var app = this._app;
                app.registerForRemovableChange("selected", this, function (e) {
                    _this.onDataSelectionChanged();
                });
                app.registerForRemovableChange("filter", this, function (e) {
                    _this.refeshRecordInfo(true);
                });
                app.registerForRemovableChange("dataFrame", this, function (e) {
                    //---- if DETAILS panel is open, rebuild it ----
                    if (_this._jsonPanel) {
                        _this.scheduleRebuild();
                    }
                });
                //---- on first use of panel, hook the "close" to keep _jsonPanel current ----
                jsonPanel.registerForChange("close", function (e) {
                    _this._jsonPanel = null;
                });
            }
            //---- hide panel while we build it's controls ----
            jsonPanel.show(false);
            //---- reset "display" so layout calculations can take take place (visibility=hidden) ----
            //vp.select(jsonPanel.getRootElem()).css("display", "");
            jsonPanel.forceTabBuild(2); // overview
            var overviewRoot = jsonPanel.getTabContentRoot("tab2");
            this.buildOverview(overviewRoot);
            this.buildContent(jsonPanel);
            //---- reflect current selection ----
            this.onDataSelectionChanged();
            jsonPanel.show(true);
        };
        return detailsPanelMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.detailsPanelMgrClass = detailsPanelMgrClass;
})(beachParty || (beachParty = {}));
//-------------------------------------------------------------------------------------
//  Copyright (c) 2016 - Microsoft Corporation.
//    undoMgr.ts - manages the UNDO stack for BeachPartyApp.
//-------------------------------------------------------------------------------------
var beachParty;
(function (beachParty) {
    /** this class is designed around an initial app state being pushed after the app init process is complete.  This becomes the
     * permanent _stack[0] entry (which is used to "undo" the first user action).
     */
    var undoMgrClass = (function (_super) {
        __extends(undoMgrClass, _super);
        //_initEntry = null;              // this is an entry created from the initial (and stable) app state 
        function undoMgrClass() {
            _super.call(this);
            this._stack = [];
            this._index = -1;
            this._maxUndoLevels = 10; // keep this low until we can guarantee tiny UndoEntry sizes (right now they get big with selected/filtered vectors)
        }
        undoMgrClass.prototype.getCurrentInsight = function () {
            var index = this._index;
            var insight = (index > -1) ? this._stack[index].insight : null;
            return insight;
        };
        undoMgrClass.prototype.push = function (insight, tooltip) {
            var stack = this._stack;
            var index = this._index;
            if (index < stack.length - 1) {
                //---- running new cmd in middle of a "back" sequence ----
                //---- throw away entries above stack[index] ----
                stack = stack.slice(0, index + 1);
            }
            if (stack.length + 1 > this._maxUndoLevels) {
                //---- too many undo states; must remove oldest entry in stack ----
                stack = stack.slice(1);
            }
            var cmdState = new UndoEntry(insight, tooltip);
            stack.push(cmdState);
            this._index = stack.length - 1;
            this._stack = stack;
            this.onDataChanged("undoStack");
        };
        undoMgrClass.prototype.isUndoAvailable = function () {
            return (this._index > 0);
        };
        undoMgrClass.prototype.getUndoTooltip = function () {
            var tip = "Undo the last action (currently unavailable)";
            if (this._index > 0) {
                var entry = this._stack[this._index];
                tip = "Undo the last action: \r\n" + entry.tooltip;
            }
            return tip;
        };
        undoMgrClass.prototype.undo = function () {
            var entry = null;
            if (this._index > 0) {
                this._index--;
                entry = this._stack[this._index];
                this.onDataChanged("undoStack");
            }
            return entry;
        };
        undoMgrClass.prototype.isRedoAvailable = function () {
            return (this._index < this._stack.length - 1);
        };
        undoMgrClass.prototype.getRedoTooltip = function () {
            var tip = "Redo the previously undone action (currently unavailable)";
            if (this._index < this._stack.length - 1) {
                var entry = this._stack[this._index + 1];
                tip = "Redo the previously undone action:\r\n" + entry.tooltip;
            }
            return tip;
        };
        undoMgrClass.prototype.redo = function () {
            var entry = null;
            if (this._index < this._stack.length - 1) {
                this._index++;
                entry = this._stack[this._index];
                this.onDataChanged("undoStack");
            }
            return entry;
        };
        return undoMgrClass;
    }(beachParty.dataChangerClass));
    beachParty.undoMgrClass = undoMgrClass;
    var UndoEntry = (function () {
        function UndoEntry(insight, tooltip) {
            this.insight = insight;
            this.tooltip = tooltip;
        }
        return UndoEntry;
    }());
    beachParty.UndoEntry = UndoEntry;
})(beachParty || (beachParty = {}));
